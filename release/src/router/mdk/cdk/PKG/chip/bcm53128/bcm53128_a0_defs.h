#ifndef __BCM53128_A0_DEFS_H__
#define __BCM53128_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM53128_A0.
 * This file provides all basic definitions required to program the BCM53128_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CPIC/IMP port */
#define BCM53128_A0_CPIC_PORT           8

/* Additional block types */
#define BCM53128_A0_BLKTYPE_CPIC        0
#define BCM53128_A0_BLKTYPE_EXP         1
#define BCM53128_A0_BLKTYPE_GPIC        2
#define BCM53128_A0_BLKTYPE_SPI         3
#define BCM53128_A0_BLKTYPE_SYS         4


#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM53128_A0_CPIC_PORT

#define BLKTYPE_CPIC                    BCM53128_A0_BLKTYPE_CPIC
#define BLKTYPE_EXP                     BCM53128_A0_BLKTYPE_EXP
#define BLKTYPE_GPIC                    BCM53128_A0_BLKTYPE_GPIC
#define BLKTYPE_SPI                     BCM53128_A0_BLKTYPE_SPI
#define BLKTYPE_SYS                     BCM53128_A0_BLKTYPE_SYS


#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_FWD_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR0 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_FWD_ENTRY0r 0x00000518

#define BCM53128_A0_ARLA_FWD_ENTRY0r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY0.
 *
 */
typedef union BCM53128_A0_ARLA_FWD_ENTRY0r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry0[1];
	uint32_t _arla_fwd_entry0;
} BCM53128_A0_ARLA_FWD_ENTRY0r_t;

#define BCM53128_A0_ARLA_FWD_ENTRY0r_CLR(r) (r).arla_fwd_entry0[0] = 0
#define BCM53128_A0_ARLA_FWD_ENTRY0r_SET(r,d) (r).arla_fwd_entry0[0] = d
#define BCM53128_A0_ARLA_FWD_ENTRY0r_GET(r) (r).arla_fwd_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_FWD_ENTRY0r_PORTIDf_GET(r) (((r).arla_fwd_entry0[0]) & 0x1ff)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_PORTIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET(r) ((((r).arla_fwd_entry0[0]) >> 9) & 0x3)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry0[0]) >> 11) & 0x7)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry0[0]) >> 14) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry0[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 16) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_ARLA_FWD_ENTRY0r_RESERVEDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 17) & 0x7fff)
#define BCM53128_A0_ARLA_FWD_ENTRY0r_RESERVEDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY0.
 *
 */
#define BCM53128_A0_READ_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_FWD_ENTRY0r,(r._arla_fwd_entry0),4)
#define BCM53128_A0_WRITE_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_FWD_ENTRY0r,&(r._arla_fwd_entry0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY0r BCM53128_A0_ARLA_FWD_ENTRY0r
#define ARLA_FWD_ENTRY0r_SIZE BCM53128_A0_ARLA_FWD_ENTRY0r_SIZE
typedef BCM53128_A0_ARLA_FWD_ENTRY0r_t ARLA_FWD_ENTRY0r_t;
#define ARLA_FWD_ENTRY0r_CLR BCM53128_A0_ARLA_FWD_ENTRY0r_CLR
#define ARLA_FWD_ENTRY0r_SET BCM53128_A0_ARLA_FWD_ENTRY0r_SET
#define ARLA_FWD_ENTRY0r_GET BCM53128_A0_ARLA_FWD_ENTRY0r_GET
#define ARLA_FWD_ENTRY0r_PORTIDf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_PORTIDf_GET
#define ARLA_FWD_ENTRY0r_PORTIDf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_PORTIDf_SET
#define ARLA_FWD_ENTRY0r_ARL_CONf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET
#define ARLA_FWD_ENTRY0r_ARL_CONf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY0r_RESERVEDf_GET BCM53128_A0_ARLA_FWD_ENTRY0r_RESERVEDf_GET
#define ARLA_FWD_ENTRY0r_RESERVEDf_SET BCM53128_A0_ARLA_FWD_ENTRY0r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY0r BCM53128_A0_READ_ARLA_FWD_ENTRY0r
#define WRITE_ARLA_FWD_ENTRY0r BCM53128_A0_WRITE_ARLA_FWD_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_FWD_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_FWD_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR1 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_FWD_ENTRY1r 0x00000528

#define BCM53128_A0_ARLA_FWD_ENTRY1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY1.
 *
 */
typedef union BCM53128_A0_ARLA_FWD_ENTRY1r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry1[1];
	uint32_t _arla_fwd_entry1;
} BCM53128_A0_ARLA_FWD_ENTRY1r_t;

#define BCM53128_A0_ARLA_FWD_ENTRY1r_CLR(r) (r).arla_fwd_entry1[0] = 0
#define BCM53128_A0_ARLA_FWD_ENTRY1r_SET(r,d) (r).arla_fwd_entry1[0] = d
#define BCM53128_A0_ARLA_FWD_ENTRY1r_GET(r) (r).arla_fwd_entry1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_FWD_ENTRY1r_PORTIDf_GET(r) (((r).arla_fwd_entry1[0]) & 0x1ff)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_PORTIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET(r) ((((r).arla_fwd_entry1[0]) >> 9) & 0x3)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry1[0]) >> 11) & 0x7)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry1[0]) >> 14) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry1[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 16) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_ARLA_FWD_ENTRY1r_RESERVEDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 17) & 0x7fff)
#define BCM53128_A0_ARLA_FWD_ENTRY1r_RESERVEDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY1.
 *
 */
#define BCM53128_A0_READ_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_FWD_ENTRY1r,(r._arla_fwd_entry1),4)
#define BCM53128_A0_WRITE_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_FWD_ENTRY1r,&(r._arla_fwd_entry1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY1r BCM53128_A0_ARLA_FWD_ENTRY1r
#define ARLA_FWD_ENTRY1r_SIZE BCM53128_A0_ARLA_FWD_ENTRY1r_SIZE
typedef BCM53128_A0_ARLA_FWD_ENTRY1r_t ARLA_FWD_ENTRY1r_t;
#define ARLA_FWD_ENTRY1r_CLR BCM53128_A0_ARLA_FWD_ENTRY1r_CLR
#define ARLA_FWD_ENTRY1r_SET BCM53128_A0_ARLA_FWD_ENTRY1r_SET
#define ARLA_FWD_ENTRY1r_GET BCM53128_A0_ARLA_FWD_ENTRY1r_GET
#define ARLA_FWD_ENTRY1r_PORTIDf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_PORTIDf_GET
#define ARLA_FWD_ENTRY1r_PORTIDf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_PORTIDf_SET
#define ARLA_FWD_ENTRY1r_ARL_CONf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET
#define ARLA_FWD_ENTRY1r_ARL_CONf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY1r_RESERVEDf_GET BCM53128_A0_ARLA_FWD_ENTRY1r_RESERVEDf_GET
#define ARLA_FWD_ENTRY1r_RESERVEDf_SET BCM53128_A0_ARLA_FWD_ENTRY1r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY1r BCM53128_A0_READ_ARLA_FWD_ENTRY1r
#define WRITE_ARLA_FWD_ENTRY1r BCM53128_A0_WRITE_ARLA_FWD_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_FWD_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_FWD_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR2 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_FWD_ENTRY2r 0x00000538

#define BCM53128_A0_ARLA_FWD_ENTRY2r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY2.
 *
 */
typedef union BCM53128_A0_ARLA_FWD_ENTRY2r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry2[1];
	uint32_t _arla_fwd_entry2;
} BCM53128_A0_ARLA_FWD_ENTRY2r_t;

#define BCM53128_A0_ARLA_FWD_ENTRY2r_CLR(r) (r).arla_fwd_entry2[0] = 0
#define BCM53128_A0_ARLA_FWD_ENTRY2r_SET(r,d) (r).arla_fwd_entry2[0] = d
#define BCM53128_A0_ARLA_FWD_ENTRY2r_GET(r) (r).arla_fwd_entry2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_FWD_ENTRY2r_PORTIDf_GET(r) (((r).arla_fwd_entry2[0]) & 0x1ff)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_PORTIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET(r) ((((r).arla_fwd_entry2[0]) >> 9) & 0x3)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry2[0]) >> 11) & 0x7)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry2[0]) >> 14) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry2[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 16) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_ARLA_FWD_ENTRY2r_RESERVEDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 17) & 0x7fff)
#define BCM53128_A0_ARLA_FWD_ENTRY2r_RESERVEDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY2.
 *
 */
#define BCM53128_A0_READ_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_FWD_ENTRY2r,(r._arla_fwd_entry2),4)
#define BCM53128_A0_WRITE_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_FWD_ENTRY2r,&(r._arla_fwd_entry2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY2r BCM53128_A0_ARLA_FWD_ENTRY2r
#define ARLA_FWD_ENTRY2r_SIZE BCM53128_A0_ARLA_FWD_ENTRY2r_SIZE
typedef BCM53128_A0_ARLA_FWD_ENTRY2r_t ARLA_FWD_ENTRY2r_t;
#define ARLA_FWD_ENTRY2r_CLR BCM53128_A0_ARLA_FWD_ENTRY2r_CLR
#define ARLA_FWD_ENTRY2r_SET BCM53128_A0_ARLA_FWD_ENTRY2r_SET
#define ARLA_FWD_ENTRY2r_GET BCM53128_A0_ARLA_FWD_ENTRY2r_GET
#define ARLA_FWD_ENTRY2r_PORTIDf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_PORTIDf_GET
#define ARLA_FWD_ENTRY2r_PORTIDf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_PORTIDf_SET
#define ARLA_FWD_ENTRY2r_ARL_CONf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET
#define ARLA_FWD_ENTRY2r_ARL_CONf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY2r_RESERVEDf_GET BCM53128_A0_ARLA_FWD_ENTRY2r_RESERVEDf_GET
#define ARLA_FWD_ENTRY2r_RESERVEDf_SET BCM53128_A0_ARLA_FWD_ENTRY2r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY2r BCM53128_A0_READ_ARLA_FWD_ENTRY2r
#define WRITE_ARLA_FWD_ENTRY2r BCM53128_A0_WRITE_ARLA_FWD_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_FWD_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_FWD_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR3 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_FWD_ENTRY3r 0x00000548

#define BCM53128_A0_ARLA_FWD_ENTRY3r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY3.
 *
 */
typedef union BCM53128_A0_ARLA_FWD_ENTRY3r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry3[1];
	uint32_t _arla_fwd_entry3;
} BCM53128_A0_ARLA_FWD_ENTRY3r_t;

#define BCM53128_A0_ARLA_FWD_ENTRY3r_CLR(r) (r).arla_fwd_entry3[0] = 0
#define BCM53128_A0_ARLA_FWD_ENTRY3r_SET(r,d) (r).arla_fwd_entry3[0] = d
#define BCM53128_A0_ARLA_FWD_ENTRY3r_GET(r) (r).arla_fwd_entry3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_FWD_ENTRY3r_PORTIDf_GET(r) (((r).arla_fwd_entry3[0]) & 0x1ff)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_PORTIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET(r) ((((r).arla_fwd_entry3[0]) >> 9) & 0x3)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry3[0]) >> 11) & 0x7)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry3[0]) >> 14) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry3[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 16) & 0x1)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_ARLA_FWD_ENTRY3r_RESERVEDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 17) & 0x7fff)
#define BCM53128_A0_ARLA_FWD_ENTRY3r_RESERVEDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY3.
 *
 */
#define BCM53128_A0_READ_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_FWD_ENTRY3r,(r._arla_fwd_entry3),4)
#define BCM53128_A0_WRITE_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_FWD_ENTRY3r,&(r._arla_fwd_entry3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY3r BCM53128_A0_ARLA_FWD_ENTRY3r
#define ARLA_FWD_ENTRY3r_SIZE BCM53128_A0_ARLA_FWD_ENTRY3r_SIZE
typedef BCM53128_A0_ARLA_FWD_ENTRY3r_t ARLA_FWD_ENTRY3r_t;
#define ARLA_FWD_ENTRY3r_CLR BCM53128_A0_ARLA_FWD_ENTRY3r_CLR
#define ARLA_FWD_ENTRY3r_SET BCM53128_A0_ARLA_FWD_ENTRY3r_SET
#define ARLA_FWD_ENTRY3r_GET BCM53128_A0_ARLA_FWD_ENTRY3r_GET
#define ARLA_FWD_ENTRY3r_PORTIDf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_PORTIDf_GET
#define ARLA_FWD_ENTRY3r_PORTIDf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_PORTIDf_SET
#define ARLA_FWD_ENTRY3r_ARL_CONf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET
#define ARLA_FWD_ENTRY3r_ARL_CONf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY3r_RESERVEDf_GET BCM53128_A0_ARLA_FWD_ENTRY3r_RESERVEDf_GET
#define ARLA_FWD_ENTRY3r_RESERVEDf_SET BCM53128_A0_ARLA_FWD_ENTRY3r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY3r BCM53128_A0_READ_ARLA_FWD_ENTRY3r
#define WRITE_ARLA_FWD_ENTRY3r BCM53128_A0_WRITE_ARLA_FWD_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_FWD_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_MAC
 * BLOCKS:   SYS
 * DESC:     MAC Address Index Register
 * SIZE:     48
 * FIELDS:
 *     MAC_ADDR_INDX    MAC Address Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0/1/2/3 locations. These entries are 64 bits wide. Initiating a write command will write the contents of ARL Entry 0/1/2/3 to the specified bin location (4 entries deep) and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_MACr 0x00000502

#define BCM53128_A0_ARLA_MACr_SIZE 6

/*
 * This structure should be used to declare and program ARLA_MAC.
 *
 */
typedef union BCM53128_A0_ARLA_MACr_s {
	uint32_t v[2];
	uint32_t arla_mac[2];
	uint32_t _arla_mac;
} BCM53128_A0_ARLA_MACr_t;

#define BCM53128_A0_ARLA_MACr_CLR(r) CDK_MEMSET(&((r)._arla_mac), 0, sizeof(BCM53128_A0_ARLA_MACr_t))
#define BCM53128_A0_ARLA_MACr_SET(r,i,d) (r).arla_mac[i] = d
#define BCM53128_A0_ARLA_MACr_GET(r,i) (r).arla_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_MACr_MAC_ADDR_INDXf_GET(r,a) cdk_field_get((r).arla_mac,0,47,a)
#define BCM53128_A0_ARLA_MACr_MAC_ADDR_INDXf_SET(r,a) cdk_field_set((r).arla_mac,0,47,a)

/*
 * These macros can be used to access ARLA_MAC.
 *
 */
#define BCM53128_A0_READ_ARLA_MACr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_MACr,(r._arla_mac),6)
#define BCM53128_A0_WRITE_ARLA_MACr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_MACr,&(r._arla_mac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACr BCM53128_A0_ARLA_MACr
#define ARLA_MACr_SIZE BCM53128_A0_ARLA_MACr_SIZE
typedef BCM53128_A0_ARLA_MACr_t ARLA_MACr_t;
#define ARLA_MACr_CLR BCM53128_A0_ARLA_MACr_CLR
#define ARLA_MACr_SET BCM53128_A0_ARLA_MACr_SET
#define ARLA_MACr_GET BCM53128_A0_ARLA_MACr_GET
#define ARLA_MACr_MAC_ADDR_INDXf_GET BCM53128_A0_ARLA_MACr_MAC_ADDR_INDXf_GET
#define ARLA_MACr_MAC_ADDR_INDXf_SET BCM53128_A0_ARLA_MACr_MAC_ADDR_INDXf_SET
#define READ_ARLA_MACr BCM53128_A0_READ_ARLA_MACr
#define WRITE_ARLA_MACr BCM53128_A0_WRITE_ARLA_MACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_MACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_MACVID_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 0.
 *     VID              VID0.The VID0 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 0 Register and MAC/VID Entry 0 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_MACVID_ENTRY0r 0x00000510

#define BCM53128_A0_ARLA_MACVID_ENTRY0r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY0.
 *
 */
typedef union BCM53128_A0_ARLA_MACVID_ENTRY0r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry0[2];
	uint32_t _arla_macvid_entry0;
} BCM53128_A0_ARLA_MACVID_ENTRY0r_t;

#define BCM53128_A0_ARLA_MACVID_ENTRY0r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry0), 0, sizeof(BCM53128_A0_ARLA_MACVID_ENTRY0r_t))
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_SET(r,i,d) (r).arla_macvid_entry0[i] = d
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_GET(r,i) (r).arla_macvid_entry0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry0,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry0,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_VIDf_GET(r) ((((r).arla_macvid_entry0[1]) >> 16) & 0xfff)
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_VIDf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_GET(r) ((((r).arla_macvid_entry0[1]) >> 28) & 0xf)
#define BCM53128_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY0.
 *
 */
#define BCM53128_A0_READ_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_MACVID_ENTRY0r,(r._arla_macvid_entry0),8)
#define BCM53128_A0_WRITE_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_MACVID_ENTRY0r,&(r._arla_macvid_entry0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY0r BCM53128_A0_ARLA_MACVID_ENTRY0r
#define ARLA_MACVID_ENTRY0r_SIZE BCM53128_A0_ARLA_MACVID_ENTRY0r_SIZE
typedef BCM53128_A0_ARLA_MACVID_ENTRY0r_t ARLA_MACVID_ENTRY0r_t;
#define ARLA_MACVID_ENTRY0r_CLR BCM53128_A0_ARLA_MACVID_ENTRY0r_CLR
#define ARLA_MACVID_ENTRY0r_SET BCM53128_A0_ARLA_MACVID_ENTRY0r_SET
#define ARLA_MACVID_ENTRY0r_GET BCM53128_A0_ARLA_MACVID_ENTRY0r_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET BCM53128_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET BCM53128_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY0r_VIDf_GET BCM53128_A0_ARLA_MACVID_ENTRY0r_VIDf_GET
#define ARLA_MACVID_ENTRY0r_VIDf_SET BCM53128_A0_ARLA_MACVID_ENTRY0r_VIDf_SET
#define ARLA_MACVID_ENTRY0r_RESERVEDf_GET BCM53128_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY0r_RESERVEDf_SET BCM53128_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY0r BCM53128_A0_READ_ARLA_MACVID_ENTRY0r
#define WRITE_ARLA_MACVID_ENTRY0r BCM53128_A0_WRITE_ARLA_MACVID_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_MACVID_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_MACVID_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 1.
 *     VID              VID1.The VID1 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 1 Register and MAC/VID Entry 1 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_MACVID_ENTRY1r 0x00000520

#define BCM53128_A0_ARLA_MACVID_ENTRY1r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY1.
 *
 */
typedef union BCM53128_A0_ARLA_MACVID_ENTRY1r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry1[2];
	uint32_t _arla_macvid_entry1;
} BCM53128_A0_ARLA_MACVID_ENTRY1r_t;

#define BCM53128_A0_ARLA_MACVID_ENTRY1r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry1), 0, sizeof(BCM53128_A0_ARLA_MACVID_ENTRY1r_t))
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_SET(r,i,d) (r).arla_macvid_entry1[i] = d
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_GET(r,i) (r).arla_macvid_entry1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry1,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry1,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_VIDf_GET(r) ((((r).arla_macvid_entry1[1]) >> 16) & 0xfff)
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_VIDf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_GET(r) ((((r).arla_macvid_entry1[1]) >> 28) & 0xf)
#define BCM53128_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY1.
 *
 */
#define BCM53128_A0_READ_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_MACVID_ENTRY1r,(r._arla_macvid_entry1),8)
#define BCM53128_A0_WRITE_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_MACVID_ENTRY1r,&(r._arla_macvid_entry1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY1r BCM53128_A0_ARLA_MACVID_ENTRY1r
#define ARLA_MACVID_ENTRY1r_SIZE BCM53128_A0_ARLA_MACVID_ENTRY1r_SIZE
typedef BCM53128_A0_ARLA_MACVID_ENTRY1r_t ARLA_MACVID_ENTRY1r_t;
#define ARLA_MACVID_ENTRY1r_CLR BCM53128_A0_ARLA_MACVID_ENTRY1r_CLR
#define ARLA_MACVID_ENTRY1r_SET BCM53128_A0_ARLA_MACVID_ENTRY1r_SET
#define ARLA_MACVID_ENTRY1r_GET BCM53128_A0_ARLA_MACVID_ENTRY1r_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET BCM53128_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET BCM53128_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY1r_VIDf_GET BCM53128_A0_ARLA_MACVID_ENTRY1r_VIDf_GET
#define ARLA_MACVID_ENTRY1r_VIDf_SET BCM53128_A0_ARLA_MACVID_ENTRY1r_VIDf_SET
#define ARLA_MACVID_ENTRY1r_RESERVEDf_GET BCM53128_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY1r_RESERVEDf_SET BCM53128_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY1r BCM53128_A0_READ_ARLA_MACVID_ENTRY1r
#define WRITE_ARLA_MACVID_ENTRY1r BCM53128_A0_WRITE_ARLA_MACVID_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_MACVID_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_MACVID_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 2 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 2.
 *     VID              VID2.The VID2 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 2 Register and MAC/VID Entry 2 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_MACVID_ENTRY2r 0x00000530

#define BCM53128_A0_ARLA_MACVID_ENTRY2r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY2.
 *
 */
typedef union BCM53128_A0_ARLA_MACVID_ENTRY2r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry2[2];
	uint32_t _arla_macvid_entry2;
} BCM53128_A0_ARLA_MACVID_ENTRY2r_t;

#define BCM53128_A0_ARLA_MACVID_ENTRY2r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry2), 0, sizeof(BCM53128_A0_ARLA_MACVID_ENTRY2r_t))
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_SET(r,i,d) (r).arla_macvid_entry2[i] = d
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_GET(r,i) (r).arla_macvid_entry2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry2,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry2,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_VIDf_GET(r) ((((r).arla_macvid_entry2[1]) >> 16) & 0xfff)
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_VIDf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_GET(r) ((((r).arla_macvid_entry2[1]) >> 28) & 0xf)
#define BCM53128_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY2.
 *
 */
#define BCM53128_A0_READ_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_MACVID_ENTRY2r,(r._arla_macvid_entry2),8)
#define BCM53128_A0_WRITE_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_MACVID_ENTRY2r,&(r._arla_macvid_entry2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY2r BCM53128_A0_ARLA_MACVID_ENTRY2r
#define ARLA_MACVID_ENTRY2r_SIZE BCM53128_A0_ARLA_MACVID_ENTRY2r_SIZE
typedef BCM53128_A0_ARLA_MACVID_ENTRY2r_t ARLA_MACVID_ENTRY2r_t;
#define ARLA_MACVID_ENTRY2r_CLR BCM53128_A0_ARLA_MACVID_ENTRY2r_CLR
#define ARLA_MACVID_ENTRY2r_SET BCM53128_A0_ARLA_MACVID_ENTRY2r_SET
#define ARLA_MACVID_ENTRY2r_GET BCM53128_A0_ARLA_MACVID_ENTRY2r_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET BCM53128_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET BCM53128_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY2r_VIDf_GET BCM53128_A0_ARLA_MACVID_ENTRY2r_VIDf_GET
#define ARLA_MACVID_ENTRY2r_VIDf_SET BCM53128_A0_ARLA_MACVID_ENTRY2r_VIDf_SET
#define ARLA_MACVID_ENTRY2r_RESERVEDf_GET BCM53128_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY2r_RESERVEDf_SET BCM53128_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY2r BCM53128_A0_READ_ARLA_MACVID_ENTRY2r
#define WRITE_ARLA_MACVID_ENTRY2r BCM53128_A0_WRITE_ARLA_MACVID_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_MACVID_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_MACVID_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 3 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 3.
 *     VID              VID3.The VID3 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 3 Register and MAC/VID Entry 3 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_MACVID_ENTRY3r 0x00000540

#define BCM53128_A0_ARLA_MACVID_ENTRY3r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY3.
 *
 */
typedef union BCM53128_A0_ARLA_MACVID_ENTRY3r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry3[2];
	uint32_t _arla_macvid_entry3;
} BCM53128_A0_ARLA_MACVID_ENTRY3r_t;

#define BCM53128_A0_ARLA_MACVID_ENTRY3r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry3), 0, sizeof(BCM53128_A0_ARLA_MACVID_ENTRY3r_t))
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_SET(r,i,d) (r).arla_macvid_entry3[i] = d
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_GET(r,i) (r).arla_macvid_entry3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry3,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry3,0,47,a)
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_VIDf_GET(r) ((((r).arla_macvid_entry3[1]) >> 16) & 0xfff)
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_VIDf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_GET(r) ((((r).arla_macvid_entry3[1]) >> 28) & 0xf)
#define BCM53128_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY3.
 *
 */
#define BCM53128_A0_READ_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_MACVID_ENTRY3r,(r._arla_macvid_entry3),8)
#define BCM53128_A0_WRITE_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_MACVID_ENTRY3r,&(r._arla_macvid_entry3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY3r BCM53128_A0_ARLA_MACVID_ENTRY3r
#define ARLA_MACVID_ENTRY3r_SIZE BCM53128_A0_ARLA_MACVID_ENTRY3r_SIZE
typedef BCM53128_A0_ARLA_MACVID_ENTRY3r_t ARLA_MACVID_ENTRY3r_t;
#define ARLA_MACVID_ENTRY3r_CLR BCM53128_A0_ARLA_MACVID_ENTRY3r_CLR
#define ARLA_MACVID_ENTRY3r_SET BCM53128_A0_ARLA_MACVID_ENTRY3r_SET
#define ARLA_MACVID_ENTRY3r_GET BCM53128_A0_ARLA_MACVID_ENTRY3r_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET BCM53128_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET BCM53128_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY3r_VIDf_GET BCM53128_A0_ARLA_MACVID_ENTRY3r_VIDf_GET
#define ARLA_MACVID_ENTRY3r_VIDf_SET BCM53128_A0_ARLA_MACVID_ENTRY3r_VIDf_SET
#define ARLA_MACVID_ENTRY3r_RESERVEDf_GET BCM53128_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY3r_RESERVEDf_SET BCM53128_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY3r BCM53128_A0_READ_ARLA_MACVID_ENTRY3r
#define WRITE_ARLA_MACVID_ENTRY3r BCM53128_A0_WRITE_ARLA_MACVID_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_MACVID_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_RWCTL
 * BLOCKS:   SYS
 * DESC:     ARL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     ARL_RW           ARL Read/Write.1 = Read,0 = Write.
 *     RESERVED         Reserved
 *     ARL_STRTDN       Start/Done Command.Write as 1 to initiate a read or write command, after first loading the MAC_ADDR_INDX register with the MAC address for which the ARL entry is to be read or written.The Blackbird2 will reset the bit to indicate a write operation completed, or a read operation has completed and data from the bin entry is available in ARL Entry 0/1 Note that both ARL Entry 0 and 1 are both always read/written by the Blackbird2 when accessing the address table locations in memory.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_RWCTLr 0x00000500

#define BCM53128_A0_ARLA_RWCTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_RWCTL.
 *
 */
typedef union BCM53128_A0_ARLA_RWCTLr_s {
	uint32_t v[1];
	uint32_t arla_rwctl[1];
	uint32_t _arla_rwctl;
} BCM53128_A0_ARLA_RWCTLr_t;

#define BCM53128_A0_ARLA_RWCTLr_CLR(r) (r).arla_rwctl[0] = 0
#define BCM53128_A0_ARLA_RWCTLr_SET(r,d) (r).arla_rwctl[0] = d
#define BCM53128_A0_ARLA_RWCTLr_GET(r) (r).arla_rwctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_RWCTLr_ARL_RWf_GET(r) (((r).arla_rwctl[0]) & 0x1)
#define BCM53128_A0_ARLA_RWCTLr_ARL_RWf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_ARLA_RWCTLr_RESERVEDf_GET(r) ((((r).arla_rwctl[0]) >> 1) & 0x3f)
#define BCM53128_A0_ARLA_RWCTLr_RESERVEDf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53128_A0_ARLA_RWCTLr_ARL_STRTDNf_GET(r) ((((r).arla_rwctl[0]) >> 7) & 0x1)
#define BCM53128_A0_ARLA_RWCTLr_ARL_STRTDNf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_RWCTL.
 *
 */
#define BCM53128_A0_READ_ARLA_RWCTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_RWCTLr,(r._arla_rwctl),1)
#define BCM53128_A0_WRITE_ARLA_RWCTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_RWCTLr,&(r._arla_rwctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_RWCTLr BCM53128_A0_ARLA_RWCTLr
#define ARLA_RWCTLr_SIZE BCM53128_A0_ARLA_RWCTLr_SIZE
typedef BCM53128_A0_ARLA_RWCTLr_t ARLA_RWCTLr_t;
#define ARLA_RWCTLr_CLR BCM53128_A0_ARLA_RWCTLr_CLR
#define ARLA_RWCTLr_SET BCM53128_A0_ARLA_RWCTLr_SET
#define ARLA_RWCTLr_GET BCM53128_A0_ARLA_RWCTLr_GET
#define ARLA_RWCTLr_ARL_RWf_GET BCM53128_A0_ARLA_RWCTLr_ARL_RWf_GET
#define ARLA_RWCTLr_ARL_RWf_SET BCM53128_A0_ARLA_RWCTLr_ARL_RWf_SET
#define ARLA_RWCTLr_RESERVEDf_GET BCM53128_A0_ARLA_RWCTLr_RESERVEDf_GET
#define ARLA_RWCTLr_RESERVEDf_SET BCM53128_A0_ARLA_RWCTLr_RESERVEDf_SET
#define ARLA_RWCTLr_ARL_STRTDNf_GET BCM53128_A0_ARLA_RWCTLr_ARL_STRTDNf_GET
#define ARLA_RWCTLr_ARL_STRTDNf_SET BCM53128_A0_ARLA_RWCTLr_ARL_STRTDNf_SET
#define READ_ARLA_RWCTLr BCM53128_A0_READ_ARLA_RWCTLr
#define WRITE_ARLA_RWCTLr BCM53128_A0_WRITE_ARLA_RWCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_RWCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_SRCH_ADR
 * BLOCKS:   SYS
 * DESC:     ARL Search Address Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_SRCH_ADR    ARL Address.15 bit internal representation of the address of the ARL entry currently being accessed by the ARL search routine.This is not a direct address of the ARL location, and is intended for factory test/diagnostic use only.
 *     ARLA_SRCH_ADR_VALID ARL Address Valid.Indicates the lower 15 bits of this register contain a valid internal representation of the ARL entry currently being accessed. Intended for factory test/diagnostic use only.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_SRCH_ADRr 0x00000551

#define BCM53128_A0_ARLA_SRCH_ADRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_ADR.
 *
 */
typedef union BCM53128_A0_ARLA_SRCH_ADRr_s {
	uint32_t v[1];
	uint32_t arla_srch_adr[1];
	uint32_t _arla_srch_adr;
} BCM53128_A0_ARLA_SRCH_ADRr_t;

#define BCM53128_A0_ARLA_SRCH_ADRr_CLR(r) (r).arla_srch_adr[0] = 0
#define BCM53128_A0_ARLA_SRCH_ADRr_SET(r,d) (r).arla_srch_adr[0] = d
#define BCM53128_A0_ARLA_SRCH_ADRr_GET(r) (r).arla_srch_adr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET(r) (((r).arla_srch_adr[0]) & 0x7fff)
#define BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))
#define BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET(r) ((((r).arla_srch_adr[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_ADR.
 *
 */
#define BCM53128_A0_READ_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_SRCH_ADRr,(r._arla_srch_adr),2)
#define BCM53128_A0_WRITE_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_SRCH_ADRr,&(r._arla_srch_adr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_ADRr BCM53128_A0_ARLA_SRCH_ADRr
#define ARLA_SRCH_ADRr_SIZE BCM53128_A0_ARLA_SRCH_ADRr_SIZE
typedef BCM53128_A0_ARLA_SRCH_ADRr_t ARLA_SRCH_ADRr_t;
#define ARLA_SRCH_ADRr_CLR BCM53128_A0_ARLA_SRCH_ADRr_CLR
#define ARLA_SRCH_ADRr_SET BCM53128_A0_ARLA_SRCH_ADRr_SET
#define ARLA_SRCH_ADRr_GET BCM53128_A0_ARLA_SRCH_ADRr_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET BCM53128_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET
#define READ_ARLA_SRCH_ADRr BCM53128_A0_READ_ARLA_SRCH_ADRr
#define WRITE_ARLA_SRCH_ADRr BCM53128_A0_WRITE_ARLA_SRCH_ADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_SRCH_ADRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_SRCH_CTL
 * BLOCKS:   SYS
 * DESC:     ARL Search Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_SRCH_VLID   ARL Search Result ValidAvailable in the ARL Search Result register.Reset by a host read to the ARL Search Result register 1 , which will cause the ARL search process to continue through the ARL entries until the next entry is found with a Valid bit is set.(Note: should not reset by a host read to ARL Search VID Result Register. The correct process of reading a ARL Entry after having searched a valid one: Read ARL Search VID Result Register => Read ARL Search Result Register 1)
 *     RESERVED         Reserved
 *     ARLA_SRCH_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The Blackbird2 will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_SRCH_CTLr 0x00000550

#define BCM53128_A0_ARLA_SRCH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_SRCH_CTL.
 *
 */
typedef union BCM53128_A0_ARLA_SRCH_CTLr_s {
	uint32_t v[1];
	uint32_t arla_srch_ctl[1];
	uint32_t _arla_srch_ctl;
} BCM53128_A0_ARLA_SRCH_CTLr_t;

#define BCM53128_A0_ARLA_SRCH_CTLr_CLR(r) (r).arla_srch_ctl[0] = 0
#define BCM53128_A0_ARLA_SRCH_CTLr_SET(r,d) (r).arla_srch_ctl[0] = d
#define BCM53128_A0_ARLA_SRCH_CTLr_GET(r) (r).arla_srch_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET(r) (((r).arla_srch_ctl[0]) & 0x1)
#define BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_ARLA_SRCH_CTLr_RESERVEDf_GET(r) ((((r).arla_srch_ctl[0]) >> 1) & 0x3f)
#define BCM53128_A0_ARLA_SRCH_CTLr_RESERVEDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET(r) ((((r).arla_srch_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_SRCH_CTL.
 *
 */
#define BCM53128_A0_READ_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_SRCH_CTLr,(r._arla_srch_ctl),1)
#define BCM53128_A0_WRITE_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_SRCH_CTLr,&(r._arla_srch_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_CTLr BCM53128_A0_ARLA_SRCH_CTLr
#define ARLA_SRCH_CTLr_SIZE BCM53128_A0_ARLA_SRCH_CTLr_SIZE
typedef BCM53128_A0_ARLA_SRCH_CTLr_t ARLA_SRCH_CTLr_t;
#define ARLA_SRCH_CTLr_CLR BCM53128_A0_ARLA_SRCH_CTLr_CLR
#define ARLA_SRCH_CTLr_SET BCM53128_A0_ARLA_SRCH_CTLr_SET
#define ARLA_SRCH_CTLr_GET BCM53128_A0_ARLA_SRCH_CTLr_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET
#define ARLA_SRCH_CTLr_RESERVEDf_GET BCM53128_A0_ARLA_SRCH_CTLr_RESERVEDf_GET
#define ARLA_SRCH_CTLr_RESERVEDf_SET BCM53128_A0_ARLA_SRCH_CTLr_RESERVEDf_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET BCM53128_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET
#define READ_ARLA_SRCH_CTLr BCM53128_A0_READ_ARLA_SRCH_CTLr
#define WRITE_ARLA_SRCH_CTLr BCM53128_A0_WRITE_ARLA_SRCH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_SRCH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL control bit for ARL control mode enhancement
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry.Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_SRCH_RSLTr 0x00000568

#define BCM53128_A0_ARLA_SRCH_RSLTr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT.
 *
 */
typedef union BCM53128_A0_ARLA_SRCH_RSLTr_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt[1];
	uint32_t _arla_srch_rslt;
} BCM53128_A0_ARLA_SRCH_RSLTr_t;

#define BCM53128_A0_ARLA_SRCH_RSLTr_CLR(r) (r).arla_srch_rslt[0] = 0
#define BCM53128_A0_ARLA_SRCH_RSLTr_SET(r,d) (r).arla_srch_rslt[0] = d
#define BCM53128_A0_ARLA_SRCH_RSLTr_GET(r) (r).arla_srch_rslt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_SRCH_RSLTr_PORTIDf_GET(r) (((r).arla_srch_rslt[0]) & 0x1ff)
#define BCM53128_A0_ARLA_SRCH_RSLTr_PORTIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET(r) ((((r).arla_srch_rslt[0]) >> 9) & 0x3)
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt[0]) >> 11) & 0x7)
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt[0]) >> 14) & 0x1)
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt[0]) >> 16) & 0x1)
#define BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_ARLA_SRCH_RSLTr_RESERVEDf_GET(r) ((((r).arla_srch_rslt[0]) >> 17) & 0x7fff)
#define BCM53128_A0_ARLA_SRCH_RSLTr_RESERVEDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT.
 *
 */
#define BCM53128_A0_READ_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_SRCH_RSLTr,(r._arla_srch_rslt),4)
#define BCM53128_A0_WRITE_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_SRCH_RSLTr,&(r._arla_srch_rslt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLTr BCM53128_A0_ARLA_SRCH_RSLTr
#define ARLA_SRCH_RSLTr_SIZE BCM53128_A0_ARLA_SRCH_RSLTr_SIZE
typedef BCM53128_A0_ARLA_SRCH_RSLTr_t ARLA_SRCH_RSLTr_t;
#define ARLA_SRCH_RSLTr_CLR BCM53128_A0_ARLA_SRCH_RSLTr_CLR
#define ARLA_SRCH_RSLTr_SET BCM53128_A0_ARLA_SRCH_RSLTr_SET
#define ARLA_SRCH_RSLTr_GET BCM53128_A0_ARLA_SRCH_RSLTr_GET
#define ARLA_SRCH_RSLTr_PORTIDf_GET BCM53128_A0_ARLA_SRCH_RSLTr_PORTIDf_GET
#define ARLA_SRCH_RSLTr_PORTIDf_SET BCM53128_A0_ARLA_SRCH_RSLTr_PORTIDf_SET
#define ARLA_SRCH_RSLTr_ARL_CONf_GET BCM53128_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET
#define ARLA_SRCH_RSLTr_ARL_CONf_SET BCM53128_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM53128_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLTr_RESERVEDf_GET BCM53128_A0_ARLA_SRCH_RSLTr_RESERVEDf_GET
#define ARLA_SRCH_RSLTr_RESERVEDf_SET BCM53128_A0_ARLA_SRCH_RSLTr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLTr BCM53128_A0_READ_ARLA_SRCH_RSLTr
#define WRITE_ARLA_SRCH_RSLTr BCM53128_A0_WRITE_ARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_SRCH_RSLTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_SRCH_RSLT_0_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr 0x00000560

#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_0_MACVID.
 *
 */
typedef union BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_0_macvid[2];
	uint32_t _arla_srch_rslt_0_macvid;
} BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_t;

#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_0_macvid), 0, sizeof(BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_t))
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_0_macvid[i] = d
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET(r,i) (r).arla_srch_rslt_0_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 16) & 0xfff)
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 28) & 0xf)
#define BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_0_MACVID.
 *
 */
#define BCM53128_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr,(r._arla_srch_rslt_0_macvid),8)
#define BCM53128_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr,&(r._arla_srch_rslt_0_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_0_MACVIDr BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr
#define ARLA_SRCH_RSLT_0_MACVIDr_SIZE BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE
typedef BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_t ARLA_SRCH_RSLT_0_MACVIDr_t;
#define ARLA_SRCH_RSLT_0_MACVIDr_CLR BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR
#define ARLA_SRCH_RSLT_0_MACVIDr_SET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_GET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_0_MACVIDr BCM53128_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_0_MACVIDr BCM53128_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_SRCH_RSLT_0_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_SRCH_RSLT_1
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL control bit for ARL control mode enhancement
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_SRCH_RSLT_1r 0x00000578

#define BCM53128_A0_ARLA_SRCH_RSLT_1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1.
 *
 */
typedef union BCM53128_A0_ARLA_SRCH_RSLT_1r_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt_1[1];
	uint32_t _arla_srch_rslt_1;
} BCM53128_A0_ARLA_SRCH_RSLT_1r_t;

#define BCM53128_A0_ARLA_SRCH_RSLT_1r_CLR(r) (r).arla_srch_rslt_1[0] = 0
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_SET(r,d) (r).arla_srch_rslt_1[0] = d
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_GET(r) (r).arla_srch_rslt_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_PORTIDf_GET(r) (((r).arla_srch_rslt_1[0]) & 0x1ff)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_PORTIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 9) & 0x3)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 11) & 0x7)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 14) & 0x1)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 15) & 0x1)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 16) & 0x1)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 17) & 0x7fff)
#define BCM53128_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1.
 *
 */
#define BCM53128_A0_READ_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_SRCH_RSLT_1r,(r._arla_srch_rslt_1),4)
#define BCM53128_A0_WRITE_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_SRCH_RSLT_1r,&(r._arla_srch_rslt_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1r BCM53128_A0_ARLA_SRCH_RSLT_1r
#define ARLA_SRCH_RSLT_1r_SIZE BCM53128_A0_ARLA_SRCH_RSLT_1r_SIZE
typedef BCM53128_A0_ARLA_SRCH_RSLT_1r_t ARLA_SRCH_RSLT_1r_t;
#define ARLA_SRCH_RSLT_1r_CLR BCM53128_A0_ARLA_SRCH_RSLT_1r_CLR
#define ARLA_SRCH_RSLT_1r_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_SET
#define ARLA_SRCH_RSLT_1r_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_GET
#define ARLA_SRCH_RSLT_1r_PORTIDf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_PORTIDf_GET
#define ARLA_SRCH_RSLT_1r_PORTIDf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_PORTIDf_SET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLT_1r_RESERVEDf_GET BCM53128_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_GET
#define ARLA_SRCH_RSLT_1r_RESERVEDf_SET BCM53128_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_1r BCM53128_A0_READ_ARLA_SRCH_RSLT_1r
#define WRITE_ARLA_SRCH_RSLT_1r BCM53128_A0_WRITE_ARLA_SRCH_RSLT_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_SRCH_RSLT_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_SRCH_RSLT_1_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr 0x00000570

#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1_MACVID.
 *
 */
typedef union BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_1_macvid[2];
	uint32_t _arla_srch_rslt_1_macvid;
} BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_t;

#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_1_macvid), 0, sizeof(BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_t))
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_1_macvid[i] = d
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET(r,i) (r).arla_srch_rslt_1_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 16) & 0xfff)
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 28) & 0xf)
#define BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1_MACVID.
 *
 */
#define BCM53128_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr,(r._arla_srch_rslt_1_macvid),8)
#define BCM53128_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr,&(r._arla_srch_rslt_1_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1_MACVIDr BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr
#define ARLA_SRCH_RSLT_1_MACVIDr_SIZE BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE
typedef BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_t ARLA_SRCH_RSLT_1_MACVIDr_t;
#define ARLA_SRCH_RSLT_1_MACVIDr_CLR BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR
#define ARLA_SRCH_RSLT_1_MACVIDr_SET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_GET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_1_MACVIDr BCM53128_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_1_MACVIDr BCM53128_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_SRCH_RSLT_1_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_VID
 * BLOCKS:   SYS
 * DESC:     VID Index Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VIDTAB_INDX VID Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address upon MAC Address Index, upon 12 bit VID Index Register if 802.1Q is enabled, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0 locations and VID Entry0. Both ARL entries are 64 bits wide. Both VID entries are 12 bits wide.Initiating a write command will write the contents of ARL Entry 0/1 and VID Entry 0/1 to the specified bin location and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *     ARLA_VIDTAB_RSRV0 Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_VIDr 0x00000508

#define BCM53128_A0_ARLA_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID.
 *
 */
typedef union BCM53128_A0_ARLA_VIDr_s {
	uint32_t v[1];
	uint32_t arla_vid[1];
	uint32_t _arla_vid;
} BCM53128_A0_ARLA_VIDr_t;

#define BCM53128_A0_ARLA_VIDr_CLR(r) (r).arla_vid[0] = 0
#define BCM53128_A0_ARLA_VIDr_SET(r,d) (r).arla_vid[0] = d
#define BCM53128_A0_ARLA_VIDr_GET(r) (r).arla_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET(r) (((r).arla_vid[0]) & 0xfff)
#define BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET(r) ((((r).arla_vid[0]) >> 12) & 0xf)
#define BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VID.
 *
 */
#define BCM53128_A0_READ_ARLA_VIDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_VIDr,(r._arla_vid),2)
#define BCM53128_A0_WRITE_ARLA_VIDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_VIDr,&(r._arla_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VIDr BCM53128_A0_ARLA_VIDr
#define ARLA_VIDr_SIZE BCM53128_A0_ARLA_VIDr_SIZE
typedef BCM53128_A0_ARLA_VIDr_t ARLA_VIDr_t;
#define ARLA_VIDr_CLR BCM53128_A0_ARLA_VIDr_CLR
#define ARLA_VIDr_SET BCM53128_A0_ARLA_VIDr_SET
#define ARLA_VIDr_GET BCM53128_A0_ARLA_VIDr_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_GET BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_SET BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET BCM53128_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET
#define READ_ARLA_VIDr BCM53128_A0_READ_ARLA_VIDr
#define WRITE_ARLA_VIDr BCM53128_A0_WRITE_ARLA_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_VTBL_ADDR
 * BLOCKS:   SYS
 * DESC:     VTBL Address Index Register
 * SIZE:     16
 * FIELDS:
 *     VTBL_ADDR_INDEX  VLAN Table Address Index.The VLAN Table Address Index Register is used to access VLAN Table Entry.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_VTBL_ADDRr 0x00000581

#define BCM53128_A0_ARLA_VTBL_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VTBL_ADDR.
 *
 */
typedef union BCM53128_A0_ARLA_VTBL_ADDRr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_addr[1];
	uint32_t _arla_vtbl_addr;
} BCM53128_A0_ARLA_VTBL_ADDRr_t;

#define BCM53128_A0_ARLA_VTBL_ADDRr_CLR(r) (r).arla_vtbl_addr[0] = 0
#define BCM53128_A0_ARLA_VTBL_ADDRr_SET(r,d) (r).arla_vtbl_addr[0] = d
#define BCM53128_A0_ARLA_VTBL_ADDRr_GET(r) (r).arla_vtbl_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET(r) (((r).arla_vtbl_addr[0]) & 0xfff)
#define BCM53128_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_ARLA_VTBL_ADDRr_RESERVEDf_GET(r) ((((r).arla_vtbl_addr[0]) >> 12) & 0xf)
#define BCM53128_A0_ARLA_VTBL_ADDRr_RESERVEDf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VTBL_ADDR.
 *
 */
#define BCM53128_A0_READ_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_VTBL_ADDRr,(r._arla_vtbl_addr),2)
#define BCM53128_A0_WRITE_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_VTBL_ADDRr,&(r._arla_vtbl_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ADDRr BCM53128_A0_ARLA_VTBL_ADDRr
#define ARLA_VTBL_ADDRr_SIZE BCM53128_A0_ARLA_VTBL_ADDRr_SIZE
typedef BCM53128_A0_ARLA_VTBL_ADDRr_t ARLA_VTBL_ADDRr_t;
#define ARLA_VTBL_ADDRr_CLR BCM53128_A0_ARLA_VTBL_ADDRr_CLR
#define ARLA_VTBL_ADDRr_SET BCM53128_A0_ARLA_VTBL_ADDRr_SET
#define ARLA_VTBL_ADDRr_GET BCM53128_A0_ARLA_VTBL_ADDRr_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET BCM53128_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET BCM53128_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET
#define ARLA_VTBL_ADDRr_RESERVEDf_GET BCM53128_A0_ARLA_VTBL_ADDRr_RESERVEDf_GET
#define ARLA_VTBL_ADDRr_RESERVEDf_SET BCM53128_A0_ARLA_VTBL_ADDRr_RESERVEDf_SET
#define READ_ARLA_VTBL_ADDRr BCM53128_A0_READ_ARLA_VTBL_ADDRr
#define WRITE_ARLA_VTBL_ADDRr BCM53128_A0_WRITE_ARLA_VTBL_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_VTBL_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_VTBL_ENTRY
 * BLOCKS:   SYS
 * DESC:     VTBL Entry Register
 * SIZE:     32
 * FIELDS:
 *     FWD_MAP          Forward PORT MAP.The VLAN-tagged Frame is allowed to be forwarded to the destination ports corresponding bits set in the Map.Bits7-0: Port 7-0.Bit8: Port 8(IMP).
 *     UNTAG_MAP        Untag Port Map.The VLAN-tagged Frame forward to the destination ports corresponding bits set in the Map will be untagged.Bits7-0: Port 7-0.Bit8: Port 8(IMP).
 *     MSPT_INDEX       Index for 16 spanning tree.
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_VTBL_ENTRYr 0x00000583

#define BCM53128_A0_ARLA_VTBL_ENTRYr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_VTBL_ENTRY.
 *
 */
typedef union BCM53128_A0_ARLA_VTBL_ENTRYr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_entry[1];
	uint32_t _arla_vtbl_entry;
} BCM53128_A0_ARLA_VTBL_ENTRYr_t;

#define BCM53128_A0_ARLA_VTBL_ENTRYr_CLR(r) (r).arla_vtbl_entry[0] = 0
#define BCM53128_A0_ARLA_VTBL_ENTRYr_SET(r,d) (r).arla_vtbl_entry[0] = d
#define BCM53128_A0_ARLA_VTBL_ENTRYr_GET(r) (r).arla_vtbl_entry[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET(r) (((r).arla_vtbl_entry[0]) & 0x1ff)
#define BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET(r) ((((r).arla_vtbl_entry[0]) >> 9) & 0x1ff)
#define BCM53128_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53128_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET(r) ((((r).arla_vtbl_entry[0]) >> 18) & 0x7)
#define BCM53128_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET(r) ((((r).arla_vtbl_entry[0]) >> 21) & 0x1)
#define BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53128_A0_ARLA_VTBL_ENTRYr_RESERVEDf_GET(r) ((((r).arla_vtbl_entry[0]) >> 22) & 0x3ff)
#define BCM53128_A0_ARLA_VTBL_ENTRYr_RESERVEDf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access ARLA_VTBL_ENTRY.
 *
 */
#define BCM53128_A0_READ_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_VTBL_ENTRYr,(r._arla_vtbl_entry),4)
#define BCM53128_A0_WRITE_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_VTBL_ENTRYr,&(r._arla_vtbl_entry),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ENTRYr BCM53128_A0_ARLA_VTBL_ENTRYr
#define ARLA_VTBL_ENTRYr_SIZE BCM53128_A0_ARLA_VTBL_ENTRYr_SIZE
typedef BCM53128_A0_ARLA_VTBL_ENTRYr_t ARLA_VTBL_ENTRYr_t;
#define ARLA_VTBL_ENTRYr_CLR BCM53128_A0_ARLA_VTBL_ENTRYr_CLR
#define ARLA_VTBL_ENTRYr_SET BCM53128_A0_ARLA_VTBL_ENTRYr_SET
#define ARLA_VTBL_ENTRYr_GET BCM53128_A0_ARLA_VTBL_ENTRYr_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_GET BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_SET BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET BCM53128_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET BCM53128_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET BCM53128_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET BCM53128_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_GET BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_SET BCM53128_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET
#define ARLA_VTBL_ENTRYr_RESERVEDf_GET BCM53128_A0_ARLA_VTBL_ENTRYr_RESERVEDf_GET
#define ARLA_VTBL_ENTRYr_RESERVEDf_SET BCM53128_A0_ARLA_VTBL_ENTRYr_RESERVEDf_SET
#define READ_ARLA_VTBL_ENTRYr BCM53128_A0_READ_ARLA_VTBL_ENTRYr
#define WRITE_ARLA_VTBL_ENTRYr BCM53128_A0_WRITE_ARLA_VTBL_ENTRYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_VTBL_ENTRYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ARLA_VTBL_RWCTRL
 * BLOCKS:   SYS
 * DESC:     VTBL Read/Write/Clear Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_VTBL_RW_CLR VTBL Read/Write/Clear-table11 = Reserved10 = Clear-table01 = Read00 = Write
 *     RESERVED         Reserved
 *     ARLA_VTBL_STDN   Start/Done.Write as 1 to initiate a read or write or clear-table command.For Read or Write Command, the VTBL Address Index register should be loaded with the VLAN ID for which the VTBL entry is to be read or written.Blackbird2 will reset the bit to indicate a write operation completed or a read operation has completed and data from the bin entry is available in VTBL Entry, or a clear-table operation has completed.
 *
 ******************************************************************************/
#define BCM53128_A0_ARLA_VTBL_RWCTRLr 0x00000580

#define BCM53128_A0_ARLA_VTBL_RWCTRLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_VTBL_RWCTRL.
 *
 */
typedef union BCM53128_A0_ARLA_VTBL_RWCTRLr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_rwctrl[1];
	uint32_t _arla_vtbl_rwctrl;
} BCM53128_A0_ARLA_VTBL_RWCTRLr_t;

#define BCM53128_A0_ARLA_VTBL_RWCTRLr_CLR(r) (r).arla_vtbl_rwctrl[0] = 0
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_SET(r,d) (r).arla_vtbl_rwctrl[0] = d
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_GET(r) (r).arla_vtbl_rwctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET(r) (((r).arla_vtbl_rwctrl[0]) & 0x3)
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 2) & 0x1f)
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_VTBL_RWCTRL.
 *
 */
#define BCM53128_A0_READ_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ARLA_VTBL_RWCTRLr,(r._arla_vtbl_rwctrl),1)
#define BCM53128_A0_WRITE_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ARLA_VTBL_RWCTRLr,&(r._arla_vtbl_rwctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_RWCTRLr BCM53128_A0_ARLA_VTBL_RWCTRLr
#define ARLA_VTBL_RWCTRLr_SIZE BCM53128_A0_ARLA_VTBL_RWCTRLr_SIZE
typedef BCM53128_A0_ARLA_VTBL_RWCTRLr_t ARLA_VTBL_RWCTRLr_t;
#define ARLA_VTBL_RWCTRLr_CLR BCM53128_A0_ARLA_VTBL_RWCTRLr_CLR
#define ARLA_VTBL_RWCTRLr_SET BCM53128_A0_ARLA_VTBL_RWCTRLr_SET
#define ARLA_VTBL_RWCTRLr_GET BCM53128_A0_ARLA_VTBL_RWCTRLr_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET
#define ARLA_VTBL_RWCTRLr_RESERVEDf_GET BCM53128_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_GET
#define ARLA_VTBL_RWCTRLr_RESERVEDf_SET BCM53128_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_SET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET BCM53128_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET
#define READ_ARLA_VTBL_RWCTRLr BCM53128_A0_READ_ARLA_VTBL_RWCTRLr
#define WRITE_ARLA_VTBL_RWCTRLr BCM53128_A0_WRITE_ARLA_VTBL_RWCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ARLA_VTBL_RWCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_AV_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     AVB AV Enable Control Register
 * SIZE:     16
 * FIELDS:
 *     AV_EN            AV enableThis field to define AV enable of each port.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_AV_EN_CTRLr 0x00009000

#define BCM53128_A0_AVB_AV_EN_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program AVB_AV_EN_CTRL.
 *
 */
typedef union BCM53128_A0_AVB_AV_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t avb_av_en_ctrl[1];
	uint32_t _avb_av_en_ctrl;
} BCM53128_A0_AVB_AV_EN_CTRLr_t;

#define BCM53128_A0_AVB_AV_EN_CTRLr_CLR(r) (r).avb_av_en_ctrl[0] = 0
#define BCM53128_A0_AVB_AV_EN_CTRLr_SET(r,d) (r).avb_av_en_ctrl[0] = d
#define BCM53128_A0_AVB_AV_EN_CTRLr_GET(r) (r).avb_av_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_AV_EN_CTRLr_AV_ENf_GET(r) (((r).avb_av_en_ctrl[0]) & 0xff)
#define BCM53128_A0_AVB_AV_EN_CTRLr_AV_ENf_SET(r,f) (r).avb_av_en_ctrl[0]=(((r).avb_av_en_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_AVB_AV_EN_CTRLr_RESERVEDf_GET(r) ((((r).avb_av_en_ctrl[0]) >> 8) & 0xff)
#define BCM53128_A0_AVB_AV_EN_CTRLr_RESERVEDf_SET(r,f) (r).avb_av_en_ctrl[0]=(((r).avb_av_en_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access AVB_AV_EN_CTRL.
 *
 */
#define BCM53128_A0_READ_AVB_AV_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_AVB_AV_EN_CTRLr,(r._avb_av_en_ctrl),2)
#define BCM53128_A0_WRITE_AVB_AV_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_AVB_AV_EN_CTRLr,&(r._avb_av_en_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_AV_EN_CTRLr BCM53128_A0_AVB_AV_EN_CTRLr
#define AVB_AV_EN_CTRLr_SIZE BCM53128_A0_AVB_AV_EN_CTRLr_SIZE
typedef BCM53128_A0_AVB_AV_EN_CTRLr_t AVB_AV_EN_CTRLr_t;
#define AVB_AV_EN_CTRLr_CLR BCM53128_A0_AVB_AV_EN_CTRLr_CLR
#define AVB_AV_EN_CTRLr_SET BCM53128_A0_AVB_AV_EN_CTRLr_SET
#define AVB_AV_EN_CTRLr_GET BCM53128_A0_AVB_AV_EN_CTRLr_GET
#define AVB_AV_EN_CTRLr_AV_ENf_GET BCM53128_A0_AVB_AV_EN_CTRLr_AV_ENf_GET
#define AVB_AV_EN_CTRLr_AV_ENf_SET BCM53128_A0_AVB_AV_EN_CTRLr_AV_ENf_SET
#define AVB_AV_EN_CTRLr_RESERVEDf_GET BCM53128_A0_AVB_AV_EN_CTRLr_RESERVEDf_GET
#define AVB_AV_EN_CTRLr_RESERVEDf_SET BCM53128_A0_AVB_AV_EN_CTRLr_RESERVEDf_SET
#define READ_AVB_AV_EN_CTRLr BCM53128_A0_READ_AVB_AV_EN_CTRLr
#define WRITE_AVB_AV_EN_CTRLr BCM53128_A0_WRITE_AVB_AV_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_AV_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_C4_BW_CNTL
 * BLOCKS:   GPIC0
 * DESC:     AVB Class 4 Bandwidth Control Register  
 * SIZE:     16
 * FIELDS:
 *     C4_BW            Class 4 Bandwidth for port NThis field defines the byte count allowed for Class 4 traffic transmission within a slot time.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_C4_BW_CNTLr 0x00009060

#define BCM53128_A0_AVB_C4_BW_CNTLr_SIZE 2

/*
 * This structure should be used to declare and program AVB_C4_BW_CNTL.
 *
 */
typedef union BCM53128_A0_AVB_C4_BW_CNTLr_s {
	uint32_t v[1];
	uint32_t avb_c4_bw_cntl[1];
	uint32_t _avb_c4_bw_cntl;
} BCM53128_A0_AVB_C4_BW_CNTLr_t;

#define BCM53128_A0_AVB_C4_BW_CNTLr_CLR(r) (r).avb_c4_bw_cntl[0] = 0
#define BCM53128_A0_AVB_C4_BW_CNTLr_SET(r,d) (r).avb_c4_bw_cntl[0] = d
#define BCM53128_A0_AVB_C4_BW_CNTLr_GET(r) (r).avb_c4_bw_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_C4_BW_CNTLr_C4_BWf_GET(r) (((r).avb_c4_bw_cntl[0]) & 0x3fff)
#define BCM53128_A0_AVB_C4_BW_CNTLr_C4_BWf_SET(r,f) (r).avb_c4_bw_cntl[0]=(((r).avb_c4_bw_cntl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53128_A0_AVB_C4_BW_CNTLr_RESERVEDf_GET(r) ((((r).avb_c4_bw_cntl[0]) >> 14) & 0x3)
#define BCM53128_A0_AVB_C4_BW_CNTLr_RESERVEDf_SET(r,f) (r).avb_c4_bw_cntl[0]=(((r).avb_c4_bw_cntl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access AVB_C4_BW_CNTL.
 *
 */
#define BCM53128_A0_READ_AVB_C4_BW_CNTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_AVB_C4_BW_CNTLr,(r._avb_c4_bw_cntl),2)
#define BCM53128_A0_WRITE_AVB_C4_BW_CNTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_AVB_C4_BW_CNTLr,&(r._avb_c4_bw_cntl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_C4_BW_CNTLr BCM53128_A0_AVB_C4_BW_CNTLr
#define AVB_C4_BW_CNTLr_SIZE BCM53128_A0_AVB_C4_BW_CNTLr_SIZE
typedef BCM53128_A0_AVB_C4_BW_CNTLr_t AVB_C4_BW_CNTLr_t;
#define AVB_C4_BW_CNTLr_CLR BCM53128_A0_AVB_C4_BW_CNTLr_CLR
#define AVB_C4_BW_CNTLr_SET BCM53128_A0_AVB_C4_BW_CNTLr_SET
#define AVB_C4_BW_CNTLr_GET BCM53128_A0_AVB_C4_BW_CNTLr_GET
#define AVB_C4_BW_CNTLr_C4_BWf_GET BCM53128_A0_AVB_C4_BW_CNTLr_C4_BWf_GET
#define AVB_C4_BW_CNTLr_C4_BWf_SET BCM53128_A0_AVB_C4_BW_CNTLr_C4_BWf_SET
#define AVB_C4_BW_CNTLr_RESERVEDf_GET BCM53128_A0_AVB_C4_BW_CNTLr_RESERVEDf_GET
#define AVB_C4_BW_CNTLr_RESERVEDf_SET BCM53128_A0_AVB_C4_BW_CNTLr_RESERVEDf_SET
#define READ_AVB_C4_BW_CNTLr BCM53128_A0_READ_AVB_C4_BW_CNTLr
#define WRITE_AVB_C4_BW_CNTLr BCM53128_A0_WRITE_AVB_C4_BW_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_C4_BW_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_C5_BW_CNTL
 * BLOCKS:   GPIC0
 * DESC:     AVB Class 5 Bandwidth Control Register  
 * SIZE:     16
 * FIELDS:
 *     C5_BW            Class 5 Bandwidth for port NThis field defines the byte count allowed for Class 5 traffic transmission within a slot time.
 *     RESERVED         Reserved
 *     C5_WNDW          Class 5 traffic  Credit Carry-over control for port NThe purpose is to control the credit carry-over under different link speed. For 100M link, the 125us slot is too small such that AVB packet could easily "slip slot", so the credit carry-over should be allowed. For 1G link, 125us slot is reasonably big such that the BW reservation could be done in a conservative way to prevent "slot slipping", so credit carry-over is not needed.
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_C5_BW_CNTLr 0x00009030

#define BCM53128_A0_AVB_C5_BW_CNTLr_SIZE 2

/*
 * This structure should be used to declare and program AVB_C5_BW_CNTL.
 *
 */
typedef union BCM53128_A0_AVB_C5_BW_CNTLr_s {
	uint32_t v[1];
	uint32_t avb_c5_bw_cntl[1];
	uint32_t _avb_c5_bw_cntl;
} BCM53128_A0_AVB_C5_BW_CNTLr_t;

#define BCM53128_A0_AVB_C5_BW_CNTLr_CLR(r) (r).avb_c5_bw_cntl[0] = 0
#define BCM53128_A0_AVB_C5_BW_CNTLr_SET(r,d) (r).avb_c5_bw_cntl[0] = d
#define BCM53128_A0_AVB_C5_BW_CNTLr_GET(r) (r).avb_c5_bw_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_C5_BW_CNTLr_C5_BWf_GET(r) (((r).avb_c5_bw_cntl[0]) & 0x3fff)
#define BCM53128_A0_AVB_C5_BW_CNTLr_C5_BWf_SET(r,f) (r).avb_c5_bw_cntl[0]=(((r).avb_c5_bw_cntl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53128_A0_AVB_C5_BW_CNTLr_RESERVEDf_GET(r) ((((r).avb_c5_bw_cntl[0]) >> 14) & 0x1)
#define BCM53128_A0_AVB_C5_BW_CNTLr_RESERVEDf_SET(r,f) (r).avb_c5_bw_cntl[0]=(((r).avb_c5_bw_cntl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_AVB_C5_BW_CNTLr_C5_WNDWf_GET(r) ((((r).avb_c5_bw_cntl[0]) >> 15) & 0x1)
#define BCM53128_A0_AVB_C5_BW_CNTLr_C5_WNDWf_SET(r,f) (r).avb_c5_bw_cntl[0]=(((r).avb_c5_bw_cntl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AVB_C5_BW_CNTL.
 *
 */
#define BCM53128_A0_READ_AVB_C5_BW_CNTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_AVB_C5_BW_CNTLr,(r._avb_c5_bw_cntl),2)
#define BCM53128_A0_WRITE_AVB_C5_BW_CNTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_AVB_C5_BW_CNTLr,&(r._avb_c5_bw_cntl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_C5_BW_CNTLr BCM53128_A0_AVB_C5_BW_CNTLr
#define AVB_C5_BW_CNTLr_SIZE BCM53128_A0_AVB_C5_BW_CNTLr_SIZE
typedef BCM53128_A0_AVB_C5_BW_CNTLr_t AVB_C5_BW_CNTLr_t;
#define AVB_C5_BW_CNTLr_CLR BCM53128_A0_AVB_C5_BW_CNTLr_CLR
#define AVB_C5_BW_CNTLr_SET BCM53128_A0_AVB_C5_BW_CNTLr_SET
#define AVB_C5_BW_CNTLr_GET BCM53128_A0_AVB_C5_BW_CNTLr_GET
#define AVB_C5_BW_CNTLr_C5_BWf_GET BCM53128_A0_AVB_C5_BW_CNTLr_C5_BWf_GET
#define AVB_C5_BW_CNTLr_C5_BWf_SET BCM53128_A0_AVB_C5_BW_CNTLr_C5_BWf_SET
#define AVB_C5_BW_CNTLr_RESERVEDf_GET BCM53128_A0_AVB_C5_BW_CNTLr_RESERVEDf_GET
#define AVB_C5_BW_CNTLr_RESERVEDf_SET BCM53128_A0_AVB_C5_BW_CNTLr_RESERVEDf_SET
#define AVB_C5_BW_CNTLr_C5_WNDWf_GET BCM53128_A0_AVB_C5_BW_CNTLr_C5_WNDWf_GET
#define AVB_C5_BW_CNTLr_C5_WNDWf_SET BCM53128_A0_AVB_C5_BW_CNTLr_C5_WNDWf_SET
#define READ_AVB_C5_BW_CNTLr BCM53128_A0_READ_AVB_C5_BW_CNTLr
#define WRITE_AVB_C5_BW_CNTLr BCM53128_A0_WRITE_AVB_C5_BW_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_C5_BW_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_EGRESS_TM_STAMP
 * BLOCKS:   GPIC0
 * DESC:     AVB Egress Time Stamp Register 
 * SIZE:     32
 * FIELDS:
 *     EGRESS_TS_TM_STAMP Egress Time Sync. Packet Time StampThis field reports the time stamp of egress time sync. packet. It use 32-bit time base as time stamping. The time between the departure of first byte of MAC DA and the time stamping point should be constant.
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_EGRESS_TM_STAMPr 0x00009090

#define BCM53128_A0_AVB_EGRESS_TM_STAMPr_SIZE 4

/*
 * This structure should be used to declare and program AVB_EGRESS_TM_STAMP.
 *
 */
typedef union BCM53128_A0_AVB_EGRESS_TM_STAMPr_s {
	uint32_t v[1];
	uint32_t avb_egress_tm_stamp[1];
	uint32_t _avb_egress_tm_stamp;
} BCM53128_A0_AVB_EGRESS_TM_STAMPr_t;

#define BCM53128_A0_AVB_EGRESS_TM_STAMPr_CLR(r) (r).avb_egress_tm_stamp[0] = 0
#define BCM53128_A0_AVB_EGRESS_TM_STAMPr_SET(r,d) (r).avb_egress_tm_stamp[0] = d
#define BCM53128_A0_AVB_EGRESS_TM_STAMPr_GET(r) (r).avb_egress_tm_stamp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET(r) ((r).avb_egress_tm_stamp[0])
#define BCM53128_A0_AVB_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET(r,f) (r).avb_egress_tm_stamp[0]=((uint32_t)f)

/*
 * These macros can be used to access AVB_EGRESS_TM_STAMP.
 *
 */
#define BCM53128_A0_READ_AVB_EGRESS_TM_STAMPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_AVB_EGRESS_TM_STAMPr,(r._avb_egress_tm_stamp),4)
#define BCM53128_A0_WRITE_AVB_EGRESS_TM_STAMPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_AVB_EGRESS_TM_STAMPr,&(r._avb_egress_tm_stamp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_EGRESS_TM_STAMPr BCM53128_A0_AVB_EGRESS_TM_STAMPr
#define AVB_EGRESS_TM_STAMPr_SIZE BCM53128_A0_AVB_EGRESS_TM_STAMPr_SIZE
typedef BCM53128_A0_AVB_EGRESS_TM_STAMPr_t AVB_EGRESS_TM_STAMPr_t;
#define AVB_EGRESS_TM_STAMPr_CLR BCM53128_A0_AVB_EGRESS_TM_STAMPr_CLR
#define AVB_EGRESS_TM_STAMPr_SET BCM53128_A0_AVB_EGRESS_TM_STAMPr_SET
#define AVB_EGRESS_TM_STAMPr_GET BCM53128_A0_AVB_EGRESS_TM_STAMPr_GET
#define AVB_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET BCM53128_A0_AVB_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET
#define AVB_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET BCM53128_A0_AVB_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET
#define READ_AVB_EGRESS_TM_STAMPr BCM53128_A0_READ_AVB_EGRESS_TM_STAMPr
#define WRITE_AVB_EGRESS_TM_STAMPr BCM53128_A0_WRITE_AVB_EGRESS_TM_STAMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_EGRESS_TM_STAMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_MAX_AV_PKT_SZ
 * BLOCKS:   SYS
 * DESC:     AVB MAX AV Packet Size Register
 * SIZE:     16
 * FIELDS:
 *     MAX_AV_PKT_SZ    Max.AV Packet SizeThis field is to define the max packet size of AV packet (Residential Ethernet).  The ingress port uses it to qualify if the packet is allowed to pass through an AV link. The egress port uses it to perform shaping gate.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr 0x00009004

#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_SIZE 2

/*
 * This structure should be used to declare and program AVB_MAX_AV_PKT_SZ.
 *
 */
typedef union BCM53128_A0_AVB_MAX_AV_PKT_SZr_s {
	uint32_t v[1];
	uint32_t avb_max_av_pkt_sz[1];
	uint32_t _avb_max_av_pkt_sz;
} BCM53128_A0_AVB_MAX_AV_PKT_SZr_t;

#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_CLR(r) (r).avb_max_av_pkt_sz[0] = 0
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_SET(r,d) (r).avb_max_av_pkt_sz[0] = d
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_GET(r) (r).avb_max_av_pkt_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET(r) (((r).avb_max_av_pkt_sz[0]) & 0xfff)
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET(r,f) (r).avb_max_av_pkt_sz[0]=(((r).avb_max_av_pkt_sz[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_GET(r) ((((r).avb_max_av_pkt_sz[0]) >> 12) & 0xf)
#define BCM53128_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_SET(r,f) (r).avb_max_av_pkt_sz[0]=(((r).avb_max_av_pkt_sz[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access AVB_MAX_AV_PKT_SZ.
 *
 */
#define BCM53128_A0_READ_AVB_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_read(u,BCM53128_A0_AVB_MAX_AV_PKT_SZr,(r._avb_max_av_pkt_sz),2)
#define BCM53128_A0_WRITE_AVB_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_write(u,BCM53128_A0_AVB_MAX_AV_PKT_SZr,&(r._avb_max_av_pkt_sz),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_MAX_AV_PKT_SZr BCM53128_A0_AVB_MAX_AV_PKT_SZr
#define AVB_MAX_AV_PKT_SZr_SIZE BCM53128_A0_AVB_MAX_AV_PKT_SZr_SIZE
typedef BCM53128_A0_AVB_MAX_AV_PKT_SZr_t AVB_MAX_AV_PKT_SZr_t;
#define AVB_MAX_AV_PKT_SZr_CLR BCM53128_A0_AVB_MAX_AV_PKT_SZr_CLR
#define AVB_MAX_AV_PKT_SZr_SET BCM53128_A0_AVB_MAX_AV_PKT_SZr_SET
#define AVB_MAX_AV_PKT_SZr_GET BCM53128_A0_AVB_MAX_AV_PKT_SZr_GET
#define AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET BCM53128_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET
#define AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET BCM53128_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET
#define AVB_MAX_AV_PKT_SZr_RESERVEDf_GET BCM53128_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_GET
#define AVB_MAX_AV_PKT_SZr_RESERVEDf_SET BCM53128_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_SET
#define READ_AVB_MAX_AV_PKT_SZr BCM53128_A0_READ_AVB_MAX_AV_PKT_SZr
#define WRITE_AVB_MAX_AV_PKT_SZr BCM53128_A0_WRITE_AVB_MAX_AV_PKT_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_MAX_AV_PKT_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_SLOT_ADJ
 * BLOCKS:   SYS
 * DESC:     AVB Slot Adjustment Register
 * SIZE:     32
 * FIELDS:
 *     SLOT_ADJ         Slot AdjustmentThis field defines when the Slot Number Counter increment by 1.Default is 40.00: Slot Number increment by 1 when tick counter rolls over 312501:312610:312411: Reserved
 *     RESERVED_2       Reserved
 *     SLOT_ADJ_PRD     Slot Adjust PeriodThis field defines the number of Slots to apply the altered SlotAdjustment.
 *     RESERVED_1       Reserved
 *     MCRO_SLOT_PRD    Macro Slot PeriodThis field defines the slot time of a Macro slot for Class 4 traffic.00: 1 ms01: 2 ms10: 4 ms11: reservedClass 5 traffic slot time is always 125 us period.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_SLOT_ADJr 0x0000901c

#define BCM53128_A0_AVB_SLOT_ADJr_SIZE 4

/*
 * This structure should be used to declare and program AVB_SLOT_ADJ.
 *
 */
typedef union BCM53128_A0_AVB_SLOT_ADJr_s {
	uint32_t v[1];
	uint32_t avb_slot_adj[1];
	uint32_t _avb_slot_adj;
} BCM53128_A0_AVB_SLOT_ADJr_t;

#define BCM53128_A0_AVB_SLOT_ADJr_CLR(r) (r).avb_slot_adj[0] = 0
#define BCM53128_A0_AVB_SLOT_ADJr_SET(r,d) (r).avb_slot_adj[0] = d
#define BCM53128_A0_AVB_SLOT_ADJr_GET(r) (r).avb_slot_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJf_GET(r) (((r).avb_slot_adj[0]) & 0x3)
#define BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJf_SET(r,f) (r).avb_slot_adj[0]=(((r).avb_slot_adj[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_AVB_SLOT_ADJr_RESERVED_2f_GET(r) ((((r).avb_slot_adj[0]) >> 2) & 0x3f)
#define BCM53128_A0_AVB_SLOT_ADJr_RESERVED_2f_SET(r,f) (r).avb_slot_adj[0]=(((r).avb_slot_adj[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJ_PRDf_GET(r) ((((r).avb_slot_adj[0]) >> 8) & 0xf)
#define BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJ_PRDf_SET(r,f) (r).avb_slot_adj[0]=(((r).avb_slot_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53128_A0_AVB_SLOT_ADJr_RESERVED_1f_GET(r) ((((r).avb_slot_adj[0]) >> 12) & 0xf)
#define BCM53128_A0_AVB_SLOT_ADJr_RESERVED_1f_SET(r,f) (r).avb_slot_adj[0]=(((r).avb_slot_adj[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53128_A0_AVB_SLOT_ADJr_MCRO_SLOT_PRDf_GET(r) ((((r).avb_slot_adj[0]) >> 16) & 0x3)
#define BCM53128_A0_AVB_SLOT_ADJr_MCRO_SLOT_PRDf_SET(r,f) (r).avb_slot_adj[0]=(((r).avb_slot_adj[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_AVB_SLOT_ADJr_RESERVED_0f_GET(r) ((((r).avb_slot_adj[0]) >> 18) & 0x3fff)
#define BCM53128_A0_AVB_SLOT_ADJr_RESERVED_0f_SET(r,f) (r).avb_slot_adj[0]=(((r).avb_slot_adj[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access AVB_SLOT_ADJ.
 *
 */
#define BCM53128_A0_READ_AVB_SLOT_ADJr(u,r) cdk_robo_reg_read(u,BCM53128_A0_AVB_SLOT_ADJr,(r._avb_slot_adj),4)
#define BCM53128_A0_WRITE_AVB_SLOT_ADJr(u,r) cdk_robo_reg_write(u,BCM53128_A0_AVB_SLOT_ADJr,&(r._avb_slot_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_SLOT_ADJr BCM53128_A0_AVB_SLOT_ADJr
#define AVB_SLOT_ADJr_SIZE BCM53128_A0_AVB_SLOT_ADJr_SIZE
typedef BCM53128_A0_AVB_SLOT_ADJr_t AVB_SLOT_ADJr_t;
#define AVB_SLOT_ADJr_CLR BCM53128_A0_AVB_SLOT_ADJr_CLR
#define AVB_SLOT_ADJr_SET BCM53128_A0_AVB_SLOT_ADJr_SET
#define AVB_SLOT_ADJr_GET BCM53128_A0_AVB_SLOT_ADJr_GET
#define AVB_SLOT_ADJr_SLOT_ADJf_GET BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJf_GET
#define AVB_SLOT_ADJr_SLOT_ADJf_SET BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJf_SET
#define AVB_SLOT_ADJr_RESERVED_2f_GET BCM53128_A0_AVB_SLOT_ADJr_RESERVED_2f_GET
#define AVB_SLOT_ADJr_RESERVED_2f_SET BCM53128_A0_AVB_SLOT_ADJr_RESERVED_2f_SET
#define AVB_SLOT_ADJr_SLOT_ADJ_PRDf_GET BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJ_PRDf_GET
#define AVB_SLOT_ADJr_SLOT_ADJ_PRDf_SET BCM53128_A0_AVB_SLOT_ADJr_SLOT_ADJ_PRDf_SET
#define AVB_SLOT_ADJr_RESERVED_1f_GET BCM53128_A0_AVB_SLOT_ADJr_RESERVED_1f_GET
#define AVB_SLOT_ADJr_RESERVED_1f_SET BCM53128_A0_AVB_SLOT_ADJr_RESERVED_1f_SET
#define AVB_SLOT_ADJr_MCRO_SLOT_PRDf_GET BCM53128_A0_AVB_SLOT_ADJr_MCRO_SLOT_PRDf_GET
#define AVB_SLOT_ADJr_MCRO_SLOT_PRDf_SET BCM53128_A0_AVB_SLOT_ADJr_MCRO_SLOT_PRDf_SET
#define AVB_SLOT_ADJr_RESERVED_0f_GET BCM53128_A0_AVB_SLOT_ADJr_RESERVED_0f_GET
#define AVB_SLOT_ADJr_RESERVED_0f_SET BCM53128_A0_AVB_SLOT_ADJr_RESERVED_0f_SET
#define READ_AVB_SLOT_ADJr BCM53128_A0_READ_AVB_SLOT_ADJr
#define WRITE_AVB_SLOT_ADJr BCM53128_A0_WRITE_AVB_SLOT_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_SLOT_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_SLOT_TICK_CNTR
 * BLOCKS:   SYS
 * DESC:     AVB Slot Number and Tick Counter Register
 * SIZE:     32
 * FIELDS:
 *     SLOT_NUM         Slot NumberThis field specifies the Slot Number for ResE.
 *     RESERVED_1       Reserved
 *     TICK_CNTR        Tick CounterThis is the tick counter which defines when will Slot Number increment. It runs from 1 to 3125 (or 3124, or 3126, depends on Slot Adjustment register setting) under 25MHz.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr 0x00009018

#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_SIZE 4

/*
 * This structure should be used to declare and program AVB_SLOT_TICK_CNTR.
 *
 */
typedef union BCM53128_A0_AVB_SLOT_TICK_CNTRr_s {
	uint32_t v[1];
	uint32_t avb_slot_tick_cntr[1];
	uint32_t _avb_slot_tick_cntr;
} BCM53128_A0_AVB_SLOT_TICK_CNTRr_t;

#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_CLR(r) (r).avb_slot_tick_cntr[0] = 0
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_SET(r,d) (r).avb_slot_tick_cntr[0] = d
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_GET(r) (r).avb_slot_tick_cntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_SLOT_NUMf_GET(r) (((r).avb_slot_tick_cntr[0]) & 0x1f)
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_SLOT_NUMf_SET(r,f) (r).avb_slot_tick_cntr[0]=(((r).avb_slot_tick_cntr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_1f_GET(r) ((((r).avb_slot_tick_cntr[0]) >> 5) & 0x7ff)
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_1f_SET(r,f) (r).avb_slot_tick_cntr[0]=(((r).avb_slot_tick_cntr[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_TICK_CNTRf_GET(r) ((((r).avb_slot_tick_cntr[0]) >> 16) & 0xfff)
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_TICK_CNTRf_SET(r,f) (r).avb_slot_tick_cntr[0]=(((r).avb_slot_tick_cntr[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_0f_GET(r) ((((r).avb_slot_tick_cntr[0]) >> 28) & 0xf)
#define BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_0f_SET(r,f) (r).avb_slot_tick_cntr[0]=(((r).avb_slot_tick_cntr[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access AVB_SLOT_TICK_CNTR.
 *
 */
#define BCM53128_A0_READ_AVB_SLOT_TICK_CNTRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_AVB_SLOT_TICK_CNTRr,(r._avb_slot_tick_cntr),4)
#define BCM53128_A0_WRITE_AVB_SLOT_TICK_CNTRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_AVB_SLOT_TICK_CNTRr,&(r._avb_slot_tick_cntr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_SLOT_TICK_CNTRr BCM53128_A0_AVB_SLOT_TICK_CNTRr
#define AVB_SLOT_TICK_CNTRr_SIZE BCM53128_A0_AVB_SLOT_TICK_CNTRr_SIZE
typedef BCM53128_A0_AVB_SLOT_TICK_CNTRr_t AVB_SLOT_TICK_CNTRr_t;
#define AVB_SLOT_TICK_CNTRr_CLR BCM53128_A0_AVB_SLOT_TICK_CNTRr_CLR
#define AVB_SLOT_TICK_CNTRr_SET BCM53128_A0_AVB_SLOT_TICK_CNTRr_SET
#define AVB_SLOT_TICK_CNTRr_GET BCM53128_A0_AVB_SLOT_TICK_CNTRr_GET
#define AVB_SLOT_TICK_CNTRr_SLOT_NUMf_GET BCM53128_A0_AVB_SLOT_TICK_CNTRr_SLOT_NUMf_GET
#define AVB_SLOT_TICK_CNTRr_SLOT_NUMf_SET BCM53128_A0_AVB_SLOT_TICK_CNTRr_SLOT_NUMf_SET
#define AVB_SLOT_TICK_CNTRr_RESERVED_1f_GET BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_1f_GET
#define AVB_SLOT_TICK_CNTRr_RESERVED_1f_SET BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_1f_SET
#define AVB_SLOT_TICK_CNTRr_TICK_CNTRf_GET BCM53128_A0_AVB_SLOT_TICK_CNTRr_TICK_CNTRf_GET
#define AVB_SLOT_TICK_CNTRr_TICK_CNTRf_SET BCM53128_A0_AVB_SLOT_TICK_CNTRr_TICK_CNTRf_SET
#define AVB_SLOT_TICK_CNTRr_RESERVED_0f_GET BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_0f_GET
#define AVB_SLOT_TICK_CNTRr_RESERVED_0f_SET BCM53128_A0_AVB_SLOT_TICK_CNTRr_RESERVED_0f_SET
#define READ_AVB_SLOT_TICK_CNTRr BCM53128_A0_READ_AVB_SLOT_TICK_CNTRr
#define WRITE_AVB_SLOT_TICK_CNTRr BCM53128_A0_WRITE_AVB_SLOT_TICK_CNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_SLOT_TICK_CNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_TM_ADJ
 * BLOCKS:   SYS
 * DESC:     AVB Time Base Adjustment Register
 * SIZE:     32
 * FIELDS:
 *     TM_INC           Time IncrementThis field defines the value to add into Time Base in each 25Mhz tick when AVB time should be adjusted.
 *     RESERVED_1       Reserved
 *     TM_ADJ_PRD       Time Adjust PeriodThis field defines the tick numbers to apply the adjusted Time Increment (when Time Increment does not equal to 40). For example, increment the Time Base 41 for 10 ticks. In this case, Time Adjust Period is 10, and Time Increment is 41.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_TM_ADJr 0x00009014

#define BCM53128_A0_AVB_TM_ADJr_SIZE 4

/*
 * This structure should be used to declare and program AVB_TM_ADJ.
 *
 */
typedef union BCM53128_A0_AVB_TM_ADJr_s {
	uint32_t v[1];
	uint32_t avb_tm_adj[1];
	uint32_t _avb_tm_adj;
} BCM53128_A0_AVB_TM_ADJr_t;

#define BCM53128_A0_AVB_TM_ADJr_CLR(r) (r).avb_tm_adj[0] = 0
#define BCM53128_A0_AVB_TM_ADJr_SET(r,d) (r).avb_tm_adj[0] = d
#define BCM53128_A0_AVB_TM_ADJr_GET(r) (r).avb_tm_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_TM_ADJr_TM_INCf_GET(r) (((r).avb_tm_adj[0]) & 0x3f)
#define BCM53128_A0_AVB_TM_ADJr_TM_INCf_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_AVB_TM_ADJr_RESERVED_1f_GET(r) ((((r).avb_tm_adj[0]) >> 6) & 0x3)
#define BCM53128_A0_AVB_TM_ADJr_RESERVED_1f_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53128_A0_AVB_TM_ADJr_TM_ADJ_PRDf_GET(r) ((((r).avb_tm_adj[0]) >> 8) & 0xf)
#define BCM53128_A0_AVB_TM_ADJr_TM_ADJ_PRDf_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53128_A0_AVB_TM_ADJr_RESERVED_0f_GET(r) ((((r).avb_tm_adj[0]) >> 12) & 0xfffff)
#define BCM53128_A0_AVB_TM_ADJr_RESERVED_0f_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0xfffff << 12)) | ((((uint32_t)f) & 0xfffff) << 12))

/*
 * These macros can be used to access AVB_TM_ADJ.
 *
 */
#define BCM53128_A0_READ_AVB_TM_ADJr(u,r) cdk_robo_reg_read(u,BCM53128_A0_AVB_TM_ADJr,(r._avb_tm_adj),4)
#define BCM53128_A0_WRITE_AVB_TM_ADJr(u,r) cdk_robo_reg_write(u,BCM53128_A0_AVB_TM_ADJr,&(r._avb_tm_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_TM_ADJr BCM53128_A0_AVB_TM_ADJr
#define AVB_TM_ADJr_SIZE BCM53128_A0_AVB_TM_ADJr_SIZE
typedef BCM53128_A0_AVB_TM_ADJr_t AVB_TM_ADJr_t;
#define AVB_TM_ADJr_CLR BCM53128_A0_AVB_TM_ADJr_CLR
#define AVB_TM_ADJr_SET BCM53128_A0_AVB_TM_ADJr_SET
#define AVB_TM_ADJr_GET BCM53128_A0_AVB_TM_ADJr_GET
#define AVB_TM_ADJr_TM_INCf_GET BCM53128_A0_AVB_TM_ADJr_TM_INCf_GET
#define AVB_TM_ADJr_TM_INCf_SET BCM53128_A0_AVB_TM_ADJr_TM_INCf_SET
#define AVB_TM_ADJr_RESERVED_1f_GET BCM53128_A0_AVB_TM_ADJr_RESERVED_1f_GET
#define AVB_TM_ADJr_RESERVED_1f_SET BCM53128_A0_AVB_TM_ADJr_RESERVED_1f_SET
#define AVB_TM_ADJr_TM_ADJ_PRDf_GET BCM53128_A0_AVB_TM_ADJr_TM_ADJ_PRDf_GET
#define AVB_TM_ADJr_TM_ADJ_PRDf_SET BCM53128_A0_AVB_TM_ADJr_TM_ADJ_PRDf_SET
#define AVB_TM_ADJr_RESERVED_0f_GET BCM53128_A0_AVB_TM_ADJr_RESERVED_0f_GET
#define AVB_TM_ADJr_RESERVED_0f_SET BCM53128_A0_AVB_TM_ADJr_RESERVED_0f_SET
#define READ_AVB_TM_ADJr BCM53128_A0_READ_AVB_TM_ADJr
#define WRITE_AVB_TM_ADJr BCM53128_A0_WRITE_AVB_TM_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_TM_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  AVB_TM_BASE
 * BLOCKS:   SYS
 * DESC:     AVB Time Base Register
 * SIZE:     32
 * FIELDS:
 *     TM_BASE          Time BaseThis is 32-bit free running clock (running in 25MHz) for AVB time base. Ingress port and Egress port use it for Time Synchronization Packet Time Stamp.The unit is neno-second, The value should be less than 1 second(the maximum value is 32'h3B9ACA00).
 *
 ******************************************************************************/
#define BCM53128_A0_AVB_TM_BASEr 0x00009010

#define BCM53128_A0_AVB_TM_BASEr_SIZE 4

/*
 * This structure should be used to declare and program AVB_TM_BASE.
 *
 */
typedef union BCM53128_A0_AVB_TM_BASEr_s {
	uint32_t v[1];
	uint32_t avb_tm_base[1];
	uint32_t _avb_tm_base;
} BCM53128_A0_AVB_TM_BASEr_t;

#define BCM53128_A0_AVB_TM_BASEr_CLR(r) (r).avb_tm_base[0] = 0
#define BCM53128_A0_AVB_TM_BASEr_SET(r,d) (r).avb_tm_base[0] = d
#define BCM53128_A0_AVB_TM_BASEr_GET(r) (r).avb_tm_base[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_AVB_TM_BASEr_TM_BASEf_GET(r) ((r).avb_tm_base[0])
#define BCM53128_A0_AVB_TM_BASEr_TM_BASEf_SET(r,f) (r).avb_tm_base[0]=((uint32_t)f)

/*
 * These macros can be used to access AVB_TM_BASE.
 *
 */
#define BCM53128_A0_READ_AVB_TM_BASEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_AVB_TM_BASEr,(r._avb_tm_base),4)
#define BCM53128_A0_WRITE_AVB_TM_BASEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_AVB_TM_BASEr,&(r._avb_tm_base),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_TM_BASEr BCM53128_A0_AVB_TM_BASEr
#define AVB_TM_BASEr_SIZE BCM53128_A0_AVB_TM_BASEr_SIZE
typedef BCM53128_A0_AVB_TM_BASEr_t AVB_TM_BASEr_t;
#define AVB_TM_BASEr_CLR BCM53128_A0_AVB_TM_BASEr_CLR
#define AVB_TM_BASEr_SET BCM53128_A0_AVB_TM_BASEr_SET
#define AVB_TM_BASEr_GET BCM53128_A0_AVB_TM_BASEr_GET
#define AVB_TM_BASEr_TM_BASEf_GET BCM53128_A0_AVB_TM_BASEr_TM_BASEf_GET
#define AVB_TM_BASEr_TM_BASEf_SET BCM53128_A0_AVB_TM_BASEr_TM_BASEf_SET
#define READ_AVB_TM_BASEr BCM53128_A0_READ_AVB_TM_BASEr
#define WRITE_AVB_TM_BASEr BCM53128_A0_WRITE_AVB_TM_BASEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_AVB_TM_BASEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr 0x00004170

#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_IMP.
 *
 */
typedef union BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_imp[1];
	uint32_t _bc_sup_pktdrop_cnt_imp;
} BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_t;

#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR(r) (r).bc_sup_pktdrop_cnt_imp[0] = 0
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_SET(r,d) (r).bc_sup_pktdrop_cnt_imp[0] = d
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_GET(r) (r).bc_sup_pktdrop_cnt_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_imp[0])
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_IMP.
 *
 */
#define BCM53128_A0_READ_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr,(r._bc_sup_pktdrop_cnt_imp),4)
#define BCM53128_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr,&(r._bc_sup_pktdrop_cnt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_IMPr BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr
#define BC_SUP_PKTDROP_CNT_IMPr_SIZE BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE
typedef BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_t BC_SUP_PKTDROP_CNT_IMPr_t;
#define BC_SUP_PKTDROP_CNT_IMPr_CLR BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR
#define BC_SUP_PKTDROP_CNT_IMPr_SET BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_SET
#define BC_SUP_PKTDROP_CNT_IMPr_GET BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_IMPr BCM53128_A0_READ_BC_SUP_PKTDROP_CNT_IMPr
#define WRITE_BC_SUP_PKTDROP_CNT_IMPr BCM53128_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BC_SUP_PKTDROP_CNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_P
 * BLOCKS:   GPIC0
 * DESC:     Port N Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr 0x00004150

#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_P.
 *
 */
typedef union BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_p[1];
	uint32_t _bc_sup_pktdrop_cnt_p;
} BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_t;

#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_CLR(r) (r).bc_sup_pktdrop_cnt_p[0] = 0
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_SET(r,d) (r).bc_sup_pktdrop_cnt_p[0] = d
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_GET(r) (r).bc_sup_pktdrop_cnt_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_p[0])
#define BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_p[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_P.
 *
 */
#define BCM53128_A0_READ_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr,(r._bc_sup_pktdrop_cnt_p),4)
#define BCM53128_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr,&(r._bc_sup_pktdrop_cnt_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_Pr BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr
#define BC_SUP_PKTDROP_CNT_Pr_SIZE BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE
typedef BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_t BC_SUP_PKTDROP_CNT_Pr_t;
#define BC_SUP_PKTDROP_CNT_Pr_CLR BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_CLR
#define BC_SUP_PKTDROP_CNT_Pr_SET BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_SET
#define BC_SUP_PKTDROP_CNT_Pr_GET BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_Pr BCM53128_A0_READ_BC_SUP_PKTDROP_CNT_Pr
#define WRITE_BC_SUP_PKTDROP_CNT_Pr BCM53128_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BC_SUP_PKTDROP_CNT_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BC_SUP_RATECTRL_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register. When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that's Bit Rate is 64Kb ~1.792Mb with Resolution 64Kb.29~127:Bit Rate = (Refresh Count-27)*1024, that's Bit Rate is 2Mb~100Mb with Resolution 1Mb.128~240:Bit Rate = (Refresh Count - 115)*1024*8, that's Bit Rate is 104Mb~1000Mb with Resolution 8Mb.When Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that's Bit Rate is 0.08Mb~10Mb with Resolution 0.08Mb.1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that's Bit Rate is 0.8Mb~100Mb with Resolution 0.8Mb.1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that's Bit Rate is 8Mb~1000Mb with Resoultion 8Mb.
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 500K bytes
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register.When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that's Bit Rate is 64Kb ~1.792Mb with Resolution 64Kb.29~127:Bit Rate = (Refresh Count-27)*1024, that's Bit Rate is 2Mb~100Mb with Resolution 1Mb.128~240:Bit Rate = (Refresh Count - 115)*1024*8, that's Bit Rate is 104Mb~1000Mb with Resolution 8Mb.When Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that's Bit Rate is 0.08Mb~10Mb with Resolution 0.08Mb.1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that's Bit Rate is 0.8Mb~100Mb with Resolution 0.8Mb.1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that's Bit Rate is 8Mb~1000Mb with Resoultion 8Mb.
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 500K bytes
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr 0x00004130

#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_IMP.
 *
 */
typedef union BCM53128_A0_BC_SUP_RATECTRL_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_imp[1];
	uint32_t _bc_sup_ratectrl_imp;
} BCM53128_A0_BC_SUP_RATECTRL_IMPr_t;

#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_CLR(r) (r).bc_sup_ratectrl_imp[0] = 0
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_SET(r,d) (r).bc_sup_ratectrl_imp[0] = d
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_GET(r) (r).bc_sup_ratectrl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_imp[0]) & 0xff)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 8) & 0x7)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 11) & 0xff)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 19) & 0x7)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 22) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 23) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 24) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 25) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 26) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 27) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 28) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 29) & 0x7)
#define BCM53128_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_IMP.
 *
 */
#define BCM53128_A0_READ_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_BC_SUP_RATECTRL_IMPr,(r._bc_sup_ratectrl_imp),4)
#define BCM53128_A0_WRITE_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_BC_SUP_RATECTRL_IMPr,&(r._bc_sup_ratectrl_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_IMPr BCM53128_A0_BC_SUP_RATECTRL_IMPr
#define BC_SUP_RATECTRL_IMPr_SIZE BCM53128_A0_BC_SUP_RATECTRL_IMPr_SIZE
typedef BCM53128_A0_BC_SUP_RATECTRL_IMPr_t BC_SUP_RATECTRL_IMPr_t;
#define BC_SUP_RATECTRL_IMPr_CLR BCM53128_A0_BC_SUP_RATECTRL_IMPr_CLR
#define BC_SUP_RATECTRL_IMPr_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_SET
#define BC_SUP_RATECTRL_IMPr_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_RESERVEDf_GET BCM53128_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_GET
#define BC_SUP_RATECTRL_IMPr_RESERVEDf_SET BCM53128_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_IMPr BCM53128_A0_READ_BC_SUP_RATECTRL_IMPr
#define WRITE_BC_SUP_RATECTRL_IMPr BCM53128_A0_WRITE_BC_SUP_RATECTRL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BC_SUP_RATECTRL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BC_SUP_RATECTRL_P
 * BLOCKS:   CPIC GPIC0
 * DESC:     Port N Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register.When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that's Bit Rate is 64Kb ~1.792Mb with Resolution 64Kb.29~127:Bit Rate = (Refresh Count-27)*1024, that's Bit Rate is 2Mb~100Mb with Resolution 1Mb.128~240:Bit Rate = (Refresh Count - 115)*1024*8, that's Bit Rate is 104Mb~1000Mb with Resolution 8Mb.When Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that's Bit Rate is 0.08Mb~10Mb with Resolution 0.08Mb.1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that's Bit Rate is 0.8Mb~100Mb with Resolution 0.8Mb.1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that's Bit Rate is 8Mb~1000Mb with Resoultion 8Mb.
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 500K bytes
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register.When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that's Bit Rate is 64Kb ~1.792Mb with Resolution 64Kb.29~127:Bit Rate = (Refresh Count-27)*1024, that's Bit Rate is 2Mb~100Mb with Resolution 1Mb.128~240:Bit Rate = (Refresh Count - 115)*1024*8, that's Bit Rate is 104Mb~1000Mb with Resolution 8Mb.When Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that's Bit Rate is 0.08Mb~10Mb with Resolution 0.08Mb.1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that's Bit Rate is 0.8Mb~100Mb with Resolution 0.8Mb.1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that's Bit Rate is 8Mb~1000Mb with Resoultion 8Mb.
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 500K bytes
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.1:Enable,0:Disable.
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_BC_SUP_RATECTRL_Pr 0x00004110

#define BCM53128_A0_BC_SUP_RATECTRL_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_P.
 *
 */
typedef union BCM53128_A0_BC_SUP_RATECTRL_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_p[1];
	uint32_t _bc_sup_ratectrl_p;
} BCM53128_A0_BC_SUP_RATECTRL_Pr_t;

#define BCM53128_A0_BC_SUP_RATECTRL_Pr_CLR(r) (r).bc_sup_ratectrl_p[0] = 0
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_SET(r,d) (r).bc_sup_ratectrl_p[0] = d
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_GET(r) (r).bc_sup_ratectrl_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_p[0]) & 0xff)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 8) & 0x7)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 11) & 0xff)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 19) & 0x7)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 22) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 23) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 24) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 25) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 26) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 27) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 28) & 0x1)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 29) & 0x7)
#define BCM53128_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_P.
 *
 */
#define BCM53128_A0_READ_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_BC_SUP_RATECTRL_Pr,(r._bc_sup_ratectrl_p),4)
#define BCM53128_A0_WRITE_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_BC_SUP_RATECTRL_Pr,&(r._bc_sup_ratectrl_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_Pr BCM53128_A0_BC_SUP_RATECTRL_Pr
#define BC_SUP_RATECTRL_Pr_SIZE BCM53128_A0_BC_SUP_RATECTRL_Pr_SIZE
typedef BCM53128_A0_BC_SUP_RATECTRL_Pr_t BC_SUP_RATECTRL_Pr_t;
#define BC_SUP_RATECTRL_Pr_CLR BCM53128_A0_BC_SUP_RATECTRL_Pr_CLR
#define BC_SUP_RATECTRL_Pr_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_SET
#define BC_SUP_RATECTRL_Pr_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_Pr_RESERVEDf_GET BCM53128_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_GET
#define BC_SUP_RATECTRL_Pr_RESERVEDf_SET BCM53128_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_Pr BCM53128_A0_READ_BC_SUP_RATECTRL_Pr
#define WRITE_BC_SUP_RATECTRL_Pr BCM53128_A0_WRITE_BC_SUP_RATECTRL_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BC_SUP_RATECTRL_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BIST_STS
 * BLOCKS:   SYS
 * DESC:     BIST Status Register (Not2Release)
 * SIZE:     48
 * FIELDS:
 *     LV_MBIST_STATUS  LV MBIST StatusOnce LV MBIST is enabled, this field is 8'hff, when the MBIST is done(around 4ms), this field contains the status of MBIST, when it is 8'h0, it means the MBIST is all pass.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_BIST_STSr 0x00000146

#define BCM53128_A0_BIST_STSr_SIZE 6

/*
 * This structure should be used to declare and program BIST_STS.
 *
 */
typedef union BCM53128_A0_BIST_STSr_s {
	uint32_t v[2];
	uint32_t bist_sts[2];
	uint32_t _bist_sts;
} BCM53128_A0_BIST_STSr_t;

#define BCM53128_A0_BIST_STSr_CLR(r) CDK_MEMSET(&((r)._bist_sts), 0, sizeof(BCM53128_A0_BIST_STSr_t))
#define BCM53128_A0_BIST_STSr_SET(r,i,d) (r).bist_sts[i] = d
#define BCM53128_A0_BIST_STSr_GET(r,i) (r).bist_sts[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BIST_STSr_LV_MBIST_STATUSf_GET(r) (((r).bist_sts[0]) & 0xff)
#define BCM53128_A0_BIST_STSr_LV_MBIST_STATUSf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_BIST_STSr_RESERVEDf_GET(r,a) cdk_field_get((r).bist_sts,8,47,a)
#define BCM53128_A0_BIST_STSr_RESERVEDf_SET(r,a) cdk_field_set((r).bist_sts,8,47,a)

/*
 * These macros can be used to access BIST_STS.
 *
 */
#define BCM53128_A0_READ_BIST_STSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_BIST_STSr,(r._bist_sts),6)
#define BCM53128_A0_WRITE_BIST_STSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_BIST_STSr,&(r._bist_sts),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STSr BCM53128_A0_BIST_STSr
#define BIST_STSr_SIZE BCM53128_A0_BIST_STSr_SIZE
typedef BCM53128_A0_BIST_STSr_t BIST_STSr_t;
#define BIST_STSr_CLR BCM53128_A0_BIST_STSr_CLR
#define BIST_STSr_SET BCM53128_A0_BIST_STSr_SET
#define BIST_STSr_GET BCM53128_A0_BIST_STSr_GET
#define BIST_STSr_LV_MBIST_STATUSf_GET BCM53128_A0_BIST_STSr_LV_MBIST_STATUSf_GET
#define BIST_STSr_LV_MBIST_STATUSf_SET BCM53128_A0_BIST_STSr_LV_MBIST_STATUSf_SET
#define BIST_STSr_RESERVEDf_GET BCM53128_A0_BIST_STSr_RESERVEDf_GET
#define BIST_STSr_RESERVEDf_SET BCM53128_A0_BIST_STSr_RESERVEDf_SET
#define READ_BIST_STSr BCM53128_A0_READ_BIST_STSr
#define WRITE_BIST_STSr BCM53128_A0_WRITE_BIST_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BIST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BONDING_PAD_STATUS
 * BLOCKS:   SYS
 * DESC:     Bonding PAD status Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     BOND_PAD         bond_bypass_phy1'b0 : BCM531281'b1 : BCM53128V
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_BONDING_PAD_STATUSr 0x000000ee

#define BCM53128_A0_BONDING_PAD_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program BONDING_PAD_STATUS.
 *
 */
typedef union BCM53128_A0_BONDING_PAD_STATUSr_s {
	uint32_t v[1];
	uint32_t bonding_pad_status[1];
	uint32_t _bonding_pad_status;
} BCM53128_A0_BONDING_PAD_STATUSr_t;

#define BCM53128_A0_BONDING_PAD_STATUSr_CLR(r) (r).bonding_pad_status[0] = 0
#define BCM53128_A0_BONDING_PAD_STATUSr_SET(r,d) (r).bonding_pad_status[0] = d
#define BCM53128_A0_BONDING_PAD_STATUSr_GET(r) (r).bonding_pad_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BONDING_PAD_STATUSr_BOND_PADf_GET(r) (((r).bonding_pad_status[0]) & 0x1)
#define BCM53128_A0_BONDING_PAD_STATUSr_BOND_PADf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_BONDING_PAD_STATUSr_RESERVEDf_GET(r) ((((r).bonding_pad_status[0]) >> 1) & 0x7f)
#define BCM53128_A0_BONDING_PAD_STATUSr_RESERVEDf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access BONDING_PAD_STATUS.
 *
 */
#define BCM53128_A0_READ_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_BONDING_PAD_STATUSr,(r._bonding_pad_status),1)
#define BCM53128_A0_WRITE_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_BONDING_PAD_STATUSr,&(r._bonding_pad_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BONDING_PAD_STATUSr BCM53128_A0_BONDING_PAD_STATUSr
#define BONDING_PAD_STATUSr_SIZE BCM53128_A0_BONDING_PAD_STATUSr_SIZE
typedef BCM53128_A0_BONDING_PAD_STATUSr_t BONDING_PAD_STATUSr_t;
#define BONDING_PAD_STATUSr_CLR BCM53128_A0_BONDING_PAD_STATUSr_CLR
#define BONDING_PAD_STATUSr_SET BCM53128_A0_BONDING_PAD_STATUSr_SET
#define BONDING_PAD_STATUSr_GET BCM53128_A0_BONDING_PAD_STATUSr_GET
#define BONDING_PAD_STATUSr_BOND_PADf_GET BCM53128_A0_BONDING_PAD_STATUSr_BOND_PADf_GET
#define BONDING_PAD_STATUSr_BOND_PADf_SET BCM53128_A0_BONDING_PAD_STATUSr_BOND_PADf_SET
#define BONDING_PAD_STATUSr_RESERVEDf_GET BCM53128_A0_BONDING_PAD_STATUSr_RESERVEDf_GET
#define BONDING_PAD_STATUSr_RESERVEDf_SET BCM53128_A0_BONDING_PAD_STATUSr_RESERVEDf_SET
#define READ_BONDING_PAD_STATUSr BCM53128_A0_READ_BONDING_PAD_STATUSr
#define WRITE_BONDING_PAD_STATUSr BCM53128_A0_WRITE_BONDING_PAD_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BONDING_PAD_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     BPDU Multicast Address 1.(not release to customer).Defaults to the 802.1 defined reserved multicast address for the Bridge Group #Address. Programming to an alternate value allows support of proprietary #protocols in place of the normal Spanning Tree Protocol. Frames with a matching #DA to this address will be forwarded only to the designated management port #(IMP).
 *
 ******************************************************************************/
#define BCM53128_A0_BPDU_MCADDRr 0x00000404

#define BCM53128_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 *
 */
typedef union BCM53128_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM53128_A0_BPDU_MCADDRr_t;

#define BCM53128_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM53128_A0_BPDU_MCADDRr_t))
#define BCM53128_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM53128_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM53128_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 *
 */
#define BCM53128_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM53128_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM53128_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM53128_A0_BPDU_MCADDRr_SIZE
typedef BCM53128_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM53128_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM53128_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM53128_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM53128_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM53128_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM53128_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM53128_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BPDU_MCADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  BRCM_HDR_CTRL
 * BLOCKS:   SYS
 * DESC:     BRCM Header Control Register
 * SIZE:     8
 * FIELDS:
 *     BRCM_HDR_EN      Broadcom Header enable for IMP portbit [1]: enable BRCM header for IMP1 (only take effect when IMP1 is enabled) (Not2Release)bit [0]: enable BRCM header for IMP1: Additional header information is inserted into the Original frame,between oiginal SA field and Type/Length fields. 0: Without additional header information.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_BRCM_HDR_CTRLr 0x00000203

#define BCM53128_A0_BRCM_HDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program BRCM_HDR_CTRL.
 *
 */
typedef union BCM53128_A0_BRCM_HDR_CTRLr_s {
	uint32_t v[1];
	uint32_t brcm_hdr_ctrl[1];
	uint32_t _brcm_hdr_ctrl;
} BCM53128_A0_BRCM_HDR_CTRLr_t;

#define BCM53128_A0_BRCM_HDR_CTRLr_CLR(r) (r).brcm_hdr_ctrl[0] = 0
#define BCM53128_A0_BRCM_HDR_CTRLr_SET(r,d) (r).brcm_hdr_ctrl[0] = d
#define BCM53128_A0_BRCM_HDR_CTRLr_GET(r) (r).brcm_hdr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET(r) (((r).brcm_hdr_ctrl[0]) & 0x3)
#define BCM53128_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_BRCM_HDR_CTRLr_RESERVEDf_GET(r) ((((r).brcm_hdr_ctrl[0]) >> 2) & 0x3f)
#define BCM53128_A0_BRCM_HDR_CTRLr_RESERVEDf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access BRCM_HDR_CTRL.
 *
 */
#define BCM53128_A0_READ_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_BRCM_HDR_CTRLr,(r._brcm_hdr_ctrl),1)
#define BCM53128_A0_WRITE_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_BRCM_HDR_CTRLr,&(r._brcm_hdr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BRCM_HDR_CTRLr BCM53128_A0_BRCM_HDR_CTRLr
#define BRCM_HDR_CTRLr_SIZE BCM53128_A0_BRCM_HDR_CTRLr_SIZE
typedef BCM53128_A0_BRCM_HDR_CTRLr_t BRCM_HDR_CTRLr_t;
#define BRCM_HDR_CTRLr_CLR BCM53128_A0_BRCM_HDR_CTRLr_CLR
#define BRCM_HDR_CTRLr_SET BCM53128_A0_BRCM_HDR_CTRLr_SET
#define BRCM_HDR_CTRLr_GET BCM53128_A0_BRCM_HDR_CTRLr_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET BCM53128_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET BCM53128_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET
#define BRCM_HDR_CTRLr_RESERVEDf_GET BCM53128_A0_BRCM_HDR_CTRLr_RESERVEDf_GET
#define BRCM_HDR_CTRLr_RESERVEDf_SET BCM53128_A0_BRCM_HDR_CTRLr_RESERVEDf_SET
#define READ_BRCM_HDR_CTRLr BCM53128_A0_READ_BRCM_HDR_CTRLr
#define WRITE_BRCM_HDR_CTRLr BCM53128_A0_WRITE_BRCM_HDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BRCM_HDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  BUFCON
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Control Table
 * SIZE:     72
 * FIELDS:
 *     NEXTBUFPTR       nextbufptr[8:0]
 *     UNTAGMAP         untagmap[6:0]
 *     PORTMAP          portmap[6:0]
 *     RXPORT           rxport[3:0]
 *     DSCP             dscp[5:0]
 *     PRESV_1P_TAG     presv_1p_tag
 *     FMLEN            fmlen[13:0]
 *     TC               tc[2:0]
 *     TS               ts
 *     RSN_CD           rsn_cd[5:0]
 *     TSRPT            tsrpt
 *     C_TAG            C_tag
 *     S_TAG            S_tag
 *     CLASS_ID         class_id[7:0]
 *     PRESV_PKT_FORMAT presv_pkt_format
 *     CVID0            cvid0
 *     SVID0            svid0
 *
 ******************************************************************************/
#define BCM53128_A0_BUFCONm 0x00000000

#define BCM53128_A0_BUFCONm_MIN 0
#define BCM53128_A0_BUFCONm_MAX 5119
#define BCM53128_A0_BUFCONm_CMAX(u) 5119
#define BCM53128_A0_BUFCONm_SIZE 9

/*
 * This structure should be used to declare and program BUFCON.
 *
 */
typedef union BCM53128_A0_BUFCONm_s {
	uint32_t v[3];
	uint32_t bufcon[3];
	uint32_t _bufcon;
} BCM53128_A0_BUFCONm_t;

#define BCM53128_A0_BUFCONm_CLR(r) CDK_MEMSET(&((r)._bufcon), 0, sizeof(BCM53128_A0_BUFCONm_t))
#define BCM53128_A0_BUFCONm_SET(r,i,d) (r).bufcon[i] = d
#define BCM53128_A0_BUFCONm_GET(r,i) (r).bufcon[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_BUFCONm_NEXTBUFPTRf_GET(r) (((r).bufcon[0]) & 0x1ff)
#define BCM53128_A0_BUFCONm_NEXTBUFPTRf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_BUFCONm_UNTAGMAPf_GET(r) ((((r).bufcon[0]) >> 9) & 0x7f)
#define BCM53128_A0_BUFCONm_UNTAGMAPf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM53128_A0_BUFCONm_PORTMAPf_GET(r) ((((r).bufcon[0]) >> 16) & 0x7f)
#define BCM53128_A0_BUFCONm_PORTMAPf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM53128_A0_BUFCONm_RXPORTf_GET(r) ((((r).bufcon[0]) >> 23) & 0xf)
#define BCM53128_A0_BUFCONm_RXPORTf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0xf << 23)) | ((((uint32_t)f) & 0xf) << 23))
#define BCM53128_A0_BUFCONm_DSCPf_GET(r) cdk_field32_get((r).bufcon,27,32)
#define BCM53128_A0_BUFCONm_DSCPf_SET(r,f) cdk_field32_set((r).bufcon,27,32,f)
#define BCM53128_A0_BUFCONm_PRESV_1P_TAGf_GET(r) ((((r).bufcon[1]) >> 1) & 0x1)
#define BCM53128_A0_BUFCONm_PRESV_1P_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_BUFCONm_FMLENf_GET(r) ((((r).bufcon[1]) >> 2) & 0x3fff)
#define BCM53128_A0_BUFCONm_FMLENf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCM53128_A0_BUFCONm_TCf_GET(r) ((((r).bufcon[1]) >> 16) & 0x7)
#define BCM53128_A0_BUFCONm_TCf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53128_A0_BUFCONm_TSf_GET(r) ((((r).bufcon[1]) >> 19) & 0x1)
#define BCM53128_A0_BUFCONm_TSf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53128_A0_BUFCONm_RSN_CDf_GET(r) ((((r).bufcon[1]) >> 20) & 0x3f)
#define BCM53128_A0_BUFCONm_RSN_CDf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM53128_A0_BUFCONm_TSRPTf_GET(r) ((((r).bufcon[1]) >> 26) & 0x1)
#define BCM53128_A0_BUFCONm_TSRPTf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53128_A0_BUFCONm_C_TAGf_GET(r) ((((r).bufcon[1]) >> 27) & 0x1)
#define BCM53128_A0_BUFCONm_C_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_BUFCONm_S_TAGf_GET(r) ((((r).bufcon[1]) >> 28) & 0x1)
#define BCM53128_A0_BUFCONm_S_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53128_A0_BUFCONm_CLASS_IDf_GET(r) cdk_field32_get((r).bufcon,61,68)
#define BCM53128_A0_BUFCONm_CLASS_IDf_SET(r,f) cdk_field32_set((r).bufcon,61,68,f)
#define BCM53128_A0_BUFCONm_PRESV_PKT_FORMATf_GET(r) ((((r).bufcon[2]) >> 5) & 0x1)
#define BCM53128_A0_BUFCONm_PRESV_PKT_FORMATf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_BUFCONm_CVID0f_GET(r) ((((r).bufcon[2]) >> 6) & 0x1)
#define BCM53128_A0_BUFCONm_CVID0f_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_BUFCONm_SVID0f_GET(r) ((((r).bufcon[2]) >> 7) & 0x1)
#define BCM53128_A0_BUFCONm_SVID0f_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access BUFCON.
 *
 */
#define BCM53128_A0_READ_BUFCONm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_BUFCONm,i,(m),9)
#define BCM53128_A0_WRITE_BUFCONm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_BUFCONm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCONm BCM53128_A0_BUFCONm
#define BUFCONm_MIN BCM53128_A0_BUFCONm_MIN
#define BUFCONm_MAX BCM53128_A0_BUFCONm_MAX
#define BUFCONm_CMAX(u) BCM53128_A0_BUFCONm_CMAX(u)
#define BUFCONm_SIZE BCM53128_A0_BUFCONm_SIZE
typedef BCM53128_A0_BUFCONm_t BUFCONm_t;
#define BUFCONm_CLR BCM53128_A0_BUFCONm_CLR
#define BUFCONm_SET BCM53128_A0_BUFCONm_SET
#define BUFCONm_GET BCM53128_A0_BUFCONm_GET
#define BUFCONm_NEXTBUFPTRf_GET BCM53128_A0_BUFCONm_NEXTBUFPTRf_GET
#define BUFCONm_NEXTBUFPTRf_SET BCM53128_A0_BUFCONm_NEXTBUFPTRf_SET
#define BUFCONm_UNTAGMAPf_GET BCM53128_A0_BUFCONm_UNTAGMAPf_GET
#define BUFCONm_UNTAGMAPf_SET BCM53128_A0_BUFCONm_UNTAGMAPf_SET
#define BUFCONm_PORTMAPf_GET BCM53128_A0_BUFCONm_PORTMAPf_GET
#define BUFCONm_PORTMAPf_SET BCM53128_A0_BUFCONm_PORTMAPf_SET
#define BUFCONm_RXPORTf_GET BCM53128_A0_BUFCONm_RXPORTf_GET
#define BUFCONm_RXPORTf_SET BCM53128_A0_BUFCONm_RXPORTf_SET
#define BUFCONm_DSCPf_GET BCM53128_A0_BUFCONm_DSCPf_GET
#define BUFCONm_DSCPf_SET BCM53128_A0_BUFCONm_DSCPf_SET
#define BUFCONm_PRESV_1P_TAGf_GET BCM53128_A0_BUFCONm_PRESV_1P_TAGf_GET
#define BUFCONm_PRESV_1P_TAGf_SET BCM53128_A0_BUFCONm_PRESV_1P_TAGf_SET
#define BUFCONm_FMLENf_GET BCM53128_A0_BUFCONm_FMLENf_GET
#define BUFCONm_FMLENf_SET BCM53128_A0_BUFCONm_FMLENf_SET
#define BUFCONm_TCf_GET BCM53128_A0_BUFCONm_TCf_GET
#define BUFCONm_TCf_SET BCM53128_A0_BUFCONm_TCf_SET
#define BUFCONm_TSf_GET BCM53128_A0_BUFCONm_TSf_GET
#define BUFCONm_TSf_SET BCM53128_A0_BUFCONm_TSf_SET
#define BUFCONm_RSN_CDf_GET BCM53128_A0_BUFCONm_RSN_CDf_GET
#define BUFCONm_RSN_CDf_SET BCM53128_A0_BUFCONm_RSN_CDf_SET
#define BUFCONm_TSRPTf_GET BCM53128_A0_BUFCONm_TSRPTf_GET
#define BUFCONm_TSRPTf_SET BCM53128_A0_BUFCONm_TSRPTf_SET
#define BUFCONm_C_TAGf_GET BCM53128_A0_BUFCONm_C_TAGf_GET
#define BUFCONm_C_TAGf_SET BCM53128_A0_BUFCONm_C_TAGf_SET
#define BUFCONm_S_TAGf_GET BCM53128_A0_BUFCONm_S_TAGf_GET
#define BUFCONm_S_TAGf_SET BCM53128_A0_BUFCONm_S_TAGf_SET
#define BUFCONm_CLASS_IDf_GET BCM53128_A0_BUFCONm_CLASS_IDf_GET
#define BUFCONm_CLASS_IDf_SET BCM53128_A0_BUFCONm_CLASS_IDf_SET
#define BUFCONm_PRESV_PKT_FORMATf_GET BCM53128_A0_BUFCONm_PRESV_PKT_FORMATf_GET
#define BUFCONm_PRESV_PKT_FORMATf_SET BCM53128_A0_BUFCONm_PRESV_PKT_FORMATf_SET
#define BUFCONm_CVID0f_GET BCM53128_A0_BUFCONm_CVID0f_GET
#define BUFCONm_CVID0f_SET BCM53128_A0_BUFCONm_CVID0f_SET
#define BUFCONm_SVID0f_GET BCM53128_A0_BUFCONm_SVID0f_GET
#define BUFCONm_SVID0f_SET BCM53128_A0_BUFCONm_SVID0f_SET
#define READ_BUFCONm BCM53128_A0_READ_BUFCONm
#define WRITE_BUFCONm BCM53128_A0_WRITE_BUFCONm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_BUFCONm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  C4_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Class4 Service Weight Register
 * SIZE:     16
 * FIELDS:
 *     C4_WEIGHT        C4 Service WeightThis field defines the service weight between Class 4 traffic and the Best Effort Q3-Q0. When this field is N, it means Class-4:Best-Effort = N:1 When in weighted round robin mode, it is meaningless to set this field as zero.
 *     C4_STRCT         C4 Strict PriorityWhen this field is set to '1', the C4 service weight is don't care and Class 4 is in strict priority over the best effort queues (Q3-Q0).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_C4_WEIGHTr 0x00003085

#define BCM53128_A0_C4_WEIGHTr_SIZE 2

/*
 * This structure should be used to declare and program C4_WEIGHT.
 *
 */
typedef union BCM53128_A0_C4_WEIGHTr_s {
	uint32_t v[1];
	uint32_t c4_weight[1];
	uint32_t _c4_weight;
} BCM53128_A0_C4_WEIGHTr_t;

#define BCM53128_A0_C4_WEIGHTr_CLR(r) (r).c4_weight[0] = 0
#define BCM53128_A0_C4_WEIGHTr_SET(r,d) (r).c4_weight[0] = d
#define BCM53128_A0_C4_WEIGHTr_GET(r) (r).c4_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_C4_WEIGHTr_C4_WEIGHTf_GET(r) (((r).c4_weight[0]) & 0xff)
#define BCM53128_A0_C4_WEIGHTr_C4_WEIGHTf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_C4_WEIGHTr_C4_STRCTf_GET(r) ((((r).c4_weight[0]) >> 8) & 0x1)
#define BCM53128_A0_C4_WEIGHTr_C4_STRCTf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_C4_WEIGHTr_RESERVEDf_GET(r) ((((r).c4_weight[0]) >> 9) & 0x7f)
#define BCM53128_A0_C4_WEIGHTr_RESERVEDf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access C4_WEIGHT.
 *
 */
#define BCM53128_A0_READ_C4_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_C4_WEIGHTr,(r._c4_weight),2)
#define BCM53128_A0_WRITE_C4_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_C4_WEIGHTr,&(r._c4_weight),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define C4_WEIGHTr BCM53128_A0_C4_WEIGHTr
#define C4_WEIGHTr_SIZE BCM53128_A0_C4_WEIGHTr_SIZE
typedef BCM53128_A0_C4_WEIGHTr_t C4_WEIGHTr_t;
#define C4_WEIGHTr_CLR BCM53128_A0_C4_WEIGHTr_CLR
#define C4_WEIGHTr_SET BCM53128_A0_C4_WEIGHTr_SET
#define C4_WEIGHTr_GET BCM53128_A0_C4_WEIGHTr_GET
#define C4_WEIGHTr_C4_WEIGHTf_GET BCM53128_A0_C4_WEIGHTr_C4_WEIGHTf_GET
#define C4_WEIGHTr_C4_WEIGHTf_SET BCM53128_A0_C4_WEIGHTr_C4_WEIGHTf_SET
#define C4_WEIGHTr_C4_STRCTf_GET BCM53128_A0_C4_WEIGHTr_C4_STRCTf_GET
#define C4_WEIGHTr_C4_STRCTf_SET BCM53128_A0_C4_WEIGHTr_C4_STRCTf_SET
#define C4_WEIGHTr_RESERVEDf_GET BCM53128_A0_C4_WEIGHTr_RESERVEDf_GET
#define C4_WEIGHTr_RESERVEDf_SET BCM53128_A0_C4_WEIGHTr_RESERVEDf_SET
#define READ_C4_WEIGHTr BCM53128_A0_READ_C4_WEIGHTr
#define WRITE_C4_WEIGHTr BCM53128_A0_WRITE_C4_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_C4_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  CHIP_REVID
 * BLOCKS:   SYS
 * DESC:     Chip Version ID Register
 * SIZE:     8
 * FIELDS:
 *     REVID            Chip Version ID.
 *
 ******************************************************************************/
#define BCM53128_A0_CHIP_REVIDr 0x00000240

#define BCM53128_A0_CHIP_REVIDr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_REVID.
 *
 */
typedef union BCM53128_A0_CHIP_REVIDr_s {
	uint32_t v[1];
	uint32_t chip_revid[1];
	uint32_t _chip_revid;
} BCM53128_A0_CHIP_REVIDr_t;

#define BCM53128_A0_CHIP_REVIDr_CLR(r) (r).chip_revid[0] = 0
#define BCM53128_A0_CHIP_REVIDr_SET(r,d) (r).chip_revid[0] = d
#define BCM53128_A0_CHIP_REVIDr_GET(r) (r).chip_revid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_CHIP_REVIDr_REVIDf_GET(r) (((r).chip_revid[0]) & 0xff)
#define BCM53128_A0_CHIP_REVIDr_REVIDf_SET(r,f) (r).chip_revid[0]=(((r).chip_revid[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CHIP_REVID.
 *
 */
#define BCM53128_A0_READ_CHIP_REVIDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_CHIP_REVIDr,(r._chip_revid),1)
#define BCM53128_A0_WRITE_CHIP_REVIDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_CHIP_REVIDr,&(r._chip_revid),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_REVIDr BCM53128_A0_CHIP_REVIDr
#define CHIP_REVIDr_SIZE BCM53128_A0_CHIP_REVIDr_SIZE
typedef BCM53128_A0_CHIP_REVIDr_t CHIP_REVIDr_t;
#define CHIP_REVIDr_CLR BCM53128_A0_CHIP_REVIDr_CLR
#define CHIP_REVIDr_SET BCM53128_A0_CHIP_REVIDr_SET
#define CHIP_REVIDr_GET BCM53128_A0_CHIP_REVIDr_GET
#define CHIP_REVIDr_REVIDf_GET BCM53128_A0_CHIP_REVIDr_REVIDf_GET
#define CHIP_REVIDr_REVIDf_SET BCM53128_A0_CHIP_REVIDr_REVIDf_SET
#define READ_CHIP_REVIDr BCM53128_A0_READ_CHIP_REVIDr
#define WRITE_CHIP_REVIDr BCM53128_A0_WRITE_CHIP_REVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_CHIP_REVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  CLKSET
 * BLOCKS:   SPI
 * DESC:     Clock Period Setting Registers
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Clock Control Register
 *
 ******************************************************************************/
#define BCM53128_A0_CLKSETr 0x0000fffa

#define BCM53128_A0_CLKSETr_SIZE 4

/*
 * This structure should be used to declare and program CLKSET.
 *
 */
typedef union BCM53128_A0_CLKSETr_s {
	uint32_t v[1];
	uint32_t clkset[1];
	uint32_t _clkset;
} BCM53128_A0_CLKSETr_t;

#define BCM53128_A0_CLKSETr_CLR(r) (r).clkset[0] = 0
#define BCM53128_A0_CLKSETr_SET(r,d) (r).clkset[0] = d
#define BCM53128_A0_CLKSETr_GET(r) (r).clkset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_CLKSETr_RESERVEDf_GET(r) ((r).clkset[0])
#define BCM53128_A0_CLKSETr_RESERVEDf_SET(r,f) (r).clkset[0]=((uint32_t)f)

/*
 * These macros can be used to access CLKSET.
 *
 */
#define BCM53128_A0_READ_CLKSETr(u,r) cdk_robo_reg_read(u,BCM53128_A0_CLKSETr,(r._clkset),4)
#define BCM53128_A0_WRITE_CLKSETr(u,r) cdk_robo_reg_write(u,BCM53128_A0_CLKSETr,&(r._clkset),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CLKSETr BCM53128_A0_CLKSETr
#define CLKSETr_SIZE BCM53128_A0_CLKSETr_SIZE
typedef BCM53128_A0_CLKSETr_t CLKSETr_t;
#define CLKSETr_CLR BCM53128_A0_CLKSETr_CLR
#define CLKSETr_SET BCM53128_A0_CLKSETr_SET
#define CLKSETr_GET BCM53128_A0_CLKSETr_GET
#define CLKSETr_RESERVEDf_GET BCM53128_A0_CLKSETr_RESERVEDf_GET
#define CLKSETr_RESERVEDf_SET BCM53128_A0_CLKSETr_RESERVEDf_SET
#define READ_CLKSETr BCM53128_A0_READ_CLKSETr
#define WRITE_CLKSETr BCM53128_A0_WRITE_CLKSETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_CLKSETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  COMM_IRC_CON
 * BLOCKS:   SYS
 * DESC:     Common Ingress rate Control Configuration Registers
 * SIZE:     32
 * FIELDS:
 *     PKT_MSK0         Packet Mask for Bucket 0Bit 0: Unicast lookup hitBit 1: Multicast lookup hitBit 2: Reserved Mac Address Frame(01-80-C2-0-00-2F)Bit 3: BroadcastBit 4: Multicats lookup failBit 5: Unicast lookup fail
 *     XLENEN_EG        Bit Rate Mode Selection for Egress Control0:TX Rate Exclude IPG1:TX Rate Include IPG(and preamble + SFD)
 *     DROP_EN0         suppression Drop Mode Enabled.1:The incoming packet will be dropped if the allowed bandwidth for those packets defined in Packet Type Mask is up.0:The Pause Frame/Jamming Frame will be transmitted depend on Full/HalfDuplex Mode if the allowed bandwidth for those packets defined in Packet Type Mask is up.
 *     RATE_TYPE0       Bit Rate Mode selection.0: E3556 ModeIncoming Bit Rate is Defined in Refresh Count in per Ingress Port Rate Control Register with Absolute amout and Nothing about Link Speed.1:Bit Rate Related to Link Speed ModeIncoming Bit Rate is Define in Refresh Count in Per Ingress Port Rate Control Register with Related Amount to Link Speed
 *     PKT_MSK1         Packet Mask for Bucket 1Suppressed Packet Type in Bucket 1Bit 0: Unicast lookup hitBit 1: Multicast lookup hitBit 2: Reserved Mac Address Frame(01-80-C2-0-00-2F)Bit 3: BroadcastBit 4: Multicats lookup failBit 5: Unicast lookup failBit 6: Reserved
 *     DROP_EN1         suppression Drop Mode Enabled1:The incoming packet will be dropped if the allowed bandwidth for those packets defined in Packet Type Mask is up.0:The Pause Frame/Jamming Frame will be transmitted depend on Full/HalfDuplex Mode if the allowed bandwidth for those packets defined in Packet Type Mask is up.
 *     RATE_TYPE1       Bit Rate Mode selection.0:Absolute Bit Rate ModeIncoming Bit Rate is Defined in Refresh Count in per Ingress Port Rate Control Register with Absolute amout and Nothing about Link Speed.1:Bit Rate Related to Link Speed ModeIncoming Bit Rate is Define in Refresh Count in Per Ingress Port Rate Control Register with Related Amount to Link Speed
 *     XLEN_EN          bit rate Mode  Selection.0 : Rx rate exclude IGP,1 : Rx rate include IGP,
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_COMM_IRC_CONr 0x00004100

#define BCM53128_A0_COMM_IRC_CONr_SIZE 4

/*
 * This structure should be used to declare and program COMM_IRC_CON.
 *
 */
typedef union BCM53128_A0_COMM_IRC_CONr_s {
	uint32_t v[1];
	uint32_t comm_irc_con[1];
	uint32_t _comm_irc_con;
} BCM53128_A0_COMM_IRC_CONr_t;

#define BCM53128_A0_COMM_IRC_CONr_CLR(r) (r).comm_irc_con[0] = 0
#define BCM53128_A0_COMM_IRC_CONr_SET(r,d) (r).comm_irc_con[0] = d
#define BCM53128_A0_COMM_IRC_CONr_GET(r) (r).comm_irc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_COMM_IRC_CONr_PKT_MSK0f_GET(r) (((r).comm_irc_con[0]) & 0x3f)
#define BCM53128_A0_COMM_IRC_CONr_PKT_MSK0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_COMM_IRC_CONr_XLENEN_EGf_GET(r) ((((r).comm_irc_con[0]) >> 6) & 0x1)
#define BCM53128_A0_COMM_IRC_CONr_XLENEN_EGf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_COMM_IRC_CONr_DROP_EN0f_GET(r) ((((r).comm_irc_con[0]) >> 7) & 0x1)
#define BCM53128_A0_COMM_IRC_CONr_DROP_EN0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_COMM_IRC_CONr_RATE_TYPE0f_GET(r) ((((r).comm_irc_con[0]) >> 8) & 0x1)
#define BCM53128_A0_COMM_IRC_CONr_RATE_TYPE0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_COMM_IRC_CONr_PKT_MSK1f_GET(r) ((((r).comm_irc_con[0]) >> 9) & 0x7f)
#define BCM53128_A0_COMM_IRC_CONr_PKT_MSK1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM53128_A0_COMM_IRC_CONr_DROP_EN1f_GET(r) ((((r).comm_irc_con[0]) >> 16) & 0x1)
#define BCM53128_A0_COMM_IRC_CONr_DROP_EN1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_COMM_IRC_CONr_RATE_TYPE1f_GET(r) ((((r).comm_irc_con[0]) >> 17) & 0x1)
#define BCM53128_A0_COMM_IRC_CONr_RATE_TYPE1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53128_A0_COMM_IRC_CONr_XLEN_ENf_GET(r) ((((r).comm_irc_con[0]) >> 18) & 0x1)
#define BCM53128_A0_COMM_IRC_CONr_XLEN_ENf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53128_A0_COMM_IRC_CONr_RESERVEDf_GET(r) ((((r).comm_irc_con[0]) >> 19) & 0x1fff)
#define BCM53128_A0_COMM_IRC_CONr_RESERVEDf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access COMM_IRC_CON.
 *
 */
#define BCM53128_A0_READ_COMM_IRC_CONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_COMM_IRC_CONr,(r._comm_irc_con),4)
#define BCM53128_A0_WRITE_COMM_IRC_CONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_COMM_IRC_CONr,&(r._comm_irc_con),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COMM_IRC_CONr BCM53128_A0_COMM_IRC_CONr
#define COMM_IRC_CONr_SIZE BCM53128_A0_COMM_IRC_CONr_SIZE
typedef BCM53128_A0_COMM_IRC_CONr_t COMM_IRC_CONr_t;
#define COMM_IRC_CONr_CLR BCM53128_A0_COMM_IRC_CONr_CLR
#define COMM_IRC_CONr_SET BCM53128_A0_COMM_IRC_CONr_SET
#define COMM_IRC_CONr_GET BCM53128_A0_COMM_IRC_CONr_GET
#define COMM_IRC_CONr_PKT_MSK0f_GET BCM53128_A0_COMM_IRC_CONr_PKT_MSK0f_GET
#define COMM_IRC_CONr_PKT_MSK0f_SET BCM53128_A0_COMM_IRC_CONr_PKT_MSK0f_SET
#define COMM_IRC_CONr_XLENEN_EGf_GET BCM53128_A0_COMM_IRC_CONr_XLENEN_EGf_GET
#define COMM_IRC_CONr_XLENEN_EGf_SET BCM53128_A0_COMM_IRC_CONr_XLENEN_EGf_SET
#define COMM_IRC_CONr_DROP_EN0f_GET BCM53128_A0_COMM_IRC_CONr_DROP_EN0f_GET
#define COMM_IRC_CONr_DROP_EN0f_SET BCM53128_A0_COMM_IRC_CONr_DROP_EN0f_SET
#define COMM_IRC_CONr_RATE_TYPE0f_GET BCM53128_A0_COMM_IRC_CONr_RATE_TYPE0f_GET
#define COMM_IRC_CONr_RATE_TYPE0f_SET BCM53128_A0_COMM_IRC_CONr_RATE_TYPE0f_SET
#define COMM_IRC_CONr_PKT_MSK1f_GET BCM53128_A0_COMM_IRC_CONr_PKT_MSK1f_GET
#define COMM_IRC_CONr_PKT_MSK1f_SET BCM53128_A0_COMM_IRC_CONr_PKT_MSK1f_SET
#define COMM_IRC_CONr_DROP_EN1f_GET BCM53128_A0_COMM_IRC_CONr_DROP_EN1f_GET
#define COMM_IRC_CONr_DROP_EN1f_SET BCM53128_A0_COMM_IRC_CONr_DROP_EN1f_SET
#define COMM_IRC_CONr_RATE_TYPE1f_GET BCM53128_A0_COMM_IRC_CONr_RATE_TYPE1f_GET
#define COMM_IRC_CONr_RATE_TYPE1f_SET BCM53128_A0_COMM_IRC_CONr_RATE_TYPE1f_SET
#define COMM_IRC_CONr_XLEN_ENf_GET BCM53128_A0_COMM_IRC_CONr_XLEN_ENf_GET
#define COMM_IRC_CONr_XLEN_ENf_SET BCM53128_A0_COMM_IRC_CONr_XLEN_ENf_SET
#define COMM_IRC_CONr_RESERVEDf_GET BCM53128_A0_COMM_IRC_CONr_RESERVEDf_GET
#define COMM_IRC_CONr_RESERVEDf_SET BCM53128_A0_COMM_IRC_CONr_RESERVEDf_SET
#define READ_COMM_IRC_CONr BCM53128_A0_READ_COMM_IRC_CONr
#define WRITE_COMM_IRC_CONr BCM53128_A0_WRITE_COMM_IRC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_COMM_IRC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  CPU2COS_MAP
 * BLOCKS:   SYS
 * DESC:     CPU to COS Mapping Register
 * SIZE:     32
 * FIELDS:
 *     MIRROR           The packet forwarded to the CPU for mirroring reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     SA_LRN           The packet forwarded to the CPU for SA Learning reason .The COS selection is based on the highest COS valuses among all the resons for the packet..
 *     SW_FLD           The packet forwarded to the CPU for Switching/Flooding reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_TRMNT       The packet forwarded to the CPU for Protocol Termination reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_SNOOP       The packet forwarded to the CPU for Protocol Snooping reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     EXCPT_PRCS       The packet forwarded to the CPU for Exception Processing reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_CPU2COS_MAPr 0x00003064

#define BCM53128_A0_CPU2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CPU2COS_MAP.
 *
 */
typedef union BCM53128_A0_CPU2COS_MAPr_s {
	uint32_t v[1];
	uint32_t cpu2cos_map[1];
	uint32_t _cpu2cos_map;
} BCM53128_A0_CPU2COS_MAPr_t;

#define BCM53128_A0_CPU2COS_MAPr_CLR(r) (r).cpu2cos_map[0] = 0
#define BCM53128_A0_CPU2COS_MAPr_SET(r,d) (r).cpu2cos_map[0] = d
#define BCM53128_A0_CPU2COS_MAPr_GET(r) (r).cpu2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_CPU2COS_MAPr_MIRRORf_GET(r) (((r).cpu2cos_map[0]) & 0x7)
#define BCM53128_A0_CPU2COS_MAPr_MIRRORf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_CPU2COS_MAPr_SA_LRNf_GET(r) ((((r).cpu2cos_map[0]) >> 3) & 0x7)
#define BCM53128_A0_CPU2COS_MAPr_SA_LRNf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_CPU2COS_MAPr_SW_FLDf_GET(r) ((((r).cpu2cos_map[0]) >> 6) & 0x7)
#define BCM53128_A0_CPU2COS_MAPr_SW_FLDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET(r) ((((r).cpu2cos_map[0]) >> 9) & 0x7)
#define BCM53128_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET(r) ((((r).cpu2cos_map[0]) >> 12) & 0x7)
#define BCM53128_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET(r) ((((r).cpu2cos_map[0]) >> 15) & 0x7)
#define BCM53128_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_CPU2COS_MAPr_RESERVEDf_GET(r) ((((r).cpu2cos_map[0]) >> 18) & 0x3fff)
#define BCM53128_A0_CPU2COS_MAPr_RESERVEDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access CPU2COS_MAP.
 *
 */
#define BCM53128_A0_READ_CPU2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_CPU2COS_MAPr,(r._cpu2cos_map),4)
#define BCM53128_A0_WRITE_CPU2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_CPU2COS_MAPr,&(r._cpu2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU2COS_MAPr BCM53128_A0_CPU2COS_MAPr
#define CPU2COS_MAPr_SIZE BCM53128_A0_CPU2COS_MAPr_SIZE
typedef BCM53128_A0_CPU2COS_MAPr_t CPU2COS_MAPr_t;
#define CPU2COS_MAPr_CLR BCM53128_A0_CPU2COS_MAPr_CLR
#define CPU2COS_MAPr_SET BCM53128_A0_CPU2COS_MAPr_SET
#define CPU2COS_MAPr_GET BCM53128_A0_CPU2COS_MAPr_GET
#define CPU2COS_MAPr_MIRRORf_GET BCM53128_A0_CPU2COS_MAPr_MIRRORf_GET
#define CPU2COS_MAPr_MIRRORf_SET BCM53128_A0_CPU2COS_MAPr_MIRRORf_SET
#define CPU2COS_MAPr_SA_LRNf_GET BCM53128_A0_CPU2COS_MAPr_SA_LRNf_GET
#define CPU2COS_MAPr_SA_LRNf_SET BCM53128_A0_CPU2COS_MAPr_SA_LRNf_SET
#define CPU2COS_MAPr_SW_FLDf_GET BCM53128_A0_CPU2COS_MAPr_SW_FLDf_GET
#define CPU2COS_MAPr_SW_FLDf_SET BCM53128_A0_CPU2COS_MAPr_SW_FLDf_SET
#define CPU2COS_MAPr_PRTC_TRMNTf_GET BCM53128_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET
#define CPU2COS_MAPr_PRTC_TRMNTf_SET BCM53128_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET
#define CPU2COS_MAPr_PRTC_SNOOPf_GET BCM53128_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET
#define CPU2COS_MAPr_PRTC_SNOOPf_SET BCM53128_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET
#define CPU2COS_MAPr_EXCPT_PRCSf_GET BCM53128_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET
#define CPU2COS_MAPr_EXCPT_PRCSf_SET BCM53128_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET
#define CPU2COS_MAPr_RESERVEDf_GET BCM53128_A0_CPU2COS_MAPr_RESERVEDf_GET
#define CPU2COS_MAPr_RESERVEDf_SET BCM53128_A0_CPU2COS_MAPr_RESERVEDf_SET
#define READ_CPU2COS_MAPr BCM53128_A0_READ_CPU2COS_MAPr
#define WRITE_CPU2COS_MAPr BCM53128_A0_WRITE_CPU2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_CPU2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  CPU_DATA1_SHARE
 * BLOCKS:   SYS
 * DESC:     CPU Data1 Share Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     CPU_DATA1_SHARE  Data to be shared by internal CPU and external CPU.
 *
 ******************************************************************************/
#define BCM53128_A0_CPU_DATA1_SHAREr 0x000000b8

#define BCM53128_A0_CPU_DATA1_SHAREr_SIZE 8

/*
 * This structure should be used to declare and program CPU_DATA1_SHARE.
 *
 */
typedef union BCM53128_A0_CPU_DATA1_SHAREr_s {
	uint32_t v[2];
	uint32_t cpu_data1_share[2];
	uint32_t _cpu_data1_share;
} BCM53128_A0_CPU_DATA1_SHAREr_t;

#define BCM53128_A0_CPU_DATA1_SHAREr_CLR(r) CDK_MEMSET(&((r)._cpu_data1_share), 0, sizeof(BCM53128_A0_CPU_DATA1_SHAREr_t))
#define BCM53128_A0_CPU_DATA1_SHAREr_SET(r,i,d) (r).cpu_data1_share[i] = d
#define BCM53128_A0_CPU_DATA1_SHAREr_GET(r,i) (r).cpu_data1_share[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_CPU_DATA1_SHAREr_CPU_DATA1_SHAREf_GET(r,a) cdk_field_get((r).cpu_data1_share,0,63,a)
#define BCM53128_A0_CPU_DATA1_SHAREr_CPU_DATA1_SHAREf_SET(r,a) cdk_field_set((r).cpu_data1_share,0,63,a)

/*
 * These macros can be used to access CPU_DATA1_SHARE.
 *
 */
#define BCM53128_A0_READ_CPU_DATA1_SHAREr(u,r) cdk_robo_reg_read(u,BCM53128_A0_CPU_DATA1_SHAREr,(r._cpu_data1_share),8)
#define BCM53128_A0_WRITE_CPU_DATA1_SHAREr(u,r) cdk_robo_reg_write(u,BCM53128_A0_CPU_DATA1_SHAREr,&(r._cpu_data1_share),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_DATA1_SHAREr BCM53128_A0_CPU_DATA1_SHAREr
#define CPU_DATA1_SHAREr_SIZE BCM53128_A0_CPU_DATA1_SHAREr_SIZE
typedef BCM53128_A0_CPU_DATA1_SHAREr_t CPU_DATA1_SHAREr_t;
#define CPU_DATA1_SHAREr_CLR BCM53128_A0_CPU_DATA1_SHAREr_CLR
#define CPU_DATA1_SHAREr_SET BCM53128_A0_CPU_DATA1_SHAREr_SET
#define CPU_DATA1_SHAREr_GET BCM53128_A0_CPU_DATA1_SHAREr_GET
#define CPU_DATA1_SHAREr_CPU_DATA1_SHAREf_GET BCM53128_A0_CPU_DATA1_SHAREr_CPU_DATA1_SHAREf_GET
#define CPU_DATA1_SHAREr_CPU_DATA1_SHAREf_SET BCM53128_A0_CPU_DATA1_SHAREr_CPU_DATA1_SHAREf_SET
#define READ_CPU_DATA1_SHAREr BCM53128_A0_READ_CPU_DATA1_SHAREr
#define WRITE_CPU_DATA1_SHAREr BCM53128_A0_WRITE_CPU_DATA1_SHAREr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_CPU_DATA1_SHAREr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  CPU_DATA_SHARE
 * BLOCKS:   SYS
 * DESC:     CPU Data Share Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     CPU_DATA_SHARE   Data to be shared by internal CPU and external CPU.
 *
 ******************************************************************************/
#define BCM53128_A0_CPU_DATA_SHAREr 0x000000b0

#define BCM53128_A0_CPU_DATA_SHAREr_SIZE 8

/*
 * This structure should be used to declare and program CPU_DATA_SHARE.
 *
 */
typedef union BCM53128_A0_CPU_DATA_SHAREr_s {
	uint32_t v[2];
	uint32_t cpu_data_share[2];
	uint32_t _cpu_data_share;
} BCM53128_A0_CPU_DATA_SHAREr_t;

#define BCM53128_A0_CPU_DATA_SHAREr_CLR(r) CDK_MEMSET(&((r)._cpu_data_share), 0, sizeof(BCM53128_A0_CPU_DATA_SHAREr_t))
#define BCM53128_A0_CPU_DATA_SHAREr_SET(r,i,d) (r).cpu_data_share[i] = d
#define BCM53128_A0_CPU_DATA_SHAREr_GET(r,i) (r).cpu_data_share[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_GET(r,a) cdk_field_get((r).cpu_data_share,0,63,a)
#define BCM53128_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_SET(r,a) cdk_field_set((r).cpu_data_share,0,63,a)

/*
 * These macros can be used to access CPU_DATA_SHARE.
 *
 */
#define BCM53128_A0_READ_CPU_DATA_SHAREr(u,r) cdk_robo_reg_read(u,BCM53128_A0_CPU_DATA_SHAREr,(r._cpu_data_share),8)
#define BCM53128_A0_WRITE_CPU_DATA_SHAREr(u,r) cdk_robo_reg_write(u,BCM53128_A0_CPU_DATA_SHAREr,&(r._cpu_data_share),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_DATA_SHAREr BCM53128_A0_CPU_DATA_SHAREr
#define CPU_DATA_SHAREr_SIZE BCM53128_A0_CPU_DATA_SHAREr_SIZE
typedef BCM53128_A0_CPU_DATA_SHAREr_t CPU_DATA_SHAREr_t;
#define CPU_DATA_SHAREr_CLR BCM53128_A0_CPU_DATA_SHAREr_CLR
#define CPU_DATA_SHAREr_SET BCM53128_A0_CPU_DATA_SHAREr_SET
#define CPU_DATA_SHAREr_GET BCM53128_A0_CPU_DATA_SHAREr_GET
#define CPU_DATA_SHAREr_CPU_DATA_SHAREf_GET BCM53128_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_GET
#define CPU_DATA_SHAREr_CPU_DATA_SHAREf_SET BCM53128_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_SET
#define READ_CPU_DATA_SHAREr BCM53128_A0_READ_CPU_DATA_SHAREr
#define WRITE_CPU_DATA_SHAREr BCM53128_A0_WRITE_CPU_DATA_SHAREr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_CPU_DATA_SHAREr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  CPU_RESOURCE_ARBITER
 * BLOCKS:   SYS
 * DESC:     CPU Resource Arbitor Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EXT_CPU_GNT      GNT signal for external CPU.1 = Granted by arbitor.
 *     EXT_CPU_REQ      REQ signal for external CPU.When CPU need to access critical section, it asserts REQ signal for arbitration. When granted by arbiter, the GNT signal will be asserted to inform the requester. The requester keeps asserting the REQ signal to lock the arbiter. When done, the requester deasserts REQ to give chance to the other requester.1 = Assert0 = Deassert
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_CPU_RESOURCE_ARBITERr 0x000000a0

#define BCM53128_A0_CPU_RESOURCE_ARBITERr_SIZE 1

/*
 * This structure should be used to declare and program CPU_RESOURCE_ARBITER.
 *
 */
typedef union BCM53128_A0_CPU_RESOURCE_ARBITERr_s {
	uint32_t v[1];
	uint32_t cpu_resource_arbiter[1];
	uint32_t _cpu_resource_arbiter;
} BCM53128_A0_CPU_RESOURCE_ARBITERr_t;

#define BCM53128_A0_CPU_RESOURCE_ARBITERr_CLR(r) (r).cpu_resource_arbiter[0] = 0
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_SET(r,d) (r).cpu_resource_arbiter[0] = d
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_GET(r) (r).cpu_resource_arbiter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_GET(r) (((r).cpu_resource_arbiter[0]) & 0x1)
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_SET(r,f) (r).cpu_resource_arbiter[0]=(((r).cpu_resource_arbiter[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_GET(r) ((((r).cpu_resource_arbiter[0]) >> 1) & 0x1)
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_SET(r,f) (r).cpu_resource_arbiter[0]=(((r).cpu_resource_arbiter[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_GET(r) ((((r).cpu_resource_arbiter[0]) >> 2) & 0x3f)
#define BCM53128_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_SET(r,f) (r).cpu_resource_arbiter[0]=(((r).cpu_resource_arbiter[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access CPU_RESOURCE_ARBITER.
 *
 */
#define BCM53128_A0_READ_CPU_RESOURCE_ARBITERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_CPU_RESOURCE_ARBITERr,(r._cpu_resource_arbiter),1)
#define BCM53128_A0_WRITE_CPU_RESOURCE_ARBITERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_CPU_RESOURCE_ARBITERr,&(r._cpu_resource_arbiter),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_RESOURCE_ARBITERr BCM53128_A0_CPU_RESOURCE_ARBITERr
#define CPU_RESOURCE_ARBITERr_SIZE BCM53128_A0_CPU_RESOURCE_ARBITERr_SIZE
typedef BCM53128_A0_CPU_RESOURCE_ARBITERr_t CPU_RESOURCE_ARBITERr_t;
#define CPU_RESOURCE_ARBITERr_CLR BCM53128_A0_CPU_RESOURCE_ARBITERr_CLR
#define CPU_RESOURCE_ARBITERr_SET BCM53128_A0_CPU_RESOURCE_ARBITERr_SET
#define CPU_RESOURCE_ARBITERr_GET BCM53128_A0_CPU_RESOURCE_ARBITERr_GET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_GET BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_GET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_SET BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_SET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_GET BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_GET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_SET BCM53128_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_SET
#define CPU_RESOURCE_ARBITERr_RESERVEDf_GET BCM53128_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_GET
#define CPU_RESOURCE_ARBITERr_RESERVEDf_SET BCM53128_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_SET
#define READ_CPU_RESOURCE_ARBITERr BCM53128_A0_READ_CPU_RESOURCE_ARBITERr
#define WRITE_CPU_RESOURCE_ARBITERr BCM53128_A0_WRITE_CPU_RESOURCE_ARBITERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_CPU_RESOURCE_ARBITERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DEBUG_REG
 * BLOCKS:   SYS
 * DESC:     Debug Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_DEBUG         1 : Enable debugging bus
 *     DEBUG_SEL        Debug bus select.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_DEBUG_REGr 0x0000001e

#define BCM53128_A0_DEBUG_REGr_SIZE 1

/*
 * This structure should be used to declare and program DEBUG_REG.
 *
 */
typedef union BCM53128_A0_DEBUG_REGr_s {
	uint32_t v[1];
	uint32_t debug_reg[1];
	uint32_t _debug_reg;
} BCM53128_A0_DEBUG_REGr_t;

#define BCM53128_A0_DEBUG_REGr_CLR(r) (r).debug_reg[0] = 0
#define BCM53128_A0_DEBUG_REGr_SET(r,d) (r).debug_reg[0] = d
#define BCM53128_A0_DEBUG_REGr_GET(r) (r).debug_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DEBUG_REGr_EN_DEBUGf_GET(r) (((r).debug_reg[0]) & 0x1)
#define BCM53128_A0_DEBUG_REGr_EN_DEBUGf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_DEBUG_REGr_DEBUG_SELf_GET(r) ((((r).debug_reg[0]) >> 1) & 0x3f)
#define BCM53128_A0_DEBUG_REGr_DEBUG_SELf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53128_A0_DEBUG_REGr_RESERVEDf_GET(r) ((((r).debug_reg[0]) >> 7) & 0x1)
#define BCM53128_A0_DEBUG_REGr_RESERVEDf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access DEBUG_REG.
 *
 */
#define BCM53128_A0_READ_DEBUG_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DEBUG_REGr,(r._debug_reg),1)
#define BCM53128_A0_WRITE_DEBUG_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DEBUG_REGr,&(r._debug_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_REGr BCM53128_A0_DEBUG_REGr
#define DEBUG_REGr_SIZE BCM53128_A0_DEBUG_REGr_SIZE
typedef BCM53128_A0_DEBUG_REGr_t DEBUG_REGr_t;
#define DEBUG_REGr_CLR BCM53128_A0_DEBUG_REGr_CLR
#define DEBUG_REGr_SET BCM53128_A0_DEBUG_REGr_SET
#define DEBUG_REGr_GET BCM53128_A0_DEBUG_REGr_GET
#define DEBUG_REGr_EN_DEBUGf_GET BCM53128_A0_DEBUG_REGr_EN_DEBUGf_GET
#define DEBUG_REGr_EN_DEBUGf_SET BCM53128_A0_DEBUG_REGr_EN_DEBUGf_SET
#define DEBUG_REGr_DEBUG_SELf_GET BCM53128_A0_DEBUG_REGr_DEBUG_SELf_GET
#define DEBUG_REGr_DEBUG_SELf_SET BCM53128_A0_DEBUG_REGr_DEBUG_SELf_SET
#define DEBUG_REGr_RESERVEDf_GET BCM53128_A0_DEBUG_REGr_RESERVEDf_GET
#define DEBUG_REGr_RESERVEDf_SET BCM53128_A0_DEBUG_REGr_RESERVEDf_SET
#define READ_DEBUG_REGr BCM53128_A0_READ_DEBUG_REGr
#define WRITE_DEBUG_REGr BCM53128_A0_WRITE_DEBUG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DEBUG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DEFAULT_1Q_TAG
 * BLOCKS:   CPIC GPIC0
 * DESC:     802.1Q Default Port N Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID('h0 and 'hfff are illegal setting).When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (Blackbird2 don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM53128_A0_DEFAULT_1Q_TAGr 0x00003410

#define BCM53128_A0_DEFAULT_1Q_TAGr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG.
 *
 */
typedef union BCM53128_A0_DEFAULT_1Q_TAGr_s {
	uint32_t v[1];
	uint32_t default_1q_tag[1];
	uint32_t _default_1q_tag;
} BCM53128_A0_DEFAULT_1Q_TAGr_t;

#define BCM53128_A0_DEFAULT_1Q_TAGr_CLR(r) (r).default_1q_tag[0] = 0
#define BCM53128_A0_DEFAULT_1Q_TAGr_SET(r,d) (r).default_1q_tag[0] = d
#define BCM53128_A0_DEFAULT_1Q_TAGr_GET(r) (r).default_1q_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DEFAULT_1Q_TAGr_VIDf_GET(r) (((r).default_1q_tag[0]) & 0xfff)
#define BCM53128_A0_DEFAULT_1Q_TAGr_VIDf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_DEFAULT_1Q_TAGr_CFIf_GET(r) ((((r).default_1q_tag[0]) >> 12) & 0x1)
#define BCM53128_A0_DEFAULT_1Q_TAGr_CFIf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_DEFAULT_1Q_TAGr_PRIf_GET(r) ((((r).default_1q_tag[0]) >> 13) & 0x7)
#define BCM53128_A0_DEFAULT_1Q_TAGr_PRIf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG.
 *
 */
#define BCM53128_A0_READ_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_DEFAULT_1Q_TAGr,(r._default_1q_tag),2)
#define BCM53128_A0_WRITE_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_DEFAULT_1Q_TAGr,&(r._default_1q_tag),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAGr BCM53128_A0_DEFAULT_1Q_TAGr
#define DEFAULT_1Q_TAGr_SIZE BCM53128_A0_DEFAULT_1Q_TAGr_SIZE
typedef BCM53128_A0_DEFAULT_1Q_TAGr_t DEFAULT_1Q_TAGr_t;
#define DEFAULT_1Q_TAGr_CLR BCM53128_A0_DEFAULT_1Q_TAGr_CLR
#define DEFAULT_1Q_TAGr_SET BCM53128_A0_DEFAULT_1Q_TAGr_SET
#define DEFAULT_1Q_TAGr_GET BCM53128_A0_DEFAULT_1Q_TAGr_GET
#define DEFAULT_1Q_TAGr_VIDf_GET BCM53128_A0_DEFAULT_1Q_TAGr_VIDf_GET
#define DEFAULT_1Q_TAGr_VIDf_SET BCM53128_A0_DEFAULT_1Q_TAGr_VIDf_SET
#define DEFAULT_1Q_TAGr_CFIf_GET BCM53128_A0_DEFAULT_1Q_TAGr_CFIf_GET
#define DEFAULT_1Q_TAGr_CFIf_SET BCM53128_A0_DEFAULT_1Q_TAGr_CFIf_SET
#define DEFAULT_1Q_TAGr_PRIf_GET BCM53128_A0_DEFAULT_1Q_TAGr_PRIf_GET
#define DEFAULT_1Q_TAGr_PRIf_SET BCM53128_A0_DEFAULT_1Q_TAGr_PRIf_SET
#define READ_DEFAULT_1Q_TAGr BCM53128_A0_READ_DEFAULT_1Q_TAGr
#define WRITE_DEFAULT_1Q_TAGr BCM53128_A0_WRITE_DEFAULT_1Q_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DEFAULT_1Q_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DEFAULT_1Q_TAG_IMP
 * BLOCKS:   CPIC
 * DESC:     802.1Q Default Port 8 Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID.('h0 and 'hfff are illegal setting).When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (Blackbird2 don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr 0x00003420

#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG_IMP.
 *
 */
typedef union BCM53128_A0_DEFAULT_1Q_TAG_IMPr_s {
	uint32_t v[1];
	uint32_t default_1q_tag_imp[1];
	uint32_t _default_1q_tag_imp;
} BCM53128_A0_DEFAULT_1Q_TAG_IMPr_t;

#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_CLR(r) (r).default_1q_tag_imp[0] = 0
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_SET(r,d) (r).default_1q_tag_imp[0] = d
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_GET(r) (r).default_1q_tag_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_VIDf_GET(r) (((r).default_1q_tag_imp[0]) & 0xfff)
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_VIDf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_CFIf_GET(r) ((((r).default_1q_tag_imp[0]) >> 12) & 0x1)
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_CFIf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_PRIf_GET(r) ((((r).default_1q_tag_imp[0]) >> 13) & 0x7)
#define BCM53128_A0_DEFAULT_1Q_TAG_IMPr_PRIf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG_IMP.
 *
 */
#define BCM53128_A0_READ_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DEFAULT_1Q_TAG_IMPr,(r._default_1q_tag_imp),2)
#define BCM53128_A0_WRITE_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DEFAULT_1Q_TAG_IMPr,&(r._default_1q_tag_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAG_IMPr BCM53128_A0_DEFAULT_1Q_TAG_IMPr
#define DEFAULT_1Q_TAG_IMPr_SIZE BCM53128_A0_DEFAULT_1Q_TAG_IMPr_SIZE
typedef BCM53128_A0_DEFAULT_1Q_TAG_IMPr_t DEFAULT_1Q_TAG_IMPr_t;
#define DEFAULT_1Q_TAG_IMPr_CLR BCM53128_A0_DEFAULT_1Q_TAG_IMPr_CLR
#define DEFAULT_1Q_TAG_IMPr_SET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_SET
#define DEFAULT_1Q_TAG_IMPr_GET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_GET
#define DEFAULT_1Q_TAG_IMPr_VIDf_GET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_VIDf_GET
#define DEFAULT_1Q_TAG_IMPr_VIDf_SET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_VIDf_SET
#define DEFAULT_1Q_TAG_IMPr_CFIf_GET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_CFIf_GET
#define DEFAULT_1Q_TAG_IMPr_CFIf_SET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_CFIf_SET
#define DEFAULT_1Q_TAG_IMPr_PRIf_GET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_PRIf_GET
#define DEFAULT_1Q_TAG_IMPr_PRIf_SET BCM53128_A0_DEFAULT_1Q_TAG_IMPr_PRIf_SET
#define READ_DEFAULT_1Q_TAG_IMPr BCM53128_A0_READ_DEFAULT_1Q_TAG_IMPr
#define WRITE_DEFAULT_1Q_TAG_IMPr BCM53128_A0_WRITE_DEFAULT_1Q_TAG_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DEFAULT_1Q_TAG_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DF_TIMER
 * BLOCKS:   SYS
 * DESC:     Discovery Frame Timer Registers
 * SIZE:     8
 * FIELDS:
 *     DF_TIME          From 1 sec to 15 sec,4'h0: 1 sec..4'hE: 15 secscale = 1 sec
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_DF_TIMERr 0x00007202

#define BCM53128_A0_DF_TIMERr_SIZE 1

/*
 * This structure should be used to declare and program DF_TIMER.
 *
 */
typedef union BCM53128_A0_DF_TIMERr_s {
	uint32_t v[1];
	uint32_t df_timer[1];
	uint32_t _df_timer;
} BCM53128_A0_DF_TIMERr_t;

#define BCM53128_A0_DF_TIMERr_CLR(r) (r).df_timer[0] = 0
#define BCM53128_A0_DF_TIMERr_SET(r,d) (r).df_timer[0] = d
#define BCM53128_A0_DF_TIMERr_GET(r) (r).df_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DF_TIMERr_DF_TIMEf_GET(r) (((r).df_timer[0]) & 0xf)
#define BCM53128_A0_DF_TIMERr_DF_TIMEf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_DF_TIMERr_RESERVEDf_GET(r) ((((r).df_timer[0]) >> 4) & 0xf)
#define BCM53128_A0_DF_TIMERr_RESERVEDf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access DF_TIMER.
 *
 */
#define BCM53128_A0_READ_DF_TIMERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DF_TIMERr,(r._df_timer),1)
#define BCM53128_A0_WRITE_DF_TIMERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DF_TIMERr,&(r._df_timer),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DF_TIMERr BCM53128_A0_DF_TIMERr
#define DF_TIMERr_SIZE BCM53128_A0_DF_TIMERr_SIZE
typedef BCM53128_A0_DF_TIMERr_t DF_TIMERr_t;
#define DF_TIMERr_CLR BCM53128_A0_DF_TIMERr_CLR
#define DF_TIMERr_SET BCM53128_A0_DF_TIMERr_SET
#define DF_TIMERr_GET BCM53128_A0_DF_TIMERr_GET
#define DF_TIMERr_DF_TIMEf_GET BCM53128_A0_DF_TIMERr_DF_TIMEf_GET
#define DF_TIMERr_DF_TIMEf_SET BCM53128_A0_DF_TIMERr_DF_TIMEf_SET
#define DF_TIMERr_RESERVEDf_GET BCM53128_A0_DF_TIMERr_RESERVEDf_GET
#define DF_TIMERr_RESERVEDf_SET BCM53128_A0_DF_TIMERr_RESERVEDf_SET
#define READ_DF_TIMERr BCM53128_A0_READ_DF_TIMERr
#define WRITE_DF_TIMERr BCM53128_A0_WRITE_DF_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DF_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DIRECT_INPUT_CTRL_VALUE
 * BLOCKS:   SYS
 * DESC:     Direct input control value register (Not2Release)
 * SIZE:     32
 * FIELDS:
 *     ACT_LOOP_DETECT  
 *     GPHY_TEST        
 *     IMP_DUPLEX       
 *     IMP_LINK         
 *     IMP_PAUSECAP_RX  
 *     IMP_PAUSECAP_TX  
 *     IMP_SPEED        
 *     OVST_B           
 *     PROBE_SYSCLK     
 *     TST_ENABLE       
 *     EN_CLK25_OUT     
 *     RESERVED_0       
 *     IMP_VOLTAGE_SEL0 
 *     IMP_VOLTAGE_SEL1 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr 0x00000180

#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program DIRECT_INPUT_CTRL_VALUE.
 *
 */
typedef union BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_s {
	uint32_t v[1];
	uint32_t direct_input_ctrl_value[1];
	uint32_t _direct_input_ctrl_value;
} BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_t;

#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_CLR(r) (r).direct_input_ctrl_value[0] = 0
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_SET(r,d) (r).direct_input_ctrl_value[0] = d
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_GET(r) (r).direct_input_ctrl_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_ACT_LOOP_DETECTf_GET(r) (((r).direct_input_ctrl_value[0]) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_ACT_LOOP_DETECTf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_GPHY_TESTf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 1) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_GPHY_TESTf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_DUPLEXf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 2) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_DUPLEXf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_LINKf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 3) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_LINKf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_RXf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 4) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_RXf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_TXf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 5) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_TXf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_SPEEDf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 6) & 0x3)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_SPEEDf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_OVST_Bf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 8) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_OVST_Bf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_PROBE_SYSCLKf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 9) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_PROBE_SYSCLKf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_TST_ENABLEf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 10) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_TST_ENABLEf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_EN_CLK25_OUTf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 11) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_EN_CLK25_OUTf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVED_0f_GET(r) ((((r).direct_input_ctrl_value[0]) >> 12) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVED_0f_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL0f_GET(r) ((((r).direct_input_ctrl_value[0]) >> 13) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL0f_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL1f_GET(r) ((((r).direct_input_ctrl_value[0]) >> 14) & 0x1)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL1f_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 15) & 0x1ffff)
#define BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x1ffff << 15)) | ((((uint32_t)f) & 0x1ffff) << 15))

/*
 * These macros can be used to access DIRECT_INPUT_CTRL_VALUE.
 *
 */
#define BCM53128_A0_READ_DIRECT_INPUT_CTRL_VALUEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr,(r._direct_input_ctrl_value),4)
#define BCM53128_A0_WRITE_DIRECT_INPUT_CTRL_VALUEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr,&(r._direct_input_ctrl_value),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIRECT_INPUT_CTRL_VALUEr BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr
#define DIRECT_INPUT_CTRL_VALUEr_SIZE BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_SIZE
typedef BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_t DIRECT_INPUT_CTRL_VALUEr_t;
#define DIRECT_INPUT_CTRL_VALUEr_CLR BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_CLR
#define DIRECT_INPUT_CTRL_VALUEr_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_SET
#define DIRECT_INPUT_CTRL_VALUEr_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_GET
#define DIRECT_INPUT_CTRL_VALUEr_ACT_LOOP_DETECTf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_ACT_LOOP_DETECTf_GET
#define DIRECT_INPUT_CTRL_VALUEr_ACT_LOOP_DETECTf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_ACT_LOOP_DETECTf_SET
#define DIRECT_INPUT_CTRL_VALUEr_GPHY_TESTf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_GPHY_TESTf_GET
#define DIRECT_INPUT_CTRL_VALUEr_GPHY_TESTf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_GPHY_TESTf_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_DUPLEXf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_DUPLEXf_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_DUPLEXf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_DUPLEXf_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_LINKf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_LINKf_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_LINKf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_LINKf_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_RXf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_RXf_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_RXf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_RXf_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_TXf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_TXf_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_TXf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_PAUSECAP_TXf_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_SPEEDf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_SPEEDf_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_SPEEDf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_SPEEDf_SET
#define DIRECT_INPUT_CTRL_VALUEr_OVST_Bf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_OVST_Bf_GET
#define DIRECT_INPUT_CTRL_VALUEr_OVST_Bf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_OVST_Bf_SET
#define DIRECT_INPUT_CTRL_VALUEr_PROBE_SYSCLKf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_PROBE_SYSCLKf_GET
#define DIRECT_INPUT_CTRL_VALUEr_PROBE_SYSCLKf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_PROBE_SYSCLKf_SET
#define DIRECT_INPUT_CTRL_VALUEr_TST_ENABLEf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_TST_ENABLEf_GET
#define DIRECT_INPUT_CTRL_VALUEr_TST_ENABLEf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_TST_ENABLEf_SET
#define DIRECT_INPUT_CTRL_VALUEr_EN_CLK25_OUTf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_EN_CLK25_OUTf_GET
#define DIRECT_INPUT_CTRL_VALUEr_EN_CLK25_OUTf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_EN_CLK25_OUTf_SET
#define DIRECT_INPUT_CTRL_VALUEr_RESERVED_0f_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVED_0f_GET
#define DIRECT_INPUT_CTRL_VALUEr_RESERVED_0f_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVED_0f_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL0f_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL0f_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL0f_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL0f_SET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL1f_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL1f_GET
#define DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL1f_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_IMP_VOLTAGE_SEL1f_SET
#define DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_GET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_GET
#define DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_SET BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_SET
#define READ_DIRECT_INPUT_CTRL_VALUEr BCM53128_A0_READ_DIRECT_INPUT_CTRL_VALUEr
#define WRITE_DIRECT_INPUT_CTRL_VALUEr BCM53128_A0_WRITE_DIRECT_INPUT_CTRL_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DIRECT_INPUT_CTRL_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DIS_LEARN
 * BLOCKS:   SYS
 * DESC:     Disable Learning Register
 * SIZE:     16
 * FIELDS:
 *     DIS_LEARN        bit[8:0] : Port 8-01 : Disable learning, when disable, the hardware won't do the following items:	a. learn entries to ARL.	b. refresh entries to ARL.	c. support software learning.0 : Enable Learning.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_DIS_LEARNr 0x0000003c

#define BCM53128_A0_DIS_LEARNr_SIZE 2

/*
 * This structure should be used to declare and program DIS_LEARN.
 *
 */
typedef union BCM53128_A0_DIS_LEARNr_s {
	uint32_t v[1];
	uint32_t dis_learn[1];
	uint32_t _dis_learn;
} BCM53128_A0_DIS_LEARNr_t;

#define BCM53128_A0_DIS_LEARNr_CLR(r) (r).dis_learn[0] = 0
#define BCM53128_A0_DIS_LEARNr_SET(r,d) (r).dis_learn[0] = d
#define BCM53128_A0_DIS_LEARNr_GET(r) (r).dis_learn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DIS_LEARNr_DIS_LEARNf_GET(r) (((r).dis_learn[0]) & 0x1ff)
#define BCM53128_A0_DIS_LEARNr_DIS_LEARNf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_DIS_LEARNr_RESERVEDf_GET(r) ((((r).dis_learn[0]) >> 9) & 0x7f)
#define BCM53128_A0_DIS_LEARNr_RESERVEDf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DIS_LEARN.
 *
 */
#define BCM53128_A0_READ_DIS_LEARNr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DIS_LEARNr,(r._dis_learn),2)
#define BCM53128_A0_WRITE_DIS_LEARNr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DIS_LEARNr,&(r._dis_learn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIS_LEARNr BCM53128_A0_DIS_LEARNr
#define DIS_LEARNr_SIZE BCM53128_A0_DIS_LEARNr_SIZE
typedef BCM53128_A0_DIS_LEARNr_t DIS_LEARNr_t;
#define DIS_LEARNr_CLR BCM53128_A0_DIS_LEARNr_CLR
#define DIS_LEARNr_SET BCM53128_A0_DIS_LEARNr_SET
#define DIS_LEARNr_GET BCM53128_A0_DIS_LEARNr_GET
#define DIS_LEARNr_DIS_LEARNf_GET BCM53128_A0_DIS_LEARNr_DIS_LEARNf_GET
#define DIS_LEARNr_DIS_LEARNf_SET BCM53128_A0_DIS_LEARNr_DIS_LEARNf_SET
#define DIS_LEARNr_RESERVEDf_GET BCM53128_A0_DIS_LEARNr_RESERVEDf_GET
#define DIS_LEARNr_RESERVEDf_SET BCM53128_A0_DIS_LEARNr_RESERVEDf_SET
#define READ_DIS_LEARNr BCM53128_A0_READ_DIS_LEARNr
#define WRITE_DIS_LEARNr BCM53128_A0_WRITE_DIS_LEARNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DIS_LEARNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DMA_CTRL
 * BLOCKS:   SYS
 * DESC:     DMA Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DMA_CTRL         Setting this bit enables DMA loopback. This is to verify the DMA function when software is not ready, for verification purpose only.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_DMA_CTRLr 0x00000091

#define BCM53128_A0_DMA_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program DMA_CTRL.
 *
 */
typedef union BCM53128_A0_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t dma_ctrl[1];
	uint32_t _dma_ctrl;
} BCM53128_A0_DMA_CTRLr_t;

#define BCM53128_A0_DMA_CTRLr_CLR(r) (r).dma_ctrl[0] = 0
#define BCM53128_A0_DMA_CTRLr_SET(r,d) (r).dma_ctrl[0] = d
#define BCM53128_A0_DMA_CTRLr_GET(r) (r).dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DMA_CTRLr_DMA_CTRLf_GET(r) (((r).dma_ctrl[0]) & 0x1)
#define BCM53128_A0_DMA_CTRLr_DMA_CTRLf_SET(r,f) (r).dma_ctrl[0]=(((r).dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_DMA_CTRLr_RESERVEDf_GET(r) ((((r).dma_ctrl[0]) >> 1) & 0x7f)
#define BCM53128_A0_DMA_CTRLr_RESERVEDf_SET(r,f) (r).dma_ctrl[0]=(((r).dma_ctrl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access DMA_CTRL.
 *
 */
#define BCM53128_A0_READ_DMA_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DMA_CTRLr,(r._dma_ctrl),1)
#define BCM53128_A0_WRITE_DMA_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DMA_CTRLr,&(r._dma_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DMA_CTRLr BCM53128_A0_DMA_CTRLr
#define DMA_CTRLr_SIZE BCM53128_A0_DMA_CTRLr_SIZE
typedef BCM53128_A0_DMA_CTRLr_t DMA_CTRLr_t;
#define DMA_CTRLr_CLR BCM53128_A0_DMA_CTRLr_CLR
#define DMA_CTRLr_SET BCM53128_A0_DMA_CTRLr_SET
#define DMA_CTRLr_GET BCM53128_A0_DMA_CTRLr_GET
#define DMA_CTRLr_DMA_CTRLf_GET BCM53128_A0_DMA_CTRLr_DMA_CTRLf_GET
#define DMA_CTRLr_DMA_CTRLf_SET BCM53128_A0_DMA_CTRLr_DMA_CTRLf_SET
#define DMA_CTRLr_RESERVEDf_GET BCM53128_A0_DMA_CTRLr_RESERVEDf_GET
#define DMA_CTRLr_RESERVEDf_SET BCM53128_A0_DMA_CTRLr_RESERVEDf_SET
#define READ_DMA_CTRLr BCM53128_A0_READ_DMA_CTRLr
#define WRITE_DMA_CTRLr BCM53128_A0_WRITE_DMA_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DMA_LPB_BUF_ADDR
 * BLOCKS:   SYS
 * DESC:     DMA Loopback Buffer Address(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DMA_LPB_BUF_ADDR DMA loopback buffer Address. This is to verify the DMA function when software is not ready, for verification purpose only.
 *
 ******************************************************************************/
#define BCM53128_A0_DMA_LPB_BUF_ADDRr 0x00000092

#define BCM53128_A0_DMA_LPB_BUF_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program DMA_LPB_BUF_ADDR.
 *
 */
typedef union BCM53128_A0_DMA_LPB_BUF_ADDRr_s {
	uint32_t v[1];
	uint32_t dma_lpb_buf_addr[1];
	uint32_t _dma_lpb_buf_addr;
} BCM53128_A0_DMA_LPB_BUF_ADDRr_t;

#define BCM53128_A0_DMA_LPB_BUF_ADDRr_CLR(r) (r).dma_lpb_buf_addr[0] = 0
#define BCM53128_A0_DMA_LPB_BUF_ADDRr_SET(r,d) (r).dma_lpb_buf_addr[0] = d
#define BCM53128_A0_DMA_LPB_BUF_ADDRr_GET(r) (r).dma_lpb_buf_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DMA_LPB_BUF_ADDRr_DMA_LPB_BUF_ADDRf_GET(r) (((r).dma_lpb_buf_addr[0]) & 0xffff)
#define BCM53128_A0_DMA_LPB_BUF_ADDRr_DMA_LPB_BUF_ADDRf_SET(r,f) (r).dma_lpb_buf_addr[0]=(((r).dma_lpb_buf_addr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DMA_LPB_BUF_ADDR.
 *
 */
#define BCM53128_A0_READ_DMA_LPB_BUF_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DMA_LPB_BUF_ADDRr,(r._dma_lpb_buf_addr),2)
#define BCM53128_A0_WRITE_DMA_LPB_BUF_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DMA_LPB_BUF_ADDRr,&(r._dma_lpb_buf_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DMA_LPB_BUF_ADDRr BCM53128_A0_DMA_LPB_BUF_ADDRr
#define DMA_LPB_BUF_ADDRr_SIZE BCM53128_A0_DMA_LPB_BUF_ADDRr_SIZE
typedef BCM53128_A0_DMA_LPB_BUF_ADDRr_t DMA_LPB_BUF_ADDRr_t;
#define DMA_LPB_BUF_ADDRr_CLR BCM53128_A0_DMA_LPB_BUF_ADDRr_CLR
#define DMA_LPB_BUF_ADDRr_SET BCM53128_A0_DMA_LPB_BUF_ADDRr_SET
#define DMA_LPB_BUF_ADDRr_GET BCM53128_A0_DMA_LPB_BUF_ADDRr_GET
#define DMA_LPB_BUF_ADDRr_DMA_LPB_BUF_ADDRf_GET BCM53128_A0_DMA_LPB_BUF_ADDRr_DMA_LPB_BUF_ADDRf_GET
#define DMA_LPB_BUF_ADDRr_DMA_LPB_BUF_ADDRf_SET BCM53128_A0_DMA_LPB_BUF_ADDRr_DMA_LPB_BUF_ADDRf_SET
#define READ_DMA_LPB_BUF_ADDRr BCM53128_A0_READ_DMA_LPB_BUF_ADDRr
#define WRITE_DMA_LPB_BUF_ADDRr BCM53128_A0_WRITE_DMA_LPB_BUF_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DMA_LPB_BUF_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DMA_LPB_BUF_SIZE
 * BLOCKS:   SYS
 * DESC:     DMA loopback Buffer Size(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DMA_LPB_BUF_SIZE DMA loopback buffer Size. This is to verify the DMA function when software is not ready, for verification purpose only.
 *
 ******************************************************************************/
#define BCM53128_A0_DMA_LPB_BUF_SIZEr 0x00000094

#define BCM53128_A0_DMA_LPB_BUF_SIZEr_SIZE 2

/*
 * This structure should be used to declare and program DMA_LPB_BUF_SIZE.
 *
 */
typedef union BCM53128_A0_DMA_LPB_BUF_SIZEr_s {
	uint32_t v[1];
	uint32_t dma_lpb_buf_size[1];
	uint32_t _dma_lpb_buf_size;
} BCM53128_A0_DMA_LPB_BUF_SIZEr_t;

#define BCM53128_A0_DMA_LPB_BUF_SIZEr_CLR(r) (r).dma_lpb_buf_size[0] = 0
#define BCM53128_A0_DMA_LPB_BUF_SIZEr_SET(r,d) (r).dma_lpb_buf_size[0] = d
#define BCM53128_A0_DMA_LPB_BUF_SIZEr_GET(r) (r).dma_lpb_buf_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DMA_LPB_BUF_SIZEr_DMA_LPB_BUF_SIZEf_GET(r) (((r).dma_lpb_buf_size[0]) & 0xffff)
#define BCM53128_A0_DMA_LPB_BUF_SIZEr_DMA_LPB_BUF_SIZEf_SET(r,f) (r).dma_lpb_buf_size[0]=(((r).dma_lpb_buf_size[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DMA_LPB_BUF_SIZE.
 *
 */
#define BCM53128_A0_READ_DMA_LPB_BUF_SIZEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DMA_LPB_BUF_SIZEr,(r._dma_lpb_buf_size),2)
#define BCM53128_A0_WRITE_DMA_LPB_BUF_SIZEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DMA_LPB_BUF_SIZEr,&(r._dma_lpb_buf_size),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DMA_LPB_BUF_SIZEr BCM53128_A0_DMA_LPB_BUF_SIZEr
#define DMA_LPB_BUF_SIZEr_SIZE BCM53128_A0_DMA_LPB_BUF_SIZEr_SIZE
typedef BCM53128_A0_DMA_LPB_BUF_SIZEr_t DMA_LPB_BUF_SIZEr_t;
#define DMA_LPB_BUF_SIZEr_CLR BCM53128_A0_DMA_LPB_BUF_SIZEr_CLR
#define DMA_LPB_BUF_SIZEr_SET BCM53128_A0_DMA_LPB_BUF_SIZEr_SET
#define DMA_LPB_BUF_SIZEr_GET BCM53128_A0_DMA_LPB_BUF_SIZEr_GET
#define DMA_LPB_BUF_SIZEr_DMA_LPB_BUF_SIZEf_GET BCM53128_A0_DMA_LPB_BUF_SIZEr_DMA_LPB_BUF_SIZEf_GET
#define DMA_LPB_BUF_SIZEr_DMA_LPB_BUF_SIZEf_SET BCM53128_A0_DMA_LPB_BUF_SIZEr_DMA_LPB_BUF_SIZEf_SET
#define READ_DMA_LPB_BUF_SIZEr BCM53128_A0_READ_DMA_LPB_BUF_SIZEr
#define WRITE_DMA_LPB_BUF_SIZEr BCM53128_A0_WRITE_DMA_LPB_BUF_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DMA_LPB_BUF_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DOS_CTRL
 * BLOCKS:   SYS
 * DESC:     DoS Control RegisterRegister
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Reserved.
 *     IP_LAND_DROP_EN  IP_LAND:IPDA=IPSA in an IP(v4/v6) datagram.1= Drop the specified packet0= Do not drop
 *     TCP_BLAT_DROP_EN TCP_BLAT:DPort=SPort in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     UDP_BLAT_DROP_EN UDP_BLAT:DPport=SPort in a UDP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_NULL_SCAN_DROP_EN TCP_NULLScan:Seq_Num=0 & All TCP_FLAGs=0, in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_XMASS_SCAN_DROP_EN TCP_XMASScan:Seq_Num=0 & FIN=1 & URG=1 & PSH=1 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SYNFIN_SCAN_DROP_EN TCP_SYNFINScan:SYN=1 & FIN=1 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SYN_ERR_DROP_EN TCP_SYNError:SYN=1 & ACK=0 & SRC_Port<1024 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SHORT_HDR_DROP_EN TCP_ShortHDR:The length of a TCP header carried in an unfragmented IP datagram or the first fragment of a fragmented IP datagram is less than MIN_TCP_Header_Size.1= Drop the specified packet0= Do not drop
 *     TCP_FRAG_ERR_DROP_EN TCP_FragError:The Fragment_Offset=1 in any fragment of a fragmented IP datagram carring part of TCP data.1= Drop the specified packet0= Do not drop
 *     ICMPV4_FRAGMENT_DROP_EN ICMPv4_Fragment:The ICMPv4 protocol data unit carrier in a fragmented IPv4 datagram.1= Drop the specified packet0= Do not drop
 *     ICMPV6_FRAGMENT_DROP_EN ICMPv6_Fragment:The ICMPv6 protocol data unit carrier in a fragmented IPv6 datagram.1= Drop the specified packet0= Do not drop
 *     ICMPV4_LONG_PING_DROP_EN ICMPv4_LongPing:The ICMPv4 Ping(Echo Request) protocol data unit carried in an unfragmented IPv4 datagram with its Payload Length indicating a value greater than the MAX_ICMPv4_Size + size of IPv4 heater.1= Drop the specified packet0= Do not drop
 *     ICMPV6_LONG_PING_DROP_EN ICMPv6_LongPing:The ICMPv6 Ping(Echo Request) protocol data unit carried in an unfragmented IPv6 datagram with its Payload Length indicating a value greater than the MAX_ICMPv6_Size.1= Drop the specified packet0= Do not drop
 *
 ******************************************************************************/
#define BCM53128_A0_DOS_CTRLr 0x00003600

#define BCM53128_A0_DOS_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CTRL.
 *
 */
typedef union BCM53128_A0_DOS_CTRLr_s {
	uint32_t v[1];
	uint32_t dos_ctrl[1];
	uint32_t _dos_ctrl;
} BCM53128_A0_DOS_CTRLr_t;

#define BCM53128_A0_DOS_CTRLr_CLR(r) (r).dos_ctrl[0] = 0
#define BCM53128_A0_DOS_CTRLr_SET(r,d) (r).dos_ctrl[0] = d
#define BCM53128_A0_DOS_CTRLr_GET(r) (r).dos_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DOS_CTRLr_RESERVEDf_GET(r) (((r).dos_ctrl[0]) & 0x1)
#define BCM53128_A0_DOS_CTRLr_RESERVEDf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 8) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 9) & 0x1)
#define BCM53128_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 10) & 0x1)
#define BCM53128_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 11) & 0x1)
#define BCM53128_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 12) & 0x1)
#define BCM53128_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 13) & 0x1)
#define BCM53128_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access DOS_CTRL.
 *
 */
#define BCM53128_A0_READ_DOS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DOS_CTRLr,(r._dos_ctrl),4)
#define BCM53128_A0_WRITE_DOS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DOS_CTRLr,&(r._dos_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CTRLr BCM53128_A0_DOS_CTRLr
#define DOS_CTRLr_SIZE BCM53128_A0_DOS_CTRLr_SIZE
typedef BCM53128_A0_DOS_CTRLr_t DOS_CTRLr_t;
#define DOS_CTRLr_CLR BCM53128_A0_DOS_CTRLr_CLR
#define DOS_CTRLr_SET BCM53128_A0_DOS_CTRLr_SET
#define DOS_CTRLr_GET BCM53128_A0_DOS_CTRLr_GET
#define DOS_CTRLr_RESERVEDf_GET BCM53128_A0_DOS_CTRLr_RESERVEDf_GET
#define DOS_CTRLr_RESERVEDf_SET BCM53128_A0_DOS_CTRLr_RESERVEDf_SET
#define DOS_CTRLr_IP_LAND_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET
#define DOS_CTRLr_IP_LAND_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET BCM53128_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET BCM53128_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET
#define READ_DOS_CTRLr BCM53128_A0_READ_DOS_CTRLr
#define WRITE_DOS_CTRLr BCM53128_A0_WRITE_DOS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DOS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DOS_DIS_LRN_REG
 * BLOCKS:   SYS
 * DESC:     DoS Disable Learn Register
 * SIZE:     8
 * FIELDS:
 *     DOS_DIS_LRN      When this bit is enabled, all frames drop by dos prevent module will NOT be learned.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_DOS_DIS_LRN_REGr 0x00003610

#define BCM53128_A0_DOS_DIS_LRN_REGr_SIZE 1

/*
 * This structure should be used to declare and program DOS_DIS_LRN_REG.
 *
 */
typedef union BCM53128_A0_DOS_DIS_LRN_REGr_s {
	uint32_t v[1];
	uint32_t dos_dis_lrn_reg[1];
	uint32_t _dos_dis_lrn_reg;
} BCM53128_A0_DOS_DIS_LRN_REGr_t;

#define BCM53128_A0_DOS_DIS_LRN_REGr_CLR(r) (r).dos_dis_lrn_reg[0] = 0
#define BCM53128_A0_DOS_DIS_LRN_REGr_SET(r,d) (r).dos_dis_lrn_reg[0] = d
#define BCM53128_A0_DOS_DIS_LRN_REGr_GET(r) (r).dos_dis_lrn_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET(r) (((r).dos_dis_lrn_reg[0]) & 0x1)
#define BCM53128_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_DOS_DIS_LRN_REGr_RESERVEDf_GET(r) ((((r).dos_dis_lrn_reg[0]) >> 1) & 0x7f)
#define BCM53128_A0_DOS_DIS_LRN_REGr_RESERVEDf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access DOS_DIS_LRN_REG.
 *
 */
#define BCM53128_A0_READ_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DOS_DIS_LRN_REGr,(r._dos_dis_lrn_reg),1)
#define BCM53128_A0_WRITE_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DOS_DIS_LRN_REGr,&(r._dos_dis_lrn_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_DIS_LRN_REGr BCM53128_A0_DOS_DIS_LRN_REGr
#define DOS_DIS_LRN_REGr_SIZE BCM53128_A0_DOS_DIS_LRN_REGr_SIZE
typedef BCM53128_A0_DOS_DIS_LRN_REGr_t DOS_DIS_LRN_REGr_t;
#define DOS_DIS_LRN_REGr_CLR BCM53128_A0_DOS_DIS_LRN_REGr_CLR
#define DOS_DIS_LRN_REGr_SET BCM53128_A0_DOS_DIS_LRN_REGr_SET
#define DOS_DIS_LRN_REGr_GET BCM53128_A0_DOS_DIS_LRN_REGr_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET BCM53128_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET BCM53128_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET
#define DOS_DIS_LRN_REGr_RESERVEDf_GET BCM53128_A0_DOS_DIS_LRN_REGr_RESERVEDf_GET
#define DOS_DIS_LRN_REGr_RESERVEDf_SET BCM53128_A0_DOS_DIS_LRN_REGr_RESERVEDf_SET
#define READ_DOS_DIS_LRN_REGr BCM53128_A0_READ_DOS_DIS_LRN_REGr
#define WRITE_DOS_DIS_LRN_REGr BCM53128_A0_WRITE_DOS_DIS_LRN_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DOS_DIS_LRN_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DTAG_TPID
 * BLOCKS:   SYS
 * DESC:     Double Tagging TPID Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_TPID         TPID used to identify double tagged frame or not.
 *
 ******************************************************************************/
#define BCM53128_A0_DTAG_TPIDr 0x00003430

#define BCM53128_A0_DTAG_TPIDr_SIZE 2

/*
 * This structure should be used to declare and program DTAG_TPID.
 *
 */
typedef union BCM53128_A0_DTAG_TPIDr_s {
	uint32_t v[1];
	uint32_t dtag_tpid[1];
	uint32_t _dtag_tpid;
} BCM53128_A0_DTAG_TPIDr_t;

#define BCM53128_A0_DTAG_TPIDr_CLR(r) (r).dtag_tpid[0] = 0
#define BCM53128_A0_DTAG_TPIDr_SET(r,d) (r).dtag_tpid[0] = d
#define BCM53128_A0_DTAG_TPIDr_GET(r) (r).dtag_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DTAG_TPIDr_ISP_TPIDf_GET(r) (((r).dtag_tpid[0]) & 0xffff)
#define BCM53128_A0_DTAG_TPIDr_ISP_TPIDf_SET(r,f) (r).dtag_tpid[0]=(((r).dtag_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DTAG_TPID.
 *
 */
#define BCM53128_A0_READ_DTAG_TPIDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DTAG_TPIDr,(r._dtag_tpid),2)
#define BCM53128_A0_WRITE_DTAG_TPIDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DTAG_TPIDr,&(r._dtag_tpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DTAG_TPIDr BCM53128_A0_DTAG_TPIDr
#define DTAG_TPIDr_SIZE BCM53128_A0_DTAG_TPIDr_SIZE
typedef BCM53128_A0_DTAG_TPIDr_t DTAG_TPIDr_t;
#define DTAG_TPIDr_CLR BCM53128_A0_DTAG_TPIDr_CLR
#define DTAG_TPIDr_SET BCM53128_A0_DTAG_TPIDr_SET
#define DTAG_TPIDr_GET BCM53128_A0_DTAG_TPIDr_GET
#define DTAG_TPIDr_ISP_TPIDf_GET BCM53128_A0_DTAG_TPIDr_ISP_TPIDf_GET
#define DTAG_TPIDr_ISP_TPIDf_SET BCM53128_A0_DTAG_TPIDr_ISP_TPIDf_SET
#define READ_DTAG_TPIDr BCM53128_A0_READ_DTAG_TPIDr
#define WRITE_DTAG_TPIDr BCM53128_A0_WRITE_DTAG_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DTAG_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Duplex status Summary Register
 * SIZE:     16
 * FIELDS:
 *     DUP_STS          Duplex State.9 bit field indicating the half/full duplex state for each 10/100/1000BASE-T port.(bits 0-7 = 10/100/1000BASE-T ports, bit 8 = imp port).0 = Half Duplex.1 = Full Duplex.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_DUPSTSr 0x00000108

#define BCM53128_A0_DUPSTSr_SIZE 2

/*
 * This structure should be used to declare and program DUPSTS.
 *
 */
typedef union BCM53128_A0_DUPSTSr_s {
	uint32_t v[1];
	uint32_t dupsts[1];
	uint32_t _dupsts;
} BCM53128_A0_DUPSTSr_t;

#define BCM53128_A0_DUPSTSr_CLR(r) (r).dupsts[0] = 0
#define BCM53128_A0_DUPSTSr_SET(r,d) (r).dupsts[0] = d
#define BCM53128_A0_DUPSTSr_GET(r) (r).dupsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_DUPSTSr_DUP_STSf_GET(r) (((r).dupsts[0]) & 0x1ff)
#define BCM53128_A0_DUPSTSr_DUP_STSf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_DUPSTSr_RESERVEDf_GET(r) ((((r).dupsts[0]) >> 9) & 0x7f)
#define BCM53128_A0_DUPSTSr_RESERVEDf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DUPSTS.
 *
 */
#define BCM53128_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_DUPSTSr,(r._dupsts),2)
#define BCM53128_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_DUPSTSr,&(r._dupsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM53128_A0_DUPSTSr
#define DUPSTSr_SIZE BCM53128_A0_DUPSTSr_SIZE
typedef BCM53128_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM53128_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM53128_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM53128_A0_DUPSTSr_GET
#define DUPSTSr_DUP_STSf_GET BCM53128_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM53128_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVEDf_GET BCM53128_A0_DUPSTSr_RESERVEDf_GET
#define DUPSTSr_RESERVEDf_SET BCM53128_A0_DUPSTSr_RESERVEDf_SET
#define READ_DUPSTSr BCM53128_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM53128_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_DUPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EAP_DIP
 * BLOCKS:   SYS
 * DESC:     EAP Destination IP Registers
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG     EAP destination IP mask register N
 *     DIP_SUB_REG      EAP destination IP subnet register N
 *
 ******************************************************************************/
#define BCM53128_A0_EAP_DIPr 0x00004202

#define BCM53128_A0_EAP_DIPr_SIZE 8

/*
 * This structure should be used to declare and program EAP_DIP.
 *
 */
typedef union BCM53128_A0_EAP_DIPr_s {
	uint32_t v[2];
	uint32_t eap_dip[2];
	uint32_t _eap_dip;
} BCM53128_A0_EAP_DIPr_t;

#define BCM53128_A0_EAP_DIPr_CLR(r) CDK_MEMSET(&((r)._eap_dip), 0, sizeof(BCM53128_A0_EAP_DIPr_t))
#define BCM53128_A0_EAP_DIPr_SET(r,i,d) (r).eap_dip[i] = d
#define BCM53128_A0_EAP_DIPr_GET(r,i) (r).eap_dip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EAP_DIPr_DIP_MASK_REGf_GET(r) ((r).eap_dip[0])
#define BCM53128_A0_EAP_DIPr_DIP_MASK_REGf_SET(r,f) (r).eap_dip[0]=((uint32_t)f)
#define BCM53128_A0_EAP_DIPr_DIP_SUB_REGf_GET(r) ((r).eap_dip[1])
#define BCM53128_A0_EAP_DIPr_DIP_SUB_REGf_SET(r,f) (r).eap_dip[1]=((uint32_t)f)

/*
 * These macros can be used to access EAP_DIP.
 *
 */
#define BCM53128_A0_READ_EAP_DIPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_EAP_DIPr+(8*(i)),(r._eap_dip),8)
#define BCM53128_A0_WRITE_EAP_DIPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_EAP_DIPr+(8*(i)),&(r._eap_dip),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_DIPr BCM53128_A0_EAP_DIPr
#define EAP_DIPr_SIZE BCM53128_A0_EAP_DIPr_SIZE
typedef BCM53128_A0_EAP_DIPr_t EAP_DIPr_t;
#define EAP_DIPr_CLR BCM53128_A0_EAP_DIPr_CLR
#define EAP_DIPr_SET BCM53128_A0_EAP_DIPr_SET
#define EAP_DIPr_GET BCM53128_A0_EAP_DIPr_GET
#define EAP_DIPr_DIP_MASK_REGf_GET BCM53128_A0_EAP_DIPr_DIP_MASK_REGf_GET
#define EAP_DIPr_DIP_MASK_REGf_SET BCM53128_A0_EAP_DIPr_DIP_MASK_REGf_SET
#define EAP_DIPr_DIP_SUB_REGf_GET BCM53128_A0_EAP_DIPr_DIP_SUB_REGf_GET
#define EAP_DIPr_DIP_SUB_REGf_SET BCM53128_A0_EAP_DIPr_DIP_SUB_REGf_SET
#define READ_EAP_DIPr BCM53128_A0_READ_EAP_DIPr
#define WRITE_EAP_DIPr BCM53128_A0_WRITE_EAP_DIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EAP_DIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EAP_GLO_CON
 * BLOCKS:   SYS
 * DESC:     EAP Global Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     EN_SPEC_SPK      When EAP_BLK_MODE is set, special frame type are allowed to pass:BPDU frame,DA : 01-80-C2-00-00-02(04-0F)2 multi-port DA
 *     EN_2_DIP         1'b1 : 2 subnet destination IP defined in EAP_DIP0_MASK & EAP_DIP1_MASK are allowed to pass1'b0 : drop
 *     EN_ARP           1'b1 : allow ARP to pass1'b0 : drop ARP
 *     EN_DHCP          1'b1 : allow DHCP to pass1'b0 : drop DHCP
 *     EN_RMC           When EAP_BLK_MODE is set,1'b1 : allow DA = 01-80-C2-00-00-02, 04-0F to pass1'b0 : drop DA = 01-80-C2-00-00-02, 04-0F
 *     EN_BPDU          When EAP_BLK_MODE is set,1'b1 : allow BPDU to pass1'b0 : drop BPDU
 *     EN_RARP          1'b1: allow RARP to pass1'b0: drop RARP
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EAP_GLO_CONr 0x00004200

#define BCM53128_A0_EAP_GLO_CONr_SIZE 1

/*
 * This structure should be used to declare and program EAP_GLO_CON.
 *
 */
typedef union BCM53128_A0_EAP_GLO_CONr_s {
	uint32_t v[1];
	uint32_t eap_glo_con[1];
	uint32_t _eap_glo_con;
} BCM53128_A0_EAP_GLO_CONr_t;

#define BCM53128_A0_EAP_GLO_CONr_CLR(r) (r).eap_glo_con[0] = 0
#define BCM53128_A0_EAP_GLO_CONr_SET(r,d) (r).eap_glo_con[0] = d
#define BCM53128_A0_EAP_GLO_CONr_GET(r) (r).eap_glo_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EAP_GLO_CONr_EN_SPEC_SPKf_GET(r) (((r).eap_glo_con[0]) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_SPEC_SPKf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_EAP_GLO_CONr_EN_2_DIPf_GET(r) ((((r).eap_glo_con[0]) >> 1) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_2_DIPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_EAP_GLO_CONr_EN_ARPf_GET(r) ((((r).eap_glo_con[0]) >> 2) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_ARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_EAP_GLO_CONr_EN_DHCPf_GET(r) ((((r).eap_glo_con[0]) >> 3) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_DHCPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_EAP_GLO_CONr_EN_RMCf_GET(r) ((((r).eap_glo_con[0]) >> 4) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_RMCf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_EAP_GLO_CONr_EN_BPDUf_GET(r) ((((r).eap_glo_con[0]) >> 5) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_BPDUf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_EAP_GLO_CONr_EN_RARPf_GET(r) ((((r).eap_glo_con[0]) >> 6) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_EN_RARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_EAP_GLO_CONr_RESERVED_0f_GET(r) ((((r).eap_glo_con[0]) >> 7) & 0x1)
#define BCM53128_A0_EAP_GLO_CONr_RESERVED_0f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access EAP_GLO_CON.
 *
 */
#define BCM53128_A0_READ_EAP_GLO_CONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EAP_GLO_CONr,(r._eap_glo_con),1)
#define BCM53128_A0_WRITE_EAP_GLO_CONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EAP_GLO_CONr,&(r._eap_glo_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_GLO_CONr BCM53128_A0_EAP_GLO_CONr
#define EAP_GLO_CONr_SIZE BCM53128_A0_EAP_GLO_CONr_SIZE
typedef BCM53128_A0_EAP_GLO_CONr_t EAP_GLO_CONr_t;
#define EAP_GLO_CONr_CLR BCM53128_A0_EAP_GLO_CONr_CLR
#define EAP_GLO_CONr_SET BCM53128_A0_EAP_GLO_CONr_SET
#define EAP_GLO_CONr_GET BCM53128_A0_EAP_GLO_CONr_GET
#define EAP_GLO_CONr_EN_SPEC_SPKf_GET BCM53128_A0_EAP_GLO_CONr_EN_SPEC_SPKf_GET
#define EAP_GLO_CONr_EN_SPEC_SPKf_SET BCM53128_A0_EAP_GLO_CONr_EN_SPEC_SPKf_SET
#define EAP_GLO_CONr_EN_2_DIPf_GET BCM53128_A0_EAP_GLO_CONr_EN_2_DIPf_GET
#define EAP_GLO_CONr_EN_2_DIPf_SET BCM53128_A0_EAP_GLO_CONr_EN_2_DIPf_SET
#define EAP_GLO_CONr_EN_ARPf_GET BCM53128_A0_EAP_GLO_CONr_EN_ARPf_GET
#define EAP_GLO_CONr_EN_ARPf_SET BCM53128_A0_EAP_GLO_CONr_EN_ARPf_SET
#define EAP_GLO_CONr_EN_DHCPf_GET BCM53128_A0_EAP_GLO_CONr_EN_DHCPf_GET
#define EAP_GLO_CONr_EN_DHCPf_SET BCM53128_A0_EAP_GLO_CONr_EN_DHCPf_SET
#define EAP_GLO_CONr_EN_RMCf_GET BCM53128_A0_EAP_GLO_CONr_EN_RMCf_GET
#define EAP_GLO_CONr_EN_RMCf_SET BCM53128_A0_EAP_GLO_CONr_EN_RMCf_SET
#define EAP_GLO_CONr_EN_BPDUf_GET BCM53128_A0_EAP_GLO_CONr_EN_BPDUf_GET
#define EAP_GLO_CONr_EN_BPDUf_SET BCM53128_A0_EAP_GLO_CONr_EN_BPDUf_SET
#define EAP_GLO_CONr_EN_RARPf_GET BCM53128_A0_EAP_GLO_CONr_EN_RARPf_GET
#define EAP_GLO_CONr_EN_RARPf_SET BCM53128_A0_EAP_GLO_CONr_EN_RARPf_SET
#define EAP_GLO_CONr_RESERVED_0f_GET BCM53128_A0_EAP_GLO_CONr_RESERVED_0f_GET
#define EAP_GLO_CONr_RESERVED_0f_SET BCM53128_A0_EAP_GLO_CONr_RESERVED_0f_SET
#define READ_EAP_GLO_CONr BCM53128_A0_READ_EAP_GLO_CONr
#define WRITE_EAP_GLO_CONr BCM53128_A0_WRITE_EAP_GLO_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EAP_GLO_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EAP_MULTI_ADDR_CTRL
 * BLOCKS:   SYS
 * DESC:     EAP Multiport Address Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_MPORT0        1'b1: allow multiport address define at Page/Offset=04/10h  to pass1'b0: drop
 *     EN_MPORT1        1'b1: allow multiport address define at Page/Offset=04/20h  to pass1'b0: drop
 *     EN_MPORT2        1'b1: allow multiport address define at Page/Offset=04/30h  to pass1'b0: drop
 *     EN_MPORT3        1'b1: allow multiport address define at Page/Offset=04/40h  to pass1'b0: drop
 *     EN_MPORT4        1'b1: allow multiport address define at Page/Offset=04/50h  to pass1'b0: drop
 *     EN_MPORT5        1'b1: allow multiport address define at Page/Offset=04/60h  to pass1'b0: drop
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr 0x00004201

#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program EAP_MULTI_ADDR_CTRL.
 *
 */
typedef union BCM53128_A0_EAP_MULTI_ADDR_CTRLr_s {
	uint32_t v[1];
	uint32_t eap_multi_addr_ctrl[1];
	uint32_t _eap_multi_addr_ctrl;
} BCM53128_A0_EAP_MULTI_ADDR_CTRLr_t;

#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_CLR(r) (r).eap_multi_addr_ctrl[0] = 0
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_SET(r,d) (r).eap_multi_addr_ctrl[0] = d
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_GET(r) (r).eap_multi_addr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET(r) (((r).eap_multi_addr_ctrl[0]) & 0x1)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 6) & 0x3)
#define BCM53128_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EAP_MULTI_ADDR_CTRL.
 *
 */
#define BCM53128_A0_READ_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EAP_MULTI_ADDR_CTRLr,(r._eap_multi_addr_ctrl),1)
#define BCM53128_A0_WRITE_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EAP_MULTI_ADDR_CTRLr,&(r._eap_multi_addr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_MULTI_ADDR_CTRLr BCM53128_A0_EAP_MULTI_ADDR_CTRLr
#define EAP_MULTI_ADDR_CTRLr_SIZE BCM53128_A0_EAP_MULTI_ADDR_CTRLr_SIZE
typedef BCM53128_A0_EAP_MULTI_ADDR_CTRLr_t EAP_MULTI_ADDR_CTRLr_t;
#define EAP_MULTI_ADDR_CTRLr_CLR BCM53128_A0_EAP_MULTI_ADDR_CTRLr_CLR
#define EAP_MULTI_ADDR_CTRLr_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_SET
#define EAP_MULTI_ADDR_CTRLr_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET
#define EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET
#define EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET BCM53128_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET
#define READ_EAP_MULTI_ADDR_CTRLr BCM53128_A0_READ_EAP_MULTI_ADDR_CTRLr
#define WRITE_EAP_MULTI_ADDR_CTRLr BCM53128_A0_WRITE_EAP_MULTI_ADDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EAP_MULTI_ADDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EAV_LNK_STATUS
 * BLOCKS:   SYS
 * DESC:     AVB Port AVB Link Status Register
 * SIZE:     16
 * FIELDS:
 *     PT_EAV_LNK_STATUS When software write the port AVB link status and select bit 14 in LED function.The AVB link status is shown on the LED.bits[7:0] : for port7~port0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EAV_LNK_STATUSr 0x000090e0

#define BCM53128_A0_EAV_LNK_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program EAV_LNK_STATUS.
 *
 */
typedef union BCM53128_A0_EAV_LNK_STATUSr_s {
	uint32_t v[1];
	uint32_t eav_lnk_status[1];
	uint32_t _eav_lnk_status;
} BCM53128_A0_EAV_LNK_STATUSr_t;

#define BCM53128_A0_EAV_LNK_STATUSr_CLR(r) (r).eav_lnk_status[0] = 0
#define BCM53128_A0_EAV_LNK_STATUSr_SET(r,d) (r).eav_lnk_status[0] = d
#define BCM53128_A0_EAV_LNK_STATUSr_GET(r) (r).eav_lnk_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET(r) (((r).eav_lnk_status[0]) & 0x1ff)
#define BCM53128_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_EAV_LNK_STATUSr_RESERVEDf_GET(r) ((((r).eav_lnk_status[0]) >> 9) & 0x7f)
#define BCM53128_A0_EAV_LNK_STATUSr_RESERVEDf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EAV_LNK_STATUS.
 *
 */
#define BCM53128_A0_READ_EAV_LNK_STATUSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EAV_LNK_STATUSr,(r._eav_lnk_status),2)
#define BCM53128_A0_WRITE_EAV_LNK_STATUSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EAV_LNK_STATUSr,&(r._eav_lnk_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAV_LNK_STATUSr BCM53128_A0_EAV_LNK_STATUSr
#define EAV_LNK_STATUSr_SIZE BCM53128_A0_EAV_LNK_STATUSr_SIZE
typedef BCM53128_A0_EAV_LNK_STATUSr_t EAV_LNK_STATUSr_t;
#define EAV_LNK_STATUSr_CLR BCM53128_A0_EAV_LNK_STATUSr_CLR
#define EAV_LNK_STATUSr_SET BCM53128_A0_EAV_LNK_STATUSr_SET
#define EAV_LNK_STATUSr_GET BCM53128_A0_EAV_LNK_STATUSr_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET BCM53128_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET BCM53128_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET
#define EAV_LNK_STATUSr_RESERVEDf_GET BCM53128_A0_EAV_LNK_STATUSr_RESERVEDf_GET
#define EAV_LNK_STATUSr_RESERVEDf_SET BCM53128_A0_EAV_LNK_STATUSr_RESERVEDf_SET
#define READ_EAV_LNK_STATUSr BCM53128_A0_READ_EAV_LNK_STATUSr
#define WRITE_EAV_LNK_STATUSr BCM53128_A0_WRITE_EAV_LNK_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EAV_LNK_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_DEBUG
 * BLOCKS:   SYS
 * DESC:     EEE Debug Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DIS_EMPTY_FLOW_CON Disable flow control checking in TXQ empty condition.0 = transmitQueueEmpty condition is included flow control checking(i.e. TXQ is not empty if "need_flow_con" = high). 1 = transmitQueueEmpty condition is not included flow control checking. 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_DEBUGr 0x000092e7

#define BCM53128_A0_EEE_DEBUGr_SIZE 1

/*
 * This structure should be used to declare and program EEE_DEBUG.
 *
 */
typedef union BCM53128_A0_EEE_DEBUGr_s {
	uint32_t v[1];
	uint32_t eee_debug[1];
	uint32_t _eee_debug;
} BCM53128_A0_EEE_DEBUGr_t;

#define BCM53128_A0_EEE_DEBUGr_CLR(r) (r).eee_debug[0] = 0
#define BCM53128_A0_EEE_DEBUGr_SET(r,d) (r).eee_debug[0] = d
#define BCM53128_A0_EEE_DEBUGr_GET(r) (r).eee_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_GET(r) (((r).eee_debug[0]) & 0x1)
#define BCM53128_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_SET(r,f) (r).eee_debug[0]=(((r).eee_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_EEE_DEBUGr_RESERVEDf_GET(r) ((((r).eee_debug[0]) >> 1) & 0x7f)
#define BCM53128_A0_EEE_DEBUGr_RESERVEDf_SET(r,f) (r).eee_debug[0]=(((r).eee_debug[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access EEE_DEBUG.
 *
 */
#define BCM53128_A0_READ_EEE_DEBUGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_DEBUGr,(r._eee_debug),1)
#define BCM53128_A0_WRITE_EEE_DEBUGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_DEBUGr,&(r._eee_debug),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_DEBUGr BCM53128_A0_EEE_DEBUGr
#define EEE_DEBUGr_SIZE BCM53128_A0_EEE_DEBUGr_SIZE
typedef BCM53128_A0_EEE_DEBUGr_t EEE_DEBUGr_t;
#define EEE_DEBUGr_CLR BCM53128_A0_EEE_DEBUGr_CLR
#define EEE_DEBUGr_SET BCM53128_A0_EEE_DEBUGr_SET
#define EEE_DEBUGr_GET BCM53128_A0_EEE_DEBUGr_GET
#define EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_GET BCM53128_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_GET
#define EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_SET BCM53128_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_SET
#define EEE_DEBUGr_RESERVEDf_GET BCM53128_A0_EEE_DEBUGr_RESERVEDf_GET
#define EEE_DEBUGr_RESERVEDf_SET BCM53128_A0_EEE_DEBUGr_RESERVEDf_SET
#define READ_EEE_DEBUGr BCM53128_A0_READ_EEE_DEBUGr
#define WRITE_EEE_DEBUGr BCM53128_A0_WRITE_EEE_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     EEE Enable Control Registers
 * SIZE:     16
 * FIELDS:
 *     EN_EEE           Enable/Disable EEE9 bit field to enable/disable EEE.(bit 0-7 = port 0- port 7, bit 8 = IMP port)1 = Enable EEE0 = Disable EEEThe port 0 ~ port 7(internal PHY) default value read from en_eee pin on power-on. Can be overwritten subsequently.For unmanaged switch, the default value is suggested to enable EEE on power-on(i.e. en_eee_pin = 1).For managed switch, the default value is suggested to disable EEE on power-on(i.e. en_eee_pin = 0). to allow the processor to initial application and configuration, before EEE is enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_EN_CTRLr 0x00009200

#define BCM53128_A0_EEE_EN_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program EEE_EN_CTRL.
 *
 */
typedef union BCM53128_A0_EEE_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t eee_en_ctrl[1];
	uint32_t _eee_en_ctrl;
} BCM53128_A0_EEE_EN_CTRLr_t;

#define BCM53128_A0_EEE_EN_CTRLr_CLR(r) (r).eee_en_ctrl[0] = 0
#define BCM53128_A0_EEE_EN_CTRLr_SET(r,d) (r).eee_en_ctrl[0] = d
#define BCM53128_A0_EEE_EN_CTRLr_GET(r) (r).eee_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_EN_CTRLr_EN_EEEf_GET(r) (((r).eee_en_ctrl[0]) & 0x1ff)
#define BCM53128_A0_EEE_EN_CTRLr_EN_EEEf_SET(r,f) (r).eee_en_ctrl[0]=(((r).eee_en_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_EEE_EN_CTRLr_RESERVEDf_GET(r) ((((r).eee_en_ctrl[0]) >> 9) & 0x7f)
#define BCM53128_A0_EEE_EN_CTRLr_RESERVEDf_SET(r,f) (r).eee_en_ctrl[0]=(((r).eee_en_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_EN_CTRL.
 *
 */
#define BCM53128_A0_READ_EEE_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_EN_CTRLr,(r._eee_en_ctrl),2)
#define BCM53128_A0_WRITE_EEE_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_EN_CTRLr,&(r._eee_en_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_EN_CTRLr BCM53128_A0_EEE_EN_CTRLr
#define EEE_EN_CTRLr_SIZE BCM53128_A0_EEE_EN_CTRLr_SIZE
typedef BCM53128_A0_EEE_EN_CTRLr_t EEE_EN_CTRLr_t;
#define EEE_EN_CTRLr_CLR BCM53128_A0_EEE_EN_CTRLr_CLR
#define EEE_EN_CTRLr_SET BCM53128_A0_EEE_EN_CTRLr_SET
#define EEE_EN_CTRLr_GET BCM53128_A0_EEE_EN_CTRLr_GET
#define EEE_EN_CTRLr_EN_EEEf_GET BCM53128_A0_EEE_EN_CTRLr_EN_EEEf_GET
#define EEE_EN_CTRLr_EN_EEEf_SET BCM53128_A0_EEE_EN_CTRLr_EN_EEEf_SET
#define EEE_EN_CTRLr_RESERVEDf_GET BCM53128_A0_EEE_EN_CTRLr_RESERVEDf_GET
#define EEE_EN_CTRLr_RESERVEDf_SET BCM53128_A0_EEE_EN_CTRLr_RESERVEDf_SET
#define READ_EEE_EN_CTRLr BCM53128_A0_READ_EEE_EN_CTRLr
#define WRITE_EEE_EN_CTRLr BCM53128_A0_WRITE_EEE_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_GLB_CONG_TH
 * BLOCKS:   SYS
 * DESC:     EEE Global Congestion Threshold Registers
 * SIZE:     16
 * FIELDS:
 *     GLB_CONG_TH      EEE Global packet buffer congestion threshold.If this threshold is set to zero, then EEE is effectively disabled, if this threshold is set equal to or greater than 768(the number of cells implemented in the packet buffer), then protections against packet loss are disabled.The unit is "Buffer Cell Size": 256-byte cell.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_GLB_CONG_THr 0x000092c4

#define BCM53128_A0_EEE_GLB_CONG_THr_SIZE 2

/*
 * This structure should be used to declare and program EEE_GLB_CONG_TH.
 *
 */
typedef union BCM53128_A0_EEE_GLB_CONG_THr_s {
	uint32_t v[1];
	uint32_t eee_glb_cong_th[1];
	uint32_t _eee_glb_cong_th;
} BCM53128_A0_EEE_GLB_CONG_THr_t;

#define BCM53128_A0_EEE_GLB_CONG_THr_CLR(r) (r).eee_glb_cong_th[0] = 0
#define BCM53128_A0_EEE_GLB_CONG_THr_SET(r,d) (r).eee_glb_cong_th[0] = d
#define BCM53128_A0_EEE_GLB_CONG_THr_GET(r) (r).eee_glb_cong_th[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_GET(r) (((r).eee_glb_cong_th[0]) & 0x7ff)
#define BCM53128_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_SET(r,f) (r).eee_glb_cong_th[0]=(((r).eee_glb_cong_th[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_EEE_GLB_CONG_THr_RESERVEDf_GET(r) ((((r).eee_glb_cong_th[0]) >> 11) & 0x1f)
#define BCM53128_A0_EEE_GLB_CONG_THr_RESERVEDf_SET(r,f) (r).eee_glb_cong_th[0]=(((r).eee_glb_cong_th[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access EEE_GLB_CONG_TH.
 *
 */
#define BCM53128_A0_READ_EEE_GLB_CONG_THr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_GLB_CONG_THr,(r._eee_glb_cong_th),2)
#define BCM53128_A0_WRITE_EEE_GLB_CONG_THr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_GLB_CONG_THr,&(r._eee_glb_cong_th),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_GLB_CONG_THr BCM53128_A0_EEE_GLB_CONG_THr
#define EEE_GLB_CONG_THr_SIZE BCM53128_A0_EEE_GLB_CONG_THr_SIZE
typedef BCM53128_A0_EEE_GLB_CONG_THr_t EEE_GLB_CONG_THr_t;
#define EEE_GLB_CONG_THr_CLR BCM53128_A0_EEE_GLB_CONG_THr_CLR
#define EEE_GLB_CONG_THr_SET BCM53128_A0_EEE_GLB_CONG_THr_SET
#define EEE_GLB_CONG_THr_GET BCM53128_A0_EEE_GLB_CONG_THr_GET
#define EEE_GLB_CONG_THr_GLB_CONG_THf_GET BCM53128_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_GET
#define EEE_GLB_CONG_THr_GLB_CONG_THf_SET BCM53128_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_SET
#define EEE_GLB_CONG_THr_RESERVEDf_GET BCM53128_A0_EEE_GLB_CONG_THr_RESERVEDf_GET
#define EEE_GLB_CONG_THr_RESERVEDf_SET BCM53128_A0_EEE_GLB_CONG_THr_RESERVEDf_SET
#define READ_EEE_GLB_CONG_THr BCM53128_A0_READ_EEE_GLB_CONG_THr
#define WRITE_EEE_GLB_CONG_THr BCM53128_A0_WRITE_EEE_GLB_CONG_THr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_GLB_CONG_THr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LINK_DLY_TIMER
 * BLOCKS:   CPIC
 * DESC:     EEE Link Delay Timer Registers(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     LINK_DLY_TIMER   EEE link delay timer.When chip is reset or link status change, the link delay timer is started after port link up. When the link delay timer expires, EEE state machine is transite from INIT state to WAIT state.The unit is 1 usec.Note: The purpose of this timer is to prevent the first packet be hold in the TXQ when chip is reset or link status change. For example, the packet may be not completely received and EEE is entering low-power idle state, the packet is queued until EEE time out.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LINK_DLY_TIMERr 0x000092e8

#define BCM53128_A0_EEE_LINK_DLY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LINK_DLY_TIMER.
 *
 */
typedef union BCM53128_A0_EEE_LINK_DLY_TIMERr_s {
	uint32_t v[1];
	uint32_t eee_link_dly_timer[1];
	uint32_t _eee_link_dly_timer;
} BCM53128_A0_EEE_LINK_DLY_TIMERr_t;

#define BCM53128_A0_EEE_LINK_DLY_TIMERr_CLR(r) (r).eee_link_dly_timer[0] = 0
#define BCM53128_A0_EEE_LINK_DLY_TIMERr_SET(r,d) (r).eee_link_dly_timer[0] = d
#define BCM53128_A0_EEE_LINK_DLY_TIMERr_GET(r) (r).eee_link_dly_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_GET(r) ((r).eee_link_dly_timer[0])
#define BCM53128_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_SET(r,f) (r).eee_link_dly_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_LINK_DLY_TIMER.
 *
 */
#define BCM53128_A0_READ_EEE_LINK_DLY_TIMERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_LINK_DLY_TIMERr,(r._eee_link_dly_timer),4)
#define BCM53128_A0_WRITE_EEE_LINK_DLY_TIMERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_LINK_DLY_TIMERr,&(r._eee_link_dly_timer),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LINK_DLY_TIMERr BCM53128_A0_EEE_LINK_DLY_TIMERr
#define EEE_LINK_DLY_TIMERr_SIZE BCM53128_A0_EEE_LINK_DLY_TIMERr_SIZE
typedef BCM53128_A0_EEE_LINK_DLY_TIMERr_t EEE_LINK_DLY_TIMERr_t;
#define EEE_LINK_DLY_TIMERr_CLR BCM53128_A0_EEE_LINK_DLY_TIMERr_CLR
#define EEE_LINK_DLY_TIMERr_SET BCM53128_A0_EEE_LINK_DLY_TIMERr_SET
#define EEE_LINK_DLY_TIMERr_GET BCM53128_A0_EEE_LINK_DLY_TIMERr_GET
#define EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_GET BCM53128_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_GET
#define EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_SET BCM53128_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_SET
#define READ_EEE_LINK_DLY_TIMERr BCM53128_A0_READ_EEE_LINK_DLY_TIMERr
#define WRITE_EEE_LINK_DLY_TIMERr BCM53128_A0_WRITE_EEE_LINK_DLY_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LINK_DLY_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LPI_ASSERT
 * BLOCKS:   SYS
 * DESC:     EEE Low Power Assert Status Registers
 * SIZE:     16
 * FIELDS:
 *     LPI_ASSERT       Low Power Assert input signal status.9 bit indicating that a lowPowerAssert input signal that commands the transmit MAC to generate low-power idle symbols to the PHY once the transmit MAC is done transmitting any in-process packet.(bit 0-7 = port 0- port 7, bit 8 = IMP port)1 = asserted0 = deasserted
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LPI_ASSERTr 0x00009202

#define BCM53128_A0_EEE_LPI_ASSERTr_SIZE 2

/*
 * This structure should be used to declare and program EEE_LPI_ASSERT.
 *
 */
typedef union BCM53128_A0_EEE_LPI_ASSERTr_s {
	uint32_t v[1];
	uint32_t eee_lpi_assert[1];
	uint32_t _eee_lpi_assert;
} BCM53128_A0_EEE_LPI_ASSERTr_t;

#define BCM53128_A0_EEE_LPI_ASSERTr_CLR(r) (r).eee_lpi_assert[0] = 0
#define BCM53128_A0_EEE_LPI_ASSERTr_SET(r,d) (r).eee_lpi_assert[0] = d
#define BCM53128_A0_EEE_LPI_ASSERTr_GET(r) (r).eee_lpi_assert[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_GET(r) (((r).eee_lpi_assert[0]) & 0x1ff)
#define BCM53128_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_SET(r,f) (r).eee_lpi_assert[0]=(((r).eee_lpi_assert[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_EEE_LPI_ASSERTr_RESERVEDf_GET(r) ((((r).eee_lpi_assert[0]) >> 9) & 0x7f)
#define BCM53128_A0_EEE_LPI_ASSERTr_RESERVEDf_SET(r,f) (r).eee_lpi_assert[0]=(((r).eee_lpi_assert[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_LPI_ASSERT.
 *
 */
#define BCM53128_A0_READ_EEE_LPI_ASSERTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_LPI_ASSERTr,(r._eee_lpi_assert),2)
#define BCM53128_A0_WRITE_EEE_LPI_ASSERTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_LPI_ASSERTr,&(r._eee_lpi_assert),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_ASSERTr BCM53128_A0_EEE_LPI_ASSERTr
#define EEE_LPI_ASSERTr_SIZE BCM53128_A0_EEE_LPI_ASSERTr_SIZE
typedef BCM53128_A0_EEE_LPI_ASSERTr_t EEE_LPI_ASSERTr_t;
#define EEE_LPI_ASSERTr_CLR BCM53128_A0_EEE_LPI_ASSERTr_CLR
#define EEE_LPI_ASSERTr_SET BCM53128_A0_EEE_LPI_ASSERTr_SET
#define EEE_LPI_ASSERTr_GET BCM53128_A0_EEE_LPI_ASSERTr_GET
#define EEE_LPI_ASSERTr_LPI_ASSERTf_GET BCM53128_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_GET
#define EEE_LPI_ASSERTr_LPI_ASSERTf_SET BCM53128_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_SET
#define EEE_LPI_ASSERTr_RESERVEDf_GET BCM53128_A0_EEE_LPI_ASSERTr_RESERVEDf_GET
#define EEE_LPI_ASSERTr_RESERVEDf_SET BCM53128_A0_EEE_LPI_ASSERTr_RESERVEDf_SET
#define READ_EEE_LPI_ASSERTr BCM53128_A0_READ_EEE_LPI_ASSERTr
#define WRITE_EEE_LPI_ASSERTr BCM53128_A0_WRITE_EEE_LPI_ASSERTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LPI_ASSERTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LPI_DURATION
 * BLOCKS:   GPIC0 CPIC
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LPI_DURATIONr 0x000020bc

#define BCM53128_A0_EEE_LPI_DURATIONr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_DURATION.
 *
 */
typedef union BCM53128_A0_EEE_LPI_DURATIONr_s {
	uint32_t v[1];
	uint32_t eee_lpi_duration[1];
	uint32_t _eee_lpi_duration;
} BCM53128_A0_EEE_LPI_DURATIONr_t;

#define BCM53128_A0_EEE_LPI_DURATIONr_CLR(r) (r).eee_lpi_duration[0] = 0
#define BCM53128_A0_EEE_LPI_DURATIONr_SET(r,d) (r).eee_lpi_duration[0] = d
#define BCM53128_A0_EEE_LPI_DURATIONr_GET(r) (r).eee_lpi_duration[0]


/*
 * These macros can be used to access EEE_LPI_DURATION.
 *
 */
#define BCM53128_A0_READ_EEE_LPI_DURATIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_LPI_DURATIONr,(r._eee_lpi_duration),4)
#define BCM53128_A0_WRITE_EEE_LPI_DURATIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_LPI_DURATIONr,&(r._eee_lpi_duration),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_DURATIONr BCM53128_A0_EEE_LPI_DURATIONr
#define EEE_LPI_DURATIONr_SIZE BCM53128_A0_EEE_LPI_DURATIONr_SIZE
typedef BCM53128_A0_EEE_LPI_DURATIONr_t EEE_LPI_DURATIONr_t;
#define EEE_LPI_DURATIONr_CLR BCM53128_A0_EEE_LPI_DURATIONr_CLR
#define EEE_LPI_DURATIONr_SET BCM53128_A0_EEE_LPI_DURATIONr_SET
#define EEE_LPI_DURATIONr_GET BCM53128_A0_EEE_LPI_DURATIONr_GET
#define READ_EEE_LPI_DURATIONr BCM53128_A0_READ_EEE_LPI_DURATIONr
#define WRITE_EEE_LPI_DURATIONr BCM53128_A0_WRITE_EEE_LPI_DURATIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LPI_DURATIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LPI_DURATION_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LPI_DURATION_IMPr 0x000028bc

#define BCM53128_A0_EEE_LPI_DURATION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_DURATION_IMP.
 *
 */
typedef union BCM53128_A0_EEE_LPI_DURATION_IMPr_s {
	uint32_t v[1];
	uint32_t eee_lpi_duration_imp[1];
	uint32_t _eee_lpi_duration_imp;
} BCM53128_A0_EEE_LPI_DURATION_IMPr_t;

#define BCM53128_A0_EEE_LPI_DURATION_IMPr_CLR(r) (r).eee_lpi_duration_imp[0] = 0
#define BCM53128_A0_EEE_LPI_DURATION_IMPr_SET(r,d) (r).eee_lpi_duration_imp[0] = d
#define BCM53128_A0_EEE_LPI_DURATION_IMPr_GET(r) (r).eee_lpi_duration_imp[0]


/*
 * These macros can be used to access EEE_LPI_DURATION_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_LPI_DURATION_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_LPI_DURATION_IMPr,(r._eee_lpi_duration_imp),4)
#define BCM53128_A0_WRITE_EEE_LPI_DURATION_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_LPI_DURATION_IMPr,&(r._eee_lpi_duration_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_DURATION_IMPr BCM53128_A0_EEE_LPI_DURATION_IMPr
#define EEE_LPI_DURATION_IMPr_SIZE BCM53128_A0_EEE_LPI_DURATION_IMPr_SIZE
typedef BCM53128_A0_EEE_LPI_DURATION_IMPr_t EEE_LPI_DURATION_IMPr_t;
#define EEE_LPI_DURATION_IMPr_CLR BCM53128_A0_EEE_LPI_DURATION_IMPr_CLR
#define EEE_LPI_DURATION_IMPr_SET BCM53128_A0_EEE_LPI_DURATION_IMPr_SET
#define EEE_LPI_DURATION_IMPr_GET BCM53128_A0_EEE_LPI_DURATION_IMPr_GET
#define READ_EEE_LPI_DURATION_IMPr BCM53128_A0_READ_EEE_LPI_DURATION_IMPr
#define WRITE_EEE_LPI_DURATION_IMPr BCM53128_A0_WRITE_EEE_LPI_DURATION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LPI_DURATION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LPI_EVENT
 * BLOCKS:   GPIC0 CPIC
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LPI_EVENTr 0x000020b8

#define BCM53128_A0_EEE_LPI_EVENTr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_EVENT.
 *
 */
typedef union BCM53128_A0_EEE_LPI_EVENTr_s {
	uint32_t v[1];
	uint32_t eee_lpi_event[1];
	uint32_t _eee_lpi_event;
} BCM53128_A0_EEE_LPI_EVENTr_t;

#define BCM53128_A0_EEE_LPI_EVENTr_CLR(r) (r).eee_lpi_event[0] = 0
#define BCM53128_A0_EEE_LPI_EVENTr_SET(r,d) (r).eee_lpi_event[0] = d
#define BCM53128_A0_EEE_LPI_EVENTr_GET(r) (r).eee_lpi_event[0]


/*
 * These macros can be used to access EEE_LPI_EVENT.
 *
 */
#define BCM53128_A0_READ_EEE_LPI_EVENTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_LPI_EVENTr,(r._eee_lpi_event),4)
#define BCM53128_A0_WRITE_EEE_LPI_EVENTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_LPI_EVENTr,&(r._eee_lpi_event),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_EVENTr BCM53128_A0_EEE_LPI_EVENTr
#define EEE_LPI_EVENTr_SIZE BCM53128_A0_EEE_LPI_EVENTr_SIZE
typedef BCM53128_A0_EEE_LPI_EVENTr_t EEE_LPI_EVENTr_t;
#define EEE_LPI_EVENTr_CLR BCM53128_A0_EEE_LPI_EVENTr_CLR
#define EEE_LPI_EVENTr_SET BCM53128_A0_EEE_LPI_EVENTr_SET
#define EEE_LPI_EVENTr_GET BCM53128_A0_EEE_LPI_EVENTr_GET
#define READ_EEE_LPI_EVENTr BCM53128_A0_READ_EEE_LPI_EVENTr
#define WRITE_EEE_LPI_EVENTr BCM53128_A0_WRITE_EEE_LPI_EVENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LPI_EVENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LPI_EVENT_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LPI_EVENT_IMPr 0x000028b8

#define BCM53128_A0_EEE_LPI_EVENT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_EVENT_IMP.
 *
 */
typedef union BCM53128_A0_EEE_LPI_EVENT_IMPr_s {
	uint32_t v[1];
	uint32_t eee_lpi_event_imp[1];
	uint32_t _eee_lpi_event_imp;
} BCM53128_A0_EEE_LPI_EVENT_IMPr_t;

#define BCM53128_A0_EEE_LPI_EVENT_IMPr_CLR(r) (r).eee_lpi_event_imp[0] = 0
#define BCM53128_A0_EEE_LPI_EVENT_IMPr_SET(r,d) (r).eee_lpi_event_imp[0] = d
#define BCM53128_A0_EEE_LPI_EVENT_IMPr_GET(r) (r).eee_lpi_event_imp[0]


/*
 * These macros can be used to access EEE_LPI_EVENT_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_LPI_EVENT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_LPI_EVENT_IMPr,(r._eee_lpi_event_imp),4)
#define BCM53128_A0_WRITE_EEE_LPI_EVENT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_LPI_EVENT_IMPr,&(r._eee_lpi_event_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_EVENT_IMPr BCM53128_A0_EEE_LPI_EVENT_IMPr
#define EEE_LPI_EVENT_IMPr_SIZE BCM53128_A0_EEE_LPI_EVENT_IMPr_SIZE
typedef BCM53128_A0_EEE_LPI_EVENT_IMPr_t EEE_LPI_EVENT_IMPr_t;
#define EEE_LPI_EVENT_IMPr_CLR BCM53128_A0_EEE_LPI_EVENT_IMPr_CLR
#define EEE_LPI_EVENT_IMPr_SET BCM53128_A0_EEE_LPI_EVENT_IMPr_SET
#define EEE_LPI_EVENT_IMPr_GET BCM53128_A0_EEE_LPI_EVENT_IMPr_GET
#define READ_EEE_LPI_EVENT_IMPr BCM53128_A0_READ_EEE_LPI_EVENT_IMPr
#define WRITE_EEE_LPI_EVENT_IMPr BCM53128_A0_WRITE_EEE_LPI_EVENT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LPI_EVENT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_LPI_INDICATE
 * BLOCKS:   SYS
 * DESC:     EEE Low Power Indicate Status Registers
 * SIZE:     16
 * FIELDS:
 *     LPI_INDICATE     lowPowerIndicate output signal status.9 bit indicating that a lowPowerIndicate output that is asserted whenever the receive PHY is sending low-power idle symbols to the receive MAC.(bit 0-7 = port 0- port 7, bit 8 = IMP port)1 = asserted0 = deasserted
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_LPI_INDICATEr 0x00009204

#define BCM53128_A0_EEE_LPI_INDICATEr_SIZE 2

/*
 * This structure should be used to declare and program EEE_LPI_INDICATE.
 *
 */
typedef union BCM53128_A0_EEE_LPI_INDICATEr_s {
	uint32_t v[1];
	uint32_t eee_lpi_indicate[1];
	uint32_t _eee_lpi_indicate;
} BCM53128_A0_EEE_LPI_INDICATEr_t;

#define BCM53128_A0_EEE_LPI_INDICATEr_CLR(r) (r).eee_lpi_indicate[0] = 0
#define BCM53128_A0_EEE_LPI_INDICATEr_SET(r,d) (r).eee_lpi_indicate[0] = d
#define BCM53128_A0_EEE_LPI_INDICATEr_GET(r) (r).eee_lpi_indicate[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_GET(r) (((r).eee_lpi_indicate[0]) & 0x1ff)
#define BCM53128_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_SET(r,f) (r).eee_lpi_indicate[0]=(((r).eee_lpi_indicate[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_EEE_LPI_INDICATEr_RESERVEDf_GET(r) ((((r).eee_lpi_indicate[0]) >> 9) & 0x7f)
#define BCM53128_A0_EEE_LPI_INDICATEr_RESERVEDf_SET(r,f) (r).eee_lpi_indicate[0]=(((r).eee_lpi_indicate[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_LPI_INDICATE.
 *
 */
#define BCM53128_A0_READ_EEE_LPI_INDICATEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_LPI_INDICATEr,(r._eee_lpi_indicate),2)
#define BCM53128_A0_WRITE_EEE_LPI_INDICATEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_LPI_INDICATEr,&(r._eee_lpi_indicate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_INDICATEr BCM53128_A0_EEE_LPI_INDICATEr
#define EEE_LPI_INDICATEr_SIZE BCM53128_A0_EEE_LPI_INDICATEr_SIZE
typedef BCM53128_A0_EEE_LPI_INDICATEr_t EEE_LPI_INDICATEr_t;
#define EEE_LPI_INDICATEr_CLR BCM53128_A0_EEE_LPI_INDICATEr_CLR
#define EEE_LPI_INDICATEr_SET BCM53128_A0_EEE_LPI_INDICATEr_SET
#define EEE_LPI_INDICATEr_GET BCM53128_A0_EEE_LPI_INDICATEr_GET
#define EEE_LPI_INDICATEr_LPI_INDICATEf_GET BCM53128_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_GET
#define EEE_LPI_INDICATEr_LPI_INDICATEf_SET BCM53128_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_SET
#define EEE_LPI_INDICATEr_RESERVEDf_GET BCM53128_A0_EEE_LPI_INDICATEr_RESERVEDf_GET
#define EEE_LPI_INDICATEr_RESERVEDf_SET BCM53128_A0_EEE_LPI_INDICATEr_RESERVEDf_SET
#define READ_EEE_LPI_INDICATEr BCM53128_A0_READ_EEE_LPI_INDICATEr
#define WRITE_EEE_LPI_INDICATEr BCM53128_A0_WRITE_EEE_LPI_INDICATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_LPI_INDICATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_MIN_LP_TIMER_G
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Minimum Low-Power Duration Timer - 1G Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_G   EEE minimum low-power duration delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr 0x00009258

#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_G.
 *
 */
typedef union BCM53128_A0_EEE_MIN_LP_TIMER_Gr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_g[1];
	uint32_t _eee_min_lp_timer_g;
} BCM53128_A0_EEE_MIN_LP_TIMER_Gr_t;

#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr_CLR(r) (r).eee_min_lp_timer_g[0] = 0
#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr_SET(r,d) (r).eee_min_lp_timer_g[0] = d
#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr_GET(r) (r).eee_min_lp_timer_g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_GET(r) ((r).eee_min_lp_timer_g[0])
#define BCM53128_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_SET(r,f) (r).eee_min_lp_timer_g[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_G.
 *
 */
#define BCM53128_A0_READ_EEE_MIN_LP_TIMER_Gr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_MIN_LP_TIMER_Gr,(r._eee_min_lp_timer_g),4)
#define BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_Gr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_MIN_LP_TIMER_Gr,&(r._eee_min_lp_timer_g),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_Gr BCM53128_A0_EEE_MIN_LP_TIMER_Gr
#define EEE_MIN_LP_TIMER_Gr_SIZE BCM53128_A0_EEE_MIN_LP_TIMER_Gr_SIZE
typedef BCM53128_A0_EEE_MIN_LP_TIMER_Gr_t EEE_MIN_LP_TIMER_Gr_t;
#define EEE_MIN_LP_TIMER_Gr_CLR BCM53128_A0_EEE_MIN_LP_TIMER_Gr_CLR
#define EEE_MIN_LP_TIMER_Gr_SET BCM53128_A0_EEE_MIN_LP_TIMER_Gr_SET
#define EEE_MIN_LP_TIMER_Gr_GET BCM53128_A0_EEE_MIN_LP_TIMER_Gr_GET
#define EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_GET BCM53128_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_GET
#define EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_SET BCM53128_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_SET
#define READ_EEE_MIN_LP_TIMER_Gr BCM53128_A0_READ_EEE_MIN_LP_TIMER_Gr
#define WRITE_EEE_MIN_LP_TIMER_Gr BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_Gr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_MIN_LP_TIMER_Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_MIN_LP_TIMER_G_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Minimum Low-Power Duration Timer Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_G_IMP EEE minimum low-power duration delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr 0x00009278

#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_G_IMP.
 *
 */
typedef union BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_g_imp[1];
	uint32_t _eee_min_lp_timer_g_imp;
} BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_t;

#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_CLR(r) (r).eee_min_lp_timer_g_imp[0] = 0
#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_SET(r,d) (r).eee_min_lp_timer_g_imp[0] = d
#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_GET(r) (r).eee_min_lp_timer_g_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_GET(r) ((r).eee_min_lp_timer_g_imp[0])
#define BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_SET(r,f) (r).eee_min_lp_timer_g_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_G_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_MIN_LP_TIMER_G_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr,(r._eee_min_lp_timer_g_imp),4)
#define BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_G_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr,&(r._eee_min_lp_timer_g_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_G_IMPr BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr
#define EEE_MIN_LP_TIMER_G_IMPr_SIZE BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_SIZE
typedef BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_t EEE_MIN_LP_TIMER_G_IMPr_t;
#define EEE_MIN_LP_TIMER_G_IMPr_CLR BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_CLR
#define EEE_MIN_LP_TIMER_G_IMPr_SET BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_SET
#define EEE_MIN_LP_TIMER_G_IMPr_GET BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_GET
#define EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_GET BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_GET
#define EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_SET BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_SET
#define READ_EEE_MIN_LP_TIMER_G_IMPr BCM53128_A0_READ_EEE_MIN_LP_TIMER_G_IMPr
#define WRITE_EEE_MIN_LP_TIMER_G_IMPr BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_G_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_MIN_LP_TIMER_G_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_MIN_LP_TIMER_H
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Minimum Low-Power Duration Timer - 100M Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_H   EEE minimum low-power duration delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr 0x0000927c

#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_H.
 *
 */
typedef union BCM53128_A0_EEE_MIN_LP_TIMER_Hr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_h[1];
	uint32_t _eee_min_lp_timer_h;
} BCM53128_A0_EEE_MIN_LP_TIMER_Hr_t;

#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr_CLR(r) (r).eee_min_lp_timer_h[0] = 0
#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr_SET(r,d) (r).eee_min_lp_timer_h[0] = d
#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr_GET(r) (r).eee_min_lp_timer_h[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_GET(r) ((r).eee_min_lp_timer_h[0])
#define BCM53128_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_SET(r,f) (r).eee_min_lp_timer_h[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_H.
 *
 */
#define BCM53128_A0_READ_EEE_MIN_LP_TIMER_Hr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_MIN_LP_TIMER_Hr,(r._eee_min_lp_timer_h),4)
#define BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_Hr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_MIN_LP_TIMER_Hr,&(r._eee_min_lp_timer_h),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_Hr BCM53128_A0_EEE_MIN_LP_TIMER_Hr
#define EEE_MIN_LP_TIMER_Hr_SIZE BCM53128_A0_EEE_MIN_LP_TIMER_Hr_SIZE
typedef BCM53128_A0_EEE_MIN_LP_TIMER_Hr_t EEE_MIN_LP_TIMER_Hr_t;
#define EEE_MIN_LP_TIMER_Hr_CLR BCM53128_A0_EEE_MIN_LP_TIMER_Hr_CLR
#define EEE_MIN_LP_TIMER_Hr_SET BCM53128_A0_EEE_MIN_LP_TIMER_Hr_SET
#define EEE_MIN_LP_TIMER_Hr_GET BCM53128_A0_EEE_MIN_LP_TIMER_Hr_GET
#define EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_GET BCM53128_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_GET
#define EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_SET BCM53128_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_SET
#define READ_EEE_MIN_LP_TIMER_Hr BCM53128_A0_READ_EEE_MIN_LP_TIMER_Hr
#define WRITE_EEE_MIN_LP_TIMER_Hr BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_MIN_LP_TIMER_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_MIN_LP_TIMER_H_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Minimum Low-Power Duration Timer - 100M Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_H_IMP EEE minimum low-power duration delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr 0x0000929c

#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_H_IMP.
 *
 */
typedef union BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_h_imp[1];
	uint32_t _eee_min_lp_timer_h_imp;
} BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_t;

#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_CLR(r) (r).eee_min_lp_timer_h_imp[0] = 0
#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_SET(r,d) (r).eee_min_lp_timer_h_imp[0] = d
#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_GET(r) (r).eee_min_lp_timer_h_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_GET(r) ((r).eee_min_lp_timer_h_imp[0])
#define BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_SET(r,f) (r).eee_min_lp_timer_h_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_H_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_MIN_LP_TIMER_H_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr,(r._eee_min_lp_timer_h_imp),4)
#define BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_H_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr,&(r._eee_min_lp_timer_h_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_H_IMPr BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr
#define EEE_MIN_LP_TIMER_H_IMPr_SIZE BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_SIZE
typedef BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_t EEE_MIN_LP_TIMER_H_IMPr_t;
#define EEE_MIN_LP_TIMER_H_IMPr_CLR BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_CLR
#define EEE_MIN_LP_TIMER_H_IMPr_SET BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_SET
#define EEE_MIN_LP_TIMER_H_IMPr_GET BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_GET
#define EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_GET BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_GET
#define EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_SET BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_SET
#define READ_EEE_MIN_LP_TIMER_H_IMPr BCM53128_A0_READ_EEE_MIN_LP_TIMER_H_IMPr
#define WRITE_EEE_MIN_LP_TIMER_H_IMPr BCM53128_A0_WRITE_EEE_MIN_LP_TIMER_H_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_MIN_LP_TIMER_H_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_PHY_CTRL
 * BLOCKS:   SYS
 * DESC:     EEE PHY Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_BIAS_10BTE    Enable BIAS for 10 Base-TThe register indicate enable 10 Base-T BIAS or not.1 = Enable0 = DisableNOTE:the register is the value of enable_bias_10bte
 *     EN_PHY_LPI       Enable PHY LPI featurePHY LPI enable/disable control.1 = Enable PHY LPI0 = Disable PHY LPINOTE:1. The definition of lpi_feature_en_def[1:0]:00 - permanently disable01 - permanently enable10 - controlled by the register with default disable11 - controlled by the register with default disable2. lpi_feature_en_def[1:0]=1x in the Blackbird2 implementation. The register is the low bit value of lpi_feature_en_def[1:0].
 *     EEE_1000BASE_TX  EEE support on 1000 Base-TThe register indicate 1000 Base-T support EEE or not.1 = EEE support0 = EEE do not supportNOTE: the register is the value of eee_1000base_tx_def and leee_pcs_1000base_tx_def.
 *     EEE_100BASE_TX   EEE support on 100 Base-TXThe register indicate 100 Base-TX support EEE or not.1 = EEE support0 = EEE do not supportNOTE: the register is the value of eee_100base_tx_def and leee_pcs_100base_tx_def.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_PHY_CTRLr 0x000092d2

#define BCM53128_A0_EEE_PHY_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program EEE_PHY_CTRL.
 *
 */
typedef union BCM53128_A0_EEE_PHY_CTRLr_s {
	uint32_t v[1];
	uint32_t eee_phy_ctrl[1];
	uint32_t _eee_phy_ctrl;
} BCM53128_A0_EEE_PHY_CTRLr_t;

#define BCM53128_A0_EEE_PHY_CTRLr_CLR(r) (r).eee_phy_ctrl[0] = 0
#define BCM53128_A0_EEE_PHY_CTRLr_SET(r,d) (r).eee_phy_ctrl[0] = d
#define BCM53128_A0_EEE_PHY_CTRLr_GET(r) (r).eee_phy_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_GET(r) (((r).eee_phy_ctrl[0]) & 0x1)
#define BCM53128_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_GET(r) ((((r).eee_phy_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_GET(r) ((((r).eee_phy_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_GET(r) ((((r).eee_phy_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_EEE_PHY_CTRLr_RESERVEDf_GET(r) ((((r).eee_phy_ctrl[0]) >> 4) & 0xf)
#define BCM53128_A0_EEE_PHY_CTRLr_RESERVEDf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access EEE_PHY_CTRL.
 *
 */
#define BCM53128_A0_READ_EEE_PHY_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_PHY_CTRLr,(r._eee_phy_ctrl),1)
#define BCM53128_A0_WRITE_EEE_PHY_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_PHY_CTRLr,&(r._eee_phy_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_PHY_CTRLr BCM53128_A0_EEE_PHY_CTRLr
#define EEE_PHY_CTRLr_SIZE BCM53128_A0_EEE_PHY_CTRLr_SIZE
typedef BCM53128_A0_EEE_PHY_CTRLr_t EEE_PHY_CTRLr_t;
#define EEE_PHY_CTRLr_CLR BCM53128_A0_EEE_PHY_CTRLr_CLR
#define EEE_PHY_CTRLr_SET BCM53128_A0_EEE_PHY_CTRLr_SET
#define EEE_PHY_CTRLr_GET BCM53128_A0_EEE_PHY_CTRLr_GET
#define EEE_PHY_CTRLr_EN_BIAS_10BTEf_GET BCM53128_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_GET
#define EEE_PHY_CTRLr_EN_BIAS_10BTEf_SET BCM53128_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_SET
#define EEE_PHY_CTRLr_EN_PHY_LPIf_GET BCM53128_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_GET
#define EEE_PHY_CTRLr_EN_PHY_LPIf_SET BCM53128_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_SET
#define EEE_PHY_CTRLr_EEE_1000BASE_TXf_GET BCM53128_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_GET
#define EEE_PHY_CTRLr_EEE_1000BASE_TXf_SET BCM53128_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_SET
#define EEE_PHY_CTRLr_EEE_100BASE_TXf_GET BCM53128_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_GET
#define EEE_PHY_CTRLr_EEE_100BASE_TXf_SET BCM53128_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_SET
#define EEE_PHY_CTRLr_RESERVEDf_GET BCM53128_A0_EEE_PHY_CTRLr_RESERVEDf_GET
#define EEE_PHY_CTRLr_RESERVEDf_SET BCM53128_A0_EEE_PHY_CTRLr_RESERVEDf_SET
#define READ_EEE_PHY_CTRLr BCM53128_A0_READ_EEE_PHY_CTRLr
#define WRITE_EEE_PHY_CTRLr BCM53128_A0_WRITE_EEE_PHY_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_PHY_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_PIPELINE_TIMER
 * BLOCKS:   SYS
 * DESC:     EEE Pipeline Delay Timer Registers
 * SIZE:     32
 * FIELDS:
 *     PIPELINE_TIMER   EEE pipeline delay timer load value.The unit is system clock rate(ex. If system clock=100Mhz, unit=10nsec).
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_PIPELINE_TIMERr 0x0000920c

#define BCM53128_A0_EEE_PIPELINE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program EEE_PIPELINE_TIMER.
 *
 */
typedef union BCM53128_A0_EEE_PIPELINE_TIMERr_s {
	uint32_t v[1];
	uint32_t eee_pipeline_timer[1];
	uint32_t _eee_pipeline_timer;
} BCM53128_A0_EEE_PIPELINE_TIMERr_t;

#define BCM53128_A0_EEE_PIPELINE_TIMERr_CLR(r) (r).eee_pipeline_timer[0] = 0
#define BCM53128_A0_EEE_PIPELINE_TIMERr_SET(r,d) (r).eee_pipeline_timer[0] = d
#define BCM53128_A0_EEE_PIPELINE_TIMERr_GET(r) (r).eee_pipeline_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_GET(r) ((r).eee_pipeline_timer[0])
#define BCM53128_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_SET(r,f) (r).eee_pipeline_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_PIPELINE_TIMER.
 *
 */
#define BCM53128_A0_READ_EEE_PIPELINE_TIMERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_PIPELINE_TIMERr,(r._eee_pipeline_timer),4)
#define BCM53128_A0_WRITE_EEE_PIPELINE_TIMERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_PIPELINE_TIMERr,&(r._eee_pipeline_timer),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_PIPELINE_TIMERr BCM53128_A0_EEE_PIPELINE_TIMERr
#define EEE_PIPELINE_TIMERr_SIZE BCM53128_A0_EEE_PIPELINE_TIMERr_SIZE
typedef BCM53128_A0_EEE_PIPELINE_TIMERr_t EEE_PIPELINE_TIMERr_t;
#define EEE_PIPELINE_TIMERr_CLR BCM53128_A0_EEE_PIPELINE_TIMERr_CLR
#define EEE_PIPELINE_TIMERr_SET BCM53128_A0_EEE_PIPELINE_TIMERr_SET
#define EEE_PIPELINE_TIMERr_GET BCM53128_A0_EEE_PIPELINE_TIMERr_GET
#define EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_GET BCM53128_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_GET
#define EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_SET BCM53128_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_SET
#define READ_EEE_PIPELINE_TIMERr BCM53128_A0_READ_EEE_PIPELINE_TIMERr
#define WRITE_EEE_PIPELINE_TIMERr BCM53128_A0_WRITE_EEE_PIPELINE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_PIPELINE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_RX_IDLE_SYMBOL
 * BLOCKS:   SYS
 * DESC:     EEE Receiving Idle Symbols Status Registers
 * SIZE:     16
 * FIELDS:
 *     RX_IDLE_SYMBOL   receivingIdleSymbols output signal status.9 bit indicating that a receivingIdleSymbols output that is asserted whenever the receive PHY is sending normal idle symbols to the receive MAC.(bit 0-7 = port 0- port 7, bit 8 = IMP port)1 = asserted0 = deasserted
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr 0x00009206

#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_SIZE 2

/*
 * This structure should be used to declare and program EEE_RX_IDLE_SYMBOL.
 *
 */
typedef union BCM53128_A0_EEE_RX_IDLE_SYMBOLr_s {
	uint32_t v[1];
	uint32_t eee_rx_idle_symbol[1];
	uint32_t _eee_rx_idle_symbol;
} BCM53128_A0_EEE_RX_IDLE_SYMBOLr_t;

#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_CLR(r) (r).eee_rx_idle_symbol[0] = 0
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_SET(r,d) (r).eee_rx_idle_symbol[0] = d
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_GET(r) (r).eee_rx_idle_symbol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_GET(r) (((r).eee_rx_idle_symbol[0]) & 0x1ff)
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_SET(r,f) (r).eee_rx_idle_symbol[0]=(((r).eee_rx_idle_symbol[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_GET(r) ((((r).eee_rx_idle_symbol[0]) >> 9) & 0x7f)
#define BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_SET(r,f) (r).eee_rx_idle_symbol[0]=(((r).eee_rx_idle_symbol[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_RX_IDLE_SYMBOL.
 *
 */
#define BCM53128_A0_READ_EEE_RX_IDLE_SYMBOLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_RX_IDLE_SYMBOLr,(r._eee_rx_idle_symbol),2)
#define BCM53128_A0_WRITE_EEE_RX_IDLE_SYMBOLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_RX_IDLE_SYMBOLr,&(r._eee_rx_idle_symbol),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_RX_IDLE_SYMBOLr BCM53128_A0_EEE_RX_IDLE_SYMBOLr
#define EEE_RX_IDLE_SYMBOLr_SIZE BCM53128_A0_EEE_RX_IDLE_SYMBOLr_SIZE
typedef BCM53128_A0_EEE_RX_IDLE_SYMBOLr_t EEE_RX_IDLE_SYMBOLr_t;
#define EEE_RX_IDLE_SYMBOLr_CLR BCM53128_A0_EEE_RX_IDLE_SYMBOLr_CLR
#define EEE_RX_IDLE_SYMBOLr_SET BCM53128_A0_EEE_RX_IDLE_SYMBOLr_SET
#define EEE_RX_IDLE_SYMBOLr_GET BCM53128_A0_EEE_RX_IDLE_SYMBOLr_GET
#define EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_GET BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_GET
#define EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_SET BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_SET
#define EEE_RX_IDLE_SYMBOLr_RESERVEDf_GET BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_GET
#define EEE_RX_IDLE_SYMBOLr_RESERVEDf_SET BCM53128_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_SET
#define READ_EEE_RX_IDLE_SYMBOLr BCM53128_A0_READ_EEE_RX_IDLE_SYMBOLr
#define WRITE_EEE_RX_IDLE_SYMBOLr BCM53128_A0_WRITE_EEE_RX_IDLE_SYMBOLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_RX_IDLE_SYMBOLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_SLEEP_TIMER_G
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Sleep Delay Timer - 1G Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_G    EEE sleep delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_SLEEP_TIMER_Gr 0x00009210

#define BCM53128_A0_EEE_SLEEP_TIMER_Gr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_G.
 *
 */
typedef union BCM53128_A0_EEE_SLEEP_TIMER_Gr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_g[1];
	uint32_t _eee_sleep_timer_g;
} BCM53128_A0_EEE_SLEEP_TIMER_Gr_t;

#define BCM53128_A0_EEE_SLEEP_TIMER_Gr_CLR(r) (r).eee_sleep_timer_g[0] = 0
#define BCM53128_A0_EEE_SLEEP_TIMER_Gr_SET(r,d) (r).eee_sleep_timer_g[0] = d
#define BCM53128_A0_EEE_SLEEP_TIMER_Gr_GET(r) (r).eee_sleep_timer_g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_GET(r) ((r).eee_sleep_timer_g[0])
#define BCM53128_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_SET(r,f) (r).eee_sleep_timer_g[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_G.
 *
 */
#define BCM53128_A0_READ_EEE_SLEEP_TIMER_Gr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_SLEEP_TIMER_Gr,(r._eee_sleep_timer_g),4)
#define BCM53128_A0_WRITE_EEE_SLEEP_TIMER_Gr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_SLEEP_TIMER_Gr,&(r._eee_sleep_timer_g),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_Gr BCM53128_A0_EEE_SLEEP_TIMER_Gr
#define EEE_SLEEP_TIMER_Gr_SIZE BCM53128_A0_EEE_SLEEP_TIMER_Gr_SIZE
typedef BCM53128_A0_EEE_SLEEP_TIMER_Gr_t EEE_SLEEP_TIMER_Gr_t;
#define EEE_SLEEP_TIMER_Gr_CLR BCM53128_A0_EEE_SLEEP_TIMER_Gr_CLR
#define EEE_SLEEP_TIMER_Gr_SET BCM53128_A0_EEE_SLEEP_TIMER_Gr_SET
#define EEE_SLEEP_TIMER_Gr_GET BCM53128_A0_EEE_SLEEP_TIMER_Gr_GET
#define EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_GET BCM53128_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_GET
#define EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_SET BCM53128_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_SET
#define READ_EEE_SLEEP_TIMER_Gr BCM53128_A0_READ_EEE_SLEEP_TIMER_Gr
#define WRITE_EEE_SLEEP_TIMER_Gr BCM53128_A0_WRITE_EEE_SLEEP_TIMER_Gr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_SLEEP_TIMER_Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_SLEEP_TIMER_G_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Sleep Delay Timer Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_G_IMP EEE sleep delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr 0x00009230

#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_G_IMP.
 *
 */
typedef union BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_g_imp[1];
	uint32_t _eee_sleep_timer_g_imp;
} BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_t;

#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_CLR(r) (r).eee_sleep_timer_g_imp[0] = 0
#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SET(r,d) (r).eee_sleep_timer_g_imp[0] = d
#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_GET(r) (r).eee_sleep_timer_g_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_GET(r) ((r).eee_sleep_timer_g_imp[0])
#define BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_SET(r,f) (r).eee_sleep_timer_g_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_G_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_SLEEP_TIMER_G_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr,(r._eee_sleep_timer_g_imp),4)
#define BCM53128_A0_WRITE_EEE_SLEEP_TIMER_G_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr,&(r._eee_sleep_timer_g_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_G_IMPr BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr
#define EEE_SLEEP_TIMER_G_IMPr_SIZE BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SIZE
typedef BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_t EEE_SLEEP_TIMER_G_IMPr_t;
#define EEE_SLEEP_TIMER_G_IMPr_CLR BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_CLR
#define EEE_SLEEP_TIMER_G_IMPr_SET BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SET
#define EEE_SLEEP_TIMER_G_IMPr_GET BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_GET
#define EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_GET BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_GET
#define EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_SET BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_SET
#define READ_EEE_SLEEP_TIMER_G_IMPr BCM53128_A0_READ_EEE_SLEEP_TIMER_G_IMPr
#define WRITE_EEE_SLEEP_TIMER_G_IMPr BCM53128_A0_WRITE_EEE_SLEEP_TIMER_G_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_SLEEP_TIMER_G_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_SLEEP_TIMER_H
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Sleep Delay Timer - 100M Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_H    EEE sleep delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_SLEEP_TIMER_Hr 0x00009234

#define BCM53128_A0_EEE_SLEEP_TIMER_Hr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_H.
 *
 */
typedef union BCM53128_A0_EEE_SLEEP_TIMER_Hr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_h[1];
	uint32_t _eee_sleep_timer_h;
} BCM53128_A0_EEE_SLEEP_TIMER_Hr_t;

#define BCM53128_A0_EEE_SLEEP_TIMER_Hr_CLR(r) (r).eee_sleep_timer_h[0] = 0
#define BCM53128_A0_EEE_SLEEP_TIMER_Hr_SET(r,d) (r).eee_sleep_timer_h[0] = d
#define BCM53128_A0_EEE_SLEEP_TIMER_Hr_GET(r) (r).eee_sleep_timer_h[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_GET(r) ((r).eee_sleep_timer_h[0])
#define BCM53128_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_SET(r,f) (r).eee_sleep_timer_h[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_H.
 *
 */
#define BCM53128_A0_READ_EEE_SLEEP_TIMER_Hr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_SLEEP_TIMER_Hr,(r._eee_sleep_timer_h),4)
#define BCM53128_A0_WRITE_EEE_SLEEP_TIMER_Hr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_SLEEP_TIMER_Hr,&(r._eee_sleep_timer_h),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_Hr BCM53128_A0_EEE_SLEEP_TIMER_Hr
#define EEE_SLEEP_TIMER_Hr_SIZE BCM53128_A0_EEE_SLEEP_TIMER_Hr_SIZE
typedef BCM53128_A0_EEE_SLEEP_TIMER_Hr_t EEE_SLEEP_TIMER_Hr_t;
#define EEE_SLEEP_TIMER_Hr_CLR BCM53128_A0_EEE_SLEEP_TIMER_Hr_CLR
#define EEE_SLEEP_TIMER_Hr_SET BCM53128_A0_EEE_SLEEP_TIMER_Hr_SET
#define EEE_SLEEP_TIMER_Hr_GET BCM53128_A0_EEE_SLEEP_TIMER_Hr_GET
#define EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_GET BCM53128_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_GET
#define EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_SET BCM53128_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_SET
#define READ_EEE_SLEEP_TIMER_Hr BCM53128_A0_READ_EEE_SLEEP_TIMER_Hr
#define WRITE_EEE_SLEEP_TIMER_Hr BCM53128_A0_WRITE_EEE_SLEEP_TIMER_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_SLEEP_TIMER_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_SLEEP_TIMER_H_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Sleep Delay Timer Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_H_IMP EEE sleep delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr 0x00009254

#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_H_IMP.
 *
 */
typedef union BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_h_imp[1];
	uint32_t _eee_sleep_timer_h_imp;
} BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_t;

#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_CLR(r) (r).eee_sleep_timer_h_imp[0] = 0
#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SET(r,d) (r).eee_sleep_timer_h_imp[0] = d
#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_GET(r) (r).eee_sleep_timer_h_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_GET(r) ((r).eee_sleep_timer_h_imp[0])
#define BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_SET(r,f) (r).eee_sleep_timer_h_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_H_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_SLEEP_TIMER_H_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr,(r._eee_sleep_timer_h_imp),4)
#define BCM53128_A0_WRITE_EEE_SLEEP_TIMER_H_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr,&(r._eee_sleep_timer_h_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_H_IMPr BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr
#define EEE_SLEEP_TIMER_H_IMPr_SIZE BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SIZE
typedef BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_t EEE_SLEEP_TIMER_H_IMPr_t;
#define EEE_SLEEP_TIMER_H_IMPr_CLR BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_CLR
#define EEE_SLEEP_TIMER_H_IMPr_SET BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SET
#define EEE_SLEEP_TIMER_H_IMPr_GET BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_GET
#define EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_GET BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_GET
#define EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_SET BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_SET
#define READ_EEE_SLEEP_TIMER_H_IMPr BCM53128_A0_READ_EEE_SLEEP_TIMER_H_IMPr
#define WRITE_EEE_SLEEP_TIMER_H_IMPr BCM53128_A0_WRITE_EEE_SLEEP_TIMER_H_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_SLEEP_TIMER_H_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_STATE
 * BLOCKS:   SYS
 * DESC:     EEE Control Policy State Registers(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     EEE_STATE        EEE Control Policy State.A 27-bit field to indicate the EEE control policy state for each port. Three bits for each port. Bits 23-0 = port 7- port 0 respectatively, bit 26-24 = IMP port.000 = ACTIVE state(INIT, WAIT)001 = SLEEP state(SLEEP_DELAY, SLEEP_WAIT)010 = PIPELINE state(PIPELINE_DELAY, PIPELINE_WAIT)011 = LOW_POWER state(ENTER_LOW_POWER, LOW_POWER)100 = WAKE state(EXIT_LOW_POWER, WAKE_DELAY)(Not2Release)
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_STATEr 0x000092ec

#define BCM53128_A0_EEE_STATEr_SIZE 4

/*
 * This structure should be used to declare and program EEE_STATE.
 *
 */
typedef union BCM53128_A0_EEE_STATEr_s {
	uint32_t v[1];
	uint32_t eee_state[1];
	uint32_t _eee_state;
} BCM53128_A0_EEE_STATEr_t;

#define BCM53128_A0_EEE_STATEr_CLR(r) (r).eee_state[0] = 0
#define BCM53128_A0_EEE_STATEr_SET(r,d) (r).eee_state[0] = d
#define BCM53128_A0_EEE_STATEr_GET(r) (r).eee_state[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_STATEr_EEE_STATEf_GET(r) (((r).eee_state[0]) & 0x7ffffff)
#define BCM53128_A0_EEE_STATEr_EEE_STATEf_SET(r,f) (r).eee_state[0]=(((r).eee_state[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))
#define BCM53128_A0_EEE_STATEr_RESERVEDf_GET(r) ((((r).eee_state[0]) >> 27) & 0x1f)
#define BCM53128_A0_EEE_STATEr_RESERVEDf_SET(r,f) (r).eee_state[0]=(((r).eee_state[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access EEE_STATE.
 *
 */
#define BCM53128_A0_READ_EEE_STATEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_STATEr,(r._eee_state),4)
#define BCM53128_A0_WRITE_EEE_STATEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_STATEr,&(r._eee_state),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_STATEr BCM53128_A0_EEE_STATEr
#define EEE_STATEr_SIZE BCM53128_A0_EEE_STATEr_SIZE
typedef BCM53128_A0_EEE_STATEr_t EEE_STATEr_t;
#define EEE_STATEr_CLR BCM53128_A0_EEE_STATEr_CLR
#define EEE_STATEr_SET BCM53128_A0_EEE_STATEr_SET
#define EEE_STATEr_GET BCM53128_A0_EEE_STATEr_GET
#define EEE_STATEr_EEE_STATEf_GET BCM53128_A0_EEE_STATEr_EEE_STATEf_GET
#define EEE_STATEr_EEE_STATEf_SET BCM53128_A0_EEE_STATEr_EEE_STATEf_SET
#define EEE_STATEr_RESERVEDf_GET BCM53128_A0_EEE_STATEr_RESERVEDf_GET
#define EEE_STATEr_RESERVEDf_SET BCM53128_A0_EEE_STATEr_RESERVEDf_SET
#define READ_EEE_STATEr BCM53128_A0_READ_EEE_STATEr
#define WRITE_EEE_STATEr BCM53128_A0_WRITE_EEE_STATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_STATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_TXQ_CONG_TH
 * BLOCKS:   SYS
 * DESC:     EEE TXQ N Congestion Threshold Registers
 * SIZE:     16
 * FIELDS:
 *     TXQ_CONG_TH      EEE TXQ packet buffer congestion threshold.If this threshold is set to zero, then EEE for queue N is effectively disabled, if this threshold is set equal to or greater than 768(the number of cells implemented in the packet buffer), then protections against packet loss are disabled.The unit is "Buffer Cell Size": 256-byte cell.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_TXQ_CONG_THr 0x000092c6

#define BCM53128_A0_EEE_TXQ_CONG_THr_SIZE 2

/*
 * This structure should be used to declare and program EEE_TXQ_CONG_TH.
 *
 */
typedef union BCM53128_A0_EEE_TXQ_CONG_THr_s {
	uint32_t v[1];
	uint32_t eee_txq_cong_th[1];
	uint32_t _eee_txq_cong_th;
} BCM53128_A0_EEE_TXQ_CONG_THr_t;

#define BCM53128_A0_EEE_TXQ_CONG_THr_CLR(r) (r).eee_txq_cong_th[0] = 0
#define BCM53128_A0_EEE_TXQ_CONG_THr_SET(r,d) (r).eee_txq_cong_th[0] = d
#define BCM53128_A0_EEE_TXQ_CONG_THr_GET(r) (r).eee_txq_cong_th[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_GET(r) (((r).eee_txq_cong_th[0]) & 0x7ff)
#define BCM53128_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_SET(r,f) (r).eee_txq_cong_th[0]=(((r).eee_txq_cong_th[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_EEE_TXQ_CONG_THr_RESERVEDf_GET(r) ((((r).eee_txq_cong_th[0]) >> 11) & 0x1f)
#define BCM53128_A0_EEE_TXQ_CONG_THr_RESERVEDf_SET(r,f) (r).eee_txq_cong_th[0]=(((r).eee_txq_cong_th[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access EEE_TXQ_CONG_TH.
 *
 */
#define BCM53128_A0_READ_EEE_TXQ_CONG_THr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_TXQ_CONG_THr+(2*(i)),(r._eee_txq_cong_th),2)
#define BCM53128_A0_WRITE_EEE_TXQ_CONG_THr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_TXQ_CONG_THr+(2*(i)),&(r._eee_txq_cong_th),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_TXQ_CONG_THr BCM53128_A0_EEE_TXQ_CONG_THr
#define EEE_TXQ_CONG_THr_SIZE BCM53128_A0_EEE_TXQ_CONG_THr_SIZE
typedef BCM53128_A0_EEE_TXQ_CONG_THr_t EEE_TXQ_CONG_THr_t;
#define EEE_TXQ_CONG_THr_CLR BCM53128_A0_EEE_TXQ_CONG_THr_CLR
#define EEE_TXQ_CONG_THr_SET BCM53128_A0_EEE_TXQ_CONG_THr_SET
#define EEE_TXQ_CONG_THr_GET BCM53128_A0_EEE_TXQ_CONG_THr_GET
#define EEE_TXQ_CONG_THr_TXQ_CONG_THf_GET BCM53128_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_GET
#define EEE_TXQ_CONG_THr_TXQ_CONG_THf_SET BCM53128_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_SET
#define EEE_TXQ_CONG_THr_RESERVEDf_GET BCM53128_A0_EEE_TXQ_CONG_THr_RESERVEDf_GET
#define EEE_TXQ_CONG_THr_RESERVEDf_SET BCM53128_A0_EEE_TXQ_CONG_THr_RESERVEDf_SET
#define READ_EEE_TXQ_CONG_THr BCM53128_A0_READ_EEE_TXQ_CONG_THr
#define WRITE_EEE_TXQ_CONG_THr BCM53128_A0_WRITE_EEE_TXQ_CONG_THr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_TXQ_CONG_THr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_WAKE_TIMER_G
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Wake Transition Timer - 1G Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_G     EEE wake transition delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_WAKE_TIMER_Gr 0x000092a0

#define BCM53128_A0_EEE_WAKE_TIMER_Gr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_G.
 *
 */
typedef union BCM53128_A0_EEE_WAKE_TIMER_Gr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_g[1];
	uint32_t _eee_wake_timer_g;
} BCM53128_A0_EEE_WAKE_TIMER_Gr_t;

#define BCM53128_A0_EEE_WAKE_TIMER_Gr_CLR(r) (r).eee_wake_timer_g[0] = 0
#define BCM53128_A0_EEE_WAKE_TIMER_Gr_SET(r,d) (r).eee_wake_timer_g[0] = d
#define BCM53128_A0_EEE_WAKE_TIMER_Gr_GET(r) (r).eee_wake_timer_g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_GET(r) (((r).eee_wake_timer_g[0]) & 0xffff)
#define BCM53128_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_SET(r,f) (r).eee_wake_timer_g[0]=(((r).eee_wake_timer_g[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_G.
 *
 */
#define BCM53128_A0_READ_EEE_WAKE_TIMER_Gr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_WAKE_TIMER_Gr,(r._eee_wake_timer_g),2)
#define BCM53128_A0_WRITE_EEE_WAKE_TIMER_Gr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_WAKE_TIMER_Gr,&(r._eee_wake_timer_g),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_Gr BCM53128_A0_EEE_WAKE_TIMER_Gr
#define EEE_WAKE_TIMER_Gr_SIZE BCM53128_A0_EEE_WAKE_TIMER_Gr_SIZE
typedef BCM53128_A0_EEE_WAKE_TIMER_Gr_t EEE_WAKE_TIMER_Gr_t;
#define EEE_WAKE_TIMER_Gr_CLR BCM53128_A0_EEE_WAKE_TIMER_Gr_CLR
#define EEE_WAKE_TIMER_Gr_SET BCM53128_A0_EEE_WAKE_TIMER_Gr_SET
#define EEE_WAKE_TIMER_Gr_GET BCM53128_A0_EEE_WAKE_TIMER_Gr_GET
#define EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_GET BCM53128_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_GET
#define EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_SET BCM53128_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_SET
#define READ_EEE_WAKE_TIMER_Gr BCM53128_A0_READ_EEE_WAKE_TIMER_Gr
#define WRITE_EEE_WAKE_TIMER_Gr BCM53128_A0_WRITE_EEE_WAKE_TIMER_Gr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_WAKE_TIMER_Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_WAKE_TIMER_G_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Wake Transition Timer - 1G Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_G_IMP EEE wake transition delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr 0x000092b0

#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_G_IMP.
 *
 */
typedef union BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_g_imp[1];
	uint32_t _eee_wake_timer_g_imp;
} BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_t;

#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_CLR(r) (r).eee_wake_timer_g_imp[0] = 0
#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_SET(r,d) (r).eee_wake_timer_g_imp[0] = d
#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_GET(r) (r).eee_wake_timer_g_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_GET(r) (((r).eee_wake_timer_g_imp[0]) & 0xffff)
#define BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_SET(r,f) (r).eee_wake_timer_g_imp[0]=(((r).eee_wake_timer_g_imp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_G_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_WAKE_TIMER_G_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_WAKE_TIMER_G_IMPr,(r._eee_wake_timer_g_imp),2)
#define BCM53128_A0_WRITE_EEE_WAKE_TIMER_G_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_WAKE_TIMER_G_IMPr,&(r._eee_wake_timer_g_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_G_IMPr BCM53128_A0_EEE_WAKE_TIMER_G_IMPr
#define EEE_WAKE_TIMER_G_IMPr_SIZE BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_SIZE
typedef BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_t EEE_WAKE_TIMER_G_IMPr_t;
#define EEE_WAKE_TIMER_G_IMPr_CLR BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_CLR
#define EEE_WAKE_TIMER_G_IMPr_SET BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_SET
#define EEE_WAKE_TIMER_G_IMPr_GET BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_GET
#define EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_GET BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_GET
#define EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_SET BCM53128_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_SET
#define READ_EEE_WAKE_TIMER_G_IMPr BCM53128_A0_READ_EEE_WAKE_TIMER_G_IMPr
#define WRITE_EEE_WAKE_TIMER_G_IMPr BCM53128_A0_WRITE_EEE_WAKE_TIMER_G_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_WAKE_TIMER_G_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_WAKE_TIMER_H
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Wake Transition Timer - 100M Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_H     EEE wake transition delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_WAKE_TIMER_Hr 0x000092b2

#define BCM53128_A0_EEE_WAKE_TIMER_Hr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_H.
 *
 */
typedef union BCM53128_A0_EEE_WAKE_TIMER_Hr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_h[1];
	uint32_t _eee_wake_timer_h;
} BCM53128_A0_EEE_WAKE_TIMER_Hr_t;

#define BCM53128_A0_EEE_WAKE_TIMER_Hr_CLR(r) (r).eee_wake_timer_h[0] = 0
#define BCM53128_A0_EEE_WAKE_TIMER_Hr_SET(r,d) (r).eee_wake_timer_h[0] = d
#define BCM53128_A0_EEE_WAKE_TIMER_Hr_GET(r) (r).eee_wake_timer_h[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_GET(r) (((r).eee_wake_timer_h[0]) & 0xffff)
#define BCM53128_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_SET(r,f) (r).eee_wake_timer_h[0]=(((r).eee_wake_timer_h[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_H.
 *
 */
#define BCM53128_A0_READ_EEE_WAKE_TIMER_Hr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EEE_WAKE_TIMER_Hr,(r._eee_wake_timer_h),2)
#define BCM53128_A0_WRITE_EEE_WAKE_TIMER_Hr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EEE_WAKE_TIMER_Hr,&(r._eee_wake_timer_h),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_Hr BCM53128_A0_EEE_WAKE_TIMER_Hr
#define EEE_WAKE_TIMER_Hr_SIZE BCM53128_A0_EEE_WAKE_TIMER_Hr_SIZE
typedef BCM53128_A0_EEE_WAKE_TIMER_Hr_t EEE_WAKE_TIMER_Hr_t;
#define EEE_WAKE_TIMER_Hr_CLR BCM53128_A0_EEE_WAKE_TIMER_Hr_CLR
#define EEE_WAKE_TIMER_Hr_SET BCM53128_A0_EEE_WAKE_TIMER_Hr_SET
#define EEE_WAKE_TIMER_Hr_GET BCM53128_A0_EEE_WAKE_TIMER_Hr_GET
#define EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_GET BCM53128_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_GET
#define EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_SET BCM53128_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_SET
#define READ_EEE_WAKE_TIMER_Hr BCM53128_A0_READ_EEE_WAKE_TIMER_Hr
#define WRITE_EEE_WAKE_TIMER_Hr BCM53128_A0_WRITE_EEE_WAKE_TIMER_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_WAKE_TIMER_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EEE_WAKE_TIMER_H_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Wake Transition Timer - 100M Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_H_IMP EEE wake transition delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr 0x000092c2

#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_H_IMP.
 *
 */
typedef union BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_h_imp[1];
	uint32_t _eee_wake_timer_h_imp;
} BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_t;

#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_CLR(r) (r).eee_wake_timer_h_imp[0] = 0
#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_SET(r,d) (r).eee_wake_timer_h_imp[0] = d
#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_GET(r) (r).eee_wake_timer_h_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_GET(r) (((r).eee_wake_timer_h_imp[0]) & 0xffff)
#define BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_SET(r,f) (r).eee_wake_timer_h_imp[0]=(((r).eee_wake_timer_h_imp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_H_IMP.
 *
 */
#define BCM53128_A0_READ_EEE_WAKE_TIMER_H_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EEE_WAKE_TIMER_H_IMPr,(r._eee_wake_timer_h_imp),2)
#define BCM53128_A0_WRITE_EEE_WAKE_TIMER_H_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EEE_WAKE_TIMER_H_IMPr,&(r._eee_wake_timer_h_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_H_IMPr BCM53128_A0_EEE_WAKE_TIMER_H_IMPr
#define EEE_WAKE_TIMER_H_IMPr_SIZE BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_SIZE
typedef BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_t EEE_WAKE_TIMER_H_IMPr_t;
#define EEE_WAKE_TIMER_H_IMPr_CLR BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_CLR
#define EEE_WAKE_TIMER_H_IMPr_SET BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_SET
#define EEE_WAKE_TIMER_H_IMPr_GET BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_GET
#define EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_GET BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_GET
#define EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_SET BCM53128_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_SET
#define READ_EEE_WAKE_TIMER_H_IMPr BCM53128_A0_READ_EEE_WAKE_TIMER_H_IMPr
#define WRITE_EEE_WAKE_TIMER_H_IMPr BCM53128_A0_WRITE_EEE_WAKE_TIMER_H_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EEE_WAKE_TIMER_H_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_MSK      Egress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-7 = Port0-7Bit 8= IMP Port.
 *     RESERVED         Reserved
 *     OUT_DIV_EN       Egress Divider Enable.Mirror every nth transmitted frame (n=OUT_MIRROR_DIV + 1) that has passed through the OUT_MIRROR_FILTER.
 *     OUT_MIR_FLTR     Egress Mirror Filter.Defines the conditions under which frames transmitted on a port that has been selected in the OUT_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all egress frames.01: Mirror all transmitted frames with DA = OUT_MIROR_MAC.10: Mirror all transmitted frames with SA = OUT_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_EGMIRCTLr 0x0000021c

#define BCM53128_A0_EGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRCTL.
 *
 */
typedef union BCM53128_A0_EGMIRCTLr_s {
	uint32_t v[1];
	uint32_t egmirctl[1];
	uint32_t _egmirctl;
} BCM53128_A0_EGMIRCTLr_t;

#define BCM53128_A0_EGMIRCTLr_CLR(r) (r).egmirctl[0] = 0
#define BCM53128_A0_EGMIRCTLr_SET(r,d) (r).egmirctl[0] = d
#define BCM53128_A0_EGMIRCTLr_GET(r) (r).egmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) (((r).egmirctl[0]) & 0x1ff)
#define BCM53128_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_EGMIRCTLr_RESERVEDf_GET(r) ((((r).egmirctl[0]) >> 9) & 0xf)
#define BCM53128_A0_EGMIRCTLr_RESERVEDf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53128_A0_EGMIRCTLr_OUT_DIV_ENf_GET(r) ((((r).egmirctl[0]) >> 13) & 0x1)
#define BCM53128_A0_EGMIRCTLr_OUT_DIV_ENf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET(r) ((((r).egmirctl[0]) >> 14) & 0x3)
#define BCM53128_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access EGMIRCTL.
 *
 */
#define BCM53128_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EGMIRCTLr,(r._egmirctl),2)
#define BCM53128_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EGMIRCTLr,&(r._egmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM53128_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM53128_A0_EGMIRCTLr_SIZE
typedef BCM53128_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM53128_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM53128_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM53128_A0_EGMIRCTLr_GET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM53128_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM53128_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_RESERVEDf_GET BCM53128_A0_EGMIRCTLr_RESERVEDf_GET
#define EGMIRCTLr_RESERVEDf_SET BCM53128_A0_EGMIRCTLr_RESERVEDf_SET
#define EGMIRCTLr_OUT_DIV_ENf_GET BCM53128_A0_EGMIRCTLr_OUT_DIV_ENf_GET
#define EGMIRCTLr_OUT_DIV_ENf_SET BCM53128_A0_EGMIRCTLr_OUT_DIV_ENf_SET
#define EGMIRCTLr_OUT_MIR_FLTRf_GET BCM53128_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET
#define EGMIRCTLr_OUT_MIR_FLTRf_SET BCM53128_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET
#define READ_EGMIRCTLr BCM53128_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM53128_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_DIV      Egress Mirror Divider.Transmit frames that have passed the OUT_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the OUT_DIV_EN bit in the Egress Mirror Control register is set, frames that pass the OUT_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = OUT_MIRROR_DIV + 1) will be mirrored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EGMIRDIVr 0x0000021e

#define BCM53128_A0_EGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRDIV.
 *
 */
typedef union BCM53128_A0_EGMIRDIVr_s {
	uint32_t v[1];
	uint32_t egmirdiv[1];
	uint32_t _egmirdiv;
} BCM53128_A0_EGMIRDIVr_t;

#define BCM53128_A0_EGMIRDIVr_CLR(r) (r).egmirdiv[0] = 0
#define BCM53128_A0_EGMIRDIVr_SET(r,d) (r).egmirdiv[0] = d
#define BCM53128_A0_EGMIRDIVr_GET(r) (r).egmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EGMIRDIVr_OUT_MIR_DIVf_GET(r) (((r).egmirdiv[0]) & 0x3ff)
#define BCM53128_A0_EGMIRDIVr_OUT_MIR_DIVf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_EGMIRDIVr_RESERVEDf_GET(r) ((((r).egmirdiv[0]) >> 10) & 0x3f)
#define BCM53128_A0_EGMIRDIVr_RESERVEDf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EGMIRDIV.
 *
 */
#define BCM53128_A0_READ_EGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EGMIRDIVr,(r._egmirdiv),2)
#define BCM53128_A0_WRITE_EGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EGMIRDIVr,&(r._egmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRDIVr BCM53128_A0_EGMIRDIVr
#define EGMIRDIVr_SIZE BCM53128_A0_EGMIRDIVr_SIZE
typedef BCM53128_A0_EGMIRDIVr_t EGMIRDIVr_t;
#define EGMIRDIVr_CLR BCM53128_A0_EGMIRDIVr_CLR
#define EGMIRDIVr_SET BCM53128_A0_EGMIRDIVr_SET
#define EGMIRDIVr_GET BCM53128_A0_EGMIRDIVr_GET
#define EGMIRDIVr_OUT_MIR_DIVf_GET BCM53128_A0_EGMIRDIVr_OUT_MIR_DIVf_GET
#define EGMIRDIVr_OUT_MIR_DIVf_SET BCM53128_A0_EGMIRDIVr_OUT_MIR_DIVf_SET
#define EGMIRDIVr_RESERVEDf_GET BCM53128_A0_EGMIRDIVr_RESERVEDf_GET
#define EGMIRDIVr_RESERVEDf_SET BCM53128_A0_EGMIRDIVr_RESERVEDf_SET
#define READ_EGMIRDIVr BCM53128_A0_READ_EGMIRDIVr
#define WRITE_EGMIRDIVr BCM53128_A0_WRITE_EGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Egress Mirror MAC Address Register
 * SIZE:     48
 * FIELDS:
 *     OUT_MIR_MAC      Egress Mirror MAC Address.MAC address that will be compared against engress frames in accordance with the OUT_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM53128_A0_EGMIRMACr 0x00000220

#define BCM53128_A0_EGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program EGMIRMAC.
 *
 */
typedef union BCM53128_A0_EGMIRMACr_s {
	uint32_t v[2];
	uint32_t egmirmac[2];
	uint32_t _egmirmac;
} BCM53128_A0_EGMIRMACr_t;

#define BCM53128_A0_EGMIRMACr_CLR(r) CDK_MEMSET(&((r)._egmirmac), 0, sizeof(BCM53128_A0_EGMIRMACr_t))
#define BCM53128_A0_EGMIRMACr_SET(r,i,d) (r).egmirmac[i] = d
#define BCM53128_A0_EGMIRMACr_GET(r,i) (r).egmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EGMIRMACr_OUT_MIR_MACf_GET(r,a) cdk_field_get((r).egmirmac,0,47,a)
#define BCM53128_A0_EGMIRMACr_OUT_MIR_MACf_SET(r,a) cdk_field_set((r).egmirmac,0,47,a)

/*
 * These macros can be used to access EGMIRMAC.
 *
 */
#define BCM53128_A0_READ_EGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53128_A0_EGMIRMACr,(r._egmirmac),6)
#define BCM53128_A0_WRITE_EGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53128_A0_EGMIRMACr,&(r._egmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRMACr BCM53128_A0_EGMIRMACr
#define EGMIRMACr_SIZE BCM53128_A0_EGMIRMACr_SIZE
typedef BCM53128_A0_EGMIRMACr_t EGMIRMACr_t;
#define EGMIRMACr_CLR BCM53128_A0_EGMIRMACr_CLR
#define EGMIRMACr_SET BCM53128_A0_EGMIRMACr_SET
#define EGMIRMACr_GET BCM53128_A0_EGMIRMACr_GET
#define EGMIRMACr_OUT_MIR_MACf_GET BCM53128_A0_EGMIRMACr_OUT_MIR_MACf_GET
#define EGMIRMACr_OUT_MIR_MACf_SET BCM53128_A0_EGMIRMACr_OUT_MIR_MACf_SET
#define READ_EGMIRMACr BCM53128_A0_READ_EGMIRMACr
#define WRITE_EGMIRMACr BCM53128_A0_WRITE_EGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  EGRESS_NAVB_PKT_TC2PCP_MAP
 * BLOCKS:   GPIC0
 * DESC:     Egress Port N Non-AVB Packet TC to PCP mapping Register
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  The {PCP} Field for {TC} = {0}
 *     RESERVED_0       Reserved
 *     PCP_FOR_RV0_TC1  The {PCP} Field for {TC} = {1}
 *     RESERVED_1       Reserved
 *     PCP_FOR_RV0_TC2  The {PCP} Field for {TC} = {2}
 *     RESERVED_2       Reserved
 *     PCP_FOR_RV0_TC3  The {PCP} Field for {TC} = {3}
 *     RESERVED_3       Reserved
 *     PCP_FOR_RV0_TC4  The {PCP} Field for {TC} = {4}
 *     RESERVED_4       Reserved
 *     PCP_FOR_RV0_TC5  The {PCP} Field for {TC} = {5}
 *     RESERVED_5       Reserved
 *     PCP_FOR_RV0_TC6  The {PCP} Field for {TC} = {6}
 *     RESERVED_6       Reserved
 *     PCP_FOR_RV0_TC7  The {PCP} Field for {TC} = {7}
 *     RESERVED_7       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr 0x00009110

#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_NAVB_PKT_TC2PCP_MAP.
 *
 */
typedef union BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_s {
	uint32_t v[2];
	uint32_t egress_navb_pkt_tc2pcp_map[2];
	uint32_t _egress_navb_pkt_tc2pcp_map;
} BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_t;

#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_CLR(r) CDK_MEMSET(&((r)._egress_navb_pkt_tc2pcp_map), 0, sizeof(BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_t))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_SET(r,i,d) (r).egress_navb_pkt_tc2pcp_map[i] = d
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_GET(r,i) (r).egress_navb_pkt_tc2pcp_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_navb_pkt_tc2pcp_map[0]) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_0f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 3) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_0f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 4) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_1f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 7) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_1f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 8) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_2f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 11) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_2f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 12) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_3f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 15) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_3f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 16) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_4f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 19) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_4f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 20) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_5f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 23) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_5f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 24) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_6f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 27) & 0x1)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_6f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_navb_pkt_tc2pcp_map[0]) >> 28) & 0x7)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_navb_pkt_tc2pcp_map[0]=(((r).egress_navb_pkt_tc2pcp_map[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_7f_GET(r,a) cdk_field_get((r).egress_navb_pkt_tc2pcp_map,31,63,a)
#define BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_7f_SET(r,a) cdk_field_set((r).egress_navb_pkt_tc2pcp_map,31,63,a)

/*
 * These macros can be used to access EGRESS_NAVB_PKT_TC2PCP_MAP.
 *
 */
#define BCM53128_A0_READ_EGRESS_NAVB_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr,(r._egress_navb_pkt_tc2pcp_map),8)
#define BCM53128_A0_WRITE_EGRESS_NAVB_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr,&(r._egress_navb_pkt_tc2pcp_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_NAVB_PKT_TC2PCP_MAPr BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_SIZE BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_SIZE
typedef BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_t EGRESS_NAVB_PKT_TC2PCP_MAPr_t;
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_CLR BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_CLR
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_0f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_0f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_0f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_0f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_1f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_1f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_1f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_1f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_2f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_2f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_2f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_2f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_3f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_3f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_3f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_3f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_4f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_4f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_4f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_4f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_5f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_5f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_5f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_5f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_6f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_6f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_6f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_6f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_7f_GET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_7f_GET
#define EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_7f_SET BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr_RESERVED_7f_SET
#define READ_EGRESS_NAVB_PKT_TC2PCP_MAPr BCM53128_A0_READ_EGRESS_NAVB_PKT_TC2PCP_MAPr
#define WRITE_EGRESS_NAVB_PKT_TC2PCP_MAPr BCM53128_A0_WRITE_EGRESS_NAVB_PKT_TC2PCP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_EGRESS_NAVB_PKT_TC2PCP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FAST_AGE_CTRL
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_FAST_AGE_STATIC Set 1'b1 to Age out Static Entry.
 *     EN_AGE_DYNAMIC   Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_PORT      Set 1'b1 to Check Port ID
 *     EN_AGE_VLAN      Set 1'b1 to Check Vlan ID.
 *     EN_AGE_SPT       Set 1'b1 to check spanning Tree ID(refer to EN_802_1S/MSPT_AGE_MAP at page/address=43h/00h,02-05h)
 *     EN_AGE_MCAST     Enable Aging Multicast entry1: Aging multicast entries in ARL table0: Disable aging multicast entries in ARL table*** Note that the EN_AGE_MCAST and the EN_AGE_PORT can't enable(set to 1'b1) at same time.
 *     RESERVED         Reserved
 *     FAST_AGE_STR_DONE Set 1'b1 to trigger fast ageing process.When Fast aging process is done, this bit is cleared to 1'b0.
 *
 ******************************************************************************/
#define BCM53128_A0_FAST_AGE_CTRLr 0x00000088

#define BCM53128_A0_FAST_AGE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_CTRL.
 *
 */
typedef union BCM53128_A0_FAST_AGE_CTRLr_s {
	uint32_t v[1];
	uint32_t fast_age_ctrl[1];
	uint32_t _fast_age_ctrl;
} BCM53128_A0_FAST_AGE_CTRLr_t;

#define BCM53128_A0_FAST_AGE_CTRLr_CLR(r) (r).fast_age_ctrl[0] = 0
#define BCM53128_A0_FAST_AGE_CTRLr_SET(r,d) (r).fast_age_ctrl[0] = d
#define BCM53128_A0_FAST_AGE_CTRLr_GET(r) (r).fast_age_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET(r) (((r).fast_age_ctrl[0]) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET(r) ((((r).fast_age_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET(r) ((((r).fast_age_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET(r) ((((r).fast_age_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET(r) ((((r).fast_age_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET(r) ((((r).fast_age_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_FAST_AGE_CTRLr_RESERVEDf_GET(r) ((((r).fast_age_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_RESERVEDf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET(r) ((((r).fast_age_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FAST_AGE_CTRL.
 *
 */
#define BCM53128_A0_READ_FAST_AGE_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FAST_AGE_CTRLr,(r._fast_age_ctrl),1)
#define BCM53128_A0_WRITE_FAST_AGE_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FAST_AGE_CTRLr,&(r._fast_age_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_CTRLr BCM53128_A0_FAST_AGE_CTRLr
#define FAST_AGE_CTRLr_SIZE BCM53128_A0_FAST_AGE_CTRLr_SIZE
typedef BCM53128_A0_FAST_AGE_CTRLr_t FAST_AGE_CTRLr_t;
#define FAST_AGE_CTRLr_CLR BCM53128_A0_FAST_AGE_CTRLr_CLR
#define FAST_AGE_CTRLr_SET BCM53128_A0_FAST_AGE_CTRLr_SET
#define FAST_AGE_CTRLr_GET BCM53128_A0_FAST_AGE_CTRLr_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET BCM53128_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET BCM53128_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_GET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_SET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_GET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_SET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_GET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_SET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_GET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_SET BCM53128_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET
#define FAST_AGE_CTRLr_RESERVEDf_GET BCM53128_A0_FAST_AGE_CTRLr_RESERVEDf_GET
#define FAST_AGE_CTRLr_RESERVEDf_SET BCM53128_A0_FAST_AGE_CTRLr_RESERVEDf_SET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET BCM53128_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET BCM53128_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET
#define READ_FAST_AGE_CTRLr BCM53128_A0_READ_FAST_AGE_CTRLr
#define WRITE_FAST_AGE_CTRLr BCM53128_A0_WRITE_FAST_AGE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FAST_AGE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FAST_AGE_PORT
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Port Control Register
 * SIZE:     8
 * FIELDS:
 *     AGE_PORT         Select Fast Ageing Source Port.Select a specified Port ID to be aged-out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FAST_AGE_PORTr 0x00000089

#define BCM53128_A0_FAST_AGE_PORTr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_PORT.
 *
 */
typedef union BCM53128_A0_FAST_AGE_PORTr_s {
	uint32_t v[1];
	uint32_t fast_age_port[1];
	uint32_t _fast_age_port;
} BCM53128_A0_FAST_AGE_PORTr_t;

#define BCM53128_A0_FAST_AGE_PORTr_CLR(r) (r).fast_age_port[0] = 0
#define BCM53128_A0_FAST_AGE_PORTr_SET(r,d) (r).fast_age_port[0] = d
#define BCM53128_A0_FAST_AGE_PORTr_GET(r) (r).fast_age_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FAST_AGE_PORTr_AGE_PORTf_GET(r) (((r).fast_age_port[0]) & 0xf)
#define BCM53128_A0_FAST_AGE_PORTr_AGE_PORTf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_FAST_AGE_PORTr_RESERVEDf_GET(r) ((((r).fast_age_port[0]) >> 4) & 0xf)
#define BCM53128_A0_FAST_AGE_PORTr_RESERVEDf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access FAST_AGE_PORT.
 *
 */
#define BCM53128_A0_READ_FAST_AGE_PORTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FAST_AGE_PORTr,(r._fast_age_port),1)
#define BCM53128_A0_WRITE_FAST_AGE_PORTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FAST_AGE_PORTr,&(r._fast_age_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_PORTr BCM53128_A0_FAST_AGE_PORTr
#define FAST_AGE_PORTr_SIZE BCM53128_A0_FAST_AGE_PORTr_SIZE
typedef BCM53128_A0_FAST_AGE_PORTr_t FAST_AGE_PORTr_t;
#define FAST_AGE_PORTr_CLR BCM53128_A0_FAST_AGE_PORTr_CLR
#define FAST_AGE_PORTr_SET BCM53128_A0_FAST_AGE_PORTr_SET
#define FAST_AGE_PORTr_GET BCM53128_A0_FAST_AGE_PORTr_GET
#define FAST_AGE_PORTr_AGE_PORTf_GET BCM53128_A0_FAST_AGE_PORTr_AGE_PORTf_GET
#define FAST_AGE_PORTr_AGE_PORTf_SET BCM53128_A0_FAST_AGE_PORTr_AGE_PORTf_SET
#define FAST_AGE_PORTr_RESERVEDf_GET BCM53128_A0_FAST_AGE_PORTr_RESERVEDf_GET
#define FAST_AGE_PORTr_RESERVEDf_SET BCM53128_A0_FAST_AGE_PORTr_RESERVEDf_SET
#define READ_FAST_AGE_PORTr BCM53128_A0_READ_FAST_AGE_PORTr
#define WRITE_FAST_AGE_PORTr BCM53128_A0_WRITE_FAST_AGE_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FAST_AGE_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FAST_AGE_VID
 * BLOCKS:   SYS
 * DESC:     Fast Ageing VID Control Register
 * SIZE:     16
 * FIELDS:
 *     AGE_VID          Select Fast Ageing VLAN IDSelect a specified VLAN ID to be aged-out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FAST_AGE_VIDr 0x0000008a

#define BCM53128_A0_FAST_AGE_VIDr_SIZE 2

/*
 * This structure should be used to declare and program FAST_AGE_VID.
 *
 */
typedef union BCM53128_A0_FAST_AGE_VIDr_s {
	uint32_t v[1];
	uint32_t fast_age_vid[1];
	uint32_t _fast_age_vid;
} BCM53128_A0_FAST_AGE_VIDr_t;

#define BCM53128_A0_FAST_AGE_VIDr_CLR(r) (r).fast_age_vid[0] = 0
#define BCM53128_A0_FAST_AGE_VIDr_SET(r,d) (r).fast_age_vid[0] = d
#define BCM53128_A0_FAST_AGE_VIDr_GET(r) (r).fast_age_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FAST_AGE_VIDr_AGE_VIDf_GET(r) (((r).fast_age_vid[0]) & 0xfff)
#define BCM53128_A0_FAST_AGE_VIDr_AGE_VIDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_FAST_AGE_VIDr_RESERVEDf_GET(r) ((((r).fast_age_vid[0]) >> 12) & 0xf)
#define BCM53128_A0_FAST_AGE_VIDr_RESERVEDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access FAST_AGE_VID.
 *
 */
#define BCM53128_A0_READ_FAST_AGE_VIDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FAST_AGE_VIDr,(r._fast_age_vid),2)
#define BCM53128_A0_WRITE_FAST_AGE_VIDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FAST_AGE_VIDr,&(r._fast_age_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_VIDr BCM53128_A0_FAST_AGE_VIDr
#define FAST_AGE_VIDr_SIZE BCM53128_A0_FAST_AGE_VIDr_SIZE
typedef BCM53128_A0_FAST_AGE_VIDr_t FAST_AGE_VIDr_t;
#define FAST_AGE_VIDr_CLR BCM53128_A0_FAST_AGE_VIDr_CLR
#define FAST_AGE_VIDr_SET BCM53128_A0_FAST_AGE_VIDr_SET
#define FAST_AGE_VIDr_GET BCM53128_A0_FAST_AGE_VIDr_GET
#define FAST_AGE_VIDr_AGE_VIDf_GET BCM53128_A0_FAST_AGE_VIDr_AGE_VIDf_GET
#define FAST_AGE_VIDr_AGE_VIDf_SET BCM53128_A0_FAST_AGE_VIDr_AGE_VIDf_SET
#define FAST_AGE_VIDr_RESERVEDf_GET BCM53128_A0_FAST_AGE_VIDr_RESERVEDf_GET
#define FAST_AGE_VIDr_RESERVEDf_SET BCM53128_A0_FAST_AGE_VIDr_RESERVEDf_SET
#define READ_FAST_AGE_VIDr BCM53128_A0_READ_FAST_AGE_VIDr
#define WRITE_FAST_AGE_VIDr BCM53128_A0_WRITE_FAST_AGE_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FAST_AGE_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CHIP_INFO
 * BLOCKS:   SYS
 * DESC:     Chip Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     PRT_LINK         
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CHIP_INFOr 0x00000a9a

#define BCM53128_A0_FC_CHIP_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_CHIP_INFO.
 *
 */
typedef union BCM53128_A0_FC_CHIP_INFOr_s {
	uint32_t v[1];
	uint32_t fc_chip_info[1];
	uint32_t _fc_chip_info;
} BCM53128_A0_FC_CHIP_INFOr_t;

#define BCM53128_A0_FC_CHIP_INFOr_CLR(r) (r).fc_chip_info[0] = 0
#define BCM53128_A0_FC_CHIP_INFOr_SET(r,d) (r).fc_chip_info[0] = d
#define BCM53128_A0_FC_CHIP_INFOr_GET(r) (r).fc_chip_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CHIP_INFOr_PRT_LINKf_GET(r) (((r).fc_chip_info[0]) & 0x1ff)
#define BCM53128_A0_FC_CHIP_INFOr_PRT_LINKf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_FC_CHIP_INFOr_RESERVEDf_GET(r) ((((r).fc_chip_info[0]) >> 9) & 0x7f)
#define BCM53128_A0_FC_CHIP_INFOr_RESERVEDf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_CHIP_INFO.
 *
 */
#define BCM53128_A0_READ_FC_CHIP_INFOr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CHIP_INFOr,(r._fc_chip_info),2)
#define BCM53128_A0_WRITE_FC_CHIP_INFOr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CHIP_INFOr,&(r._fc_chip_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CHIP_INFOr BCM53128_A0_FC_CHIP_INFOr
#define FC_CHIP_INFOr_SIZE BCM53128_A0_FC_CHIP_INFOr_SIZE
typedef BCM53128_A0_FC_CHIP_INFOr_t FC_CHIP_INFOr_t;
#define FC_CHIP_INFOr_CLR BCM53128_A0_FC_CHIP_INFOr_CLR
#define FC_CHIP_INFOr_SET BCM53128_A0_FC_CHIP_INFOr_SET
#define FC_CHIP_INFOr_GET BCM53128_A0_FC_CHIP_INFOr_GET
#define FC_CHIP_INFOr_PRT_LINKf_GET BCM53128_A0_FC_CHIP_INFOr_PRT_LINKf_GET
#define FC_CHIP_INFOr_PRT_LINKf_SET BCM53128_A0_FC_CHIP_INFOr_PRT_LINKf_SET
#define FC_CHIP_INFOr_RESERVEDf_GET BCM53128_A0_FC_CHIP_INFOr_RESERVEDf_GET
#define FC_CHIP_INFOr_RESERVEDf_SET BCM53128_A0_FC_CHIP_INFOr_RESERVEDf_SET
#define READ_FC_CHIP_INFOr BCM53128_A0_READ_FC_CHIP_INFOr
#define WRITE_FC_CHIP_INFOr BCM53128_A0_WRITE_FC_CHIP_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CHIP_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CONG_BUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Congested Bus Error Register
 * SIZE:     16
 * FIELDS:
 *     CONG_BUF_ERR_HIS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr 0x00000aaa

#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_BUF_ERR_HIS.
 *
 */
typedef union BCM53128_A0_FC_CONG_BUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_cong_buf_err_his[1];
	uint32_t _fc_cong_buf_err_his;
} BCM53128_A0_FC_CONG_BUF_ERR_HISr_t;

#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_CLR(r) (r).fc_cong_buf_err_his[0] = 0
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_SET(r,d) (r).fc_cong_buf_err_his[0] = d
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_GET(r) (r).fc_cong_buf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET(r) (((r).fc_cong_buf_err_his[0]) & 0x1)
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_GET(r) ((((r).fc_cong_buf_err_his[0]) >> 1) & 0x7fff)
#define BCM53128_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access FC_CONG_BUF_ERR_HIS.
 *
 */
#define BCM53128_A0_READ_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CONG_BUF_ERR_HISr,(r._fc_cong_buf_err_his),2)
#define BCM53128_A0_WRITE_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CONG_BUF_ERR_HISr,&(r._fc_cong_buf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_BUF_ERR_HISr BCM53128_A0_FC_CONG_BUF_ERR_HISr
#define FC_CONG_BUF_ERR_HISr_SIZE BCM53128_A0_FC_CONG_BUF_ERR_HISr_SIZE
typedef BCM53128_A0_FC_CONG_BUF_ERR_HISr_t FC_CONG_BUF_ERR_HISr_t;
#define FC_CONG_BUF_ERR_HISr_CLR BCM53128_A0_FC_CONG_BUF_ERR_HISr_CLR
#define FC_CONG_BUF_ERR_HISr_SET BCM53128_A0_FC_CONG_BUF_ERR_HISr_SET
#define FC_CONG_BUF_ERR_HISr_GET BCM53128_A0_FC_CONG_BUF_ERR_HISr_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET BCM53128_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET BCM53128_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET
#define FC_CONG_BUF_ERR_HISr_RESERVEDf_GET BCM53128_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_GET
#define FC_CONG_BUF_ERR_HISr_RESERVEDf_SET BCM53128_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_SET
#define READ_FC_CONG_BUF_ERR_HISr BCM53128_A0_READ_FC_CONG_BUF_ERR_HISr
#define WRITE_FC_CONG_BUF_ERR_HISr BCM53128_A0_WRITE_FC_CONG_BUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CONG_BUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CONG_PORTMAP01
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port01 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP0    Port 0 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP1    Port 1 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CONG_PORTMAP01r 0x00000a90

#define BCM53128_A0_FC_CONG_PORTMAP01r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP01.
 *
 */
typedef union BCM53128_A0_FC_CONG_PORTMAP01r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap01[1];
	uint32_t _fc_cong_portmap01;
} BCM53128_A0_FC_CONG_PORTMAP01r_t;

#define BCM53128_A0_FC_CONG_PORTMAP01r_CLR(r) (r).fc_cong_portmap01[0] = 0
#define BCM53128_A0_FC_CONG_PORTMAP01r_SET(r,d) (r).fc_cong_portmap01[0] = d
#define BCM53128_A0_FC_CONG_PORTMAP01r_GET(r) (r).fc_cong_portmap01[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET(r) (((r).fc_cong_portmap01[0]) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET(r) ((((r).fc_cong_portmap01[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP01.
 *
 */
#define BCM53128_A0_READ_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CONG_PORTMAP01r,(r._fc_cong_portmap01),2)
#define BCM53128_A0_WRITE_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CONG_PORTMAP01r,&(r._fc_cong_portmap01),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP01r BCM53128_A0_FC_CONG_PORTMAP01r
#define FC_CONG_PORTMAP01r_SIZE BCM53128_A0_FC_CONG_PORTMAP01r_SIZE
typedef BCM53128_A0_FC_CONG_PORTMAP01r_t FC_CONG_PORTMAP01r_t;
#define FC_CONG_PORTMAP01r_CLR BCM53128_A0_FC_CONG_PORTMAP01r_CLR
#define FC_CONG_PORTMAP01r_SET BCM53128_A0_FC_CONG_PORTMAP01r_SET
#define FC_CONG_PORTMAP01r_GET BCM53128_A0_FC_CONG_PORTMAP01r_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET BCM53128_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET
#define READ_FC_CONG_PORTMAP01r BCM53128_A0_READ_FC_CONG_PORTMAP01r
#define WRITE_FC_CONG_PORTMAP01r BCM53128_A0_WRITE_FC_CONG_PORTMAP01r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CONG_PORTMAP01r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CONG_PORTMAP23
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port23 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP2    Port 2 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP3    Port 3 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CONG_PORTMAP23r 0x00000a92

#define BCM53128_A0_FC_CONG_PORTMAP23r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP23.
 *
 */
typedef union BCM53128_A0_FC_CONG_PORTMAP23r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap23[1];
	uint32_t _fc_cong_portmap23;
} BCM53128_A0_FC_CONG_PORTMAP23r_t;

#define BCM53128_A0_FC_CONG_PORTMAP23r_CLR(r) (r).fc_cong_portmap23[0] = 0
#define BCM53128_A0_FC_CONG_PORTMAP23r_SET(r,d) (r).fc_cong_portmap23[0] = d
#define BCM53128_A0_FC_CONG_PORTMAP23r_GET(r) (r).fc_cong_portmap23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET(r) (((r).fc_cong_portmap23[0]) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET(r) ((((r).fc_cong_portmap23[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP23.
 *
 */
#define BCM53128_A0_READ_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CONG_PORTMAP23r,(r._fc_cong_portmap23),2)
#define BCM53128_A0_WRITE_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CONG_PORTMAP23r,&(r._fc_cong_portmap23),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP23r BCM53128_A0_FC_CONG_PORTMAP23r
#define FC_CONG_PORTMAP23r_SIZE BCM53128_A0_FC_CONG_PORTMAP23r_SIZE
typedef BCM53128_A0_FC_CONG_PORTMAP23r_t FC_CONG_PORTMAP23r_t;
#define FC_CONG_PORTMAP23r_CLR BCM53128_A0_FC_CONG_PORTMAP23r_CLR
#define FC_CONG_PORTMAP23r_SET BCM53128_A0_FC_CONG_PORTMAP23r_SET
#define FC_CONG_PORTMAP23r_GET BCM53128_A0_FC_CONG_PORTMAP23r_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET BCM53128_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET
#define READ_FC_CONG_PORTMAP23r BCM53128_A0_READ_FC_CONG_PORTMAP23r
#define WRITE_FC_CONG_PORTMAP23r BCM53128_A0_WRITE_FC_CONG_PORTMAP23r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CONG_PORTMAP23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CONG_PORTMAP45
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port45 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP4    Port 4 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP5    Port 5 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CONG_PORTMAP45r 0x00000a94

#define BCM53128_A0_FC_CONG_PORTMAP45r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP45.
 *
 */
typedef union BCM53128_A0_FC_CONG_PORTMAP45r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap45[1];
	uint32_t _fc_cong_portmap45;
} BCM53128_A0_FC_CONG_PORTMAP45r_t;

#define BCM53128_A0_FC_CONG_PORTMAP45r_CLR(r) (r).fc_cong_portmap45[0] = 0
#define BCM53128_A0_FC_CONG_PORTMAP45r_SET(r,d) (r).fc_cong_portmap45[0] = d
#define BCM53128_A0_FC_CONG_PORTMAP45r_GET(r) (r).fc_cong_portmap45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET(r) (((r).fc_cong_portmap45[0]) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET(r) ((((r).fc_cong_portmap45[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP45.
 *
 */
#define BCM53128_A0_READ_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CONG_PORTMAP45r,(r._fc_cong_portmap45),2)
#define BCM53128_A0_WRITE_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CONG_PORTMAP45r,&(r._fc_cong_portmap45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP45r BCM53128_A0_FC_CONG_PORTMAP45r
#define FC_CONG_PORTMAP45r_SIZE BCM53128_A0_FC_CONG_PORTMAP45r_SIZE
typedef BCM53128_A0_FC_CONG_PORTMAP45r_t FC_CONG_PORTMAP45r_t;
#define FC_CONG_PORTMAP45r_CLR BCM53128_A0_FC_CONG_PORTMAP45r_CLR
#define FC_CONG_PORTMAP45r_SET BCM53128_A0_FC_CONG_PORTMAP45r_SET
#define FC_CONG_PORTMAP45r_GET BCM53128_A0_FC_CONG_PORTMAP45r_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET BCM53128_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET
#define READ_FC_CONG_PORTMAP45r BCM53128_A0_READ_FC_CONG_PORTMAP45r
#define WRITE_FC_CONG_PORTMAP45r BCM53128_A0_WRITE_FC_CONG_PORTMAP45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CONG_PORTMAP45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CONG_PORTMAP67
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port67 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP6    Port 6 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP7    Port 7 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CONG_PORTMAP67r 0x00000a96

#define BCM53128_A0_FC_CONG_PORTMAP67r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP67.
 *
 */
typedef union BCM53128_A0_FC_CONG_PORTMAP67r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap67[1];
	uint32_t _fc_cong_portmap67;
} BCM53128_A0_FC_CONG_PORTMAP67r_t;

#define BCM53128_A0_FC_CONG_PORTMAP67r_CLR(r) (r).fc_cong_portmap67[0] = 0
#define BCM53128_A0_FC_CONG_PORTMAP67r_SET(r,d) (r).fc_cong_portmap67[0] = d
#define BCM53128_A0_FC_CONG_PORTMAP67r_GET(r) (r).fc_cong_portmap67[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET(r) (((r).fc_cong_portmap67[0]) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET(r) ((((r).fc_cong_portmap67[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP67.
 *
 */
#define BCM53128_A0_READ_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CONG_PORTMAP67r,(r._fc_cong_portmap67),2)
#define BCM53128_A0_WRITE_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CONG_PORTMAP67r,&(r._fc_cong_portmap67),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP67r BCM53128_A0_FC_CONG_PORTMAP67r
#define FC_CONG_PORTMAP67r_SIZE BCM53128_A0_FC_CONG_PORTMAP67r_SIZE
typedef BCM53128_A0_FC_CONG_PORTMAP67r_t FC_CONG_PORTMAP67r_t;
#define FC_CONG_PORTMAP67r_CLR BCM53128_A0_FC_CONG_PORTMAP67r_CLR
#define FC_CONG_PORTMAP67r_SET BCM53128_A0_FC_CONG_PORTMAP67r_SET
#define FC_CONG_PORTMAP67r_GET BCM53128_A0_FC_CONG_PORTMAP67r_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET BCM53128_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET
#define READ_FC_CONG_PORTMAP67r BCM53128_A0_READ_FC_CONG_PORTMAP67r
#define WRITE_FC_CONG_PORTMAP67r BCM53128_A0_WRITE_FC_CONG_PORTMAP67r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CONG_PORTMAP67r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_CONG_PORTMAP8
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    Port 8 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_CONG_PORTMAP8r 0x00000a98

#define BCM53128_A0_FC_CONG_PORTMAP8r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP8.
 *
 */
typedef union BCM53128_A0_FC_CONG_PORTMAP8r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap8[1];
	uint32_t _fc_cong_portmap8;
} BCM53128_A0_FC_CONG_PORTMAP8r_t;

#define BCM53128_A0_FC_CONG_PORTMAP8r_CLR(r) (r).fc_cong_portmap8[0] = 0
#define BCM53128_A0_FC_CONG_PORTMAP8r_SET(r,d) (r).fc_cong_portmap8[0] = d
#define BCM53128_A0_FC_CONG_PORTMAP8r_GET(r) (r).fc_cong_portmap8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET(r) (((r).fc_cong_portmap8[0]) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_CONG_PORTMAP8r_RESERVEDf_GET(r) ((((r).fc_cong_portmap8[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_CONG_PORTMAP8r_RESERVEDf_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP8.
 *
 */
#define BCM53128_A0_READ_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_CONG_PORTMAP8r,(r._fc_cong_portmap8),2)
#define BCM53128_A0_WRITE_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_CONG_PORTMAP8r,&(r._fc_cong_portmap8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP8r BCM53128_A0_FC_CONG_PORTMAP8r
#define FC_CONG_PORTMAP8r_SIZE BCM53128_A0_FC_CONG_PORTMAP8r_SIZE
typedef BCM53128_A0_FC_CONG_PORTMAP8r_t FC_CONG_PORTMAP8r_t;
#define FC_CONG_PORTMAP8r_CLR BCM53128_A0_FC_CONG_PORTMAP8r_CLR
#define FC_CONG_PORTMAP8r_SET BCM53128_A0_FC_CONG_PORTMAP8r_SET
#define FC_CONG_PORTMAP8r_GET BCM53128_A0_FC_CONG_PORTMAP8r_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET BCM53128_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET BCM53128_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET
#define FC_CONG_PORTMAP8r_RESERVEDf_GET BCM53128_A0_FC_CONG_PORTMAP8r_RESERVEDf_GET
#define FC_CONG_PORTMAP8r_RESERVEDf_SET BCM53128_A0_FC_CONG_PORTMAP8r_RESERVEDf_SET
#define READ_FC_CONG_PORTMAP8r BCM53128_A0_READ_FC_CONG_PORTMAP8r
#define WRITE_FC_CONG_PORTMAP8r BCM53128_A0_WRITE_FC_CONG_PORTMAP8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_CONG_PORTMAP8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_DIAG_CTRL
 * BLOCKS:   SYS
 * DESC:     Flowcon Diagnosis Control Register
 * SIZE:     16
 * FIELDS:
 *     DIG_FLOWCON_PROT Diagnosis only: Select which port to be monitored.4'd0 : port 0; 4'd1: port1;  4'd 7: port 7
 *     RESERVED_1       Reserved.
 *     RESERVED_2       Reserved.
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_DIAG_CTRLr 0x00000a00

#define BCM53128_A0_FC_DIAG_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_DIAG_CTRL.
 *
 */
typedef union BCM53128_A0_FC_DIAG_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_diag_ctrl[1];
	uint32_t _fc_diag_ctrl;
} BCM53128_A0_FC_DIAG_CTRLr_t;

#define BCM53128_A0_FC_DIAG_CTRLr_CLR(r) (r).fc_diag_ctrl[0] = 0
#define BCM53128_A0_FC_DIAG_CTRLr_SET(r,d) (r).fc_diag_ctrl[0] = d
#define BCM53128_A0_FC_DIAG_CTRLr_GET(r) (r).fc_diag_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET(r) (((r).fc_diag_ctrl[0]) & 0xf)
#define BCM53128_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_FC_DIAG_CTRLr_RESERVED_1f_GET(r) ((((r).fc_diag_ctrl[0]) >> 4) & 0x3)
#define BCM53128_A0_FC_DIAG_CTRLr_RESERVED_1f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_FC_DIAG_CTRLr_RESERVED_2f_GET(r) ((((r).fc_diag_ctrl[0]) >> 6) & 0x3)
#define BCM53128_A0_FC_DIAG_CTRLr_RESERVED_2f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53128_A0_FC_DIAG_CTRLr_RESERVED_3f_GET(r) ((((r).fc_diag_ctrl[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_DIAG_CTRLr_RESERVED_3f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_DIAG_CTRL.
 *
 */
#define BCM53128_A0_READ_FC_DIAG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_DIAG_CTRLr,(r._fc_diag_ctrl),2)
#define BCM53128_A0_WRITE_FC_DIAG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_DIAG_CTRLr,&(r._fc_diag_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_DIAG_CTRLr BCM53128_A0_FC_DIAG_CTRLr
#define FC_DIAG_CTRLr_SIZE BCM53128_A0_FC_DIAG_CTRLr_SIZE
typedef BCM53128_A0_FC_DIAG_CTRLr_t FC_DIAG_CTRLr_t;
#define FC_DIAG_CTRLr_CLR BCM53128_A0_FC_DIAG_CTRLr_CLR
#define FC_DIAG_CTRLr_SET BCM53128_A0_FC_DIAG_CTRLr_SET
#define FC_DIAG_CTRLr_GET BCM53128_A0_FC_DIAG_CTRLr_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET BCM53128_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET BCM53128_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET
#define FC_DIAG_CTRLr_RESERVED_1f_GET BCM53128_A0_FC_DIAG_CTRLr_RESERVED_1f_GET
#define FC_DIAG_CTRLr_RESERVED_1f_SET BCM53128_A0_FC_DIAG_CTRLr_RESERVED_1f_SET
#define FC_DIAG_CTRLr_RESERVED_2f_GET BCM53128_A0_FC_DIAG_CTRLr_RESERVED_2f_GET
#define FC_DIAG_CTRLr_RESERVED_2f_SET BCM53128_A0_FC_DIAG_CTRLr_RESERVED_2f_SET
#define FC_DIAG_CTRLr_RESERVED_3f_GET BCM53128_A0_FC_DIAG_CTRLr_RESERVED_3f_GET
#define FC_DIAG_CTRLr_RESERVED_3f_SET BCM53128_A0_FC_DIAG_CTRLr_RESERVED_3f_SET
#define READ_FC_DIAG_CTRLr BCM53128_A0_READ_FC_DIAG_CTRLr
#define WRITE_FC_DIAG_CTRLr BCM53128_A0_WRITE_FC_DIAG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_DIAG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_GIGA_INFO
 * BLOCKS:   SYS
 * DESC:     Giga Speed Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     GIGA_PORTMAP     
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_GIGA_INFOr 0x00000a9c

#define BCM53128_A0_FC_GIGA_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_GIGA_INFO.
 *
 */
typedef union BCM53128_A0_FC_GIGA_INFOr_s {
	uint32_t v[1];
	uint32_t fc_giga_info[1];
	uint32_t _fc_giga_info;
} BCM53128_A0_FC_GIGA_INFOr_t;

#define BCM53128_A0_FC_GIGA_INFOr_CLR(r) (r).fc_giga_info[0] = 0
#define BCM53128_A0_FC_GIGA_INFOr_SET(r,d) (r).fc_giga_info[0] = d
#define BCM53128_A0_FC_GIGA_INFOr_GET(r) (r).fc_giga_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET(r) (((r).fc_giga_info[0]) & 0x1ff)
#define BCM53128_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_FC_GIGA_INFOr_RESERVEDf_GET(r) ((((r).fc_giga_info[0]) >> 9) & 0x7f)
#define BCM53128_A0_FC_GIGA_INFOr_RESERVEDf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_GIGA_INFO.
 *
 */
#define BCM53128_A0_READ_FC_GIGA_INFOr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_GIGA_INFOr,(r._fc_giga_info),2)
#define BCM53128_A0_WRITE_FC_GIGA_INFOr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_GIGA_INFOr,&(r._fc_giga_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_GIGA_INFOr BCM53128_A0_FC_GIGA_INFOr
#define FC_GIGA_INFOr_SIZE BCM53128_A0_FC_GIGA_INFOr_SIZE
typedef BCM53128_A0_FC_GIGA_INFOr_t FC_GIGA_INFOr_t;
#define FC_GIGA_INFOr_CLR BCM53128_A0_FC_GIGA_INFOr_CLR
#define FC_GIGA_INFOr_SET BCM53128_A0_FC_GIGA_INFOr_SET
#define FC_GIGA_INFOr_GET BCM53128_A0_FC_GIGA_INFOr_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_GET BCM53128_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_SET BCM53128_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET
#define FC_GIGA_INFOr_RESERVEDf_GET BCM53128_A0_FC_GIGA_INFOr_RESERVEDf_GET
#define FC_GIGA_INFOr_RESERVEDf_SET BCM53128_A0_FC_GIGA_INFOr_RESERVEDf_SET
#define READ_FC_GIGA_INFOr BCM53128_A0_READ_FC_GIGA_INFOr
#define WRITE_FC_GIGA_INFOr BCM53128_A0_WRITE_FC_GIGA_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_GIGA_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_IMP_THRESH_ADJUST_Q
 * BLOCKS:   SYS
 * DESC:     IMP Threshold Adjustment for Queue N Register
 * SIZE:     16
 * FIELDS:
 *     OFFSET           IMP port offset adjustment: The value defined in this field is used to offset the TXQ counter.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr 0x00000d80

#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_IMP_THRESH_ADJUST_Q.
 *
 */
typedef union BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_s {
	uint32_t v[1];
	uint32_t fc_imp_thresh_adjust_q[1];
	uint32_t _fc_imp_thresh_adjust_q;
} BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_t;

#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_CLR(r) (r).fc_imp_thresh_adjust_q[0] = 0
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_SET(r,d) (r).fc_imp_thresh_adjust_q[0] = d
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_GET(r) (r).fc_imp_thresh_adjust_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_OFFSETf_GET(r) (((r).fc_imp_thresh_adjust_q[0]) & 0x3ff)
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_OFFSETf_SET(r,f) (r).fc_imp_thresh_adjust_q[0]=(((r).fc_imp_thresh_adjust_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_RESERVEDf_GET(r) ((((r).fc_imp_thresh_adjust_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_RESERVEDf_SET(r,f) (r).fc_imp_thresh_adjust_q[0]=(((r).fc_imp_thresh_adjust_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_IMP_THRESH_ADJUST_Q.
 *
 */
#define BCM53128_A0_READ_FC_IMP_THRESH_ADJUST_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr+(2*(i)),(r._fc_imp_thresh_adjust_q),2)
#define BCM53128_A0_WRITE_FC_IMP_THRESH_ADJUST_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr+(2*(i)),&(r._fc_imp_thresh_adjust_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_IMP_THRESH_ADJUST_Qr BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr
#define FC_IMP_THRESH_ADJUST_Qr_SIZE BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_SIZE
typedef BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_t FC_IMP_THRESH_ADJUST_Qr_t;
#define FC_IMP_THRESH_ADJUST_Qr_CLR BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_CLR
#define FC_IMP_THRESH_ADJUST_Qr_SET BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_SET
#define FC_IMP_THRESH_ADJUST_Qr_GET BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_GET
#define FC_IMP_THRESH_ADJUST_Qr_OFFSETf_GET BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_OFFSETf_GET
#define FC_IMP_THRESH_ADJUST_Qr_OFFSETf_SET BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_OFFSETf_SET
#define FC_IMP_THRESH_ADJUST_Qr_RESERVEDf_GET BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_RESERVEDf_GET
#define FC_IMP_THRESH_ADJUST_Qr_RESERVEDf_SET BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr_RESERVEDf_SET
#define READ_FC_IMP_THRESH_ADJUST_Qr BCM53128_A0_READ_FC_IMP_THRESH_ADJUST_Qr
#define WRITE_FC_IMP_THRESH_ADJUST_Qr BCM53128_A0_WRITE_FC_IMP_THRESH_ADJUST_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_IMP_THRESH_ADJUST_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_MCAST_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Multicast Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     PAR_DROP_EN      Multicast Partial Drop Enalbed.Bit 8 = IMP port,Bit 7:0 = Port 7 ~ Port 0,1: Multicast Frame can forward to uncongested Destination Port, and will not forward to congested Destination Port0: Multicast Frame can forward only if all destination ports are not congested.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_MCAST_DROP_CTRLr 0x00000a0c

#define BCM53128_A0_FC_MCAST_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_MCAST_DROP_CTRL.
 *
 */
typedef union BCM53128_A0_FC_MCAST_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_mcast_drop_ctrl[1];
	uint32_t _fc_mcast_drop_ctrl;
} BCM53128_A0_FC_MCAST_DROP_CTRLr_t;

#define BCM53128_A0_FC_MCAST_DROP_CTRLr_CLR(r) (r).fc_mcast_drop_ctrl[0] = 0
#define BCM53128_A0_FC_MCAST_DROP_CTRLr_SET(r,d) (r).fc_mcast_drop_ctrl[0] = d
#define BCM53128_A0_FC_MCAST_DROP_CTRLr_GET(r) (r).fc_mcast_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET(r) (((r).fc_mcast_drop_ctrl[0]) & 0x1ff)
#define BCM53128_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_GET(r) ((((r).fc_mcast_drop_ctrl[0]) >> 9) & 0x7f)
#define BCM53128_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_MCAST_DROP_CTRL.
 *
 */
#define BCM53128_A0_READ_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_MCAST_DROP_CTRLr,(r._fc_mcast_drop_ctrl),2)
#define BCM53128_A0_WRITE_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_MCAST_DROP_CTRLr,&(r._fc_mcast_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MCAST_DROP_CTRLr BCM53128_A0_FC_MCAST_DROP_CTRLr
#define FC_MCAST_DROP_CTRLr_SIZE BCM53128_A0_FC_MCAST_DROP_CTRLr_SIZE
typedef BCM53128_A0_FC_MCAST_DROP_CTRLr_t FC_MCAST_DROP_CTRLr_t;
#define FC_MCAST_DROP_CTRLr_CLR BCM53128_A0_FC_MCAST_DROP_CTRLr_CLR
#define FC_MCAST_DROP_CTRLr_SET BCM53128_A0_FC_MCAST_DROP_CTRLr_SET
#define FC_MCAST_DROP_CTRLr_GET BCM53128_A0_FC_MCAST_DROP_CTRLr_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET BCM53128_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET BCM53128_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET
#define FC_MCAST_DROP_CTRLr_RESERVEDf_GET BCM53128_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_GET
#define FC_MCAST_DROP_CTRLr_RESERVEDf_SET BCM53128_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_SET
#define READ_FC_MCAST_DROP_CTRLr BCM53128_A0_READ_FC_MCAST_DROP_CTRLr
#define WRITE_FC_MCAST_DROP_CTRLr BCM53128_A0_WRITE_FC_MCAST_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_MCAST_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_MON_TXQ
 * BLOCKS:   SYS
 * DESC:     Monitored TxQ N (0~5) Register
 * SIZE:     16
 * FIELDS:
 *     MONITORED_TXQ_CNT Monitor TxQ 0~5 countTxQ 4/5 indicate Class4/5 trafficThe diag_port setting in Diag register(Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_MON_TXQr 0x00000a60

#define BCM53128_A0_FC_MON_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_MON_TXQ.
 *
 */
typedef union BCM53128_A0_FC_MON_TXQr_s {
	uint32_t v[1];
	uint32_t fc_mon_txq[1];
	uint32_t _fc_mon_txq;
} BCM53128_A0_FC_MON_TXQr_t;

#define BCM53128_A0_FC_MON_TXQr_CLR(r) (r).fc_mon_txq[0] = 0
#define BCM53128_A0_FC_MON_TXQr_SET(r,d) (r).fc_mon_txq[0] = d
#define BCM53128_A0_FC_MON_TXQr_GET(r) (r).fc_mon_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET(r) (((r).fc_mon_txq[0]) & 0x7ff)
#define BCM53128_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_MON_TXQr_RESERVEDf_GET(r) ((((r).fc_mon_txq[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_MON_TXQr_RESERVEDf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_MON_TXQ.
 *
 */
#define BCM53128_A0_READ_FC_MON_TXQr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_MON_TXQr+(2*(i)),(r._fc_mon_txq),2)
#define BCM53128_A0_WRITE_FC_MON_TXQr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_MON_TXQr+(2*(i)),&(r._fc_mon_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_TXQr BCM53128_A0_FC_MON_TXQr
#define FC_MON_TXQr_SIZE BCM53128_A0_FC_MON_TXQr_SIZE
typedef BCM53128_A0_FC_MON_TXQr_t FC_MON_TXQr_t;
#define FC_MON_TXQr_CLR BCM53128_A0_FC_MON_TXQr_CLR
#define FC_MON_TXQr_SET BCM53128_A0_FC_MON_TXQr_SET
#define FC_MON_TXQr_GET BCM53128_A0_FC_MON_TXQr_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_GET BCM53128_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_SET BCM53128_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET
#define FC_MON_TXQr_RESERVEDf_GET BCM53128_A0_FC_MON_TXQr_RESERVEDf_GET
#define FC_MON_TXQr_RESERVEDf_SET BCM53128_A0_FC_MON_TXQr_RESERVEDf_SET
#define READ_FC_MON_TXQr BCM53128_A0_READ_FC_MON_TXQr
#define WRITE_FC_MON_TXQr BCM53128_A0_WRITE_FC_MON_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_MON_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_PAUSE_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause/Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TX_PAUSE      To enable txq pause machinism on Ethernet port
 *     EN_TX_DROP       
 *     EN_TOTAL_PAUSE   To enable total pause machinism on Ethernet port
 *     EN_TOTAL_DROP    
 *     EN_TX_LEGACY_PAUSE 
 *     RESERVED         Reserved.
 *     EN_RX_PAUSE      
 *     EN_RX_DROP       
 *     RESERVED_0       Reserved.
 *     RESERVED_1       Reserved.
 *     EN_IMP_TXQ_PAUSE To enable txq pause machinism on IMP
 *     EN_IMP_TOTAL_PAUSE To enable total pause machinism on IMP
 *
 ******************************************************************************/
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr 0x00000a0e

#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_DROP_CTRL.
 *
 */
typedef union BCM53128_A0_FC_PAUSE_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_pause_drop_ctrl[1];
	uint32_t _fc_pause_drop_ctrl;
} BCM53128_A0_FC_PAUSE_DROP_CTRLr_t;

#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_CLR(r) (r).fc_pause_drop_ctrl[0] = 0
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_SET(r,d) (r).fc_pause_drop_ctrl[0] = d
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_GET(r) (r).fc_pause_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET(r) (((r).fc_pause_drop_ctrl[0]) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 8) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 9) & 0x3)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 11) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 12) & 0x1)
#define BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access FC_PAUSE_DROP_CTRL.
 *
 */
#define BCM53128_A0_READ_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_PAUSE_DROP_CTRLr,(r._fc_pause_drop_ctrl),2)
#define BCM53128_A0_WRITE_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_PAUSE_DROP_CTRLr,&(r._fc_pause_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_DROP_CTRLr BCM53128_A0_FC_PAUSE_DROP_CTRLr
#define FC_PAUSE_DROP_CTRLr_SIZE BCM53128_A0_FC_PAUSE_DROP_CTRLr_SIZE
typedef BCM53128_A0_FC_PAUSE_DROP_CTRLr_t FC_PAUSE_DROP_CTRLr_t;
#define FC_PAUSE_DROP_CTRLr_CLR BCM53128_A0_FC_PAUSE_DROP_CTRLr_CLR
#define FC_PAUSE_DROP_CTRLr_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_SET
#define FC_PAUSE_DROP_CTRLr_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVEDf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVEDf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET BCM53128_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET
#define READ_FC_PAUSE_DROP_CTRLr BCM53128_A0_READ_FC_PAUSE_DROP_CTRLr
#define WRITE_FC_PAUSE_DROP_CTRLr BCM53128_A0_WRITE_FC_PAUSE_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_PAUSE_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_PAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     Pause History Register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_HIS        
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_PAUSE_HISr 0x00000aa0

#define BCM53128_A0_FC_PAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_HIS.
 *
 */
typedef union BCM53128_A0_FC_PAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_pause_his[1];
	uint32_t _fc_pause_his;
} BCM53128_A0_FC_PAUSE_HISr_t;

#define BCM53128_A0_FC_PAUSE_HISr_CLR(r) (r).fc_pause_his[0] = 0
#define BCM53128_A0_FC_PAUSE_HISr_SET(r,d) (r).fc_pause_his[0] = d
#define BCM53128_A0_FC_PAUSE_HISr_GET(r) (r).fc_pause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_PAUSE_HISr_PAUSE_HISf_GET(r) (((r).fc_pause_his[0]) & 0x7ff)
#define BCM53128_A0_FC_PAUSE_HISr_PAUSE_HISf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_PAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_pause_his[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_PAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PAUSE_HIS.
 *
 */
#define BCM53128_A0_READ_FC_PAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_PAUSE_HISr,(r._fc_pause_his),2)
#define BCM53128_A0_WRITE_FC_PAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_PAUSE_HISr,&(r._fc_pause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_HISr BCM53128_A0_FC_PAUSE_HISr
#define FC_PAUSE_HISr_SIZE BCM53128_A0_FC_PAUSE_HISr_SIZE
typedef BCM53128_A0_FC_PAUSE_HISr_t FC_PAUSE_HISr_t;
#define FC_PAUSE_HISr_CLR BCM53128_A0_FC_PAUSE_HISr_CLR
#define FC_PAUSE_HISr_SET BCM53128_A0_FC_PAUSE_HISr_SET
#define FC_PAUSE_HISr_GET BCM53128_A0_FC_PAUSE_HISr_GET
#define FC_PAUSE_HISr_PAUSE_HISf_GET BCM53128_A0_FC_PAUSE_HISr_PAUSE_HISf_GET
#define FC_PAUSE_HISr_PAUSE_HISf_SET BCM53128_A0_FC_PAUSE_HISr_PAUSE_HISf_SET
#define FC_PAUSE_HISr_RESERVEDf_GET BCM53128_A0_FC_PAUSE_HISr_RESERVEDf_GET
#define FC_PAUSE_HISr_RESERVEDf_SET BCM53128_A0_FC_PAUSE_HISr_RESERVEDf_SET
#define READ_FC_PAUSE_HISr BCM53128_A0_READ_FC_PAUSE_HISr
#define WRITE_FC_PAUSE_HISr BCM53128_A0_WRITE_FC_PAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_PAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_PEAK_RXBYTE
 * BLOCKS:   SYS
 * DESC:     Peak Rx Buffer Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_RXBUFFER_CNT Peak Rx Byte count.The diag_port setting in Diag register (Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_PEAK_RXBYTEr 0x00000a78

#define BCM53128_A0_FC_PEAK_RXBYTEr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_RXBYTE.
 *
 */
typedef union BCM53128_A0_FC_PEAK_RXBYTEr_s {
	uint32_t v[1];
	uint32_t fc_peak_rxbyte[1];
	uint32_t _fc_peak_rxbyte;
} BCM53128_A0_FC_PEAK_RXBYTEr_t;

#define BCM53128_A0_FC_PEAK_RXBYTEr_CLR(r) (r).fc_peak_rxbyte[0] = 0
#define BCM53128_A0_FC_PEAK_RXBYTEr_SET(r,d) (r).fc_peak_rxbyte[0] = d
#define BCM53128_A0_FC_PEAK_RXBYTEr_GET(r) (r).fc_peak_rxbyte[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET(r) (((r).fc_peak_rxbyte[0]) & 0x7ff)
#define BCM53128_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_PEAK_RXBYTEr_RESERVEDf_GET(r) ((((r).fc_peak_rxbyte[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_PEAK_RXBYTEr_RESERVEDf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_RXBYTE.
 *
 */
#define BCM53128_A0_READ_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_PEAK_RXBYTEr,(r._fc_peak_rxbyte),2)
#define BCM53128_A0_WRITE_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_PEAK_RXBYTEr,&(r._fc_peak_rxbyte),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_RXBYTEr BCM53128_A0_FC_PEAK_RXBYTEr
#define FC_PEAK_RXBYTEr_SIZE BCM53128_A0_FC_PEAK_RXBYTEr_SIZE
typedef BCM53128_A0_FC_PEAK_RXBYTEr_t FC_PEAK_RXBYTEr_t;
#define FC_PEAK_RXBYTEr_CLR BCM53128_A0_FC_PEAK_RXBYTEr_CLR
#define FC_PEAK_RXBYTEr_SET BCM53128_A0_FC_PEAK_RXBYTEr_SET
#define FC_PEAK_RXBYTEr_GET BCM53128_A0_FC_PEAK_RXBYTEr_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET BCM53128_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET BCM53128_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET
#define FC_PEAK_RXBYTEr_RESERVEDf_GET BCM53128_A0_FC_PEAK_RXBYTEr_RESERVEDf_GET
#define FC_PEAK_RXBYTEr_RESERVEDf_SET BCM53128_A0_FC_PEAK_RXBYTEr_RESERVEDf_SET
#define READ_FC_PEAK_RXBYTEr BCM53128_A0_READ_FC_PEAK_RXBYTEr
#define WRITE_FC_PEAK_RXBYTEr BCM53128_A0_WRITE_FC_PEAK_RXBYTEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_PEAK_RXBYTEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_PEAK_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Peak Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_USE   Peak Total Used count.This register lock the peak value of total used count.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr 0x00000a80

#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TOTAL_USED.
 *
 */
typedef union BCM53128_A0_FC_PEAK_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_peak_total_used[1];
	uint32_t _fc_peak_total_used;
} BCM53128_A0_FC_PEAK_TOTAL_USEDr_t;

#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_CLR(r) (r).fc_peak_total_used[0] = 0
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_SET(r,d) (r).fc_peak_total_used[0] = d
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_GET(r) (r).fc_peak_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET(r) (((r).fc_peak_total_used[0]) & 0x7ff)
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_GET(r) ((((r).fc_peak_total_used[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_TOTAL_USED.
 *
 */
#define BCM53128_A0_READ_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_PEAK_TOTAL_USEDr,(r._fc_peak_total_used),2)
#define BCM53128_A0_WRITE_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_PEAK_TOTAL_USEDr,&(r._fc_peak_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TOTAL_USEDr BCM53128_A0_FC_PEAK_TOTAL_USEDr
#define FC_PEAK_TOTAL_USEDr_SIZE BCM53128_A0_FC_PEAK_TOTAL_USEDr_SIZE
typedef BCM53128_A0_FC_PEAK_TOTAL_USEDr_t FC_PEAK_TOTAL_USEDr_t;
#define FC_PEAK_TOTAL_USEDr_CLR BCM53128_A0_FC_PEAK_TOTAL_USEDr_CLR
#define FC_PEAK_TOTAL_USEDr_SET BCM53128_A0_FC_PEAK_TOTAL_USEDr_SET
#define FC_PEAK_TOTAL_USEDr_GET BCM53128_A0_FC_PEAK_TOTAL_USEDr_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET BCM53128_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET BCM53128_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET
#define FC_PEAK_TOTAL_USEDr_RESERVEDf_GET BCM53128_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_GET
#define FC_PEAK_TOTAL_USEDr_RESERVEDf_SET BCM53128_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_SET
#define READ_FC_PEAK_TOTAL_USEDr BCM53128_A0_READ_FC_PEAK_TOTAL_USEDr
#define WRITE_FC_PEAK_TOTAL_USEDr BCM53128_A0_WRITE_FC_PEAK_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_PEAK_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_PEAK_TXQ
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (0~3) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 0~3 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_PEAK_TXQr 0x00000a70

#define BCM53128_A0_FC_PEAK_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ.
 *
 */
typedef union BCM53128_A0_FC_PEAK_TXQr_s {
	uint32_t v[1];
	uint32_t fc_peak_txq[1];
	uint32_t _fc_peak_txq;
} BCM53128_A0_FC_PEAK_TXQr_t;

#define BCM53128_A0_FC_PEAK_TXQr_CLR(r) (r).fc_peak_txq[0] = 0
#define BCM53128_A0_FC_PEAK_TXQr_SET(r,d) (r).fc_peak_txq[0] = d
#define BCM53128_A0_FC_PEAK_TXQr_GET(r) (r).fc_peak_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq[0]) & 0x7ff)
#define BCM53128_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_PEAK_TXQr_RESERVEDf_GET(r) ((((r).fc_peak_txq[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_PEAK_TXQr_RESERVEDf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ.
 *
 */
#define BCM53128_A0_READ_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_PEAK_TXQr+(2*(i)),(r._fc_peak_txq),2)
#define BCM53128_A0_WRITE_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_PEAK_TXQr+(2*(i)),&(r._fc_peak_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQr BCM53128_A0_FC_PEAK_TXQr
#define FC_PEAK_TXQr_SIZE BCM53128_A0_FC_PEAK_TXQr_SIZE
typedef BCM53128_A0_FC_PEAK_TXQr_t FC_PEAK_TXQr_t;
#define FC_PEAK_TXQr_CLR BCM53128_A0_FC_PEAK_TXQr_CLR
#define FC_PEAK_TXQr_SET BCM53128_A0_FC_PEAK_TXQr_SET
#define FC_PEAK_TXQr_GET BCM53128_A0_FC_PEAK_TXQr_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_GET BCM53128_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_SET BCM53128_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQr_RESERVEDf_GET BCM53128_A0_FC_PEAK_TXQr_RESERVEDf_GET
#define FC_PEAK_TXQr_RESERVEDf_SET BCM53128_A0_FC_PEAK_TXQr_RESERVEDf_SET
#define READ_FC_PEAK_TXQr BCM53128_A0_READ_FC_PEAK_TXQr
#define WRITE_FC_PEAK_TXQr BCM53128_A0_WRITE_FC_PEAK_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_PEAK_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_PEAK_TXQ_45
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (4~5) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 4~5 count.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_PEAK_TXQ_45r 0x00000a88

#define BCM53128_A0_FC_PEAK_TXQ_45r_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ_45.
 *
 */
typedef union BCM53128_A0_FC_PEAK_TXQ_45r_s {
	uint32_t v[1];
	uint32_t fc_peak_txq_45[1];
	uint32_t _fc_peak_txq_45;
} BCM53128_A0_FC_PEAK_TXQ_45r_t;

#define BCM53128_A0_FC_PEAK_TXQ_45r_CLR(r) (r).fc_peak_txq_45[0] = 0
#define BCM53128_A0_FC_PEAK_TXQ_45r_SET(r,d) (r).fc_peak_txq_45[0] = d
#define BCM53128_A0_FC_PEAK_TXQ_45r_GET(r) (r).fc_peak_txq_45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq_45[0]) & 0x7ff)
#define BCM53128_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_PEAK_TXQ_45r_RESERVEDf_GET(r) ((((r).fc_peak_txq_45[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_PEAK_TXQ_45r_RESERVEDf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ_45.
 *
 */
#define BCM53128_A0_READ_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_PEAK_TXQ_45r+(2*(i)),(r._fc_peak_txq_45),2)
#define BCM53128_A0_WRITE_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_PEAK_TXQ_45r+(2*(i)),&(r._fc_peak_txq_45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQ_45r BCM53128_A0_FC_PEAK_TXQ_45r
#define FC_PEAK_TXQ_45r_SIZE BCM53128_A0_FC_PEAK_TXQ_45r_SIZE
typedef BCM53128_A0_FC_PEAK_TXQ_45r_t FC_PEAK_TXQ_45r_t;
#define FC_PEAK_TXQ_45r_CLR BCM53128_A0_FC_PEAK_TXQ_45r_CLR
#define FC_PEAK_TXQ_45r_SET BCM53128_A0_FC_PEAK_TXQ_45r_SET
#define FC_PEAK_TXQ_45r_GET BCM53128_A0_FC_PEAK_TXQ_45r_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET BCM53128_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET BCM53128_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQ_45r_RESERVEDf_GET BCM53128_A0_FC_PEAK_TXQ_45r_RESERVEDf_GET
#define FC_PEAK_TXQ_45r_RESERVEDf_SET BCM53128_A0_FC_PEAK_TXQ_45r_RESERVEDf_SET
#define READ_FC_PEAK_TXQ_45r BCM53128_A0_READ_FC_PEAK_TXQ_45r
#define WRITE_FC_PEAK_TXQ_45r BCM53128_A0_WRITE_FC_PEAK_TXQ_45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_PEAK_TXQ_45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_0123
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 0,1,2,3 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP01   Port 1 congest status for Queue 4/5bit[7:6] = congest status for Q5bit[5:4] = congest status for Q4Port 1 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     CONG_PORTMAP23   Port 3 congest status for Queue 4/5bit[15:14] = congest status for Q5bit[13:12] = congest status for Q4Port 2 congest status for Queue 4/5bit[11:10] = congest status for Q5bit[9:8] = congest status for Q4
 *
 ******************************************************************************/
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r 0x00000ad0

#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_0123.
 *
 */
typedef union BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_0123[1];
	uint32_t _fc_q45_cong_portmap_0123;
} BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_t;

#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CLR(r) (r).fc_q45_cong_portmap_0123[0] = 0
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_SET(r,d) (r).fc_q45_cong_portmap_0123[0] = d
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_GET(r) (r).fc_q45_cong_portmap_0123[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET(r) (((r).fc_q45_cong_portmap_0123[0]) & 0xff)
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET(r) ((((r).fc_q45_cong_portmap_0123[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_0123.
 *
 */
#define BCM53128_A0_READ_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r,(r._fc_q45_cong_portmap_0123),2)
#define BCM53128_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r,&(r._fc_q45_cong_portmap_0123),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_0123r BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r
#define FC_Q45_CONG_PORTMAP_0123r_SIZE BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE
typedef BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_t FC_Q45_CONG_PORTMAP_0123r_t;
#define FC_Q45_CONG_PORTMAP_0123r_CLR BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CLR
#define FC_Q45_CONG_PORTMAP_0123r_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_SET
#define FC_Q45_CONG_PORTMAP_0123r_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET
#define READ_FC_Q45_CONG_PORTMAP_0123r BCM53128_A0_READ_FC_Q45_CONG_PORTMAP_0123r
#define WRITE_FC_Q45_CONG_PORTMAP_0123r BCM53128_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_Q45_CONG_PORTMAP_0123r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_4567
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 4,5,6,7 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP45   Port 5 congest status for Queue 4/5bit[7:6] = congest status for Q5bit[5:4] = congest status for Q4Port 4 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     CONG_PORTMAP67   Port 7 congest status for Queue 4/5bit[15:14] = congest status for Q5bit[13:12] = congest status for Q4Port 6 congest status for Queue 4/5bit[11:10] = congest status for Q5bit[9:8] = congest status for Q4
 *
 ******************************************************************************/
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r 0x00000ad2

#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_4567.
 *
 */
typedef union BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_4567[1];
	uint32_t _fc_q45_cong_portmap_4567;
} BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_t;

#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CLR(r) (r).fc_q45_cong_portmap_4567[0] = 0
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_SET(r,d) (r).fc_q45_cong_portmap_4567[0] = d
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_GET(r) (r).fc_q45_cong_portmap_4567[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET(r) (((r).fc_q45_cong_portmap_4567[0]) & 0xff)
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET(r) ((((r).fc_q45_cong_portmap_4567[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_4567.
 *
 */
#define BCM53128_A0_READ_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r,(r._fc_q45_cong_portmap_4567),2)
#define BCM53128_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r,&(r._fc_q45_cong_portmap_4567),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_4567r BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r
#define FC_Q45_CONG_PORTMAP_4567r_SIZE BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE
typedef BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_t FC_Q45_CONG_PORTMAP_4567r_t;
#define FC_Q45_CONG_PORTMAP_4567r_CLR BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CLR
#define FC_Q45_CONG_PORTMAP_4567r_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_SET
#define FC_Q45_CONG_PORTMAP_4567r_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET
#define READ_FC_Q45_CONG_PORTMAP_4567r BCM53128_A0_READ_FC_Q45_CONG_PORTMAP_4567r
#define WRITE_FC_Q45_CONG_PORTMAP_4567r BCM53128_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_Q45_CONG_PORTMAP_4567r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_8
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    Port 8 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r 0x00000ad4

#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_8.
 *
 */
typedef union BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_8[1];
	uint32_t _fc_q45_cong_portmap_8;
} BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_t;

#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_CLR(r) (r).fc_q45_cong_portmap_8[0] = 0
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_SET(r,d) (r).fc_q45_cong_portmap_8[0] = d
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_GET(r) (r).fc_q45_cong_portmap_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET(r) (((r).fc_q45_cong_portmap_8[0]) & 0xf)
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET(r) ((((r).fc_q45_cong_portmap_8[0]) >> 4) & 0xfff)
#define BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_8.
 *
 */
#define BCM53128_A0_READ_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_Q45_CONG_PORTMAP_8r,(r._fc_q45_cong_portmap_8),2)
#define BCM53128_A0_WRITE_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_Q45_CONG_PORTMAP_8r,&(r._fc_q45_cong_portmap_8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_8r BCM53128_A0_FC_Q45_CONG_PORTMAP_8r
#define FC_Q45_CONG_PORTMAP_8r_SIZE BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_SIZE
typedef BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_t FC_Q45_CONG_PORTMAP_8r_t;
#define FC_Q45_CONG_PORTMAP_8r_CLR BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_CLR
#define FC_Q45_CONG_PORTMAP_8r_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_SET
#define FC_Q45_CONG_PORTMAP_8r_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET
#define FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET
#define FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET BCM53128_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET
#define READ_FC_Q45_CONG_PORTMAP_8r BCM53128_A0_READ_FC_Q45_CONG_PORTMAP_8r
#define WRITE_FC_Q45_CONG_PORTMAP_8r BCM53128_A0_WRITE_FC_Q45_CONG_PORTMAP_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_Q45_CONG_PORTMAP_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_RXBUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Rx Buffer Error History Register
 * SIZE:     16
 * FIELDS:
 *     RXBUF_ERR_HIS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_RXBUF_ERR_HISr 0x00000aa8

#define BCM53128_A0_FC_RXBUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXBUF_ERR_HIS.
 *
 */
typedef union BCM53128_A0_FC_RXBUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxbuf_err_his[1];
	uint32_t _fc_rxbuf_err_his;
} BCM53128_A0_FC_RXBUF_ERR_HISr_t;

#define BCM53128_A0_FC_RXBUF_ERR_HISr_CLR(r) (r).fc_rxbuf_err_his[0] = 0
#define BCM53128_A0_FC_RXBUF_ERR_HISr_SET(r,d) (r).fc_rxbuf_err_his[0] = d
#define BCM53128_A0_FC_RXBUF_ERR_HISr_GET(r) (r).fc_rxbuf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET(r) (((r).fc_rxbuf_err_his[0]) & 0x7ff)
#define BCM53128_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_RXBUF_ERR_HISr_RESERVEDf_GET(r) ((((r).fc_rxbuf_err_his[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_RXBUF_ERR_HISr_RESERVEDf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXBUF_ERR_HIS.
 *
 */
#define BCM53128_A0_READ_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_RXBUF_ERR_HISr,(r._fc_rxbuf_err_his),2)
#define BCM53128_A0_WRITE_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_RXBUF_ERR_HISr,&(r._fc_rxbuf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXBUF_ERR_HISr BCM53128_A0_FC_RXBUF_ERR_HISr
#define FC_RXBUF_ERR_HISr_SIZE BCM53128_A0_FC_RXBUF_ERR_HISr_SIZE
typedef BCM53128_A0_FC_RXBUF_ERR_HISr_t FC_RXBUF_ERR_HISr_t;
#define FC_RXBUF_ERR_HISr_CLR BCM53128_A0_FC_RXBUF_ERR_HISr_CLR
#define FC_RXBUF_ERR_HISr_SET BCM53128_A0_FC_RXBUF_ERR_HISr_SET
#define FC_RXBUF_ERR_HISr_GET BCM53128_A0_FC_RXBUF_ERR_HISr_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET BCM53128_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET BCM53128_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET
#define FC_RXBUF_ERR_HISr_RESERVEDf_GET BCM53128_A0_FC_RXBUF_ERR_HISr_RESERVEDf_GET
#define FC_RXBUF_ERR_HISr_RESERVEDf_SET BCM53128_A0_FC_RXBUF_ERR_HISr_RESERVEDf_SET
#define READ_FC_RXBUF_ERR_HISr BCM53128_A0_READ_FC_RXBUF_ERR_HISr
#define WRITE_FC_RXBUF_ERR_HISr BCM53128_A0_WRITE_FC_RXBUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_RXBUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_RX_HYST
 * BLOCKS:   SYS
 * DESC:     Rx-Base Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     RX_HYST_THRS     
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_RX_HYSTr 0x00000a54

#define BCM53128_A0_FC_RX_HYSTr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_HYST.
 *
 */
typedef union BCM53128_A0_FC_RX_HYSTr_s {
	uint32_t v[1];
	uint32_t fc_rx_hyst[1];
	uint32_t _fc_rx_hyst;
} BCM53128_A0_FC_RX_HYSTr_t;

#define BCM53128_A0_FC_RX_HYSTr_CLR(r) (r).fc_rx_hyst[0] = 0
#define BCM53128_A0_FC_RX_HYSTr_SET(r,d) (r).fc_rx_hyst[0] = d
#define BCM53128_A0_FC_RX_HYSTr_GET(r) (r).fc_rx_hyst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET(r) (((r).fc_rx_hyst[0]) & 0xff)
#define BCM53128_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_RX_HYSTr_RESERVEDf_GET(r) ((((r).fc_rx_hyst[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_RX_HYSTr_RESERVEDf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_HYST.
 *
 */
#define BCM53128_A0_READ_FC_RX_HYSTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_RX_HYSTr,(r._fc_rx_hyst),2)
#define BCM53128_A0_WRITE_FC_RX_HYSTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_RX_HYSTr,&(r._fc_rx_hyst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_HYSTr BCM53128_A0_FC_RX_HYSTr
#define FC_RX_HYSTr_SIZE BCM53128_A0_FC_RX_HYSTr_SIZE
typedef BCM53128_A0_FC_RX_HYSTr_t FC_RX_HYSTr_t;
#define FC_RX_HYSTr_CLR BCM53128_A0_FC_RX_HYSTr_CLR
#define FC_RX_HYSTr_SET BCM53128_A0_FC_RX_HYSTr_SET
#define FC_RX_HYSTr_GET BCM53128_A0_FC_RX_HYSTr_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_GET BCM53128_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_SET BCM53128_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET
#define FC_RX_HYSTr_RESERVEDf_GET BCM53128_A0_FC_RX_HYSTr_RESERVEDf_GET
#define FC_RX_HYSTr_RESERVEDf_SET BCM53128_A0_FC_RX_HYSTr_RESERVEDf_SET
#define READ_FC_RX_HYSTr BCM53128_A0_READ_FC_RX_HYSTr
#define WRITE_FC_RX_HYSTr BCM53128_A0_WRITE_FC_RX_HYSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_RX_HYSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_RX_MAX_PTR
 * BLOCKS:   SYS
 * DESC:     Rx-Base Max-Buffer Remap Register
 * SIZE:     16
 * FIELDS:
 *     MAXBUF_REMAP     Max_Buffer_ReMap Value.
 *     RESERVED         Reserved.
 *     EN_REMAP         Enable remap.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_RX_MAX_PTRr 0x00000a56

#define BCM53128_A0_FC_RX_MAX_PTRr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_MAX_PTR.
 *
 */
typedef union BCM53128_A0_FC_RX_MAX_PTRr_s {
	uint32_t v[1];
	uint32_t fc_rx_max_ptr[1];
	uint32_t _fc_rx_max_ptr;
} BCM53128_A0_FC_RX_MAX_PTRr_t;

#define BCM53128_A0_FC_RX_MAX_PTRr_CLR(r) (r).fc_rx_max_ptr[0] = 0
#define BCM53128_A0_FC_RX_MAX_PTRr_SET(r,d) (r).fc_rx_max_ptr[0] = d
#define BCM53128_A0_FC_RX_MAX_PTRr_GET(r) (r).fc_rx_max_ptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET(r) (((r).fc_rx_max_ptr[0]) & 0x7ff)
#define BCM53128_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_RX_MAX_PTRr_RESERVEDf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 11) & 0xf)
#define BCM53128_A0_FC_RX_MAX_PTRr_RESERVEDf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53128_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 15) & 0x1)
#define BCM53128_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FC_RX_MAX_PTR.
 *
 */
#define BCM53128_A0_READ_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_RX_MAX_PTRr,(r._fc_rx_max_ptr),2)
#define BCM53128_A0_WRITE_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_RX_MAX_PTRr,&(r._fc_rx_max_ptr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_MAX_PTRr BCM53128_A0_FC_RX_MAX_PTRr
#define FC_RX_MAX_PTRr_SIZE BCM53128_A0_FC_RX_MAX_PTRr_SIZE
typedef BCM53128_A0_FC_RX_MAX_PTRr_t FC_RX_MAX_PTRr_t;
#define FC_RX_MAX_PTRr_CLR BCM53128_A0_FC_RX_MAX_PTRr_CLR
#define FC_RX_MAX_PTRr_SET BCM53128_A0_FC_RX_MAX_PTRr_SET
#define FC_RX_MAX_PTRr_GET BCM53128_A0_FC_RX_MAX_PTRr_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET BCM53128_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET BCM53128_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET
#define FC_RX_MAX_PTRr_RESERVEDf_GET BCM53128_A0_FC_RX_MAX_PTRr_RESERVEDf_GET
#define FC_RX_MAX_PTRr_RESERVEDf_SET BCM53128_A0_FC_RX_MAX_PTRr_RESERVEDf_SET
#define FC_RX_MAX_PTRr_EN_REMAPf_GET BCM53128_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET
#define FC_RX_MAX_PTRr_EN_REMAPf_SET BCM53128_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET
#define READ_FC_RX_MAX_PTRr BCM53128_A0_READ_FC_RX_MAX_PTRr
#define WRITE_FC_RX_MAX_PTRr BCM53128_A0_WRITE_FC_RX_MAX_PTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_RX_MAX_PTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_RX_RSRV
 * BLOCKS:   SYS
 * DESC:     Rx-Base Reserved Register
 * SIZE:     16
 * FIELDS:
 *     RESV_CTRL        
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_RX_RSRVr 0x00000a52

#define BCM53128_A0_FC_RX_RSRVr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RSRV.
 *
 */
typedef union BCM53128_A0_FC_RX_RSRVr_s {
	uint32_t v[1];
	uint32_t fc_rx_rsrv[1];
	uint32_t _fc_rx_rsrv;
} BCM53128_A0_FC_RX_RSRVr_t;

#define BCM53128_A0_FC_RX_RSRVr_CLR(r) (r).fc_rx_rsrv[0] = 0
#define BCM53128_A0_FC_RX_RSRVr_SET(r,d) (r).fc_rx_rsrv[0] = d
#define BCM53128_A0_FC_RX_RSRVr_GET(r) (r).fc_rx_rsrv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_RX_RSRVr_RESV_CTRLf_GET(r) (((r).fc_rx_rsrv[0]) & 0xff)
#define BCM53128_A0_FC_RX_RSRVr_RESV_CTRLf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_RX_RSRVr_RESERVEDf_GET(r) ((((r).fc_rx_rsrv[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_RX_RSRVr_RESERVEDf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RSRV.
 *
 */
#define BCM53128_A0_READ_FC_RX_RSRVr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_RX_RSRVr,(r._fc_rx_rsrv),2)
#define BCM53128_A0_WRITE_FC_RX_RSRVr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_RX_RSRVr,&(r._fc_rx_rsrv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RSRVr BCM53128_A0_FC_RX_RSRVr
#define FC_RX_RSRVr_SIZE BCM53128_A0_FC_RX_RSRVr_SIZE
typedef BCM53128_A0_FC_RX_RSRVr_t FC_RX_RSRVr_t;
#define FC_RX_RSRVr_CLR BCM53128_A0_FC_RX_RSRVr_CLR
#define FC_RX_RSRVr_SET BCM53128_A0_FC_RX_RSRVr_SET
#define FC_RX_RSRVr_GET BCM53128_A0_FC_RX_RSRVr_GET
#define FC_RX_RSRVr_RESV_CTRLf_GET BCM53128_A0_FC_RX_RSRVr_RESV_CTRLf_GET
#define FC_RX_RSRVr_RESV_CTRLf_SET BCM53128_A0_FC_RX_RSRVr_RESV_CTRLf_SET
#define FC_RX_RSRVr_RESERVEDf_GET BCM53128_A0_FC_RX_RSRVr_RESERVEDf_GET
#define FC_RX_RSRVr_RESERVEDf_SET BCM53128_A0_FC_RX_RSRVr_RESERVEDf_SET
#define READ_FC_RX_RSRVr BCM53128_A0_READ_FC_RX_RSRVr
#define WRITE_FC_RX_RSRVr BCM53128_A0_WRITE_FC_RX_RSRVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_RX_RSRVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_RX_RUNOFF
 * BLOCKS:   SYS
 * DESC:     Rx-Base Run-Off Register
 * SIZE:     16
 * FIELDS:
 *     RUN_OFF          
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_RX_RUNOFFr 0x00000a50

#define BCM53128_A0_FC_RX_RUNOFFr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RUNOFF.
 *
 */
typedef union BCM53128_A0_FC_RX_RUNOFFr_s {
	uint32_t v[1];
	uint32_t fc_rx_runoff[1];
	uint32_t _fc_rx_runoff;
} BCM53128_A0_FC_RX_RUNOFFr_t;

#define BCM53128_A0_FC_RX_RUNOFFr_CLR(r) (r).fc_rx_runoff[0] = 0
#define BCM53128_A0_FC_RX_RUNOFFr_SET(r,d) (r).fc_rx_runoff[0] = d
#define BCM53128_A0_FC_RX_RUNOFFr_GET(r) (r).fc_rx_runoff[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_RX_RUNOFFr_RUN_OFFf_GET(r) (((r).fc_rx_runoff[0]) & 0xff)
#define BCM53128_A0_FC_RX_RUNOFFr_RUN_OFFf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_FC_RX_RUNOFFr_RESERVEDf_GET(r) ((((r).fc_rx_runoff[0]) >> 8) & 0xff)
#define BCM53128_A0_FC_RX_RUNOFFr_RESERVEDf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RUNOFF.
 *
 */
#define BCM53128_A0_READ_FC_RX_RUNOFFr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_RX_RUNOFFr,(r._fc_rx_runoff),2)
#define BCM53128_A0_WRITE_FC_RX_RUNOFFr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_RX_RUNOFFr,&(r._fc_rx_runoff),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RUNOFFr BCM53128_A0_FC_RX_RUNOFFr
#define FC_RX_RUNOFFr_SIZE BCM53128_A0_FC_RX_RUNOFFr_SIZE
typedef BCM53128_A0_FC_RX_RUNOFFr_t FC_RX_RUNOFFr_t;
#define FC_RX_RUNOFFr_CLR BCM53128_A0_FC_RX_RUNOFFr_CLR
#define FC_RX_RUNOFFr_SET BCM53128_A0_FC_RX_RUNOFFr_SET
#define FC_RX_RUNOFFr_GET BCM53128_A0_FC_RX_RUNOFFr_GET
#define FC_RX_RUNOFFr_RUN_OFFf_GET BCM53128_A0_FC_RX_RUNOFFr_RUN_OFFf_GET
#define FC_RX_RUNOFFr_RUN_OFFf_SET BCM53128_A0_FC_RX_RUNOFFr_RUN_OFFf_SET
#define FC_RX_RUNOFFr_RESERVEDf_GET BCM53128_A0_FC_RX_RUNOFFr_RESERVEDf_GET
#define FC_RX_RUNOFFr_RESERVEDf_SET BCM53128_A0_FC_RX_RUNOFFr_RESERVEDf_SET
#define READ_FC_RX_RUNOFFr BCM53128_A0_READ_FC_RX_RUNOFFr
#define WRITE_FC_RX_RUNOFFr BCM53128_A0_WRITE_FC_RX_RUNOFFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_RX_RUNOFFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_SPARE_REG
 * BLOCKS:   SYS
 * DESC:     Spare Registers
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_SPARE_REGr 0x00000a58

#define BCM53128_A0_FC_SPARE_REGr_SIZE 2

/*
 * This structure should be used to declare and program FC_SPARE_REG.
 *
 */
typedef union BCM53128_A0_FC_SPARE_REGr_s {
	uint32_t v[1];
	uint32_t fc_spare_reg[1];
	uint32_t _fc_spare_reg;
} BCM53128_A0_FC_SPARE_REGr_t;

#define BCM53128_A0_FC_SPARE_REGr_CLR(r) (r).fc_spare_reg[0] = 0
#define BCM53128_A0_FC_SPARE_REGr_SET(r,d) (r).fc_spare_reg[0] = d
#define BCM53128_A0_FC_SPARE_REGr_GET(r) (r).fc_spare_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_SPARE_REGr_RESERVEDf_GET(r) (((r).fc_spare_reg[0]) & 0xffff)
#define BCM53128_A0_FC_SPARE_REGr_RESERVEDf_SET(r,f) (r).fc_spare_reg[0]=(((r).fc_spare_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FC_SPARE_REG.
 *
 */
#define BCM53128_A0_READ_FC_SPARE_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_SPARE_REGr,(r._fc_spare_reg),2)
#define BCM53128_A0_WRITE_FC_SPARE_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_SPARE_REGr,&(r._fc_spare_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_SPARE_REGr BCM53128_A0_FC_SPARE_REGr
#define FC_SPARE_REGr_SIZE BCM53128_A0_FC_SPARE_REGr_SIZE
typedef BCM53128_A0_FC_SPARE_REGr_t FC_SPARE_REGr_t;
#define FC_SPARE_REGr_CLR BCM53128_A0_FC_SPARE_REGr_CLR
#define FC_SPARE_REGr_SET BCM53128_A0_FC_SPARE_REGr_SET
#define FC_SPARE_REGr_GET BCM53128_A0_FC_SPARE_REGr_GET
#define FC_SPARE_REGr_RESERVEDf_GET BCM53128_A0_FC_SPARE_REGr_RESERVEDf_GET
#define FC_SPARE_REGr_RESERVEDf_SET BCM53128_A0_FC_SPARE_REGr_RESERVEDf_SET
#define READ_FC_SPARE_REGr BCM53128_A0_READ_FC_SPARE_REGr
#define WRITE_FC_SPARE_REGr BCM53128_A0_WRITE_FC_SPARE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_SPARE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr 0x00000a38

#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q[1];
	uint32_t _fc_total_th_drop_q;
} BCM53128_A0_FC_TOTAL_TH_DROP_Qr_t;

#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_CLR(r) (r).fc_total_th_drop_q[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_SET(r,d) (r).fc_total_th_drop_q[0] = d
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_GET(r) (r).fc_total_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q[0]) & 0x7ff)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),(r._fc_total_th_drop_q),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),&(r._fc_total_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Qr BCM53128_A0_FC_TOTAL_TH_DROP_Qr
#define FC_TOTAL_TH_DROP_Qr_SIZE BCM53128_A0_FC_TOTAL_TH_DROP_Qr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_DROP_Qr_t FC_TOTAL_TH_DROP_Qr_t;
#define FC_TOTAL_TH_DROP_Qr_CLR BCM53128_A0_FC_TOTAL_TH_DROP_Qr_CLR
#define FC_TOTAL_TH_DROP_Qr_SET BCM53128_A0_FC_TOTAL_TH_DROP_Qr_SET
#define FC_TOTAL_TH_DROP_Qr_GET BCM53128_A0_FC_TOTAL_TH_DROP_Qr_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Qr BCM53128_A0_READ_FC_TOTAL_TH_DROP_Qr
#define WRITE_FC_TOTAL_TH_DROP_Qr BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r 0x00000ac4

#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q45.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q45[1];
	uint32_t _fc_total_th_drop_q45;
} BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_t;

#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_CLR(r) (r).fc_total_th_drop_q45[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_SET(r,d) (r).fc_total_th_drop_q45[0] = d
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_GET(r) (r).fc_total_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q45[0]) & 0x7ff)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q45[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q45.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),(r._fc_total_th_drop_q45),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),&(r._fc_total_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q45r BCM53128_A0_FC_TOTAL_TH_DROP_Q45r
#define FC_TOTAL_TH_DROP_Q45r_SIZE BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_t FC_TOTAL_TH_DROP_Q45r_t;
#define FC_TOTAL_TH_DROP_Q45r_CLR BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_CLR
#define FC_TOTAL_TH_DROP_Q45r_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_SET
#define FC_TOTAL_TH_DROP_Q45r_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q45r BCM53128_A0_READ_FC_TOTAL_TH_DROP_Q45r
#define WRITE_FC_TOTAL_TH_DROP_Q45r BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr 0x00000d38

#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_imp[1];
	uint32_t _fc_total_th_drop_q_imp;
} BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_t;

#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR(r) (r).fc_total_th_drop_q_imp[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET(r,d) (r).fc_total_th_drop_q_imp[0] = d
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET(r) (r).fc_total_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_imp[0]) & 0x7ff)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q_imp[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),(r._fc_total_th_drop_q_imp),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_total_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_IMPr BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr
#define FC_TOTAL_TH_DROP_Q_IMPr_SIZE BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_t FC_TOTAL_TH_DROP_Q_IMPr_t;
#define FC_TOTAL_TH_DROP_Q_IMPr_CLR BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR
#define FC_TOTAL_TH_DROP_Q_IMPr_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q_IMPr BCM53128_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr
#define WRITE_FC_TOTAL_TH_DROP_Q_IMPr BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for IMP1
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr 0x00000e38

#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_wan[1];
	uint32_t _fc_total_th_drop_q_wan;
} BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_t;

#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR(r) (r).fc_total_th_drop_q_wan[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_SET(r,d) (r).fc_total_th_drop_q_wan[0] = d
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_GET(r) (r).fc_total_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_wan[0]) & 0x7ff)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q_wan[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),(r._fc_total_th_drop_q_wan),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),&(r._fc_total_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_WANr BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr
#define FC_TOTAL_TH_DROP_Q_WANr_SIZE BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_t FC_TOTAL_TH_DROP_Q_WANr_t;
#define FC_TOTAL_TH_DROP_Q_WANr_CLR BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR
#define FC_TOTAL_TH_DROP_Q_WANr_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_SET
#define FC_TOTAL_TH_DROP_Q_WANr_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q_WANr BCM53128_A0_READ_FC_TOTAL_TH_DROP_Q_WANr
#define WRITE_FC_TOTAL_TH_DROP_Q_WANr BCM53128_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr 0x00000a28

#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_HYST_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q[1];
	uint32_t _fc_total_th_hyst_q;
} BCM53128_A0_FC_TOTAL_TH_HYST_Qr_t;

#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_CLR(r) (r).fc_total_th_hyst_q[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_SET(r,d) (r).fc_total_th_hyst_q[0] = d
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_GET(r) (r).fc_total_th_hyst_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),(r._fc_total_th_hyst_q),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),&(r._fc_total_th_hyst_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Qr BCM53128_A0_FC_TOTAL_TH_HYST_Qr
#define FC_TOTAL_TH_HYST_Qr_SIZE BCM53128_A0_FC_TOTAL_TH_HYST_Qr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_HYST_Qr_t FC_TOTAL_TH_HYST_Qr_t;
#define FC_TOTAL_TH_HYST_Qr_CLR BCM53128_A0_FC_TOTAL_TH_HYST_Qr_CLR
#define FC_TOTAL_TH_HYST_Qr_SET BCM53128_A0_FC_TOTAL_TH_HYST_Qr_SET
#define FC_TOTAL_TH_HYST_Qr_GET BCM53128_A0_FC_TOTAL_TH_HYST_Qr_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Qr BCM53128_A0_READ_FC_TOTAL_TH_HYST_Qr
#define WRITE_FC_TOTAL_TH_HYST_Qr BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_HYST_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q45
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r 0x00000abc

#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q45.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q45[1];
	uint32_t _fc_total_th_hyst_q45;
} BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_t;

#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_CLR(r) (r).fc_total_th_hyst_q45[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_SET(r,d) (r).fc_total_th_hyst_q45[0] = d
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_GET(r) (r).fc_total_th_hyst_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q45[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q45[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q45.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),(r._fc_total_th_hyst_q45),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),&(r._fc_total_th_hyst_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q45r BCM53128_A0_FC_TOTAL_TH_HYST_Q45r
#define FC_TOTAL_TH_HYST_Q45r_SIZE BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_t FC_TOTAL_TH_HYST_Q45r_t;
#define FC_TOTAL_TH_HYST_Q45r_CLR BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_CLR
#define FC_TOTAL_TH_HYST_Q45r_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_SET
#define FC_TOTAL_TH_HYST_Q45r_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q45r BCM53128_A0_READ_FC_TOTAL_TH_HYST_Q45r
#define WRITE_FC_TOTAL_TH_HYST_Q45r BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_HYST_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr 0x00000d28

#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_imp[1];
	uint32_t _fc_total_th_hyst_q_imp;
} BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_t;

#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR(r) (r).fc_total_th_hyst_q_imp[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET(r,d) (r).fc_total_th_hyst_q_imp[0] = d
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET(r) (r).fc_total_th_hyst_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_imp[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q_imp[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),(r._fc_total_th_hyst_q_imp),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),&(r._fc_total_th_hyst_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_IMPr BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr
#define FC_TOTAL_TH_HYST_Q_IMPr_SIZE BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_t FC_TOTAL_TH_HYST_Q_IMPr_t;
#define FC_TOTAL_TH_HYST_Q_IMPr_CLR BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR
#define FC_TOTAL_TH_HYST_Q_IMPr_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q_IMPr BCM53128_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr
#define WRITE_FC_TOTAL_TH_HYST_Q_IMPr BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_HYST_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for IMP1
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr 0x00000e28

#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_wan[1];
	uint32_t _fc_total_th_hyst_q_wan;
} BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_t;

#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR(r) (r).fc_total_th_hyst_q_wan[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_SET(r,d) (r).fc_total_th_hyst_q_wan[0] = d
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_GET(r) (r).fc_total_th_hyst_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_wan[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q_wan[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),(r._fc_total_th_hyst_q_wan),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),&(r._fc_total_th_hyst_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_WANr BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr
#define FC_TOTAL_TH_HYST_Q_WANr_SIZE BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_t FC_TOTAL_TH_HYST_Q_WANr_t;
#define FC_TOTAL_TH_HYST_Q_WANr_CLR BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR
#define FC_TOTAL_TH_HYST_Q_WANr_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_SET
#define FC_TOTAL_TH_HYST_Q_WANr_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q_WANr BCM53128_A0_READ_FC_TOTAL_TH_HYST_Q_WANr
#define WRITE_FC_TOTAL_TH_HYST_Q_WANr BCM53128_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_HYST_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr 0x00000a30

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q[1];
	uint32_t _fc_total_th_pause_q;
} BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_t;

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_CLR(r) (r).fc_total_th_pause_q[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_SET(r,d) (r).fc_total_th_pause_q[0] = d
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_GET(r) (r).fc_total_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),(r._fc_total_th_pause_q),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),&(r._fc_total_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Qr BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr
#define FC_TOTAL_TH_PAUSE_Qr_SIZE BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_t FC_TOTAL_TH_PAUSE_Qr_t;
#define FC_TOTAL_TH_PAUSE_Qr_CLR BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_CLR
#define FC_TOTAL_TH_PAUSE_Qr_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_SET
#define FC_TOTAL_TH_PAUSE_Qr_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Qr BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Qr
#define WRITE_FC_TOTAL_TH_PAUSE_Qr BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r 0x00000ac0

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q45.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q45[1];
	uint32_t _fc_total_th_pause_q45;
} BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_t;

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR(r) (r).fc_total_th_pause_q45[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_SET(r,d) (r).fc_total_th_pause_q45[0] = d
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_GET(r) (r).fc_total_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q45[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q45.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),(r._fc_total_th_pause_q45),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),&(r._fc_total_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q45r BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r
#define FC_TOTAL_TH_PAUSE_Q45r_SIZE BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_t FC_TOTAL_TH_PAUSE_Q45r_t;
#define FC_TOTAL_TH_PAUSE_Q45r_CLR BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR
#define FC_TOTAL_TH_PAUSE_Q45r_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_SET
#define FC_TOTAL_TH_PAUSE_Q45r_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q45r BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Q45r
#define WRITE_FC_TOTAL_TH_PAUSE_Q45r BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr 0x00000d30

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_imp[1];
	uint32_t _fc_total_th_pause_q_imp;
} BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t;

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_total_th_pause_q_imp[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_total_th_pause_q_imp[0] = d
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET(r) (r).fc_total_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_imp[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_total_th_pause_q_imp),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_total_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_IMPr BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t FC_TOTAL_TH_PAUSE_Q_IMPr_t;
#define FC_TOTAL_TH_PAUSE_Q_IMPr_CLR BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_IMPr BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for IMP1
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr 0x00000e30

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_wan[1];
	uint32_t _fc_total_th_pause_q_wan;
} BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t;

#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR(r) (r).fc_total_th_pause_q_wan[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_total_th_pause_q_wan[0] = d
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET(r) (r).fc_total_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_wan[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_total_th_pause_q_wan),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_total_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_WANr BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr
#define FC_TOTAL_TH_PAUSE_Q_WANr_SIZE BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t FC_TOTAL_TH_PAUSE_Q_WANr_t;
#define FC_TOTAL_TH_PAUSE_Q_WANr_CLR BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR
#define FC_TOTAL_TH_PAUSE_Q_WANr_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_WANr BCM53128_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_WANr BCM53128_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Total Reserved Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_RSRV_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr 0x00000a40

#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_RSRV_Q.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_rsrv_q[1];
	uint32_t _fc_total_th_rsrv_q;
} BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_t;

#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_CLR(r) (r).fc_total_th_rsrv_q[0] = 0
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_SET(r,d) (r).fc_total_th_rsrv_q[0] = d
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_GET(r) (r).fc_total_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET(r) (((r).fc_total_th_rsrv_q[0]) & 0x3ff)
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_RSRV_Q.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),(r._fc_total_th_rsrv_q),2)
#define BCM53128_A0_WRITE_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),&(r._fc_total_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_RSRV_Qr BCM53128_A0_FC_TOTAL_TH_RSRV_Qr
#define FC_TOTAL_TH_RSRV_Qr_SIZE BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_SIZE
typedef BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_t FC_TOTAL_TH_RSRV_Qr_t;
#define FC_TOTAL_TH_RSRV_Qr_CLR BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_CLR
#define FC_TOTAL_TH_RSRV_Qr_SET BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_SET
#define FC_TOTAL_TH_RSRV_Qr_GET BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET
#define FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_RSRV_Qr BCM53128_A0_READ_FC_TOTAL_TH_RSRV_Qr
#define WRITE_FC_TOTAL_TH_RSRV_Qr BCM53128_A0_WRITE_FC_TOTAL_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_USE        Total Used count.This register records the current total used count.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TOTAL_USEDr 0x00000a82

#define BCM53128_A0_FC_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_USED.
 *
 */
typedef union BCM53128_A0_FC_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_total_used[1];
	uint32_t _fc_total_used;
} BCM53128_A0_FC_TOTAL_USEDr_t;

#define BCM53128_A0_FC_TOTAL_USEDr_CLR(r) (r).fc_total_used[0] = 0
#define BCM53128_A0_FC_TOTAL_USEDr_SET(r,d) (r).fc_total_used[0] = d
#define BCM53128_A0_FC_TOTAL_USEDr_GET(r) (r).fc_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET(r) (((r).fc_total_used[0]) & 0x7ff)
#define BCM53128_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_TOTAL_USEDr_RESERVEDf_GET(r) ((((r).fc_total_used[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_TOTAL_USEDr_RESERVEDf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_USED.
 *
 */
#define BCM53128_A0_READ_FC_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TOTAL_USEDr,(r._fc_total_used),2)
#define BCM53128_A0_WRITE_FC_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TOTAL_USEDr,&(r._fc_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_USEDr BCM53128_A0_FC_TOTAL_USEDr
#define FC_TOTAL_USEDr_SIZE BCM53128_A0_FC_TOTAL_USEDr_SIZE
typedef BCM53128_A0_FC_TOTAL_USEDr_t FC_TOTAL_USEDr_t;
#define FC_TOTAL_USEDr_CLR BCM53128_A0_FC_TOTAL_USEDr_CLR
#define FC_TOTAL_USEDr_SET BCM53128_A0_FC_TOTAL_USEDr_SET
#define FC_TOTAL_USEDr_GET BCM53128_A0_FC_TOTAL_USEDr_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_GET BCM53128_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_SET BCM53128_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET
#define FC_TOTAL_USEDr_RESERVEDf_GET BCM53128_A0_FC_TOTAL_USEDr_RESERVEDf_GET
#define FC_TOTAL_USEDr_RESERVEDf_SET BCM53128_A0_FC_TOTAL_USEDr_RESERVEDf_SET
#define READ_FC_TOTAL_USEDr BCM53128_A0_READ_FC_TOTAL_USEDr
#define WRITE_FC_TOTAL_USEDr BCM53128_A0_WRITE_FC_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     TX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     TXPAUSE_HIS      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXPAUSE_HISr 0x00000aa2

#define BCM53128_A0_FC_TXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXPAUSE_HIS.
 *
 */
typedef union BCM53128_A0_FC_TXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_txpause_his[1];
	uint32_t _fc_txpause_his;
} BCM53128_A0_FC_TXPAUSE_HISr_t;

#define BCM53128_A0_FC_TXPAUSE_HISr_CLR(r) (r).fc_txpause_his[0] = 0
#define BCM53128_A0_FC_TXPAUSE_HISr_SET(r,d) (r).fc_txpause_his[0] = d
#define BCM53128_A0_FC_TXPAUSE_HISr_GET(r) (r).fc_txpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET(r) (((r).fc_txpause_his[0]) & 0x7ff)
#define BCM53128_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53128_A0_FC_TXPAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_txpause_his[0]) >> 11) & 0x1f)
#define BCM53128_A0_FC_TXPAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TXPAUSE_HIS.
 *
 */
#define BCM53128_A0_READ_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXPAUSE_HISr,(r._fc_txpause_his),2)
#define BCM53128_A0_WRITE_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXPAUSE_HISr,&(r._fc_txpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXPAUSE_HISr BCM53128_A0_FC_TXPAUSE_HISr
#define FC_TXPAUSE_HISr_SIZE BCM53128_A0_FC_TXPAUSE_HISr_SIZE
typedef BCM53128_A0_FC_TXPAUSE_HISr_t FC_TXPAUSE_HISr_t;
#define FC_TXPAUSE_HISr_CLR BCM53128_A0_FC_TXPAUSE_HISr_CLR
#define FC_TXPAUSE_HISr_SET BCM53128_A0_FC_TXPAUSE_HISr_SET
#define FC_TXPAUSE_HISr_GET BCM53128_A0_FC_TXPAUSE_HISr_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_GET BCM53128_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_SET BCM53128_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET
#define FC_TXPAUSE_HISr_RESERVEDf_GET BCM53128_A0_FC_TXPAUSE_HISr_RESERVEDf_GET
#define FC_TXPAUSE_HISr_RESERVEDf_SET BCM53128_A0_FC_TXPAUSE_HISr_RESERVEDf_SET
#define READ_FC_TXPAUSE_HISr BCM53128_A0_READ_FC_TXPAUSE_HISr
#define WRITE_FC_TXPAUSE_HISr BCM53128_A0_WRITE_FC_TXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr 0x00000a20

#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q[1];
	uint32_t _fc_txq_th_drop_q;
} BCM53128_A0_FC_TXQ_TH_DROP_Qr_t;

#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_CLR(r) (r).fc_txq_th_drop_q[0] = 0
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_SET(r,d) (r).fc_txq_th_drop_q[0] = d
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_GET(r) (r).fc_txq_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),(r._fc_txq_th_drop_q),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),&(r._fc_txq_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Qr BCM53128_A0_FC_TXQ_TH_DROP_Qr
#define FC_TXQ_TH_DROP_Qr_SIZE BCM53128_A0_FC_TXQ_TH_DROP_Qr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_DROP_Qr_t FC_TXQ_TH_DROP_Qr_t;
#define FC_TXQ_TH_DROP_Qr_CLR BCM53128_A0_FC_TXQ_TH_DROP_Qr_CLR
#define FC_TXQ_TH_DROP_Qr_SET BCM53128_A0_FC_TXQ_TH_DROP_Qr_SET
#define FC_TXQ_TH_DROP_Qr_GET BCM53128_A0_FC_TXQ_TH_DROP_Qr_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET BCM53128_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET BCM53128_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Qr_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Qr_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Qr BCM53128_A0_READ_FC_TXQ_TH_DROP_Qr
#define WRITE_FC_TXQ_TH_DROP_Qr BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r 0x00000ab8

#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q45.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q45[1];
	uint32_t _fc_txq_th_drop_q45;
} BCM53128_A0_FC_TXQ_TH_DROP_Q45r_t;

#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_CLR(r) (r).fc_txq_th_drop_q45[0] = 0
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_SET(r,d) (r).fc_txq_th_drop_q45[0] = d
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_GET(r) (r).fc_txq_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q45[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q45[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q45.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),(r._fc_txq_th_drop_q45),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),&(r._fc_txq_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q45r BCM53128_A0_FC_TXQ_TH_DROP_Q45r
#define FC_TXQ_TH_DROP_Q45r_SIZE BCM53128_A0_FC_TXQ_TH_DROP_Q45r_SIZE
typedef BCM53128_A0_FC_TXQ_TH_DROP_Q45r_t FC_TXQ_TH_DROP_Q45r_t;
#define FC_TXQ_TH_DROP_Q45r_CLR BCM53128_A0_FC_TXQ_TH_DROP_Q45r_CLR
#define FC_TXQ_TH_DROP_Q45r_SET BCM53128_A0_FC_TXQ_TH_DROP_Q45r_SET
#define FC_TXQ_TH_DROP_Q45r_GET BCM53128_A0_FC_TXQ_TH_DROP_Q45r_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET BCM53128_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET BCM53128_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q45r BCM53128_A0_READ_FC_TXQ_TH_DROP_Q45r
#define WRITE_FC_TXQ_TH_DROP_Q45r BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr 0x00000d20

#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_IMP.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_imp[1];
	uint32_t _fc_txq_th_drop_q_imp;
} BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_t;

#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR(r) (r).fc_txq_th_drop_q_imp[0] = 0
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_SET(r,d) (r).fc_txq_th_drop_q_imp[0] = d
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_GET(r) (r).fc_txq_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_imp[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q_imp[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_IMP.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),(r._fc_txq_th_drop_q_imp),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_txq_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_IMPr BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr
#define FC_TXQ_TH_DROP_Q_IMPr_SIZE BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_t FC_TXQ_TH_DROP_Q_IMPr_t;
#define FC_TXQ_TH_DROP_Q_IMPr_CLR BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR
#define FC_TXQ_TH_DROP_Q_IMPr_SET BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_SET
#define FC_TXQ_TH_DROP_Q_IMPr_GET BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q_IMPr BCM53128_A0_READ_FC_TXQ_TH_DROP_Q_IMPr
#define WRITE_FC_TXQ_TH_DROP_Q_IMPr BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for IMP1
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr 0x00000e20

#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_WAN.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_wan[1];
	uint32_t _fc_txq_th_drop_q_wan;
} BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_t;

#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_CLR(r) (r).fc_txq_th_drop_q_wan[0] = 0
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_SET(r,d) (r).fc_txq_th_drop_q_wan[0] = d
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_GET(r) (r).fc_txq_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_wan[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q_wan[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_WAN.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),(r._fc_txq_th_drop_q_wan),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),&(r._fc_txq_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_WANr BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr
#define FC_TXQ_TH_DROP_Q_WANr_SIZE BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_t FC_TXQ_TH_DROP_Q_WANr_t;
#define FC_TXQ_TH_DROP_Q_WANr_CLR BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_CLR
#define FC_TXQ_TH_DROP_Q_WANr_SET BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_SET
#define FC_TXQ_TH_DROP_Q_WANr_GET BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q_WANr BCM53128_A0_READ_FC_TXQ_TH_DROP_Q_WANr
#define WRITE_FC_TXQ_TH_DROP_Q_WANr BCM53128_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr 0x00000a18

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q[1];
	uint32_t _fc_txq_th_pause_q;
} BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_t;

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_CLR(r) (r).fc_txq_th_pause_q[0] = 0
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_SET(r,d) (r).fc_txq_th_pause_q[0] = d
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_GET(r) (r).fc_txq_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),(r._fc_txq_th_pause_q),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),&(r._fc_txq_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Qr BCM53128_A0_FC_TXQ_TH_PAUSE_Qr
#define FC_TXQ_TH_PAUSE_Qr_SIZE BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_t FC_TXQ_TH_PAUSE_Qr_t;
#define FC_TXQ_TH_PAUSE_Qr_CLR BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_CLR
#define FC_TXQ_TH_PAUSE_Qr_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_SET
#define FC_TXQ_TH_PAUSE_Qr_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Qr BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Qr
#define WRITE_FC_TXQ_TH_PAUSE_Qr BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r 0x00000ab4

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q45.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q45[1];
	uint32_t _fc_txq_th_pause_q45;
} BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_t;

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_CLR(r) (r).fc_txq_th_pause_q45[0] = 0
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_SET(r,d) (r).fc_txq_th_pause_q45[0] = d
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_GET(r) (r).fc_txq_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q45[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q45.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),(r._fc_txq_th_pause_q45),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),&(r._fc_txq_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q45r BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r
#define FC_TXQ_TH_PAUSE_Q45r_SIZE BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE
typedef BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_t FC_TXQ_TH_PAUSE_Q45r_t;
#define FC_TXQ_TH_PAUSE_Q45r_CLR BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_CLR
#define FC_TXQ_TH_PAUSE_Q45r_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_SET
#define FC_TXQ_TH_PAUSE_Q45r_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q45r BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Q45r
#define WRITE_FC_TXQ_TH_PAUSE_Q45r BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr 0x00000d18

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_imp[1];
	uint32_t _fc_txq_th_pause_q_imp;
} BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t;

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_txq_th_pause_q_imp[0] = 0
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_txq_th_pause_q_imp[0] = d
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET(r) (r).fc_txq_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_imp[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_txq_th_pause_q_imp),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_txq_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_IMPr BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr
#define FC_TXQ_TH_PAUSE_Q_IMPr_SIZE BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t FC_TXQ_TH_PAUSE_Q_IMPr_t;
#define FC_TXQ_TH_PAUSE_Q_IMPr_CLR BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR
#define FC_TXQ_TH_PAUSE_Q_IMPr_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_IMPr BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr
#define WRITE_FC_TXQ_TH_PAUSE_Q_IMPr BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for IMP1
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr 0x00000e18

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_wan[1];
	uint32_t _fc_txq_th_pause_q_wan;
} BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_t;

#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR(r) (r).fc_txq_th_pause_q_wan[0] = 0
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_txq_th_pause_q_wan[0] = d
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET(r) (r).fc_txq_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_wan[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_txq_th_pause_q_wan),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_txq_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_WANr BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr
#define FC_TXQ_TH_PAUSE_Q_WANr_SIZE BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_t FC_TXQ_TH_PAUSE_Q_WANr_t;
#define FC_TXQ_TH_PAUSE_Q_WANr_CLR BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR
#define FC_TXQ_TH_PAUSE_Q_WANr_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_WANr BCM53128_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr
#define WRITE_FC_TXQ_TH_PAUSE_Q_WANr BCM53128_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr 0x00000a10

#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q[1];
	uint32_t _fc_txq_th_rsrv_q;
} BCM53128_A0_FC_TXQ_TH_RSRV_Qr_t;

#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_CLR(r) (r).fc_txq_th_rsrv_q[0] = 0
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_SET(r,d) (r).fc_txq_th_rsrv_q[0] = d
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_GET(r) (r).fc_txq_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),(r._fc_txq_th_rsrv_q),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),&(r._fc_txq_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Qr BCM53128_A0_FC_TXQ_TH_RSRV_Qr
#define FC_TXQ_TH_RSRV_Qr_SIZE BCM53128_A0_FC_TXQ_TH_RSRV_Qr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_RSRV_Qr_t FC_TXQ_TH_RSRV_Qr_t;
#define FC_TXQ_TH_RSRV_Qr_CLR BCM53128_A0_FC_TXQ_TH_RSRV_Qr_CLR
#define FC_TXQ_TH_RSRV_Qr_SET BCM53128_A0_FC_TXQ_TH_RSRV_Qr_SET
#define FC_TXQ_TH_RSRV_Qr_GET BCM53128_A0_FC_TXQ_TH_RSRV_Qr_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET BCM53128_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET BCM53128_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET BCM53128_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET BCM53128_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Qr BCM53128_A0_READ_FC_TXQ_TH_RSRV_Qr
#define WRITE_FC_TXQ_TH_RSRV_Qr BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r 0x00000ab0

#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q45.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q45[1];
	uint32_t _fc_txq_th_rsrv_q45;
} BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_t;

#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_CLR(r) (r).fc_txq_th_rsrv_q45[0] = 0
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_SET(r,d) (r).fc_txq_th_rsrv_q45[0] = d
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_GET(r) (r).fc_txq_th_rsrv_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q45[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q45[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q45.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),(r._fc_txq_th_rsrv_q45),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),&(r._fc_txq_th_rsrv_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q45r BCM53128_A0_FC_TXQ_TH_RSRV_Q45r
#define FC_TXQ_TH_RSRV_Q45r_SIZE BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_SIZE
typedef BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_t FC_TXQ_TH_RSRV_Q45r_t;
#define FC_TXQ_TH_RSRV_Q45r_CLR BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_CLR
#define FC_TXQ_TH_RSRV_Q45r_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_SET
#define FC_TXQ_TH_RSRV_Q45r_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q45r BCM53128_A0_READ_FC_TXQ_TH_RSRV_Q45r
#define WRITE_FC_TXQ_TH_RSRV_Q45r BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_RSRV_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr 0x00000d10

#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_imp[1];
	uint32_t _fc_txq_th_rsrv_q_imp;
} BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_t;

#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR(r) (r).fc_txq_th_rsrv_q_imp[0] = 0
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET(r,d) (r).fc_txq_th_rsrv_q_imp[0] = d
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET(r) (r).fc_txq_th_rsrv_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_imp[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q_imp[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),(r._fc_txq_th_rsrv_q_imp),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),&(r._fc_txq_th_rsrv_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_IMPr BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr
#define FC_TXQ_TH_RSRV_Q_IMPr_SIZE BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_t FC_TXQ_TH_RSRV_Q_IMPr_t;
#define FC_TXQ_TH_RSRV_Q_IMPr_CLR BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR
#define FC_TXQ_TH_RSRV_Q_IMPr_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q_IMPr BCM53128_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr
#define WRITE_FC_TXQ_TH_RSRV_Q_IMPr BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_RSRV_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for IMP1
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr 0x00000e10

#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
typedef union BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_wan[1];
	uint32_t _fc_txq_th_rsrv_q_wan;
} BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_t;

#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR(r) (r).fc_txq_th_rsrv_q_wan[0] = 0
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_SET(r,d) (r).fc_txq_th_rsrv_q_wan[0] = d
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_GET(r) (r).fc_txq_th_rsrv_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_wan[0]) & 0x3ff)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q_wan[0]) >> 10) & 0x3f)
#define BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
#define BCM53128_A0_READ_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),(r._fc_txq_th_rsrv_q_wan),2)
#define BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),&(r._fc_txq_th_rsrv_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_WANr BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr
#define FC_TXQ_TH_RSRV_Q_WANr_SIZE BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE
typedef BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_t FC_TXQ_TH_RSRV_Q_WANr_t;
#define FC_TXQ_TH_RSRV_Q_WANr_CLR BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR
#define FC_TXQ_TH_RSRV_Q_WANr_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_SET
#define FC_TXQ_TH_RSRV_Q_WANr_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q_WANr BCM53128_A0_READ_FC_TXQ_TH_RSRV_Q_WANr
#define WRITE_FC_TXQ_TH_RSRV_Q_WANr BCM53128_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FC_TXQ_TH_RSRV_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  FORCE_FRAME_DROP
 * BLOCKS:   SYS
 * DESC:     Force Frame Drop Register
 * SIZE:     16
 * FIELDS:
 *     FORCE_FRAME_DROP Force frame drop if the port in congestion.Bit 8 = IMP portBit 7:0 = Port 7 ~ port 01: Frame drop when the congestions status of the queue = "01" (Default)0: Frame not drop when the congestions status of the queue = "01" (For fixing the strict priroity fairness issue)
 *     RESERVED         Reserved.
 *     FIX_WAN_PAUSE_OFF Enable Pause on/off threshold right for wan1: enable:0: follow original design, pause off threshold will follow normal queue
 *
 ******************************************************************************/
#define BCM53128_A0_FORCE_FRAME_DROPr 0x00000a5a

#define BCM53128_A0_FORCE_FRAME_DROPr_SIZE 2

/*
 * This structure should be used to declare and program FORCE_FRAME_DROP.
 *
 */
typedef union BCM53128_A0_FORCE_FRAME_DROPr_s {
	uint32_t v[1];
	uint32_t force_frame_drop[1];
	uint32_t _force_frame_drop;
} BCM53128_A0_FORCE_FRAME_DROPr_t;

#define BCM53128_A0_FORCE_FRAME_DROPr_CLR(r) (r).force_frame_drop[0] = 0
#define BCM53128_A0_FORCE_FRAME_DROPr_SET(r,d) (r).force_frame_drop[0] = d
#define BCM53128_A0_FORCE_FRAME_DROPr_GET(r) (r).force_frame_drop[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FORCE_FRAME_DROPr_FORCE_FRAME_DROPf_GET(r) (((r).force_frame_drop[0]) & 0x1ff)
#define BCM53128_A0_FORCE_FRAME_DROPr_FORCE_FRAME_DROPf_SET(r,f) (r).force_frame_drop[0]=(((r).force_frame_drop[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_FORCE_FRAME_DROPr_RESERVEDf_GET(r) ((((r).force_frame_drop[0]) >> 9) & 0x3f)
#define BCM53128_A0_FORCE_FRAME_DROPr_RESERVEDf_SET(r,f) (r).force_frame_drop[0]=(((r).force_frame_drop[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM53128_A0_FORCE_FRAME_DROPr_FIX_WAN_PAUSE_OFFf_GET(r) ((((r).force_frame_drop[0]) >> 15) & 0x1)
#define BCM53128_A0_FORCE_FRAME_DROPr_FIX_WAN_PAUSE_OFFf_SET(r,f) (r).force_frame_drop[0]=(((r).force_frame_drop[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FORCE_FRAME_DROP.
 *
 */
#define BCM53128_A0_READ_FORCE_FRAME_DROPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_FORCE_FRAME_DROPr,(r._force_frame_drop),2)
#define BCM53128_A0_WRITE_FORCE_FRAME_DROPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_FORCE_FRAME_DROPr,&(r._force_frame_drop),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FORCE_FRAME_DROPr BCM53128_A0_FORCE_FRAME_DROPr
#define FORCE_FRAME_DROPr_SIZE BCM53128_A0_FORCE_FRAME_DROPr_SIZE
typedef BCM53128_A0_FORCE_FRAME_DROPr_t FORCE_FRAME_DROPr_t;
#define FORCE_FRAME_DROPr_CLR BCM53128_A0_FORCE_FRAME_DROPr_CLR
#define FORCE_FRAME_DROPr_SET BCM53128_A0_FORCE_FRAME_DROPr_SET
#define FORCE_FRAME_DROPr_GET BCM53128_A0_FORCE_FRAME_DROPr_GET
#define FORCE_FRAME_DROPr_FORCE_FRAME_DROPf_GET BCM53128_A0_FORCE_FRAME_DROPr_FORCE_FRAME_DROPf_GET
#define FORCE_FRAME_DROPr_FORCE_FRAME_DROPf_SET BCM53128_A0_FORCE_FRAME_DROPr_FORCE_FRAME_DROPf_SET
#define FORCE_FRAME_DROPr_RESERVEDf_GET BCM53128_A0_FORCE_FRAME_DROPr_RESERVEDf_GET
#define FORCE_FRAME_DROPr_RESERVEDf_SET BCM53128_A0_FORCE_FRAME_DROPr_RESERVEDf_SET
#define FORCE_FRAME_DROPr_FIX_WAN_PAUSE_OFFf_GET BCM53128_A0_FORCE_FRAME_DROPr_FIX_WAN_PAUSE_OFFf_GET
#define FORCE_FRAME_DROPr_FIX_WAN_PAUSE_OFFf_SET BCM53128_A0_FORCE_FRAME_DROPr_FIX_WAN_PAUSE_OFFf_SET
#define READ_FORCE_FRAME_DROPr BCM53128_A0_READ_FORCE_FRAME_DROPr
#define WRITE_FORCE_FRAME_DROPr BCM53128_A0_WRITE_FORCE_FRAME_DROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FORCE_FRAME_DROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  FRAME_BUF
 * BLOCKS:   SYS
 * DESC:     Frame Buffer Memory
 * SIZE:     64
 * FIELDS:
 *     GENMEM_DATA      RAM data entry
 *
 ******************************************************************************/
#define BCM53128_A0_FRAME_BUFm 0x00000000

#define BCM53128_A0_FRAME_BUFm_MIN 0
#define BCM53128_A0_FRAME_BUFm_MAX 4095
#define BCM53128_A0_FRAME_BUFm_CMAX(u) 4095
#define BCM53128_A0_FRAME_BUFm_SIZE 8

/*
 * This structure should be used to declare and program FRAME_BUF.
 *
 */
typedef union BCM53128_A0_FRAME_BUFm_s {
	uint32_t v[2];
	uint32_t frame_buf[2];
	uint32_t _frame_buf;
} BCM53128_A0_FRAME_BUFm_t;

#define BCM53128_A0_FRAME_BUFm_CLR(r) CDK_MEMSET(&((r)._frame_buf), 0, sizeof(BCM53128_A0_FRAME_BUFm_t))
#define BCM53128_A0_FRAME_BUFm_SET(r,i,d) (r).frame_buf[i] = d
#define BCM53128_A0_FRAME_BUFm_GET(r,i) (r).frame_buf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_FRAME_BUFm_GENMEM_DATAf_GET(r,a) cdk_field_get((r).frame_buf,0,63,a)
#define BCM53128_A0_FRAME_BUFm_GENMEM_DATAf_SET(r,a) cdk_field_set((r).frame_buf,0,63,a)

/*
 * These macros can be used to access FRAME_BUF.
 *
 */
#define BCM53128_A0_READ_FRAME_BUFm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_FRAME_BUFm,i,(m),8)
#define BCM53128_A0_WRITE_FRAME_BUFm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_FRAME_BUFm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FRAME_BUFm BCM53128_A0_FRAME_BUFm
#define FRAME_BUFm_MIN BCM53128_A0_FRAME_BUFm_MIN
#define FRAME_BUFm_MAX BCM53128_A0_FRAME_BUFm_MAX
#define FRAME_BUFm_CMAX(u) BCM53128_A0_FRAME_BUFm_CMAX(u)
#define FRAME_BUFm_SIZE BCM53128_A0_FRAME_BUFm_SIZE
typedef BCM53128_A0_FRAME_BUFm_t FRAME_BUFm_t;
#define FRAME_BUFm_CLR BCM53128_A0_FRAME_BUFm_CLR
#define FRAME_BUFm_SET BCM53128_A0_FRAME_BUFm_SET
#define FRAME_BUFm_GET BCM53128_A0_FRAME_BUFm_GET
#define FRAME_BUFm_GENMEM_DATAf_GET BCM53128_A0_FRAME_BUFm_GENMEM_DATAf_GET
#define FRAME_BUFm_GENMEM_DATAf_SET BCM53128_A0_FRAME_BUFm_GENMEM_DATAf_SET
#define READ_FRAME_BUFm BCM53128_A0_READ_FRAME_BUFm
#define WRITE_FRAME_BUFm BCM53128_A0_WRITE_FRAME_BUFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_FRAME_BUFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable The hash function for the ARL such that entries are direct mapped to the table. The hash function is enabled as the default for the Blackbird2 ARL,but can be disabled by setting this bit.
 *     RESERVED_0       Reserved
 *     AGE_ACC          Age Accele rate, test only.1: accelerate 128 times for age process.0: Keep original age process.
 *     SA_MOVE_DROP     SA Station Move Drop (reserved, not implemented in Vulcan)This bit is to control whether station movement is allowed or not.0: if the ARL control mode = 10, Drop packet if SA match. (Default, allow station movement)1: if the ARL control mode = 10, Drop packet if SA match and port number not match. (Not allow station movement)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_GARLCFGr 0x00000400

#define BCM53128_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 *
 */
typedef union BCM53128_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM53128_A0_GARLCFGr_t;

#define BCM53128_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM53128_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM53128_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM53128_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_GARLCFGr_RESERVED_0f_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM53128_A0_GARLCFGr_RESERVED_0f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM53128_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_GARLCFGr_SA_MOVE_DROPf_GET(r) ((((r).garlcfg[0]) >> 3) & 0x1)
#define BCM53128_A0_GARLCFGr_SA_MOVE_DROPf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_GARLCFGr_RESERVED_1f_GET(r) ((((r).garlcfg[0]) >> 4) & 0xf)
#define BCM53128_A0_GARLCFGr_RESERVED_1f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access GARLCFG.
 *
 */
#define BCM53128_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_GARLCFGr,(r._garlcfg),1)
#define BCM53128_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM53128_A0_GARLCFGr
#define GARLCFGr_SIZE BCM53128_A0_GARLCFGr_SIZE
typedef BCM53128_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM53128_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM53128_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM53128_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM53128_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM53128_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_RESERVED_0f_GET BCM53128_A0_GARLCFGr_RESERVED_0f_GET
#define GARLCFGr_RESERVED_0f_SET BCM53128_A0_GARLCFGr_RESERVED_0f_SET
#define GARLCFGr_AGE_ACCf_GET BCM53128_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM53128_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_SA_MOVE_DROPf_GET BCM53128_A0_GARLCFGr_SA_MOVE_DROPf_GET
#define GARLCFGr_SA_MOVE_DROPf_SET BCM53128_A0_GARLCFGr_SA_MOVE_DROPf_SET
#define GARLCFGr_RESERVED_1f_GET BCM53128_A0_GARLCFGr_RESERVED_1f_GET
#define GARLCFGr_RESERVED_1f_SET BCM53128_A0_GARLCFGr_RESERVED_1f_SET
#define READ_GARLCFGr BCM53128_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM53128_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GARLCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB CountersResets all MIB counters for all ports to zero (Pages 20h-28h). The host must set the bit and then clear the bit in successive write cycles to activate the reset operation.
 *     RXBPDU_EN        Receive BPDU Enable.Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.
 *     RESERVED_0       Reserved
 *     INT_EN           Interrupt enable
 *     RESERVED_1       Reserved
 *     FRM_MNGP         IMP port enableThis field enables the IMP (In-band Management Port) function under management mode.00=No Management Port01=Reserved10=Enable IMPAll traffic to CPU from LAN ports and WAN ports will be forwarded to IMP.11=Enable Dual IMP (Not2Release)All traffic to CPU from LAN ports will be forwarded to IMP; and All traffic from WAN ports will be forwarded to IMP1.These bits are ignored when SW FWD MODE=Unmanaged inthe Switch Mode Register, and the device will behave as if thereis no defined management port.In BB2, IMP port is port 8. IMP1 is port 7.
 *
 ******************************************************************************/
#define BCM53128_A0_GMNGCFGr 0x00000200

#define BCM53128_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 *
 */
typedef union BCM53128_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM53128_A0_GMNGCFGr_t;

#define BCM53128_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM53128_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM53128_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GMNGCFGr_RST_MIB_CNTf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM53128_A0_GMNGCFGr_RST_MIB_CNTf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_GMNGCFGr_RXBPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM53128_A0_GMNGCFGr_RXBPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_GMNGCFGr_RESERVED_0f_GET(r) ((((r).gmngcfg[0]) >> 2) & 0x3)
#define BCM53128_A0_GMNGCFGr_RESERVED_0f_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_GMNGCFGr_INT_ENf_GET(r) ((((r).gmngcfg[0]) >> 4) & 0x1)
#define BCM53128_A0_GMNGCFGr_INT_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_GMNGCFGr_RESERVED_1f_GET(r) ((((r).gmngcfg[0]) >> 5) & 0x1)
#define BCM53128_A0_GMNGCFGr_RESERVED_1f_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM53128_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 *
 */
#define BCM53128_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM53128_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM53128_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM53128_A0_GMNGCFGr_SIZE
typedef BCM53128_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM53128_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM53128_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM53128_A0_GMNGCFGr_GET
#define GMNGCFGr_RST_MIB_CNTf_GET BCM53128_A0_GMNGCFGr_RST_MIB_CNTf_GET
#define GMNGCFGr_RST_MIB_CNTf_SET BCM53128_A0_GMNGCFGr_RST_MIB_CNTf_SET
#define GMNGCFGr_RXBPDU_ENf_GET BCM53128_A0_GMNGCFGr_RXBPDU_ENf_GET
#define GMNGCFGr_RXBPDU_ENf_SET BCM53128_A0_GMNGCFGr_RXBPDU_ENf_SET
#define GMNGCFGr_RESERVED_0f_GET BCM53128_A0_GMNGCFGr_RESERVED_0f_GET
#define GMNGCFGr_RESERVED_0f_SET BCM53128_A0_GMNGCFGr_RESERVED_0f_SET
#define GMNGCFGr_INT_ENf_GET BCM53128_A0_GMNGCFGr_INT_ENf_GET
#define GMNGCFGr_INT_ENf_SET BCM53128_A0_GMNGCFGr_INT_ENf_SET
#define GMNGCFGr_RESERVED_1f_GET BCM53128_A0_GMNGCFGr_RESERVED_1f_GET
#define GMNGCFGr_RESERVED_1f_SET BCM53128_A0_GMNGCFGr_RESERVED_1f_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM53128_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM53128_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM53128_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM53128_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GMNGCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GREEN_MODE_DATA
 * BLOCKS:   SYS
 * DESC:     Green Mode Data Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     GREEN_MODE_DATA  Green mode parameters(GL_T_A, GL_T_B, EXP10, and THRESHOLD) loaded from OTP.
 *
 ******************************************************************************/
#define BCM53128_A0_GREEN_MODE_DATAr 0x000000c0

#define BCM53128_A0_GREEN_MODE_DATAr_SIZE 8

/*
 * This structure should be used to declare and program GREEN_MODE_DATA.
 *
 */
typedef union BCM53128_A0_GREEN_MODE_DATAr_s {
	uint32_t v[2];
	uint32_t green_mode_data[2];
	uint32_t _green_mode_data;
} BCM53128_A0_GREEN_MODE_DATAr_t;

#define BCM53128_A0_GREEN_MODE_DATAr_CLR(r) CDK_MEMSET(&((r)._green_mode_data), 0, sizeof(BCM53128_A0_GREEN_MODE_DATAr_t))
#define BCM53128_A0_GREEN_MODE_DATAr_SET(r,i,d) (r).green_mode_data[i] = d
#define BCM53128_A0_GREEN_MODE_DATAr_GET(r,i) (r).green_mode_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_GET(r,a) cdk_field_get((r).green_mode_data,0,63,a)
#define BCM53128_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_SET(r,a) cdk_field_set((r).green_mode_data,0,63,a)

/*
 * These macros can be used to access GREEN_MODE_DATA.
 *
 */
#define BCM53128_A0_READ_GREEN_MODE_DATAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_GREEN_MODE_DATAr,(r._green_mode_data),8)
#define BCM53128_A0_WRITE_GREEN_MODE_DATAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_GREEN_MODE_DATAr,&(r._green_mode_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GREEN_MODE_DATAr BCM53128_A0_GREEN_MODE_DATAr
#define GREEN_MODE_DATAr_SIZE BCM53128_A0_GREEN_MODE_DATAr_SIZE
typedef BCM53128_A0_GREEN_MODE_DATAr_t GREEN_MODE_DATAr_t;
#define GREEN_MODE_DATAr_CLR BCM53128_A0_GREEN_MODE_DATAr_CLR
#define GREEN_MODE_DATAr_SET BCM53128_A0_GREEN_MODE_DATAr_SET
#define GREEN_MODE_DATAr_GET BCM53128_A0_GREEN_MODE_DATAr_GET
#define GREEN_MODE_DATAr_GREEN_MODE_DATAf_GET BCM53128_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_GET
#define GREEN_MODE_DATAr_GREEN_MODE_DATAf_SET BCM53128_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_SET
#define READ_GREEN_MODE_DATAr BCM53128_A0_READ_GREEN_MODE_DATAr
#define WRITE_GREEN_MODE_DATAr BCM53128_A0_WRITE_GREEN_MODE_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GREEN_MODE_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GREEN_MODE_SELECT
 * BLOCKS:   SYS
 * DESC:     Green mode Select Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved.
 *     GREEN_MODE_SELECT Green mode select parameter loaded from OTP.
 *
 ******************************************************************************/
#define BCM53128_A0_GREEN_MODE_SELECTr 0x000000c9

#define BCM53128_A0_GREEN_MODE_SELECTr_SIZE 1

/*
 * This structure should be used to declare and program GREEN_MODE_SELECT.
 *
 */
typedef union BCM53128_A0_GREEN_MODE_SELECTr_s {
	uint32_t v[1];
	uint32_t green_mode_select[1];
	uint32_t _green_mode_select;
} BCM53128_A0_GREEN_MODE_SELECTr_t;

#define BCM53128_A0_GREEN_MODE_SELECTr_CLR(r) (r).green_mode_select[0] = 0
#define BCM53128_A0_GREEN_MODE_SELECTr_SET(r,d) (r).green_mode_select[0] = d
#define BCM53128_A0_GREEN_MODE_SELECTr_GET(r) (r).green_mode_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GREEN_MODE_SELECTr_RESERVEDf_GET(r) (((r).green_mode_select[0]) & 0x1)
#define BCM53128_A0_GREEN_MODE_SELECTr_RESERVEDf_SET(r,f) (r).green_mode_select[0]=(((r).green_mode_select[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_GET(r) ((((r).green_mode_select[0]) >> 1) & 0x7f)
#define BCM53128_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_SET(r,f) (r).green_mode_select[0]=(((r).green_mode_select[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access GREEN_MODE_SELECT.
 *
 */
#define BCM53128_A0_READ_GREEN_MODE_SELECTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_GREEN_MODE_SELECTr,(r._green_mode_select),1)
#define BCM53128_A0_WRITE_GREEN_MODE_SELECTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_GREEN_MODE_SELECTr,&(r._green_mode_select),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GREEN_MODE_SELECTr BCM53128_A0_GREEN_MODE_SELECTr
#define GREEN_MODE_SELECTr_SIZE BCM53128_A0_GREEN_MODE_SELECTr_SIZE
typedef BCM53128_A0_GREEN_MODE_SELECTr_t GREEN_MODE_SELECTr_t;
#define GREEN_MODE_SELECTr_CLR BCM53128_A0_GREEN_MODE_SELECTr_CLR
#define GREEN_MODE_SELECTr_SET BCM53128_A0_GREEN_MODE_SELECTr_SET
#define GREEN_MODE_SELECTr_GET BCM53128_A0_GREEN_MODE_SELECTr_GET
#define GREEN_MODE_SELECTr_RESERVEDf_GET BCM53128_A0_GREEN_MODE_SELECTr_RESERVEDf_GET
#define GREEN_MODE_SELECTr_RESERVEDf_SET BCM53128_A0_GREEN_MODE_SELECTr_RESERVEDf_SET
#define GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_GET BCM53128_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_GET
#define GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_SET BCM53128_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_SET
#define READ_GREEN_MODE_SELECTr BCM53128_A0_READ_GREEN_MODE_SELECTr
#define WRITE_GREEN_MODE_SELECTr BCM53128_A0_WRITE_GREEN_MODE_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GREEN_MODE_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GSPI_CFR0
 * BLOCKS:   SYS
 * DESC:     GSPI Configure Register 0 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     GSPI_BCWC        GSPI Bit Count for Write Command.
 *
 ******************************************************************************/
#define BCM53128_A0_GSPI_CFR0r 0x0000ff01

#define BCM53128_A0_GSPI_CFR0r_SIZE 1

/*
 * This structure should be used to declare and program GSPI_CFR0.
 *
 */
typedef union BCM53128_A0_GSPI_CFR0r_s {
	uint32_t v[1];
	uint32_t gspi_cfr0[1];
	uint32_t _gspi_cfr0;
} BCM53128_A0_GSPI_CFR0r_t;

#define BCM53128_A0_GSPI_CFR0r_CLR(r) (r).gspi_cfr0[0] = 0
#define BCM53128_A0_GSPI_CFR0r_SET(r,d) (r).gspi_cfr0[0] = d
#define BCM53128_A0_GSPI_CFR0r_GET(r) (r).gspi_cfr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GSPI_CFR0r_GSPI_BCWCf_GET(r) (((r).gspi_cfr0[0]) & 0xff)
#define BCM53128_A0_GSPI_CFR0r_GSPI_BCWCf_SET(r,f) (r).gspi_cfr0[0]=(((r).gspi_cfr0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GSPI_CFR0.
 *
 */
#define BCM53128_A0_READ_GSPI_CFR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_GSPI_CFR0r,(r._gspi_cfr0),1)
#define BCM53128_A0_WRITE_GSPI_CFR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_GSPI_CFR0r,&(r._gspi_cfr0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSPI_CFR0r BCM53128_A0_GSPI_CFR0r
#define GSPI_CFR0r_SIZE BCM53128_A0_GSPI_CFR0r_SIZE
typedef BCM53128_A0_GSPI_CFR0r_t GSPI_CFR0r_t;
#define GSPI_CFR0r_CLR BCM53128_A0_GSPI_CFR0r_CLR
#define GSPI_CFR0r_SET BCM53128_A0_GSPI_CFR0r_SET
#define GSPI_CFR0r_GET BCM53128_A0_GSPI_CFR0r_GET
#define GSPI_CFR0r_GSPI_BCWCf_GET BCM53128_A0_GSPI_CFR0r_GSPI_BCWCf_GET
#define GSPI_CFR0r_GSPI_BCWCf_SET BCM53128_A0_GSPI_CFR0r_GSPI_BCWCf_SET
#define READ_GSPI_CFR0r BCM53128_A0_READ_GSPI_CFR0r
#define WRITE_GSPI_CFR0r BCM53128_A0_WRITE_GSPI_CFR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GSPI_CFR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GSPI_CFR1
 * BLOCKS:   SYS
 * DESC:     GSPI Configure Register 1 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     GSPI_BCWR        GSPI bit count for write.
 *
 ******************************************************************************/
#define BCM53128_A0_GSPI_CFR1r 0x0000ff02

#define BCM53128_A0_GSPI_CFR1r_SIZE 1

/*
 * This structure should be used to declare and program GSPI_CFR1.
 *
 */
typedef union BCM53128_A0_GSPI_CFR1r_s {
	uint32_t v[1];
	uint32_t gspi_cfr1[1];
	uint32_t _gspi_cfr1;
} BCM53128_A0_GSPI_CFR1r_t;

#define BCM53128_A0_GSPI_CFR1r_CLR(r) (r).gspi_cfr1[0] = 0
#define BCM53128_A0_GSPI_CFR1r_SET(r,d) (r).gspi_cfr1[0] = d
#define BCM53128_A0_GSPI_CFR1r_GET(r) (r).gspi_cfr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GSPI_CFR1r_GSPI_BCWRf_GET(r) (((r).gspi_cfr1[0]) & 0xff)
#define BCM53128_A0_GSPI_CFR1r_GSPI_BCWRf_SET(r,f) (r).gspi_cfr1[0]=(((r).gspi_cfr1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GSPI_CFR1.
 *
 */
#define BCM53128_A0_READ_GSPI_CFR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_GSPI_CFR1r,(r._gspi_cfr1),1)
#define BCM53128_A0_WRITE_GSPI_CFR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_GSPI_CFR1r,&(r._gspi_cfr1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSPI_CFR1r BCM53128_A0_GSPI_CFR1r
#define GSPI_CFR1r_SIZE BCM53128_A0_GSPI_CFR1r_SIZE
typedef BCM53128_A0_GSPI_CFR1r_t GSPI_CFR1r_t;
#define GSPI_CFR1r_CLR BCM53128_A0_GSPI_CFR1r_CLR
#define GSPI_CFR1r_SET BCM53128_A0_GSPI_CFR1r_SET
#define GSPI_CFR1r_GET BCM53128_A0_GSPI_CFR1r_GET
#define GSPI_CFR1r_GSPI_BCWRf_GET BCM53128_A0_GSPI_CFR1r_GSPI_BCWRf_GET
#define GSPI_CFR1r_GSPI_BCWRf_SET BCM53128_A0_GSPI_CFR1r_GSPI_BCWRf_SET
#define READ_GSPI_CFR1r BCM53128_A0_READ_GSPI_CFR1r
#define WRITE_GSPI_CFR1r BCM53128_A0_WRITE_GSPI_CFR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GSPI_CFR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GSPI_CFR2
 * BLOCKS:   SYS
 * DESC:     GSPI Configure Register 2 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     GSPI_BCRD        GSPI bit count for read.
 *
 ******************************************************************************/
#define BCM53128_A0_GSPI_CFR2r 0x0000ff03

#define BCM53128_A0_GSPI_CFR2r_SIZE 1

/*
 * This structure should be used to declare and program GSPI_CFR2.
 *
 */
typedef union BCM53128_A0_GSPI_CFR2r_s {
	uint32_t v[1];
	uint32_t gspi_cfr2[1];
	uint32_t _gspi_cfr2;
} BCM53128_A0_GSPI_CFR2r_t;

#define BCM53128_A0_GSPI_CFR2r_CLR(r) (r).gspi_cfr2[0] = 0
#define BCM53128_A0_GSPI_CFR2r_SET(r,d) (r).gspi_cfr2[0] = d
#define BCM53128_A0_GSPI_CFR2r_GET(r) (r).gspi_cfr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GSPI_CFR2r_GSPI_BCRDf_GET(r) (((r).gspi_cfr2[0]) & 0xff)
#define BCM53128_A0_GSPI_CFR2r_GSPI_BCRDf_SET(r,f) (r).gspi_cfr2[0]=(((r).gspi_cfr2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GSPI_CFR2.
 *
 */
#define BCM53128_A0_READ_GSPI_CFR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_GSPI_CFR2r,(r._gspi_cfr2),1)
#define BCM53128_A0_WRITE_GSPI_CFR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_GSPI_CFR2r,&(r._gspi_cfr2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSPI_CFR2r BCM53128_A0_GSPI_CFR2r
#define GSPI_CFR2r_SIZE BCM53128_A0_GSPI_CFR2r_SIZE
typedef BCM53128_A0_GSPI_CFR2r_t GSPI_CFR2r_t;
#define GSPI_CFR2r_CLR BCM53128_A0_GSPI_CFR2r_CLR
#define GSPI_CFR2r_SET BCM53128_A0_GSPI_CFR2r_SET
#define GSPI_CFR2r_GET BCM53128_A0_GSPI_CFR2r_GET
#define GSPI_CFR2r_GSPI_BCRDf_GET BCM53128_A0_GSPI_CFR2r_GSPI_BCRDf_GET
#define GSPI_CFR2r_GSPI_BCRDf_SET BCM53128_A0_GSPI_CFR2r_GSPI_BCRDf_SET
#define READ_GSPI_CFR2r BCM53128_A0_READ_GSPI_CFR2r
#define WRITE_GSPI_CFR2r BCM53128_A0_WRITE_GSPI_CFR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GSPI_CFR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GSPI_CR
 * BLOCKS:   SYS
 * DESC:     GSPI Control Registers (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     GSPI_IPGC        GSPI IPG Count=0, extra 0 SCK is counted=1, extra 2 SCK is counted=2, extra 8 SCK is counted=3, extra 64 SCK is counted
 *     GSPI_CKDIV       GSPI SCK clock divider parameter=0, SCK frequency = system clock /2=1, SCK frequency = system clock /4=2, SCK frequency = system clock /8...=15, SCK frequency = system clock / 65536
 *     GSPI_FIFOS       GSPI FIFO status=0, GSPI FIFO is not available=1, GSPI FIFO is ready for read or write
 *     GSPI_START       GSPI Status if read=0, GSPI is done, and it is ready for next task=1, GSPI is busy. The currently task is still running.GSPI Strobe if writeWrite 1 to start GSPI.
 *
 ******************************************************************************/
#define BCM53128_A0_GSPI_CRr 0x0000ff00

#define BCM53128_A0_GSPI_CRr_SIZE 1

/*
 * This structure should be used to declare and program GSPI_CR.
 *
 */
typedef union BCM53128_A0_GSPI_CRr_s {
	uint32_t v[1];
	uint32_t gspi_cr[1];
	uint32_t _gspi_cr;
} BCM53128_A0_GSPI_CRr_t;

#define BCM53128_A0_GSPI_CRr_CLR(r) (r).gspi_cr[0] = 0
#define BCM53128_A0_GSPI_CRr_SET(r,d) (r).gspi_cr[0] = d
#define BCM53128_A0_GSPI_CRr_GET(r) (r).gspi_cr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GSPI_CRr_GSPI_IPGCf_GET(r) (((r).gspi_cr[0]) & 0x3)
#define BCM53128_A0_GSPI_CRr_GSPI_IPGCf_SET(r,f) (r).gspi_cr[0]=(((r).gspi_cr[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_GSPI_CRr_GSPI_CKDIVf_GET(r) ((((r).gspi_cr[0]) >> 2) & 0xf)
#define BCM53128_A0_GSPI_CRr_GSPI_CKDIVf_SET(r,f) (r).gspi_cr[0]=(((r).gspi_cr[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53128_A0_GSPI_CRr_GSPI_FIFOSf_GET(r) ((((r).gspi_cr[0]) >> 6) & 0x1)
#define BCM53128_A0_GSPI_CRr_GSPI_FIFOSf_SET(r,f) (r).gspi_cr[0]=(((r).gspi_cr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_GSPI_CRr_GSPI_STARTf_GET(r) ((((r).gspi_cr[0]) >> 7) & 0x1)
#define BCM53128_A0_GSPI_CRr_GSPI_STARTf_SET(r,f) (r).gspi_cr[0]=(((r).gspi_cr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access GSPI_CR.
 *
 */
#define BCM53128_A0_READ_GSPI_CRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_GSPI_CRr,(r._gspi_cr),1)
#define BCM53128_A0_WRITE_GSPI_CRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_GSPI_CRr,&(r._gspi_cr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSPI_CRr BCM53128_A0_GSPI_CRr
#define GSPI_CRr_SIZE BCM53128_A0_GSPI_CRr_SIZE
typedef BCM53128_A0_GSPI_CRr_t GSPI_CRr_t;
#define GSPI_CRr_CLR BCM53128_A0_GSPI_CRr_CLR
#define GSPI_CRr_SET BCM53128_A0_GSPI_CRr_SET
#define GSPI_CRr_GET BCM53128_A0_GSPI_CRr_GET
#define GSPI_CRr_GSPI_IPGCf_GET BCM53128_A0_GSPI_CRr_GSPI_IPGCf_GET
#define GSPI_CRr_GSPI_IPGCf_SET BCM53128_A0_GSPI_CRr_GSPI_IPGCf_SET
#define GSPI_CRr_GSPI_CKDIVf_GET BCM53128_A0_GSPI_CRr_GSPI_CKDIVf_GET
#define GSPI_CRr_GSPI_CKDIVf_SET BCM53128_A0_GSPI_CRr_GSPI_CKDIVf_SET
#define GSPI_CRr_GSPI_FIFOSf_GET BCM53128_A0_GSPI_CRr_GSPI_FIFOSf_GET
#define GSPI_CRr_GSPI_FIFOSf_SET BCM53128_A0_GSPI_CRr_GSPI_FIFOSf_SET
#define GSPI_CRr_GSPI_STARTf_GET BCM53128_A0_GSPI_CRr_GSPI_STARTf_GET
#define GSPI_CRr_GSPI_STARTf_SET BCM53128_A0_GSPI_CRr_GSPI_STARTf_SET
#define READ_GSPI_CRr BCM53128_A0_READ_GSPI_CRr
#define WRITE_GSPI_CRr BCM53128_A0_WRITE_GSPI_CRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GSPI_CRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  GSPI_DR
 * BLOCKS:   SYS
 * DESC:     GSPI Data Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     GSPI_FIFO        GSPI data FIFO portWrite or read to access FIFO
 *
 ******************************************************************************/
#define BCM53128_A0_GSPI_DRr 0x0000ff04

#define BCM53128_A0_GSPI_DRr_SIZE 1

/*
 * This structure should be used to declare and program GSPI_DR.
 *
 */
typedef union BCM53128_A0_GSPI_DRr_s {
	uint32_t v[1];
	uint32_t gspi_dr[1];
	uint32_t _gspi_dr;
} BCM53128_A0_GSPI_DRr_t;

#define BCM53128_A0_GSPI_DRr_CLR(r) (r).gspi_dr[0] = 0
#define BCM53128_A0_GSPI_DRr_SET(r,d) (r).gspi_dr[0] = d
#define BCM53128_A0_GSPI_DRr_GET(r) (r).gspi_dr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_GSPI_DRr_GSPI_FIFOf_GET(r) (((r).gspi_dr[0]) & 0xff)
#define BCM53128_A0_GSPI_DRr_GSPI_FIFOf_SET(r,f) (r).gspi_dr[0]=(((r).gspi_dr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GSPI_DR.
 *
 */
#define BCM53128_A0_READ_GSPI_DRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_GSPI_DRr,(r._gspi_dr),1)
#define BCM53128_A0_WRITE_GSPI_DRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_GSPI_DRr,&(r._gspi_dr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSPI_DRr BCM53128_A0_GSPI_DRr
#define GSPI_DRr_SIZE BCM53128_A0_GSPI_DRr_SIZE
typedef BCM53128_A0_GSPI_DRr_t GSPI_DRr_t;
#define GSPI_DRr_CLR BCM53128_A0_GSPI_DRr_CLR
#define GSPI_DRr_SET BCM53128_A0_GSPI_DRr_SET
#define GSPI_DRr_GET BCM53128_A0_GSPI_DRr_GET
#define GSPI_DRr_GSPI_FIFOf_GET BCM53128_A0_GSPI_DRr_GSPI_FIFOf_GET
#define GSPI_DRr_GSPI_FIFOf_SET BCM53128_A0_GSPI_DRr_GSPI_FIFOf_SET
#define READ_GSPI_DRr BCM53128_A0_READ_GSPI_DRr
#define WRITE_GSPI_DRr BCM53128_A0_WRITE_GSPI_DRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_GSPI_DRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANADV
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANADVr 0x00001008

#define BCM53128_A0_G_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV.
 *
 */
typedef union BCM53128_A0_G_ANADVr_s {
	uint32_t v[1];
	uint32_t g_anadv[1];
	uint32_t _g_anadv;
} BCM53128_A0_G_ANADVr_t;

#define BCM53128_A0_G_ANADVr_CLR(r) (r).g_anadv[0] = 0
#define BCM53128_A0_G_ANADVr_SET(r,d) (r).g_anadv[0] = d
#define BCM53128_A0_G_ANADVr_GET(r) (r).g_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANADVr_PROTOCOL_SELf_GET(r) (((r).g_anadv[0]) & 0x1f)
#define BCM53128_A0_G_ANADVr_PROTOCOL_SELf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_G_ANADVr_ADV_B10Tf_GET(r) ((((r).g_anadv[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANADVr_ADV_B10Tf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv[0]) >> 6) & 0x1)
#define BCM53128_A0_G_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_ANADVr_ADV_B100Xf_GET(r) ((((r).g_anadv[0]) >> 7) & 0x1)
#define BCM53128_A0_G_ANADVr_ADV_B100Xf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_ANADVr_ADV_B100_FDXf_GET(r) ((((r).g_anadv[0]) >> 8) & 0x1)
#define BCM53128_A0_G_ANADVr_ADV_B100_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_ANADVr_B100T4f_GET(r) ((((r).g_anadv[0]) >> 9) & 0x1)
#define BCM53128_A0_G_ANADVr_B100T4f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv[0]) >> 10) & 0x1)
#define BCM53128_A0_G_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_ANADVr_ASY_PAUSEf_GET(r) ((((r).g_anadv[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANADVr_ASY_PAUSEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANADVr_RESERVED_1f_GET(r) ((((r).g_anadv[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANADVr_RESERVED_1f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANADVr_REMOTE_FAULTf_GET(r) ((((r).g_anadv[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANADVr_REMOTE_FAULTf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANADVr_RESERVED_2f_GET(r) ((((r).g_anadv[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANADVr_RESERVED_2f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANADVr_NEXT_PAGEf_GET(r) ((((r).g_anadv[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANADVr_NEXT_PAGEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV.
 *
 */
#define BCM53128_A0_READ_G_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_ANADVr,(r._g_anadv),2)
#define BCM53128_A0_WRITE_G_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_ANADVr,&(r._g_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADVr BCM53128_A0_G_ANADVr
#define G_ANADVr_SIZE BCM53128_A0_G_ANADVr_SIZE
typedef BCM53128_A0_G_ANADVr_t G_ANADVr_t;
#define G_ANADVr_CLR BCM53128_A0_G_ANADVr_CLR
#define G_ANADVr_SET BCM53128_A0_G_ANADVr_SET
#define G_ANADVr_GET BCM53128_A0_G_ANADVr_GET
#define G_ANADVr_PROTOCOL_SELf_GET BCM53128_A0_G_ANADVr_PROTOCOL_SELf_GET
#define G_ANADVr_PROTOCOL_SELf_SET BCM53128_A0_G_ANADVr_PROTOCOL_SELf_SET
#define G_ANADVr_ADV_B10Tf_GET BCM53128_A0_G_ANADVr_ADV_B10Tf_GET
#define G_ANADVr_ADV_B10Tf_SET BCM53128_A0_G_ANADVr_ADV_B10Tf_SET
#define G_ANADVr_ADV_B10T_FDXf_GET BCM53128_A0_G_ANADVr_ADV_B10T_FDXf_GET
#define G_ANADVr_ADV_B10T_FDXf_SET BCM53128_A0_G_ANADVr_ADV_B10T_FDXf_SET
#define G_ANADVr_ADV_B100Xf_GET BCM53128_A0_G_ANADVr_ADV_B100Xf_GET
#define G_ANADVr_ADV_B100Xf_SET BCM53128_A0_G_ANADVr_ADV_B100Xf_SET
#define G_ANADVr_ADV_B100_FDXf_GET BCM53128_A0_G_ANADVr_ADV_B100_FDXf_GET
#define G_ANADVr_ADV_B100_FDXf_SET BCM53128_A0_G_ANADVr_ADV_B100_FDXf_SET
#define G_ANADVr_B100T4f_GET BCM53128_A0_G_ANADVr_B100T4f_GET
#define G_ANADVr_B100T4f_SET BCM53128_A0_G_ANADVr_B100T4f_SET
#define G_ANADVr_ADV_PAUSE_CAPf_GET BCM53128_A0_G_ANADVr_ADV_PAUSE_CAPf_GET
#define G_ANADVr_ADV_PAUSE_CAPf_SET BCM53128_A0_G_ANADVr_ADV_PAUSE_CAPf_SET
#define G_ANADVr_ASY_PAUSEf_GET BCM53128_A0_G_ANADVr_ASY_PAUSEf_GET
#define G_ANADVr_ASY_PAUSEf_SET BCM53128_A0_G_ANADVr_ASY_PAUSEf_SET
#define G_ANADVr_RESERVED_1f_GET BCM53128_A0_G_ANADVr_RESERVED_1f_GET
#define G_ANADVr_RESERVED_1f_SET BCM53128_A0_G_ANADVr_RESERVED_1f_SET
#define G_ANADVr_REMOTE_FAULTf_GET BCM53128_A0_G_ANADVr_REMOTE_FAULTf_GET
#define G_ANADVr_REMOTE_FAULTf_SET BCM53128_A0_G_ANADVr_REMOTE_FAULTf_SET
#define G_ANADVr_RESERVED_2f_GET BCM53128_A0_G_ANADVr_RESERVED_2f_GET
#define G_ANADVr_RESERVED_2f_SET BCM53128_A0_G_ANADVr_RESERVED_2f_SET
#define G_ANADVr_NEXT_PAGEf_GET BCM53128_A0_G_ANADVr_NEXT_PAGEf_GET
#define G_ANADVr_NEXT_PAGEf_SET BCM53128_A0_G_ANADVr_NEXT_PAGEf_SET
#define READ_G_ANADVr BCM53128_A0_READ_G_ANADVr
#define WRITE_G_ANADVr BCM53128_A0_WRITE_G_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANADV_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANADV_EXTr 0x00008808

#define BCM53128_A0_G_ANADV_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT.
 *
 */
typedef union BCM53128_A0_G_ANADV_EXTr_s {
	uint32_t v[1];
	uint32_t g_anadv_ext[1];
	uint32_t _g_anadv_ext;
} BCM53128_A0_G_ANADV_EXTr_t;

#define BCM53128_A0_G_ANADV_EXTr_CLR(r) (r).g_anadv_ext[0] = 0
#define BCM53128_A0_G_ANADV_EXTr_SET(r,d) (r).g_anadv_ext[0] = d
#define BCM53128_A0_G_ANADV_EXTr_GET(r) (r).g_anadv_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext[0]) & 0x1f)
#define BCM53128_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_G_ANADV_EXTr_ADV_B10Tf_GET(r) ((((r).g_anadv_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_ADV_B10Tf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 6) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_ANADV_EXTr_ADV_B100Xf_GET(r) ((((r).g_anadv_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_ADV_B100Xf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_ANADV_EXTr_B100T4f_GET(r) ((((r).g_anadv_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_B100T4f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_ANADV_EXTr_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANADV_EXTr_RESERVED_1f_GET(r) ((((r).g_anadv_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_RESERVED_1f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANADV_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANADV_EXTr_RESERVED_2f_GET(r) ((((r).g_anadv_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_RESERVED_2f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANADV_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANADV_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT.
 *
 */
#define BCM53128_A0_READ_G_ANADV_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANADV_EXTr,(r._g_anadv_ext),2)
#define BCM53128_A0_WRITE_G_ANADV_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANADV_EXTr,&(r._g_anadv_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXTr BCM53128_A0_G_ANADV_EXTr
#define G_ANADV_EXTr_SIZE BCM53128_A0_G_ANADV_EXTr_SIZE
typedef BCM53128_A0_G_ANADV_EXTr_t G_ANADV_EXTr_t;
#define G_ANADV_EXTr_CLR BCM53128_A0_G_ANADV_EXTr_CLR
#define G_ANADV_EXTr_SET BCM53128_A0_G_ANADV_EXTr_SET
#define G_ANADV_EXTr_GET BCM53128_A0_G_ANADV_EXTr_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_GET BCM53128_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_SET BCM53128_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET
#define G_ANADV_EXTr_ADV_B10Tf_GET BCM53128_A0_G_ANADV_EXTr_ADV_B10Tf_GET
#define G_ANADV_EXTr_ADV_B10Tf_SET BCM53128_A0_G_ANADV_EXTr_ADV_B10Tf_SET
#define G_ANADV_EXTr_ADV_B10T_FDXf_GET BCM53128_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET
#define G_ANADV_EXTr_ADV_B10T_FDXf_SET BCM53128_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET
#define G_ANADV_EXTr_ADV_B100Xf_GET BCM53128_A0_G_ANADV_EXTr_ADV_B100Xf_GET
#define G_ANADV_EXTr_ADV_B100Xf_SET BCM53128_A0_G_ANADV_EXTr_ADV_B100Xf_SET
#define G_ANADV_EXTr_ADV_B100_FDXf_GET BCM53128_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET
#define G_ANADV_EXTr_ADV_B100_FDXf_SET BCM53128_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET
#define G_ANADV_EXTr_B100T4f_GET BCM53128_A0_G_ANADV_EXTr_B100T4f_GET
#define G_ANADV_EXTr_B100T4f_SET BCM53128_A0_G_ANADV_EXTr_B100T4f_SET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_GET BCM53128_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_SET BCM53128_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXTr_ASY_PAUSEf_GET BCM53128_A0_G_ANADV_EXTr_ASY_PAUSEf_GET
#define G_ANADV_EXTr_ASY_PAUSEf_SET BCM53128_A0_G_ANADV_EXTr_ASY_PAUSEf_SET
#define G_ANADV_EXTr_RESERVED_1f_GET BCM53128_A0_G_ANADV_EXTr_RESERVED_1f_GET
#define G_ANADV_EXTr_RESERVED_1f_SET BCM53128_A0_G_ANADV_EXTr_RESERVED_1f_SET
#define G_ANADV_EXTr_REMOTE_FAULTf_GET BCM53128_A0_G_ANADV_EXTr_REMOTE_FAULTf_GET
#define G_ANADV_EXTr_REMOTE_FAULTf_SET BCM53128_A0_G_ANADV_EXTr_REMOTE_FAULTf_SET
#define G_ANADV_EXTr_RESERVED_2f_GET BCM53128_A0_G_ANADV_EXTr_RESERVED_2f_GET
#define G_ANADV_EXTr_RESERVED_2f_SET BCM53128_A0_G_ANADV_EXTr_RESERVED_2f_SET
#define G_ANADV_EXTr_NEXT_PAGEf_GET BCM53128_A0_G_ANADV_EXTr_NEXT_PAGEf_GET
#define G_ANADV_EXTr_NEXT_PAGEf_SET BCM53128_A0_G_ANADV_EXTr_NEXT_PAGEf_SET
#define READ_G_ANADV_EXTr BCM53128_A0_READ_G_ANADV_EXTr
#define WRITE_G_ANADV_EXTr BCM53128_A0_WRITE_G_ANADV_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANADV_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANADV_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANADV_EXT_P7r 0x00008708

#define BCM53128_A0_G_ANADV_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_ANADV_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_anadv_ext_p7[1];
	uint32_t _g_anadv_ext_p7;
} BCM53128_A0_G_ANADV_EXT_P7r_t;

#define BCM53128_A0_G_ANADV_EXT_P7r_CLR(r) (r).g_anadv_ext_p7[0] = 0
#define BCM53128_A0_G_ANADV_EXT_P7r_SET(r,d) (r).g_anadv_ext_p7[0] = d
#define BCM53128_A0_G_ANADV_EXT_P7r_GET(r) (r).g_anadv_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANADV_EXT_P7r_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext_p7[0]) & 0x1f)
#define BCM53128_A0_G_ANADV_EXT_P7r_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10Tf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10Tf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 6) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100Xf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100Xf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_ANADV_EXT_P7r_B100T4f_GET(r) ((((r).g_anadv_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_B100T4f_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_ANADV_EXT_P7r_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_1f_GET(r) ((((r).g_anadv_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_1f_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANADV_EXT_P7r_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_2f_GET(r) ((((r).g_anadv_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_2f_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANADV_EXT_P7r_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANADV_EXT_P7r_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext_p7[0]=(((r).g_anadv_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_ANADV_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANADV_EXT_P7r,(r._g_anadv_ext_p7),2)
#define BCM53128_A0_WRITE_G_ANADV_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANADV_EXT_P7r,&(r._g_anadv_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXT_P7r BCM53128_A0_G_ANADV_EXT_P7r
#define G_ANADV_EXT_P7r_SIZE BCM53128_A0_G_ANADV_EXT_P7r_SIZE
typedef BCM53128_A0_G_ANADV_EXT_P7r_t G_ANADV_EXT_P7r_t;
#define G_ANADV_EXT_P7r_CLR BCM53128_A0_G_ANADV_EXT_P7r_CLR
#define G_ANADV_EXT_P7r_SET BCM53128_A0_G_ANADV_EXT_P7r_SET
#define G_ANADV_EXT_P7r_GET BCM53128_A0_G_ANADV_EXT_P7r_GET
#define G_ANADV_EXT_P7r_PROTOCOL_SELf_GET BCM53128_A0_G_ANADV_EXT_P7r_PROTOCOL_SELf_GET
#define G_ANADV_EXT_P7r_PROTOCOL_SELf_SET BCM53128_A0_G_ANADV_EXT_P7r_PROTOCOL_SELf_SET
#define G_ANADV_EXT_P7r_ADV_B10Tf_GET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10Tf_GET
#define G_ANADV_EXT_P7r_ADV_B10Tf_SET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10Tf_SET
#define G_ANADV_EXT_P7r_ADV_B10T_FDXf_GET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10T_FDXf_GET
#define G_ANADV_EXT_P7r_ADV_B10T_FDXf_SET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B10T_FDXf_SET
#define G_ANADV_EXT_P7r_ADV_B100Xf_GET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100Xf_GET
#define G_ANADV_EXT_P7r_ADV_B100Xf_SET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100Xf_SET
#define G_ANADV_EXT_P7r_ADV_B100_FDXf_GET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100_FDXf_GET
#define G_ANADV_EXT_P7r_ADV_B100_FDXf_SET BCM53128_A0_G_ANADV_EXT_P7r_ADV_B100_FDXf_SET
#define G_ANADV_EXT_P7r_B100T4f_GET BCM53128_A0_G_ANADV_EXT_P7r_B100T4f_GET
#define G_ANADV_EXT_P7r_B100T4f_SET BCM53128_A0_G_ANADV_EXT_P7r_B100T4f_SET
#define G_ANADV_EXT_P7r_ADV_PAUSE_CAPf_GET BCM53128_A0_G_ANADV_EXT_P7r_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXT_P7r_ADV_PAUSE_CAPf_SET BCM53128_A0_G_ANADV_EXT_P7r_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXT_P7r_ASY_PAUSEf_GET BCM53128_A0_G_ANADV_EXT_P7r_ASY_PAUSEf_GET
#define G_ANADV_EXT_P7r_ASY_PAUSEf_SET BCM53128_A0_G_ANADV_EXT_P7r_ASY_PAUSEf_SET
#define G_ANADV_EXT_P7r_RESERVED_1f_GET BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_1f_GET
#define G_ANADV_EXT_P7r_RESERVED_1f_SET BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_1f_SET
#define G_ANADV_EXT_P7r_REMOTE_FAULTf_GET BCM53128_A0_G_ANADV_EXT_P7r_REMOTE_FAULTf_GET
#define G_ANADV_EXT_P7r_REMOTE_FAULTf_SET BCM53128_A0_G_ANADV_EXT_P7r_REMOTE_FAULTf_SET
#define G_ANADV_EXT_P7r_RESERVED_2f_GET BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_2f_GET
#define G_ANADV_EXT_P7r_RESERVED_2f_SET BCM53128_A0_G_ANADV_EXT_P7r_RESERVED_2f_SET
#define G_ANADV_EXT_P7r_NEXT_PAGEf_GET BCM53128_A0_G_ANADV_EXT_P7r_NEXT_PAGEf_GET
#define G_ANADV_EXT_P7r_NEXT_PAGEf_SET BCM53128_A0_G_ANADV_EXT_P7r_NEXT_PAGEf_SET
#define READ_G_ANADV_EXT_P7r BCM53128_A0_READ_G_ANADV_EXT_P7r
#define WRITE_G_ANADV_EXT_P7r BCM53128_A0_WRITE_G_ANADV_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANADV_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANEXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANEXPr 0x0000100c

#define BCM53128_A0_G_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP.
 *
 */
typedef union BCM53128_A0_G_ANEXPr_s {
	uint32_t v[1];
	uint32_t g_anexp[1];
	uint32_t _g_anexp;
} BCM53128_A0_G_ANEXPr_t;

#define BCM53128_A0_G_ANEXPr_CLR(r) (r).g_anexp[0] = 0
#define BCM53128_A0_G_ANEXPr_SET(r,d) (r).g_anexp[0] = d
#define BCM53128_A0_G_ANEXPr_GET(r) (r).g_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANEXPr_LP_AN_ABIf_GET(r) (((r).g_anexp[0]) & 0x1)
#define BCM53128_A0_G_ANEXPr_LP_AN_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_ANEXPr_PAGE_RECf_GET(r) ((((r).g_anexp[0]) >> 1) & 0x1)
#define BCM53128_A0_G_ANEXPr_PAGE_RECf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 2) & 0x1)
#define BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 3) & 0x1)
#define BCM53128_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_ANEXPr_PAR_DET_FAILf_GET(r) ((((r).g_anexp[0]) >> 4) & 0x1)
#define BCM53128_A0_G_ANEXPr_PAR_DET_FAILf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_ANEXPr_NEXT_PAGEf_GET(r) ((((r).g_anexp[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANEXPr_NEXT_PAGEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp[0]) >> 6) & 0x1)
#define BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_ANEXPr_RESERVED_1f_GET(r) ((((r).g_anexp[0]) >> 7) & 0x1ff)
#define BCM53128_A0_G_ANEXPr_RESERVED_1f_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP.
 *
 */
#define BCM53128_A0_READ_G_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_ANEXPr,(r._g_anexp),2)
#define BCM53128_A0_WRITE_G_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_ANEXPr,&(r._g_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXPr BCM53128_A0_G_ANEXPr
#define G_ANEXPr_SIZE BCM53128_A0_G_ANEXPr_SIZE
typedef BCM53128_A0_G_ANEXPr_t G_ANEXPr_t;
#define G_ANEXPr_CLR BCM53128_A0_G_ANEXPr_CLR
#define G_ANEXPr_SET BCM53128_A0_G_ANEXPr_SET
#define G_ANEXPr_GET BCM53128_A0_G_ANEXPr_GET
#define G_ANEXPr_LP_AN_ABIf_GET BCM53128_A0_G_ANEXPr_LP_AN_ABIf_GET
#define G_ANEXPr_LP_AN_ABIf_SET BCM53128_A0_G_ANEXPr_LP_AN_ABIf_SET
#define G_ANEXPr_PAGE_RECf_GET BCM53128_A0_G_ANEXPr_PAGE_RECf_GET
#define G_ANEXPr_PAGE_RECf_SET BCM53128_A0_G_ANEXPr_PAGE_RECf_SET
#define G_ANEXPr_NEXT_PAGE_ABIf_GET BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_NEXT_PAGE_ABIf_SET BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_GET BCM53128_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_SET BCM53128_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_PAR_DET_FAILf_GET BCM53128_A0_G_ANEXPr_PAR_DET_FAILf_GET
#define G_ANEXPr_PAR_DET_FAILf_SET BCM53128_A0_G_ANEXPr_PAR_DET_FAILf_SET
#define G_ANEXPr_NEXT_PAGEf_GET BCM53128_A0_G_ANEXPr_NEXT_PAGEf_GET
#define G_ANEXPr_NEXT_PAGEf_SET BCM53128_A0_G_ANEXPr_NEXT_PAGEf_SET
#define G_ANEXPr_NEXT_PAGE_ABLEf_GET BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET
#define G_ANEXPr_NEXT_PAGE_ABLEf_SET BCM53128_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET
#define G_ANEXPr_RESERVED_1f_GET BCM53128_A0_G_ANEXPr_RESERVED_1f_GET
#define G_ANEXPr_RESERVED_1f_SET BCM53128_A0_G_ANEXPr_RESERVED_1f_SET
#define READ_G_ANEXPr BCM53128_A0_READ_G_ANEXPr
#define WRITE_G_ANEXPr BCM53128_A0_WRITE_G_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANEXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANEXP_EXTr 0x0000880c

#define BCM53128_A0_G_ANEXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT.
 *
 */
typedef union BCM53128_A0_G_ANEXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_anexp_ext[1];
	uint32_t _g_anexp_ext;
} BCM53128_A0_G_ANEXP_EXTr_t;

#define BCM53128_A0_G_ANEXP_EXTr_CLR(r) (r).g_anexp_ext[0] = 0
#define BCM53128_A0_G_ANEXP_EXTr_SET(r,d) (r).g_anexp_ext[0] = d
#define BCM53128_A0_G_ANEXP_EXTr_GET(r) (r).g_anexp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET(r) (((r).g_anexp_ext[0]) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_ANEXP_EXTr_PAGE_RECf_GET(r) ((((r).g_anexp_ext[0]) >> 1) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_PAGE_RECf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 2) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 3) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext[0]) >> 4) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext[0]) >> 6) & 0x1)
#define BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_ANEXP_EXTr_RESERVED_1f_GET(r) ((((r).g_anexp_ext[0]) >> 7) & 0x1ff)
#define BCM53128_A0_G_ANEXP_EXTr_RESERVED_1f_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT.
 *
 */
#define BCM53128_A0_READ_G_ANEXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANEXP_EXTr,(r._g_anexp_ext),2)
#define BCM53128_A0_WRITE_G_ANEXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANEXP_EXTr,&(r._g_anexp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXTr BCM53128_A0_G_ANEXP_EXTr
#define G_ANEXP_EXTr_SIZE BCM53128_A0_G_ANEXP_EXTr_SIZE
typedef BCM53128_A0_G_ANEXP_EXTr_t G_ANEXP_EXTr_t;
#define G_ANEXP_EXTr_CLR BCM53128_A0_G_ANEXP_EXTr_CLR
#define G_ANEXP_EXTr_SET BCM53128_A0_G_ANEXP_EXTr_SET
#define G_ANEXP_EXTr_GET BCM53128_A0_G_ANEXP_EXTr_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_GET BCM53128_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_SET BCM53128_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET
#define G_ANEXP_EXTr_PAGE_RECf_GET BCM53128_A0_G_ANEXP_EXTr_PAGE_RECf_GET
#define G_ANEXP_EXTr_PAGE_RECf_SET BCM53128_A0_G_ANEXP_EXTr_PAGE_RECf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET BCM53128_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET BCM53128_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_PAR_DET_FAILf_GET BCM53128_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET
#define G_ANEXP_EXTr_PAR_DET_FAILf_SET BCM53128_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET
#define G_ANEXP_EXTr_NEXT_PAGEf_GET BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET
#define G_ANEXP_EXTr_NEXT_PAGEf_SET BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET BCM53128_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXTr_RESERVED_1f_GET BCM53128_A0_G_ANEXP_EXTr_RESERVED_1f_GET
#define G_ANEXP_EXTr_RESERVED_1f_SET BCM53128_A0_G_ANEXP_EXTr_RESERVED_1f_SET
#define READ_G_ANEXP_EXTr BCM53128_A0_READ_G_ANEXP_EXTr
#define WRITE_G_ANEXP_EXTr BCM53128_A0_WRITE_G_ANEXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANEXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANEXP_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANEXP_EXT_P7r 0x0000870c

#define BCM53128_A0_G_ANEXP_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_ANEXP_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_anexp_ext_p7[1];
	uint32_t _g_anexp_ext_p7;
} BCM53128_A0_G_ANEXP_EXT_P7r_t;

#define BCM53128_A0_G_ANEXP_EXT_P7r_CLR(r) (r).g_anexp_ext_p7[0] = 0
#define BCM53128_A0_G_ANEXP_EXT_P7r_SET(r,d) (r).g_anexp_ext_p7[0] = d
#define BCM53128_A0_G_ANEXP_EXT_P7r_GET(r) (r).g_anexp_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANEXP_EXT_P7r_LP_AN_ABIf_GET(r) (((r).g_anexp_ext_p7[0]) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_ANEXP_EXT_P7r_PAGE_RECf_GET(r) ((((r).g_anexp_ext_p7[0]) >> 1) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_PAGE_RECf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p7[0]) >> 2) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_ANEXP_EXT_P7r_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p7[0]) >> 3) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_ANEXP_EXT_P7r_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext_p7[0]) >> 4) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext_p7[0]) >> 6) & 0x1)
#define BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_ANEXP_EXT_P7r_RESERVED_1f_GET(r) ((((r).g_anexp_ext_p7[0]) >> 7) & 0x1ff)
#define BCM53128_A0_G_ANEXP_EXT_P7r_RESERVED_1f_SET(r,f) (r).g_anexp_ext_p7[0]=(((r).g_anexp_ext_p7[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_ANEXP_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANEXP_EXT_P7r,(r._g_anexp_ext_p7),2)
#define BCM53128_A0_WRITE_G_ANEXP_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANEXP_EXT_P7r,&(r._g_anexp_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXT_P7r BCM53128_A0_G_ANEXP_EXT_P7r
#define G_ANEXP_EXT_P7r_SIZE BCM53128_A0_G_ANEXP_EXT_P7r_SIZE
typedef BCM53128_A0_G_ANEXP_EXT_P7r_t G_ANEXP_EXT_P7r_t;
#define G_ANEXP_EXT_P7r_CLR BCM53128_A0_G_ANEXP_EXT_P7r_CLR
#define G_ANEXP_EXT_P7r_SET BCM53128_A0_G_ANEXP_EXT_P7r_SET
#define G_ANEXP_EXT_P7r_GET BCM53128_A0_G_ANEXP_EXT_P7r_GET
#define G_ANEXP_EXT_P7r_LP_AN_ABIf_GET BCM53128_A0_G_ANEXP_EXT_P7r_LP_AN_ABIf_GET
#define G_ANEXP_EXT_P7r_LP_AN_ABIf_SET BCM53128_A0_G_ANEXP_EXT_P7r_LP_AN_ABIf_SET
#define G_ANEXP_EXT_P7r_PAGE_RECf_GET BCM53128_A0_G_ANEXP_EXT_P7r_PAGE_RECf_GET
#define G_ANEXP_EXT_P7r_PAGE_RECf_SET BCM53128_A0_G_ANEXP_EXT_P7r_PAGE_RECf_SET
#define G_ANEXP_EXT_P7r_NEXT_PAGE_ABIf_GET BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P7r_NEXT_PAGE_ABIf_SET BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P7r_LP_NEXT_PAGE_ABIf_GET BCM53128_A0_G_ANEXP_EXT_P7r_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P7r_LP_NEXT_PAGE_ABIf_SET BCM53128_A0_G_ANEXP_EXT_P7r_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P7r_PAR_DET_FAILf_GET BCM53128_A0_G_ANEXP_EXT_P7r_PAR_DET_FAILf_GET
#define G_ANEXP_EXT_P7r_PAR_DET_FAILf_SET BCM53128_A0_G_ANEXP_EXT_P7r_PAR_DET_FAILf_SET
#define G_ANEXP_EXT_P7r_NEXT_PAGEf_GET BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGEf_GET
#define G_ANEXP_EXT_P7r_NEXT_PAGEf_SET BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGEf_SET
#define G_ANEXP_EXT_P7r_NEXT_PAGE_ABLEf_GET BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXT_P7r_NEXT_PAGE_ABLEf_SET BCM53128_A0_G_ANEXP_EXT_P7r_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXT_P7r_RESERVED_1f_GET BCM53128_A0_G_ANEXP_EXT_P7r_RESERVED_1f_GET
#define G_ANEXP_EXT_P7r_RESERVED_1f_SET BCM53128_A0_G_ANEXP_EXT_P7r_RESERVED_1f_SET
#define READ_G_ANEXP_EXT_P7r BCM53128_A0_READ_G_ANEXP_EXT_P7r
#define WRITE_G_ANEXP_EXT_P7r BCM53128_A0_WRITE_G_ANEXP_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANEXP_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANLPA
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANLPAr 0x0000100a

#define BCM53128_A0_G_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA.
 *
 */
typedef union BCM53128_A0_G_ANLPAr_s {
	uint32_t v[1];
	uint32_t g_anlpa[1];
	uint32_t _g_anlpa;
} BCM53128_A0_G_ANLPAr_t;

#define BCM53128_A0_G_ANLPAr_CLR(r) (r).g_anlpa[0] = 0
#define BCM53128_A0_G_ANLPAr_SET(r,d) (r).g_anlpa[0] = d
#define BCM53128_A0_G_ANLPAr_GET(r) (r).g_anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANLPAr_PROTOCOL_SELf_GET(r) (((r).g_anlpa[0]) & 0x1f)
#define BCM53128_A0_G_ANLPAr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_G_ANLPAr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANLPAr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANLPAr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 7) & 0x1)
#define BCM53128_A0_G_ANLPAr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_ANLPAr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 8) & 0x1)
#define BCM53128_A0_G_ANLPAr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_ANLPAr_B100T4_CAPf_GET(r) ((((r).g_anlpa[0]) >> 9) & 0x1)
#define BCM53128_A0_G_ANLPAr_B100T4_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_ANLPAr_PAUSE_CAPf_GET(r) ((((r).g_anlpa[0]) >> 10) & 0x1)
#define BCM53128_A0_G_ANLPAr_PAUSE_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANLPAr_RESERVED_1f_GET(r) ((((r).g_anlpa[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANLPAr_RESERVED_1f_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANLPAr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANLPAr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANLPAr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANLPAr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANLPAr_NEXT_PAGEf_GET(r) ((((r).g_anlpa[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANLPAr_NEXT_PAGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA.
 *
 */
#define BCM53128_A0_READ_G_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_ANLPAr,(r._g_anlpa),2)
#define BCM53128_A0_WRITE_G_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_ANLPAr,&(r._g_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPAr BCM53128_A0_G_ANLPAr
#define G_ANLPAr_SIZE BCM53128_A0_G_ANLPAr_SIZE
typedef BCM53128_A0_G_ANLPAr_t G_ANLPAr_t;
#define G_ANLPAr_CLR BCM53128_A0_G_ANLPAr_CLR
#define G_ANLPAr_SET BCM53128_A0_G_ANLPAr_SET
#define G_ANLPAr_GET BCM53128_A0_G_ANLPAr_GET
#define G_ANLPAr_PROTOCOL_SELf_GET BCM53128_A0_G_ANLPAr_PROTOCOL_SELf_GET
#define G_ANLPAr_PROTOCOL_SELf_SET BCM53128_A0_G_ANLPAr_PROTOCOL_SELf_SET
#define G_ANLPAr_B10T_FD_CAPf_GET BCM53128_A0_G_ANLPAr_B10T_FD_CAPf_GET
#define G_ANLPAr_B10T_FD_CAPf_SET BCM53128_A0_G_ANLPAr_B10T_FD_CAPf_SET
#define G_ANLPAr_B100_TXHD_CAPf_GET BCM53128_A0_G_ANLPAr_B100_TXHD_CAPf_GET
#define G_ANLPAr_B100_TXHD_CAPf_SET BCM53128_A0_G_ANLPAr_B100_TXHD_CAPf_SET
#define G_ANLPAr_B100_TXFD_CAPf_GET BCM53128_A0_G_ANLPAr_B100_TXFD_CAPf_GET
#define G_ANLPAr_B100_TXFD_CAPf_SET BCM53128_A0_G_ANLPAr_B100_TXFD_CAPf_SET
#define G_ANLPAr_B100T4_CAPf_GET BCM53128_A0_G_ANLPAr_B100T4_CAPf_GET
#define G_ANLPAr_B100T4_CAPf_SET BCM53128_A0_G_ANLPAr_B100T4_CAPf_SET
#define G_ANLPAr_PAUSE_CAPf_GET BCM53128_A0_G_ANLPAr_PAUSE_CAPf_GET
#define G_ANLPAr_PAUSE_CAPf_SET BCM53128_A0_G_ANLPAr_PAUSE_CAPf_SET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_GET BCM53128_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_SET BCM53128_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPAr_RESERVED_1f_GET BCM53128_A0_G_ANLPAr_RESERVED_1f_GET
#define G_ANLPAr_RESERVED_1f_SET BCM53128_A0_G_ANLPAr_RESERVED_1f_SET
#define G_ANLPAr_REMOTE_FAULTf_GET BCM53128_A0_G_ANLPAr_REMOTE_FAULTf_GET
#define G_ANLPAr_REMOTE_FAULTf_SET BCM53128_A0_G_ANLPAr_REMOTE_FAULTf_SET
#define G_ANLPAr_ACKNOWLEDGEf_GET BCM53128_A0_G_ANLPAr_ACKNOWLEDGEf_GET
#define G_ANLPAr_ACKNOWLEDGEf_SET BCM53128_A0_G_ANLPAr_ACKNOWLEDGEf_SET
#define G_ANLPAr_NEXT_PAGEf_GET BCM53128_A0_G_ANLPAr_NEXT_PAGEf_GET
#define G_ANLPAr_NEXT_PAGEf_SET BCM53128_A0_G_ANLPAr_NEXT_PAGEf_SET
#define READ_G_ANLPAr BCM53128_A0_READ_G_ANLPAr
#define WRITE_G_ANLPAr BCM53128_A0_WRITE_G_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANLPA_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANLPA_EXTr 0x0000880a

#define BCM53128_A0_G_ANLPA_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT.
 *
 */
typedef union BCM53128_A0_G_ANLPA_EXTr_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext[1];
	uint32_t _g_anlpa_ext;
} BCM53128_A0_G_ANLPA_EXTr_t;

#define BCM53128_A0_G_ANLPA_EXTr_CLR(r) (r).g_anlpa_ext[0] = 0
#define BCM53128_A0_G_ANLPA_EXTr_SET(r,d) (r).g_anlpa_ext[0] = d
#define BCM53128_A0_G_ANLPA_EXTr_GET(r) (r).g_anlpa_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext[0]) & 0x1f)
#define BCM53128_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_ANLPA_EXTr_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANLPA_EXTr_RESERVED_1f_GET(r) ((((r).g_anlpa_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_RESERVED_1f_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANLPA_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT.
 *
 */
#define BCM53128_A0_READ_G_ANLPA_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANLPA_EXTr,(r._g_anlpa_ext),2)
#define BCM53128_A0_WRITE_G_ANLPA_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANLPA_EXTr,&(r._g_anlpa_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXTr BCM53128_A0_G_ANLPA_EXTr
#define G_ANLPA_EXTr_SIZE BCM53128_A0_G_ANLPA_EXTr_SIZE
typedef BCM53128_A0_G_ANLPA_EXTr_t G_ANLPA_EXTr_t;
#define G_ANLPA_EXTr_CLR BCM53128_A0_G_ANLPA_EXTr_CLR
#define G_ANLPA_EXTr_SET BCM53128_A0_G_ANLPA_EXTr_SET
#define G_ANLPA_EXTr_GET BCM53128_A0_G_ANLPA_EXTr_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_GET BCM53128_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_SET BCM53128_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET
#define G_ANLPA_EXTr_B10T_FD_CAPf_GET BCM53128_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET
#define G_ANLPA_EXTr_B10T_FD_CAPf_SET BCM53128_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_GET BCM53128_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_SET BCM53128_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_GET BCM53128_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_SET BCM53128_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET
#define G_ANLPA_EXTr_B100T4_CAPf_GET BCM53128_A0_G_ANLPA_EXTr_B100T4_CAPf_GET
#define G_ANLPA_EXTr_B100T4_CAPf_SET BCM53128_A0_G_ANLPA_EXTr_B100T4_CAPf_SET
#define G_ANLPA_EXTr_PAUSE_CAPf_GET BCM53128_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET
#define G_ANLPA_EXTr_PAUSE_CAPf_SET BCM53128_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET BCM53128_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET BCM53128_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXTr_RESERVED_1f_GET BCM53128_A0_G_ANLPA_EXTr_RESERVED_1f_GET
#define G_ANLPA_EXTr_RESERVED_1f_SET BCM53128_A0_G_ANLPA_EXTr_RESERVED_1f_SET
#define G_ANLPA_EXTr_REMOTE_FAULTf_GET BCM53128_A0_G_ANLPA_EXTr_REMOTE_FAULTf_GET
#define G_ANLPA_EXTr_REMOTE_FAULTf_SET BCM53128_A0_G_ANLPA_EXTr_REMOTE_FAULTf_SET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_GET BCM53128_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_SET BCM53128_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET
#define G_ANLPA_EXTr_NEXT_PAGEf_GET BCM53128_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET
#define G_ANLPA_EXTr_NEXT_PAGEf_SET BCM53128_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXTr BCM53128_A0_READ_G_ANLPA_EXTr
#define WRITE_G_ANLPA_EXTr BCM53128_A0_WRITE_G_ANLPA_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANLPA_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANLPA_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANLPA_EXT_P7r 0x0000870a

#define BCM53128_A0_G_ANLPA_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_ANLPA_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext_p7[1];
	uint32_t _g_anlpa_ext_p7;
} BCM53128_A0_G_ANLPA_EXT_P7r_t;

#define BCM53128_A0_G_ANLPA_EXT_P7r_CLR(r) (r).g_anlpa_ext_p7[0] = 0
#define BCM53128_A0_G_ANLPA_EXT_P7r_SET(r,d) (r).g_anlpa_ext_p7[0] = d
#define BCM53128_A0_G_ANLPA_EXT_P7r_GET(r) (r).g_anlpa_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANLPA_EXT_P7r_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext_p7[0]) & 0x1f)
#define BCM53128_A0_G_ANLPA_EXT_P7r_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_G_ANLPA_EXT_P7r_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_ANLPA_EXT_P7r_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_ANLPA_EXT_P7r_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_ANLPA_EXT_P7r_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANLPA_EXT_P7r_RESERVED_1f_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_RESERVED_1f_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANLPA_EXT_P7r_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANLPA_EXT_P7r_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANLPA_EXT_P7r_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANLPA_EXT_P7r_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext_p7[0]=(((r).g_anlpa_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_ANLPA_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANLPA_EXT_P7r,(r._g_anlpa_ext_p7),2)
#define BCM53128_A0_WRITE_G_ANLPA_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANLPA_EXT_P7r,&(r._g_anlpa_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXT_P7r BCM53128_A0_G_ANLPA_EXT_P7r
#define G_ANLPA_EXT_P7r_SIZE BCM53128_A0_G_ANLPA_EXT_P7r_SIZE
typedef BCM53128_A0_G_ANLPA_EXT_P7r_t G_ANLPA_EXT_P7r_t;
#define G_ANLPA_EXT_P7r_CLR BCM53128_A0_G_ANLPA_EXT_P7r_CLR
#define G_ANLPA_EXT_P7r_SET BCM53128_A0_G_ANLPA_EXT_P7r_SET
#define G_ANLPA_EXT_P7r_GET BCM53128_A0_G_ANLPA_EXT_P7r_GET
#define G_ANLPA_EXT_P7r_PROTOCOL_SELf_GET BCM53128_A0_G_ANLPA_EXT_P7r_PROTOCOL_SELf_GET
#define G_ANLPA_EXT_P7r_PROTOCOL_SELf_SET BCM53128_A0_G_ANLPA_EXT_P7r_PROTOCOL_SELf_SET
#define G_ANLPA_EXT_P7r_B10T_FD_CAPf_GET BCM53128_A0_G_ANLPA_EXT_P7r_B10T_FD_CAPf_GET
#define G_ANLPA_EXT_P7r_B10T_FD_CAPf_SET BCM53128_A0_G_ANLPA_EXT_P7r_B10T_FD_CAPf_SET
#define G_ANLPA_EXT_P7r_B100_TXHD_CAPf_GET BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXHD_CAPf_GET
#define G_ANLPA_EXT_P7r_B100_TXHD_CAPf_SET BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXHD_CAPf_SET
#define G_ANLPA_EXT_P7r_B100_TXFD_CAPf_GET BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXFD_CAPf_GET
#define G_ANLPA_EXT_P7r_B100_TXFD_CAPf_SET BCM53128_A0_G_ANLPA_EXT_P7r_B100_TXFD_CAPf_SET
#define G_ANLPA_EXT_P7r_B100T4_CAPf_GET BCM53128_A0_G_ANLPA_EXT_P7r_B100T4_CAPf_GET
#define G_ANLPA_EXT_P7r_B100T4_CAPf_SET BCM53128_A0_G_ANLPA_EXT_P7r_B100T4_CAPf_SET
#define G_ANLPA_EXT_P7r_PAUSE_CAPf_GET BCM53128_A0_G_ANLPA_EXT_P7r_PAUSE_CAPf_GET
#define G_ANLPA_EXT_P7r_PAUSE_CAPf_SET BCM53128_A0_G_ANLPA_EXT_P7r_PAUSE_CAPf_SET
#define G_ANLPA_EXT_P7r_LK_PAR_ASYM_CAPf_GET BCM53128_A0_G_ANLPA_EXT_P7r_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXT_P7r_LK_PAR_ASYM_CAPf_SET BCM53128_A0_G_ANLPA_EXT_P7r_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXT_P7r_RESERVED_1f_GET BCM53128_A0_G_ANLPA_EXT_P7r_RESERVED_1f_GET
#define G_ANLPA_EXT_P7r_RESERVED_1f_SET BCM53128_A0_G_ANLPA_EXT_P7r_RESERVED_1f_SET
#define G_ANLPA_EXT_P7r_REMOTE_FAULTf_GET BCM53128_A0_G_ANLPA_EXT_P7r_REMOTE_FAULTf_GET
#define G_ANLPA_EXT_P7r_REMOTE_FAULTf_SET BCM53128_A0_G_ANLPA_EXT_P7r_REMOTE_FAULTf_SET
#define G_ANLPA_EXT_P7r_ACKNOWLEDGEf_GET BCM53128_A0_G_ANLPA_EXT_P7r_ACKNOWLEDGEf_GET
#define G_ANLPA_EXT_P7r_ACKNOWLEDGEf_SET BCM53128_A0_G_ANLPA_EXT_P7r_ACKNOWLEDGEf_SET
#define G_ANLPA_EXT_P7r_NEXT_PAGEf_GET BCM53128_A0_G_ANLPA_EXT_P7r_NEXT_PAGEf_GET
#define G_ANLPA_EXT_P7r_NEXT_PAGEf_SET BCM53128_A0_G_ANLPA_EXT_P7r_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXT_P7r BCM53128_A0_READ_G_ANLPA_EXT_P7r
#define WRITE_G_ANLPA_EXT_P7r BCM53128_A0_WRITE_G_ANLPA_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANLPA_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANNXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANNXPr 0x0000100e

#define BCM53128_A0_G_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP.
 *
 */
typedef union BCM53128_A0_G_ANNXPr_s {
	uint32_t v[1];
	uint32_t g_annxp[1];
	uint32_t _g_annxp;
} BCM53128_A0_G_ANNXPr_t;

#define BCM53128_A0_G_ANNXPr_CLR(r) (r).g_annxp[0] = 0
#define BCM53128_A0_G_ANNXPr_SET(r,d) (r).g_annxp[0] = d
#define BCM53128_A0_G_ANNXPr_GET(r) (r).g_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANNXPr_CODE_FIELDf_GET(r) ((((r).g_annxp[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANNXPr_CODE_FIELDf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANNXPr_TOGGLEf_GET(r) ((((r).g_annxp[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANNXPr_TOGGLEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANNXPr_MES_PAGEf_GET(r) ((((r).g_annxp[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANNXPr_MES_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANNXPr_RESERVED_1f_GET(r) ((((r).g_annxp[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANNXPr_RESERVED_1f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANNXPr_NEXT_PAGEf_GET(r) ((((r).g_annxp[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANNXPr_NEXT_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP.
 *
 */
#define BCM53128_A0_READ_G_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_ANNXPr,(r._g_annxp),2)
#define BCM53128_A0_WRITE_G_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_ANNXPr,&(r._g_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXPr BCM53128_A0_G_ANNXPr
#define G_ANNXPr_SIZE BCM53128_A0_G_ANNXPr_SIZE
typedef BCM53128_A0_G_ANNXPr_t G_ANNXPr_t;
#define G_ANNXPr_CLR BCM53128_A0_G_ANNXPr_CLR
#define G_ANNXPr_SET BCM53128_A0_G_ANNXPr_SET
#define G_ANNXPr_GET BCM53128_A0_G_ANNXPr_GET
#define G_ANNXPr_CODE_FIELDf_GET BCM53128_A0_G_ANNXPr_CODE_FIELDf_GET
#define G_ANNXPr_CODE_FIELDf_SET BCM53128_A0_G_ANNXPr_CODE_FIELDf_SET
#define G_ANNXPr_TOGGLEf_GET BCM53128_A0_G_ANNXPr_TOGGLEf_GET
#define G_ANNXPr_TOGGLEf_SET BCM53128_A0_G_ANNXPr_TOGGLEf_SET
#define G_ANNXPr_ACKNOWLEDGE_2f_GET BCM53128_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET
#define G_ANNXPr_ACKNOWLEDGE_2f_SET BCM53128_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET
#define G_ANNXPr_MES_PAGEf_GET BCM53128_A0_G_ANNXPr_MES_PAGEf_GET
#define G_ANNXPr_MES_PAGEf_SET BCM53128_A0_G_ANNXPr_MES_PAGEf_SET
#define G_ANNXPr_RESERVED_1f_GET BCM53128_A0_G_ANNXPr_RESERVED_1f_GET
#define G_ANNXPr_RESERVED_1f_SET BCM53128_A0_G_ANNXPr_RESERVED_1f_SET
#define G_ANNXPr_NEXT_PAGEf_GET BCM53128_A0_G_ANNXPr_NEXT_PAGEf_GET
#define G_ANNXPr_NEXT_PAGEf_SET BCM53128_A0_G_ANNXPr_NEXT_PAGEf_SET
#define READ_G_ANNXPr BCM53128_A0_READ_G_ANNXPr
#define WRITE_G_ANNXPr BCM53128_A0_WRITE_G_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANNXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANNXP_EXTr 0x0000880e

#define BCM53128_A0_G_ANNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT.
 *
 */
typedef union BCM53128_A0_G_ANNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_annxp_ext[1];
	uint32_t _g_annxp_ext;
} BCM53128_A0_G_ANNXP_EXTr_t;

#define BCM53128_A0_G_ANNXP_EXTr_CLR(r) (r).g_annxp_ext[0] = 0
#define BCM53128_A0_G_ANNXP_EXTr_SET(r,d) (r).g_annxp_ext[0] = d
#define BCM53128_A0_G_ANNXP_EXTr_GET(r) (r).g_annxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_annxp_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANNXP_EXTr_TOGGLEf_GET(r) ((((r).g_annxp_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANNXP_EXTr_TOGGLEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANNXP_EXTr_RESERVED_1f_GET(r) ((((r).g_annxp_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANNXP_EXTr_RESERVED_1f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT.
 *
 */
#define BCM53128_A0_READ_G_ANNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANNXP_EXTr,(r._g_annxp_ext),2)
#define BCM53128_A0_WRITE_G_ANNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANNXP_EXTr,&(r._g_annxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXTr BCM53128_A0_G_ANNXP_EXTr
#define G_ANNXP_EXTr_SIZE BCM53128_A0_G_ANNXP_EXTr_SIZE
typedef BCM53128_A0_G_ANNXP_EXTr_t G_ANNXP_EXTr_t;
#define G_ANNXP_EXTr_CLR BCM53128_A0_G_ANNXP_EXTr_CLR
#define G_ANNXP_EXTr_SET BCM53128_A0_G_ANNXP_EXTr_SET
#define G_ANNXP_EXTr_GET BCM53128_A0_G_ANNXP_EXTr_GET
#define G_ANNXP_EXTr_CODE_FIELDf_GET BCM53128_A0_G_ANNXP_EXTr_CODE_FIELDf_GET
#define G_ANNXP_EXTr_CODE_FIELDf_SET BCM53128_A0_G_ANNXP_EXTr_CODE_FIELDf_SET
#define G_ANNXP_EXTr_TOGGLEf_GET BCM53128_A0_G_ANNXP_EXTr_TOGGLEf_GET
#define G_ANNXP_EXTr_TOGGLEf_SET BCM53128_A0_G_ANNXP_EXTr_TOGGLEf_SET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET BCM53128_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET BCM53128_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXTr_MES_PAGEf_GET BCM53128_A0_G_ANNXP_EXTr_MES_PAGEf_GET
#define G_ANNXP_EXTr_MES_PAGEf_SET BCM53128_A0_G_ANNXP_EXTr_MES_PAGEf_SET
#define G_ANNXP_EXTr_RESERVED_1f_GET BCM53128_A0_G_ANNXP_EXTr_RESERVED_1f_GET
#define G_ANNXP_EXTr_RESERVED_1f_SET BCM53128_A0_G_ANNXP_EXTr_RESERVED_1f_SET
#define G_ANNXP_EXTr_NEXT_PAGEf_GET BCM53128_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET
#define G_ANNXP_EXTr_NEXT_PAGEf_SET BCM53128_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXTr BCM53128_A0_READ_G_ANNXP_EXTr
#define WRITE_G_ANNXP_EXTr BCM53128_A0_WRITE_G_ANNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_ANNXP_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53128_A0_G_ANNXP_EXT_P7r 0x0000870e

#define BCM53128_A0_G_ANNXP_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_ANNXP_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_annxp_ext_p7[1];
	uint32_t _g_annxp_ext_p7;
} BCM53128_A0_G_ANNXP_EXT_P7r_t;

#define BCM53128_A0_G_ANNXP_EXT_P7r_CLR(r) (r).g_annxp_ext_p7[0] = 0
#define BCM53128_A0_G_ANNXP_EXT_P7r_SET(r,d) (r).g_annxp_ext_p7[0] = d
#define BCM53128_A0_G_ANNXP_EXT_P7r_GET(r) (r).g_annxp_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_ANNXP_EXT_P7r_CODE_FIELDf_GET(r) ((((r).g_annxp_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_ANNXP_EXT_P7r_CODE_FIELDf_SET(r,f) (r).g_annxp_ext_p7[0]=(((r).g_annxp_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_ANNXP_EXT_P7r_TOGGLEf_GET(r) ((((r).g_annxp_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_ANNXP_EXT_P7r_TOGGLEf_SET(r,f) (r).g_annxp_ext_p7[0]=(((r).g_annxp_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_ANNXP_EXT_P7r_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_ANNXP_EXT_P7r_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext_p7[0]=(((r).g_annxp_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_ANNXP_EXT_P7r_MES_PAGEf_GET(r) ((((r).g_annxp_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_ANNXP_EXT_P7r_MES_PAGEf_SET(r,f) (r).g_annxp_ext_p7[0]=(((r).g_annxp_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_ANNXP_EXT_P7r_RESERVED_1f_GET(r) ((((r).g_annxp_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_ANNXP_EXT_P7r_RESERVED_1f_SET(r,f) (r).g_annxp_ext_p7[0]=(((r).g_annxp_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_ANNXP_EXT_P7r_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_ANNXP_EXT_P7r_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext_p7[0]=(((r).g_annxp_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_ANNXP_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_ANNXP_EXT_P7r,(r._g_annxp_ext_p7),2)
#define BCM53128_A0_WRITE_G_ANNXP_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_ANNXP_EXT_P7r,&(r._g_annxp_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXT_P7r BCM53128_A0_G_ANNXP_EXT_P7r
#define G_ANNXP_EXT_P7r_SIZE BCM53128_A0_G_ANNXP_EXT_P7r_SIZE
typedef BCM53128_A0_G_ANNXP_EXT_P7r_t G_ANNXP_EXT_P7r_t;
#define G_ANNXP_EXT_P7r_CLR BCM53128_A0_G_ANNXP_EXT_P7r_CLR
#define G_ANNXP_EXT_P7r_SET BCM53128_A0_G_ANNXP_EXT_P7r_SET
#define G_ANNXP_EXT_P7r_GET BCM53128_A0_G_ANNXP_EXT_P7r_GET
#define G_ANNXP_EXT_P7r_CODE_FIELDf_GET BCM53128_A0_G_ANNXP_EXT_P7r_CODE_FIELDf_GET
#define G_ANNXP_EXT_P7r_CODE_FIELDf_SET BCM53128_A0_G_ANNXP_EXT_P7r_CODE_FIELDf_SET
#define G_ANNXP_EXT_P7r_TOGGLEf_GET BCM53128_A0_G_ANNXP_EXT_P7r_TOGGLEf_GET
#define G_ANNXP_EXT_P7r_TOGGLEf_SET BCM53128_A0_G_ANNXP_EXT_P7r_TOGGLEf_SET
#define G_ANNXP_EXT_P7r_ACKNOWLEDGE_2f_GET BCM53128_A0_G_ANNXP_EXT_P7r_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXT_P7r_ACKNOWLEDGE_2f_SET BCM53128_A0_G_ANNXP_EXT_P7r_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXT_P7r_MES_PAGEf_GET BCM53128_A0_G_ANNXP_EXT_P7r_MES_PAGEf_GET
#define G_ANNXP_EXT_P7r_MES_PAGEf_SET BCM53128_A0_G_ANNXP_EXT_P7r_MES_PAGEf_SET
#define G_ANNXP_EXT_P7r_RESERVED_1f_GET BCM53128_A0_G_ANNXP_EXT_P7r_RESERVED_1f_GET
#define G_ANNXP_EXT_P7r_RESERVED_1f_SET BCM53128_A0_G_ANNXP_EXT_P7r_RESERVED_1f_SET
#define G_ANNXP_EXT_P7r_NEXT_PAGEf_GET BCM53128_A0_G_ANNXP_EXT_P7r_NEXT_PAGEf_GET
#define G_ANNXP_EXT_P7r_NEXT_PAGEf_SET BCM53128_A0_G_ANNXP_EXT_P7r_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXT_P7r BCM53128_A0_READ_G_ANNXP_EXT_P7r
#define WRITE_G_ANNXP_EXT_P7r BCM53128_A0_WRITE_G_ANNXP_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_ANNXP_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_AUX_CTL
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53128_A0_G_AUX_CTLr 0x00001030

#define BCM53128_A0_G_AUX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL.
 *
 */
typedef union BCM53128_A0_G_AUX_CTLr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl[1];
	uint32_t _g_aux_ctl;
} BCM53128_A0_G_AUX_CTLr_t;

#define BCM53128_A0_G_AUX_CTLr_CLR(r) (r).g_aux_ctl[0] = 0
#define BCM53128_A0_G_AUX_CTLr_SET(r,d) (r).g_aux_ctl[0] = d
#define BCM53128_A0_G_AUX_CTLr_GET(r) (r).g_aux_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_AUX_CTLr_SHADOW_REGf_GET(r) (((r).g_aux_ctl[0]) & 0xffff)
#define BCM53128_A0_G_AUX_CTLr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl[0]=(((r).g_aux_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL.
 *
 */
#define BCM53128_A0_READ_G_AUX_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_AUX_CTLr,(r._g_aux_ctl),2)
#define BCM53128_A0_WRITE_G_AUX_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_AUX_CTLr,&(r._g_aux_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTLr BCM53128_A0_G_AUX_CTLr
#define G_AUX_CTLr_SIZE BCM53128_A0_G_AUX_CTLr_SIZE
typedef BCM53128_A0_G_AUX_CTLr_t G_AUX_CTLr_t;
#define G_AUX_CTLr_CLR BCM53128_A0_G_AUX_CTLr_CLR
#define G_AUX_CTLr_SET BCM53128_A0_G_AUX_CTLr_SET
#define G_AUX_CTLr_GET BCM53128_A0_G_AUX_CTLr_GET
#define G_AUX_CTLr_SHADOW_REGf_GET BCM53128_A0_G_AUX_CTLr_SHADOW_REGf_GET
#define G_AUX_CTLr_SHADOW_REGf_SET BCM53128_A0_G_AUX_CTLr_SHADOW_REGf_SET
#define READ_G_AUX_CTLr BCM53128_A0_READ_G_AUX_CTLr
#define WRITE_G_AUX_CTLr BCM53128_A0_WRITE_G_AUX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_AUX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_AUX_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53128_A0_G_AUX_CTL_EXTr 0x00008830

#define BCM53128_A0_G_AUX_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT.
 *
 */
typedef union BCM53128_A0_G_AUX_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext[1];
	uint32_t _g_aux_ctl_ext;
} BCM53128_A0_G_AUX_CTL_EXTr_t;

#define BCM53128_A0_G_AUX_CTL_EXTr_CLR(r) (r).g_aux_ctl_ext[0] = 0
#define BCM53128_A0_G_AUX_CTL_EXTr_SET(r,d) (r).g_aux_ctl_ext[0] = d
#define BCM53128_A0_G_AUX_CTL_EXTr_GET(r) (r).g_aux_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext[0]) & 0xffff)
#define BCM53128_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext[0]=(((r).g_aux_ctl_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT.
 *
 */
#define BCM53128_A0_READ_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_AUX_CTL_EXTr,(r._g_aux_ctl_ext),2)
#define BCM53128_A0_WRITE_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_AUX_CTL_EXTr,&(r._g_aux_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXTr BCM53128_A0_G_AUX_CTL_EXTr
#define G_AUX_CTL_EXTr_SIZE BCM53128_A0_G_AUX_CTL_EXTr_SIZE
typedef BCM53128_A0_G_AUX_CTL_EXTr_t G_AUX_CTL_EXTr_t;
#define G_AUX_CTL_EXTr_CLR BCM53128_A0_G_AUX_CTL_EXTr_CLR
#define G_AUX_CTL_EXTr_SET BCM53128_A0_G_AUX_CTL_EXTr_SET
#define G_AUX_CTL_EXTr_GET BCM53128_A0_G_AUX_CTL_EXTr_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_GET BCM53128_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_SET BCM53128_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXTr BCM53128_A0_READ_G_AUX_CTL_EXTr
#define WRITE_G_AUX_CTL_EXTr BCM53128_A0_WRITE_G_AUX_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_AUX_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_AUX_CTL_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53128_A0_G_AUX_CTL_EXT_P7r 0x00008730

#define BCM53128_A0_G_AUX_CTL_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_AUX_CTL_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext_p7[1];
	uint32_t _g_aux_ctl_ext_p7;
} BCM53128_A0_G_AUX_CTL_EXT_P7r_t;

#define BCM53128_A0_G_AUX_CTL_EXT_P7r_CLR(r) (r).g_aux_ctl_ext_p7[0] = 0
#define BCM53128_A0_G_AUX_CTL_EXT_P7r_SET(r,d) (r).g_aux_ctl_ext_p7[0] = d
#define BCM53128_A0_G_AUX_CTL_EXT_P7r_GET(r) (r).g_aux_ctl_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_AUX_CTL_EXT_P7r_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_AUX_CTL_EXT_P7r_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext_p7[0]=(((r).g_aux_ctl_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_AUX_CTL_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_AUX_CTL_EXT_P7r,(r._g_aux_ctl_ext_p7),2)
#define BCM53128_A0_WRITE_G_AUX_CTL_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_AUX_CTL_EXT_P7r,&(r._g_aux_ctl_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXT_P7r BCM53128_A0_G_AUX_CTL_EXT_P7r
#define G_AUX_CTL_EXT_P7r_SIZE BCM53128_A0_G_AUX_CTL_EXT_P7r_SIZE
typedef BCM53128_A0_G_AUX_CTL_EXT_P7r_t G_AUX_CTL_EXT_P7r_t;
#define G_AUX_CTL_EXT_P7r_CLR BCM53128_A0_G_AUX_CTL_EXT_P7r_CLR
#define G_AUX_CTL_EXT_P7r_SET BCM53128_A0_G_AUX_CTL_EXT_P7r_SET
#define G_AUX_CTL_EXT_P7r_GET BCM53128_A0_G_AUX_CTL_EXT_P7r_GET
#define G_AUX_CTL_EXT_P7r_SHADOW_REGf_GET BCM53128_A0_G_AUX_CTL_EXT_P7r_SHADOW_REGf_GET
#define G_AUX_CTL_EXT_P7r_SHADOW_REGf_SET BCM53128_A0_G_AUX_CTL_EXT_P7r_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXT_P7r BCM53128_A0_READ_G_AUX_CTL_EXT_P7r
#define WRITE_G_AUX_CTL_EXT_P7r BCM53128_A0_WRITE_G_AUX_CTL_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_AUX_CTL_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_AUX_STS
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53128_A0_G_AUX_STSr 0x00001032

#define BCM53128_A0_G_AUX_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS.
 *
 */
typedef union BCM53128_A0_G_AUX_STSr_s {
	uint32_t v[1];
	uint32_t g_aux_sts[1];
	uint32_t _g_aux_sts;
} BCM53128_A0_G_AUX_STSr_t;

#define BCM53128_A0_G_AUX_STSr_CLR(r) (r).g_aux_sts[0] = 0
#define BCM53128_A0_G_AUX_STSr_SET(r,d) (r).g_aux_sts[0] = d
#define BCM53128_A0_G_AUX_STSr_GET(r) (r).g_aux_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_AUX_STSr_AUX_STSf_GET(r) (((r).g_aux_sts[0]) & 0xffff)
#define BCM53128_A0_G_AUX_STSr_AUX_STSf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS.
 *
 */
#define BCM53128_A0_READ_G_AUX_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_AUX_STSr,(r._g_aux_sts),2)
#define BCM53128_A0_WRITE_G_AUX_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_AUX_STSr,&(r._g_aux_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STSr BCM53128_A0_G_AUX_STSr
#define G_AUX_STSr_SIZE BCM53128_A0_G_AUX_STSr_SIZE
typedef BCM53128_A0_G_AUX_STSr_t G_AUX_STSr_t;
#define G_AUX_STSr_CLR BCM53128_A0_G_AUX_STSr_CLR
#define G_AUX_STSr_SET BCM53128_A0_G_AUX_STSr_SET
#define G_AUX_STSr_GET BCM53128_A0_G_AUX_STSr_GET
#define G_AUX_STSr_AUX_STSf_GET BCM53128_A0_G_AUX_STSr_AUX_STSf_GET
#define G_AUX_STSr_AUX_STSf_SET BCM53128_A0_G_AUX_STSr_AUX_STSf_SET
#define READ_G_AUX_STSr BCM53128_A0_READ_G_AUX_STSr
#define WRITE_G_AUX_STSr BCM53128_A0_WRITE_G_AUX_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_AUX_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_AUX_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53128_A0_G_AUX_STS_EXTr 0x00008832

#define BCM53128_A0_G_AUX_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT.
 *
 */
typedef union BCM53128_A0_G_AUX_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext[1];
	uint32_t _g_aux_sts_ext;
} BCM53128_A0_G_AUX_STS_EXTr_t;

#define BCM53128_A0_G_AUX_STS_EXTr_CLR(r) (r).g_aux_sts_ext[0] = 0
#define BCM53128_A0_G_AUX_STS_EXTr_SET(r,d) (r).g_aux_sts_ext[0] = d
#define BCM53128_A0_G_AUX_STS_EXTr_GET(r) (r).g_aux_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_AUX_STS_EXTr_AUX_STSf_GET(r) (((r).g_aux_sts_ext[0]) & 0xffff)
#define BCM53128_A0_G_AUX_STS_EXTr_AUX_STSf_SET(r,f) (r).g_aux_sts_ext[0]=(((r).g_aux_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT.
 *
 */
#define BCM53128_A0_READ_G_AUX_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_AUX_STS_EXTr,(r._g_aux_sts_ext),2)
#define BCM53128_A0_WRITE_G_AUX_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_AUX_STS_EXTr,&(r._g_aux_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXTr BCM53128_A0_G_AUX_STS_EXTr
#define G_AUX_STS_EXTr_SIZE BCM53128_A0_G_AUX_STS_EXTr_SIZE
typedef BCM53128_A0_G_AUX_STS_EXTr_t G_AUX_STS_EXTr_t;
#define G_AUX_STS_EXTr_CLR BCM53128_A0_G_AUX_STS_EXTr_CLR
#define G_AUX_STS_EXTr_SET BCM53128_A0_G_AUX_STS_EXTr_SET
#define G_AUX_STS_EXTr_GET BCM53128_A0_G_AUX_STS_EXTr_GET
#define G_AUX_STS_EXTr_AUX_STSf_GET BCM53128_A0_G_AUX_STS_EXTr_AUX_STSf_GET
#define G_AUX_STS_EXTr_AUX_STSf_SET BCM53128_A0_G_AUX_STS_EXTr_AUX_STSf_SET
#define READ_G_AUX_STS_EXTr BCM53128_A0_READ_G_AUX_STS_EXTr
#define WRITE_G_AUX_STS_EXTr BCM53128_A0_WRITE_G_AUX_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_AUX_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_AUX_STS_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53128_A0_G_AUX_STS_EXT_P7r 0x00008732

#define BCM53128_A0_G_AUX_STS_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_AUX_STS_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext_p7[1];
	uint32_t _g_aux_sts_ext_p7;
} BCM53128_A0_G_AUX_STS_EXT_P7r_t;

#define BCM53128_A0_G_AUX_STS_EXT_P7r_CLR(r) (r).g_aux_sts_ext_p7[0] = 0
#define BCM53128_A0_G_AUX_STS_EXT_P7r_SET(r,d) (r).g_aux_sts_ext_p7[0] = d
#define BCM53128_A0_G_AUX_STS_EXT_P7r_GET(r) (r).g_aux_sts_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_AUX_STS_EXT_P7r_AUX_STSf_GET(r) (((r).g_aux_sts_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_AUX_STS_EXT_P7r_AUX_STSf_SET(r,f) (r).g_aux_sts_ext_p7[0]=(((r).g_aux_sts_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_AUX_STS_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_AUX_STS_EXT_P7r,(r._g_aux_sts_ext_p7),2)
#define BCM53128_A0_WRITE_G_AUX_STS_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_AUX_STS_EXT_P7r,&(r._g_aux_sts_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXT_P7r BCM53128_A0_G_AUX_STS_EXT_P7r
#define G_AUX_STS_EXT_P7r_SIZE BCM53128_A0_G_AUX_STS_EXT_P7r_SIZE
typedef BCM53128_A0_G_AUX_STS_EXT_P7r_t G_AUX_STS_EXT_P7r_t;
#define G_AUX_STS_EXT_P7r_CLR BCM53128_A0_G_AUX_STS_EXT_P7r_CLR
#define G_AUX_STS_EXT_P7r_SET BCM53128_A0_G_AUX_STS_EXT_P7r_SET
#define G_AUX_STS_EXT_P7r_GET BCM53128_A0_G_AUX_STS_EXT_P7r_GET
#define G_AUX_STS_EXT_P7r_AUX_STSf_GET BCM53128_A0_G_AUX_STS_EXT_P7r_AUX_STSf_GET
#define G_AUX_STS_EXT_P7r_AUX_STSf_SET BCM53128_A0_G_AUX_STS_EXT_P7r_AUX_STSf_SET
#define READ_G_AUX_STS_EXT_P7r BCM53128_A0_READ_G_AUX_STS_EXT_P7r
#define WRITE_G_AUX_STS_EXT_P7r BCM53128_A0_WRITE_G_AUX_STS_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_AUX_STS_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_B1000T_CTL
 * BLOCKS:   GPIC0
 * DESC:     1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53128_A0_G_B1000T_CTLr 0x00001012

#define BCM53128_A0_G_B1000T_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL.
 *
 */
typedef union BCM53128_A0_G_B1000T_CTLr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl[1];
	uint32_t _g_b1000t_ctl;
} BCM53128_A0_G_B1000T_CTLr_t;

#define BCM53128_A0_G_B1000T_CTLr_CLR(r) (r).g_b1000t_ctl[0] = 0
#define BCM53128_A0_G_B1000T_CTLr_SET(r,d) (r).g_b1000t_ctl[0] = d
#define BCM53128_A0_G_B1000T_CTLr_GET(r) (r).g_b1000t_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_B1000T_CTLr_RESERVEDf_GET(r) (((r).g_b1000t_ctl[0]) & 0xff)
#define BCM53128_A0_G_B1000T_CTLr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 8) & 0x1)
#define BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 9) & 0x1)
#define BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_B1000T_CTLr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 10) & 0x1)
#define BCM53128_A0_G_B1000T_CTLr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 11) & 0x1)
#define BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl[0]) >> 12) & 0x1)
#define BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_B1000T_CTLr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 13) & 0x7)
#define BCM53128_A0_G_B1000T_CTLr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL.
 *
 */
#define BCM53128_A0_READ_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_B1000T_CTLr,(r._g_b1000t_ctl),2)
#define BCM53128_A0_WRITE_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_B1000T_CTLr,&(r._g_b1000t_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTLr BCM53128_A0_G_B1000T_CTLr
#define G_B1000T_CTLr_SIZE BCM53128_A0_G_B1000T_CTLr_SIZE
typedef BCM53128_A0_G_B1000T_CTLr_t G_B1000T_CTLr_t;
#define G_B1000T_CTLr_CLR BCM53128_A0_G_B1000T_CTLr_CLR
#define G_B1000T_CTLr_SET BCM53128_A0_G_B1000T_CTLr_SET
#define G_B1000T_CTLr_GET BCM53128_A0_G_B1000T_CTLr_GET
#define G_B1000T_CTLr_RESERVEDf_GET BCM53128_A0_G_B1000T_CTLr_RESERVEDf_GET
#define G_B1000T_CTLr_RESERVEDf_SET BCM53128_A0_G_B1000T_CTLr_RESERVEDf_SET
#define G_B1000T_CTLr_ADV_B1000T_HDf_GET BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET
#define G_B1000T_CTLr_ADV_B1000T_HDf_SET BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET
#define G_B1000T_CTLr_ADV_B1000T_FDf_GET BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET
#define G_B1000T_CTLr_ADV_B1000T_FDf_SET BCM53128_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET
#define G_B1000T_CTLr_REPEATER_DTEf_GET BCM53128_A0_G_B1000T_CTLr_REPEATER_DTEf_GET
#define G_B1000T_CTLr_REPEATER_DTEf_SET BCM53128_A0_G_B1000T_CTLr_REPEATER_DTEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET BCM53128_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTLr_TEST_MODEf_GET BCM53128_A0_G_B1000T_CTLr_TEST_MODEf_GET
#define G_B1000T_CTLr_TEST_MODEf_SET BCM53128_A0_G_B1000T_CTLr_TEST_MODEf_SET
#define READ_G_B1000T_CTLr BCM53128_A0_READ_G_B1000T_CTLr
#define WRITE_G_B1000T_CTLr BCM53128_A0_WRITE_G_B1000T_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_B1000T_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_B1000T_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53128_A0_G_B1000T_CTL_EXTr 0x00008812

#define BCM53128_A0_G_B1000T_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT.
 *
 */
typedef union BCM53128_A0_G_B1000T_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext[1];
	uint32_t _g_b1000t_ctl_ext;
} BCM53128_A0_G_B1000T_CTL_EXTr_t;

#define BCM53128_A0_G_B1000T_CTL_EXTr_CLR(r) (r).g_b1000t_ctl_ext[0] = 0
#define BCM53128_A0_G_B1000T_CTL_EXTr_SET(r,d) (r).g_b1000t_ctl_ext[0] = d
#define BCM53128_A0_G_B1000T_CTL_EXTr_GET(r) (r).g_b1000t_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_B1000T_CTL_EXTr_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext[0]) & 0xff)
#define BCM53128_A0_G_B1000T_CTL_EXTr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_B1000T_CTL_EXTr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 13) & 0x7)
#define BCM53128_A0_G_B1000T_CTL_EXTr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT.
 *
 */
#define BCM53128_A0_READ_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_B1000T_CTL_EXTr,(r._g_b1000t_ctl_ext),2)
#define BCM53128_A0_WRITE_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_B1000T_CTL_EXTr,&(r._g_b1000t_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXTr BCM53128_A0_G_B1000T_CTL_EXTr
#define G_B1000T_CTL_EXTr_SIZE BCM53128_A0_G_B1000T_CTL_EXTr_SIZE
typedef BCM53128_A0_G_B1000T_CTL_EXTr_t G_B1000T_CTL_EXTr_t;
#define G_B1000T_CTL_EXTr_CLR BCM53128_A0_G_B1000T_CTL_EXTr_CLR
#define G_B1000T_CTL_EXTr_SET BCM53128_A0_G_B1000T_CTL_EXTr_SET
#define G_B1000T_CTL_EXTr_GET BCM53128_A0_G_B1000T_CTL_EXTr_GET
#define G_B1000T_CTL_EXTr_RESERVEDf_GET BCM53128_A0_G_B1000T_CTL_EXTr_RESERVEDf_GET
#define G_B1000T_CTL_EXTr_RESERVEDf_SET BCM53128_A0_G_B1000T_CTL_EXTr_RESERVEDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET BCM53128_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_GET BCM53128_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_SET BCM53128_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET BCM53128_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXTr_TEST_MODEf_GET BCM53128_A0_G_B1000T_CTL_EXTr_TEST_MODEf_GET
#define G_B1000T_CTL_EXTr_TEST_MODEf_SET BCM53128_A0_G_B1000T_CTL_EXTr_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXTr BCM53128_A0_READ_G_B1000T_CTL_EXTr
#define WRITE_G_B1000T_CTL_EXTr BCM53128_A0_WRITE_G_B1000T_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_B1000T_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_B1000T_CTL_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r 0x00008712

#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_B1000T_CTL_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext_p7[1];
	uint32_t _g_b1000t_ctl_ext_p7;
} BCM53128_A0_G_B1000T_CTL_EXT_P7r_t;

#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_CLR(r) (r).g_b1000t_ctl_ext_p7[0] = 0
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_SET(r,d) (r).g_b1000t_ctl_ext_p7[0] = d
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_GET(r) (r).g_b1000t_ctl_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext_p7[0]) & 0xff)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext_p7[0]) >> 13) & 0x7)
#define BCM53128_A0_G_B1000T_CTL_EXT_P7r_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext_p7[0]=(((r).g_b1000t_ctl_ext_p7[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_B1000T_CTL_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_B1000T_CTL_EXT_P7r,(r._g_b1000t_ctl_ext_p7),2)
#define BCM53128_A0_WRITE_G_B1000T_CTL_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_B1000T_CTL_EXT_P7r,&(r._g_b1000t_ctl_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXT_P7r BCM53128_A0_G_B1000T_CTL_EXT_P7r
#define G_B1000T_CTL_EXT_P7r_SIZE BCM53128_A0_G_B1000T_CTL_EXT_P7r_SIZE
typedef BCM53128_A0_G_B1000T_CTL_EXT_P7r_t G_B1000T_CTL_EXT_P7r_t;
#define G_B1000T_CTL_EXT_P7r_CLR BCM53128_A0_G_B1000T_CTL_EXT_P7r_CLR
#define G_B1000T_CTL_EXT_P7r_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_SET
#define G_B1000T_CTL_EXT_P7r_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_GET
#define G_B1000T_CTL_EXT_P7r_RESERVEDf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_RESERVEDf_GET
#define G_B1000T_CTL_EXT_P7r_RESERVEDf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_RESERVEDf_SET
#define G_B1000T_CTL_EXT_P7r_ADV_B1000T_HDf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXT_P7r_ADV_B1000T_HDf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXT_P7r_ADV_B1000T_FDf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXT_P7r_ADV_B1000T_FDf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXT_P7r_REPEATER_DTEf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXT_P7r_REPEATER_DTEf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_VALUEf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_VALUEf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_ENf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_ENf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXT_P7r_TEST_MODEf_GET BCM53128_A0_G_B1000T_CTL_EXT_P7r_TEST_MODEf_GET
#define G_B1000T_CTL_EXT_P7r_TEST_MODEf_SET BCM53128_A0_G_B1000T_CTL_EXT_P7r_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXT_P7r BCM53128_A0_READ_G_B1000T_CTL_EXT_P7r
#define WRITE_G_B1000T_CTL_EXT_P7r BCM53128_A0_WRITE_G_B1000T_CTL_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_B1000T_CTL_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_B1000T_STS
 * BLOCKS:   GPIC0
 * DESC:     1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53128_A0_G_B1000T_STSr 0x00001014

#define BCM53128_A0_G_B1000T_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS.
 *
 */
typedef union BCM53128_A0_G_B1000T_STSr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts[1];
	uint32_t _g_b1000t_sts;
} BCM53128_A0_G_B1000T_STSr_t;

#define BCM53128_A0_G_B1000T_STSr_CLR(r) (r).g_b1000t_sts[0] = 0
#define BCM53128_A0_G_B1000T_STSr_SET(r,d) (r).g_b1000t_sts[0] = d
#define BCM53128_A0_G_B1000T_STSr_GET(r) (r).g_b1000t_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts[0]) & 0xff)
#define BCM53128_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_B1000T_STSr_RESERVEDf_GET(r) ((((r).g_b1000t_sts[0]) >> 8) & 0x3)
#define BCM53128_A0_G_B1000T_STSr_RESERVEDf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53128_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 10) & 0x1)
#define BCM53128_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 11) & 0x1)
#define BCM53128_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 12) & 0x1)
#define BCM53128_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 13) & 0x1)
#define BCM53128_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 14) & 0x1)
#define BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts[0]) >> 15) & 0x1)
#define BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS.
 *
 */
#define BCM53128_A0_READ_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_B1000T_STSr,(r._g_b1000t_sts),2)
#define BCM53128_A0_WRITE_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_B1000T_STSr,&(r._g_b1000t_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STSr BCM53128_A0_G_B1000T_STSr
#define G_B1000T_STSr_SIZE BCM53128_A0_G_B1000T_STSr_SIZE
typedef BCM53128_A0_G_B1000T_STSr_t G_B1000T_STSr_t;
#define G_B1000T_STSr_CLR BCM53128_A0_G_B1000T_STSr_CLR
#define G_B1000T_STSr_SET BCM53128_A0_G_B1000T_STSr_SET
#define G_B1000T_STSr_GET BCM53128_A0_G_B1000T_STSr_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_GET BCM53128_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_SET BCM53128_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET
#define G_B1000T_STSr_RESERVEDf_GET BCM53128_A0_G_B1000T_STSr_RESERVEDf_GET
#define G_B1000T_STSr_RESERVEDf_SET BCM53128_A0_G_B1000T_STSr_RESERVEDf_SET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_GET BCM53128_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_SET BCM53128_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_GET BCM53128_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_SET BCM53128_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STSr_REMOTE_REC_STSf_GET BCM53128_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET
#define G_B1000T_STSr_REMOTE_REC_STSf_SET BCM53128_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET
#define G_B1000T_STSr_LOCAL_REC_STSf_GET BCM53128_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET
#define G_B1000T_STSr_LOCAL_REC_STSf_SET BCM53128_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_GET BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_SET BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET BCM53128_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STSr BCM53128_A0_READ_G_B1000T_STSr
#define WRITE_G_B1000T_STSr BCM53128_A0_WRITE_G_B1000T_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_B1000T_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_B1000T_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53128_A0_G_B1000T_STS_EXTr 0x00008814

#define BCM53128_A0_G_B1000T_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT.
 *
 */
typedef union BCM53128_A0_G_B1000T_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext[1];
	uint32_t _g_b1000t_sts_ext;
} BCM53128_A0_G_B1000T_STS_EXTr_t;

#define BCM53128_A0_G_B1000T_STS_EXTr_CLR(r) (r).g_b1000t_sts_ext[0] = 0
#define BCM53128_A0_G_B1000T_STS_EXTr_SET(r,d) (r).g_b1000t_sts_ext[0] = d
#define BCM53128_A0_G_B1000T_STS_EXTr_GET(r) (r).g_b1000t_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext[0]) & 0xff)
#define BCM53128_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_B1000T_STS_EXTr_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 8) & 0x3)
#define BCM53128_A0_G_B1000T_STS_EXTr_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT.
 *
 */
#define BCM53128_A0_READ_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_B1000T_STS_EXTr,(r._g_b1000t_sts_ext),2)
#define BCM53128_A0_WRITE_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_B1000T_STS_EXTr,&(r._g_b1000t_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXTr BCM53128_A0_G_B1000T_STS_EXTr
#define G_B1000T_STS_EXTr_SIZE BCM53128_A0_G_B1000T_STS_EXTr_SIZE
typedef BCM53128_A0_G_B1000T_STS_EXTr_t G_B1000T_STS_EXTr_t;
#define G_B1000T_STS_EXTr_CLR BCM53128_A0_G_B1000T_STS_EXTr_CLR
#define G_B1000T_STS_EXTr_SET BCM53128_A0_G_B1000T_STS_EXTr_SET
#define G_B1000T_STS_EXTr_GET BCM53128_A0_G_B1000T_STS_EXTr_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET BCM53128_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET BCM53128_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXTr_RESERVEDf_GET BCM53128_A0_G_B1000T_STS_EXTr_RESERVEDf_GET
#define G_B1000T_STS_EXTr_RESERVEDf_SET BCM53128_A0_G_B1000T_STS_EXTr_RESERVEDf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET BCM53128_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET BCM53128_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET BCM53128_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET BCM53128_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET BCM53128_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET BCM53128_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXTr BCM53128_A0_READ_G_B1000T_STS_EXTr
#define WRITE_G_B1000T_STS_EXTr BCM53128_A0_WRITE_G_B1000T_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_B1000T_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_B1000T_STS_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53128_A0_G_B1000T_STS_EXT_P7r 0x00008714

#define BCM53128_A0_G_B1000T_STS_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_B1000T_STS_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext_p7[1];
	uint32_t _g_b1000t_sts_ext_p7;
} BCM53128_A0_G_B1000T_STS_EXT_P7r_t;

#define BCM53128_A0_G_B1000T_STS_EXT_P7r_CLR(r) (r).g_b1000t_sts_ext_p7[0] = 0
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_SET(r,d) (r).g_b1000t_sts_ext_p7[0] = d
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_GET(r) (r).g_b1000t_sts_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext_p7[0]) & 0xff)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 8) & 0x3)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext_p7[0]=(((r).g_b1000t_sts_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_B1000T_STS_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_B1000T_STS_EXT_P7r,(r._g_b1000t_sts_ext_p7),2)
#define BCM53128_A0_WRITE_G_B1000T_STS_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_B1000T_STS_EXT_P7r,&(r._g_b1000t_sts_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXT_P7r BCM53128_A0_G_B1000T_STS_EXT_P7r
#define G_B1000T_STS_EXT_P7r_SIZE BCM53128_A0_G_B1000T_STS_EXT_P7r_SIZE
typedef BCM53128_A0_G_B1000T_STS_EXT_P7r_t G_B1000T_STS_EXT_P7r_t;
#define G_B1000T_STS_EXT_P7r_CLR BCM53128_A0_G_B1000T_STS_EXT_P7r_CLR
#define G_B1000T_STS_EXT_P7r_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_SET
#define G_B1000T_STS_EXT_P7r_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_GET
#define G_B1000T_STS_EXT_P7r_IDLE_ERR_CNTf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXT_P7r_IDLE_ERR_CNTf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXT_P7r_RESERVEDf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_RESERVEDf_GET
#define G_B1000T_STS_EXT_P7r_RESERVEDf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_RESERVEDf_SET
#define G_B1000T_STS_EXT_P7r_LP_B1000T_HD_CAPf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXT_P7r_LP_B1000T_HD_CAPf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXT_P7r_LP_B1000T_FD_CAPf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXT_P7r_LP_B1000T_FD_CAPf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXT_P7r_REMOTE_REC_STSf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXT_P7r_REMOTE_REC_STSf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXT_P7r_LOCAL_REC_STSf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXT_P7r_LOCAL_REC_STSf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_STSf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_STSf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_FAULTf_GET BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_FAULTf_SET BCM53128_A0_G_B1000T_STS_EXT_P7r_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXT_P7r BCM53128_A0_READ_G_B1000T_STS_EXT_P7r
#define WRITE_G_B1000T_STS_EXT_P7r BCM53128_A0_WRITE_G_B1000T_STS_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_B1000T_STS_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_DSP_COEFFICIENT
 * BLOCKS:   GPIC0
 * DESC:     DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53128_A0_G_DSP_COEFFICIENTr 0x0000102a

#define BCM53128_A0_G_DSP_COEFFICIENTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT.
 *
 */
typedef union BCM53128_A0_G_DSP_COEFFICIENTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient[1];
	uint32_t _g_dsp_coefficient;
} BCM53128_A0_G_DSP_COEFFICIENTr_t;

#define BCM53128_A0_G_DSP_COEFFICIENTr_CLR(r) (r).g_dsp_coefficient[0] = 0
#define BCM53128_A0_G_DSP_COEFFICIENTr_SET(r,d) (r).g_dsp_coefficient[0] = d
#define BCM53128_A0_G_DSP_COEFFICIENTr_GET(r) (r).g_dsp_coefficient[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient[0]) & 0xffff)
#define BCM53128_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient[0]=(((r).g_dsp_coefficient[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT.
 *
 */
#define BCM53128_A0_READ_G_DSP_COEFFICIENTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_DSP_COEFFICIENTr,(r._g_dsp_coefficient),2)
#define BCM53128_A0_WRITE_G_DSP_COEFFICIENTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_DSP_COEFFICIENTr,&(r._g_dsp_coefficient),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENTr BCM53128_A0_G_DSP_COEFFICIENTr
#define G_DSP_COEFFICIENTr_SIZE BCM53128_A0_G_DSP_COEFFICIENTr_SIZE
typedef BCM53128_A0_G_DSP_COEFFICIENTr_t G_DSP_COEFFICIENTr_t;
#define G_DSP_COEFFICIENTr_CLR BCM53128_A0_G_DSP_COEFFICIENTr_CLR
#define G_DSP_COEFFICIENTr_SET BCM53128_A0_G_DSP_COEFFICIENTr_SET
#define G_DSP_COEFFICIENTr_GET BCM53128_A0_G_DSP_COEFFICIENTr_GET
#define G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_GET BCM53128_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_SET BCM53128_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENTr BCM53128_A0_READ_G_DSP_COEFFICIENTr
#define WRITE_G_DSP_COEFFICIENTr BCM53128_A0_WRITE_G_DSP_COEFFICIENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_DSP_COEFFICIENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR
 * BLOCKS:   GPIC0
 * DESC:     DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr 0x0000102e

#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR.
 *
 */
typedef union BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr[1];
	uint32_t _g_dsp_coefficient_addr;
} BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_t;

#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_CLR(r) (r).g_dsp_coefficient_addr[0] = 0
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_SET(r,d) (r).g_dsp_coefficient_addr[0] = d
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_GET(r) (r).g_dsp_coefficient_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr[0]) & 0xff)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 8) & 0xf)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 12) & 0x1)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 13) & 0x3)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 15) & 0x1)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR.
 *
 */
#define BCM53128_A0_READ_G_DSP_COEFFICIENT_ADDRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_DSP_COEFFICIENT_ADDRr,(r._g_dsp_coefficient_addr),2)
#define BCM53128_A0_WRITE_G_DSP_COEFFICIENT_ADDRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_DSP_COEFFICIENT_ADDRr,&(r._g_dsp_coefficient_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDRr BCM53128_A0_G_DSP_COEFFICIENT_ADDRr
#define G_DSP_COEFFICIENT_ADDRr_SIZE BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_SIZE
typedef BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_t G_DSP_COEFFICIENT_ADDRr_t;
#define G_DSP_COEFFICIENT_ADDRr_CLR BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_CLR
#define G_DSP_COEFFICIENT_ADDRr_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_SET
#define G_DSP_COEFFICIENT_ADDRr_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_GET
#define G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDRr BCM53128_A0_READ_G_DSP_COEFFICIENT_ADDRr
#define WRITE_G_DSP_COEFFICIENT_ADDRr BCM53128_A0_WRITE_G_DSP_COEFFICIENT_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_DSP_COEFFICIENT_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr 0x0000882e

#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
typedef union BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext[1];
	uint32_t _g_dsp_coefficient_addr_ext;
} BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t;

#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR(r) (r).g_dsp_coefficient_addr_ext[0] = 0
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET(r,d) (r).g_dsp_coefficient_addr_ext[0] = d
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET(r) (r).g_dsp_coefficient_addr_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext[0]) & 0xff)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 8) & 0xf)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 13) & 0x3)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
#define BCM53128_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr,(r._g_dsp_coefficient_addr_ext),2)
#define BCM53128_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr,&(r._g_dsp_coefficient_addr_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXTr BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr
#define G_DSP_COEFFICIENT_ADDR_EXTr_SIZE BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE
typedef BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t G_DSP_COEFFICIENT_ADDR_EXTr_t;
#define G_DSP_COEFFICIENT_ADDR_EXTr_CLR BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR
#define G_DSP_COEFFICIENT_ADDR_EXTr_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXTr BCM53128_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXTr BCM53128_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r 0x0000872e

#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext_p7[1];
	uint32_t _g_dsp_coefficient_addr_ext_p7;
} BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_t;

#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_CLR(r) (r).g_dsp_coefficient_addr_ext_p7[0] = 0
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_SET(r,d) (r).g_dsp_coefficient_addr_ext_p7[0] = d
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_GET(r) (r).g_dsp_coefficient_addr_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext_p7[0]) & 0xff)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p7[0]=(((r).g_dsp_coefficient_addr_ext_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p7[0]) >> 8) & 0xf)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p7[0]=(((r).g_dsp_coefficient_addr_ext_p7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p7[0]=(((r).g_dsp_coefficient_addr_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p7[0]) >> 13) & 0x3)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p7[0]=(((r).g_dsp_coefficient_addr_ext_p7[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p7[0]=(((r).g_dsp_coefficient_addr_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r,(r._g_dsp_coefficient_addr_ext_p7),2)
#define BCM53128_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r,&(r._g_dsp_coefficient_addr_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXT_P7r BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_SIZE BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_SIZE
typedef BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_t G_DSP_COEFFICIENT_ADDR_EXT_P7r_t;
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_CLR BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_CLR
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_TAP_NUMf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_TAP_NUMf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_FILTER_SELf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_FILTER_SELf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_FILTER_CTLf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_FILTER_CTLf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_CHANNEL_SELf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_CHANNEL_SELf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_CHANNEL_CTLf_GET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_CHANNEL_CTLf_SET BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXT_P7r BCM53128_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P7r
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P7r BCM53128_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_DSP_COEFFICIENT_ADDR_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr 0x0000882a

#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT.
 *
 */
typedef union BCM53128_A0_G_DSP_COEFFICIENT_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext[1];
	uint32_t _g_dsp_coefficient_ext;
} BCM53128_A0_G_DSP_COEFFICIENT_EXTr_t;

#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr_CLR(r) (r).g_dsp_coefficient_ext[0] = 0
#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr_SET(r,d) (r).g_dsp_coefficient_ext[0] = d
#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr_GET(r) (r).g_dsp_coefficient_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext[0]) & 0xffff)
#define BCM53128_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext[0]=(((r).g_dsp_coefficient_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT.
 *
 */
#define BCM53128_A0_READ_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_DSP_COEFFICIENT_EXTr,(r._g_dsp_coefficient_ext),2)
#define BCM53128_A0_WRITE_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_DSP_COEFFICIENT_EXTr,&(r._g_dsp_coefficient_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXTr BCM53128_A0_G_DSP_COEFFICIENT_EXTr
#define G_DSP_COEFFICIENT_EXTr_SIZE BCM53128_A0_G_DSP_COEFFICIENT_EXTr_SIZE
typedef BCM53128_A0_G_DSP_COEFFICIENT_EXTr_t G_DSP_COEFFICIENT_EXTr_t;
#define G_DSP_COEFFICIENT_EXTr_CLR BCM53128_A0_G_DSP_COEFFICIENT_EXTr_CLR
#define G_DSP_COEFFICIENT_EXTr_SET BCM53128_A0_G_DSP_COEFFICIENT_EXTr_SET
#define G_DSP_COEFFICIENT_EXTr_GET BCM53128_A0_G_DSP_COEFFICIENT_EXTr_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET BCM53128_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET BCM53128_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXTr BCM53128_A0_READ_G_DSP_COEFFICIENT_EXTr
#define WRITE_G_DSP_COEFFICIENT_EXTr BCM53128_A0_WRITE_G_DSP_COEFFICIENT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_DSP_COEFFICIENT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r 0x0000872a

#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext_p7[1];
	uint32_t _g_dsp_coefficient_ext_p7;
} BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_t;

#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_CLR(r) (r).g_dsp_coefficient_ext_p7[0] = 0
#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_SET(r,d) (r).g_dsp_coefficient_ext_p7[0] = d
#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_GET(r) (r).g_dsp_coefficient_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext_p7[0]=(((r).g_dsp_coefficient_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_DSP_COEFFICIENT_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r,(r._g_dsp_coefficient_ext_p7),2)
#define BCM53128_A0_WRITE_G_DSP_COEFFICIENT_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r,&(r._g_dsp_coefficient_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXT_P7r BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r
#define G_DSP_COEFFICIENT_EXT_P7r_SIZE BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_SIZE
typedef BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_t G_DSP_COEFFICIENT_EXT_P7r_t;
#define G_DSP_COEFFICIENT_EXT_P7r_CLR BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_CLR
#define G_DSP_COEFFICIENT_EXT_P7r_SET BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_SET
#define G_DSP_COEFFICIENT_EXT_P7r_GET BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_GET
#define G_DSP_COEFFICIENT_EXT_P7r_DSP_COEFFICIENTf_GET BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXT_P7r_DSP_COEFFICIENTf_SET BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXT_P7r BCM53128_A0_READ_G_DSP_COEFFICIENT_EXT_P7r
#define WRITE_G_DSP_COEFFICIENT_EXT_P7r BCM53128_A0_WRITE_G_DSP_COEFFICIENT_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_DSP_COEFFICIENT_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53128_A0_G_EXT_STSr 0x0000101e

#define BCM53128_A0_G_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS.
 *
 */
typedef union BCM53128_A0_G_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_ext_sts[1];
	uint32_t _g_ext_sts;
} BCM53128_A0_G_EXT_STSr_t;

#define BCM53128_A0_G_EXT_STSr_CLR(r) (r).g_ext_sts[0] = 0
#define BCM53128_A0_G_EXT_STSr_SET(r,d) (r).g_ext_sts[0] = d
#define BCM53128_A0_G_EXT_STSr_GET(r) (r).g_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_EXT_STSr_RESERVEDf_GET(r) (((r).g_ext_sts[0]) & 0xfff)
#define BCM53128_A0_G_EXT_STSr_RESERVEDf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_G_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 12) & 0x1)
#define BCM53128_A0_G_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 13) & 0x1)
#define BCM53128_A0_G_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 14) & 0x1)
#define BCM53128_A0_G_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 15) & 0x1)
#define BCM53128_A0_G_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS.
 *
 */
#define BCM53128_A0_READ_G_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_EXT_STSr,(r._g_ext_sts),2)
#define BCM53128_A0_WRITE_G_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_EXT_STSr,&(r._g_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STSr BCM53128_A0_G_EXT_STSr
#define G_EXT_STSr_SIZE BCM53128_A0_G_EXT_STSr_SIZE
typedef BCM53128_A0_G_EXT_STSr_t G_EXT_STSr_t;
#define G_EXT_STSr_CLR BCM53128_A0_G_EXT_STSr_CLR
#define G_EXT_STSr_SET BCM53128_A0_G_EXT_STSr_SET
#define G_EXT_STSr_GET BCM53128_A0_G_EXT_STSr_GET
#define G_EXT_STSr_RESERVEDf_GET BCM53128_A0_G_EXT_STSr_RESERVEDf_GET
#define G_EXT_STSr_RESERVEDf_SET BCM53128_A0_G_EXT_STSr_RESERVEDf_SET
#define G_EXT_STSr_B1000T_HD_CAPf_GET BCM53128_A0_G_EXT_STSr_B1000T_HD_CAPf_GET
#define G_EXT_STSr_B1000T_HD_CAPf_SET BCM53128_A0_G_EXT_STSr_B1000T_HD_CAPf_SET
#define G_EXT_STSr_B1000T_FD_CAPf_GET BCM53128_A0_G_EXT_STSr_B1000T_FD_CAPf_GET
#define G_EXT_STSr_B1000T_FD_CAPf_SET BCM53128_A0_G_EXT_STSr_B1000T_FD_CAPf_SET
#define G_EXT_STSr_B1000X_HD_CAPf_GET BCM53128_A0_G_EXT_STSr_B1000X_HD_CAPf_GET
#define G_EXT_STSr_B1000X_HD_CAPf_SET BCM53128_A0_G_EXT_STSr_B1000X_HD_CAPf_SET
#define G_EXT_STSr_B1000X_FD_CAPf_GET BCM53128_A0_G_EXT_STSr_B1000X_FD_CAPf_GET
#define G_EXT_STSr_B1000X_FD_CAPf_SET BCM53128_A0_G_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STSr BCM53128_A0_READ_G_EXT_STSr
#define WRITE_G_EXT_STSr BCM53128_A0_WRITE_G_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_EXT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53128_A0_G_EXT_STS_EXTr 0x0000881e

#define BCM53128_A0_G_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT.
 *
 */
typedef union BCM53128_A0_G_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext[1];
	uint32_t _g_ext_sts_ext;
} BCM53128_A0_G_EXT_STS_EXTr_t;

#define BCM53128_A0_G_EXT_STS_EXTr_CLR(r) (r).g_ext_sts_ext[0] = 0
#define BCM53128_A0_G_EXT_STS_EXTr_SET(r,d) (r).g_ext_sts_ext[0] = d
#define BCM53128_A0_G_EXT_STS_EXTr_GET(r) (r).g_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_EXT_STS_EXTr_RESERVEDf_GET(r) (((r).g_ext_sts_ext[0]) & 0xfff)
#define BCM53128_A0_G_EXT_STS_EXTr_RESERVEDf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT.
 *
 */
#define BCM53128_A0_READ_G_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_EXT_STS_EXTr,(r._g_ext_sts_ext),2)
#define BCM53128_A0_WRITE_G_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_EXT_STS_EXTr,&(r._g_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXTr BCM53128_A0_G_EXT_STS_EXTr
#define G_EXT_STS_EXTr_SIZE BCM53128_A0_G_EXT_STS_EXTr_SIZE
typedef BCM53128_A0_G_EXT_STS_EXTr_t G_EXT_STS_EXTr_t;
#define G_EXT_STS_EXTr_CLR BCM53128_A0_G_EXT_STS_EXTr_CLR
#define G_EXT_STS_EXTr_SET BCM53128_A0_G_EXT_STS_EXTr_SET
#define G_EXT_STS_EXTr_GET BCM53128_A0_G_EXT_STS_EXTr_GET
#define G_EXT_STS_EXTr_RESERVEDf_GET BCM53128_A0_G_EXT_STS_EXTr_RESERVEDf_GET
#define G_EXT_STS_EXTr_RESERVEDf_SET BCM53128_A0_G_EXT_STS_EXTr_RESERVEDf_SET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_GET BCM53128_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_SET BCM53128_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_GET BCM53128_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_SET BCM53128_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_GET BCM53128_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_SET BCM53128_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_GET BCM53128_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_SET BCM53128_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXTr BCM53128_A0_READ_G_EXT_STS_EXTr
#define WRITE_G_EXT_STS_EXTr BCM53128_A0_WRITE_G_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_EXT_STS_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53128_A0_G_EXT_STS_EXT_P7r 0x0000871e

#define BCM53128_A0_G_EXT_STS_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_EXT_STS_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext_p7[1];
	uint32_t _g_ext_sts_ext_p7;
} BCM53128_A0_G_EXT_STS_EXT_P7r_t;

#define BCM53128_A0_G_EXT_STS_EXT_P7r_CLR(r) (r).g_ext_sts_ext_p7[0] = 0
#define BCM53128_A0_G_EXT_STS_EXT_P7r_SET(r,d) (r).g_ext_sts_ext_p7[0] = d
#define BCM53128_A0_G_EXT_STS_EXT_P7r_GET(r) (r).g_ext_sts_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_EXT_STS_EXT_P7r_RESERVEDf_GET(r) (((r).g_ext_sts_ext_p7[0]) & 0xfff)
#define BCM53128_A0_G_EXT_STS_EXT_P7r_RESERVEDf_SET(r,f) (r).g_ext_sts_ext_p7[0]=(((r).g_ext_sts_ext_p7[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p7[0]=(((r).g_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p7[0]=(((r).g_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p7[0]=(((r).g_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p7[0]=(((r).g_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_EXT_STS_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_EXT_STS_EXT_P7r,(r._g_ext_sts_ext_p7),2)
#define BCM53128_A0_WRITE_G_EXT_STS_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_EXT_STS_EXT_P7r,&(r._g_ext_sts_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXT_P7r BCM53128_A0_G_EXT_STS_EXT_P7r
#define G_EXT_STS_EXT_P7r_SIZE BCM53128_A0_G_EXT_STS_EXT_P7r_SIZE
typedef BCM53128_A0_G_EXT_STS_EXT_P7r_t G_EXT_STS_EXT_P7r_t;
#define G_EXT_STS_EXT_P7r_CLR BCM53128_A0_G_EXT_STS_EXT_P7r_CLR
#define G_EXT_STS_EXT_P7r_SET BCM53128_A0_G_EXT_STS_EXT_P7r_SET
#define G_EXT_STS_EXT_P7r_GET BCM53128_A0_G_EXT_STS_EXT_P7r_GET
#define G_EXT_STS_EXT_P7r_RESERVEDf_GET BCM53128_A0_G_EXT_STS_EXT_P7r_RESERVEDf_GET
#define G_EXT_STS_EXT_P7r_RESERVEDf_SET BCM53128_A0_G_EXT_STS_EXT_P7r_RESERVEDf_SET
#define G_EXT_STS_EXT_P7r_B1000T_HD_CAPf_GET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXT_P7r_B1000T_HD_CAPf_SET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXT_P7r_B1000T_FD_CAPf_GET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXT_P7r_B1000T_FD_CAPf_SET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXT_P7r_B1000X_HD_CAPf_GET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXT_P7r_B1000X_HD_CAPf_SET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXT_P7r_B1000X_FD_CAPf_GET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXT_P7r_B1000X_FD_CAPf_SET BCM53128_A0_G_EXT_STS_EXT_P7r_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXT_P7r BCM53128_A0_READ_G_EXT_STS_EXT_P7r
#define WRITE_G_EXT_STS_EXT_P7r BCM53128_A0_WRITE_G_EXT_STS_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_EXT_STS_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_FALSE_CARR_CNT
 * BLOCKS:   GPIC0
 * DESC:     False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53128_A0_G_FALSE_CARR_CNTr 0x00001026

#define BCM53128_A0_G_FALSE_CARR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT.
 *
 */
typedef union BCM53128_A0_G_FALSE_CARR_CNTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt[1];
	uint32_t _g_false_carr_cnt;
} BCM53128_A0_G_FALSE_CARR_CNTr_t;

#define BCM53128_A0_G_FALSE_CARR_CNTr_CLR(r) (r).g_false_carr_cnt[0] = 0
#define BCM53128_A0_G_FALSE_CARR_CNTr_SET(r,d) (r).g_false_carr_cnt[0] = d
#define BCM53128_A0_G_FALSE_CARR_CNTr_GET(r) (r).g_false_carr_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt[0]) & 0xff)
#define BCM53128_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt[0]) >> 8) & 0xff)
#define BCM53128_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT.
 *
 */
#define BCM53128_A0_READ_G_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_FALSE_CARR_CNTr,(r._g_false_carr_cnt),2)
#define BCM53128_A0_WRITE_G_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_FALSE_CARR_CNTr,&(r._g_false_carr_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNTr BCM53128_A0_G_FALSE_CARR_CNTr
#define G_FALSE_CARR_CNTr_SIZE BCM53128_A0_G_FALSE_CARR_CNTr_SIZE
typedef BCM53128_A0_G_FALSE_CARR_CNTr_t G_FALSE_CARR_CNTr_t;
#define G_FALSE_CARR_CNTr_CLR BCM53128_A0_G_FALSE_CARR_CNTr_CLR
#define G_FALSE_CARR_CNTr_SET BCM53128_A0_G_FALSE_CARR_CNTr_SET
#define G_FALSE_CARR_CNTr_GET BCM53128_A0_G_FALSE_CARR_CNTr_GET
#define G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET BCM53128_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET BCM53128_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNTr_SERDES_BER_CNTf_GET BCM53128_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNTr_SERDES_BER_CNTf_SET BCM53128_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNTr BCM53128_A0_READ_G_FALSE_CARR_CNTr
#define WRITE_G_FALSE_CARR_CNTr BCM53128_A0_WRITE_G_FALSE_CARR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_FALSE_CARR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr 0x00008826

#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT.
 *
 */
typedef union BCM53128_A0_G_FALSE_CARR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext[1];
	uint32_t _g_false_carr_cnt_ext;
} BCM53128_A0_G_FALSE_CARR_CNT_EXTr_t;

#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_CLR(r) (r).g_false_carr_cnt_ext[0] = 0
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SET(r,d) (r).g_false_carr_cnt_ext[0] = d
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_GET(r) (r).g_false_carr_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext[0]) & 0xff)
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext[0]) >> 8) & 0xff)
#define BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT.
 *
 */
#define BCM53128_A0_READ_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_FALSE_CARR_CNT_EXTr,(r._g_false_carr_cnt_ext),2)
#define BCM53128_A0_WRITE_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_FALSE_CARR_CNT_EXTr,&(r._g_false_carr_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXTr BCM53128_A0_G_FALSE_CARR_CNT_EXTr
#define G_FALSE_CARR_CNT_EXTr_SIZE BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SIZE
typedef BCM53128_A0_G_FALSE_CARR_CNT_EXTr_t G_FALSE_CARR_CNT_EXTr_t;
#define G_FALSE_CARR_CNT_EXTr_CLR BCM53128_A0_G_FALSE_CARR_CNT_EXTr_CLR
#define G_FALSE_CARR_CNT_EXTr_SET BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SET
#define G_FALSE_CARR_CNT_EXTr_GET BCM53128_A0_G_FALSE_CARR_CNT_EXTr_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET BCM53128_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET BCM53128_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET BCM53128_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXTr BCM53128_A0_READ_G_FALSE_CARR_CNT_EXTr
#define WRITE_G_FALSE_CARR_CNT_EXTr BCM53128_A0_WRITE_G_FALSE_CARR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_FALSE_CARR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r 0x00008726

#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext_p7[1];
	uint32_t _g_false_carr_cnt_ext_p7;
} BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_t;

#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_CLR(r) (r).g_false_carr_cnt_ext_p7[0] = 0
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SET(r,d) (r).g_false_carr_cnt_ext_p7[0] = d
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_GET(r) (r).g_false_carr_cnt_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext_p7[0]) & 0xff)
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p7[0]=(((r).g_false_carr_cnt_ext_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext_p7[0]) >> 8) & 0xff)
#define BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p7[0]=(((r).g_false_carr_cnt_ext_p7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_FALSE_CARR_CNT_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r,(r._g_false_carr_cnt_ext_p7),2)
#define BCM53128_A0_WRITE_G_FALSE_CARR_CNT_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r,&(r._g_false_carr_cnt_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXT_P7r BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r
#define G_FALSE_CARR_CNT_EXT_P7r_SIZE BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SIZE
typedef BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_t G_FALSE_CARR_CNT_EXT_P7r_t;
#define G_FALSE_CARR_CNT_EXT_P7r_CLR BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_CLR
#define G_FALSE_CARR_CNT_EXT_P7r_SET BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SET
#define G_FALSE_CARR_CNT_EXT_P7r_GET BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_GET
#define G_FALSE_CARR_CNT_EXT_P7r_REC_ERR_CNTf_GET BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P7r_REC_ERR_CNTf_SET BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXT_P7r_SERDES_BER_CNTf_GET BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P7r_SERDES_BER_CNTf_SET BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXT_P7r BCM53128_A0_READ_G_FALSE_CARR_CNT_EXT_P7r
#define WRITE_G_FALSE_CARR_CNT_EXT_P7r BCM53128_A0_WRITE_G_FALSE_CARR_CNT_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_FALSE_CARR_CNT_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_INTERRUPT_MSK
 * BLOCKS:   GPIC0
 * DESC:     Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53128_A0_G_INTERRUPT_MSKr 0x00001036

#define BCM53128_A0_G_INTERRUPT_MSKr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK.
 *
 */
typedef union BCM53128_A0_G_INTERRUPT_MSKr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk[1];
	uint32_t _g_interrupt_msk;
} BCM53128_A0_G_INTERRUPT_MSKr_t;

#define BCM53128_A0_G_INTERRUPT_MSKr_CLR(r) (r).g_interrupt_msk[0] = 0
#define BCM53128_A0_G_INTERRUPT_MSKr_SET(r,d) (r).g_interrupt_msk[0] = d
#define BCM53128_A0_G_INTERRUPT_MSKr_GET(r) (r).g_interrupt_msk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk[0]) & 0xffff)
#define BCM53128_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk[0]=(((r).g_interrupt_msk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK.
 *
 */
#define BCM53128_A0_READ_G_INTERRUPT_MSKr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_INTERRUPT_MSKr,(r._g_interrupt_msk),2)
#define BCM53128_A0_WRITE_G_INTERRUPT_MSKr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_INTERRUPT_MSKr,&(r._g_interrupt_msk),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSKr BCM53128_A0_G_INTERRUPT_MSKr
#define G_INTERRUPT_MSKr_SIZE BCM53128_A0_G_INTERRUPT_MSKr_SIZE
typedef BCM53128_A0_G_INTERRUPT_MSKr_t G_INTERRUPT_MSKr_t;
#define G_INTERRUPT_MSKr_CLR BCM53128_A0_G_INTERRUPT_MSKr_CLR
#define G_INTERRUPT_MSKr_SET BCM53128_A0_G_INTERRUPT_MSKr_SET
#define G_INTERRUPT_MSKr_GET BCM53128_A0_G_INTERRUPT_MSKr_GET
#define G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET BCM53128_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET BCM53128_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSKr BCM53128_A0_READ_G_INTERRUPT_MSKr
#define WRITE_G_INTERRUPT_MSKr BCM53128_A0_WRITE_G_INTERRUPT_MSKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_INTERRUPT_MSKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53128_A0_G_INTERRUPT_MSK_EXTr 0x00008836

#define BCM53128_A0_G_INTERRUPT_MSK_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT.
 *
 */
typedef union BCM53128_A0_G_INTERRUPT_MSK_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext[1];
	uint32_t _g_interrupt_msk_ext;
} BCM53128_A0_G_INTERRUPT_MSK_EXTr_t;

#define BCM53128_A0_G_INTERRUPT_MSK_EXTr_CLR(r) (r).g_interrupt_msk_ext[0] = 0
#define BCM53128_A0_G_INTERRUPT_MSK_EXTr_SET(r,d) (r).g_interrupt_msk_ext[0] = d
#define BCM53128_A0_G_INTERRUPT_MSK_EXTr_GET(r) (r).g_interrupt_msk_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext[0]) & 0xffff)
#define BCM53128_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext[0]=(((r).g_interrupt_msk_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT.
 *
 */
#define BCM53128_A0_READ_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_INTERRUPT_MSK_EXTr,(r._g_interrupt_msk_ext),2)
#define BCM53128_A0_WRITE_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_INTERRUPT_MSK_EXTr,&(r._g_interrupt_msk_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXTr BCM53128_A0_G_INTERRUPT_MSK_EXTr
#define G_INTERRUPT_MSK_EXTr_SIZE BCM53128_A0_G_INTERRUPT_MSK_EXTr_SIZE
typedef BCM53128_A0_G_INTERRUPT_MSK_EXTr_t G_INTERRUPT_MSK_EXTr_t;
#define G_INTERRUPT_MSK_EXTr_CLR BCM53128_A0_G_INTERRUPT_MSK_EXTr_CLR
#define G_INTERRUPT_MSK_EXTr_SET BCM53128_A0_G_INTERRUPT_MSK_EXTr_SET
#define G_INTERRUPT_MSK_EXTr_GET BCM53128_A0_G_INTERRUPT_MSK_EXTr_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET BCM53128_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET BCM53128_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXTr BCM53128_A0_READ_G_INTERRUPT_MSK_EXTr
#define WRITE_G_INTERRUPT_MSK_EXTr BCM53128_A0_WRITE_G_INTERRUPT_MSK_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_INTERRUPT_MSK_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r 0x00008736

#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext_p7[1];
	uint32_t _g_interrupt_msk_ext_p7;
} BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_t;

#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_CLR(r) (r).g_interrupt_msk_ext_p7[0] = 0
#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_SET(r,d) (r).g_interrupt_msk_ext_p7[0] = d
#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_GET(r) (r).g_interrupt_msk_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext_p7[0]=(((r).g_interrupt_msk_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_INTERRUPT_MSK_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r,(r._g_interrupt_msk_ext_p7),2)
#define BCM53128_A0_WRITE_G_INTERRUPT_MSK_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r,&(r._g_interrupt_msk_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXT_P7r BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r
#define G_INTERRUPT_MSK_EXT_P7r_SIZE BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_SIZE
typedef BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_t G_INTERRUPT_MSK_EXT_P7r_t;
#define G_INTERRUPT_MSK_EXT_P7r_CLR BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_CLR
#define G_INTERRUPT_MSK_EXT_P7r_SET BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_SET
#define G_INTERRUPT_MSK_EXT_P7r_GET BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_GET
#define G_INTERRUPT_MSK_EXT_P7r_INTERRUPT_MSKf_GET BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXT_P7r_INTERRUPT_MSKf_SET BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXT_P7r BCM53128_A0_READ_G_INTERRUPT_MSK_EXT_P7r
#define WRITE_G_INTERRUPT_MSK_EXT_P7r BCM53128_A0_WRITE_G_INTERRUPT_MSK_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_INTERRUPT_MSK_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_INTERRUPT_STS
 * BLOCKS:   GPIC0
 * DESC:     Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53128_A0_G_INTERRUPT_STSr 0x00001034

#define BCM53128_A0_G_INTERRUPT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS.
 *
 */
typedef union BCM53128_A0_G_INTERRUPT_STSr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts[1];
	uint32_t _g_interrupt_sts;
} BCM53128_A0_G_INTERRUPT_STSr_t;

#define BCM53128_A0_G_INTERRUPT_STSr_CLR(r) (r).g_interrupt_sts[0] = 0
#define BCM53128_A0_G_INTERRUPT_STSr_SET(r,d) (r).g_interrupt_sts[0] = d
#define BCM53128_A0_G_INTERRUPT_STSr_GET(r) (r).g_interrupt_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts[0]) & 0xffff)
#define BCM53128_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS.
 *
 */
#define BCM53128_A0_READ_G_INTERRUPT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_INTERRUPT_STSr,(r._g_interrupt_sts),2)
#define BCM53128_A0_WRITE_G_INTERRUPT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_INTERRUPT_STSr,&(r._g_interrupt_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STSr BCM53128_A0_G_INTERRUPT_STSr
#define G_INTERRUPT_STSr_SIZE BCM53128_A0_G_INTERRUPT_STSr_SIZE
typedef BCM53128_A0_G_INTERRUPT_STSr_t G_INTERRUPT_STSr_t;
#define G_INTERRUPT_STSr_CLR BCM53128_A0_G_INTERRUPT_STSr_CLR
#define G_INTERRUPT_STSr_SET BCM53128_A0_G_INTERRUPT_STSr_SET
#define G_INTERRUPT_STSr_GET BCM53128_A0_G_INTERRUPT_STSr_GET
#define G_INTERRUPT_STSr_INTERRUPT_STSf_GET BCM53128_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STSr_INTERRUPT_STSf_SET BCM53128_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STSr BCM53128_A0_READ_G_INTERRUPT_STSr
#define WRITE_G_INTERRUPT_STSr BCM53128_A0_WRITE_G_INTERRUPT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_INTERRUPT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_INTERRUPT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53128_A0_G_INTERRUPT_STS_EXTr 0x00008834

#define BCM53128_A0_G_INTERRUPT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT.
 *
 */
typedef union BCM53128_A0_G_INTERRUPT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext[1];
	uint32_t _g_interrupt_sts_ext;
} BCM53128_A0_G_INTERRUPT_STS_EXTr_t;

#define BCM53128_A0_G_INTERRUPT_STS_EXTr_CLR(r) (r).g_interrupt_sts_ext[0] = 0
#define BCM53128_A0_G_INTERRUPT_STS_EXTr_SET(r,d) (r).g_interrupt_sts_ext[0] = d
#define BCM53128_A0_G_INTERRUPT_STS_EXTr_GET(r) (r).g_interrupt_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext[0]) & 0xffff)
#define BCM53128_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext[0]=(((r).g_interrupt_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT.
 *
 */
#define BCM53128_A0_READ_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_INTERRUPT_STS_EXTr,(r._g_interrupt_sts_ext),2)
#define BCM53128_A0_WRITE_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_INTERRUPT_STS_EXTr,&(r._g_interrupt_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXTr BCM53128_A0_G_INTERRUPT_STS_EXTr
#define G_INTERRUPT_STS_EXTr_SIZE BCM53128_A0_G_INTERRUPT_STS_EXTr_SIZE
typedef BCM53128_A0_G_INTERRUPT_STS_EXTr_t G_INTERRUPT_STS_EXTr_t;
#define G_INTERRUPT_STS_EXTr_CLR BCM53128_A0_G_INTERRUPT_STS_EXTr_CLR
#define G_INTERRUPT_STS_EXTr_SET BCM53128_A0_G_INTERRUPT_STS_EXTr_SET
#define G_INTERRUPT_STS_EXTr_GET BCM53128_A0_G_INTERRUPT_STS_EXTr_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET BCM53128_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET BCM53128_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXTr BCM53128_A0_READ_G_INTERRUPT_STS_EXTr
#define WRITE_G_INTERRUPT_STS_EXTr BCM53128_A0_WRITE_G_INTERRUPT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_INTERRUPT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_INTERRUPT_STS_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r 0x00008734

#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext_p7[1];
	uint32_t _g_interrupt_sts_ext_p7;
} BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_t;

#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_CLR(r) (r).g_interrupt_sts_ext_p7[0] = 0
#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_SET(r,d) (r).g_interrupt_sts_ext_p7[0] = d
#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_GET(r) (r).g_interrupt_sts_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext_p7[0]=(((r).g_interrupt_sts_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_INTERRUPT_STS_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_INTERRUPT_STS_EXT_P7r,(r._g_interrupt_sts_ext_p7),2)
#define BCM53128_A0_WRITE_G_INTERRUPT_STS_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_INTERRUPT_STS_EXT_P7r,&(r._g_interrupt_sts_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXT_P7r BCM53128_A0_G_INTERRUPT_STS_EXT_P7r
#define G_INTERRUPT_STS_EXT_P7r_SIZE BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_SIZE
typedef BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_t G_INTERRUPT_STS_EXT_P7r_t;
#define G_INTERRUPT_STS_EXT_P7r_CLR BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_CLR
#define G_INTERRUPT_STS_EXT_P7r_SET BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_SET
#define G_INTERRUPT_STS_EXT_P7r_GET BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_GET
#define G_INTERRUPT_STS_EXT_P7r_INTERRUPT_STSf_GET BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXT_P7r_INTERRUPT_STSf_SET BCM53128_A0_G_INTERRUPT_STS_EXT_P7r_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXT_P7r BCM53128_A0_READ_G_INTERRUPT_STS_EXT_P7r
#define WRITE_G_INTERRUPT_STS_EXT_P7r BCM53128_A0_WRITE_G_INTERRUPT_STS_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_INTERRUPT_STS_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_LPNXP
 * BLOCKS:   GPIC0
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53128_A0_G_LPNXPr 0x00001010

#define BCM53128_A0_G_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP.
 *
 */
typedef union BCM53128_A0_G_LPNXPr_s {
	uint32_t v[1];
	uint32_t g_lpnxp[1];
	uint32_t _g_lpnxp;
} BCM53128_A0_G_LPNXPr_t;

#define BCM53128_A0_G_LPNXPr_CLR(r) (r).g_lpnxp[0] = 0
#define BCM53128_A0_G_LPNXPr_SET(r,d) (r).g_lpnxp[0] = d
#define BCM53128_A0_G_LPNXPr_GET(r) (r).g_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_LPNXPr_CODE_FIELDf_GET(r) ((((r).g_lpnxp[0]) >> 5) & 0x1)
#define BCM53128_A0_G_LPNXPr_CODE_FIELDf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_LPNXPr_TOGGLEf_GET(r) ((((r).g_lpnxp[0]) >> 11) & 0x1)
#define BCM53128_A0_G_LPNXPr_TOGGLEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp[0]) >> 12) & 0x1)
#define BCM53128_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_LPNXPr_MES_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 13) & 0x1)
#define BCM53128_A0_G_LPNXPr_MES_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_LPNXPr_ACKf_GET(r) ((((r).g_lpnxp[0]) >> 14) & 0x1)
#define BCM53128_A0_G_LPNXPr_ACKf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_LPNXPr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 15) & 0x1)
#define BCM53128_A0_G_LPNXPr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP.
 *
 */
#define BCM53128_A0_READ_G_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_LPNXPr,(r._g_lpnxp),2)
#define BCM53128_A0_WRITE_G_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_LPNXPr,&(r._g_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXPr BCM53128_A0_G_LPNXPr
#define G_LPNXPr_SIZE BCM53128_A0_G_LPNXPr_SIZE
typedef BCM53128_A0_G_LPNXPr_t G_LPNXPr_t;
#define G_LPNXPr_CLR BCM53128_A0_G_LPNXPr_CLR
#define G_LPNXPr_SET BCM53128_A0_G_LPNXPr_SET
#define G_LPNXPr_GET BCM53128_A0_G_LPNXPr_GET
#define G_LPNXPr_CODE_FIELDf_GET BCM53128_A0_G_LPNXPr_CODE_FIELDf_GET
#define G_LPNXPr_CODE_FIELDf_SET BCM53128_A0_G_LPNXPr_CODE_FIELDf_SET
#define G_LPNXPr_TOGGLEf_GET BCM53128_A0_G_LPNXPr_TOGGLEf_GET
#define G_LPNXPr_TOGGLEf_SET BCM53128_A0_G_LPNXPr_TOGGLEf_SET
#define G_LPNXPr_ACKNOWLEDGE_2f_GET BCM53128_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET
#define G_LPNXPr_ACKNOWLEDGE_2f_SET BCM53128_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET
#define G_LPNXPr_MES_PAGEf_GET BCM53128_A0_G_LPNXPr_MES_PAGEf_GET
#define G_LPNXPr_MES_PAGEf_SET BCM53128_A0_G_LPNXPr_MES_PAGEf_SET
#define G_LPNXPr_ACKf_GET BCM53128_A0_G_LPNXPr_ACKf_GET
#define G_LPNXPr_ACKf_SET BCM53128_A0_G_LPNXPr_ACKf_SET
#define G_LPNXPr_NEXT_PAGEf_GET BCM53128_A0_G_LPNXPr_NEXT_PAGEf_GET
#define G_LPNXPr_NEXT_PAGEf_SET BCM53128_A0_G_LPNXPr_NEXT_PAGEf_SET
#define READ_G_LPNXPr BCM53128_A0_READ_G_LPNXPr
#define WRITE_G_LPNXPr BCM53128_A0_WRITE_G_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_LPNXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53128_A0_G_LPNXP_EXTr 0x00008810

#define BCM53128_A0_G_LPNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT.
 *
 */
typedef union BCM53128_A0_G_LPNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext[1];
	uint32_t _g_lpnxp_ext;
} BCM53128_A0_G_LPNXP_EXTr_t;

#define BCM53128_A0_G_LPNXP_EXTr_CLR(r) (r).g_lpnxp_ext[0] = 0
#define BCM53128_A0_G_LPNXP_EXTr_SET(r,d) (r).g_lpnxp_ext[0] = d
#define BCM53128_A0_G_LPNXP_EXTr_GET(r) (r).g_lpnxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_LPNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_LPNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_LPNXP_EXTr_TOGGLEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_LPNXP_EXTr_TOGGLEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_LPNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_LPNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_LPNXP_EXTr_ACKf_GET(r) ((((r).g_lpnxp_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_LPNXP_EXTr_ACKf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT.
 *
 */
#define BCM53128_A0_READ_G_LPNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_LPNXP_EXTr,(r._g_lpnxp_ext),2)
#define BCM53128_A0_WRITE_G_LPNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_LPNXP_EXTr,&(r._g_lpnxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXTr BCM53128_A0_G_LPNXP_EXTr
#define G_LPNXP_EXTr_SIZE BCM53128_A0_G_LPNXP_EXTr_SIZE
typedef BCM53128_A0_G_LPNXP_EXTr_t G_LPNXP_EXTr_t;
#define G_LPNXP_EXTr_CLR BCM53128_A0_G_LPNXP_EXTr_CLR
#define G_LPNXP_EXTr_SET BCM53128_A0_G_LPNXP_EXTr_SET
#define G_LPNXP_EXTr_GET BCM53128_A0_G_LPNXP_EXTr_GET
#define G_LPNXP_EXTr_CODE_FIELDf_GET BCM53128_A0_G_LPNXP_EXTr_CODE_FIELDf_GET
#define G_LPNXP_EXTr_CODE_FIELDf_SET BCM53128_A0_G_LPNXP_EXTr_CODE_FIELDf_SET
#define G_LPNXP_EXTr_TOGGLEf_GET BCM53128_A0_G_LPNXP_EXTr_TOGGLEf_GET
#define G_LPNXP_EXTr_TOGGLEf_SET BCM53128_A0_G_LPNXP_EXTr_TOGGLEf_SET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET BCM53128_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET BCM53128_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXTr_MES_PAGEf_GET BCM53128_A0_G_LPNXP_EXTr_MES_PAGEf_GET
#define G_LPNXP_EXTr_MES_PAGEf_SET BCM53128_A0_G_LPNXP_EXTr_MES_PAGEf_SET
#define G_LPNXP_EXTr_ACKf_GET BCM53128_A0_G_LPNXP_EXTr_ACKf_GET
#define G_LPNXP_EXTr_ACKf_SET BCM53128_A0_G_LPNXP_EXTr_ACKf_SET
#define G_LPNXP_EXTr_NEXT_PAGEf_GET BCM53128_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET
#define G_LPNXP_EXTr_NEXT_PAGEf_SET BCM53128_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXTr BCM53128_A0_READ_G_LPNXP_EXTr
#define WRITE_G_LPNXP_EXTr BCM53128_A0_WRITE_G_LPNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_LPNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_LPNXP_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53128_A0_G_LPNXP_EXT_P7r 0x00008710

#define BCM53128_A0_G_LPNXP_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_LPNXP_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext_p7[1];
	uint32_t _g_lpnxp_ext_p7;
} BCM53128_A0_G_LPNXP_EXT_P7r_t;

#define BCM53128_A0_G_LPNXP_EXT_P7r_CLR(r) (r).g_lpnxp_ext_p7[0] = 0
#define BCM53128_A0_G_LPNXP_EXT_P7r_SET(r,d) (r).g_lpnxp_ext_p7[0] = d
#define BCM53128_A0_G_LPNXP_EXT_P7r_GET(r) (r).g_lpnxp_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_LPNXP_EXT_P7r_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_LPNXP_EXT_P7r_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext_p7[0]=(((r).g_lpnxp_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_LPNXP_EXT_P7r_TOGGLEf_GET(r) ((((r).g_lpnxp_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_LPNXP_EXT_P7r_TOGGLEf_SET(r,f) (r).g_lpnxp_ext_p7[0]=(((r).g_lpnxp_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_LPNXP_EXT_P7r_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_LPNXP_EXT_P7r_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext_p7[0]=(((r).g_lpnxp_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_LPNXP_EXT_P7r_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_LPNXP_EXT_P7r_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext_p7[0]=(((r).g_lpnxp_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_LPNXP_EXT_P7r_ACKf_GET(r) ((((r).g_lpnxp_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_LPNXP_EXT_P7r_ACKf_SET(r,f) (r).g_lpnxp_ext_p7[0]=(((r).g_lpnxp_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_LPNXP_EXT_P7r_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_LPNXP_EXT_P7r_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext_p7[0]=(((r).g_lpnxp_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_LPNXP_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_LPNXP_EXT_P7r,(r._g_lpnxp_ext_p7),2)
#define BCM53128_A0_WRITE_G_LPNXP_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_LPNXP_EXT_P7r,&(r._g_lpnxp_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXT_P7r BCM53128_A0_G_LPNXP_EXT_P7r
#define G_LPNXP_EXT_P7r_SIZE BCM53128_A0_G_LPNXP_EXT_P7r_SIZE
typedef BCM53128_A0_G_LPNXP_EXT_P7r_t G_LPNXP_EXT_P7r_t;
#define G_LPNXP_EXT_P7r_CLR BCM53128_A0_G_LPNXP_EXT_P7r_CLR
#define G_LPNXP_EXT_P7r_SET BCM53128_A0_G_LPNXP_EXT_P7r_SET
#define G_LPNXP_EXT_P7r_GET BCM53128_A0_G_LPNXP_EXT_P7r_GET
#define G_LPNXP_EXT_P7r_CODE_FIELDf_GET BCM53128_A0_G_LPNXP_EXT_P7r_CODE_FIELDf_GET
#define G_LPNXP_EXT_P7r_CODE_FIELDf_SET BCM53128_A0_G_LPNXP_EXT_P7r_CODE_FIELDf_SET
#define G_LPNXP_EXT_P7r_TOGGLEf_GET BCM53128_A0_G_LPNXP_EXT_P7r_TOGGLEf_GET
#define G_LPNXP_EXT_P7r_TOGGLEf_SET BCM53128_A0_G_LPNXP_EXT_P7r_TOGGLEf_SET
#define G_LPNXP_EXT_P7r_ACKNOWLEDGE_2f_GET BCM53128_A0_G_LPNXP_EXT_P7r_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXT_P7r_ACKNOWLEDGE_2f_SET BCM53128_A0_G_LPNXP_EXT_P7r_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXT_P7r_MES_PAGEf_GET BCM53128_A0_G_LPNXP_EXT_P7r_MES_PAGEf_GET
#define G_LPNXP_EXT_P7r_MES_PAGEf_SET BCM53128_A0_G_LPNXP_EXT_P7r_MES_PAGEf_SET
#define G_LPNXP_EXT_P7r_ACKf_GET BCM53128_A0_G_LPNXP_EXT_P7r_ACKf_GET
#define G_LPNXP_EXT_P7r_ACKf_SET BCM53128_A0_G_LPNXP_EXT_P7r_ACKf_SET
#define G_LPNXP_EXT_P7r_NEXT_PAGEf_GET BCM53128_A0_G_LPNXP_EXT_P7r_NEXT_PAGEf_GET
#define G_LPNXP_EXT_P7r_NEXT_PAGEf_SET BCM53128_A0_G_LPNXP_EXT_P7r_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXT_P7r BCM53128_A0_READ_G_LPNXP_EXT_P7r
#define WRITE_G_LPNXP_EXT_P7r BCM53128_A0_WRITE_G_LPNXP_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_LPNXP_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MASTER_SLAVE_SEED
 * BLOCKS:   GPIC0
 * DESC:     Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53128_A0_G_MASTER_SLAVE_SEEDr 0x0000103a

#define BCM53128_A0_G_MASTER_SLAVE_SEEDr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED.
 *
 */
typedef union BCM53128_A0_G_MASTER_SLAVE_SEEDr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed[1];
	uint32_t _g_master_slave_seed;
} BCM53128_A0_G_MASTER_SLAVE_SEEDr_t;

#define BCM53128_A0_G_MASTER_SLAVE_SEEDr_CLR(r) (r).g_master_slave_seed[0] = 0
#define BCM53128_A0_G_MASTER_SLAVE_SEEDr_SET(r,d) (r).g_master_slave_seed[0] = d
#define BCM53128_A0_G_MASTER_SLAVE_SEEDr_GET(r) (r).g_master_slave_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MASTER_SLAVE_SEEDr_SEEDf_GET(r) (((r).g_master_slave_seed[0]) & 0xffff)
#define BCM53128_A0_G_MASTER_SLAVE_SEEDr_SEEDf_SET(r,f) (r).g_master_slave_seed[0]=(((r).g_master_slave_seed[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED.
 *
 */
#define BCM53128_A0_READ_G_MASTER_SLAVE_SEEDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_MASTER_SLAVE_SEEDr,(r._g_master_slave_seed),2)
#define BCM53128_A0_WRITE_G_MASTER_SLAVE_SEEDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_MASTER_SLAVE_SEEDr,&(r._g_master_slave_seed),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEEDr BCM53128_A0_G_MASTER_SLAVE_SEEDr
#define G_MASTER_SLAVE_SEEDr_SIZE BCM53128_A0_G_MASTER_SLAVE_SEEDr_SIZE
typedef BCM53128_A0_G_MASTER_SLAVE_SEEDr_t G_MASTER_SLAVE_SEEDr_t;
#define G_MASTER_SLAVE_SEEDr_CLR BCM53128_A0_G_MASTER_SLAVE_SEEDr_CLR
#define G_MASTER_SLAVE_SEEDr_SET BCM53128_A0_G_MASTER_SLAVE_SEEDr_SET
#define G_MASTER_SLAVE_SEEDr_GET BCM53128_A0_G_MASTER_SLAVE_SEEDr_GET
#define G_MASTER_SLAVE_SEEDr_SEEDf_GET BCM53128_A0_G_MASTER_SLAVE_SEEDr_SEEDf_GET
#define G_MASTER_SLAVE_SEEDr_SEEDf_SET BCM53128_A0_G_MASTER_SLAVE_SEEDr_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEEDr BCM53128_A0_READ_G_MASTER_SLAVE_SEEDr
#define WRITE_G_MASTER_SLAVE_SEEDr BCM53128_A0_WRITE_G_MASTER_SLAVE_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MASTER_SLAVE_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr 0x0000883a

#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT.
 *
 */
typedef union BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext[1];
	uint32_t _g_master_slave_seed_ext;
} BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_t;

#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_CLR(r) (r).g_master_slave_seed_ext[0] = 0
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SET(r,d) (r).g_master_slave_seed_ext[0] = d
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_GET(r) (r).g_master_slave_seed_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET(r) (((r).g_master_slave_seed_ext[0]) & 0xffff)
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET(r,f) (r).g_master_slave_seed_ext[0]=(((r).g_master_slave_seed_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT.
 *
 */
#define BCM53128_A0_READ_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr,(r._g_master_slave_seed_ext),2)
#define BCM53128_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr,&(r._g_master_slave_seed_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXTr BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr
#define G_MASTER_SLAVE_SEED_EXTr_SIZE BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE
typedef BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_t G_MASTER_SLAVE_SEED_EXTr_t;
#define G_MASTER_SLAVE_SEED_EXTr_CLR BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_CLR
#define G_MASTER_SLAVE_SEED_EXTr_SET BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SET
#define G_MASTER_SLAVE_SEED_EXTr_GET BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXTr BCM53128_A0_READ_G_MASTER_SLAVE_SEED_EXTr
#define WRITE_G_MASTER_SLAVE_SEED_EXTr BCM53128_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MASTER_SLAVE_SEED_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r 0x0000873a

#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext_p7[1];
	uint32_t _g_master_slave_seed_ext_p7;
} BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_t;

#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_CLR(r) (r).g_master_slave_seed_ext_p7[0] = 0
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SET(r,d) (r).g_master_slave_seed_ext_p7[0] = d
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_GET(r) (r).g_master_slave_seed_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SEEDf_GET(r) (((r).g_master_slave_seed_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SEEDf_SET(r,f) (r).g_master_slave_seed_ext_p7[0]=(((r).g_master_slave_seed_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_MASTER_SLAVE_SEED_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r,(r._g_master_slave_seed_ext_p7),2)
#define BCM53128_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r,&(r._g_master_slave_seed_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXT_P7r BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r
#define G_MASTER_SLAVE_SEED_EXT_P7r_SIZE BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SIZE
typedef BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_t G_MASTER_SLAVE_SEED_EXT_P7r_t;
#define G_MASTER_SLAVE_SEED_EXT_P7r_CLR BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_CLR
#define G_MASTER_SLAVE_SEED_EXT_P7r_SET BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SET
#define G_MASTER_SLAVE_SEED_EXT_P7r_GET BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_GET
#define G_MASTER_SLAVE_SEED_EXT_P7r_SEEDf_GET BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXT_P7r_SEEDf_SET BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXT_P7r BCM53128_A0_READ_G_MASTER_SLAVE_SEED_EXT_P7r
#define WRITE_G_MASTER_SLAVE_SEED_EXT_P7r BCM53128_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MASTER_SLAVE_SEED_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MIICTL
 * BLOCKS:   GPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53128_A0_G_MIICTLr 0x00001000

#define BCM53128_A0_G_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL.
 *
 */
typedef union BCM53128_A0_G_MIICTLr_s {
	uint32_t v[1];
	uint32_t g_miictl[1];
	uint32_t _g_miictl;
} BCM53128_A0_G_MIICTLr_t;

#define BCM53128_A0_G_MIICTLr_CLR(r) (r).g_miictl[0] = 0
#define BCM53128_A0_G_MIICTLr_SET(r,d) (r).g_miictl[0] = d
#define BCM53128_A0_G_MIICTLr_GET(r) (r).g_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MIICTLr_RESERVEDf_GET(r) (((r).g_miictl[0]) & 0x3f)
#define BCM53128_A0_G_MIICTLr_RESERVEDf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_G_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl[0]) >> 6) & 0x1)
#define BCM53128_A0_G_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_MIICTLr_COL_TESTf_GET(r) ((((r).g_miictl[0]) >> 7) & 0x1)
#define BCM53128_A0_G_MIICTLr_COL_TESTf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_MIICTLr_DUPLEX_MODf_GET(r) ((((r).g_miictl[0]) >> 8) & 0x1)
#define BCM53128_A0_G_MIICTLr_DUPLEX_MODf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_MIICTLr_RE_ANf_GET(r) ((((r).g_miictl[0]) >> 9) & 0x1)
#define BCM53128_A0_G_MIICTLr_RE_ANf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_MIICTLr_ISOLATEf_GET(r) ((((r).g_miictl[0]) >> 10) & 0x1)
#define BCM53128_A0_G_MIICTLr_ISOLATEf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_MIICTLr_PWR_DOWNf_GET(r) ((((r).g_miictl[0]) >> 11) & 0x1)
#define BCM53128_A0_G_MIICTLr_PWR_DOWNf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_MIICTLr_AN_ENf_GET(r) ((((r).g_miictl[0]) >> 12) & 0x1)
#define BCM53128_A0_G_MIICTLr_AN_ENf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl[0]) >> 13) & 0x1)
#define BCM53128_A0_G_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_MIICTLr_LOOPBACKf_GET(r) ((((r).g_miictl[0]) >> 14) & 0x1)
#define BCM53128_A0_G_MIICTLr_LOOPBACKf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_MIICTLr_RESETf_GET(r) ((((r).g_miictl[0]) >> 15) & 0x1)
#define BCM53128_A0_G_MIICTLr_RESETf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL.
 *
 */
#define BCM53128_A0_READ_G_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_MIICTLr,(r._g_miictl),2)
#define BCM53128_A0_WRITE_G_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_MIICTLr,&(r._g_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTLr BCM53128_A0_G_MIICTLr
#define G_MIICTLr_SIZE BCM53128_A0_G_MIICTLr_SIZE
typedef BCM53128_A0_G_MIICTLr_t G_MIICTLr_t;
#define G_MIICTLr_CLR BCM53128_A0_G_MIICTLr_CLR
#define G_MIICTLr_SET BCM53128_A0_G_MIICTLr_SET
#define G_MIICTLr_GET BCM53128_A0_G_MIICTLr_GET
#define G_MIICTLr_RESERVEDf_GET BCM53128_A0_G_MIICTLr_RESERVEDf_GET
#define G_MIICTLr_RESERVEDf_SET BCM53128_A0_G_MIICTLr_RESERVEDf_SET
#define G_MIICTLr_SPD_SEL_MSBf_GET BCM53128_A0_G_MIICTLr_SPD_SEL_MSBf_GET
#define G_MIICTLr_SPD_SEL_MSBf_SET BCM53128_A0_G_MIICTLr_SPD_SEL_MSBf_SET
#define G_MIICTLr_COL_TESTf_GET BCM53128_A0_G_MIICTLr_COL_TESTf_GET
#define G_MIICTLr_COL_TESTf_SET BCM53128_A0_G_MIICTLr_COL_TESTf_SET
#define G_MIICTLr_DUPLEX_MODf_GET BCM53128_A0_G_MIICTLr_DUPLEX_MODf_GET
#define G_MIICTLr_DUPLEX_MODf_SET BCM53128_A0_G_MIICTLr_DUPLEX_MODf_SET
#define G_MIICTLr_RE_ANf_GET BCM53128_A0_G_MIICTLr_RE_ANf_GET
#define G_MIICTLr_RE_ANf_SET BCM53128_A0_G_MIICTLr_RE_ANf_SET
#define G_MIICTLr_ISOLATEf_GET BCM53128_A0_G_MIICTLr_ISOLATEf_GET
#define G_MIICTLr_ISOLATEf_SET BCM53128_A0_G_MIICTLr_ISOLATEf_SET
#define G_MIICTLr_PWR_DOWNf_GET BCM53128_A0_G_MIICTLr_PWR_DOWNf_GET
#define G_MIICTLr_PWR_DOWNf_SET BCM53128_A0_G_MIICTLr_PWR_DOWNf_SET
#define G_MIICTLr_AN_ENf_GET BCM53128_A0_G_MIICTLr_AN_ENf_GET
#define G_MIICTLr_AN_ENf_SET BCM53128_A0_G_MIICTLr_AN_ENf_SET
#define G_MIICTLr_SPD_SEL_LSBf_GET BCM53128_A0_G_MIICTLr_SPD_SEL_LSBf_GET
#define G_MIICTLr_SPD_SEL_LSBf_SET BCM53128_A0_G_MIICTLr_SPD_SEL_LSBf_SET
#define G_MIICTLr_LOOPBACKf_GET BCM53128_A0_G_MIICTLr_LOOPBACKf_GET
#define G_MIICTLr_LOOPBACKf_SET BCM53128_A0_G_MIICTLr_LOOPBACKf_SET
#define G_MIICTLr_RESETf_GET BCM53128_A0_G_MIICTLr_RESETf_GET
#define G_MIICTLr_RESETf_SET BCM53128_A0_G_MIICTLr_RESETf_SET
#define READ_G_MIICTLr BCM53128_A0_READ_G_MIICTLr
#define WRITE_G_MIICTLr BCM53128_A0_WRITE_G_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MIICTL_EXT
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53128_A0_G_MIICTL_EXTr 0x00008800

#define BCM53128_A0_G_MIICTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT.
 *
 */
typedef union BCM53128_A0_G_MIICTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_miictl_ext[1];
	uint32_t _g_miictl_ext;
} BCM53128_A0_G_MIICTL_EXTr_t;

#define BCM53128_A0_G_MIICTL_EXTr_CLR(r) (r).g_miictl_ext[0] = 0
#define BCM53128_A0_G_MIICTL_EXTr_SET(r,d) (r).g_miictl_ext[0] = d
#define BCM53128_A0_G_MIICTL_EXTr_GET(r) (r).g_miictl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MIICTL_EXTr_RESERVEDf_GET(r) (((r).g_miictl_ext[0]) & 0x3f)
#define BCM53128_A0_G_MIICTL_EXTr_RESERVEDf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext[0]) >> 6) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_MIICTL_EXTr_COL_TESTf_GET(r) ((((r).g_miictl_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_COL_TESTf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_MIICTL_EXTr_RE_ANf_GET(r) ((((r).g_miictl_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_RE_ANf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_MIICTL_EXTr_ISOLATEf_GET(r) ((((r).g_miictl_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_ISOLATEf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_MIICTL_EXTr_PWR_DOWNf_GET(r) ((((r).g_miictl_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_PWR_DOWNf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_MIICTL_EXTr_AN_ENf_GET(r) ((((r).g_miictl_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_AN_ENf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_MIICTL_EXTr_LOOPBACKf_GET(r) ((((r).g_miictl_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_LOOPBACKf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_MIICTL_EXTr_RESETf_GET(r) ((((r).g_miictl_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_MIICTL_EXTr_RESETf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT.
 *
 */
#define BCM53128_A0_READ_G_MIICTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MIICTL_EXTr,(r._g_miictl_ext),2)
#define BCM53128_A0_WRITE_G_MIICTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MIICTL_EXTr,&(r._g_miictl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXTr BCM53128_A0_G_MIICTL_EXTr
#define G_MIICTL_EXTr_SIZE BCM53128_A0_G_MIICTL_EXTr_SIZE
typedef BCM53128_A0_G_MIICTL_EXTr_t G_MIICTL_EXTr_t;
#define G_MIICTL_EXTr_CLR BCM53128_A0_G_MIICTL_EXTr_CLR
#define G_MIICTL_EXTr_SET BCM53128_A0_G_MIICTL_EXTr_SET
#define G_MIICTL_EXTr_GET BCM53128_A0_G_MIICTL_EXTr_GET
#define G_MIICTL_EXTr_RESERVEDf_GET BCM53128_A0_G_MIICTL_EXTr_RESERVEDf_GET
#define G_MIICTL_EXTr_RESERVEDf_SET BCM53128_A0_G_MIICTL_EXTr_RESERVEDf_SET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_GET BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_SET BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET
#define G_MIICTL_EXTr_COL_TESTf_GET BCM53128_A0_G_MIICTL_EXTr_COL_TESTf_GET
#define G_MIICTL_EXTr_COL_TESTf_SET BCM53128_A0_G_MIICTL_EXTr_COL_TESTf_SET
#define G_MIICTL_EXTr_DUPLEX_MODf_GET BCM53128_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET
#define G_MIICTL_EXTr_DUPLEX_MODf_SET BCM53128_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET
#define G_MIICTL_EXTr_RE_ANf_GET BCM53128_A0_G_MIICTL_EXTr_RE_ANf_GET
#define G_MIICTL_EXTr_RE_ANf_SET BCM53128_A0_G_MIICTL_EXTr_RE_ANf_SET
#define G_MIICTL_EXTr_ISOLATEf_GET BCM53128_A0_G_MIICTL_EXTr_ISOLATEf_GET
#define G_MIICTL_EXTr_ISOLATEf_SET BCM53128_A0_G_MIICTL_EXTr_ISOLATEf_SET
#define G_MIICTL_EXTr_PWR_DOWNf_GET BCM53128_A0_G_MIICTL_EXTr_PWR_DOWNf_GET
#define G_MIICTL_EXTr_PWR_DOWNf_SET BCM53128_A0_G_MIICTL_EXTr_PWR_DOWNf_SET
#define G_MIICTL_EXTr_AN_ENf_GET BCM53128_A0_G_MIICTL_EXTr_AN_ENf_GET
#define G_MIICTL_EXTr_AN_ENf_SET BCM53128_A0_G_MIICTL_EXTr_AN_ENf_SET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_GET BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_SET BCM53128_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET
#define G_MIICTL_EXTr_LOOPBACKf_GET BCM53128_A0_G_MIICTL_EXTr_LOOPBACKf_GET
#define G_MIICTL_EXTr_LOOPBACKf_SET BCM53128_A0_G_MIICTL_EXTr_LOOPBACKf_SET
#define G_MIICTL_EXTr_RESETf_GET BCM53128_A0_G_MIICTL_EXTr_RESETf_GET
#define G_MIICTL_EXTr_RESETf_SET BCM53128_A0_G_MIICTL_EXTr_RESETf_SET
#define READ_G_MIICTL_EXTr BCM53128_A0_READ_G_MIICTL_EXTr
#define WRITE_G_MIICTL_EXTr BCM53128_A0_WRITE_G_MIICTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MIICTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MIICTL_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53128_A0_G_MIICTL_EXT_P7r 0x00008700

#define BCM53128_A0_G_MIICTL_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_MIICTL_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_miictl_ext_p7[1];
	uint32_t _g_miictl_ext_p7;
} BCM53128_A0_G_MIICTL_EXT_P7r_t;

#define BCM53128_A0_G_MIICTL_EXT_P7r_CLR(r) (r).g_miictl_ext_p7[0] = 0
#define BCM53128_A0_G_MIICTL_EXT_P7r_SET(r,d) (r).g_miictl_ext_p7[0] = d
#define BCM53128_A0_G_MIICTL_EXT_P7r_GET(r) (r).g_miictl_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MIICTL_EXT_P7r_RESERVEDf_GET(r) (((r).g_miictl_ext_p7[0]) & 0x3f)
#define BCM53128_A0_G_MIICTL_EXT_P7r_RESERVEDf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 6) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_MIICTL_EXT_P7r_COL_TESTf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_COL_TESTf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_MIICTL_EXT_P7r_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_MIICTL_EXT_P7r_RE_ANf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_RE_ANf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_MIICTL_EXT_P7r_ISOLATEf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_ISOLATEf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_MIICTL_EXT_P7r_PWR_DOWNf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_PWR_DOWNf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_MIICTL_EXT_P7r_AN_ENf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_AN_ENf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_MIICTL_EXT_P7r_LOOPBACKf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_LOOPBACKf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_MIICTL_EXT_P7r_RESETf_GET(r) ((((r).g_miictl_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_MIICTL_EXT_P7r_RESETf_SET(r,f) (r).g_miictl_ext_p7[0]=(((r).g_miictl_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_MIICTL_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MIICTL_EXT_P7r,(r._g_miictl_ext_p7),2)
#define BCM53128_A0_WRITE_G_MIICTL_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MIICTL_EXT_P7r,&(r._g_miictl_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXT_P7r BCM53128_A0_G_MIICTL_EXT_P7r
#define G_MIICTL_EXT_P7r_SIZE BCM53128_A0_G_MIICTL_EXT_P7r_SIZE
typedef BCM53128_A0_G_MIICTL_EXT_P7r_t G_MIICTL_EXT_P7r_t;
#define G_MIICTL_EXT_P7r_CLR BCM53128_A0_G_MIICTL_EXT_P7r_CLR
#define G_MIICTL_EXT_P7r_SET BCM53128_A0_G_MIICTL_EXT_P7r_SET
#define G_MIICTL_EXT_P7r_GET BCM53128_A0_G_MIICTL_EXT_P7r_GET
#define G_MIICTL_EXT_P7r_RESERVEDf_GET BCM53128_A0_G_MIICTL_EXT_P7r_RESERVEDf_GET
#define G_MIICTL_EXT_P7r_RESERVEDf_SET BCM53128_A0_G_MIICTL_EXT_P7r_RESERVEDf_SET
#define G_MIICTL_EXT_P7r_SPD_SEL_MSBf_GET BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_MSBf_GET
#define G_MIICTL_EXT_P7r_SPD_SEL_MSBf_SET BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_MSBf_SET
#define G_MIICTL_EXT_P7r_COL_TESTf_GET BCM53128_A0_G_MIICTL_EXT_P7r_COL_TESTf_GET
#define G_MIICTL_EXT_P7r_COL_TESTf_SET BCM53128_A0_G_MIICTL_EXT_P7r_COL_TESTf_SET
#define G_MIICTL_EXT_P7r_DUPLEX_MODf_GET BCM53128_A0_G_MIICTL_EXT_P7r_DUPLEX_MODf_GET
#define G_MIICTL_EXT_P7r_DUPLEX_MODf_SET BCM53128_A0_G_MIICTL_EXT_P7r_DUPLEX_MODf_SET
#define G_MIICTL_EXT_P7r_RE_ANf_GET BCM53128_A0_G_MIICTL_EXT_P7r_RE_ANf_GET
#define G_MIICTL_EXT_P7r_RE_ANf_SET BCM53128_A0_G_MIICTL_EXT_P7r_RE_ANf_SET
#define G_MIICTL_EXT_P7r_ISOLATEf_GET BCM53128_A0_G_MIICTL_EXT_P7r_ISOLATEf_GET
#define G_MIICTL_EXT_P7r_ISOLATEf_SET BCM53128_A0_G_MIICTL_EXT_P7r_ISOLATEf_SET
#define G_MIICTL_EXT_P7r_PWR_DOWNf_GET BCM53128_A0_G_MIICTL_EXT_P7r_PWR_DOWNf_GET
#define G_MIICTL_EXT_P7r_PWR_DOWNf_SET BCM53128_A0_G_MIICTL_EXT_P7r_PWR_DOWNf_SET
#define G_MIICTL_EXT_P7r_AN_ENf_GET BCM53128_A0_G_MIICTL_EXT_P7r_AN_ENf_GET
#define G_MIICTL_EXT_P7r_AN_ENf_SET BCM53128_A0_G_MIICTL_EXT_P7r_AN_ENf_SET
#define G_MIICTL_EXT_P7r_SPD_SEL_LSBf_GET BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_LSBf_GET
#define G_MIICTL_EXT_P7r_SPD_SEL_LSBf_SET BCM53128_A0_G_MIICTL_EXT_P7r_SPD_SEL_LSBf_SET
#define G_MIICTL_EXT_P7r_LOOPBACKf_GET BCM53128_A0_G_MIICTL_EXT_P7r_LOOPBACKf_GET
#define G_MIICTL_EXT_P7r_LOOPBACKf_SET BCM53128_A0_G_MIICTL_EXT_P7r_LOOPBACKf_SET
#define G_MIICTL_EXT_P7r_RESETf_GET BCM53128_A0_G_MIICTL_EXT_P7r_RESETf_GET
#define G_MIICTL_EXT_P7r_RESETf_SET BCM53128_A0_G_MIICTL_EXT_P7r_RESETf_SET
#define READ_G_MIICTL_EXT_P7r BCM53128_A0_READ_G_MIICTL_EXT_P7r
#define WRITE_G_MIICTL_EXT_P7r BCM53128_A0_WRITE_G_MIICTL_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MIICTL_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MIISTS
 * BLOCKS:   GPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53128_A0_G_MIISTSr 0x00001002

#define BCM53128_A0_G_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS.
 *
 */
typedef union BCM53128_A0_G_MIISTSr_s {
	uint32_t v[1];
	uint32_t g_miists[1];
	uint32_t _g_miists;
} BCM53128_A0_G_MIISTSr_t;

#define BCM53128_A0_G_MIISTSr_CLR(r) (r).g_miists[0] = 0
#define BCM53128_A0_G_MIISTSr_SET(r,d) (r).g_miists[0] = d
#define BCM53128_A0_G_MIISTSr_GET(r) (r).g_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MIISTSr_EXT_CAPf_GET(r) (((r).g_miists[0]) & 0x1)
#define BCM53128_A0_G_MIISTSr_EXT_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_MIISTSr_JABBER_DETf_GET(r) ((((r).g_miists[0]) >> 1) & 0x1)
#define BCM53128_A0_G_MIISTSr_JABBER_DETf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_MIISTSr_LINK_STAf_GET(r) ((((r).g_miists[0]) >> 2) & 0x1)
#define BCM53128_A0_G_MIISTSr_LINK_STAf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists[0]) >> 3) & 0x1)
#define BCM53128_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_MIISTSr_REMOTE_FAULTf_GET(r) ((((r).g_miists[0]) >> 4) & 0x1)
#define BCM53128_A0_G_MIISTSr_REMOTE_FAULTf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists[0]) >> 5) & 0x1)
#define BCM53128_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).g_miists[0]) >> 6) & 0x1)
#define BCM53128_A0_G_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_MIISTSr_RESERVEDf_GET(r) ((((r).g_miists[0]) >> 7) & 0x1)
#define BCM53128_A0_G_MIISTSr_RESERVEDf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_MIISTSr_EXT_STSf_GET(r) ((((r).g_miists[0]) >> 8) & 0x1)
#define BCM53128_A0_G_MIISTSr_EXT_STSf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_MIISTSr_B100T2_HD_CAPf_GET(r) ((((r).g_miists[0]) >> 9) & 0x1)
#define BCM53128_A0_G_MIISTSr_B100T2_HD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_MIISTSr_B100T2_FD_CAPf_GET(r) ((((r).g_miists[0]) >> 10) & 0x1)
#define BCM53128_A0_G_MIISTSr_B100T2_FD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_MIISTSr_B10T_CAPf_GET(r) ((((r).g_miists[0]) >> 11) & 0x1)
#define BCM53128_A0_G_MIISTSr_B10T_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 12) & 0x1)
#define BCM53128_A0_G_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_MIISTSr_B100TX_CAPf_GET(r) ((((r).g_miists[0]) >> 13) & 0x1)
#define BCM53128_A0_G_MIISTSr_B100TX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 14) & 0x1)
#define BCM53128_A0_G_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_MIISTSr_B100T4_CAPf_GET(r) ((((r).g_miists[0]) >> 15) & 0x1)
#define BCM53128_A0_G_MIISTSr_B100T4_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS.
 *
 */
#define BCM53128_A0_READ_G_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_MIISTSr,(r._g_miists),2)
#define BCM53128_A0_WRITE_G_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_MIISTSr,&(r._g_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTSr BCM53128_A0_G_MIISTSr
#define G_MIISTSr_SIZE BCM53128_A0_G_MIISTSr_SIZE
typedef BCM53128_A0_G_MIISTSr_t G_MIISTSr_t;
#define G_MIISTSr_CLR BCM53128_A0_G_MIISTSr_CLR
#define G_MIISTSr_SET BCM53128_A0_G_MIISTSr_SET
#define G_MIISTSr_GET BCM53128_A0_G_MIISTSr_GET
#define G_MIISTSr_EXT_CAPf_GET BCM53128_A0_G_MIISTSr_EXT_CAPf_GET
#define G_MIISTSr_EXT_CAPf_SET BCM53128_A0_G_MIISTSr_EXT_CAPf_SET
#define G_MIISTSr_JABBER_DETf_GET BCM53128_A0_G_MIISTSr_JABBER_DETf_GET
#define G_MIISTSr_JABBER_DETf_SET BCM53128_A0_G_MIISTSr_JABBER_DETf_SET
#define G_MIISTSr_LINK_STAf_GET BCM53128_A0_G_MIISTSr_LINK_STAf_GET
#define G_MIISTSr_LINK_STAf_SET BCM53128_A0_G_MIISTSr_LINK_STAf_SET
#define G_MIISTSr_AUTO_NEGO_CAPf_GET BCM53128_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET
#define G_MIISTSr_AUTO_NEGO_CAPf_SET BCM53128_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET
#define G_MIISTSr_REMOTE_FAULTf_GET BCM53128_A0_G_MIISTSr_REMOTE_FAULTf_GET
#define G_MIISTSr_REMOTE_FAULTf_SET BCM53128_A0_G_MIISTSr_REMOTE_FAULTf_SET
#define G_MIISTSr_AUTO_NEGO_COMPf_GET BCM53128_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET
#define G_MIISTSr_AUTO_NEGO_COMPf_SET BCM53128_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET
#define G_MIISTSr_MF_PRE_SUPf_GET BCM53128_A0_G_MIISTSr_MF_PRE_SUPf_GET
#define G_MIISTSr_MF_PRE_SUPf_SET BCM53128_A0_G_MIISTSr_MF_PRE_SUPf_SET
#define G_MIISTSr_RESERVEDf_GET BCM53128_A0_G_MIISTSr_RESERVEDf_GET
#define G_MIISTSr_RESERVEDf_SET BCM53128_A0_G_MIISTSr_RESERVEDf_SET
#define G_MIISTSr_EXT_STSf_GET BCM53128_A0_G_MIISTSr_EXT_STSf_GET
#define G_MIISTSr_EXT_STSf_SET BCM53128_A0_G_MIISTSr_EXT_STSf_SET
#define G_MIISTSr_B100T2_HD_CAPf_GET BCM53128_A0_G_MIISTSr_B100T2_HD_CAPf_GET
#define G_MIISTSr_B100T2_HD_CAPf_SET BCM53128_A0_G_MIISTSr_B100T2_HD_CAPf_SET
#define G_MIISTSr_B100T2_FD_CAPf_GET BCM53128_A0_G_MIISTSr_B100T2_FD_CAPf_GET
#define G_MIISTSr_B100T2_FD_CAPf_SET BCM53128_A0_G_MIISTSr_B100T2_FD_CAPf_SET
#define G_MIISTSr_B10T_CAPf_GET BCM53128_A0_G_MIISTSr_B10T_CAPf_GET
#define G_MIISTSr_B10T_CAPf_SET BCM53128_A0_G_MIISTSr_B10T_CAPf_SET
#define G_MIISTSr_B10T_FDX_CAPf_GET BCM53128_A0_G_MIISTSr_B10T_FDX_CAPf_GET
#define G_MIISTSr_B10T_FDX_CAPf_SET BCM53128_A0_G_MIISTSr_B10T_FDX_CAPf_SET
#define G_MIISTSr_B100TX_CAPf_GET BCM53128_A0_G_MIISTSr_B100TX_CAPf_GET
#define G_MIISTSr_B100TX_CAPf_SET BCM53128_A0_G_MIISTSr_B100TX_CAPf_SET
#define G_MIISTSr_B100TX_FDX_CAPf_GET BCM53128_A0_G_MIISTSr_B100TX_FDX_CAPf_GET
#define G_MIISTSr_B100TX_FDX_CAPf_SET BCM53128_A0_G_MIISTSr_B100TX_FDX_CAPf_SET
#define G_MIISTSr_B100T4_CAPf_GET BCM53128_A0_G_MIISTSr_B100T4_CAPf_GET
#define G_MIISTSr_B100T4_CAPf_SET BCM53128_A0_G_MIISTSr_B100T4_CAPf_SET
#define READ_G_MIISTSr BCM53128_A0_READ_G_MIISTSr
#define WRITE_G_MIISTSr BCM53128_A0_WRITE_G_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MIISTS_EXT
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53128_A0_G_MIISTS_EXTr 0x00008802

#define BCM53128_A0_G_MIISTS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT.
 *
 */
typedef union BCM53128_A0_G_MIISTS_EXTr_s {
	uint32_t v[1];
	uint32_t g_miists_ext[1];
	uint32_t _g_miists_ext;
} BCM53128_A0_G_MIISTS_EXTr_t;

#define BCM53128_A0_G_MIISTS_EXTr_CLR(r) (r).g_miists_ext[0] = 0
#define BCM53128_A0_G_MIISTS_EXTr_SET(r,d) (r).g_miists_ext[0] = d
#define BCM53128_A0_G_MIISTS_EXTr_GET(r) (r).g_miists_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MIISTS_EXTr_EXT_CAPf_GET(r) (((r).g_miists_ext[0]) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_EXT_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_MIISTS_EXTr_JABBER_DETf_GET(r) ((((r).g_miists_ext[0]) >> 1) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_JABBER_DETf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_MIISTS_EXTr_LINK_STAf_GET(r) ((((r).g_miists_ext[0]) >> 2) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_LINK_STAf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 3) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_MIISTS_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext[0]) >> 4) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext[0]) >> 6) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_MIISTS_EXTr_RESERVEDf_GET(r) ((((r).g_miists_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_RESERVEDf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_MIISTS_EXTr_EXT_STSf_GET(r) ((((r).g_miists_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_EXT_STSf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_MIISTS_EXTr_B10T_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B10T_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_MIISTS_EXTr_B100TX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B100TX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_MIISTS_EXTr_B100T4_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_MIISTS_EXTr_B100T4_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT.
 *
 */
#define BCM53128_A0_READ_G_MIISTS_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MIISTS_EXTr,(r._g_miists_ext),2)
#define BCM53128_A0_WRITE_G_MIISTS_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MIISTS_EXTr,&(r._g_miists_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXTr BCM53128_A0_G_MIISTS_EXTr
#define G_MIISTS_EXTr_SIZE BCM53128_A0_G_MIISTS_EXTr_SIZE
typedef BCM53128_A0_G_MIISTS_EXTr_t G_MIISTS_EXTr_t;
#define G_MIISTS_EXTr_CLR BCM53128_A0_G_MIISTS_EXTr_CLR
#define G_MIISTS_EXTr_SET BCM53128_A0_G_MIISTS_EXTr_SET
#define G_MIISTS_EXTr_GET BCM53128_A0_G_MIISTS_EXTr_GET
#define G_MIISTS_EXTr_EXT_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_EXT_CAPf_GET
#define G_MIISTS_EXTr_EXT_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_EXT_CAPf_SET
#define G_MIISTS_EXTr_JABBER_DETf_GET BCM53128_A0_G_MIISTS_EXTr_JABBER_DETf_GET
#define G_MIISTS_EXTr_JABBER_DETf_SET BCM53128_A0_G_MIISTS_EXTr_JABBER_DETf_SET
#define G_MIISTS_EXTr_LINK_STAf_GET BCM53128_A0_G_MIISTS_EXTr_LINK_STAf_GET
#define G_MIISTS_EXTr_LINK_STAf_SET BCM53128_A0_G_MIISTS_EXTr_LINK_STAf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXTr_REMOTE_FAULTf_GET BCM53128_A0_G_MIISTS_EXTr_REMOTE_FAULTf_GET
#define G_MIISTS_EXTr_REMOTE_FAULTf_SET BCM53128_A0_G_MIISTS_EXTr_REMOTE_FAULTf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET BCM53128_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXTr_MF_PRE_SUPf_GET BCM53128_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET
#define G_MIISTS_EXTr_MF_PRE_SUPf_SET BCM53128_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET
#define G_MIISTS_EXTr_RESERVEDf_GET BCM53128_A0_G_MIISTS_EXTr_RESERVEDf_GET
#define G_MIISTS_EXTr_RESERVEDf_SET BCM53128_A0_G_MIISTS_EXTr_RESERVEDf_SET
#define G_MIISTS_EXTr_EXT_STSf_GET BCM53128_A0_G_MIISTS_EXTr_EXT_STSf_GET
#define G_MIISTS_EXTr_EXT_STSf_SET BCM53128_A0_G_MIISTS_EXTr_EXT_STSf_SET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET
#define G_MIISTS_EXTr_B10T_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B10T_CAPf_GET
#define G_MIISTS_EXTr_B10T_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B10T_CAPf_SET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B100TX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B100TX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100T4_CAPf_GET BCM53128_A0_G_MIISTS_EXTr_B100T4_CAPf_GET
#define G_MIISTS_EXTr_B100T4_CAPf_SET BCM53128_A0_G_MIISTS_EXTr_B100T4_CAPf_SET
#define READ_G_MIISTS_EXTr BCM53128_A0_READ_G_MIISTS_EXTr
#define WRITE_G_MIISTS_EXTr BCM53128_A0_WRITE_G_MIISTS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MIISTS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MIISTS_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53128_A0_G_MIISTS_EXT_P7r 0x00008702

#define BCM53128_A0_G_MIISTS_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_MIISTS_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_miists_ext_p7[1];
	uint32_t _g_miists_ext_p7;
} BCM53128_A0_G_MIISTS_EXT_P7r_t;

#define BCM53128_A0_G_MIISTS_EXT_P7r_CLR(r) (r).g_miists_ext_p7[0] = 0
#define BCM53128_A0_G_MIISTS_EXT_P7r_SET(r,d) (r).g_miists_ext_p7[0] = d
#define BCM53128_A0_G_MIISTS_EXT_P7r_GET(r) (r).g_miists_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MIISTS_EXT_P7r_EXT_CAPf_GET(r) (((r).g_miists_ext_p7[0]) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_EXT_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_MIISTS_EXT_P7r_JABBER_DETf_GET(r) ((((r).g_miists_ext_p7[0]) >> 1) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_JABBER_DETf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_MIISTS_EXT_P7r_LINK_STAf_GET(r) ((((r).g_miists_ext_p7[0]) >> 2) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_LINK_STAf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 3) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_MIISTS_EXT_P7r_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext_p7[0]) >> 4) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_MIISTS_EXT_P7r_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 6) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_MIISTS_EXT_P7r_RESERVEDf_GET(r) ((((r).g_miists_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_RESERVEDf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_MIISTS_EXT_P7r_EXT_STSf_GET(r) ((((r).g_miists_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_EXT_STSf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B10T_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B10T_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100T4_CAPf_GET(r) ((((r).g_miists_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_MIISTS_EXT_P7r_B100T4_CAPf_SET(r,f) (r).g_miists_ext_p7[0]=(((r).g_miists_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_MIISTS_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MIISTS_EXT_P7r,(r._g_miists_ext_p7),2)
#define BCM53128_A0_WRITE_G_MIISTS_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MIISTS_EXT_P7r,&(r._g_miists_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXT_P7r BCM53128_A0_G_MIISTS_EXT_P7r
#define G_MIISTS_EXT_P7r_SIZE BCM53128_A0_G_MIISTS_EXT_P7r_SIZE
typedef BCM53128_A0_G_MIISTS_EXT_P7r_t G_MIISTS_EXT_P7r_t;
#define G_MIISTS_EXT_P7r_CLR BCM53128_A0_G_MIISTS_EXT_P7r_CLR
#define G_MIISTS_EXT_P7r_SET BCM53128_A0_G_MIISTS_EXT_P7r_SET
#define G_MIISTS_EXT_P7r_GET BCM53128_A0_G_MIISTS_EXT_P7r_GET
#define G_MIISTS_EXT_P7r_EXT_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_EXT_CAPf_GET
#define G_MIISTS_EXT_P7r_EXT_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_EXT_CAPf_SET
#define G_MIISTS_EXT_P7r_JABBER_DETf_GET BCM53128_A0_G_MIISTS_EXT_P7r_JABBER_DETf_GET
#define G_MIISTS_EXT_P7r_JABBER_DETf_SET BCM53128_A0_G_MIISTS_EXT_P7r_JABBER_DETf_SET
#define G_MIISTS_EXT_P7r_LINK_STAf_GET BCM53128_A0_G_MIISTS_EXT_P7r_LINK_STAf_GET
#define G_MIISTS_EXT_P7r_LINK_STAf_SET BCM53128_A0_G_MIISTS_EXT_P7r_LINK_STAf_SET
#define G_MIISTS_EXT_P7r_AUTO_NEGO_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXT_P7r_AUTO_NEGO_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXT_P7r_REMOTE_FAULTf_GET BCM53128_A0_G_MIISTS_EXT_P7r_REMOTE_FAULTf_GET
#define G_MIISTS_EXT_P7r_REMOTE_FAULTf_SET BCM53128_A0_G_MIISTS_EXT_P7r_REMOTE_FAULTf_SET
#define G_MIISTS_EXT_P7r_AUTO_NEGO_COMPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXT_P7r_AUTO_NEGO_COMPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXT_P7r_MF_PRE_SUPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_MF_PRE_SUPf_GET
#define G_MIISTS_EXT_P7r_MF_PRE_SUPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_MF_PRE_SUPf_SET
#define G_MIISTS_EXT_P7r_RESERVEDf_GET BCM53128_A0_G_MIISTS_EXT_P7r_RESERVEDf_GET
#define G_MIISTS_EXT_P7r_RESERVEDf_SET BCM53128_A0_G_MIISTS_EXT_P7r_RESERVEDf_SET
#define G_MIISTS_EXT_P7r_EXT_STSf_GET BCM53128_A0_G_MIISTS_EXT_P7r_EXT_STSf_GET
#define G_MIISTS_EXT_P7r_EXT_STSf_SET BCM53128_A0_G_MIISTS_EXT_P7r_EXT_STSf_SET
#define G_MIISTS_EXT_P7r_B100T2_HD_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_HD_CAPf_GET
#define G_MIISTS_EXT_P7r_B100T2_HD_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_HD_CAPf_SET
#define G_MIISTS_EXT_P7r_B100T2_FD_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_FD_CAPf_GET
#define G_MIISTS_EXT_P7r_B100T2_FD_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B100T2_FD_CAPf_SET
#define G_MIISTS_EXT_P7r_B10T_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B10T_CAPf_GET
#define G_MIISTS_EXT_P7r_B10T_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B10T_CAPf_SET
#define G_MIISTS_EXT_P7r_B10T_FDX_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B10T_FDX_CAPf_GET
#define G_MIISTS_EXT_P7r_B10T_FDX_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B10T_FDX_CAPf_SET
#define G_MIISTS_EXT_P7r_B100TX_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_CAPf_GET
#define G_MIISTS_EXT_P7r_B100TX_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_CAPf_SET
#define G_MIISTS_EXT_P7r_B100TX_FDX_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXT_P7r_B100TX_FDX_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXT_P7r_B100T4_CAPf_GET BCM53128_A0_G_MIISTS_EXT_P7r_B100T4_CAPf_GET
#define G_MIISTS_EXT_P7r_B100T4_CAPf_SET BCM53128_A0_G_MIISTS_EXT_P7r_B100T4_CAPf_SET
#define READ_G_MIISTS_EXT_P7r BCM53128_A0_READ_G_MIISTS_EXT_P7r
#define WRITE_G_MIISTS_EXT_P7r BCM53128_A0_WRITE_G_MIISTS_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MIISTS_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MISC_SHADOW
 * BLOCKS:   GPIC0
 * DESC:     Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53128_A0_G_MISC_SHADOWr 0x00001038

#define BCM53128_A0_G_MISC_SHADOWr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW.
 *
 */
typedef union BCM53128_A0_G_MISC_SHADOWr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow[1];
	uint32_t _g_misc_shadow;
} BCM53128_A0_G_MISC_SHADOWr_t;

#define BCM53128_A0_G_MISC_SHADOWr_CLR(r) (r).g_misc_shadow[0] = 0
#define BCM53128_A0_G_MISC_SHADOWr_SET(r,d) (r).g_misc_shadow[0] = d
#define BCM53128_A0_G_MISC_SHADOWr_GET(r) (r).g_misc_shadow[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow[0]) & 0xffff)
#define BCM53128_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow[0]=(((r).g_misc_shadow[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW.
 *
 */
#define BCM53128_A0_READ_G_MISC_SHADOWr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_MISC_SHADOWr,(r._g_misc_shadow),2)
#define BCM53128_A0_WRITE_G_MISC_SHADOWr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_MISC_SHADOWr,&(r._g_misc_shadow),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOWr BCM53128_A0_G_MISC_SHADOWr
#define G_MISC_SHADOWr_SIZE BCM53128_A0_G_MISC_SHADOWr_SIZE
typedef BCM53128_A0_G_MISC_SHADOWr_t G_MISC_SHADOWr_t;
#define G_MISC_SHADOWr_CLR BCM53128_A0_G_MISC_SHADOWr_CLR
#define G_MISC_SHADOWr_SET BCM53128_A0_G_MISC_SHADOWr_SET
#define G_MISC_SHADOWr_GET BCM53128_A0_G_MISC_SHADOWr_GET
#define G_MISC_SHADOWr_INTERRUPT_MSKf_GET BCM53128_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOWr_INTERRUPT_MSKf_SET BCM53128_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOWr BCM53128_A0_READ_G_MISC_SHADOWr
#define WRITE_G_MISC_SHADOWr BCM53128_A0_WRITE_G_MISC_SHADOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MISC_SHADOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MISC_SHADOW_EXT
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53128_A0_G_MISC_SHADOW_EXTr 0x00008838

#define BCM53128_A0_G_MISC_SHADOW_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT.
 *
 */
typedef union BCM53128_A0_G_MISC_SHADOW_EXTr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext[1];
	uint32_t _g_misc_shadow_ext;
} BCM53128_A0_G_MISC_SHADOW_EXTr_t;

#define BCM53128_A0_G_MISC_SHADOW_EXTr_CLR(r) (r).g_misc_shadow_ext[0] = 0
#define BCM53128_A0_G_MISC_SHADOW_EXTr_SET(r,d) (r).g_misc_shadow_ext[0] = d
#define BCM53128_A0_G_MISC_SHADOW_EXTr_GET(r) (r).g_misc_shadow_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext[0]) & 0xffff)
#define BCM53128_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext[0]=(((r).g_misc_shadow_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT.
 *
 */
#define BCM53128_A0_READ_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MISC_SHADOW_EXTr,(r._g_misc_shadow_ext),2)
#define BCM53128_A0_WRITE_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MISC_SHADOW_EXTr,&(r._g_misc_shadow_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXTr BCM53128_A0_G_MISC_SHADOW_EXTr
#define G_MISC_SHADOW_EXTr_SIZE BCM53128_A0_G_MISC_SHADOW_EXTr_SIZE
typedef BCM53128_A0_G_MISC_SHADOW_EXTr_t G_MISC_SHADOW_EXTr_t;
#define G_MISC_SHADOW_EXTr_CLR BCM53128_A0_G_MISC_SHADOW_EXTr_CLR
#define G_MISC_SHADOW_EXTr_SET BCM53128_A0_G_MISC_SHADOW_EXTr_SET
#define G_MISC_SHADOW_EXTr_GET BCM53128_A0_G_MISC_SHADOW_EXTr_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET BCM53128_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET BCM53128_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXTr BCM53128_A0_READ_G_MISC_SHADOW_EXTr
#define WRITE_G_MISC_SHADOW_EXTr BCM53128_A0_WRITE_G_MISC_SHADOW_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MISC_SHADOW_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_MISC_SHADOW_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r 0x00008738

#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_MISC_SHADOW_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext_p7[1];
	uint32_t _g_misc_shadow_ext_p7;
} BCM53128_A0_G_MISC_SHADOW_EXT_P7r_t;

#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r_CLR(r) (r).g_misc_shadow_ext_p7[0] = 0
#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r_SET(r,d) (r).g_misc_shadow_ext_p7[0] = d
#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r_GET(r) (r).g_misc_shadow_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_MISC_SHADOW_EXT_P7r_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext_p7[0]=(((r).g_misc_shadow_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_MISC_SHADOW_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_MISC_SHADOW_EXT_P7r,(r._g_misc_shadow_ext_p7),2)
#define BCM53128_A0_WRITE_G_MISC_SHADOW_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_MISC_SHADOW_EXT_P7r,&(r._g_misc_shadow_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXT_P7r BCM53128_A0_G_MISC_SHADOW_EXT_P7r
#define G_MISC_SHADOW_EXT_P7r_SIZE BCM53128_A0_G_MISC_SHADOW_EXT_P7r_SIZE
typedef BCM53128_A0_G_MISC_SHADOW_EXT_P7r_t G_MISC_SHADOW_EXT_P7r_t;
#define G_MISC_SHADOW_EXT_P7r_CLR BCM53128_A0_G_MISC_SHADOW_EXT_P7r_CLR
#define G_MISC_SHADOW_EXT_P7r_SET BCM53128_A0_G_MISC_SHADOW_EXT_P7r_SET
#define G_MISC_SHADOW_EXT_P7r_GET BCM53128_A0_G_MISC_SHADOW_EXT_P7r_GET
#define G_MISC_SHADOW_EXT_P7r_INTERRUPT_MSKf_GET BCM53128_A0_G_MISC_SHADOW_EXT_P7r_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXT_P7r_INTERRUPT_MSKf_SET BCM53128_A0_G_MISC_SHADOW_EXT_P7r_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXT_P7r BCM53128_A0_READ_G_MISC_SHADOW_EXT_P7r
#define WRITE_G_MISC_SHADOW_EXT_P7r BCM53128_A0_WRITE_G_MISC_SHADOW_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_MISC_SHADOW_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     10/100/1000 Port N Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED         Reserved.
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3b'b000: No Spanning Tree(default by HW_FWDG_EN).3b'b001: Disable State(default by ~HW_FWDG_EN).3b'b010: Blocking State.3b'b011: Listening State.3b'b100: Learning State.3b'b101: Forwarding State.3b'b110 - 3b'b111: Reserved.Programmed from the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PCTLr 0x00000000

#define BCM53128_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 *
 */
typedef union BCM53128_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM53128_A0_G_PCTLr_t;

#define BCM53128_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM53128_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM53128_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PCTLr_RX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM53128_A0_G_PCTLr_RX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PCTLr_TX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PCTLr_TX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PCTLr_RESERVEDf_GET(r) ((((r).g_pctl[0]) >> 2) & 0x7)
#define BCM53128_A0_G_PCTLr_RESERVEDf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53128_A0_G_PCTLr_G_MISTP_STATEf_GET(r) ((((r).g_pctl[0]) >> 5) & 0x7)
#define BCM53128_A0_G_PCTLr_G_MISTP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access G_PCTL.
 *
 */
#define BCM53128_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_PCTLr,(r._g_pctl),1)
#define BCM53128_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM53128_A0_G_PCTLr
#define G_PCTLr_SIZE BCM53128_A0_G_PCTLr_SIZE
typedef BCM53128_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM53128_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM53128_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM53128_A0_G_PCTLr_GET
#define G_PCTLr_RX_DISf_GET BCM53128_A0_G_PCTLr_RX_DISf_GET
#define G_PCTLr_RX_DISf_SET BCM53128_A0_G_PCTLr_RX_DISf_SET
#define G_PCTLr_TX_DISf_GET BCM53128_A0_G_PCTLr_TX_DISf_GET
#define G_PCTLr_TX_DISf_SET BCM53128_A0_G_PCTLr_TX_DISf_SET
#define G_PCTLr_RESERVEDf_GET BCM53128_A0_G_PCTLr_RESERVEDf_GET
#define G_PCTLr_RESERVEDf_SET BCM53128_A0_G_PCTLr_RESERVEDf_SET
#define G_PCTLr_G_MISTP_STATEf_GET BCM53128_A0_G_PCTLr_G_MISTP_STATEf_GET
#define G_PCTLr_G_MISTP_STATEf_SET BCM53128_A0_G_PCTLr_G_MISTP_STATEf_SET
#define READ_G_PCTLr BCM53128_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM53128_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHYIDH
 * BLOCKS:   GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHYIDHr 0x00001004

#define BCM53128_A0_G_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH.
 *
 */
typedef union BCM53128_A0_G_PHYIDHr_s {
	uint32_t v[1];
	uint32_t g_phyidh[1];
	uint32_t _g_phyidh;
} BCM53128_A0_G_PHYIDHr_t;

#define BCM53128_A0_G_PHYIDHr_CLR(r) (r).g_phyidh[0] = 0
#define BCM53128_A0_G_PHYIDHr_SET(r,d) (r).g_phyidh[0] = d
#define BCM53128_A0_G_PHYIDHr_GET(r) (r).g_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHYIDHr_OUIf_GET(r) (((r).g_phyidh[0]) & 0xffff)
#define BCM53128_A0_G_PHYIDHr_OUIf_SET(r,f) (r).g_phyidh[0]=(((r).g_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH.
 *
 */
#define BCM53128_A0_READ_G_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_PHYIDHr,(r._g_phyidh),2)
#define BCM53128_A0_WRITE_G_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_PHYIDHr,&(r._g_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDHr BCM53128_A0_G_PHYIDHr
#define G_PHYIDHr_SIZE BCM53128_A0_G_PHYIDHr_SIZE
typedef BCM53128_A0_G_PHYIDHr_t G_PHYIDHr_t;
#define G_PHYIDHr_CLR BCM53128_A0_G_PHYIDHr_CLR
#define G_PHYIDHr_SET BCM53128_A0_G_PHYIDHr_SET
#define G_PHYIDHr_GET BCM53128_A0_G_PHYIDHr_GET
#define G_PHYIDHr_OUIf_GET BCM53128_A0_G_PHYIDHr_OUIf_GET
#define G_PHYIDHr_OUIf_SET BCM53128_A0_G_PHYIDHr_OUIf_SET
#define READ_G_PHYIDHr BCM53128_A0_READ_G_PHYIDHr
#define WRITE_G_PHYIDHr BCM53128_A0_WRITE_G_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHYIDH_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHYIDH_EXTr 0x00008804

#define BCM53128_A0_G_PHYIDH_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT.
 *
 */
typedef union BCM53128_A0_G_PHYIDH_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext[1];
	uint32_t _g_phyidh_ext;
} BCM53128_A0_G_PHYIDH_EXTr_t;

#define BCM53128_A0_G_PHYIDH_EXTr_CLR(r) (r).g_phyidh_ext[0] = 0
#define BCM53128_A0_G_PHYIDH_EXTr_SET(r,d) (r).g_phyidh_ext[0] = d
#define BCM53128_A0_G_PHYIDH_EXTr_GET(r) (r).g_phyidh_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHYIDH_EXTr_OUIf_GET(r) (((r).g_phyidh_ext[0]) & 0xffff)
#define BCM53128_A0_G_PHYIDH_EXTr_OUIf_SET(r,f) (r).g_phyidh_ext[0]=(((r).g_phyidh_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT.
 *
 */
#define BCM53128_A0_READ_G_PHYIDH_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHYIDH_EXTr,(r._g_phyidh_ext),2)
#define BCM53128_A0_WRITE_G_PHYIDH_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHYIDH_EXTr,&(r._g_phyidh_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXTr BCM53128_A0_G_PHYIDH_EXTr
#define G_PHYIDH_EXTr_SIZE BCM53128_A0_G_PHYIDH_EXTr_SIZE
typedef BCM53128_A0_G_PHYIDH_EXTr_t G_PHYIDH_EXTr_t;
#define G_PHYIDH_EXTr_CLR BCM53128_A0_G_PHYIDH_EXTr_CLR
#define G_PHYIDH_EXTr_SET BCM53128_A0_G_PHYIDH_EXTr_SET
#define G_PHYIDH_EXTr_GET BCM53128_A0_G_PHYIDH_EXTr_GET
#define G_PHYIDH_EXTr_OUIf_GET BCM53128_A0_G_PHYIDH_EXTr_OUIf_GET
#define G_PHYIDH_EXTr_OUIf_SET BCM53128_A0_G_PHYIDH_EXTr_OUIf_SET
#define READ_G_PHYIDH_EXTr BCM53128_A0_READ_G_PHYIDH_EXTr
#define WRITE_G_PHYIDH_EXTr BCM53128_A0_WRITE_G_PHYIDH_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHYIDH_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHYIDH_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHYIDH_EXT_P7r 0x00008704

#define BCM53128_A0_G_PHYIDH_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_PHYIDH_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext_p7[1];
	uint32_t _g_phyidh_ext_p7;
} BCM53128_A0_G_PHYIDH_EXT_P7r_t;

#define BCM53128_A0_G_PHYIDH_EXT_P7r_CLR(r) (r).g_phyidh_ext_p7[0] = 0
#define BCM53128_A0_G_PHYIDH_EXT_P7r_SET(r,d) (r).g_phyidh_ext_p7[0] = d
#define BCM53128_A0_G_PHYIDH_EXT_P7r_GET(r) (r).g_phyidh_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHYIDH_EXT_P7r_OUIf_GET(r) (((r).g_phyidh_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_PHYIDH_EXT_P7r_OUIf_SET(r,f) (r).g_phyidh_ext_p7[0]=(((r).g_phyidh_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_PHYIDH_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHYIDH_EXT_P7r,(r._g_phyidh_ext_p7),2)
#define BCM53128_A0_WRITE_G_PHYIDH_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHYIDH_EXT_P7r,&(r._g_phyidh_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXT_P7r BCM53128_A0_G_PHYIDH_EXT_P7r
#define G_PHYIDH_EXT_P7r_SIZE BCM53128_A0_G_PHYIDH_EXT_P7r_SIZE
typedef BCM53128_A0_G_PHYIDH_EXT_P7r_t G_PHYIDH_EXT_P7r_t;
#define G_PHYIDH_EXT_P7r_CLR BCM53128_A0_G_PHYIDH_EXT_P7r_CLR
#define G_PHYIDH_EXT_P7r_SET BCM53128_A0_G_PHYIDH_EXT_P7r_SET
#define G_PHYIDH_EXT_P7r_GET BCM53128_A0_G_PHYIDH_EXT_P7r_GET
#define G_PHYIDH_EXT_P7r_OUIf_GET BCM53128_A0_G_PHYIDH_EXT_P7r_OUIf_GET
#define G_PHYIDH_EXT_P7r_OUIf_SET BCM53128_A0_G_PHYIDH_EXT_P7r_OUIf_SET
#define READ_G_PHYIDH_EXT_P7r BCM53128_A0_READ_G_PHYIDH_EXT_P7r
#define WRITE_G_PHYIDH_EXT_P7r BCM53128_A0_WRITE_G_PHYIDH_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHYIDH_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHYIDL
 * BLOCKS:   GPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHYIDLr 0x00001006

#define BCM53128_A0_G_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL.
 *
 */
typedef union BCM53128_A0_G_PHYIDLr_s {
	uint32_t v[1];
	uint32_t g_phyidl[1];
	uint32_t _g_phyidl;
} BCM53128_A0_G_PHYIDLr_t;

#define BCM53128_A0_G_PHYIDLr_CLR(r) (r).g_phyidl[0] = 0
#define BCM53128_A0_G_PHYIDLr_SET(r,d) (r).g_phyidl[0] = d
#define BCM53128_A0_G_PHYIDLr_GET(r) (r).g_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHYIDLr_REVISIONf_GET(r) (((r).g_phyidl[0]) & 0xf)
#define BCM53128_A0_G_PHYIDLr_REVISIONf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_G_PHYIDLr_MODELf_GET(r) ((((r).g_phyidl[0]) >> 4) & 0x3f)
#define BCM53128_A0_G_PHYIDLr_MODELf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53128_A0_G_PHYIDLr_OUIf_GET(r) ((((r).g_phyidl[0]) >> 10) & 0x3f)
#define BCM53128_A0_G_PHYIDLr_OUIf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL.
 *
 */
#define BCM53128_A0_READ_G_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_PHYIDLr,(r._g_phyidl),2)
#define BCM53128_A0_WRITE_G_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_PHYIDLr,&(r._g_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDLr BCM53128_A0_G_PHYIDLr
#define G_PHYIDLr_SIZE BCM53128_A0_G_PHYIDLr_SIZE
typedef BCM53128_A0_G_PHYIDLr_t G_PHYIDLr_t;
#define G_PHYIDLr_CLR BCM53128_A0_G_PHYIDLr_CLR
#define G_PHYIDLr_SET BCM53128_A0_G_PHYIDLr_SET
#define G_PHYIDLr_GET BCM53128_A0_G_PHYIDLr_GET
#define G_PHYIDLr_REVISIONf_GET BCM53128_A0_G_PHYIDLr_REVISIONf_GET
#define G_PHYIDLr_REVISIONf_SET BCM53128_A0_G_PHYIDLr_REVISIONf_SET
#define G_PHYIDLr_MODELf_GET BCM53128_A0_G_PHYIDLr_MODELf_GET
#define G_PHYIDLr_MODELf_SET BCM53128_A0_G_PHYIDLr_MODELf_SET
#define G_PHYIDLr_OUIf_GET BCM53128_A0_G_PHYIDLr_OUIf_GET
#define G_PHYIDLr_OUIf_SET BCM53128_A0_G_PHYIDLr_OUIf_SET
#define READ_G_PHYIDLr BCM53128_A0_READ_G_PHYIDLr
#define WRITE_G_PHYIDLr BCM53128_A0_WRITE_G_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHYIDL_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHYIDL_EXTr 0x00008806

#define BCM53128_A0_G_PHYIDL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT.
 *
 */
typedef union BCM53128_A0_G_PHYIDL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext[1];
	uint32_t _g_phyidl_ext;
} BCM53128_A0_G_PHYIDL_EXTr_t;

#define BCM53128_A0_G_PHYIDL_EXTr_CLR(r) (r).g_phyidl_ext[0] = 0
#define BCM53128_A0_G_PHYIDL_EXTr_SET(r,d) (r).g_phyidl_ext[0] = d
#define BCM53128_A0_G_PHYIDL_EXTr_GET(r) (r).g_phyidl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHYIDL_EXTr_REVISIONf_GET(r) (((r).g_phyidl_ext[0]) & 0xf)
#define BCM53128_A0_G_PHYIDL_EXTr_REVISIONf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_G_PHYIDL_EXTr_MODELf_GET(r) ((((r).g_phyidl_ext[0]) >> 4) & 0x3f)
#define BCM53128_A0_G_PHYIDL_EXTr_MODELf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53128_A0_G_PHYIDL_EXTr_OUIf_GET(r) ((((r).g_phyidl_ext[0]) >> 10) & 0x3f)
#define BCM53128_A0_G_PHYIDL_EXTr_OUIf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT.
 *
 */
#define BCM53128_A0_READ_G_PHYIDL_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHYIDL_EXTr,(r._g_phyidl_ext),2)
#define BCM53128_A0_WRITE_G_PHYIDL_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHYIDL_EXTr,&(r._g_phyidl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXTr BCM53128_A0_G_PHYIDL_EXTr
#define G_PHYIDL_EXTr_SIZE BCM53128_A0_G_PHYIDL_EXTr_SIZE
typedef BCM53128_A0_G_PHYIDL_EXTr_t G_PHYIDL_EXTr_t;
#define G_PHYIDL_EXTr_CLR BCM53128_A0_G_PHYIDL_EXTr_CLR
#define G_PHYIDL_EXTr_SET BCM53128_A0_G_PHYIDL_EXTr_SET
#define G_PHYIDL_EXTr_GET BCM53128_A0_G_PHYIDL_EXTr_GET
#define G_PHYIDL_EXTr_REVISIONf_GET BCM53128_A0_G_PHYIDL_EXTr_REVISIONf_GET
#define G_PHYIDL_EXTr_REVISIONf_SET BCM53128_A0_G_PHYIDL_EXTr_REVISIONf_SET
#define G_PHYIDL_EXTr_MODELf_GET BCM53128_A0_G_PHYIDL_EXTr_MODELf_GET
#define G_PHYIDL_EXTr_MODELf_SET BCM53128_A0_G_PHYIDL_EXTr_MODELf_SET
#define G_PHYIDL_EXTr_OUIf_GET BCM53128_A0_G_PHYIDL_EXTr_OUIf_GET
#define G_PHYIDL_EXTr_OUIf_SET BCM53128_A0_G_PHYIDL_EXTr_OUIf_SET
#define READ_G_PHYIDL_EXTr BCM53128_A0_READ_G_PHYIDL_EXTr
#define WRITE_G_PHYIDL_EXTr BCM53128_A0_WRITE_G_PHYIDL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHYIDL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHYIDL_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHYIDL_EXT_P7r 0x00008706

#define BCM53128_A0_G_PHYIDL_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_PHYIDL_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext_p7[1];
	uint32_t _g_phyidl_ext_p7;
} BCM53128_A0_G_PHYIDL_EXT_P7r_t;

#define BCM53128_A0_G_PHYIDL_EXT_P7r_CLR(r) (r).g_phyidl_ext_p7[0] = 0
#define BCM53128_A0_G_PHYIDL_EXT_P7r_SET(r,d) (r).g_phyidl_ext_p7[0] = d
#define BCM53128_A0_G_PHYIDL_EXT_P7r_GET(r) (r).g_phyidl_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHYIDL_EXT_P7r_REVISIONf_GET(r) (((r).g_phyidl_ext_p7[0]) & 0xf)
#define BCM53128_A0_G_PHYIDL_EXT_P7r_REVISIONf_SET(r,f) (r).g_phyidl_ext_p7[0]=(((r).g_phyidl_ext_p7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_G_PHYIDL_EXT_P7r_MODELf_GET(r) ((((r).g_phyidl_ext_p7[0]) >> 4) & 0x3f)
#define BCM53128_A0_G_PHYIDL_EXT_P7r_MODELf_SET(r,f) (r).g_phyidl_ext_p7[0]=(((r).g_phyidl_ext_p7[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53128_A0_G_PHYIDL_EXT_P7r_OUIf_GET(r) ((((r).g_phyidl_ext_p7[0]) >> 10) & 0x3f)
#define BCM53128_A0_G_PHYIDL_EXT_P7r_OUIf_SET(r,f) (r).g_phyidl_ext_p7[0]=(((r).g_phyidl_ext_p7[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_PHYIDL_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHYIDL_EXT_P7r,(r._g_phyidl_ext_p7),2)
#define BCM53128_A0_WRITE_G_PHYIDL_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHYIDL_EXT_P7r,&(r._g_phyidl_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXT_P7r BCM53128_A0_G_PHYIDL_EXT_P7r
#define G_PHYIDL_EXT_P7r_SIZE BCM53128_A0_G_PHYIDL_EXT_P7r_SIZE
typedef BCM53128_A0_G_PHYIDL_EXT_P7r_t G_PHYIDL_EXT_P7r_t;
#define G_PHYIDL_EXT_P7r_CLR BCM53128_A0_G_PHYIDL_EXT_P7r_CLR
#define G_PHYIDL_EXT_P7r_SET BCM53128_A0_G_PHYIDL_EXT_P7r_SET
#define G_PHYIDL_EXT_P7r_GET BCM53128_A0_G_PHYIDL_EXT_P7r_GET
#define G_PHYIDL_EXT_P7r_REVISIONf_GET BCM53128_A0_G_PHYIDL_EXT_P7r_REVISIONf_GET
#define G_PHYIDL_EXT_P7r_REVISIONf_SET BCM53128_A0_G_PHYIDL_EXT_P7r_REVISIONf_SET
#define G_PHYIDL_EXT_P7r_MODELf_GET BCM53128_A0_G_PHYIDL_EXT_P7r_MODELf_GET
#define G_PHYIDL_EXT_P7r_MODELf_SET BCM53128_A0_G_PHYIDL_EXT_P7r_MODELf_SET
#define G_PHYIDL_EXT_P7r_OUIf_GET BCM53128_A0_G_PHYIDL_EXT_P7r_OUIf_GET
#define G_PHYIDL_EXT_P7r_OUIf_SET BCM53128_A0_G_PHYIDL_EXT_P7r_OUIf_SET
#define READ_G_PHYIDL_EXT_P7r BCM53128_A0_READ_G_PHYIDL_EXT_P7r
#define WRITE_G_PHYIDL_EXT_P7r BCM53128_A0_WRITE_G_PHYIDL_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHYIDL_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHY_EXT_CTL
 * BLOCKS:   GPIC0
 * DESC:     PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHY_EXT_CTLr 0x00001020

#define BCM53128_A0_G_PHY_EXT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL.
 *
 */
typedef union BCM53128_A0_G_PHY_EXT_CTLr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl[1];
	uint32_t _g_phy_ext_ctl;
} BCM53128_A0_G_PHY_EXT_CTLr_t;

#define BCM53128_A0_G_PHY_EXT_CTLr_CLR(r) (r).g_phy_ext_ctl[0] = 0
#define BCM53128_A0_G_PHY_EXT_CTLr_SET(r,d) (r).g_phy_ext_ctl[0] = d
#define BCM53128_A0_G_PHY_EXT_CTLr_GET(r) (r).g_phy_ext_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl[0]) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 2) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 5) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 6) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl[0]) >> 8) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 9) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 10) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 11) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 12) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 13) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 14) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 15) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL.
 *
 */
#define BCM53128_A0_READ_G_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_PHY_EXT_CTLr,(r._g_phy_ext_ctl),2)
#define BCM53128_A0_WRITE_G_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_PHY_EXT_CTLr,&(r._g_phy_ext_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTLr BCM53128_A0_G_PHY_EXT_CTLr
#define G_PHY_EXT_CTLr_SIZE BCM53128_A0_G_PHY_EXT_CTLr_SIZE
typedef BCM53128_A0_G_PHY_EXT_CTLr_t G_PHY_EXT_CTLr_t;
#define G_PHY_EXT_CTLr_CLR BCM53128_A0_G_PHY_EXT_CTLr_CLR
#define G_PHY_EXT_CTLr_SET BCM53128_A0_G_PHY_EXT_CTLr_SET
#define G_PHY_EXT_CTLr_GET BCM53128_A0_G_PHY_EXT_CTLr_GET
#define G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET BCM53128_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET BCM53128_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET BCM53128_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET BCM53128_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET BCM53128_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET BCM53128_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_GET BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_SET BCM53128_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET BCM53128_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET BCM53128_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET BCM53128_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET BCM53128_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET BCM53128_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET BCM53128_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET BCM53128_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_GET BCM53128_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_SET BCM53128_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_GET BCM53128_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_SET BCM53128_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET BCM53128_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET BCM53128_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET BCM53128_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET BCM53128_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTLr BCM53128_A0_READ_G_PHY_EXT_CTLr
#define WRITE_G_PHY_EXT_CTLr BCM53128_A0_WRITE_G_PHY_EXT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHY_EXT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr 0x00008820

#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT.
 *
 */
typedef union BCM53128_A0_G_PHY_EXT_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext[1];
	uint32_t _g_phy_ext_ctl_ext;
} BCM53128_A0_G_PHY_EXT_CTL_EXTr_t;

#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_CLR(r) (r).g_phy_ext_ctl_ext[0] = 0
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_SET(r,d) (r).g_phy_ext_ctl_ext[0] = d
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_GET(r) (r).g_phy_ext_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext[0]) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 2) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 3) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 4) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 6) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT.
 *
 */
#define BCM53128_A0_READ_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHY_EXT_CTL_EXTr,(r._g_phy_ext_ctl_ext),2)
#define BCM53128_A0_WRITE_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHY_EXT_CTL_EXTr,&(r._g_phy_ext_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXTr BCM53128_A0_G_PHY_EXT_CTL_EXTr
#define G_PHY_EXT_CTL_EXTr_SIZE BCM53128_A0_G_PHY_EXT_CTL_EXTr_SIZE
typedef BCM53128_A0_G_PHY_EXT_CTL_EXTr_t G_PHY_EXT_CTL_EXTr_t;
#define G_PHY_EXT_CTL_EXTr_CLR BCM53128_A0_G_PHY_EXT_CTL_EXTr_CLR
#define G_PHY_EXT_CTL_EXTr_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_SET
#define G_PHY_EXT_CTL_EXTr_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET BCM53128_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET BCM53128_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXTr BCM53128_A0_READ_G_PHY_EXT_CTL_EXTr
#define WRITE_G_PHY_EXT_CTL_EXTr BCM53128_A0_WRITE_G_PHY_EXT_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHY_EXT_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r 0x00008720

#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext_p7[1];
	uint32_t _g_phy_ext_ctl_ext_p7;
} BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_t;

#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_CLR(r) (r).g_phy_ext_ctl_ext_p7[0] = 0
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_SET(r,d) (r).g_phy_ext_ctl_ext_p7[0] = d
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_GET(r) (r).g_phy_ext_ctl_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext_p7[0]) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 2) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 3) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 4) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 6) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p7[0]=(((r).g_phy_ext_ctl_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_PHY_EXT_CTL_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r,(r._g_phy_ext_ctl_ext_p7),2)
#define BCM53128_A0_WRITE_G_PHY_EXT_CTL_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r,&(r._g_phy_ext_ctl_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXT_P7r BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r
#define G_PHY_EXT_CTL_EXT_P7r_SIZE BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_SIZE
typedef BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_t G_PHY_EXT_CTL_EXT_P7r_t;
#define G_PHY_EXT_CTL_EXT_P7r_CLR BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_CLR
#define G_PHY_EXT_CTL_EXT_P7r_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_SET
#define G_PHY_EXT_CTL_EXT_P7r_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_GET
#define G_PHY_EXT_CTL_EXT_P7r_B1000T_PCS_TRANS_FIFOf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXT_P7r_B1000T_PCS_TRANS_FIFOf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXT_P7r_GMII_FIFO_MODf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXT_P7r_GMII_FIFO_MODf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXT_P7r_BLK_TXEN_MODf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXT_P7r_BLK_TXEN_MODf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_OFFf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_OFFf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_ONf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_ONf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXT_P7r_EN_LED_TRAFFIC_MODf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXT_P7r_EN_LED_TRAFFIC_MODf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXT_P7r_RST_SCRAMBLERf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P7r_RST_SCRAMBLERf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_ALIGNMENTf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_ALIGNMENTf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_NRZI_MLT3f_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_NRZI_MLT3f_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_SCRAMBLERf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_SCRAMBLERf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_ENCODEf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXT_P7r_BYPASS_ENCODEf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXT_P7r_FORCE_INTERRUPTf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXT_P7r_FORCE_INTERRUPTf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXT_P7r_INTERRUPT_DISf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P7r_INTERRUPT_DISf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P7r_TRANSMIT_DISf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P7r_TRANSMIT_DISf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P7r_DIS_AUTO_MDI_CROSf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXT_P7r_DIS_AUTO_MDI_CROSf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXT_P7r_MAC_PHY_MODEf_GET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXT_P7r_MAC_PHY_MODEf_SET BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXT_P7r BCM53128_A0_READ_G_PHY_EXT_CTL_EXT_P7r
#define WRITE_G_PHY_EXT_CTL_EXT_P7r BCM53128_A0_WRITE_G_PHY_EXT_CTL_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHY_EXT_CTL_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHY_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHY_EXT_STSr 0x00001022

#define BCM53128_A0_G_PHY_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS.
 *
 */
typedef union BCM53128_A0_G_PHY_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts[1];
	uint32_t _g_phy_ext_sts;
} BCM53128_A0_G_PHY_EXT_STSr_t;

#define BCM53128_A0_G_PHY_EXT_STSr_CLR(r) (r).g_phy_ext_sts[0] = 0
#define BCM53128_A0_G_PHY_EXT_STSr_SET(r,d) (r).g_phy_ext_sts[0] = d
#define BCM53128_A0_G_PHY_EXT_STSr_GET(r) (r).g_phy_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts[0]) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 2) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 3) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 4) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 5) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 6) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 7) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_PHY_EXT_STSr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 8) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_PHY_EXT_STSr_LOCKf_GET(r) ((((r).g_phy_ext_sts[0]) >> 9) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_LOCKf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 10) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 11) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 12) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 13) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 14) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts[0]) >> 15) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS.
 *
 */
#define BCM53128_A0_READ_G_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_PHY_EXT_STSr,(r._g_phy_ext_sts),2)
#define BCM53128_A0_WRITE_G_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_PHY_EXT_STSr,&(r._g_phy_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STSr BCM53128_A0_G_PHY_EXT_STSr
#define G_PHY_EXT_STSr_SIZE BCM53128_A0_G_PHY_EXT_STSr_SIZE
typedef BCM53128_A0_G_PHY_EXT_STSr_t G_PHY_EXT_STSr_t;
#define G_PHY_EXT_STSr_CLR BCM53128_A0_G_PHY_EXT_STSr_CLR
#define G_PHY_EXT_STSr_SET BCM53128_A0_G_PHY_EXT_STSr_SET
#define G_PHY_EXT_STSr_GET BCM53128_A0_G_PHY_EXT_STSr_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STSr_REC_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET
#define G_PHY_EXT_STSr_REC_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STSr_LINK_STSf_GET BCM53128_A0_G_PHY_EXT_STSr_LINK_STSf_GET
#define G_PHY_EXT_STSr_LINK_STSf_SET BCM53128_A0_G_PHY_EXT_STSr_LINK_STSf_SET
#define G_PHY_EXT_STSr_LOCKf_GET BCM53128_A0_G_PHY_EXT_STSr_LOCKf_GET
#define G_PHY_EXT_STSr_LOCKf_SET BCM53128_A0_G_PHY_EXT_STSr_LOCKf_SET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_GET BCM53128_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_SET BCM53128_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_GET BCM53128_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_SET BCM53128_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_GET BCM53128_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_SET BCM53128_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_GET BCM53128_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_SET BCM53128_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET BCM53128_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET BCM53128_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET BCM53128_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET BCM53128_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STSr BCM53128_A0_READ_G_PHY_EXT_STSr
#define WRITE_G_PHY_EXT_STSr BCM53128_A0_WRITE_G_PHY_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHY_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHY_EXT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHY_EXT_STS_EXTr 0x00008822

#define BCM53128_A0_G_PHY_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT.
 *
 */
typedef union BCM53128_A0_G_PHY_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext[1];
	uint32_t _g_phy_ext_sts_ext;
} BCM53128_A0_G_PHY_EXT_STS_EXTr_t;

#define BCM53128_A0_G_PHY_EXT_STS_EXTr_CLR(r) (r).g_phy_ext_sts_ext[0] = 0
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_SET(r,d) (r).g_phy_ext_sts_ext[0] = d
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_GET(r) (r).g_phy_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext[0]) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 2) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 3) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 4) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 5) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 6) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 8) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 9) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 10) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 11) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT.
 *
 */
#define BCM53128_A0_READ_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHY_EXT_STS_EXTr,(r._g_phy_ext_sts_ext),2)
#define BCM53128_A0_WRITE_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHY_EXT_STS_EXTr,&(r._g_phy_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXTr BCM53128_A0_G_PHY_EXT_STS_EXTr
#define G_PHY_EXT_STS_EXTr_SIZE BCM53128_A0_G_PHY_EXT_STS_EXTr_SIZE
typedef BCM53128_A0_G_PHY_EXT_STS_EXTr_t G_PHY_EXT_STS_EXTr_t;
#define G_PHY_EXT_STS_EXTr_CLR BCM53128_A0_G_PHY_EXT_STS_EXTr_CLR
#define G_PHY_EXT_STS_EXTr_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_SET
#define G_PHY_EXT_STS_EXTr_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET
#define G_PHY_EXT_STS_EXTr_LOCKf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCKf_GET
#define G_PHY_EXT_STS_EXTr_LOCKf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCKf_SET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET BCM53128_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET BCM53128_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXTr BCM53128_A0_READ_G_PHY_EXT_STS_EXTr
#define WRITE_G_PHY_EXT_STS_EXTr BCM53128_A0_WRITE_G_PHY_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHY_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_PHY_EXT_STS_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r 0x00008722

#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext_p7[1];
	uint32_t _g_phy_ext_sts_ext_p7;
} BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_t;

#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CLR(r) (r).g_phy_ext_sts_ext_p7[0] = 0
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_SET(r,d) (r).g_phy_ext_sts_ext_p7[0] = d
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_GET(r) (r).g_phy_ext_sts_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext_p7[0]) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 1) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 2) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 3) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 4) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 5) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 6) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 8) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 9) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 10) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 11) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 13) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext_p7[0]=(((r).g_phy_ext_sts_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_PHY_EXT_STS_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_PHY_EXT_STS_EXT_P7r,(r._g_phy_ext_sts_ext_p7),2)
#define BCM53128_A0_WRITE_G_PHY_EXT_STS_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_PHY_EXT_STS_EXT_P7r,&(r._g_phy_ext_sts_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXT_P7r BCM53128_A0_G_PHY_EXT_STS_EXT_P7r
#define G_PHY_EXT_STS_EXT_P7r_SIZE BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_SIZE
typedef BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_t G_PHY_EXT_STS_EXT_P7r_t;
#define G_PHY_EXT_STS_EXT_P7r_CLR BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CLR
#define G_PHY_EXT_STS_EXT_P7r_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_SET
#define G_PHY_EXT_STS_EXT_P7r_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_GET
#define G_PHY_EXT_STS_EXT_P7r_MLT3_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_MLT3_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_LCK_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_LCK_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_TRMIT_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_TRMIT_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_REC_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_REC_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_BAD_ESD_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_BAD_ESD_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_BAD_SSD_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_BAD_SSD_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_CARR_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_CARR_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_CRC_ERR_DETf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P7r_CRC_ERR_DETf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P7r_LINK_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LINK_STSf_GET
#define G_PHY_EXT_STS_EXT_P7r_LINK_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LINK_STSf_SET
#define G_PHY_EXT_STS_EXT_P7r_LOCKf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCKf_GET
#define G_PHY_EXT_STS_EXT_P7r_LOCKf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCKf_SET
#define G_PHY_EXT_STS_EXT_P7r_LOCAL_REC_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P7r_LOCAL_REC_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P7r_REMOTE_REC_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P7r_REMOTE_REC_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P7r_INTERRUPT_STSf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXT_P7r_INTERRUPT_STSf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXT_P7r_MDI_CROS_STATEf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXT_P7r_MDI_CROS_STATEf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXT_P7r_WIRESPEED_DOWNGRADEf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXT_P7r_WIRESPEED_DOWNGRADEf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXT_P7r_AN_PAGE_SEL_MISMATCHf_GET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXT_P7r_AN_PAGE_SEL_MISMATCHf_SET BCM53128_A0_G_PHY_EXT_STS_EXT_P7r_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXT_P7r BCM53128_A0_READ_G_PHY_EXT_STS_EXT_P7r
#define WRITE_G_PHY_EXT_STS_EXT_P7r BCM53128_A0_WRITE_G_PHY_EXT_STS_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_PHY_EXT_STS_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_REC_ERR_CNT
 * BLOCKS:   GPIC0
 * DESC:     Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53128_A0_G_REC_ERR_CNTr 0x00001024

#define BCM53128_A0_G_REC_ERR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT.
 *
 */
typedef union BCM53128_A0_G_REC_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt[1];
	uint32_t _g_rec_err_cnt;
} BCM53128_A0_G_REC_ERR_CNTr_t;

#define BCM53128_A0_G_REC_ERR_CNTr_CLR(r) (r).g_rec_err_cnt[0] = 0
#define BCM53128_A0_G_REC_ERR_CNTr_SET(r,d) (r).g_rec_err_cnt[0] = d
#define BCM53128_A0_G_REC_ERR_CNTr_GET(r) (r).g_rec_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt[0]) & 0xffff)
#define BCM53128_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt[0]=(((r).g_rec_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT.
 *
 */
#define BCM53128_A0_READ_G_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_REC_ERR_CNTr,(r._g_rec_err_cnt),2)
#define BCM53128_A0_WRITE_G_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_REC_ERR_CNTr,&(r._g_rec_err_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNTr BCM53128_A0_G_REC_ERR_CNTr
#define G_REC_ERR_CNTr_SIZE BCM53128_A0_G_REC_ERR_CNTr_SIZE
typedef BCM53128_A0_G_REC_ERR_CNTr_t G_REC_ERR_CNTr_t;
#define G_REC_ERR_CNTr_CLR BCM53128_A0_G_REC_ERR_CNTr_CLR
#define G_REC_ERR_CNTr_SET BCM53128_A0_G_REC_ERR_CNTr_SET
#define G_REC_ERR_CNTr_GET BCM53128_A0_G_REC_ERR_CNTr_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_GET BCM53128_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_SET BCM53128_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNTr BCM53128_A0_READ_G_REC_ERR_CNTr
#define WRITE_G_REC_ERR_CNTr BCM53128_A0_WRITE_G_REC_ERR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_REC_ERR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_REC_ERR_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53128_A0_G_REC_ERR_CNT_EXTr 0x00008824

#define BCM53128_A0_G_REC_ERR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT.
 *
 */
typedef union BCM53128_A0_G_REC_ERR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext[1];
	uint32_t _g_rec_err_cnt_ext;
} BCM53128_A0_G_REC_ERR_CNT_EXTr_t;

#define BCM53128_A0_G_REC_ERR_CNT_EXTr_CLR(r) (r).g_rec_err_cnt_ext[0] = 0
#define BCM53128_A0_G_REC_ERR_CNT_EXTr_SET(r,d) (r).g_rec_err_cnt_ext[0] = d
#define BCM53128_A0_G_REC_ERR_CNT_EXTr_GET(r) (r).g_rec_err_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext[0]) & 0xffff)
#define BCM53128_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext[0]=(((r).g_rec_err_cnt_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT.
 *
 */
#define BCM53128_A0_READ_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_REC_ERR_CNT_EXTr,(r._g_rec_err_cnt_ext),2)
#define BCM53128_A0_WRITE_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_REC_ERR_CNT_EXTr,&(r._g_rec_err_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXTr BCM53128_A0_G_REC_ERR_CNT_EXTr
#define G_REC_ERR_CNT_EXTr_SIZE BCM53128_A0_G_REC_ERR_CNT_EXTr_SIZE
typedef BCM53128_A0_G_REC_ERR_CNT_EXTr_t G_REC_ERR_CNT_EXTr_t;
#define G_REC_ERR_CNT_EXTr_CLR BCM53128_A0_G_REC_ERR_CNT_EXTr_CLR
#define G_REC_ERR_CNT_EXTr_SET BCM53128_A0_G_REC_ERR_CNT_EXTr_SET
#define G_REC_ERR_CNT_EXTr_GET BCM53128_A0_G_REC_ERR_CNT_EXTr_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET BCM53128_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET BCM53128_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXTr BCM53128_A0_READ_G_REC_ERR_CNT_EXTr
#define WRITE_G_REC_ERR_CNT_EXTr BCM53128_A0_WRITE_G_REC_ERR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_REC_ERR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_REC_ERR_CNT_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r 0x00008724

#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext_p7[1];
	uint32_t _g_rec_err_cnt_ext_p7;
} BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_t;

#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_CLR(r) (r).g_rec_err_cnt_ext_p7[0] = 0
#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_SET(r,d) (r).g_rec_err_cnt_ext_p7[0] = d
#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_GET(r) (r).g_rec_err_cnt_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext_p7[0]=(((r).g_rec_err_cnt_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_REC_ERR_CNT_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_REC_ERR_CNT_EXT_P7r,(r._g_rec_err_cnt_ext_p7),2)
#define BCM53128_A0_WRITE_G_REC_ERR_CNT_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_REC_ERR_CNT_EXT_P7r,&(r._g_rec_err_cnt_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXT_P7r BCM53128_A0_G_REC_ERR_CNT_EXT_P7r
#define G_REC_ERR_CNT_EXT_P7r_SIZE BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_SIZE
typedef BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_t G_REC_ERR_CNT_EXT_P7r_t;
#define G_REC_ERR_CNT_EXT_P7r_CLR BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_CLR
#define G_REC_ERR_CNT_EXT_P7r_SET BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_SET
#define G_REC_ERR_CNT_EXT_P7r_GET BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_GET
#define G_REC_ERR_CNT_EXT_P7r_REC_ERR_CNTf_GET BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXT_P7r_REC_ERR_CNTf_SET BCM53128_A0_G_REC_ERR_CNT_EXT_P7r_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXT_P7r BCM53128_A0_READ_G_REC_ERR_CNT_EXT_P7r
#define WRITE_G_REC_ERR_CNT_EXT_P7r BCM53128_A0_WRITE_G_REC_ERR_CNT_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_REC_ERR_CNT_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_REC_NOTOK_CNT
 * BLOCKS:   GPIC0
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53128_A0_G_REC_NOTOK_CNTr 0x00001028

#define BCM53128_A0_G_REC_NOTOK_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT.
 *
 */
typedef union BCM53128_A0_G_REC_NOTOK_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt[1];
	uint32_t _g_rec_notok_cnt;
} BCM53128_A0_G_REC_NOTOK_CNTr_t;

#define BCM53128_A0_G_REC_NOTOK_CNTr_CLR(r) (r).g_rec_notok_cnt[0] = 0
#define BCM53128_A0_G_REC_NOTOK_CNTr_SET(r,d) (r).g_rec_notok_cnt[0] = d
#define BCM53128_A0_G_REC_NOTOK_CNTr_GET(r) (r).g_rec_notok_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt[0]) & 0xff)
#define BCM53128_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt[0]) >> 8) & 0xff)
#define BCM53128_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT.
 *
 */
#define BCM53128_A0_READ_G_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_REC_NOTOK_CNTr,(r._g_rec_notok_cnt),2)
#define BCM53128_A0_WRITE_G_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_REC_NOTOK_CNTr,&(r._g_rec_notok_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNTr BCM53128_A0_G_REC_NOTOK_CNTr
#define G_REC_NOTOK_CNTr_SIZE BCM53128_A0_G_REC_NOTOK_CNTr_SIZE
typedef BCM53128_A0_G_REC_NOTOK_CNTr_t G_REC_NOTOK_CNTr_t;
#define G_REC_NOTOK_CNTr_CLR BCM53128_A0_G_REC_NOTOK_CNTr_CLR
#define G_REC_NOTOK_CNTr_SET BCM53128_A0_G_REC_NOTOK_CNTr_SET
#define G_REC_NOTOK_CNTr_GET BCM53128_A0_G_REC_NOTOK_CNTr_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET BCM53128_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET BCM53128_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET BCM53128_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET BCM53128_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNTr BCM53128_A0_READ_G_REC_NOTOK_CNTr
#define WRITE_G_REC_NOTOK_CNTr BCM53128_A0_WRITE_G_REC_NOTOK_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_REC_NOTOK_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr 0x00008828

#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT.
 *
 */
typedef union BCM53128_A0_G_REC_NOTOK_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext[1];
	uint32_t _g_rec_notok_cnt_ext;
} BCM53128_A0_G_REC_NOTOK_CNT_EXTr_t;

#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_CLR(r) (r).g_rec_notok_cnt_ext[0] = 0
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_SET(r,d) (r).g_rec_notok_cnt_ext[0] = d
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_GET(r) (r).g_rec_notok_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext[0]) & 0xff)
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext[0]) >> 8) & 0xff)
#define BCM53128_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT.
 *
 */
#define BCM53128_A0_READ_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_REC_NOTOK_CNT_EXTr,(r._g_rec_notok_cnt_ext),2)
#define BCM53128_A0_WRITE_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_REC_NOTOK_CNT_EXTr,&(r._g_rec_notok_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXTr BCM53128_A0_G_REC_NOTOK_CNT_EXTr
#define G_REC_NOTOK_CNT_EXTr_SIZE BCM53128_A0_G_REC_NOTOK_CNT_EXTr_SIZE
typedef BCM53128_A0_G_REC_NOTOK_CNT_EXTr_t G_REC_NOTOK_CNT_EXTr_t;
#define G_REC_NOTOK_CNT_EXTr_CLR BCM53128_A0_G_REC_NOTOK_CNT_EXTr_CLR
#define G_REC_NOTOK_CNT_EXTr_SET BCM53128_A0_G_REC_NOTOK_CNT_EXTr_SET
#define G_REC_NOTOK_CNT_EXTr_GET BCM53128_A0_G_REC_NOTOK_CNT_EXTr_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET BCM53128_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET BCM53128_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET BCM53128_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET BCM53128_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXTr BCM53128_A0_READ_G_REC_NOTOK_CNT_EXTr
#define WRITE_G_REC_NOTOK_CNT_EXTr BCM53128_A0_WRITE_G_REC_NOTOK_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_REC_NOTOK_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r 0x00008728

#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext_p7[1];
	uint32_t _g_rec_notok_cnt_ext_p7;
} BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_t;

#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_CLR(r) (r).g_rec_notok_cnt_ext_p7[0] = 0
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_SET(r,d) (r).g_rec_notok_cnt_ext_p7[0] = d
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_GET(r) (r).g_rec_notok_cnt_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext_p7[0]) & 0xff)
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p7[0]=(((r).g_rec_notok_cnt_ext_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext_p7[0]) >> 8) & 0xff)
#define BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p7[0]=(((r).g_rec_notok_cnt_ext_p7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_REC_NOTOK_CNT_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r,(r._g_rec_notok_cnt_ext_p7),2)
#define BCM53128_A0_WRITE_G_REC_NOTOK_CNT_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r,&(r._g_rec_notok_cnt_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXT_P7r BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r
#define G_REC_NOTOK_CNT_EXT_P7r_SIZE BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_SIZE
typedef BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_t G_REC_NOTOK_CNT_EXT_P7r_t;
#define G_REC_NOTOK_CNT_EXT_P7r_CLR BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_CLR
#define G_REC_NOTOK_CNT_EXT_P7r_SET BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_SET
#define G_REC_NOTOK_CNT_EXT_P7r_GET BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_GET
#define G_REC_NOTOK_CNT_EXT_P7r_REMOTE_REC_NOTOK_CNTf_GET BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P7r_REMOTE_REC_NOTOK_CNTf_SET BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXT_P7r_LOCAL_REC_NOTOK_CNTf_GET BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P7r_LOCAL_REC_NOTOK_CNTf_SET BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXT_P7r BCM53128_A0_READ_G_REC_NOTOK_CNT_EXT_P7r
#define WRITE_G_REC_NOTOK_CNT_EXT_P7r BCM53128_A0_WRITE_G_REC_NOTOK_CNT_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_REC_NOTOK_CNT_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_TEST1
 * BLOCKS:   GPIC0
 * DESC:     Test Register 1
 * SIZE:     16
 * FIELDS:
 *     MAN_SWP_MDI_ST   
 *     FORCE_LINK       
 *     TX_ERR_CODE_VIS  
 *     CRC_ERR_CNT_SEL  
 *
 ******************************************************************************/
#define BCM53128_A0_G_TEST1r 0x0000103c

#define BCM53128_A0_G_TEST1r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1.
 *
 */
typedef union BCM53128_A0_G_TEST1r_s {
	uint32_t v[1];
	uint32_t g_test1[1];
	uint32_t _g_test1;
} BCM53128_A0_G_TEST1r_t;

#define BCM53128_A0_G_TEST1r_CLR(r) (r).g_test1[0] = 0
#define BCM53128_A0_G_TEST1r_SET(r,d) (r).g_test1[0] = d
#define BCM53128_A0_G_TEST1r_GET(r) (r).g_test1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_TEST1r_MAN_SWP_MDI_STf_GET(r) ((((r).g_test1[0]) >> 7) & 0x1)
#define BCM53128_A0_G_TEST1r_MAN_SWP_MDI_STf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_TEST1r_FORCE_LINKf_GET(r) ((((r).g_test1[0]) >> 12) & 0x1)
#define BCM53128_A0_G_TEST1r_FORCE_LINKf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_TEST1r_TX_ERR_CODE_VISf_GET(r) ((((r).g_test1[0]) >> 14) & 0x1)
#define BCM53128_A0_G_TEST1r_TX_ERR_CODE_VISf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_TEST1r_CRC_ERR_CNT_SELf_GET(r) ((((r).g_test1[0]) >> 15) & 0x1)
#define BCM53128_A0_G_TEST1r_CRC_ERR_CNT_SELf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_TEST1.
 *
 */
#define BCM53128_A0_READ_G_TEST1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_TEST1r,(r._g_test1),2)
#define BCM53128_A0_WRITE_G_TEST1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_TEST1r,&(r._g_test1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1r BCM53128_A0_G_TEST1r
#define G_TEST1r_SIZE BCM53128_A0_G_TEST1r_SIZE
typedef BCM53128_A0_G_TEST1r_t G_TEST1r_t;
#define G_TEST1r_CLR BCM53128_A0_G_TEST1r_CLR
#define G_TEST1r_SET BCM53128_A0_G_TEST1r_SET
#define G_TEST1r_GET BCM53128_A0_G_TEST1r_GET
#define G_TEST1r_MAN_SWP_MDI_STf_GET BCM53128_A0_G_TEST1r_MAN_SWP_MDI_STf_GET
#define G_TEST1r_MAN_SWP_MDI_STf_SET BCM53128_A0_G_TEST1r_MAN_SWP_MDI_STf_SET
#define G_TEST1r_FORCE_LINKf_GET BCM53128_A0_G_TEST1r_FORCE_LINKf_GET
#define G_TEST1r_FORCE_LINKf_SET BCM53128_A0_G_TEST1r_FORCE_LINKf_SET
#define G_TEST1r_TX_ERR_CODE_VISf_GET BCM53128_A0_G_TEST1r_TX_ERR_CODE_VISf_GET
#define G_TEST1r_TX_ERR_CODE_VISf_SET BCM53128_A0_G_TEST1r_TX_ERR_CODE_VISf_SET
#define G_TEST1r_CRC_ERR_CNT_SELf_GET BCM53128_A0_G_TEST1r_CRC_ERR_CNT_SELf_GET
#define G_TEST1r_CRC_ERR_CNT_SELf_SET BCM53128_A0_G_TEST1r_CRC_ERR_CNT_SELf_SET
#define READ_G_TEST1r BCM53128_A0_READ_G_TEST1r
#define WRITE_G_TEST1r BCM53128_A0_WRITE_G_TEST1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_TEST1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_TEST1_EXT
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     MAN_SWP_MDI_ST   
 *     FORCE_LINK       
 *     TX_ERR_CODE_VIS  
 *     CRC_ERR_CNT_SEL  
 *
 ******************************************************************************/
#define BCM53128_A0_G_TEST1_EXTr 0x0000883c

#define BCM53128_A0_G_TEST1_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT.
 *
 */
typedef union BCM53128_A0_G_TEST1_EXTr_s {
	uint32_t v[1];
	uint32_t g_test1_ext[1];
	uint32_t _g_test1_ext;
} BCM53128_A0_G_TEST1_EXTr_t;

#define BCM53128_A0_G_TEST1_EXTr_CLR(r) (r).g_test1_ext[0] = 0
#define BCM53128_A0_G_TEST1_EXTr_SET(r,d) (r).g_test1_ext[0] = d
#define BCM53128_A0_G_TEST1_EXTr_GET(r) (r).g_test1_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_GET(r) ((((r).g_test1_ext[0]) >> 7) & 0x1)
#define BCM53128_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_TEST1_EXTr_FORCE_LINKf_GET(r) ((((r).g_test1_ext[0]) >> 12) & 0x1)
#define BCM53128_A0_G_TEST1_EXTr_FORCE_LINKf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_GET(r) ((((r).g_test1_ext[0]) >> 14) & 0x1)
#define BCM53128_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_GET(r) ((((r).g_test1_ext[0]) >> 15) & 0x1)
#define BCM53128_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_TEST1_EXT.
 *
 */
#define BCM53128_A0_READ_G_TEST1_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_TEST1_EXTr,(r._g_test1_ext),2)
#define BCM53128_A0_WRITE_G_TEST1_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_TEST1_EXTr,&(r._g_test1_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXTr BCM53128_A0_G_TEST1_EXTr
#define G_TEST1_EXTr_SIZE BCM53128_A0_G_TEST1_EXTr_SIZE
typedef BCM53128_A0_G_TEST1_EXTr_t G_TEST1_EXTr_t;
#define G_TEST1_EXTr_CLR BCM53128_A0_G_TEST1_EXTr_CLR
#define G_TEST1_EXTr_SET BCM53128_A0_G_TEST1_EXTr_SET
#define G_TEST1_EXTr_GET BCM53128_A0_G_TEST1_EXTr_GET
#define G_TEST1_EXTr_MAN_SWP_MDI_STf_GET BCM53128_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_GET
#define G_TEST1_EXTr_MAN_SWP_MDI_STf_SET BCM53128_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_SET
#define G_TEST1_EXTr_FORCE_LINKf_GET BCM53128_A0_G_TEST1_EXTr_FORCE_LINKf_GET
#define G_TEST1_EXTr_FORCE_LINKf_SET BCM53128_A0_G_TEST1_EXTr_FORCE_LINKf_SET
#define G_TEST1_EXTr_TX_ERR_CODE_VISf_GET BCM53128_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_GET
#define G_TEST1_EXTr_TX_ERR_CODE_VISf_SET BCM53128_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_SET
#define G_TEST1_EXTr_CRC_ERR_CNT_SELf_GET BCM53128_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_GET
#define G_TEST1_EXTr_CRC_ERR_CNT_SELf_SET BCM53128_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_SET
#define READ_G_TEST1_EXTr BCM53128_A0_READ_G_TEST1_EXTr
#define WRITE_G_TEST1_EXTr BCM53128_A0_WRITE_G_TEST1_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_TEST1_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_TEST1_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     MAN_SWP_MDI_ST   
 *     FORCE_LINK       
 *     TX_ERR_CODE_VIS  
 *     CRC_ERR_CNT_SEL  
 *
 ******************************************************************************/
#define BCM53128_A0_G_TEST1_EXT_P7r 0x0000873c

#define BCM53128_A0_G_TEST1_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_TEST1_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_test1_ext_p7[1];
	uint32_t _g_test1_ext_p7;
} BCM53128_A0_G_TEST1_EXT_P7r_t;

#define BCM53128_A0_G_TEST1_EXT_P7r_CLR(r) (r).g_test1_ext_p7[0] = 0
#define BCM53128_A0_G_TEST1_EXT_P7r_SET(r,d) (r).g_test1_ext_p7[0] = d
#define BCM53128_A0_G_TEST1_EXT_P7r_GET(r) (r).g_test1_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_TEST1_EXT_P7r_MAN_SWP_MDI_STf_GET(r) ((((r).g_test1_ext_p7[0]) >> 7) & 0x1)
#define BCM53128_A0_G_TEST1_EXT_P7r_MAN_SWP_MDI_STf_SET(r,f) (r).g_test1_ext_p7[0]=(((r).g_test1_ext_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_G_TEST1_EXT_P7r_FORCE_LINKf_GET(r) ((((r).g_test1_ext_p7[0]) >> 12) & 0x1)
#define BCM53128_A0_G_TEST1_EXT_P7r_FORCE_LINKf_SET(r,f) (r).g_test1_ext_p7[0]=(((r).g_test1_ext_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_G_TEST1_EXT_P7r_TX_ERR_CODE_VISf_GET(r) ((((r).g_test1_ext_p7[0]) >> 14) & 0x1)
#define BCM53128_A0_G_TEST1_EXT_P7r_TX_ERR_CODE_VISf_SET(r,f) (r).g_test1_ext_p7[0]=(((r).g_test1_ext_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_G_TEST1_EXT_P7r_CRC_ERR_CNT_SELf_GET(r) ((((r).g_test1_ext_p7[0]) >> 15) & 0x1)
#define BCM53128_A0_G_TEST1_EXT_P7r_CRC_ERR_CNT_SELf_SET(r,f) (r).g_test1_ext_p7[0]=(((r).g_test1_ext_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_TEST1_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_TEST1_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_TEST1_EXT_P7r,(r._g_test1_ext_p7),2)
#define BCM53128_A0_WRITE_G_TEST1_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_TEST1_EXT_P7r,&(r._g_test1_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXT_P7r BCM53128_A0_G_TEST1_EXT_P7r
#define G_TEST1_EXT_P7r_SIZE BCM53128_A0_G_TEST1_EXT_P7r_SIZE
typedef BCM53128_A0_G_TEST1_EXT_P7r_t G_TEST1_EXT_P7r_t;
#define G_TEST1_EXT_P7r_CLR BCM53128_A0_G_TEST1_EXT_P7r_CLR
#define G_TEST1_EXT_P7r_SET BCM53128_A0_G_TEST1_EXT_P7r_SET
#define G_TEST1_EXT_P7r_GET BCM53128_A0_G_TEST1_EXT_P7r_GET
#define G_TEST1_EXT_P7r_MAN_SWP_MDI_STf_GET BCM53128_A0_G_TEST1_EXT_P7r_MAN_SWP_MDI_STf_GET
#define G_TEST1_EXT_P7r_MAN_SWP_MDI_STf_SET BCM53128_A0_G_TEST1_EXT_P7r_MAN_SWP_MDI_STf_SET
#define G_TEST1_EXT_P7r_FORCE_LINKf_GET BCM53128_A0_G_TEST1_EXT_P7r_FORCE_LINKf_GET
#define G_TEST1_EXT_P7r_FORCE_LINKf_SET BCM53128_A0_G_TEST1_EXT_P7r_FORCE_LINKf_SET
#define G_TEST1_EXT_P7r_TX_ERR_CODE_VISf_GET BCM53128_A0_G_TEST1_EXT_P7r_TX_ERR_CODE_VISf_GET
#define G_TEST1_EXT_P7r_TX_ERR_CODE_VISf_SET BCM53128_A0_G_TEST1_EXT_P7r_TX_ERR_CODE_VISf_SET
#define G_TEST1_EXT_P7r_CRC_ERR_CNT_SELf_GET BCM53128_A0_G_TEST1_EXT_P7r_CRC_ERR_CNT_SELf_GET
#define G_TEST1_EXT_P7r_CRC_ERR_CNT_SELf_SET BCM53128_A0_G_TEST1_EXT_P7r_CRC_ERR_CNT_SELf_SET
#define READ_G_TEST1_EXT_P7r BCM53128_A0_READ_G_TEST1_EXT_P7r
#define WRITE_G_TEST1_EXT_P7r BCM53128_A0_WRITE_G_TEST1_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_TEST1_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_TEST2
 * BLOCKS:   GPIC0
 * DESC:     Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM53128_A0_G_TEST2r 0x0000103e

#define BCM53128_A0_G_TEST2r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2.
 *
 */
typedef union BCM53128_A0_G_TEST2r_s {
	uint32_t v[1];
	uint32_t g_test2[1];
	uint32_t _g_test2;
} BCM53128_A0_G_TEST2r_t;

#define BCM53128_A0_G_TEST2r_CLR(r) (r).g_test2[0] = 0
#define BCM53128_A0_G_TEST2r_SET(r,d) (r).g_test2[0] = d
#define BCM53128_A0_G_TEST2r_GET(r) (r).g_test2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_TEST2r_TESTf_GET(r) (((r).g_test2[0]) & 0xffff)
#define BCM53128_A0_G_TEST2r_TESTf_SET(r,f) (r).g_test2[0]=(((r).g_test2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2.
 *
 */
#define BCM53128_A0_READ_G_TEST2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_G_TEST2r,(r._g_test2),2)
#define BCM53128_A0_WRITE_G_TEST2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_G_TEST2r,&(r._g_test2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2r BCM53128_A0_G_TEST2r
#define G_TEST2r_SIZE BCM53128_A0_G_TEST2r_SIZE
typedef BCM53128_A0_G_TEST2r_t G_TEST2r_t;
#define G_TEST2r_CLR BCM53128_A0_G_TEST2r_CLR
#define G_TEST2r_SET BCM53128_A0_G_TEST2r_SET
#define G_TEST2r_GET BCM53128_A0_G_TEST2r_GET
#define G_TEST2r_TESTf_GET BCM53128_A0_G_TEST2r_TESTf_GET
#define G_TEST2r_TESTf_SET BCM53128_A0_G_TEST2r_TESTf_SET
#define READ_G_TEST2r BCM53128_A0_READ_G_TEST2r
#define WRITE_G_TEST2r BCM53128_A0_WRITE_G_TEST2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_TEST2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_TEST2_EXT
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM53128_A0_G_TEST2_EXTr 0x0000883e

#define BCM53128_A0_G_TEST2_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT.
 *
 */
typedef union BCM53128_A0_G_TEST2_EXTr_s {
	uint32_t v[1];
	uint32_t g_test2_ext[1];
	uint32_t _g_test2_ext;
} BCM53128_A0_G_TEST2_EXTr_t;

#define BCM53128_A0_G_TEST2_EXTr_CLR(r) (r).g_test2_ext[0] = 0
#define BCM53128_A0_G_TEST2_EXTr_SET(r,d) (r).g_test2_ext[0] = d
#define BCM53128_A0_G_TEST2_EXTr_GET(r) (r).g_test2_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_TEST2_EXTr_TESTf_GET(r) (((r).g_test2_ext[0]) & 0xffff)
#define BCM53128_A0_G_TEST2_EXTr_TESTf_SET(r,f) (r).g_test2_ext[0]=(((r).g_test2_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT.
 *
 */
#define BCM53128_A0_READ_G_TEST2_EXTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_TEST2_EXTr,(r._g_test2_ext),2)
#define BCM53128_A0_WRITE_G_TEST2_EXTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_TEST2_EXTr,&(r._g_test2_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXTr BCM53128_A0_G_TEST2_EXTr
#define G_TEST2_EXTr_SIZE BCM53128_A0_G_TEST2_EXTr_SIZE
typedef BCM53128_A0_G_TEST2_EXTr_t G_TEST2_EXTr_t;
#define G_TEST2_EXTr_CLR BCM53128_A0_G_TEST2_EXTr_CLR
#define G_TEST2_EXTr_SET BCM53128_A0_G_TEST2_EXTr_SET
#define G_TEST2_EXTr_GET BCM53128_A0_G_TEST2_EXTr_GET
#define G_TEST2_EXTr_TESTf_GET BCM53128_A0_G_TEST2_EXTr_TESTf_GET
#define G_TEST2_EXTr_TESTf_SET BCM53128_A0_G_TEST2_EXTr_TESTf_SET
#define READ_G_TEST2_EXTr BCM53128_A0_READ_G_TEST2_EXTr
#define WRITE_G_TEST2_EXTr BCM53128_A0_WRITE_G_TEST2_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_TEST2_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  G_TEST2_EXT_P7
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM53128_A0_G_TEST2_EXT_P7r 0x0000873e

#define BCM53128_A0_G_TEST2_EXT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT_P7.
 *
 */
typedef union BCM53128_A0_G_TEST2_EXT_P7r_s {
	uint32_t v[1];
	uint32_t g_test2_ext_p7[1];
	uint32_t _g_test2_ext_p7;
} BCM53128_A0_G_TEST2_EXT_P7r_t;

#define BCM53128_A0_G_TEST2_EXT_P7r_CLR(r) (r).g_test2_ext_p7[0] = 0
#define BCM53128_A0_G_TEST2_EXT_P7r_SET(r,d) (r).g_test2_ext_p7[0] = d
#define BCM53128_A0_G_TEST2_EXT_P7r_GET(r) (r).g_test2_ext_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_G_TEST2_EXT_P7r_TESTf_GET(r) (((r).g_test2_ext_p7[0]) & 0xffff)
#define BCM53128_A0_G_TEST2_EXT_P7r_TESTf_SET(r,f) (r).g_test2_ext_p7[0]=(((r).g_test2_ext_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT_P7.
 *
 */
#define BCM53128_A0_READ_G_TEST2_EXT_P7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_G_TEST2_EXT_P7r,(r._g_test2_ext_p7),2)
#define BCM53128_A0_WRITE_G_TEST2_EXT_P7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_G_TEST2_EXT_P7r,&(r._g_test2_ext_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXT_P7r BCM53128_A0_G_TEST2_EXT_P7r
#define G_TEST2_EXT_P7r_SIZE BCM53128_A0_G_TEST2_EXT_P7r_SIZE
typedef BCM53128_A0_G_TEST2_EXT_P7r_t G_TEST2_EXT_P7r_t;
#define G_TEST2_EXT_P7r_CLR BCM53128_A0_G_TEST2_EXT_P7r_CLR
#define G_TEST2_EXT_P7r_SET BCM53128_A0_G_TEST2_EXT_P7r_SET
#define G_TEST2_EXT_P7r_GET BCM53128_A0_G_TEST2_EXT_P7r_GET
#define G_TEST2_EXT_P7r_TESTf_GET BCM53128_A0_G_TEST2_EXT_P7r_TESTf_GET
#define G_TEST2_EXT_P7r_TESTf_SET BCM53128_A0_G_TEST2_EXT_P7r_TESTf_SET
#define READ_G_TEST2_EXT_P7r BCM53128_A0_READ_G_TEST2_EXT_P7r
#define WRITE_G_TEST2_EXT_P7r BCM53128_A0_WRITE_G_TEST2_EXT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_G_TEST2_EXT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  HL_PRTC_CTRL
 * BLOCKS:   SYS
 * DESC:     High Level Protocol Control Register
 * SIZE:     32
 * FIELDS:
 *     ARP_EN           ARP Snooping Enable1: ARP frames will be forwarded by L2 result and also copied to CPU.0: ARP frames will be forwarded by L2 result .
 *     RARP_EN          RARP Snooping Enable1: RARP frames will be forwarded by L2 result and also copied to CPU.0: RARP frames will be forwarded by L2 result .
 *     DHCP_EN          DHCP Snooping Enable1: DHCP frames will be forwarded by L2 result and also copied to CPU.0: DHCP frames will be forwarded by L2 result.
 *     ICMPV4_EN        ICMPv4 Snooping Enable1: ICMPv4 frames will be forwarded by L2 result and also copied to CPU.0: ICMPv4 frames will be forwarded by L2 result.
 *     ICMPV6_EN        ICMPv6(exclude MLD) Snooping/ Redirect EnableICMPv6, with a next header value of 58, will be classified by IPv6 datagram.
 *     ICMPV6_FWD_MODE  ICMPv6(exclude MLD) Forwarding Mode1: ICMPv6 frames will be trapped to CPU port only.0: ICMPv6 frames will be forwarded by L2 result and also copied to CPU.
 *     RESERVED_0       Reserved
 *     IGMP_DIP_EN      IGMP L3 DIP Checking EnableIn addition to the IP datagram with a protocol value of 2, IGMP will be classified by matching its DIP with the Class D IP address (224.0.0.0 ~ 239.255.255.255).
 *     IGMP_RPTLVE_EN   IGMP Report/Leave Message Snooping/Redirect Enable1: Enable IGMP Report/Leave Message Snooping/Redirect.0: Disable.
 *     IGMP_RPTLVE_FWD_MODE IGMP Report/Leave Message Forwarding Mode1: IGMP Report/Leave Message frames will be trapped to CPU port only.0: IGMP Report/Leave Message frames will be forwarded by L2 result and also copied to CPU.
 *     IGMP_QRY_EN      IGMP Query Message Snooping/Redirect Enable1: Enable IGMP Query Message Snooping/Redirect.0: Disable.
 *     IGMP_QRY_FWD_MODE IGMP Query Message Forwarding Mode1: IGMP Query Message frames will be trapped to CPU port only.0: IGMP Query Message frames will be forwarded by L2 result and also copied to CPU.
 *     IGMP_UKN_EN      IGMP Unknown Message Snooping/Redirect Enable1: Enable IGMP Unknown Message Snooping/Redirect.0: Disable.
 *     IGMP_UKN_FWD_MODE IGMP Unknown Message Forwarding Mode1: IGMP Unknown Message frames will be trapped to CPU port only.0: IGMP Unknown Message frames will be forwarded by L2 result and also copied to CPU.
 *     MLD_RPTDONE_EN   MLD Report/Done Message Snooping/Redirect Enable1: Enable MLD Report/Done Message Snooping/Redirect.0: Disable.
 *     MLD_RPTDONE_FWD_MODE MLD Report/Done Message Forwarding Mode1: MLD Report/Done Message frames will be trapped to CPU port only.0: MLD Report/Done Message frames will be forwarded by L2 result and also copied to CPU.
 *     MLD_QRY_EN       MLD Query Message Snooping/Redirect Enable1: Enable MLD Query Message Snooping/Redirect.0: Disable.
 *     MLD_QRY_FWD_MODE MLD Query Message Forwarding Mode1: MLD Query Message frames will be trapped to CPU port only.0: MLD Query Message frames will be forwarded by L2 result and also copied to CPU.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_HL_PRTC_CTRLr 0x00000250

#define BCM53128_A0_HL_PRTC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program HL_PRTC_CTRL.
 *
 */
typedef union BCM53128_A0_HL_PRTC_CTRLr_s {
	uint32_t v[1];
	uint32_t hl_prtc_ctrl[1];
	uint32_t _hl_prtc_ctrl;
} BCM53128_A0_HL_PRTC_CTRLr_t;

#define BCM53128_A0_HL_PRTC_CTRLr_CLR(r) (r).hl_prtc_ctrl[0] = 0
#define BCM53128_A0_HL_PRTC_CTRLr_SET(r,d) (r).hl_prtc_ctrl[0] = d
#define BCM53128_A0_HL_PRTC_CTRLr_GET(r) (r).hl_prtc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_HL_PRTC_CTRLr_ARP_ENf_GET(r) (((r).hl_prtc_ctrl[0]) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_ARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_HL_PRTC_CTRLr_RARP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_RARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_HL_PRTC_CTRLr_DHCP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_DHCP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_HL_PRTC_CTRLr_RESERVED_0f_GET(r) ((((r).hl_prtc_ctrl[0]) >> 6) & 0x3)
#define BCM53128_A0_HL_PRTC_CTRLr_RESERVED_0f_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 8) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 9) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 10) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 11) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 12) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 13) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 14) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 15) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 16) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 17) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 18) & 0x1)
#define BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53128_A0_HL_PRTC_CTRLr_RESERVED_1f_GET(r) ((((r).hl_prtc_ctrl[0]) >> 19) & 0x1fff)
#define BCM53128_A0_HL_PRTC_CTRLr_RESERVED_1f_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access HL_PRTC_CTRL.
 *
 */
#define BCM53128_A0_READ_HL_PRTC_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_HL_PRTC_CTRLr,(r._hl_prtc_ctrl),4)
#define BCM53128_A0_WRITE_HL_PRTC_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_HL_PRTC_CTRLr,&(r._hl_prtc_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HL_PRTC_CTRLr BCM53128_A0_HL_PRTC_CTRLr
#define HL_PRTC_CTRLr_SIZE BCM53128_A0_HL_PRTC_CTRLr_SIZE
typedef BCM53128_A0_HL_PRTC_CTRLr_t HL_PRTC_CTRLr_t;
#define HL_PRTC_CTRLr_CLR BCM53128_A0_HL_PRTC_CTRLr_CLR
#define HL_PRTC_CTRLr_SET BCM53128_A0_HL_PRTC_CTRLr_SET
#define HL_PRTC_CTRLr_GET BCM53128_A0_HL_PRTC_CTRLr_GET
#define HL_PRTC_CTRLr_ARP_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_ARP_ENf_GET
#define HL_PRTC_CTRLr_ARP_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_ARP_ENf_SET
#define HL_PRTC_CTRLr_RARP_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_RARP_ENf_GET
#define HL_PRTC_CTRLr_RARP_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_RARP_ENf_SET
#define HL_PRTC_CTRLr_DHCP_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_DHCP_ENf_GET
#define HL_PRTC_CTRLr_DHCP_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_DHCP_ENf_SET
#define HL_PRTC_CTRLr_ICMPV4_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET
#define HL_PRTC_CTRLr_ICMPV4_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET
#define HL_PRTC_CTRLr_ICMPV6_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET BCM53128_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_0f_GET BCM53128_A0_HL_PRTC_CTRLr_RESERVED_0f_GET
#define HL_PRTC_CTRLr_RESERVED_0f_SET BCM53128_A0_HL_PRTC_CTRLr_RESERVED_0f_SET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET BCM53128_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET BCM53128_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_GET BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_SET BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET BCM53128_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_1f_GET BCM53128_A0_HL_PRTC_CTRLr_RESERVED_1f_GET
#define HL_PRTC_CTRLr_RESERVED_1f_SET BCM53128_A0_HL_PRTC_CTRLr_RESERVED_1f_SET
#define READ_HL_PRTC_CTRLr BCM53128_A0_READ_HL_PRTC_CTRLr
#define WRITE_HL_PRTC_CTRLr BCM53128_A0_WRITE_HL_PRTC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_HL_PRTC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_MSK       Ingress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-7 = Port 0-7Bit 8= IMP Port.
 *     RESERVED         Reserved
 *     IN_DIV_EN        Ingress Divider Enable.Mirror every nth received frame (n=IN_MIRROR_DIV + 1) that has passed through the IN_MIRROR_FILTER.
 *     IN_MIR_FLTR      Ingress Mirror Filter.Defines the conditions under which frames received on a port that has been selected in the IN_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all ingress frames.01: Mirror all received frames with DA = IN_MIRROR_MAC.10: Mirror all received frames with SA = IN_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_IGMIRCTLr 0x00000212

#define BCM53128_A0_IGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRCTL.
 *
 */
typedef union BCM53128_A0_IGMIRCTLr_s {
	uint32_t v[1];
	uint32_t igmirctl[1];
	uint32_t _igmirctl;
} BCM53128_A0_IGMIRCTLr_t;

#define BCM53128_A0_IGMIRCTLr_CLR(r) (r).igmirctl[0] = 0
#define BCM53128_A0_IGMIRCTLr_SET(r,d) (r).igmirctl[0] = d
#define BCM53128_A0_IGMIRCTLr_GET(r) (r).igmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) (((r).igmirctl[0]) & 0x1ff)
#define BCM53128_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_IGMIRCTLr_RESERVEDf_GET(r) ((((r).igmirctl[0]) >> 9) & 0xf)
#define BCM53128_A0_IGMIRCTLr_RESERVEDf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53128_A0_IGMIRCTLr_IN_DIV_ENf_GET(r) ((((r).igmirctl[0]) >> 13) & 0x1)
#define BCM53128_A0_IGMIRCTLr_IN_DIV_ENf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_IGMIRCTLr_IN_MIR_FLTRf_GET(r) ((((r).igmirctl[0]) >> 14) & 0x3)
#define BCM53128_A0_IGMIRCTLr_IN_MIR_FLTRf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IGMIRCTL.
 *
 */
#define BCM53128_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IGMIRCTLr,(r._igmirctl),2)
#define BCM53128_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IGMIRCTLr,&(r._igmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM53128_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM53128_A0_IGMIRCTLr_SIZE
typedef BCM53128_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM53128_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM53128_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM53128_A0_IGMIRCTLr_GET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM53128_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM53128_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_RESERVEDf_GET BCM53128_A0_IGMIRCTLr_RESERVEDf_GET
#define IGMIRCTLr_RESERVEDf_SET BCM53128_A0_IGMIRCTLr_RESERVEDf_SET
#define IGMIRCTLr_IN_DIV_ENf_GET BCM53128_A0_IGMIRCTLr_IN_DIV_ENf_GET
#define IGMIRCTLr_IN_DIV_ENf_SET BCM53128_A0_IGMIRCTLr_IN_DIV_ENf_SET
#define IGMIRCTLr_IN_MIR_FLTRf_GET BCM53128_A0_IGMIRCTLr_IN_MIR_FLTRf_GET
#define IGMIRCTLr_IN_MIR_FLTRf_SET BCM53128_A0_IGMIRCTLr_IN_MIR_FLTRf_SET
#define READ_IGMIRCTLr BCM53128_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM53128_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_DIV       Ingress Mirror Divider.Receive frames that have passed the IN_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the IN_DIV_EN bit in the Ingress Mirror Control register is set, frames that pass the IN_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = IN_MIRROR_DIV + 1) will be mirrored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IGMIRDIVr 0x00000214

#define BCM53128_A0_IGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRDIV.
 *
 */
typedef union BCM53128_A0_IGMIRDIVr_s {
	uint32_t v[1];
	uint32_t igmirdiv[1];
	uint32_t _igmirdiv;
} BCM53128_A0_IGMIRDIVr_t;

#define BCM53128_A0_IGMIRDIVr_CLR(r) (r).igmirdiv[0] = 0
#define BCM53128_A0_IGMIRDIVr_SET(r,d) (r).igmirdiv[0] = d
#define BCM53128_A0_IGMIRDIVr_GET(r) (r).igmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IGMIRDIVr_IN_MIR_DIVf_GET(r) (((r).igmirdiv[0]) & 0x3ff)
#define BCM53128_A0_IGMIRDIVr_IN_MIR_DIVf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53128_A0_IGMIRDIVr_RESERVEDf_GET(r) ((((r).igmirdiv[0]) >> 10) & 0x3f)
#define BCM53128_A0_IGMIRDIVr_RESERVEDf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access IGMIRDIV.
 *
 */
#define BCM53128_A0_READ_IGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IGMIRDIVr,(r._igmirdiv),2)
#define BCM53128_A0_WRITE_IGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IGMIRDIVr,&(r._igmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRDIVr BCM53128_A0_IGMIRDIVr
#define IGMIRDIVr_SIZE BCM53128_A0_IGMIRDIVr_SIZE
typedef BCM53128_A0_IGMIRDIVr_t IGMIRDIVr_t;
#define IGMIRDIVr_CLR BCM53128_A0_IGMIRDIVr_CLR
#define IGMIRDIVr_SET BCM53128_A0_IGMIRDIVr_SET
#define IGMIRDIVr_GET BCM53128_A0_IGMIRDIVr_GET
#define IGMIRDIVr_IN_MIR_DIVf_GET BCM53128_A0_IGMIRDIVr_IN_MIR_DIVf_GET
#define IGMIRDIVr_IN_MIR_DIVf_SET BCM53128_A0_IGMIRDIVr_IN_MIR_DIVf_SET
#define IGMIRDIVr_RESERVEDf_GET BCM53128_A0_IGMIRDIVr_RESERVEDf_GET
#define IGMIRDIVr_RESERVEDf_SET BCM53128_A0_IGMIRDIVr_RESERVEDf_SET
#define READ_IGMIRDIVr BCM53128_A0_READ_IGMIRDIVr
#define WRITE_IGMIRDIVr BCM53128_A0_WRITE_IGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Mac Address Register
 * SIZE:     48
 * FIELDS:
 *     IN_MIR_MAC       Ingress Mirror MAC AddressMAC address that will be compared against ingress frames in accordance with the IN_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM53128_A0_IGMIRMACr 0x00000216

#define BCM53128_A0_IGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program IGMIRMAC.
 *
 */
typedef union BCM53128_A0_IGMIRMACr_s {
	uint32_t v[2];
	uint32_t igmirmac[2];
	uint32_t _igmirmac;
} BCM53128_A0_IGMIRMACr_t;

#define BCM53128_A0_IGMIRMACr_CLR(r) CDK_MEMSET(&((r)._igmirmac), 0, sizeof(BCM53128_A0_IGMIRMACr_t))
#define BCM53128_A0_IGMIRMACr_SET(r,i,d) (r).igmirmac[i] = d
#define BCM53128_A0_IGMIRMACr_GET(r,i) (r).igmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IGMIRMACr_IN_MIR_MACf_GET(r,a) cdk_field_get((r).igmirmac,0,47,a)
#define BCM53128_A0_IGMIRMACr_IN_MIR_MACf_SET(r,a) cdk_field_set((r).igmirmac,0,47,a)

/*
 * These macros can be used to access IGMIRMAC.
 *
 */
#define BCM53128_A0_READ_IGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IGMIRMACr,(r._igmirmac),6)
#define BCM53128_A0_WRITE_IGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IGMIRMACr,&(r._igmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRMACr BCM53128_A0_IGMIRMACr
#define IGMIRMACr_SIZE BCM53128_A0_IGMIRMACr_SIZE
typedef BCM53128_A0_IGMIRMACr_t IGMIRMACr_t;
#define IGMIRMACr_CLR BCM53128_A0_IGMIRMACr_CLR
#define IGMIRMACr_SET BCM53128_A0_IGMIRMACr_SET
#define IGMIRMACr_GET BCM53128_A0_IGMIRMACr_GET
#define IGMIRMACr_IN_MIR_MACf_GET BCM53128_A0_IGMIRMACr_IN_MIR_MACf_GET
#define IGMIRMACr_IN_MIR_MACf_SET BCM53128_A0_IGMIRMACr_IN_MIR_MACf_SET
#define READ_IGMIRMACr BCM53128_A0_READ_IGMIRMACr
#define WRITE_IGMIRMACr BCM53128_A0_WRITE_IGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP0_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP/IMP0 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP0_PRT_ID      IMP/IMP0 Port IDThis field specifies the port ID of the IMP/IMP0 port.In Blackbird2, IMP/IMP0 is fixed at Port 8.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP0_PRT_IDr 0x00000201

#define BCM53128_A0_IMP0_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP0_PRT_ID.
 *
 */
typedef union BCM53128_A0_IMP0_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp0_prt_id[1];
	uint32_t _imp0_prt_id;
} BCM53128_A0_IMP0_PRT_IDr_t;

#define BCM53128_A0_IMP0_PRT_IDr_CLR(r) (r).imp0_prt_id[0] = 0
#define BCM53128_A0_IMP0_PRT_IDr_SET(r,d) (r).imp0_prt_id[0] = d
#define BCM53128_A0_IMP0_PRT_IDr_GET(r) (r).imp0_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET(r) (((r).imp0_prt_id[0]) & 0xf)
#define BCM53128_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_IMP0_PRT_IDr_RESERVEDf_GET(r) ((((r).imp0_prt_id[0]) >> 4) & 0xf)
#define BCM53128_A0_IMP0_PRT_IDr_RESERVEDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP0_PRT_ID.
 *
 */
#define BCM53128_A0_READ_IMP0_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP0_PRT_IDr,(r._imp0_prt_id),1)
#define BCM53128_A0_WRITE_IMP0_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP0_PRT_IDr,&(r._imp0_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP0_PRT_IDr BCM53128_A0_IMP0_PRT_IDr
#define IMP0_PRT_IDr_SIZE BCM53128_A0_IMP0_PRT_IDr_SIZE
typedef BCM53128_A0_IMP0_PRT_IDr_t IMP0_PRT_IDr_t;
#define IMP0_PRT_IDr_CLR BCM53128_A0_IMP0_PRT_IDr_CLR
#define IMP0_PRT_IDr_SET BCM53128_A0_IMP0_PRT_IDr_SET
#define IMP0_PRT_IDr_GET BCM53128_A0_IMP0_PRT_IDr_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_GET BCM53128_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_SET BCM53128_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET
#define IMP0_PRT_IDr_RESERVEDf_GET BCM53128_A0_IMP0_PRT_IDr_RESERVEDf_GET
#define IMP0_PRT_IDr_RESERVEDf_SET BCM53128_A0_IMP0_PRT_IDr_RESERVEDf_SET
#define READ_IMP0_PRT_IDr BCM53128_A0_READ_IMP0_PRT_IDr
#define WRITE_IMP0_PRT_IDr BCM53128_A0_WRITE_IMP0_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP0_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP1_EGRESS_RATE_CTRL_CFG_REG
 * BLOCKS:   SYS
 * DESC:     IMP1 Egress Rate Control Configuration Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     RATE_INDEX       The rate_index is used to configure different egress rate for IMP in terms of Packet Per Second(PPS). When setting to 0, the egress rate is limited to a maximum of 384 packets/second for continuous minimum sized packet(68 bytes, including 4 byte BRCM header). When setting to 63, the egress rate control function is disabled and all packets are transmitted at wire-speed. The rate_index setting is not affected by the network speed configuration. For example, once you set the rate_index at certain value, the egress rate is limitted to the corresponding speed no matter the switch is running at 10Mbps, 100Mbps or 1Gbps. However, the maximum rate you programmed should be a reasonable value under the corresponding network speed configuration. For example, it doesn't make sense to set a value of 63 with the network configuration at 10Mbps. In that case, the egress rate is limitted up to 10Mbps no matter what.      (Rate_index :        Packets/sec)           (0     :             384);           (1     :             512)           (2     :             639);           (3     :             768)           (4     :            1024);           (5     :            1280)           (6     :            1536);           (7     :            1791)           (8     :            2048);           (9     :            2303)          (10     :            2559);          (11     :            2815)          (12     :            3328);          (13     :            3840)          (14     :            4352);          (15     :            4863)          (16     :            5376);          (17     :            5887)          (18     :            6400);          (19     :            6911)          (20     :            7936);          (21     :            8960)          (22     :            9984);          (23     :           11008)          (24     :           12030);          (25     :           13054)          (26     :           14076);          (27     :           15105)          (28     :           17146);          (29     :           19201)          (30     :           21240);          (31     :           23299)          (32     :           25354);          (33     :           27382)          (34     :           29446);          (35     :           31486)          (36     :           35561);          (37     :           39682)          (38     :           42589);          (39     :           56818)          (40     :           71023);          (41     :           85324)          (42     :           99602);          (43     :          113636)          (44     :          127551);          (45     :          142045)          (46     :          213675);          (47     :          284091)          (48     :          357143);          (49     :          423729)          (50     :          500000);          (51     :          568182)          (52     :          641026);          (53     :          714286)          (54     :          781250);          (55     :          862069)          (56     :          925926);          (57     :         1000000)          (58     :         1086957);          (59     :         1136364)          (60     :         1190476);          (61     :         1250000)          (62     :         1315789);          (63     :         1388889)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr 0x000041c1

#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SIZE 1

/*
 * This structure should be used to declare and program IMP1_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
typedef union BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_s {
	uint32_t v[1];
	uint32_t imp1_egress_rate_ctrl_cfg_reg[1];
	uint32_t _imp1_egress_rate_ctrl_cfg_reg;
} BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_t;

#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_CLR(r) (r).imp1_egress_rate_ctrl_cfg_reg[0] = 0
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SET(r,d) (r).imp1_egress_rate_ctrl_cfg_reg[0] = d
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_GET(r) (r).imp1_egress_rate_ctrl_cfg_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET(r) (((r).imp1_egress_rate_ctrl_cfg_reg[0]) & 0x3f)
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET(r,f) (r).imp1_egress_rate_ctrl_cfg_reg[0]=(((r).imp1_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET(r) ((((r).imp1_egress_rate_ctrl_cfg_reg[0]) >> 6) & 0x3)
#define BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET(r,f) (r).imp1_egress_rate_ctrl_cfg_reg[0]=(((r).imp1_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP1_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
#define BCM53128_A0_READ_IMP1_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr,(r._imp1_egress_rate_ctrl_cfg_reg),1)
#define BCM53128_A0_WRITE_IMP1_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr,&(r._imp1_egress_rate_ctrl_cfg_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP1_EGRESS_RATE_CTRL_CFG_REGr BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_SIZE BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SIZE
typedef BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_t IMP1_EGRESS_RATE_CTRL_CFG_REGr_t;
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_CLR BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_CLR
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_SET BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_GET BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_GET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET
#define READ_IMP1_EGRESS_RATE_CTRL_CFG_REGr BCM53128_A0_READ_IMP1_EGRESS_RATE_CTRL_CFG_REGr
#define WRITE_IMP1_EGRESS_RATE_CTRL_CFG_REGr BCM53128_A0_WRITE_IMP1_EGRESS_RATE_CTRL_CFG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_CTL
 * BLOCKS:   CPIC
 * DESC:     IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.It's illegal to set this bit to '1'.(Not2Release).
 *     TX_DIS           Disables the transmit function of the port at the MAC level.It's illegal to set this bit to '1'.(Not2Release).
 *     RX_BCST_EN       Receive Broadcast Enable.Allow broadcast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_MCST_EN       Receive Multicast Enable.Allow multicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flodded due to no matching address table entry.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_UCST_EN       Receive Unicast Enable.Allow unicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flooded due to no matching address table entry.When cleared, unicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_CTLr 0x00000008

#define BCM53128_A0_IMP_CTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_CTL.
 *
 */
typedef union BCM53128_A0_IMP_CTLr_s {
	uint32_t v[1];
	uint32_t imp_ctl[1];
	uint32_t _imp_ctl;
} BCM53128_A0_IMP_CTLr_t;

#define BCM53128_A0_IMP_CTLr_CLR(r) (r).imp_ctl[0] = 0
#define BCM53128_A0_IMP_CTLr_SET(r,d) (r).imp_ctl[0] = d
#define BCM53128_A0_IMP_CTLr_GET(r) (r).imp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_CTLr_RX_DISf_GET(r) (((r).imp_ctl[0]) & 0x1)
#define BCM53128_A0_IMP_CTLr_RX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_IMP_CTLr_TX_DISf_GET(r) ((((r).imp_ctl[0]) >> 1) & 0x1)
#define BCM53128_A0_IMP_CTLr_TX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_IMP_CTLr_RX_BCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 2) & 0x1)
#define BCM53128_A0_IMP_CTLr_RX_BCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_IMP_CTLr_RX_MCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_IMP_CTLr_RX_MCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_IMP_CTLr_RX_UCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_IMP_CTLr_RX_UCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_IMP_CTLr_RESERVEDf_GET(r) ((((r).imp_ctl[0]) >> 5) & 0x7)
#define BCM53128_A0_IMP_CTLr_RESERVEDf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access IMP_CTL.
 *
 */
#define BCM53128_A0_READ_IMP_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_CTLr,(r._imp_ctl),1)
#define BCM53128_A0_WRITE_IMP_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_CTLr,&(r._imp_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_CTLr BCM53128_A0_IMP_CTLr
#define IMP_CTLr_SIZE BCM53128_A0_IMP_CTLr_SIZE
typedef BCM53128_A0_IMP_CTLr_t IMP_CTLr_t;
#define IMP_CTLr_CLR BCM53128_A0_IMP_CTLr_CLR
#define IMP_CTLr_SET BCM53128_A0_IMP_CTLr_SET
#define IMP_CTLr_GET BCM53128_A0_IMP_CTLr_GET
#define IMP_CTLr_RX_DISf_GET BCM53128_A0_IMP_CTLr_RX_DISf_GET
#define IMP_CTLr_RX_DISf_SET BCM53128_A0_IMP_CTLr_RX_DISf_SET
#define IMP_CTLr_TX_DISf_GET BCM53128_A0_IMP_CTLr_TX_DISf_GET
#define IMP_CTLr_TX_DISf_SET BCM53128_A0_IMP_CTLr_TX_DISf_SET
#define IMP_CTLr_RX_BCST_ENf_GET BCM53128_A0_IMP_CTLr_RX_BCST_ENf_GET
#define IMP_CTLr_RX_BCST_ENf_SET BCM53128_A0_IMP_CTLr_RX_BCST_ENf_SET
#define IMP_CTLr_RX_MCST_ENf_GET BCM53128_A0_IMP_CTLr_RX_MCST_ENf_GET
#define IMP_CTLr_RX_MCST_ENf_SET BCM53128_A0_IMP_CTLr_RX_MCST_ENf_SET
#define IMP_CTLr_RX_UCST_ENf_GET BCM53128_A0_IMP_CTLr_RX_UCST_ENf_GET
#define IMP_CTLr_RX_UCST_ENf_SET BCM53128_A0_IMP_CTLr_RX_UCST_ENf_SET
#define IMP_CTLr_RESERVEDf_GET BCM53128_A0_IMP_CTLr_RESERVEDf_GET
#define IMP_CTLr_RESERVEDf_SET BCM53128_A0_IMP_CTLr_RESERVEDf_SET
#define READ_IMP_CTLr BCM53128_A0_READ_IMP_CTLr
#define WRITE_IMP_CTLr BCM53128_A0_WRITE_IMP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_EGRESS_RATE_CTRL_CFG_REG
 * BLOCKS:   SYS
 * DESC:     IMP0 Egress Rate Control Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RATE_INDEX       The rate_index is used to configure different egress rate for IMP in terms of Packet Per Second(PPS). When setting to 0, the egress rate is limited to a maximum of 384 packets/second for continuous minimum sized packet(68 bytes, including 4 byte BRCM header). When setting to 63, the egress rate control function is disabled and all packets are transmitted at wire-speed. The rate_index setting is not affected by the network speed configuration. For example, once you set the rate_index at certain value, the egress rate is limitted to the corresponding speed no matter the switch is running at 10Mbps, 100Mbps or 1Gbps. However, the maximum rate you programmed should be a reasonable value under the corresponding network speed configuration. For example, it doesn't make sense to set a value of 63 with the network configuration at 10Mbps. In that case, the egress rate is limitted up to 10Mbps no matter what.      (Rate_index :        Packets/sec)           (0     :             384);           (1     :             512)           (2     :             639);           (3     :             768)           (4     :            1024);           (5     :            1280)           (6     :            1536);           (7     :            1791)           (8     :            2048);           (9     :            2303)          (10     :            2559);          (11     :            2815)          (12     :            3328);          (13     :            3840)          (14     :            4352);          (15     :            4863)          (16     :            5376);          (17     :            5887)          (18     :            6400);          (19     :            6911)          (20     :            7936);          (21     :            8960)          (22     :            9984);          (23     :           11008)          (24     :           12030);          (25     :           13054)          (26     :           14076);          (27     :           15105)          (28     :           17146);          (29     :           19201)          (30     :           21240);          (31     :           23299)          (32     :           25354);          (33     :           27382)          (34     :           29446);          (35     :           31486)          (36     :           35561);          (37     :           39682)          (38     :           42589);          (39     :           56818)          (40     :           71023);          (41     :           85324)          (42     :           99602);          (43     :          113636)          (44     :          127551);          (45     :          142045)          (46     :          213675);          (47     :          284091)          (48     :          357143);          (49     :          423729)          (50     :          500000);          (51     :          568182)          (52     :          641026);          (53     :          714286)          (54     :          781250);          (55     :          862069)          (56     :          925926);          (57     :         1000000)          (58     :         1086957);          (59     :         1136364)          (60     :         1190476);          (61     :         1250000)          (62     :         1315789);          (63     :         1388889)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr 0x000041c0

#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE 1

/*
 * This structure should be used to declare and program IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
typedef union BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_s {
	uint32_t v[1];
	uint32_t imp_egress_rate_ctrl_cfg_reg[1];
	uint32_t _imp_egress_rate_ctrl_cfg_reg;
} BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t;

#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR(r) (r).imp_egress_rate_ctrl_cfg_reg[0] = 0
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET(r,d) (r).imp_egress_rate_ctrl_cfg_reg[0] = d
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET(r) (r).imp_egress_rate_ctrl_cfg_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET(r) (((r).imp_egress_rate_ctrl_cfg_reg[0]) & 0x3f)
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET(r) ((((r).imp_egress_rate_ctrl_cfg_reg[0]) >> 6) & 0x3)
#define BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
#define BCM53128_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr,(r._imp_egress_rate_ctrl_cfg_reg),1)
#define BCM53128_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr,&(r._imp_egress_rate_ctrl_cfg_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE
typedef BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t IMP_EGRESS_RATE_CTRL_CFG_REGr_t;
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SET BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_GET BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET
#define READ_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53128_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53128_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_PCP2TC
 * BLOCKS:   SYS
 * DESC:     Port 8 PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_PCP2TCr 0x00003030

#define BCM53128_A0_IMP_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program IMP_PCP2TC.
 *
 */
typedef union BCM53128_A0_IMP_PCP2TCr_s {
	uint32_t v[1];
	uint32_t imp_pcp2tc[1];
	uint32_t _imp_pcp2tc;
} BCM53128_A0_IMP_PCP2TCr_t;

#define BCM53128_A0_IMP_PCP2TCr_CLR(r) (r).imp_pcp2tc[0] = 0
#define BCM53128_A0_IMP_PCP2TCr_SET(r,d) (r).imp_pcp2tc[0] = d
#define BCM53128_A0_IMP_PCP2TCr_GET(r) (r).imp_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).imp_pcp2tc[0]) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 3) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 6) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 9) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 12) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 15) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 18) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 21) & 0x7)
#define BCM53128_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_IMP_PCP2TCr_RESERVEDf_GET(r) ((((r).imp_pcp2tc[0]) >> 24) & 0xff)
#define BCM53128_A0_IMP_PCP2TCr_RESERVEDf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access IMP_PCP2TC.
 *
 */
#define BCM53128_A0_READ_IMP_PCP2TCr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_PCP2TCr,(r._imp_pcp2tc),4)
#define BCM53128_A0_WRITE_IMP_PCP2TCr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_PCP2TCr,&(r._imp_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_PCP2TCr BCM53128_A0_IMP_PCP2TCr
#define IMP_PCP2TCr_SIZE BCM53128_A0_IMP_PCP2TCr_SIZE
typedef BCM53128_A0_IMP_PCP2TCr_t IMP_PCP2TCr_t;
#define IMP_PCP2TCr_CLR BCM53128_A0_IMP_PCP2TCr_CLR
#define IMP_PCP2TCr_SET BCM53128_A0_IMP_PCP2TCr_SET
#define IMP_PCP2TCr_GET BCM53128_A0_IMP_PCP2TCr_GET
#define IMP_PCP2TCr_TAG000_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG000_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG001_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG001_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG010_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG010_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG011_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG011_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG100_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG100_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG101_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG101_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG110_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG110_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG111_PRI_MAPf_GET BCM53128_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG111_PRI_MAPf_SET BCM53128_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_SET
#define IMP_PCP2TCr_RESERVEDf_GET BCM53128_A0_IMP_PCP2TCr_RESERVEDf_GET
#define IMP_PCP2TCr_RESERVEDf_SET BCM53128_A0_IMP_PCP2TCr_RESERVEDf_SET
#define READ_IMP_PCP2TCr BCM53128_A0_READ_IMP_PCP2TCr
#define WRITE_IMP_PCP2TCr BCM53128_A0_WRITE_IMP_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_RGMII_CTL_GP
 * BLOCKS:   CPIC
 * DESC:     IMP RGMII Control register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_IMP_RGMII_DLL_TXC 1: RGMII tx_clk delayed timing mode(Delay Mode)0: RGMII tx_clk aligned timing mode(Normal Mode)default value by strap pin gtx_0_setup.
 *     EN_IMP_RGMII_DLL_RXC 1: clock delay by DLL is enabled(Delay Mode)0: clock delay by DLL is disabled (Normal Mode)default value by strap pin grx_0_setup.
 *     BYPASS_IMP_2NS_DEL 1: bypass dll65_2ns_del IP0: use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affected by bit[0] and bit[1]{Bit[2], Bit[0]}= 2'b10, Bypass tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b11, use tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b0X, use tx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b10, Bypass rx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b11, use rx side dll65_2ns_del IP{Bit[2], Bit[1}= 2'b0X, use rx side dll65_2ns_del IP
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_RGMII_CTL_GPr 0x00000060

#define BCM53128_A0_IMP_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_CTL_GP.
 *
 */
typedef union BCM53128_A0_IMP_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_ctl_gp[1];
	uint32_t _imp_rgmii_ctl_gp;
} BCM53128_A0_IMP_RGMII_CTL_GPr_t;

#define BCM53128_A0_IMP_RGMII_CTL_GPr_CLR(r) (r).imp_rgmii_ctl_gp[0] = 0
#define BCM53128_A0_IMP_RGMII_CTL_GPr_SET(r,d) (r).imp_rgmii_ctl_gp[0] = d
#define BCM53128_A0_IMP_RGMII_CTL_GPr_GET(r) (r).imp_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_TXCf_GET(r) (((r).imp_rgmii_ctl_gp[0]) & 0x1)
#define BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_TXCf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_RXCf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_RXCf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_IMP_RGMII_CTL_GPr_BYPASS_IMP_2NS_DELf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM53128_A0_IMP_RGMII_CTL_GPr_BYPASS_IMP_2NS_DELf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_IMP_RGMII_CTL_GPr_RESERVEDf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 3) & 0x1f)
#define BCM53128_A0_IMP_RGMII_CTL_GPr_RESERVEDf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access IMP_RGMII_CTL_GP.
 *
 */
#define BCM53128_A0_READ_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_RGMII_CTL_GPr,(r._imp_rgmii_ctl_gp),1)
#define BCM53128_A0_WRITE_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_RGMII_CTL_GPr,&(r._imp_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_CTL_GPr BCM53128_A0_IMP_RGMII_CTL_GPr
#define IMP_RGMII_CTL_GPr_SIZE BCM53128_A0_IMP_RGMII_CTL_GPr_SIZE
typedef BCM53128_A0_IMP_RGMII_CTL_GPr_t IMP_RGMII_CTL_GPr_t;
#define IMP_RGMII_CTL_GPr_CLR BCM53128_A0_IMP_RGMII_CTL_GPr_CLR
#define IMP_RGMII_CTL_GPr_SET BCM53128_A0_IMP_RGMII_CTL_GPr_SET
#define IMP_RGMII_CTL_GPr_GET BCM53128_A0_IMP_RGMII_CTL_GPr_GET
#define IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_TXCf_GET BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_TXCf_GET
#define IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_TXCf_SET BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_TXCf_SET
#define IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_RXCf_GET BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_RXCf_GET
#define IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_RXCf_SET BCM53128_A0_IMP_RGMII_CTL_GPr_EN_IMP_RGMII_DLL_RXCf_SET
#define IMP_RGMII_CTL_GPr_BYPASS_IMP_2NS_DELf_GET BCM53128_A0_IMP_RGMII_CTL_GPr_BYPASS_IMP_2NS_DELf_GET
#define IMP_RGMII_CTL_GPr_BYPASS_IMP_2NS_DELf_SET BCM53128_A0_IMP_RGMII_CTL_GPr_BYPASS_IMP_2NS_DELf_SET
#define IMP_RGMII_CTL_GPr_RESERVEDf_GET BCM53128_A0_IMP_RGMII_CTL_GPr_RESERVEDf_GET
#define IMP_RGMII_CTL_GPr_RESERVEDf_SET BCM53128_A0_IMP_RGMII_CTL_GPr_RESERVEDf_SET
#define READ_IMP_RGMII_CTL_GPr BCM53128_A0_READ_IMP_RGMII_CTL_GPr
#define WRITE_IMP_RGMII_CTL_GPr BCM53128_A0_WRITE_IMP_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_RGMII_TIME_DLY_GP
 * BLOCKS:   CPIC
 * DESC:     IMP Port RGMII TIMING DELAY register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr 0x00000068

#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_time_dly_gp[1];
	uint32_t _imp_rgmii_time_dly_gp;
} BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_t;

#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_CLR(r) (r).imp_rgmii_time_dly_gp[0] = 0
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_SET(r,d) (r).imp_rgmii_time_dly_gp[0] = d
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_GET(r) (r).imp_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).imp_rgmii_time_dly_gp[0]) & 0xf)
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access IMP_RGMII_TIME_DLY_GP.
 *
 */
#define BCM53128_A0_READ_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_RGMII_TIME_DLY_GPr,(r._imp_rgmii_time_dly_gp),1)
#define BCM53128_A0_WRITE_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_RGMII_TIME_DLY_GPr,&(r._imp_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_TIME_DLY_GPr BCM53128_A0_IMP_RGMII_TIME_DLY_GPr
#define IMP_RGMII_TIME_DLY_GPr_SIZE BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_SIZE
typedef BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_t IMP_RGMII_TIME_DLY_GPr_t;
#define IMP_RGMII_TIME_DLY_GPr_CLR BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_CLR
#define IMP_RGMII_TIME_DLY_GPr_SET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_SET
#define IMP_RGMII_TIME_DLY_GPr_GET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM53128_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_IMP_RGMII_TIME_DLY_GPr BCM53128_A0_READ_IMP_RGMII_TIME_DLY_GPr
#define WRITE_IMP_RGMII_TIME_DLY_GPr BCM53128_A0_WRITE_IMP_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_SLEEP_STS
 * BLOCKS:   SYS
 * DESC:     IMP Sleep Status Register
 * SIZE:     8
 * FIELDS:
 *     IMP_PORT_SLEEP_STS IMP Port(port8) Sleep Status.0 = IMP port is not in IMP_Sleep mode whenever either reset or the counter of IMP SLEEP Timer is equal to zero.(Note: the port is in IMP_SLEEP INIT state)1 = IMP port is in IMP_Sleep mode when the counter of IMP Sleep Timer is not equal to zero.(Note: the port is not in IMP_SLEEP INIT state)
 *     RESERVED         Reserved
 *     WAN_PORT_SLEEP_STS Port7 Sleep Status.0 = Port7 is not in IMP_Sleep mode whenever either reset or the counter of Port7 Sleep Timer is equal to zero.(Note: the port is in IMP_SLEEP INIT state)1 = Port7 is in IMP_Sleep mode when the counter of Port7 Sleep Timer is not equal to zero.(Note: the port is not in IMP_SLEEP INIT state)(Not2Release)
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_SLEEP_STSr 0x00000318

#define BCM53128_A0_IMP_SLEEP_STSr_SIZE 1

/*
 * This structure should be used to declare and program IMP_SLEEP_STS.
 *
 */
typedef union BCM53128_A0_IMP_SLEEP_STSr_s {
	uint32_t v[1];
	uint32_t imp_sleep_sts[1];
	uint32_t _imp_sleep_sts;
} BCM53128_A0_IMP_SLEEP_STSr_t;

#define BCM53128_A0_IMP_SLEEP_STSr_CLR(r) (r).imp_sleep_sts[0] = 0
#define BCM53128_A0_IMP_SLEEP_STSr_SET(r,d) (r).imp_sleep_sts[0] = d
#define BCM53128_A0_IMP_SLEEP_STSr_GET(r) (r).imp_sleep_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_SLEEP_STSr_IMP_PORT_SLEEP_STSf_GET(r) (((r).imp_sleep_sts[0]) & 0x1)
#define BCM53128_A0_IMP_SLEEP_STSr_IMP_PORT_SLEEP_STSf_SET(r,f) (r).imp_sleep_sts[0]=(((r).imp_sleep_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_IMP_SLEEP_STSr_RESERVEDf_GET(r) ((((r).imp_sleep_sts[0]) >> 1) & 0x7f)
#define BCM53128_A0_IMP_SLEEP_STSr_RESERVEDf_SET(r,f) (r).imp_sleep_sts[0]=(((r).imp_sleep_sts[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53128_A0_IMP_SLEEP_STSr_WAN_PORT_SLEEP_STSf_GET(r) ((((r).imp_sleep_sts[0]) >> 1) & 0x1)
#define BCM53128_A0_IMP_SLEEP_STSr_WAN_PORT_SLEEP_STSf_SET(r,f) (r).imp_sleep_sts[0]=(((r).imp_sleep_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access IMP_SLEEP_STS.
 *
 */
#define BCM53128_A0_READ_IMP_SLEEP_STSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_SLEEP_STSr,(r._imp_sleep_sts),1)
#define BCM53128_A0_WRITE_IMP_SLEEP_STSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_SLEEP_STSr,&(r._imp_sleep_sts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_SLEEP_STSr BCM53128_A0_IMP_SLEEP_STSr
#define IMP_SLEEP_STSr_SIZE BCM53128_A0_IMP_SLEEP_STSr_SIZE
typedef BCM53128_A0_IMP_SLEEP_STSr_t IMP_SLEEP_STSr_t;
#define IMP_SLEEP_STSr_CLR BCM53128_A0_IMP_SLEEP_STSr_CLR
#define IMP_SLEEP_STSr_SET BCM53128_A0_IMP_SLEEP_STSr_SET
#define IMP_SLEEP_STSr_GET BCM53128_A0_IMP_SLEEP_STSr_GET
#define IMP_SLEEP_STSr_IMP_PORT_SLEEP_STSf_GET BCM53128_A0_IMP_SLEEP_STSr_IMP_PORT_SLEEP_STSf_GET
#define IMP_SLEEP_STSr_IMP_PORT_SLEEP_STSf_SET BCM53128_A0_IMP_SLEEP_STSr_IMP_PORT_SLEEP_STSf_SET
#define IMP_SLEEP_STSr_RESERVEDf_GET BCM53128_A0_IMP_SLEEP_STSr_RESERVEDf_GET
#define IMP_SLEEP_STSr_RESERVEDf_SET BCM53128_A0_IMP_SLEEP_STSr_RESERVEDf_SET
#define IMP_SLEEP_STSr_WAN_PORT_SLEEP_STSf_GET BCM53128_A0_IMP_SLEEP_STSr_WAN_PORT_SLEEP_STSf_GET
#define IMP_SLEEP_STSr_WAN_PORT_SLEEP_STSf_SET BCM53128_A0_IMP_SLEEP_STSr_WAN_PORT_SLEEP_STSf_SET
#define READ_IMP_SLEEP_STSr BCM53128_A0_READ_IMP_SLEEP_STSr
#define WRITE_IMP_SLEEP_STSr BCM53128_A0_WRITE_IMP_SLEEP_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_SLEEP_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_SLEEP_TIMER
 * BLOCKS:   SYS
 * DESC:     IMP Port(port 8) Sleep Timer Register
 * SIZE:     16
 * FIELDS:
 *     IMP_SLEEP_TIMER  IMP Sleep Timer.The configuration value of IMP port(port 8) sleep timer to indicate the desired sleep recovery time(i.e. wake-up time). When the timer is set by the CPU to a non-zero value. it puts the IMP port to sleep. The wake-up time is the set value decrease 1.The unit is 1 usec
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_SLEEP_TIMERr 0x00000310

#define BCM53128_A0_IMP_SLEEP_TIMERr_SIZE 2

/*
 * This structure should be used to declare and program IMP_SLEEP_TIMER.
 *
 */
typedef union BCM53128_A0_IMP_SLEEP_TIMERr_s {
	uint32_t v[1];
	uint32_t imp_sleep_timer[1];
	uint32_t _imp_sleep_timer;
} BCM53128_A0_IMP_SLEEP_TIMERr_t;

#define BCM53128_A0_IMP_SLEEP_TIMERr_CLR(r) (r).imp_sleep_timer[0] = 0
#define BCM53128_A0_IMP_SLEEP_TIMERr_SET(r,d) (r).imp_sleep_timer[0] = d
#define BCM53128_A0_IMP_SLEEP_TIMERr_GET(r) (r).imp_sleep_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_GET(r) (((r).imp_sleep_timer[0]) & 0x1fff)
#define BCM53128_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_SET(r,f) (r).imp_sleep_timer[0]=(((r).imp_sleep_timer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53128_A0_IMP_SLEEP_TIMERr_RESERVEDf_GET(r) ((((r).imp_sleep_timer[0]) >> 13) & 0x7)
#define BCM53128_A0_IMP_SLEEP_TIMERr_RESERVEDf_SET(r,f) (r).imp_sleep_timer[0]=(((r).imp_sleep_timer[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access IMP_SLEEP_TIMER.
 *
 */
#define BCM53128_A0_READ_IMP_SLEEP_TIMERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_SLEEP_TIMERr,(r._imp_sleep_timer),2)
#define BCM53128_A0_WRITE_IMP_SLEEP_TIMERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_SLEEP_TIMERr,&(r._imp_sleep_timer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_SLEEP_TIMERr BCM53128_A0_IMP_SLEEP_TIMERr
#define IMP_SLEEP_TIMERr_SIZE BCM53128_A0_IMP_SLEEP_TIMERr_SIZE
typedef BCM53128_A0_IMP_SLEEP_TIMERr_t IMP_SLEEP_TIMERr_t;
#define IMP_SLEEP_TIMERr_CLR BCM53128_A0_IMP_SLEEP_TIMERr_CLR
#define IMP_SLEEP_TIMERr_SET BCM53128_A0_IMP_SLEEP_TIMERr_SET
#define IMP_SLEEP_TIMERr_GET BCM53128_A0_IMP_SLEEP_TIMERr_GET
#define IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_GET BCM53128_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_GET
#define IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_SET BCM53128_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_SET
#define IMP_SLEEP_TIMERr_RESERVEDf_GET BCM53128_A0_IMP_SLEEP_TIMERr_RESERVEDf_GET
#define IMP_SLEEP_TIMERr_RESERVEDf_SET BCM53128_A0_IMP_SLEEP_TIMERr_RESERVEDf_SET
#define READ_IMP_SLEEP_TIMERr BCM53128_A0_READ_IMP_SLEEP_TIMERr
#define WRITE_IMP_SLEEP_TIMERr BCM53128_A0_WRITE_IMP_SLEEP_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_SLEEP_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IMP_SOFTWARE_EGRESS_CTRL
 * BLOCKS:   SYS
 * DESC:     IMP Software Egress Control Register
 * SIZE:     8
 * FIELDS:
 *     START            Start of transmitting packet control (this field is valid only if bit [2] is set to 1'b1)2'b00: no action.2'b01: Writing 2'b01 to this filed allows IMP to transmit one packet. IMP will transmit the packet if there is any. Hardware will clear bit[0] when it finished sending one packet. If read 2'b01, It might be IMP busy in transmitting packet or IMP has no packet to transmit and is waiting.2'b10: Writing 2'b10 to this field request IMP to transmit all the packets to flush tx queues until all queues are empty. Hardware will clear bit[1] when it finished sending all packets. If read 2'b10, It means IMP is busy in transmitting packet. Prior to enable this flush function, the software must link down the IMP port.2'b11: Not allowed
 *     ENABLE           Enable of software egress control1'b1: enable, when enabled, IMP need to listen to bit [1:0] for transmitting permission. This bit must be set when 8051 TX/RX function is enabled.1'b0: disable, when disabled, IMP port doesn't need software permission to start transmitting.
 *     IMP_EGRESS_Q_STS IMP egress queue status1'b1: there are packets queueing in the IMP egress queues.1'b0: no packets in the IMP egress queues.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr 0x000041d0

#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_SOFTWARE_EGRESS_CTRL.
 *
 */
typedef union BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_s {
	uint32_t v[1];
	uint32_t imp_software_egress_ctrl[1];
	uint32_t _imp_software_egress_ctrl;
} BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_t;

#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_CLR(r) (r).imp_software_egress_ctrl[0] = 0
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_SET(r,d) (r).imp_software_egress_ctrl[0] = d
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_GET(r) (r).imp_software_egress_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_STARTf_GET(r) (((r).imp_software_egress_ctrl[0]) & 0x3)
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_STARTf_SET(r,f) (r).imp_software_egress_ctrl[0]=(((r).imp_software_egress_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_ENABLEf_GET(r) ((((r).imp_software_egress_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_ENABLEf_SET(r,f) (r).imp_software_egress_ctrl[0]=(((r).imp_software_egress_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_IMP_EGRESS_Q_STSf_GET(r) ((((r).imp_software_egress_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_IMP_EGRESS_Q_STSf_SET(r,f) (r).imp_software_egress_ctrl[0]=(((r).imp_software_egress_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_RESERVEDf_GET(r) ((((r).imp_software_egress_ctrl[0]) >> 4) & 0xf)
#define BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_RESERVEDf_SET(r,f) (r).imp_software_egress_ctrl[0]=(((r).imp_software_egress_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP_SOFTWARE_EGRESS_CTRL.
 *
 */
#define BCM53128_A0_READ_IMP_SOFTWARE_EGRESS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr,(r._imp_software_egress_ctrl),1)
#define BCM53128_A0_WRITE_IMP_SOFTWARE_EGRESS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr,&(r._imp_software_egress_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_SOFTWARE_EGRESS_CTRLr BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr
#define IMP_SOFTWARE_EGRESS_CTRLr_SIZE BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_SIZE
typedef BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_t IMP_SOFTWARE_EGRESS_CTRLr_t;
#define IMP_SOFTWARE_EGRESS_CTRLr_CLR BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_CLR
#define IMP_SOFTWARE_EGRESS_CTRLr_SET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_SET
#define IMP_SOFTWARE_EGRESS_CTRLr_GET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_GET
#define IMP_SOFTWARE_EGRESS_CTRLr_STARTf_GET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_STARTf_GET
#define IMP_SOFTWARE_EGRESS_CTRLr_STARTf_SET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_STARTf_SET
#define IMP_SOFTWARE_EGRESS_CTRLr_ENABLEf_GET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_ENABLEf_GET
#define IMP_SOFTWARE_EGRESS_CTRLr_ENABLEf_SET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_ENABLEf_SET
#define IMP_SOFTWARE_EGRESS_CTRLr_IMP_EGRESS_Q_STSf_GET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_IMP_EGRESS_Q_STSf_GET
#define IMP_SOFTWARE_EGRESS_CTRLr_IMP_EGRESS_Q_STSf_SET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_IMP_EGRESS_Q_STSf_SET
#define IMP_SOFTWARE_EGRESS_CTRLr_RESERVEDf_GET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_RESERVEDf_GET
#define IMP_SOFTWARE_EGRESS_CTRLr_RESERVEDf_SET BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr_RESERVEDf_SET
#define READ_IMP_SOFTWARE_EGRESS_CTRLr BCM53128_A0_READ_IMP_SOFTWARE_EGRESS_CTRLr
#define WRITE_IMP_SOFTWARE_EGRESS_CTRLr BCM53128_A0_WRITE_IMP_SOFTWARE_EGRESS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IMP_SOFTWARE_EGRESS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_ENR0
 * BLOCKS:   SYS
 * DESC:     Interrupt Enable Register 0 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_ENR0        Enable of the following interrupt requests:Bit 4-7: link status changes, port 0~port 3Bit 3: Resource grantBit 2: External CPU interrupt requestBit 1: WAN port wake upBit 0: IMP wake up
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_ENR0r 0x0000ff14

#define BCM53128_A0_INTC_ENR0r_SIZE 1

/*
 * This structure should be used to declare and program INTC_ENR0.
 *
 */
typedef union BCM53128_A0_INTC_ENR0r_s {
	uint32_t v[1];
	uint32_t intc_enr0[1];
	uint32_t _intc_enr0;
} BCM53128_A0_INTC_ENR0r_t;

#define BCM53128_A0_INTC_ENR0r_CLR(r) (r).intc_enr0[0] = 0
#define BCM53128_A0_INTC_ENR0r_SET(r,d) (r).intc_enr0[0] = d
#define BCM53128_A0_INTC_ENR0r_GET(r) (r).intc_enr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_ENR0r_INTC_ENR0f_GET(r) (((r).intc_enr0[0]) & 0xff)
#define BCM53128_A0_INTC_ENR0r_INTC_ENR0f_SET(r,f) (r).intc_enr0[0]=(((r).intc_enr0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_ENR0.
 *
 */
#define BCM53128_A0_READ_INTC_ENR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_ENR0r,(r._intc_enr0),1)
#define BCM53128_A0_WRITE_INTC_ENR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_ENR0r,&(r._intc_enr0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_ENR0r BCM53128_A0_INTC_ENR0r
#define INTC_ENR0r_SIZE BCM53128_A0_INTC_ENR0r_SIZE
typedef BCM53128_A0_INTC_ENR0r_t INTC_ENR0r_t;
#define INTC_ENR0r_CLR BCM53128_A0_INTC_ENR0r_CLR
#define INTC_ENR0r_SET BCM53128_A0_INTC_ENR0r_SET
#define INTC_ENR0r_GET BCM53128_A0_INTC_ENR0r_GET
#define INTC_ENR0r_INTC_ENR0f_GET BCM53128_A0_INTC_ENR0r_INTC_ENR0f_GET
#define INTC_ENR0r_INTC_ENR0f_SET BCM53128_A0_INTC_ENR0r_INTC_ENR0f_SET
#define READ_INTC_ENR0r BCM53128_A0_READ_INTC_ENR0r
#define WRITE_INTC_ENR0r BCM53128_A0_WRITE_INTC_ENR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_ENR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_ENR1
 * BLOCKS:   SYS
 * DESC:     Interrupt Enable Register 1 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_ENR1        Bit 5-7: reservedBit 0-4: link status changes, port 4~port 8
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_ENR1r 0x0000ff15

#define BCM53128_A0_INTC_ENR1r_SIZE 1

/*
 * This structure should be used to declare and program INTC_ENR1.
 *
 */
typedef union BCM53128_A0_INTC_ENR1r_s {
	uint32_t v[1];
	uint32_t intc_enr1[1];
	uint32_t _intc_enr1;
} BCM53128_A0_INTC_ENR1r_t;

#define BCM53128_A0_INTC_ENR1r_CLR(r) (r).intc_enr1[0] = 0
#define BCM53128_A0_INTC_ENR1r_SET(r,d) (r).intc_enr1[0] = d
#define BCM53128_A0_INTC_ENR1r_GET(r) (r).intc_enr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_ENR1r_INTC_ENR1f_GET(r) (((r).intc_enr1[0]) & 0xff)
#define BCM53128_A0_INTC_ENR1r_INTC_ENR1f_SET(r,f) (r).intc_enr1[0]=(((r).intc_enr1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_ENR1.
 *
 */
#define BCM53128_A0_READ_INTC_ENR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_ENR1r,(r._intc_enr1),1)
#define BCM53128_A0_WRITE_INTC_ENR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_ENR1r,&(r._intc_enr1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_ENR1r BCM53128_A0_INTC_ENR1r
#define INTC_ENR1r_SIZE BCM53128_A0_INTC_ENR1r_SIZE
typedef BCM53128_A0_INTC_ENR1r_t INTC_ENR1r_t;
#define INTC_ENR1r_CLR BCM53128_A0_INTC_ENR1r_CLR
#define INTC_ENR1r_SET BCM53128_A0_INTC_ENR1r_SET
#define INTC_ENR1r_GET BCM53128_A0_INTC_ENR1r_GET
#define INTC_ENR1r_INTC_ENR1f_GET BCM53128_A0_INTC_ENR1r_INTC_ENR1f_GET
#define INTC_ENR1r_INTC_ENR1f_SET BCM53128_A0_INTC_ENR1r_INTC_ENR1f_SET
#define READ_INTC_ENR1r BCM53128_A0_READ_INTC_ENR1r
#define WRITE_INTC_ENR1r BCM53128_A0_WRITE_INTC_ENR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_ENR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_ENR2
 * BLOCKS:   SYS
 * DESC:     Interrupt Enable Register 2 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_ENR2        Enable of the following interrupt requests:Bit 7:6: reservedBit 5: TX resource availableBit 4: Lack of TX resourceBit 3: TX ErrorBit 2: RX ErrorBit 1: TX finishBit 0: RX finish
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_ENR2r 0x0000ff16

#define BCM53128_A0_INTC_ENR2r_SIZE 1

/*
 * This structure should be used to declare and program INTC_ENR2.
 *
 */
typedef union BCM53128_A0_INTC_ENR2r_s {
	uint32_t v[1];
	uint32_t intc_enr2[1];
	uint32_t _intc_enr2;
} BCM53128_A0_INTC_ENR2r_t;

#define BCM53128_A0_INTC_ENR2r_CLR(r) (r).intc_enr2[0] = 0
#define BCM53128_A0_INTC_ENR2r_SET(r,d) (r).intc_enr2[0] = d
#define BCM53128_A0_INTC_ENR2r_GET(r) (r).intc_enr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_ENR2r_INTC_ENR2f_GET(r) (((r).intc_enr2[0]) & 0xff)
#define BCM53128_A0_INTC_ENR2r_INTC_ENR2f_SET(r,f) (r).intc_enr2[0]=(((r).intc_enr2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_ENR2.
 *
 */
#define BCM53128_A0_READ_INTC_ENR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_ENR2r,(r._intc_enr2),1)
#define BCM53128_A0_WRITE_INTC_ENR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_ENR2r,&(r._intc_enr2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_ENR2r BCM53128_A0_INTC_ENR2r
#define INTC_ENR2r_SIZE BCM53128_A0_INTC_ENR2r_SIZE
typedef BCM53128_A0_INTC_ENR2r_t INTC_ENR2r_t;
#define INTC_ENR2r_CLR BCM53128_A0_INTC_ENR2r_CLR
#define INTC_ENR2r_SET BCM53128_A0_INTC_ENR2r_SET
#define INTC_ENR2r_GET BCM53128_A0_INTC_ENR2r_GET
#define INTC_ENR2r_INTC_ENR2f_GET BCM53128_A0_INTC_ENR2r_INTC_ENR2f_GET
#define INTC_ENR2r_INTC_ENR2f_SET BCM53128_A0_INTC_ENR2r_INTC_ENR2f_SET
#define READ_INTC_ENR2r BCM53128_A0_READ_INTC_ENR2r
#define WRITE_INTC_ENR2r BCM53128_A0_WRITE_INTC_ENR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_ENR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_ENR3
 * BLOCKS:   SYS
 * DESC:     Interrupt Enable Register 3 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_ENR3        Enable of the following interrupt requests:Bit 7:3:reservedBit 2: DMA loopback endBit 1: DMA loopback startBit 0: Switch register access done
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_ENR3r 0x0000ff17

#define BCM53128_A0_INTC_ENR3r_SIZE 1

/*
 * This structure should be used to declare and program INTC_ENR3.
 *
 */
typedef union BCM53128_A0_INTC_ENR3r_s {
	uint32_t v[1];
	uint32_t intc_enr3[1];
	uint32_t _intc_enr3;
} BCM53128_A0_INTC_ENR3r_t;

#define BCM53128_A0_INTC_ENR3r_CLR(r) (r).intc_enr3[0] = 0
#define BCM53128_A0_INTC_ENR3r_SET(r,d) (r).intc_enr3[0] = d
#define BCM53128_A0_INTC_ENR3r_GET(r) (r).intc_enr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_ENR3r_INTC_ENR3f_GET(r) (((r).intc_enr3[0]) & 0xff)
#define BCM53128_A0_INTC_ENR3r_INTC_ENR3f_SET(r,f) (r).intc_enr3[0]=(((r).intc_enr3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_ENR3.
 *
 */
#define BCM53128_A0_READ_INTC_ENR3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_ENR3r,(r._intc_enr3),1)
#define BCM53128_A0_WRITE_INTC_ENR3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_ENR3r,&(r._intc_enr3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_ENR3r BCM53128_A0_INTC_ENR3r
#define INTC_ENR3r_SIZE BCM53128_A0_INTC_ENR3r_SIZE
typedef BCM53128_A0_INTC_ENR3r_t INTC_ENR3r_t;
#define INTC_ENR3r_CLR BCM53128_A0_INTC_ENR3r_CLR
#define INTC_ENR3r_SET BCM53128_A0_INTC_ENR3r_SET
#define INTC_ENR3r_GET BCM53128_A0_INTC_ENR3r_GET
#define INTC_ENR3r_INTC_ENR3f_GET BCM53128_A0_INTC_ENR3r_INTC_ENR3f_GET
#define INTC_ENR3r_INTC_ENR3f_SET BCM53128_A0_INTC_ENR3r_INTC_ENR3f_SET
#define READ_INTC_ENR3r BCM53128_A0_READ_INTC_ENR3r
#define WRITE_INTC_ENR3r BCM53128_A0_WRITE_INTC_ENR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_ENR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_ITR
 * BLOCKS:   SYS
 * DESC:     Interrupt Trigger Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_WPZE        Interrupt Trigger RegisterWriting 1 onto this bit causes an interrupt request to external CPUReading this bit returns 0.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_ITRr 0x0000ff18

#define BCM53128_A0_INTC_ITRr_SIZE 1

/*
 * This structure should be used to declare and program INTC_ITR.
 *
 */
typedef union BCM53128_A0_INTC_ITRr_s {
	uint32_t v[1];
	uint32_t intc_itr[1];
	uint32_t _intc_itr;
} BCM53128_A0_INTC_ITRr_t;

#define BCM53128_A0_INTC_ITRr_CLR(r) (r).intc_itr[0] = 0
#define BCM53128_A0_INTC_ITRr_SET(r,d) (r).intc_itr[0] = d
#define BCM53128_A0_INTC_ITRr_GET(r) (r).intc_itr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_ITRr_INTC_WPZEf_GET(r) (((r).intc_itr[0]) & 0x1)
#define BCM53128_A0_INTC_ITRr_INTC_WPZEf_SET(r,f) (r).intc_itr[0]=(((r).intc_itr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_INTC_ITRr_RESERVEDf_GET(r) ((((r).intc_itr[0]) >> 1) & 0x7f)
#define BCM53128_A0_INTC_ITRr_RESERVEDf_SET(r,f) (r).intc_itr[0]=(((r).intc_itr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access INTC_ITR.
 *
 */
#define BCM53128_A0_READ_INTC_ITRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_ITRr,(r._intc_itr),1)
#define BCM53128_A0_WRITE_INTC_ITRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_ITRr,&(r._intc_itr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_ITRr BCM53128_A0_INTC_ITRr
#define INTC_ITRr_SIZE BCM53128_A0_INTC_ITRr_SIZE
typedef BCM53128_A0_INTC_ITRr_t INTC_ITRr_t;
#define INTC_ITRr_CLR BCM53128_A0_INTC_ITRr_CLR
#define INTC_ITRr_SET BCM53128_A0_INTC_ITRr_SET
#define INTC_ITRr_GET BCM53128_A0_INTC_ITRr_GET
#define INTC_ITRr_INTC_WPZEf_GET BCM53128_A0_INTC_ITRr_INTC_WPZEf_GET
#define INTC_ITRr_INTC_WPZEf_SET BCM53128_A0_INTC_ITRr_INTC_WPZEf_SET
#define INTC_ITRr_RESERVEDf_GET BCM53128_A0_INTC_ITRr_RESERVEDf_GET
#define INTC_ITRr_RESERVEDf_SET BCM53128_A0_INTC_ITRr_RESERVEDf_SET
#define READ_INTC_ITRr BCM53128_A0_READ_INTC_ITRr
#define WRITE_INTC_ITRr BCM53128_A0_WRITE_INTC_ITRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_ITRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_STSR0
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register 0 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_STSR0       Writing 1 to specific bit clears the interrupt request.Bit 4-7: link status changes, port 0~port 3Bit 3: Resource grantBit 2: External CPU interrupt requestBit 1: WAN port wake upBit 0: IMP wake up
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_STSR0r 0x0000ff10

#define BCM53128_A0_INTC_STSR0r_SIZE 1

/*
 * This structure should be used to declare and program INTC_STSR0.
 *
 */
typedef union BCM53128_A0_INTC_STSR0r_s {
	uint32_t v[1];
	uint32_t intc_stsr0[1];
	uint32_t _intc_stsr0;
} BCM53128_A0_INTC_STSR0r_t;

#define BCM53128_A0_INTC_STSR0r_CLR(r) (r).intc_stsr0[0] = 0
#define BCM53128_A0_INTC_STSR0r_SET(r,d) (r).intc_stsr0[0] = d
#define BCM53128_A0_INTC_STSR0r_GET(r) (r).intc_stsr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_STSR0r_INTC_STSR0f_GET(r) (((r).intc_stsr0[0]) & 0xff)
#define BCM53128_A0_INTC_STSR0r_INTC_STSR0f_SET(r,f) (r).intc_stsr0[0]=(((r).intc_stsr0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_STSR0.
 *
 */
#define BCM53128_A0_READ_INTC_STSR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_STSR0r,(r._intc_stsr0),1)
#define BCM53128_A0_WRITE_INTC_STSR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_STSR0r,&(r._intc_stsr0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_STSR0r BCM53128_A0_INTC_STSR0r
#define INTC_STSR0r_SIZE BCM53128_A0_INTC_STSR0r_SIZE
typedef BCM53128_A0_INTC_STSR0r_t INTC_STSR0r_t;
#define INTC_STSR0r_CLR BCM53128_A0_INTC_STSR0r_CLR
#define INTC_STSR0r_SET BCM53128_A0_INTC_STSR0r_SET
#define INTC_STSR0r_GET BCM53128_A0_INTC_STSR0r_GET
#define INTC_STSR0r_INTC_STSR0f_GET BCM53128_A0_INTC_STSR0r_INTC_STSR0f_GET
#define INTC_STSR0r_INTC_STSR0f_SET BCM53128_A0_INTC_STSR0r_INTC_STSR0f_SET
#define READ_INTC_STSR0r BCM53128_A0_READ_INTC_STSR0r
#define WRITE_INTC_STSR0r BCM53128_A0_WRITE_INTC_STSR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_STSR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_STSR1
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register 1 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_STSR1       Bit 5-7: reservedBit 0-4: link status changes, port 4~port 8
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_STSR1r 0x0000ff11

#define BCM53128_A0_INTC_STSR1r_SIZE 1

/*
 * This structure should be used to declare and program INTC_STSR1.
 *
 */
typedef union BCM53128_A0_INTC_STSR1r_s {
	uint32_t v[1];
	uint32_t intc_stsr1[1];
	uint32_t _intc_stsr1;
} BCM53128_A0_INTC_STSR1r_t;

#define BCM53128_A0_INTC_STSR1r_CLR(r) (r).intc_stsr1[0] = 0
#define BCM53128_A0_INTC_STSR1r_SET(r,d) (r).intc_stsr1[0] = d
#define BCM53128_A0_INTC_STSR1r_GET(r) (r).intc_stsr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_STSR1r_INTC_STSR1f_GET(r) (((r).intc_stsr1[0]) & 0xff)
#define BCM53128_A0_INTC_STSR1r_INTC_STSR1f_SET(r,f) (r).intc_stsr1[0]=(((r).intc_stsr1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_STSR1.
 *
 */
#define BCM53128_A0_READ_INTC_STSR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_STSR1r,(r._intc_stsr1),1)
#define BCM53128_A0_WRITE_INTC_STSR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_STSR1r,&(r._intc_stsr1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_STSR1r BCM53128_A0_INTC_STSR1r
#define INTC_STSR1r_SIZE BCM53128_A0_INTC_STSR1r_SIZE
typedef BCM53128_A0_INTC_STSR1r_t INTC_STSR1r_t;
#define INTC_STSR1r_CLR BCM53128_A0_INTC_STSR1r_CLR
#define INTC_STSR1r_SET BCM53128_A0_INTC_STSR1r_SET
#define INTC_STSR1r_GET BCM53128_A0_INTC_STSR1r_GET
#define INTC_STSR1r_INTC_STSR1f_GET BCM53128_A0_INTC_STSR1r_INTC_STSR1f_GET
#define INTC_STSR1r_INTC_STSR1f_SET BCM53128_A0_INTC_STSR1r_INTC_STSR1f_SET
#define READ_INTC_STSR1r BCM53128_A0_READ_INTC_STSR1r
#define WRITE_INTC_STSR1r BCM53128_A0_WRITE_INTC_STSR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_STSR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_STSR2
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register 2 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_STSR2       Writing 1 to specific bit clears the interrupt request.Bit 7:6: reservedBit 5: TX resource availableBit 4: Lack of TX resourceBit 3: TX ErrorBit 2: RX ErrorBit 1: TX finishBit 0: RX finish
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_STSR2r 0x0000ff12

#define BCM53128_A0_INTC_STSR2r_SIZE 1

/*
 * This structure should be used to declare and program INTC_STSR2.
 *
 */
typedef union BCM53128_A0_INTC_STSR2r_s {
	uint32_t v[1];
	uint32_t intc_stsr2[1];
	uint32_t _intc_stsr2;
} BCM53128_A0_INTC_STSR2r_t;

#define BCM53128_A0_INTC_STSR2r_CLR(r) (r).intc_stsr2[0] = 0
#define BCM53128_A0_INTC_STSR2r_SET(r,d) (r).intc_stsr2[0] = d
#define BCM53128_A0_INTC_STSR2r_GET(r) (r).intc_stsr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_STSR2r_INTC_STSR2f_GET(r) (((r).intc_stsr2[0]) & 0xff)
#define BCM53128_A0_INTC_STSR2r_INTC_STSR2f_SET(r,f) (r).intc_stsr2[0]=(((r).intc_stsr2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_STSR2.
 *
 */
#define BCM53128_A0_READ_INTC_STSR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_STSR2r,(r._intc_stsr2),1)
#define BCM53128_A0_WRITE_INTC_STSR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_STSR2r,&(r._intc_stsr2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_STSR2r BCM53128_A0_INTC_STSR2r
#define INTC_STSR2r_SIZE BCM53128_A0_INTC_STSR2r_SIZE
typedef BCM53128_A0_INTC_STSR2r_t INTC_STSR2r_t;
#define INTC_STSR2r_CLR BCM53128_A0_INTC_STSR2r_CLR
#define INTC_STSR2r_SET BCM53128_A0_INTC_STSR2r_SET
#define INTC_STSR2r_GET BCM53128_A0_INTC_STSR2r_GET
#define INTC_STSR2r_INTC_STSR2f_GET BCM53128_A0_INTC_STSR2r_INTC_STSR2f_GET
#define INTC_STSR2r_INTC_STSR2f_SET BCM53128_A0_INTC_STSR2r_INTC_STSR2f_SET
#define READ_INTC_STSR2r BCM53128_A0_READ_INTC_STSR2r
#define WRITE_INTC_STSR2r BCM53128_A0_WRITE_INTC_STSR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_STSR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTC_STSR3
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register 3 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     INTC_STSR3       Writing 1 to specific bit clears the interrupt request.Bit 7:3:reservedBit 2: DMA loopback endBit 1: DMA loopback startBit 0: Switch register access done
 *
 ******************************************************************************/
#define BCM53128_A0_INTC_STSR3r 0x0000ff13

#define BCM53128_A0_INTC_STSR3r_SIZE 1

/*
 * This structure should be used to declare and program INTC_STSR3.
 *
 */
typedef union BCM53128_A0_INTC_STSR3r_s {
	uint32_t v[1];
	uint32_t intc_stsr3[1];
	uint32_t _intc_stsr3;
} BCM53128_A0_INTC_STSR3r_t;

#define BCM53128_A0_INTC_STSR3r_CLR(r) (r).intc_stsr3[0] = 0
#define BCM53128_A0_INTC_STSR3r_SET(r,d) (r).intc_stsr3[0] = d
#define BCM53128_A0_INTC_STSR3r_GET(r) (r).intc_stsr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTC_STSR3r_INTC_STSR3f_GET(r) (((r).intc_stsr3[0]) & 0xff)
#define BCM53128_A0_INTC_STSR3r_INTC_STSR3f_SET(r,f) (r).intc_stsr3[0]=(((r).intc_stsr3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access INTC_STSR3.
 *
 */
#define BCM53128_A0_READ_INTC_STSR3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTC_STSR3r,(r._intc_stsr3),1)
#define BCM53128_A0_WRITE_INTC_STSR3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTC_STSR3r,&(r._intc_stsr3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTC_STSR3r BCM53128_A0_INTC_STSR3r
#define INTC_STSR3r_SIZE BCM53128_A0_INTC_STSR3r_SIZE
typedef BCM53128_A0_INTC_STSR3r_t INTC_STSR3r_t;
#define INTC_STSR3r_CLR BCM53128_A0_INTC_STSR3r_CLR
#define INTC_STSR3r_SET BCM53128_A0_INTC_STSR3r_SET
#define INTC_STSR3r_GET BCM53128_A0_INTC_STSR3r_GET
#define INTC_STSR3r_INTC_STSR3f_GET BCM53128_A0_INTC_STSR3r_INTC_STSR3f_GET
#define INTC_STSR3r_INTC_STSR3f_SET BCM53128_A0_INTC_STSR3r_INTC_STSR3f_SET
#define READ_INTC_STSR3r BCM53128_A0_READ_INTC_STSR3r
#define WRITE_INTC_STSR3r BCM53128_A0_WRITE_INTC_STSR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTC_STSR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INTERNAL_CPU_DEBUG
 * BLOCKS:   SYS
 * DESC:     Internal CPU Debug Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     FORCECLKON       Force 8051 cpu subsytem clocks toggling regardless of strapping-pin setting.1'b1: force clocks toggling in 8051 cpu subsystem.1'b0: clock gating is controlled by strapping pins and 8051 power saving mode.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_INTERNAL_CPU_DEBUGr 0x00000096

#define BCM53128_A0_INTERNAL_CPU_DEBUGr_SIZE 1

/*
 * This structure should be used to declare and program INTERNAL_CPU_DEBUG.
 *
 */
typedef union BCM53128_A0_INTERNAL_CPU_DEBUGr_s {
	uint32_t v[1];
	uint32_t internal_cpu_debug[1];
	uint32_t _internal_cpu_debug;
} BCM53128_A0_INTERNAL_CPU_DEBUGr_t;

#define BCM53128_A0_INTERNAL_CPU_DEBUGr_CLR(r) (r).internal_cpu_debug[0] = 0
#define BCM53128_A0_INTERNAL_CPU_DEBUGr_SET(r,d) (r).internal_cpu_debug[0] = d
#define BCM53128_A0_INTERNAL_CPU_DEBUGr_GET(r) (r).internal_cpu_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INTERNAL_CPU_DEBUGr_FORCECLKONf_GET(r) (((r).internal_cpu_debug[0]) & 0x1)
#define BCM53128_A0_INTERNAL_CPU_DEBUGr_FORCECLKONf_SET(r,f) (r).internal_cpu_debug[0]=(((r).internal_cpu_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_INTERNAL_CPU_DEBUGr_RESERVEDf_GET(r) ((((r).internal_cpu_debug[0]) >> 1) & 0x7f)
#define BCM53128_A0_INTERNAL_CPU_DEBUGr_RESERVEDf_SET(r,f) (r).internal_cpu_debug[0]=(((r).internal_cpu_debug[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access INTERNAL_CPU_DEBUG.
 *
 */
#define BCM53128_A0_READ_INTERNAL_CPU_DEBUGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_INTERNAL_CPU_DEBUGr,(r._internal_cpu_debug),1)
#define BCM53128_A0_WRITE_INTERNAL_CPU_DEBUGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_INTERNAL_CPU_DEBUGr,&(r._internal_cpu_debug),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTERNAL_CPU_DEBUGr BCM53128_A0_INTERNAL_CPU_DEBUGr
#define INTERNAL_CPU_DEBUGr_SIZE BCM53128_A0_INTERNAL_CPU_DEBUGr_SIZE
typedef BCM53128_A0_INTERNAL_CPU_DEBUGr_t INTERNAL_CPU_DEBUGr_t;
#define INTERNAL_CPU_DEBUGr_CLR BCM53128_A0_INTERNAL_CPU_DEBUGr_CLR
#define INTERNAL_CPU_DEBUGr_SET BCM53128_A0_INTERNAL_CPU_DEBUGr_SET
#define INTERNAL_CPU_DEBUGr_GET BCM53128_A0_INTERNAL_CPU_DEBUGr_GET
#define INTERNAL_CPU_DEBUGr_FORCECLKONf_GET BCM53128_A0_INTERNAL_CPU_DEBUGr_FORCECLKONf_GET
#define INTERNAL_CPU_DEBUGr_FORCECLKONf_SET BCM53128_A0_INTERNAL_CPU_DEBUGr_FORCECLKONf_SET
#define INTERNAL_CPU_DEBUGr_RESERVEDf_GET BCM53128_A0_INTERNAL_CPU_DEBUGr_RESERVEDf_GET
#define INTERNAL_CPU_DEBUGr_RESERVEDf_SET BCM53128_A0_INTERNAL_CPU_DEBUGr_RESERVEDf_SET
#define READ_INTERNAL_CPU_DEBUGr BCM53128_A0_READ_INTERNAL_CPU_DEBUGr
#define WRITE_INTERNAL_CPU_DEBUGr BCM53128_A0_WRITE_INTERNAL_CPU_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INTERNAL_CPU_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  INT_8051_RAM
 * BLOCKS:   SYS
 * DESC:     Internal 8051 RAM Table
 * SIZE:     64
 * FIELDS:
 *     RAM_DATA         RAM data entry
 *
 ******************************************************************************/
#define BCM53128_A0_INT_8051_RAMm 0x00004000

#define BCM53128_A0_INT_8051_RAMm_MIN 0
#define BCM53128_A0_INT_8051_RAMm_MAX 8191
#define BCM53128_A0_INT_8051_RAMm_CMAX(u) 8191
#define BCM53128_A0_INT_8051_RAMm_SIZE 8

/*
 * This structure should be used to declare and program INT_8051_RAM.
 *
 */
typedef union BCM53128_A0_INT_8051_RAMm_s {
	uint32_t v[2];
	uint32_t int_8051_ram[2];
	uint32_t _int_8051_ram;
} BCM53128_A0_INT_8051_RAMm_t;

#define BCM53128_A0_INT_8051_RAMm_CLR(r) CDK_MEMSET(&((r)._int_8051_ram), 0, sizeof(BCM53128_A0_INT_8051_RAMm_t))
#define BCM53128_A0_INT_8051_RAMm_SET(r,i,d) (r).int_8051_ram[i] = d
#define BCM53128_A0_INT_8051_RAMm_GET(r,i) (r).int_8051_ram[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INT_8051_RAMm_RAM_DATAf_GET(r,a) cdk_field_get((r).int_8051_ram,0,63,a)
#define BCM53128_A0_INT_8051_RAMm_RAM_DATAf_SET(r,a) cdk_field_set((r).int_8051_ram,0,63,a)

/*
 * These macros can be used to access INT_8051_RAM.
 *
 */
#define BCM53128_A0_READ_INT_8051_RAMm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_INT_8051_RAMm,i,(m),8)
#define BCM53128_A0_WRITE_INT_8051_RAMm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_INT_8051_RAMm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_8051_RAMm BCM53128_A0_INT_8051_RAMm
#define INT_8051_RAMm_MIN BCM53128_A0_INT_8051_RAMm_MIN
#define INT_8051_RAMm_MAX BCM53128_A0_INT_8051_RAMm_MAX
#define INT_8051_RAMm_CMAX(u) BCM53128_A0_INT_8051_RAMm_CMAX(u)
#define INT_8051_RAMm_SIZE BCM53128_A0_INT_8051_RAMm_SIZE
typedef BCM53128_A0_INT_8051_RAMm_t INT_8051_RAMm_t;
#define INT_8051_RAMm_CLR BCM53128_A0_INT_8051_RAMm_CLR
#define INT_8051_RAMm_SET BCM53128_A0_INT_8051_RAMm_SET
#define INT_8051_RAMm_GET BCM53128_A0_INT_8051_RAMm_GET
#define INT_8051_RAMm_RAM_DATAf_GET BCM53128_A0_INT_8051_RAMm_RAM_DATAf_GET
#define INT_8051_RAMm_RAM_DATAf_SET BCM53128_A0_INT_8051_RAMm_RAM_DATAf_SET
#define READ_INT_8051_RAMm BCM53128_A0_READ_INT_8051_RAMm
#define WRITE_INT_8051_RAMm BCM53128_A0_WRITE_INT_8051_RAMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INT_8051_RAMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  INT_8051_ROM
 * BLOCKS:   SYS
 * DESC:     Internal 8051 ROM Table
 * SIZE:     64
 * FIELDS:
 *     ROM_DATA         ROM data entry
 *
 ******************************************************************************/
#define BCM53128_A0_INT_8051_ROMm 0x00006000

#define BCM53128_A0_INT_8051_ROMm_MIN 0
#define BCM53128_A0_INT_8051_ROMm_MAX 8191
#define BCM53128_A0_INT_8051_ROMm_CMAX(u) 8191
#define BCM53128_A0_INT_8051_ROMm_SIZE 8

/*
 * This structure should be used to declare and program INT_8051_ROM.
 *
 */
typedef union BCM53128_A0_INT_8051_ROMm_s {
	uint32_t v[2];
	uint32_t int_8051_rom[2];
	uint32_t _int_8051_rom;
} BCM53128_A0_INT_8051_ROMm_t;

#define BCM53128_A0_INT_8051_ROMm_CLR(r) CDK_MEMSET(&((r)._int_8051_rom), 0, sizeof(BCM53128_A0_INT_8051_ROMm_t))
#define BCM53128_A0_INT_8051_ROMm_SET(r,i,d) (r).int_8051_rom[i] = d
#define BCM53128_A0_INT_8051_ROMm_GET(r,i) (r).int_8051_rom[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INT_8051_ROMm_ROM_DATAf_GET(r,a) cdk_field_get((r).int_8051_rom,0,63,a)
#define BCM53128_A0_INT_8051_ROMm_ROM_DATAf_SET(r,a) cdk_field_set((r).int_8051_rom,0,63,a)

/*
 * These macros can be used to access INT_8051_ROM.
 *
 */
#define BCM53128_A0_READ_INT_8051_ROMm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_INT_8051_ROMm,i,(m),8)
#define BCM53128_A0_WRITE_INT_8051_ROMm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_INT_8051_ROMm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_8051_ROMm BCM53128_A0_INT_8051_ROMm
#define INT_8051_ROMm_MIN BCM53128_A0_INT_8051_ROMm_MIN
#define INT_8051_ROMm_MAX BCM53128_A0_INT_8051_ROMm_MAX
#define INT_8051_ROMm_CMAX(u) BCM53128_A0_INT_8051_ROMm_CMAX(u)
#define INT_8051_ROMm_SIZE BCM53128_A0_INT_8051_ROMm_SIZE
typedef BCM53128_A0_INT_8051_ROMm_t INT_8051_ROMm_t;
#define INT_8051_ROMm_CLR BCM53128_A0_INT_8051_ROMm_CLR
#define INT_8051_ROMm_SET BCM53128_A0_INT_8051_ROMm_SET
#define INT_8051_ROMm_GET BCM53128_A0_INT_8051_ROMm_GET
#define INT_8051_ROMm_ROM_DATAf_GET BCM53128_A0_INT_8051_ROMm_ROM_DATAf_GET
#define INT_8051_ROMm_ROM_DATAf_SET BCM53128_A0_INT_8051_ROMm_ROM_DATAf_SET
#define READ_INT_8051_ROMm BCM53128_A0_READ_INT_8051_ROMm
#define WRITE_INT_8051_ROMm BCM53128_A0_WRITE_INT_8051_ROMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INT_8051_ROMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INT_EN
 * BLOCKS:   SYS
 * DESC:     Interrupt Enable Register
 * SIZE:     32
 * FIELDS:
 *     INT_EN           Interrupt Enable Register.To control individual interrupt enable bits for each interrupt type1 = enable0 = disableBit 31:25 - ReservedBit 24:16 - linkStatusChangeEnable[8:0].9 bit field indicating that the link status change interrupt is enable or not.-Bits 23-16 = port 7- port 0-Bit 24 = IMP port(port 8)Bits 15:9 - ReservedBit 8 - arbiter GNT interrupt1 bit field indicating arbiter grant interrupt is enable or not.Bits 7:3 - ReservedBit 2 - CPU Semaphore interrupt1 bit field indicating internal CPU trigger an interrupt to external CPU is enable or not.Bit 1:0 - impSleepTimerRunningEnable[1:0]2 bit field indicating that IMP sleep interrupt is enable or not.-Bit 1 = port 7-Bit 0 = IMP port(port 8)
 *
 ******************************************************************************/
#define BCM53128_A0_INT_ENr 0x00000308

#define BCM53128_A0_INT_ENr_SIZE 4

/*
 * This structure should be used to declare and program INT_EN.
 *
 */
typedef union BCM53128_A0_INT_ENr_s {
	uint32_t v[1];
	uint32_t int_en[1];
	uint32_t _int_en;
} BCM53128_A0_INT_ENr_t;

#define BCM53128_A0_INT_ENr_CLR(r) (r).int_en[0] = 0
#define BCM53128_A0_INT_ENr_SET(r,d) (r).int_en[0] = d
#define BCM53128_A0_INT_ENr_GET(r) (r).int_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INT_ENr_INT_ENf_GET(r) ((r).int_en[0])
#define BCM53128_A0_INT_ENr_INT_ENf_SET(r,f) (r).int_en[0]=((uint32_t)f)

/*
 * These macros can be used to access INT_EN.
 *
 */
#define BCM53128_A0_READ_INT_ENr(u,r) cdk_robo_reg_read(u,BCM53128_A0_INT_ENr,(r._int_en),4)
#define BCM53128_A0_WRITE_INT_ENr(u,r) cdk_robo_reg_write(u,BCM53128_A0_INT_ENr,&(r._int_en),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_ENr BCM53128_A0_INT_ENr
#define INT_ENr_SIZE BCM53128_A0_INT_ENr_SIZE
typedef BCM53128_A0_INT_ENr_t INT_ENr_t;
#define INT_ENr_CLR BCM53128_A0_INT_ENr_CLR
#define INT_ENr_SET BCM53128_A0_INT_ENr_SET
#define INT_ENr_GET BCM53128_A0_INT_ENr_GET
#define INT_ENr_INT_ENf_GET BCM53128_A0_INT_ENr_INT_ENf_GET
#define INT_ENr_INT_ENf_SET BCM53128_A0_INT_ENr_INT_ENf_SET
#define READ_INT_ENr BCM53128_A0_READ_INT_ENr
#define WRITE_INT_ENr BCM53128_A0_WRITE_INT_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INT_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INT_STS
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     INT_STS          Interrupt Status Register.Interrupt Status bits to indicate the cause of the interrupt.1= to indicate which interrupt is triggered.CPU write a "1" to the interrupt status register to reset the cause of the interrupt and reset the corresponding interrupt status bit.Bit 31:25 - ReservedBit 24:16 - linkStatusChangeInterrupt[8:0].9 bit field indicating that the its link status has changed.-Bits 23-16 = port 7- port 0-Bit 24 = IMP port(port 8)Bits 15:9 - ReservedBit 8 - arbiter GNT interrupt1 bit field indicating resource arbiter grant interrupt when catch the rising edge of the external CPU GNT signal.Bit 7:3 - ReservedBit 2 - CPU Semaphore interrupt1 bit field indicating internal CPU trigger an interrupt to external CPU.Bit 1:0 - impSleepTimerRunningInterrupt[1:0]2 bit field indicating which of the timers has been triggered.-Bit 1 = port 7-Bit 0 = IMP port(port 8)
 *
 ******************************************************************************/
#define BCM53128_A0_INT_STSr 0x00000300

#define BCM53128_A0_INT_STSr_SIZE 4

/*
 * This structure should be used to declare and program INT_STS.
 *
 */
typedef union BCM53128_A0_INT_STSr_s {
	uint32_t v[1];
	uint32_t int_sts[1];
	uint32_t _int_sts;
} BCM53128_A0_INT_STSr_t;

#define BCM53128_A0_INT_STSr_CLR(r) (r).int_sts[0] = 0
#define BCM53128_A0_INT_STSr_SET(r,d) (r).int_sts[0] = d
#define BCM53128_A0_INT_STSr_GET(r) (r).int_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INT_STSr_INT_STSf_GET(r) ((r).int_sts[0])
#define BCM53128_A0_INT_STSr_INT_STSf_SET(r,f) (r).int_sts[0]=((uint32_t)f)

/*
 * These macros can be used to access INT_STS.
 *
 */
#define BCM53128_A0_READ_INT_STSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_INT_STSr,(r._int_sts),4)
#define BCM53128_A0_WRITE_INT_STSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_INT_STSr,&(r._int_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_STSr BCM53128_A0_INT_STSr
#define INT_STSr_SIZE BCM53128_A0_INT_STSr_SIZE
typedef BCM53128_A0_INT_STSr_t INT_STSr_t;
#define INT_STSr_CLR BCM53128_A0_INT_STSr_CLR
#define INT_STSr_SET BCM53128_A0_INT_STSr_SET
#define INT_STSr_GET BCM53128_A0_INT_STSr_GET
#define INT_STSr_INT_STSf_GET BCM53128_A0_INT_STSr_INT_STSf_GET
#define INT_STSr_INT_STSf_SET BCM53128_A0_INT_STSr_INT_STSf_SET
#define READ_INT_STSr BCM53128_A0_READ_INT_STSr
#define WRITE_INT_STSr BCM53128_A0_WRITE_INT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  INT_TRIGGER
 * BLOCKS:   SYS
 * DESC:     Interrupt Trigger Register
 * SIZE:     8
 * FIELDS:
 *     EXT_CPU_INT      external-to-internal CPU Semaphore interrupt.When the bit is set to 1, external CPU trigger an interrupt to internal CPU.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_INT_TRIGGERr 0x00000320

#define BCM53128_A0_INT_TRIGGERr_SIZE 1

/*
 * This structure should be used to declare and program INT_TRIGGER.
 *
 */
typedef union BCM53128_A0_INT_TRIGGERr_s {
	uint32_t v[1];
	uint32_t int_trigger[1];
	uint32_t _int_trigger;
} BCM53128_A0_INT_TRIGGERr_t;

#define BCM53128_A0_INT_TRIGGERr_CLR(r) (r).int_trigger[0] = 0
#define BCM53128_A0_INT_TRIGGERr_SET(r,d) (r).int_trigger[0] = d
#define BCM53128_A0_INT_TRIGGERr_GET(r) (r).int_trigger[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_INT_TRIGGERr_EXT_CPU_INTf_GET(r) (((r).int_trigger[0]) & 0x1)
#define BCM53128_A0_INT_TRIGGERr_EXT_CPU_INTf_SET(r,f) (r).int_trigger[0]=(((r).int_trigger[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_INT_TRIGGERr_RESERVEDf_GET(r) ((((r).int_trigger[0]) >> 1) & 0x7f)
#define BCM53128_A0_INT_TRIGGERr_RESERVEDf_SET(r,f) (r).int_trigger[0]=(((r).int_trigger[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access INT_TRIGGER.
 *
 */
#define BCM53128_A0_READ_INT_TRIGGERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_INT_TRIGGERr,(r._int_trigger),1)
#define BCM53128_A0_WRITE_INT_TRIGGERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_INT_TRIGGERr,&(r._int_trigger),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_TRIGGERr BCM53128_A0_INT_TRIGGERr
#define INT_TRIGGERr_SIZE BCM53128_A0_INT_TRIGGERr_SIZE
typedef BCM53128_A0_INT_TRIGGERr_t INT_TRIGGERr_t;
#define INT_TRIGGERr_CLR BCM53128_A0_INT_TRIGGERr_CLR
#define INT_TRIGGERr_SET BCM53128_A0_INT_TRIGGERr_SET
#define INT_TRIGGERr_GET BCM53128_A0_INT_TRIGGERr_GET
#define INT_TRIGGERr_EXT_CPU_INTf_GET BCM53128_A0_INT_TRIGGERr_EXT_CPU_INTf_GET
#define INT_TRIGGERr_EXT_CPU_INTf_SET BCM53128_A0_INT_TRIGGERr_EXT_CPU_INTf_SET
#define INT_TRIGGERr_RESERVEDf_GET BCM53128_A0_INT_TRIGGERr_RESERVEDf_GET
#define INT_TRIGGERr_RESERVEDf_SET BCM53128_A0_INT_TRIGGERr_RESERVEDf_SET
#define READ_INT_TRIGGERr BCM53128_A0_READ_INT_TRIGGERr
#define WRITE_INT_TRIGGERr BCM53128_A0_WRITE_INT_TRIGGERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INT_TRIGGERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IN_CPU_CTRL
 * BLOCKS:   SYS
 * DESC:     Internal CPU Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     IN_RAM_CODE_SIZE Internal CPU RAM code size. Unit: K-byte.To indicate the code size of the internal CPU RAM. Program address is starting from RAM address 0. Data address is starting from RAM address of this register.(Not2Release).
 *     IN_CPU_CODE_SEL  Internal CPU RAM/ROM code selection.0= When reset, internal CPU start running from ROM address 0.1= When reset, internal CPU start running from RAM address 0.(Not2Release).
 *     IN_CPU_RST       Internal CPU (8051) reset.Write "1" to active an internal CPU reset, internal CPU stop running.Write "0" to clear the reset state, internal CPU start running.(Not2Release).
 *
 ******************************************************************************/
#define BCM53128_A0_IN_CPU_CTRLr 0x00000090

#define BCM53128_A0_IN_CPU_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program IN_CPU_CTRL.
 *
 */
typedef union BCM53128_A0_IN_CPU_CTRLr_s {
	uint32_t v[1];
	uint32_t in_cpu_ctrl[1];
	uint32_t _in_cpu_ctrl;
} BCM53128_A0_IN_CPU_CTRLr_t;

#define BCM53128_A0_IN_CPU_CTRLr_CLR(r) (r).in_cpu_ctrl[0] = 0
#define BCM53128_A0_IN_CPU_CTRLr_SET(r,d) (r).in_cpu_ctrl[0] = d
#define BCM53128_A0_IN_CPU_CTRLr_GET(r) (r).in_cpu_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IN_CPU_CTRLr_IN_RAM_CODE_SIZEf_GET(r) (((r).in_cpu_ctrl[0]) & 0x3f)
#define BCM53128_A0_IN_CPU_CTRLr_IN_RAM_CODE_SIZEf_SET(r,f) (r).in_cpu_ctrl[0]=(((r).in_cpu_ctrl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53128_A0_IN_CPU_CTRLr_IN_CPU_CODE_SELf_GET(r) ((((r).in_cpu_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_IN_CPU_CTRLr_IN_CPU_CODE_SELf_SET(r,f) (r).in_cpu_ctrl[0]=(((r).in_cpu_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_IN_CPU_CTRLr_IN_CPU_RSTf_GET(r) ((((r).in_cpu_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_IN_CPU_CTRLr_IN_CPU_RSTf_SET(r,f) (r).in_cpu_ctrl[0]=(((r).in_cpu_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access IN_CPU_CTRL.
 *
 */
#define BCM53128_A0_READ_IN_CPU_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IN_CPU_CTRLr,(r._in_cpu_ctrl),1)
#define BCM53128_A0_WRITE_IN_CPU_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IN_CPU_CTRLr,&(r._in_cpu_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IN_CPU_CTRLr BCM53128_A0_IN_CPU_CTRLr
#define IN_CPU_CTRLr_SIZE BCM53128_A0_IN_CPU_CTRLr_SIZE
typedef BCM53128_A0_IN_CPU_CTRLr_t IN_CPU_CTRLr_t;
#define IN_CPU_CTRLr_CLR BCM53128_A0_IN_CPU_CTRLr_CLR
#define IN_CPU_CTRLr_SET BCM53128_A0_IN_CPU_CTRLr_SET
#define IN_CPU_CTRLr_GET BCM53128_A0_IN_CPU_CTRLr_GET
#define IN_CPU_CTRLr_IN_RAM_CODE_SIZEf_GET BCM53128_A0_IN_CPU_CTRLr_IN_RAM_CODE_SIZEf_GET
#define IN_CPU_CTRLr_IN_RAM_CODE_SIZEf_SET BCM53128_A0_IN_CPU_CTRLr_IN_RAM_CODE_SIZEf_SET
#define IN_CPU_CTRLr_IN_CPU_CODE_SELf_GET BCM53128_A0_IN_CPU_CTRLr_IN_CPU_CODE_SELf_GET
#define IN_CPU_CTRLr_IN_CPU_CODE_SELf_SET BCM53128_A0_IN_CPU_CTRLr_IN_CPU_CODE_SELf_SET
#define IN_CPU_CTRLr_IN_CPU_RSTf_GET BCM53128_A0_IN_CPU_CTRLr_IN_CPU_RSTf_GET
#define IN_CPU_CTRLr_IN_CPU_RSTf_SET BCM53128_A0_IN_CPU_CTRLr_IN_CPU_RSTf_SET
#define READ_IN_CPU_CTRLr BCM53128_A0_READ_IN_CPU_CTRLr
#define WRITE_IN_CPU_CTRLr BCM53128_A0_WRITE_IN_CPU_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IN_CPU_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  IPG_SHRNK_CTRL
 * BLOCKS:   SYS
 * DESC:     IPG Shrink Control Register
 * SIZE:     32
 * FIELDS:
 *     IPG_SHKCTRL      IPG Shrink ControlThis field specifies the IPG for each port.IPG shrinking at Egress.00: No IPG shrinking(default)01: IPG shrinking of 1-byte10: IPG shrinking of 4-byte11: IPG shrinking of 5-bytebit[17:16] = Port 8(IMP port)bit[15:0] = Port 7 ~ Port 0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_IPG_SHRNK_CTRLr 0x0000020c

#define BCM53128_A0_IPG_SHRNK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program IPG_SHRNK_CTRL.
 *
 */
typedef union BCM53128_A0_IPG_SHRNK_CTRLr_s {
	uint32_t v[1];
	uint32_t ipg_shrnk_ctrl[1];
	uint32_t _ipg_shrnk_ctrl;
} BCM53128_A0_IPG_SHRNK_CTRLr_t;

#define BCM53128_A0_IPG_SHRNK_CTRLr_CLR(r) (r).ipg_shrnk_ctrl[0] = 0
#define BCM53128_A0_IPG_SHRNK_CTRLr_SET(r,d) (r).ipg_shrnk_ctrl[0] = d
#define BCM53128_A0_IPG_SHRNK_CTRLr_GET(r) (r).ipg_shrnk_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET(r) (((r).ipg_shrnk_ctrl[0]) & 0x3ffff)
#define BCM53128_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53128_A0_IPG_SHRNK_CTRLr_RESERVEDf_GET(r) ((((r).ipg_shrnk_ctrl[0]) >> 18) & 0x3fff)
#define BCM53128_A0_IPG_SHRNK_CTRLr_RESERVEDf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IPG_SHRNK_CTRL.
 *
 */
#define BCM53128_A0_READ_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_IPG_SHRNK_CTRLr,(r._ipg_shrnk_ctrl),4)
#define BCM53128_A0_WRITE_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_IPG_SHRNK_CTRLr,&(r._ipg_shrnk_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPG_SHRNK_CTRLr BCM53128_A0_IPG_SHRNK_CTRLr
#define IPG_SHRNK_CTRLr_SIZE BCM53128_A0_IPG_SHRNK_CTRLr_SIZE
typedef BCM53128_A0_IPG_SHRNK_CTRLr_t IPG_SHRNK_CTRLr_t;
#define IPG_SHRNK_CTRLr_CLR BCM53128_A0_IPG_SHRNK_CTRLr_CLR
#define IPG_SHRNK_CTRLr_SET BCM53128_A0_IPG_SHRNK_CTRLr_SET
#define IPG_SHRNK_CTRLr_GET BCM53128_A0_IPG_SHRNK_CTRLr_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET BCM53128_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET BCM53128_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET
#define IPG_SHRNK_CTRLr_RESERVEDf_GET BCM53128_A0_IPG_SHRNK_CTRLr_RESERVEDf_GET
#define IPG_SHRNK_CTRLr_RESERVEDf_SET BCM53128_A0_IPG_SHRNK_CTRLr_RESERVEDf_SET
#define READ_IPG_SHRNK_CTRLr BCM53128_A0_READ_IPG_SHRNK_CTRLr
#define WRITE_IPG_SHRNK_CTRLr BCM53128_A0_WRITE_IPG_SHRNK_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_IPG_SHRNK_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ISP_SEL_PORTMAP
 * BLOCKS:   SYS
 * DESC:     ISP Port Selection Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_PORTMAP      Bittmap to define which port as ISP-port.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_ISP_SEL_PORTMAPr 0x00003432

#define BCM53128_A0_ISP_SEL_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program ISP_SEL_PORTMAP.
 *
 */
typedef union BCM53128_A0_ISP_SEL_PORTMAPr_s {
	uint32_t v[1];
	uint32_t isp_sel_portmap[1];
	uint32_t _isp_sel_portmap;
} BCM53128_A0_ISP_SEL_PORTMAPr_t;

#define BCM53128_A0_ISP_SEL_PORTMAPr_CLR(r) (r).isp_sel_portmap[0] = 0
#define BCM53128_A0_ISP_SEL_PORTMAPr_SET(r,d) (r).isp_sel_portmap[0] = d
#define BCM53128_A0_ISP_SEL_PORTMAPr_GET(r) (r).isp_sel_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET(r) (((r).isp_sel_portmap[0]) & 0x1ff)
#define BCM53128_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET(r) ((((r).isp_sel_portmap[0]) >> 9) & 0x7f)
#define BCM53128_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ISP_SEL_PORTMAP.
 *
 */
#define BCM53128_A0_READ_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ISP_SEL_PORTMAPr,(r._isp_sel_portmap),2)
#define BCM53128_A0_WRITE_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ISP_SEL_PORTMAPr,&(r._isp_sel_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_SEL_PORTMAPr BCM53128_A0_ISP_SEL_PORTMAPr
#define ISP_SEL_PORTMAPr_SIZE BCM53128_A0_ISP_SEL_PORTMAPr_SIZE
typedef BCM53128_A0_ISP_SEL_PORTMAPr_t ISP_SEL_PORTMAPr_t;
#define ISP_SEL_PORTMAPr_CLR BCM53128_A0_ISP_SEL_PORTMAPr_CLR
#define ISP_SEL_PORTMAPr_SET BCM53128_A0_ISP_SEL_PORTMAPr_SET
#define ISP_SEL_PORTMAPr_GET BCM53128_A0_ISP_SEL_PORTMAPr_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET BCM53128_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET BCM53128_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET
#define ISP_SEL_PORTMAPr_RESERVEDf_GET BCM53128_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET
#define ISP_SEL_PORTMAPr_RESERVEDf_SET BCM53128_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET
#define READ_ISP_SEL_PORTMAPr BCM53128_A0_READ_ISP_SEL_PORTMAPr
#define WRITE_ISP_SEL_PORTMAPr BCM53128_A0_WRITE_ISP_SEL_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ISP_SEL_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  InRangeErrCount
 * BLOCKS:   GPIC0 CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_INRANGEERRCOUNTr 0x000020b0

#define BCM53128_A0_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount.
 *
 */
typedef union BCM53128_A0_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount[1];
	uint32_t _inrangeerrcount;
} BCM53128_A0_INRANGEERRCOUNTr_t;

#define BCM53128_A0_INRANGEERRCOUNTr_CLR(r) (r).inrangeerrcount[0] = 0
#define BCM53128_A0_INRANGEERRCOUNTr_SET(r,d) (r).inrangeerrcount[0] = d
#define BCM53128_A0_INRANGEERRCOUNTr_GET(r) (r).inrangeerrcount[0]


/*
 * These macros can be used to access InRangeErrCount.
 *
 */
#define BCM53128_A0_READ_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_INRANGEERRCOUNTr,(r._inrangeerrcount),4)
#define BCM53128_A0_WRITE_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_INRANGEERRCOUNTr,&(r._inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNTr BCM53128_A0_INRANGEERRCOUNTr
#define INRANGEERRCOUNTr_SIZE BCM53128_A0_INRANGEERRCOUNTr_SIZE
typedef BCM53128_A0_INRANGEERRCOUNTr_t INRANGEERRCOUNTr_t;
#define INRANGEERRCOUNTr_CLR BCM53128_A0_INRANGEERRCOUNTr_CLR
#define INRANGEERRCOUNTr_SET BCM53128_A0_INRANGEERRCOUNTr_SET
#define INRANGEERRCOUNTr_GET BCM53128_A0_INRANGEERRCOUNTr_GET
#define READ_INRANGEERRCOUNTr BCM53128_A0_READ_INRANGEERRCOUNTr
#define WRITE_INRANGEERRCOUNTr BCM53128_A0_WRITE_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  InRangeErrCount_IMP
 * BLOCKS:   CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_INRANGEERRCOUNT_IMPr 0x000028b0

#define BCM53128_A0_INRANGEERRCOUNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount_IMP.
 *
 */
typedef union BCM53128_A0_INRANGEERRCOUNT_IMPr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount_imp[1];
	uint32_t _inrangeerrcount_imp;
} BCM53128_A0_INRANGEERRCOUNT_IMPr_t;

#define BCM53128_A0_INRANGEERRCOUNT_IMPr_CLR(r) (r).inrangeerrcount_imp[0] = 0
#define BCM53128_A0_INRANGEERRCOUNT_IMPr_SET(r,d) (r).inrangeerrcount_imp[0] = d
#define BCM53128_A0_INRANGEERRCOUNT_IMPr_GET(r) (r).inrangeerrcount_imp[0]


/*
 * These macros can be used to access InRangeErrCount_IMP.
 *
 */
#define BCM53128_A0_READ_INRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_INRANGEERRCOUNT_IMPr,(r._inrangeerrcount_imp),4)
#define BCM53128_A0_WRITE_INRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_INRANGEERRCOUNT_IMPr,&(r._inrangeerrcount_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNT_IMPr BCM53128_A0_INRANGEERRCOUNT_IMPr
#define INRANGEERRCOUNT_IMPr_SIZE BCM53128_A0_INRANGEERRCOUNT_IMPr_SIZE
typedef BCM53128_A0_INRANGEERRCOUNT_IMPr_t INRANGEERRCOUNT_IMPr_t;
#define INRANGEERRCOUNT_IMPr_CLR BCM53128_A0_INRANGEERRCOUNT_IMPr_CLR
#define INRANGEERRCOUNT_IMPr_SET BCM53128_A0_INRANGEERRCOUNT_IMPr_SET
#define INRANGEERRCOUNT_IMPr_GET BCM53128_A0_INRANGEERRCOUNT_IMPr_GET
#define READ_INRANGEERRCOUNT_IMPr BCM53128_A0_READ_INRANGEERRCOUNT_IMPr
#define WRITE_INRANGEERRCOUNT_IMPr BCM53128_A0_WRITE_INRANGEERRCOUNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_INRANGEERRCOUNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  JUMBO_PORT_MASK
 * BLOCKS:   SYS
 * DESC:     Jumbo Frame Port Mask Registers
 * SIZE:     32
 * FIELDS:
 *     JUMBO_FM_PORT_MASK Jumbo Frame Port Mask.Ports defined in the Jumbo Frame Port Mask Register can Receive/Transmit Jumbo Frame ( Frame Size over the bytes defined in "Standard Max. Frame Size" register and less than 9720B).Bit7:0 = Port 7-0 in chip 0.0 : Disable Jumbo Frame Capability,1 : Enable Jumbo Frame Capability,Jumbo Frames can be allowed to be delivered among these Ports. Non-Jumbo Frame will not be constrained by the register. It is recommended that no more than two ports be enabled simultaneously to ensure system performance.
 *     RESERVED_0       Reserved.
 *     EN_10_100_JUMBO  Enable 10/100 Port can receive and transmit jumbo frame Only Giga Port can #receive jumbo frame as default.(Not2Release)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_JUMBO_PORT_MASKr 0x00004001

#define BCM53128_A0_JUMBO_PORT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program JUMBO_PORT_MASK.
 *
 */
typedef union BCM53128_A0_JUMBO_PORT_MASKr_s {
	uint32_t v[1];
	uint32_t jumbo_port_mask[1];
	uint32_t _jumbo_port_mask;
} BCM53128_A0_JUMBO_PORT_MASKr_t;

#define BCM53128_A0_JUMBO_PORT_MASKr_CLR(r) (r).jumbo_port_mask[0] = 0
#define BCM53128_A0_JUMBO_PORT_MASKr_SET(r,d) (r).jumbo_port_mask[0] = d
#define BCM53128_A0_JUMBO_PORT_MASKr_GET(r) (r).jumbo_port_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET(r) (((r).jumbo_port_mask[0]) & 0x1ff)
#define BCM53128_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_0f_GET(r) ((((r).jumbo_port_mask[0]) >> 9) & 0x7fff)
#define BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_0f_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7fff << 9)) | ((((uint32_t)f) & 0x7fff) << 9))
#define BCM53128_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET(r) ((((r).jumbo_port_mask[0]) >> 24) & 0x1)
#define BCM53128_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_1f_GET(r) ((((r).jumbo_port_mask[0]) >> 25) & 0x7f)
#define BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_1f_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access JUMBO_PORT_MASK.
 *
 */
#define BCM53128_A0_READ_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_read(u,BCM53128_A0_JUMBO_PORT_MASKr,(r._jumbo_port_mask),4)
#define BCM53128_A0_WRITE_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_write(u,BCM53128_A0_JUMBO_PORT_MASKr,&(r._jumbo_port_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBO_PORT_MASKr BCM53128_A0_JUMBO_PORT_MASKr
#define JUMBO_PORT_MASKr_SIZE BCM53128_A0_JUMBO_PORT_MASKr_SIZE
typedef BCM53128_A0_JUMBO_PORT_MASKr_t JUMBO_PORT_MASKr_t;
#define JUMBO_PORT_MASKr_CLR BCM53128_A0_JUMBO_PORT_MASKr_CLR
#define JUMBO_PORT_MASKr_SET BCM53128_A0_JUMBO_PORT_MASKr_SET
#define JUMBO_PORT_MASKr_GET BCM53128_A0_JUMBO_PORT_MASKr_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET BCM53128_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET BCM53128_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET
#define JUMBO_PORT_MASKr_RESERVED_0f_GET BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_0f_GET
#define JUMBO_PORT_MASKr_RESERVED_0f_SET BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_0f_SET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET BCM53128_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET BCM53128_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET
#define JUMBO_PORT_MASKr_RESERVED_1f_GET BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_1f_GET
#define JUMBO_PORT_MASKr_RESERVED_1f_SET BCM53128_A0_JUMBO_PORT_MASKr_RESERVED_1f_SET
#define READ_JUMBO_PORT_MASKr BCM53128_A0_READ_JUMBO_PORT_MASKr
#define WRITE_JUMBO_PORT_MASKr BCM53128_A0_WRITE_JUMBO_PORT_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_JUMBO_PORT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  JumboPkt
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_JUMBOPKTr 0x000020a8

#define BCM53128_A0_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt.
 *
 */
typedef union BCM53128_A0_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t jumbopkt[1];
	uint32_t _jumbopkt;
} BCM53128_A0_JUMBOPKTr_t;

#define BCM53128_A0_JUMBOPKTr_CLR(r) (r).jumbopkt[0] = 0
#define BCM53128_A0_JUMBOPKTr_SET(r,d) (r).jumbopkt[0] = d
#define BCM53128_A0_JUMBOPKTr_GET(r) (r).jumbopkt[0]


/*
 * These macros can be used to access JumboPkt.
 *
 */
#define BCM53128_A0_READ_JUMBOPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_JUMBOPKTr,(r._jumbopkt),4)
#define BCM53128_A0_WRITE_JUMBOPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_JUMBOPKTr,&(r._jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKTr BCM53128_A0_JUMBOPKTr
#define JUMBOPKTr_SIZE BCM53128_A0_JUMBOPKTr_SIZE
typedef BCM53128_A0_JUMBOPKTr_t JUMBOPKTr_t;
#define JUMBOPKTr_CLR BCM53128_A0_JUMBOPKTr_CLR
#define JUMBOPKTr_SET BCM53128_A0_JUMBOPKTr_SET
#define JUMBOPKTr_GET BCM53128_A0_JUMBOPKTr_GET
#define READ_JUMBOPKTr BCM53128_A0_READ_JUMBOPKTr
#define WRITE_JUMBOPKTr BCM53128_A0_WRITE_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  JumboPkt_IMP
 * BLOCKS:   CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_JUMBOPKT_IMPr 0x000028a8

#define BCM53128_A0_JUMBOPKT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt_IMP.
 *
 */
typedef union BCM53128_A0_JUMBOPKT_IMPr_s {
	uint32_t v[1];
	uint32_t jumbopkt_imp[1];
	uint32_t _jumbopkt_imp;
} BCM53128_A0_JUMBOPKT_IMPr_t;

#define BCM53128_A0_JUMBOPKT_IMPr_CLR(r) (r).jumbopkt_imp[0] = 0
#define BCM53128_A0_JUMBOPKT_IMPr_SET(r,d) (r).jumbopkt_imp[0] = d
#define BCM53128_A0_JUMBOPKT_IMPr_GET(r) (r).jumbopkt_imp[0]


/*
 * These macros can be used to access JumboPkt_IMP.
 *
 */
#define BCM53128_A0_READ_JUMBOPKT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_JUMBOPKT_IMPr,(r._jumbopkt_imp),4)
#define BCM53128_A0_WRITE_JUMBOPKT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_JUMBOPKT_IMPr,&(r._jumbopkt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKT_IMPr BCM53128_A0_JUMBOPKT_IMPr
#define JUMBOPKT_IMPr_SIZE BCM53128_A0_JUMBOPKT_IMPr_SIZE
typedef BCM53128_A0_JUMBOPKT_IMPr_t JUMBOPKT_IMPr_t;
#define JUMBOPKT_IMPr_CLR BCM53128_A0_JUMBOPKT_IMPr_CLR
#define JUMBOPKT_IMPr_SET BCM53128_A0_JUMBOPKT_IMPr_SET
#define JUMBOPKT_IMPr_GET BCM53128_A0_JUMBOPKT_IMPr_GET
#define READ_JUMBOPKT_IMPr BCM53128_A0_READ_JUMBOPKT_IMPr
#define WRITE_JUMBOPKT_IMPr BCM53128_A0_WRITE_JUMBOPKT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_JUMBOPKT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     67
 * FIELDS:
 *     MACADDR_47_12    Source Address[47:12]
 *     VID              VID 
 *     MULTCAST_PORTMAP Multicast Portmap
 *     CONTROL          ARL control :2b'b00 : Normal ARL function.2b'b01 : Drop if MAC_DA match.(Please also set the "Static" bit)2b'b01 : Drop if MAC_SA match.(Please also set the "Static" bit)2b'b11 : Forward the destination port specified by ARL, Also send a copy to CPU.
 *     TC               Traffic Class
 *     AGE              Age bit
 *     STATIC           Static status
 *     VALID            Valid status
 *
 ******************************************************************************/
#define BCM53128_A0_L2_ARLm 0x12120808

#define BCM53128_A0_L2_ARLm_MIN 0
#define BCM53128_A0_L2_ARLm_MAX 4095
#define BCM53128_A0_L2_ARLm_CMAX(u) 4095
#define BCM53128_A0_L2_ARLm_SIZE 9

/*
 * This structure should be used to declare and program L2_ARL.
 *
 */
typedef union BCM53128_A0_L2_ARLm_s {
	uint32_t v[3];
	uint32_t l2_arl[3];
	uint32_t _l2_arl;
} BCM53128_A0_L2_ARLm_t;

#define BCM53128_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM53128_A0_L2_ARLm_t))
#define BCM53128_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM53128_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,2,37,a)
#define BCM53128_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,2,37,a)
#define BCM53128_A0_L2_ARLm_VIDf_GET(r) ((((r).l2_arl[1]) >> 6) & 0xfff)
#define BCM53128_A0_L2_ARLm_VIDf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53128_A0_L2_ARLm_MULTCAST_PORTMAPf_GET(r) ((((r).l2_arl[1]) >> 18) & 0x1ff)
#define BCM53128_A0_L2_ARLm_MULTCAST_PORTMAPf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1ff << 18)) | ((((uint32_t)f) & 0x1ff) << 18))
#define BCM53128_A0_L2_ARLm_CONTROLf_GET(r) ((((r).l2_arl[1]) >> 27) & 0x3)
#define BCM53128_A0_L2_ARLm_CONTROLf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM53128_A0_L2_ARLm_TCf_GET(r) ((((r).l2_arl[1]) >> 29) & 0x7)
#define BCM53128_A0_L2_ARLm_TCf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM53128_A0_L2_ARLm_AGEf_GET(r) (((r).l2_arl[2]) & 0x1)
#define BCM53128_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_L2_ARLm_STATICf_GET(r) ((((r).l2_arl[2]) >> 1) & 0x1)
#define BCM53128_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_L2_ARLm_VALIDf_GET(r) ((((r).l2_arl[2]) >> 2) & 0x1)
#define BCM53128_A0_L2_ARLm_VALIDf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access L2_ARL.
 *
 */
#define BCM53128_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_L2_ARLm,i,(m),9)
#define BCM53128_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_L2_ARLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM53128_A0_L2_ARLm
#define L2_ARLm_MIN BCM53128_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM53128_A0_L2_ARLm_MAX
#define L2_ARLm_CMAX(u) BCM53128_A0_L2_ARLm_CMAX(u)
#define L2_ARLm_SIZE BCM53128_A0_L2_ARLm_SIZE
typedef BCM53128_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM53128_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM53128_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM53128_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM53128_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM53128_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_VIDf_GET BCM53128_A0_L2_ARLm_VIDf_GET
#define L2_ARLm_VIDf_SET BCM53128_A0_L2_ARLm_VIDf_SET
#define L2_ARLm_MULTCAST_PORTMAPf_GET BCM53128_A0_L2_ARLm_MULTCAST_PORTMAPf_GET
#define L2_ARLm_MULTCAST_PORTMAPf_SET BCM53128_A0_L2_ARLm_MULTCAST_PORTMAPf_SET
#define L2_ARLm_CONTROLf_GET BCM53128_A0_L2_ARLm_CONTROLf_GET
#define L2_ARLm_CONTROLf_SET BCM53128_A0_L2_ARLm_CONTROLf_SET
#define L2_ARLm_TCf_GET BCM53128_A0_L2_ARLm_TCf_GET
#define L2_ARLm_TCf_SET BCM53128_A0_L2_ARLm_TCf_SET
#define L2_ARLm_AGEf_GET BCM53128_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM53128_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_STATICf_GET BCM53128_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM53128_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_VALIDf_GET BCM53128_A0_L2_ARLm_VALIDf_GET
#define L2_ARLm_VALIDf_SET BCM53128_A0_L2_ARLm_VALIDf_SET
#define READ_L2_ARLm BCM53128_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM53128_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_L2_ARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     16
 * FIELDS:
 *     LED_EN_MAP       Per port enable function bit,1: Enable LED function0: Disable LED function
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_EN_MAPr 0x00000016

#define BCM53128_A0_LED_EN_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_EN_MAP.
 *
 */
typedef union BCM53128_A0_LED_EN_MAPr_s {
	uint32_t v[1];
	uint32_t led_en_map[1];
	uint32_t _led_en_map;
} BCM53128_A0_LED_EN_MAPr_t;

#define BCM53128_A0_LED_EN_MAPr_CLR(r) (r).led_en_map[0] = 0
#define BCM53128_A0_LED_EN_MAPr_SET(r,d) (r).led_en_map[0] = d
#define BCM53128_A0_LED_EN_MAPr_GET(r) (r).led_en_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) (((r).led_en_map[0]) & 0x1ff)
#define BCM53128_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LED_EN_MAPr_RESERVEDf_GET(r) ((((r).led_en_map[0]) >> 9) & 0x7f)
#define BCM53128_A0_LED_EN_MAPr_RESERVEDf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_EN_MAP.
 *
 */
#define BCM53128_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_EN_MAPr,(r._led_en_map),2)
#define BCM53128_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_EN_MAPr,&(r._led_en_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM53128_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM53128_A0_LED_EN_MAPr_SIZE
typedef BCM53128_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM53128_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM53128_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM53128_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM53128_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM53128_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVEDf_GET BCM53128_A0_LED_EN_MAPr_RESERVEDf_GET
#define LED_EN_MAPr_RESERVEDf_SET BCM53128_A0_LED_EN_MAPr_RESERVEDf_SET
#define READ_LED_EN_MAPr BCM53128_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM53128_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_EN_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     LNK              LNK.
 *     DPX              DPX.Default Value.ledmode = 00/01 : 0;ledmode = 10/11 : 1;
 *     ACT              ACT.
 *     COL              COL.
 *     LNK_ACT          LNK/ACT.Default Value.ledmode = 00/10 : 1;ledmode = 01/11 : 0;
 *     DPX_COL          DPX/COL.Default Value.ledmode = 00/10/11 : 0;ledmode = 01 : 1;
 *     SPD10M           SPD10M.
 *     SPD100M          SPD100M.Default Value.ledmode = 00/10 : 1;ledmode = 01/11 : 0;
 *     SPD1G            SPD1G.
 *     ACT_10M          10M/ACT.Default Value.ledmode = 00/10 : 0;ledmode = 01/11 : 1;
 *     ACT_100M         100M/ACT.Default Value.ledmode = 00/10 : 0;ledmode = 01/11 : 1;
 *     ACT_10M_100M     10/100M/ACT.
 *     ACT_1G           1G/ACT.
 *     BROADSYNC_HD_LINK BroadSync HD Link.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_FUNC0_CTLr 0x00000010

#define BCM53128_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 *
 */
typedef union BCM53128_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM53128_A0_LED_FUNC0_CTLr_t;

#define BCM53128_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM53128_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM53128_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_FUNC0_CTLr_RESERVED_0f_GET(r) (((r).led_func0_ctl[0]) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_RESERVED_0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_LED_FUNC0_CTLr_LNKf_GET(r) ((((r).led_func0_ctl[0]) >> 1) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_LNKf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_LED_FUNC0_CTLr_DPXf_GET(r) ((((r).led_func0_ctl[0]) >> 2) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_DPXf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_LED_FUNC0_CTLr_ACTf_GET(r) ((((r).led_func0_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_ACTf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_LED_FUNC0_CTLr_COLf_GET(r) ((((r).led_func0_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_COLf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_LED_FUNC0_CTLr_LNK_ACTf_GET(r) ((((r).led_func0_ctl[0]) >> 5) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_LNK_ACTf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_LED_FUNC0_CTLr_DPX_COLf_GET(r) ((((r).led_func0_ctl[0]) >> 6) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_DPX_COLf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_LED_FUNC0_CTLr_SPD10Mf_GET(r) ((((r).led_func0_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_SPD10Mf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_LED_FUNC0_CTLr_SPD100Mf_GET(r) ((((r).led_func0_ctl[0]) >> 8) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_SPD100Mf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_LED_FUNC0_CTLr_SPD1Gf_GET(r) ((((r).led_func0_ctl[0]) >> 9) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_SPD1Gf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_10Mf_GET(r) ((((r).led_func0_ctl[0]) >> 10) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_10Mf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_100Mf_GET(r) ((((r).led_func0_ctl[0]) >> 11) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_100Mf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_10M_100Mf_GET(r) ((((r).led_func0_ctl[0]) >> 12) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_10M_100Mf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_1Gf_GET(r) ((((r).led_func0_ctl[0]) >> 13) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_ACT_1Gf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_LED_FUNC0_CTLr_BROADSYNC_HD_LINKf_GET(r) ((((r).led_func0_ctl[0]) >> 14) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_BROADSYNC_HD_LINKf_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_LED_FUNC0_CTLr_RESERVED_1f_GET(r) ((((r).led_func0_ctl[0]) >> 15) & 0x1)
#define BCM53128_A0_LED_FUNC0_CTLr_RESERVED_1f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 *
 */
#define BCM53128_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM53128_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM53128_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM53128_A0_LED_FUNC0_CTLr_SIZE
typedef BCM53128_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM53128_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM53128_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM53128_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_RESERVED_0f_GET BCM53128_A0_LED_FUNC0_CTLr_RESERVED_0f_GET
#define LED_FUNC0_CTLr_RESERVED_0f_SET BCM53128_A0_LED_FUNC0_CTLr_RESERVED_0f_SET
#define LED_FUNC0_CTLr_LNKf_GET BCM53128_A0_LED_FUNC0_CTLr_LNKf_GET
#define LED_FUNC0_CTLr_LNKf_SET BCM53128_A0_LED_FUNC0_CTLr_LNKf_SET
#define LED_FUNC0_CTLr_DPXf_GET BCM53128_A0_LED_FUNC0_CTLr_DPXf_GET
#define LED_FUNC0_CTLr_DPXf_SET BCM53128_A0_LED_FUNC0_CTLr_DPXf_SET
#define LED_FUNC0_CTLr_ACTf_GET BCM53128_A0_LED_FUNC0_CTLr_ACTf_GET
#define LED_FUNC0_CTLr_ACTf_SET BCM53128_A0_LED_FUNC0_CTLr_ACTf_SET
#define LED_FUNC0_CTLr_COLf_GET BCM53128_A0_LED_FUNC0_CTLr_COLf_GET
#define LED_FUNC0_CTLr_COLf_SET BCM53128_A0_LED_FUNC0_CTLr_COLf_SET
#define LED_FUNC0_CTLr_LNK_ACTf_GET BCM53128_A0_LED_FUNC0_CTLr_LNK_ACTf_GET
#define LED_FUNC0_CTLr_LNK_ACTf_SET BCM53128_A0_LED_FUNC0_CTLr_LNK_ACTf_SET
#define LED_FUNC0_CTLr_DPX_COLf_GET BCM53128_A0_LED_FUNC0_CTLr_DPX_COLf_GET
#define LED_FUNC0_CTLr_DPX_COLf_SET BCM53128_A0_LED_FUNC0_CTLr_DPX_COLf_SET
#define LED_FUNC0_CTLr_SPD10Mf_GET BCM53128_A0_LED_FUNC0_CTLr_SPD10Mf_GET
#define LED_FUNC0_CTLr_SPD10Mf_SET BCM53128_A0_LED_FUNC0_CTLr_SPD10Mf_SET
#define LED_FUNC0_CTLr_SPD100Mf_GET BCM53128_A0_LED_FUNC0_CTLr_SPD100Mf_GET
#define LED_FUNC0_CTLr_SPD100Mf_SET BCM53128_A0_LED_FUNC0_CTLr_SPD100Mf_SET
#define LED_FUNC0_CTLr_SPD1Gf_GET BCM53128_A0_LED_FUNC0_CTLr_SPD1Gf_GET
#define LED_FUNC0_CTLr_SPD1Gf_SET BCM53128_A0_LED_FUNC0_CTLr_SPD1Gf_SET
#define LED_FUNC0_CTLr_ACT_10Mf_GET BCM53128_A0_LED_FUNC0_CTLr_ACT_10Mf_GET
#define LED_FUNC0_CTLr_ACT_10Mf_SET BCM53128_A0_LED_FUNC0_CTLr_ACT_10Mf_SET
#define LED_FUNC0_CTLr_ACT_100Mf_GET BCM53128_A0_LED_FUNC0_CTLr_ACT_100Mf_GET
#define LED_FUNC0_CTLr_ACT_100Mf_SET BCM53128_A0_LED_FUNC0_CTLr_ACT_100Mf_SET
#define LED_FUNC0_CTLr_ACT_10M_100Mf_GET BCM53128_A0_LED_FUNC0_CTLr_ACT_10M_100Mf_GET
#define LED_FUNC0_CTLr_ACT_10M_100Mf_SET BCM53128_A0_LED_FUNC0_CTLr_ACT_10M_100Mf_SET
#define LED_FUNC0_CTLr_ACT_1Gf_GET BCM53128_A0_LED_FUNC0_CTLr_ACT_1Gf_GET
#define LED_FUNC0_CTLr_ACT_1Gf_SET BCM53128_A0_LED_FUNC0_CTLr_ACT_1Gf_SET
#define LED_FUNC0_CTLr_BROADSYNC_HD_LINKf_GET BCM53128_A0_LED_FUNC0_CTLr_BROADSYNC_HD_LINKf_GET
#define LED_FUNC0_CTLr_BROADSYNC_HD_LINKf_SET BCM53128_A0_LED_FUNC0_CTLr_BROADSYNC_HD_LINKf_SET
#define LED_FUNC0_CTLr_RESERVED_1f_GET BCM53128_A0_LED_FUNC0_CTLr_RESERVED_1f_GET
#define LED_FUNC0_CTLr_RESERVED_1f_SET BCM53128_A0_LED_FUNC0_CTLr_RESERVED_1f_SET
#define READ_LED_FUNC0_CTLr BCM53128_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM53128_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_FUNC0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     LNK              LNK.
 *     DPX              DPX.Default Value.ledmode = 00/01 : 0;ledmode = 10/11 : 1;
 *     ACT              ACT.
 *     COL              COL.
 *     LNK_ACT          LNK/ACT.Default Value.ledmode = 00/10 : 1;ledmode = 01/11 : 0;
 *     DPX_COL          DPX/COL.Default Value.ledmode = 00/10/11 : 0;ledmode = 01 : 1;
 *     SPD10M           SPD10M.
 *     SPD100M          SPD100M.Default Value.ledmode = 00/10 : 1;ledmode = 01/11 : 0;
 *     SPD1G            SPD1G.Default Value.ledmode = 00/10 : 1;ledmode = 01/11 : 0;
 *     ACT_10M          10M/ACT.Default Value.ledmode = 00/01/10 : 0;ledmode = 11 : 1;
 *     ACT_100M         100M/ACT.Default Value.ledmode = 00/01/10 : 0;ledmode = 11 : 1;
 *     ACT_10M_100M     10/100M/ACT.Default Value.ledmode = 00/10/11 : 0;ledmode = 01 : 1;
 *     ACT_1G           1G/ACT.Default Value.ledmode = 00/10 : 0;ledmode = 01/11 : 1;
 *     BROADSYNC_HD_LINK BroadSync HD Link.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_FUNC1_CTLr 0x00000012

#define BCM53128_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 *
 */
typedef union BCM53128_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM53128_A0_LED_FUNC1_CTLr_t;

#define BCM53128_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM53128_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM53128_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_FUNC1_CTLr_RESERVED_0f_GET(r) (((r).led_func1_ctl[0]) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_RESERVED_0f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_LED_FUNC1_CTLr_LNKf_GET(r) ((((r).led_func1_ctl[0]) >> 1) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_LNKf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_LED_FUNC1_CTLr_DPXf_GET(r) ((((r).led_func1_ctl[0]) >> 2) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_DPXf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_LED_FUNC1_CTLr_ACTf_GET(r) ((((r).led_func1_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_ACTf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_LED_FUNC1_CTLr_COLf_GET(r) ((((r).led_func1_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_COLf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_LED_FUNC1_CTLr_LNK_ACTf_GET(r) ((((r).led_func1_ctl[0]) >> 5) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_LNK_ACTf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_LED_FUNC1_CTLr_DPX_COLf_GET(r) ((((r).led_func1_ctl[0]) >> 6) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_DPX_COLf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_LED_FUNC1_CTLr_SPD10Mf_GET(r) ((((r).led_func1_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_SPD10Mf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_LED_FUNC1_CTLr_SPD100Mf_GET(r) ((((r).led_func1_ctl[0]) >> 8) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_SPD100Mf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_LED_FUNC1_CTLr_SPD1Gf_GET(r) ((((r).led_func1_ctl[0]) >> 9) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_SPD1Gf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_10Mf_GET(r) ((((r).led_func1_ctl[0]) >> 10) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_10Mf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_100Mf_GET(r) ((((r).led_func1_ctl[0]) >> 11) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_100Mf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_10M_100Mf_GET(r) ((((r).led_func1_ctl[0]) >> 12) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_10M_100Mf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_1Gf_GET(r) ((((r).led_func1_ctl[0]) >> 13) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_ACT_1Gf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_LED_FUNC1_CTLr_BROADSYNC_HD_LINKf_GET(r) ((((r).led_func1_ctl[0]) >> 14) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_BROADSYNC_HD_LINKf_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_LED_FUNC1_CTLr_RESERVED_1f_GET(r) ((((r).led_func1_ctl[0]) >> 15) & 0x1)
#define BCM53128_A0_LED_FUNC1_CTLr_RESERVED_1f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 *
 */
#define BCM53128_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM53128_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM53128_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM53128_A0_LED_FUNC1_CTLr_SIZE
typedef BCM53128_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM53128_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM53128_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM53128_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_RESERVED_0f_GET BCM53128_A0_LED_FUNC1_CTLr_RESERVED_0f_GET
#define LED_FUNC1_CTLr_RESERVED_0f_SET BCM53128_A0_LED_FUNC1_CTLr_RESERVED_0f_SET
#define LED_FUNC1_CTLr_LNKf_GET BCM53128_A0_LED_FUNC1_CTLr_LNKf_GET
#define LED_FUNC1_CTLr_LNKf_SET BCM53128_A0_LED_FUNC1_CTLr_LNKf_SET
#define LED_FUNC1_CTLr_DPXf_GET BCM53128_A0_LED_FUNC1_CTLr_DPXf_GET
#define LED_FUNC1_CTLr_DPXf_SET BCM53128_A0_LED_FUNC1_CTLr_DPXf_SET
#define LED_FUNC1_CTLr_ACTf_GET BCM53128_A0_LED_FUNC1_CTLr_ACTf_GET
#define LED_FUNC1_CTLr_ACTf_SET BCM53128_A0_LED_FUNC1_CTLr_ACTf_SET
#define LED_FUNC1_CTLr_COLf_GET BCM53128_A0_LED_FUNC1_CTLr_COLf_GET
#define LED_FUNC1_CTLr_COLf_SET BCM53128_A0_LED_FUNC1_CTLr_COLf_SET
#define LED_FUNC1_CTLr_LNK_ACTf_GET BCM53128_A0_LED_FUNC1_CTLr_LNK_ACTf_GET
#define LED_FUNC1_CTLr_LNK_ACTf_SET BCM53128_A0_LED_FUNC1_CTLr_LNK_ACTf_SET
#define LED_FUNC1_CTLr_DPX_COLf_GET BCM53128_A0_LED_FUNC1_CTLr_DPX_COLf_GET
#define LED_FUNC1_CTLr_DPX_COLf_SET BCM53128_A0_LED_FUNC1_CTLr_DPX_COLf_SET
#define LED_FUNC1_CTLr_SPD10Mf_GET BCM53128_A0_LED_FUNC1_CTLr_SPD10Mf_GET
#define LED_FUNC1_CTLr_SPD10Mf_SET BCM53128_A0_LED_FUNC1_CTLr_SPD10Mf_SET
#define LED_FUNC1_CTLr_SPD100Mf_GET BCM53128_A0_LED_FUNC1_CTLr_SPD100Mf_GET
#define LED_FUNC1_CTLr_SPD100Mf_SET BCM53128_A0_LED_FUNC1_CTLr_SPD100Mf_SET
#define LED_FUNC1_CTLr_SPD1Gf_GET BCM53128_A0_LED_FUNC1_CTLr_SPD1Gf_GET
#define LED_FUNC1_CTLr_SPD1Gf_SET BCM53128_A0_LED_FUNC1_CTLr_SPD1Gf_SET
#define LED_FUNC1_CTLr_ACT_10Mf_GET BCM53128_A0_LED_FUNC1_CTLr_ACT_10Mf_GET
#define LED_FUNC1_CTLr_ACT_10Mf_SET BCM53128_A0_LED_FUNC1_CTLr_ACT_10Mf_SET
#define LED_FUNC1_CTLr_ACT_100Mf_GET BCM53128_A0_LED_FUNC1_CTLr_ACT_100Mf_GET
#define LED_FUNC1_CTLr_ACT_100Mf_SET BCM53128_A0_LED_FUNC1_CTLr_ACT_100Mf_SET
#define LED_FUNC1_CTLr_ACT_10M_100Mf_GET BCM53128_A0_LED_FUNC1_CTLr_ACT_10M_100Mf_GET
#define LED_FUNC1_CTLr_ACT_10M_100Mf_SET BCM53128_A0_LED_FUNC1_CTLr_ACT_10M_100Mf_SET
#define LED_FUNC1_CTLr_ACT_1Gf_GET BCM53128_A0_LED_FUNC1_CTLr_ACT_1Gf_GET
#define LED_FUNC1_CTLr_ACT_1Gf_SET BCM53128_A0_LED_FUNC1_CTLr_ACT_1Gf_SET
#define LED_FUNC1_CTLr_BROADSYNC_HD_LINKf_GET BCM53128_A0_LED_FUNC1_CTLr_BROADSYNC_HD_LINKf_GET
#define LED_FUNC1_CTLr_BROADSYNC_HD_LINKf_SET BCM53128_A0_LED_FUNC1_CTLr_BROADSYNC_HD_LINKf_SET
#define LED_FUNC1_CTLr_RESERVED_1f_GET BCM53128_A0_LED_FUNC1_CTLr_RESERVED_1f_GET
#define LED_FUNC1_CTLr_RESERVED_1f_SET BCM53128_A0_LED_FUNC1_CTLr_RESERVED_1f_SET
#define READ_LED_FUNC1_CTLr BCM53128_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM53128_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_FUNC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC_MAP     Per port select function bit.1: select function 1,0: select function 0.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_FUNC_MAPr 0x00000014

#define BCM53128_A0_LED_FUNC_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 *
 */
typedef union BCM53128_A0_LED_FUNC_MAPr_s {
	uint32_t v[1];
	uint32_t led_func_map[1];
	uint32_t _led_func_map;
} BCM53128_A0_LED_FUNC_MAPr_t;

#define BCM53128_A0_LED_FUNC_MAPr_CLR(r) (r).led_func_map[0] = 0
#define BCM53128_A0_LED_FUNC_MAPr_SET(r,d) (r).led_func_map[0] = d
#define BCM53128_A0_LED_FUNC_MAPr_GET(r) (r).led_func_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) (((r).led_func_map[0]) & 0x1ff)
#define BCM53128_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LED_FUNC_MAPr_RESERVEDf_GET(r) ((((r).led_func_map[0]) >> 9) & 0x7f)
#define BCM53128_A0_LED_FUNC_MAPr_RESERVEDf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_FUNC_MAP.
 *
 */
#define BCM53128_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_FUNC_MAPr,(r._led_func_map),2)
#define BCM53128_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_FUNC_MAPr,&(r._led_func_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM53128_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM53128_A0_LED_FUNC_MAPr_SIZE
typedef BCM53128_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM53128_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM53128_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM53128_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM53128_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM53128_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVEDf_GET BCM53128_A0_LED_FUNC_MAPr_RESERVEDf_GET
#define LED_FUNC_MAPr_RESERVEDf_SET BCM53128_A0_LED_FUNC_MAPr_RESERVEDf_SET
#define READ_LED_FUNC_MAPr BCM53128_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM53128_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_FUNC_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP0    Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_MODE_MAP_0r 0x00000018

#define BCM53128_A0_LED_MODE_MAP_0r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 *
 */
typedef union BCM53128_A0_LED_MODE_MAP_0r_s {
	uint32_t v[1];
	uint32_t led_mode_map_0[1];
	uint32_t _led_mode_map_0;
} BCM53128_A0_LED_MODE_MAP_0r_t;

#define BCM53128_A0_LED_MODE_MAP_0r_CLR(r) (r).led_mode_map_0[0] = 0
#define BCM53128_A0_LED_MODE_MAP_0r_SET(r,d) (r).led_mode_map_0[0] = d
#define BCM53128_A0_LED_MODE_MAP_0r_GET(r) (r).led_mode_map_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_GET(r) (((r).led_mode_map_0[0]) & 0x1ff)
#define BCM53128_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LED_MODE_MAP_0r_RESERVEDf_GET(r) ((((r).led_mode_map_0[0]) >> 9) & 0x7f)
#define BCM53128_A0_LED_MODE_MAP_0r_RESERVEDf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 *
 */
#define BCM53128_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),2)
#define BCM53128_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM53128_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM53128_A0_LED_MODE_MAP_0r_SIZE
typedef BCM53128_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM53128_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM53128_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM53128_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_LED_MODE_MAP0f_GET BCM53128_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_GET
#define LED_MODE_MAP_0r_LED_MODE_MAP0f_SET BCM53128_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_SET
#define LED_MODE_MAP_0r_RESERVEDf_GET BCM53128_A0_LED_MODE_MAP_0r_RESERVEDf_GET
#define LED_MODE_MAP_0r_RESERVEDf_SET BCM53128_A0_LED_MODE_MAP_0r_RESERVEDf_SET
#define READ_LED_MODE_MAP_0r BCM53128_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM53128_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_MODE_MAP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP1    Combine with LED_MODEMAP0 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_MODE_MAP_1r 0x0000001a

#define BCM53128_A0_LED_MODE_MAP_1r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 *
 */
typedef union BCM53128_A0_LED_MODE_MAP_1r_s {
	uint32_t v[1];
	uint32_t led_mode_map_1[1];
	uint32_t _led_mode_map_1;
} BCM53128_A0_LED_MODE_MAP_1r_t;

#define BCM53128_A0_LED_MODE_MAP_1r_CLR(r) (r).led_mode_map_1[0] = 0
#define BCM53128_A0_LED_MODE_MAP_1r_SET(r,d) (r).led_mode_map_1[0] = d
#define BCM53128_A0_LED_MODE_MAP_1r_GET(r) (r).led_mode_map_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_GET(r) (((r).led_mode_map_1[0]) & 0x1ff)
#define BCM53128_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LED_MODE_MAP_1r_RESERVEDf_GET(r) ((((r).led_mode_map_1[0]) >> 9) & 0x7f)
#define BCM53128_A0_LED_MODE_MAP_1r_RESERVEDf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 *
 */
#define BCM53128_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),2)
#define BCM53128_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM53128_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM53128_A0_LED_MODE_MAP_1r_SIZE
typedef BCM53128_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM53128_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM53128_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM53128_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_LED_MODE_MAP1f_GET BCM53128_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_GET
#define LED_MODE_MAP_1r_LED_MODE_MAP1f_SET BCM53128_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_SET
#define LED_MODE_MAP_1r_RESERVEDf_GET BCM53128_A0_LED_MODE_MAP_1r_RESERVEDf_GET
#define LED_MODE_MAP_1r_RESERVEDf_SET BCM53128_A0_LED_MODE_MAP_1r_RESERVEDf_SET
#define READ_LED_MODE_MAP_1r BCM53128_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM53128_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_MODE_MAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_OPTIONS
 * BLOCKS:   SYS
 * DESC:     LED Control Register
 * SIZE:     8
 * FIELDS:
 *     OE_PHY_LED       Enable PHY LED output through the LED pinsWhen this bits is set, the PHY LED pins will be output through the chip LED pins, this bit can only be enabled under parallel LED mode.(Not2Release)
 *     MDC_TIMING_ENH   1'b1: MDC design which might have glitch(Falcon implementation)1'b0: Provide exact MDC cycles for accessing interal or external PHYs.(Not2Release)
 *     RESERVED         Reserved.
 *     DUAL_LED_CTRL    Dual-color LED Test Control:When this bit is '1', the POST will test one side of the dual-color LED, which corresponding post_led_ctrl bit = 1'b1 first, and then test the other side of the dual-color LED, which corresponding post_led_ctrl bit = 1'b0.When this bit is '0', the POST will only test one side of the dual-color LED, which corresponding post_led_ctrl bit = '1b1, and leave the other side of the dual-color LED untested.
 *     POST_LED_CTRL    Post LED Control:The 4 bits control the LED on/off state during POST to allow dual-color LED to be tested.[7:4] control LED3~LED0 of each port.When '1', the LED pin is activated during POST, when '0', the LED pin is deactivated during POST.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_OPTIONSr 0x0000001c

#define BCM53128_A0_LED_OPTIONSr_SIZE 1

/*
 * This structure should be used to declare and program LED_OPTIONS.
 *
 */
typedef union BCM53128_A0_LED_OPTIONSr_s {
	uint32_t v[1];
	uint32_t led_options[1];
	uint32_t _led_options;
} BCM53128_A0_LED_OPTIONSr_t;

#define BCM53128_A0_LED_OPTIONSr_CLR(r) (r).led_options[0] = 0
#define BCM53128_A0_LED_OPTIONSr_SET(r,d) (r).led_options[0] = d
#define BCM53128_A0_LED_OPTIONSr_GET(r) (r).led_options[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_OPTIONSr_OE_PHY_LEDf_GET(r) (((r).led_options[0]) & 0x1)
#define BCM53128_A0_LED_OPTIONSr_OE_PHY_LEDf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_LED_OPTIONSr_MDC_TIMING_ENHf_GET(r) ((((r).led_options[0]) >> 1) & 0x1)
#define BCM53128_A0_LED_OPTIONSr_MDC_TIMING_ENHf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_LED_OPTIONSr_RESERVEDf_GET(r) ((((r).led_options[0]) >> 2) & 0x1)
#define BCM53128_A0_LED_OPTIONSr_RESERVEDf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_LED_OPTIONSr_DUAL_LED_CTRLf_GET(r) ((((r).led_options[0]) >> 3) & 0x1)
#define BCM53128_A0_LED_OPTIONSr_DUAL_LED_CTRLf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_LED_OPTIONSr_POST_LED_CTRLf_GET(r) ((((r).led_options[0]) >> 4) & 0xf)
#define BCM53128_A0_LED_OPTIONSr_POST_LED_CTRLf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access LED_OPTIONS.
 *
 */
#define BCM53128_A0_READ_LED_OPTIONSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_OPTIONSr,(r._led_options),1)
#define BCM53128_A0_WRITE_LED_OPTIONSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_OPTIONSr,&(r._led_options),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_OPTIONSr BCM53128_A0_LED_OPTIONSr
#define LED_OPTIONSr_SIZE BCM53128_A0_LED_OPTIONSr_SIZE
typedef BCM53128_A0_LED_OPTIONSr_t LED_OPTIONSr_t;
#define LED_OPTIONSr_CLR BCM53128_A0_LED_OPTIONSr_CLR
#define LED_OPTIONSr_SET BCM53128_A0_LED_OPTIONSr_SET
#define LED_OPTIONSr_GET BCM53128_A0_LED_OPTIONSr_GET
#define LED_OPTIONSr_OE_PHY_LEDf_GET BCM53128_A0_LED_OPTIONSr_OE_PHY_LEDf_GET
#define LED_OPTIONSr_OE_PHY_LEDf_SET BCM53128_A0_LED_OPTIONSr_OE_PHY_LEDf_SET
#define LED_OPTIONSr_MDC_TIMING_ENHf_GET BCM53128_A0_LED_OPTIONSr_MDC_TIMING_ENHf_GET
#define LED_OPTIONSr_MDC_TIMING_ENHf_SET BCM53128_A0_LED_OPTIONSr_MDC_TIMING_ENHf_SET
#define LED_OPTIONSr_RESERVEDf_GET BCM53128_A0_LED_OPTIONSr_RESERVEDf_GET
#define LED_OPTIONSr_RESERVEDf_SET BCM53128_A0_LED_OPTIONSr_RESERVEDf_SET
#define LED_OPTIONSr_DUAL_LED_CTRLf_GET BCM53128_A0_LED_OPTIONSr_DUAL_LED_CTRLf_GET
#define LED_OPTIONSr_DUAL_LED_CTRLf_SET BCM53128_A0_LED_OPTIONSr_DUAL_LED_CTRLf_SET
#define LED_OPTIONSr_POST_LED_CTRLf_GET BCM53128_A0_LED_OPTIONSr_POST_LED_CTRLf_GET
#define LED_OPTIONSr_POST_LED_CTRLf_SET BCM53128_A0_LED_OPTIONSr_POST_LED_CTRLf_SET
#define READ_LED_OPTIONSr BCM53128_A0_READ_LED_OPTIONSr
#define WRITE_LED_OPTIONSr BCM53128_A0_WRITE_LED_OPTIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_OPTIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_PORTMAP
 * BLOCKS:   SYS
 * DESC:     LED Waming Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     LED_WARNING_PORTMAP LED indication for loop detection foundbit 8 for IMPbit 7:0 for port 7-0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_LED_PORTMAPr 0x00007203

#define BCM53128_A0_LED_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_PORTMAP.
 *
 */
typedef union BCM53128_A0_LED_PORTMAPr_s {
	uint32_t v[1];
	uint32_t led_portmap[1];
	uint32_t _led_portmap;
} BCM53128_A0_LED_PORTMAPr_t;

#define BCM53128_A0_LED_PORTMAPr_CLR(r) (r).led_portmap[0] = 0
#define BCM53128_A0_LED_PORTMAPr_SET(r,d) (r).led_portmap[0] = d
#define BCM53128_A0_LED_PORTMAPr_GET(r) (r).led_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET(r) (((r).led_portmap[0]) & 0x1ff)
#define BCM53128_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LED_PORTMAPr_RESERVEDf_GET(r) ((((r).led_portmap[0]) >> 9) & 0x7f)
#define BCM53128_A0_LED_PORTMAPr_RESERVEDf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_PORTMAP.
 *
 */
#define BCM53128_A0_READ_LED_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_PORTMAPr,(r._led_portmap),2)
#define BCM53128_A0_WRITE_LED_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_PORTMAPr,&(r._led_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_PORTMAPr BCM53128_A0_LED_PORTMAPr
#define LED_PORTMAPr_SIZE BCM53128_A0_LED_PORTMAPr_SIZE
typedef BCM53128_A0_LED_PORTMAPr_t LED_PORTMAPr_t;
#define LED_PORTMAPr_CLR BCM53128_A0_LED_PORTMAPr_CLR
#define LED_PORTMAPr_SET BCM53128_A0_LED_PORTMAPr_SET
#define LED_PORTMAPr_GET BCM53128_A0_LED_PORTMAPr_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_GET BCM53128_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_SET BCM53128_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET
#define LED_PORTMAPr_RESERVEDf_GET BCM53128_A0_LED_PORTMAPr_RESERVEDf_GET
#define LED_PORTMAPr_RESERVEDf_SET BCM53128_A0_LED_PORTMAPr_RESERVEDf_SET
#define READ_LED_PORTMAPr BCM53128_A0_READ_LED_PORTMAPr
#define WRITE_LED_PORTMAPr BCM53128_A0_WRITE_LED_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LED_REFLSH_CTL
 * BLOCKS:   SYS
 * DESC:     LED Configuration Register
 * SIZE:     8
 * FIELDS:
 *     LED_RFS_STOP     LED reflash control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     LED_NORM_CD_EN   Write 1 to active cable diag in normal mode.
 *     LED_POST_CD_EN   Write 1 to active cable diag after POST.
 *     LED_PSCAN_EN     Write 1 to active port scan during POST.
 *     LED_POST_EXEC    Write 1 to re-start POST.
 *     LED_EN           Enable LED.
 *
 ******************************************************************************/
#define BCM53128_A0_LED_REFLSH_CTLr 0x0000000f

#define BCM53128_A0_LED_REFLSH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program LED_REFLSH_CTL.
 *
 */
typedef union BCM53128_A0_LED_REFLSH_CTLr_s {
	uint32_t v[1];
	uint32_t led_reflsh_ctl[1];
	uint32_t _led_reflsh_ctl;
} BCM53128_A0_LED_REFLSH_CTLr_t;

#define BCM53128_A0_LED_REFLSH_CTLr_CLR(r) (r).led_reflsh_ctl[0] = 0
#define BCM53128_A0_LED_REFLSH_CTLr_SET(r,d) (r).led_reflsh_ctl[0] = d
#define BCM53128_A0_LED_REFLSH_CTLr_GET(r) (r).led_reflsh_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET(r) (((r).led_reflsh_ctl[0]) & 0x7)
#define BCM53128_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 5) & 0x1)
#define BCM53128_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET(r) ((((r).led_reflsh_ctl[0]) >> 6) & 0x1)
#define BCM53128_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_LED_REFLSH_CTLr_LED_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_LED_REFLSH_CTLr_LED_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access LED_REFLSH_CTL.
 *
 */
#define BCM53128_A0_READ_LED_REFLSH_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LED_REFLSH_CTLr,(r._led_reflsh_ctl),1)
#define BCM53128_A0_WRITE_LED_REFLSH_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LED_REFLSH_CTLr,&(r._led_reflsh_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_REFLSH_CTLr BCM53128_A0_LED_REFLSH_CTLr
#define LED_REFLSH_CTLr_SIZE BCM53128_A0_LED_REFLSH_CTLr_SIZE
typedef BCM53128_A0_LED_REFLSH_CTLr_t LED_REFLSH_CTLr_t;
#define LED_REFLSH_CTLr_CLR BCM53128_A0_LED_REFLSH_CTLr_CLR
#define LED_REFLSH_CTLr_SET BCM53128_A0_LED_REFLSH_CTLr_SET
#define LED_REFLSH_CTLr_GET BCM53128_A0_LED_REFLSH_CTLr_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_GET BCM53128_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_SET BCM53128_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET BCM53128_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET BCM53128_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_GET BCM53128_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_SET BCM53128_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_GET BCM53128_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_SET BCM53128_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_EXECf_GET BCM53128_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET
#define LED_REFLSH_CTLr_LED_POST_EXECf_SET BCM53128_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET
#define LED_REFLSH_CTLr_LED_ENf_GET BCM53128_A0_LED_REFLSH_CTLr_LED_ENf_GET
#define LED_REFLSH_CTLr_LED_ENf_SET BCM53128_A0_LED_REFLSH_CTLr_LED_ENf_SET
#define READ_LED_REFLSH_CTLr BCM53128_A0_READ_LED_REFLSH_CTLr
#define WRITE_LED_REFLSH_CTLr BCM53128_A0_WRITE_LED_REFLSH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LED_REFLSH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     Link Status Summary Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS          Link Status.9bit field indicating the Link Status for each 10/100/1000 BASE-T port, (bits 0-7 = 10/100/1000 BASE-T, bit 8 IMP port ).0 = Link Fail1 = Link Pass
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_LNKSTSr 0x00000100

#define BCM53128_A0_LNKSTSr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTS.
 *
 */
typedef union BCM53128_A0_LNKSTSr_s {
	uint32_t v[1];
	uint32_t lnksts[1];
	uint32_t _lnksts;
} BCM53128_A0_LNKSTSr_t;

#define BCM53128_A0_LNKSTSr_CLR(r) (r).lnksts[0] = 0
#define BCM53128_A0_LNKSTSr_SET(r,d) (r).lnksts[0] = d
#define BCM53128_A0_LNKSTSr_GET(r) (r).lnksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LNKSTSr_LNK_STSf_GET(r) (((r).lnksts[0]) & 0x1ff)
#define BCM53128_A0_LNKSTSr_LNK_STSf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LNKSTSr_RESERVEDf_GET(r) ((((r).lnksts[0]) >> 9) & 0x7f)
#define BCM53128_A0_LNKSTSr_RESERVEDf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTS.
 *
 */
#define BCM53128_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LNKSTSr,(r._lnksts),2)
#define BCM53128_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LNKSTSr,&(r._lnksts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM53128_A0_LNKSTSr
#define LNKSTSr_SIZE BCM53128_A0_LNKSTSr_SIZE
typedef BCM53128_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM53128_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM53128_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM53128_A0_LNKSTSr_GET
#define LNKSTSr_LNK_STSf_GET BCM53128_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM53128_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVEDf_GET BCM53128_A0_LNKSTSr_RESERVEDf_GET
#define LNKSTSr_RESERVEDf_SET BCM53128_A0_LNKSTSr_RESERVEDf_SET
#define READ_LNKSTSr BCM53128_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM53128_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LNKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Link Status Change Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS_CHG      Link Status Change.9 bit field indicating that the Link Status for an individual 10/100/1000BASE-T port had changed since the last read operation (bits 0-7 = 10/100/1000BASE- T ports, bit 8 = IMP port). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant,1 = Link Status Change.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_LNKSTSCHGr 0x00000102

#define BCM53128_A0_LNKSTSCHGr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTSCHG.
 *
 */
typedef union BCM53128_A0_LNKSTSCHGr_s {
	uint32_t v[1];
	uint32_t lnkstschg[1];
	uint32_t _lnkstschg;
} BCM53128_A0_LNKSTSCHGr_t;

#define BCM53128_A0_LNKSTSCHGr_CLR(r) (r).lnkstschg[0] = 0
#define BCM53128_A0_LNKSTSCHGr_SET(r,d) (r).lnkstschg[0] = d
#define BCM53128_A0_LNKSTSCHGr_GET(r) (r).lnkstschg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) (((r).lnkstschg[0]) & 0x1ff)
#define BCM53128_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_LNKSTSCHGr_RESERVEDf_GET(r) ((((r).lnkstschg[0]) >> 9) & 0x7f)
#define BCM53128_A0_LNKSTSCHGr_RESERVEDf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTSCHG.
 *
 */
#define BCM53128_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LNKSTSCHGr,(r._lnkstschg),2)
#define BCM53128_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LNKSTSCHGr,&(r._lnkstschg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM53128_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM53128_A0_LNKSTSCHGr_SIZE
typedef BCM53128_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM53128_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM53128_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM53128_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM53128_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM53128_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVEDf_GET BCM53128_A0_LNKSTSCHGr_RESERVEDf_GET
#define LNKSTSCHGr_RESERVEDf_SET BCM53128_A0_LNKSTSCHGr_RESERVEDf_SET
#define READ_LNKSTSCHGr BCM53128_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM53128_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LNKSTSCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LOW_POWER_CTRL
 * BLOCKS:   SYS
 * DESC:     LOW Power Control Register
 * SIZE:     16
 * FIELDS:
 *     LOW_POWER_DIVIDER low_power_divider.When bit[7] is 1'b1, this field indicates the divider of the low power clock. If this field is 0, the system clock=CK25/2, otherwise=CK25/(low_power_divider*4).4'h00: 12.5Mhz4'h01: 6.25Mhz4'h02: 3.125Mhz
 *     SLEEP_MAC_50     Writing 1'b1 to this bit will stop MAC source clocks 50MHz for P7 and P8(IMP Port).1'b1: Clock frequency for MAC source clock 50MHz is "Inactive".1'b0: Clock frequency for MAC source clock 50MHz is "Active".
 *     SLEEP_MAC_250    Writing 1'b1 to this bit will stop MAC source clocks 250MHz for P7 and P8(IMP Port).1'b1: Clock frequency for MAC source clock 250MHz is "Inactive".1'b0: Clock frequency for MAC source clock 250MHz is "Active".
 *     SLEEP_SYS        Writing 1'b1 to this bit will stop system clock.1).Clock frequency for switch related logic is "Inactive".2).Clock frequency for core logic(included 8051/bcmregs/spi) is "Active".
 *     EN_LOW_POWER     low power enableWhen enabled, system clock will be switched to low power clock source based on the value of low_power_divider.
 *     TIMER_DISABLE    Disable timer1 = disable0 = enable(Not2Release)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_LOW_POWER_CTRLr 0x000000de

#define BCM53128_A0_LOW_POWER_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program LOW_POWER_CTRL.
 *
 */
typedef union BCM53128_A0_LOW_POWER_CTRLr_s {
	uint32_t v[1];
	uint32_t low_power_ctrl[1];
	uint32_t _low_power_ctrl;
} BCM53128_A0_LOW_POWER_CTRLr_t;

#define BCM53128_A0_LOW_POWER_CTRLr_CLR(r) (r).low_power_ctrl[0] = 0
#define BCM53128_A0_LOW_POWER_CTRLr_SET(r,d) (r).low_power_ctrl[0] = d
#define BCM53128_A0_LOW_POWER_CTRLr_GET(r) (r).low_power_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_GET(r) (((r).low_power_ctrl[0]) & 0xf)
#define BCM53128_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_50f_GET(r) ((((r).low_power_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_50f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_250f_GET(r) ((((r).low_power_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_250f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_LOW_POWER_CTRLr_SLEEP_SYSf_GET(r) ((((r).low_power_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_LOW_POWER_CTRLr_SLEEP_SYSf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_GET(r) ((((r).low_power_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_GET(r) ((((r).low_power_ctrl[0]) >> 8) & 0x1)
#define BCM53128_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_LOW_POWER_CTRLr_RESERVEDf_GET(r) ((((r).low_power_ctrl[0]) >> 9) & 0x7f)
#define BCM53128_A0_LOW_POWER_CTRLr_RESERVEDf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LOW_POWER_CTRL.
 *
 */
#define BCM53128_A0_READ_LOW_POWER_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LOW_POWER_CTRLr,(r._low_power_ctrl),2)
#define BCM53128_A0_WRITE_LOW_POWER_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LOW_POWER_CTRLr,&(r._low_power_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOW_POWER_CTRLr BCM53128_A0_LOW_POWER_CTRLr
#define LOW_POWER_CTRLr_SIZE BCM53128_A0_LOW_POWER_CTRLr_SIZE
typedef BCM53128_A0_LOW_POWER_CTRLr_t LOW_POWER_CTRLr_t;
#define LOW_POWER_CTRLr_CLR BCM53128_A0_LOW_POWER_CTRLr_CLR
#define LOW_POWER_CTRLr_SET BCM53128_A0_LOW_POWER_CTRLr_SET
#define LOW_POWER_CTRLr_GET BCM53128_A0_LOW_POWER_CTRLr_GET
#define LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_GET BCM53128_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_GET
#define LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_SET BCM53128_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_SET
#define LOW_POWER_CTRLr_SLEEP_MAC_50f_GET BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_50f_GET
#define LOW_POWER_CTRLr_SLEEP_MAC_50f_SET BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_50f_SET
#define LOW_POWER_CTRLr_SLEEP_MAC_250f_GET BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_250f_GET
#define LOW_POWER_CTRLr_SLEEP_MAC_250f_SET BCM53128_A0_LOW_POWER_CTRLr_SLEEP_MAC_250f_SET
#define LOW_POWER_CTRLr_SLEEP_SYSf_GET BCM53128_A0_LOW_POWER_CTRLr_SLEEP_SYSf_GET
#define LOW_POWER_CTRLr_SLEEP_SYSf_SET BCM53128_A0_LOW_POWER_CTRLr_SLEEP_SYSf_SET
#define LOW_POWER_CTRLr_EN_LOW_POWERf_GET BCM53128_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_GET
#define LOW_POWER_CTRLr_EN_LOW_POWERf_SET BCM53128_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_SET
#define LOW_POWER_CTRLr_TIMER_DISABLEf_GET BCM53128_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_GET
#define LOW_POWER_CTRLr_TIMER_DISABLEf_SET BCM53128_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_SET
#define LOW_POWER_CTRLr_RESERVEDf_GET BCM53128_A0_LOW_POWER_CTRLr_RESERVEDf_GET
#define LOW_POWER_CTRLr_RESERVEDf_SET BCM53128_A0_LOW_POWER_CTRLr_RESERVEDf_SET
#define READ_LOW_POWER_CTRLr BCM53128_A0_READ_LOW_POWER_CTRLr
#define WRITE_LOW_POWER_CTRLr BCM53128_A0_WRITE_LOW_POWER_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LOW_POWER_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LPDET_CFG
 * BLOCKS:   SYS
 * DESC:     Loop Detection Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     DFQ_SEL          specify which queue to be put for received discovery frame, default is Q1.
 *     OV_PAUSE_ON      1'b1: transmit frame in highest queue even the port is in pause on state(might not work if prefetch fifo is occupied by low-Q frame).1'b0: transmit frame follow the pause state rule.
 *     LED_RST_CTL      specify how many times we can miss discovery time before we reset LED_warning_portmap.
 *     LOOP_IMP_SEL     1'b1: IMP support loop detection feature.1'b0: IMP do not support loop detection feature.
 *     EN_LPDET         1'b1: enable loop detection feature.(Blackbird2 support for unmanaged mode only)1'b0: disable loop detection feature.
 *     EN_TXPASS        QOS_MODE at Page/Offset=30h/80h,bit3:2 MUST match to DFQ_SEL,bit1:0.HQ_Preempt at Page/Offset=30h/80h,bit4 MUST set to 1.1'b1:when EN_LPDET and act_loop_detect are active, LoopDetect frame would send out even if prefetch fifo is occupied by low-Q frame.1'b0:follow OV_PAUSE_ON(bit-2) setting.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_LPDET_CFGr 0x00007200

#define BCM53128_A0_LPDET_CFGr_SIZE 2

/*
 * This structure should be used to declare and program LPDET_CFG.
 *
 */
typedef union BCM53128_A0_LPDET_CFGr_s {
	uint32_t v[1];
	uint32_t lpdet_cfg[1];
	uint32_t _lpdet_cfg;
} BCM53128_A0_LPDET_CFGr_t;

#define BCM53128_A0_LPDET_CFGr_CLR(r) (r).lpdet_cfg[0] = 0
#define BCM53128_A0_LPDET_CFGr_SET(r,d) (r).lpdet_cfg[0] = d
#define BCM53128_A0_LPDET_CFGr_GET(r) (r).lpdet_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LPDET_CFGr_DFQ_SELf_GET(r) (((r).lpdet_cfg[0]) & 0x3)
#define BCM53128_A0_LPDET_CFGr_DFQ_SELf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_LPDET_CFGr_OV_PAUSE_ONf_GET(r) ((((r).lpdet_cfg[0]) >> 2) & 0x1)
#define BCM53128_A0_LPDET_CFGr_OV_PAUSE_ONf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_LPDET_CFGr_LED_RST_CTLf_GET(r) ((((r).lpdet_cfg[0]) >> 3) & 0xff)
#define BCM53128_A0_LPDET_CFGr_LED_RST_CTLf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM53128_A0_LPDET_CFGr_LOOP_IMP_SELf_GET(r) ((((r).lpdet_cfg[0]) >> 11) & 0x1)
#define BCM53128_A0_LPDET_CFGr_LOOP_IMP_SELf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_LPDET_CFGr_EN_LPDETf_GET(r) ((((r).lpdet_cfg[0]) >> 12) & 0x1)
#define BCM53128_A0_LPDET_CFGr_EN_LPDETf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53128_A0_LPDET_CFGr_EN_TXPASSf_GET(r) ((((r).lpdet_cfg[0]) >> 13) & 0x1)
#define BCM53128_A0_LPDET_CFGr_EN_TXPASSf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_LPDET_CFGr_RESERVEDf_GET(r) ((((r).lpdet_cfg[0]) >> 14) & 0x3)
#define BCM53128_A0_LPDET_CFGr_RESERVEDf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access LPDET_CFG.
 *
 */
#define BCM53128_A0_READ_LPDET_CFGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LPDET_CFGr,(r._lpdet_cfg),2)
#define BCM53128_A0_WRITE_LPDET_CFGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LPDET_CFGr,&(r._lpdet_cfg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_CFGr BCM53128_A0_LPDET_CFGr
#define LPDET_CFGr_SIZE BCM53128_A0_LPDET_CFGr_SIZE
typedef BCM53128_A0_LPDET_CFGr_t LPDET_CFGr_t;
#define LPDET_CFGr_CLR BCM53128_A0_LPDET_CFGr_CLR
#define LPDET_CFGr_SET BCM53128_A0_LPDET_CFGr_SET
#define LPDET_CFGr_GET BCM53128_A0_LPDET_CFGr_GET
#define LPDET_CFGr_DFQ_SELf_GET BCM53128_A0_LPDET_CFGr_DFQ_SELf_GET
#define LPDET_CFGr_DFQ_SELf_SET BCM53128_A0_LPDET_CFGr_DFQ_SELf_SET
#define LPDET_CFGr_OV_PAUSE_ONf_GET BCM53128_A0_LPDET_CFGr_OV_PAUSE_ONf_GET
#define LPDET_CFGr_OV_PAUSE_ONf_SET BCM53128_A0_LPDET_CFGr_OV_PAUSE_ONf_SET
#define LPDET_CFGr_LED_RST_CTLf_GET BCM53128_A0_LPDET_CFGr_LED_RST_CTLf_GET
#define LPDET_CFGr_LED_RST_CTLf_SET BCM53128_A0_LPDET_CFGr_LED_RST_CTLf_SET
#define LPDET_CFGr_LOOP_IMP_SELf_GET BCM53128_A0_LPDET_CFGr_LOOP_IMP_SELf_GET
#define LPDET_CFGr_LOOP_IMP_SELf_SET BCM53128_A0_LPDET_CFGr_LOOP_IMP_SELf_SET
#define LPDET_CFGr_EN_LPDETf_GET BCM53128_A0_LPDET_CFGr_EN_LPDETf_GET
#define LPDET_CFGr_EN_LPDETf_SET BCM53128_A0_LPDET_CFGr_EN_LPDETf_SET
#define LPDET_CFGr_EN_TXPASSf_GET BCM53128_A0_LPDET_CFGr_EN_TXPASSf_GET
#define LPDET_CFGr_EN_TXPASSf_SET BCM53128_A0_LPDET_CFGr_EN_TXPASSf_SET
#define LPDET_CFGr_RESERVEDf_GET BCM53128_A0_LPDET_CFGr_RESERVEDf_GET
#define LPDET_CFGr_RESERVEDf_SET BCM53128_A0_LPDET_CFGr_RESERVEDf_SET
#define READ_LPDET_CFGr BCM53128_A0_READ_LPDET_CFGr
#define WRITE_LPDET_CFGr BCM53128_A0_WRITE_LPDET_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LPDET_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LPDET_SA
 * BLOCKS:   SYS
 * DESC:     Loop Detect Frame SA Registers
 * SIZE:     48
 * FIELDS:
 *     LPDET_SA         Loop Detection Frame SA.
 *
 ******************************************************************************/
#define BCM53128_A0_LPDET_SAr 0x00007211

#define BCM53128_A0_LPDET_SAr_SIZE 6

/*
 * This structure should be used to declare and program LPDET_SA.
 *
 */
typedef union BCM53128_A0_LPDET_SAr_s {
	uint32_t v[2];
	uint32_t lpdet_sa[2];
	uint32_t _lpdet_sa;
} BCM53128_A0_LPDET_SAr_t;

#define BCM53128_A0_LPDET_SAr_CLR(r) CDK_MEMSET(&((r)._lpdet_sa), 0, sizeof(BCM53128_A0_LPDET_SAr_t))
#define BCM53128_A0_LPDET_SAr_SET(r,i,d) (r).lpdet_sa[i] = d
#define BCM53128_A0_LPDET_SAr_GET(r,i) (r).lpdet_sa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LPDET_SAr_LPDET_SAf_GET(r,a) cdk_field_get((r).lpdet_sa,0,47,a)
#define BCM53128_A0_LPDET_SAr_LPDET_SAf_SET(r,a) cdk_field_set((r).lpdet_sa,0,47,a)

/*
 * These macros can be used to access LPDET_SA.
 *
 */
#define BCM53128_A0_READ_LPDET_SAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LPDET_SAr,(r._lpdet_sa),6)
#define BCM53128_A0_WRITE_LPDET_SAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LPDET_SAr,&(r._lpdet_sa),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_SAr BCM53128_A0_LPDET_SAr
#define LPDET_SAr_SIZE BCM53128_A0_LPDET_SAr_SIZE
typedef BCM53128_A0_LPDET_SAr_t LPDET_SAr_t;
#define LPDET_SAr_CLR BCM53128_A0_LPDET_SAr_CLR
#define LPDET_SAr_SET BCM53128_A0_LPDET_SAr_SET
#define LPDET_SAr_GET BCM53128_A0_LPDET_SAr_GET
#define LPDET_SAr_LPDET_SAf_GET BCM53128_A0_LPDET_SAr_LPDET_SAf_GET
#define LPDET_SAr_LPDET_SAf_SET BCM53128_A0_LPDET_SAr_LPDET_SAf_SET
#define READ_LPDET_SAr BCM53128_A0_READ_LPDET_SAr
#define WRITE_LPDET_SAr BCM53128_A0_WRITE_LPDET_SAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LPDET_SAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LSA_MII_PORT
 * BLOCKS:   SYS
 * DESC:     Last Source Address MII Port
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address for IMP port. The 48-bit SA of the last received packet.
 *
 ******************************************************************************/
#define BCM53128_A0_LSA_MII_PORTr 0x00000140

#define BCM53128_A0_LSA_MII_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_MII_PORT.
 *
 */
typedef union BCM53128_A0_LSA_MII_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_mii_port[2];
	uint32_t _lsa_mii_port;
} BCM53128_A0_LSA_MII_PORTr_t;

#define BCM53128_A0_LSA_MII_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_mii_port), 0, sizeof(BCM53128_A0_LSA_MII_PORTr_t))
#define BCM53128_A0_LSA_MII_PORTr_SET(r,i,d) (r).lsa_mii_port[i] = d
#define BCM53128_A0_LSA_MII_PORTr_GET(r,i) (r).lsa_mii_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LSA_MII_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_mii_port,0,47,a)
#define BCM53128_A0_LSA_MII_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_mii_port,0,47,a)

/*
 * These macros can be used to access LSA_MII_PORT.
 *
 */
#define BCM53128_A0_READ_LSA_MII_PORTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_LSA_MII_PORTr,(r._lsa_mii_port),6)
#define BCM53128_A0_WRITE_LSA_MII_PORTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_LSA_MII_PORTr,&(r._lsa_mii_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_MII_PORTr BCM53128_A0_LSA_MII_PORTr
#define LSA_MII_PORTr_SIZE BCM53128_A0_LSA_MII_PORTr_SIZE
typedef BCM53128_A0_LSA_MII_PORTr_t LSA_MII_PORTr_t;
#define LSA_MII_PORTr_CLR BCM53128_A0_LSA_MII_PORTr_CLR
#define LSA_MII_PORTr_SET BCM53128_A0_LSA_MII_PORTr_SET
#define LSA_MII_PORTr_GET BCM53128_A0_LSA_MII_PORTr_GET
#define LSA_MII_PORTr_LST_ADDRf_GET BCM53128_A0_LSA_MII_PORTr_LST_ADDRf_GET
#define LSA_MII_PORTr_LST_ADDRf_SET BCM53128_A0_LSA_MII_PORTr_LST_ADDRf_SET
#define READ_LSA_MII_PORTr BCM53128_A0_READ_LSA_MII_PORTr
#define WRITE_LSA_MII_PORTr BCM53128_A0_WRITE_LSA_MII_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LSA_MII_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  LSA_PORT
 * BLOCKS:   CPIC GPIC0
 * DESC:     Last Source Address Port N
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address. The 48-bit SA of the last received packet.
 *
 ******************************************************************************/
#define BCM53128_A0_LSA_PORTr 0x00000110

#define BCM53128_A0_LSA_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_PORT.
 *
 */
typedef union BCM53128_A0_LSA_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_port[2];
	uint32_t _lsa_port;
} BCM53128_A0_LSA_PORTr_t;

#define BCM53128_A0_LSA_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_port), 0, sizeof(BCM53128_A0_LSA_PORTr_t))
#define BCM53128_A0_LSA_PORTr_SET(r,i,d) (r).lsa_port[i] = d
#define BCM53128_A0_LSA_PORTr_GET(r,i) (r).lsa_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_LSA_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_port,0,47,a)
#define BCM53128_A0_LSA_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_port,0,47,a)

/*
 * These macros can be used to access LSA_PORT.
 *
 */
#define BCM53128_A0_READ_LSA_PORTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_LSA_PORTr,(r._lsa_port),6)
#define BCM53128_A0_WRITE_LSA_PORTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_LSA_PORTr,&(r._lsa_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_PORTr BCM53128_A0_LSA_PORTr
#define LSA_PORTr_SIZE BCM53128_A0_LSA_PORTr_SIZE
typedef BCM53128_A0_LSA_PORTr_t LSA_PORTr_t;
#define LSA_PORTr_CLR BCM53128_A0_LSA_PORTr_CLR
#define LSA_PORTr_SET BCM53128_A0_LSA_PORTr_SET
#define LSA_PORTr_GET BCM53128_A0_LSA_PORTr_GET
#define LSA_PORTr_LST_ADDRf_GET BCM53128_A0_LSA_PORTr_LST_ADDRf_GET
#define LSA_PORTr_LST_ADDRf_SET BCM53128_A0_LSA_PORTr_LST_ADDRf_SET
#define READ_LSA_PORTr BCM53128_A0_READ_LSA_PORTr
#define WRITE_LSA_PORTr BCM53128_A0_WRITE_LSA_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_LSA_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MAC_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     MAC Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     HASH_SEL         index selection00 : use hash DA ^ SA) to generate index. ( default=0 )01 : use hash(DA) to generate index.10 : Use hash (SA) to generate index.
 *     SERVER_0         Reserved
 *     EN_TRUNK_LOCAL   Enable Mac trunking .Blackbird2  support 2 trunking groups. The trunking group can support up to 4 ports as defined trunking group register.
 *     SERVER_1         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MAC_TRUNK_CTLr 0x00003200

#define BCM53128_A0_MAC_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MAC_TRUNK_CTL.
 *
 */
typedef union BCM53128_A0_MAC_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t mac_trunk_ctl[1];
	uint32_t _mac_trunk_ctl;
} BCM53128_A0_MAC_TRUNK_CTLr_t;

#define BCM53128_A0_MAC_TRUNK_CTLr_CLR(r) (r).mac_trunk_ctl[0] = 0
#define BCM53128_A0_MAC_TRUNK_CTLr_SET(r,d) (r).mac_trunk_ctl[0] = d
#define BCM53128_A0_MAC_TRUNK_CTLr_GET(r) (r).mac_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MAC_TRUNK_CTLr_HASH_SELf_GET(r) (((r).mac_trunk_ctl[0]) & 0x3)
#define BCM53128_A0_MAC_TRUNK_CTLr_HASH_SELf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_MAC_TRUNK_CTLr_SERVER_0f_GET(r) ((((r).mac_trunk_ctl[0]) >> 2) & 0x1)
#define BCM53128_A0_MAC_TRUNK_CTLr_SERVER_0f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).mac_trunk_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_MAC_TRUNK_CTLr_SERVER_1f_GET(r) ((((r).mac_trunk_ctl[0]) >> 4) & 0xf)
#define BCM53128_A0_MAC_TRUNK_CTLr_SERVER_1f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access MAC_TRUNK_CTL.
 *
 */
#define BCM53128_A0_READ_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MAC_TRUNK_CTLr,(r._mac_trunk_ctl),1)
#define BCM53128_A0_WRITE_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MAC_TRUNK_CTLr,&(r._mac_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TRUNK_CTLr BCM53128_A0_MAC_TRUNK_CTLr
#define MAC_TRUNK_CTLr_SIZE BCM53128_A0_MAC_TRUNK_CTLr_SIZE
typedef BCM53128_A0_MAC_TRUNK_CTLr_t MAC_TRUNK_CTLr_t;
#define MAC_TRUNK_CTLr_CLR BCM53128_A0_MAC_TRUNK_CTLr_CLR
#define MAC_TRUNK_CTLr_SET BCM53128_A0_MAC_TRUNK_CTLr_SET
#define MAC_TRUNK_CTLr_GET BCM53128_A0_MAC_TRUNK_CTLr_GET
#define MAC_TRUNK_CTLr_HASH_SELf_GET BCM53128_A0_MAC_TRUNK_CTLr_HASH_SELf_GET
#define MAC_TRUNK_CTLr_HASH_SELf_SET BCM53128_A0_MAC_TRUNK_CTLr_HASH_SELf_SET
#define MAC_TRUNK_CTLr_SERVER_0f_GET BCM53128_A0_MAC_TRUNK_CTLr_SERVER_0f_GET
#define MAC_TRUNK_CTLr_SERVER_0f_SET BCM53128_A0_MAC_TRUNK_CTLr_SERVER_0f_SET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM53128_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM53128_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define MAC_TRUNK_CTLr_SERVER_1f_GET BCM53128_A0_MAC_TRUNK_CTLr_SERVER_1f_GET
#define MAC_TRUNK_CTLr_SERVER_1f_SET BCM53128_A0_MAC_TRUNK_CTLr_SERVER_1f_SET
#define READ_MAC_TRUNK_CTLr BCM53128_A0_READ_MAC_TRUNK_CTLr
#define WRITE_MAC_TRUNK_CTLr BCM53128_A0_WRITE_MAC_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MAC_TRUNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  MARL_PBMP
 * BLOCKS:   SYS
 * DESC:     Multicast Table
 * SIZE:     29
 * FIELDS:
 *     PBMP             Multicast forwarding vector
 *
 ******************************************************************************/
#define BCM53128_A0_MARL_PBMPm 0x00000000

#define BCM53128_A0_MARL_PBMPm_MIN 0
#define BCM53128_A0_MARL_PBMPm_MAX 4095
#define BCM53128_A0_MARL_PBMPm_CMAX(u) 4095
#define BCM53128_A0_MARL_PBMPm_SIZE 4

/*
 * This structure should be used to declare and program MARL_PBMP.
 *
 */
typedef union BCM53128_A0_MARL_PBMPm_s {
	uint32_t v[1];
	uint32_t marl_pbmp[1];
	uint32_t _marl_pbmp;
} BCM53128_A0_MARL_PBMPm_t;

#define BCM53128_A0_MARL_PBMPm_CLR(r) (r).marl_pbmp[0] = 0
#define BCM53128_A0_MARL_PBMPm_SET(r,d) (r).marl_pbmp[0] = d
#define BCM53128_A0_MARL_PBMPm_GET(r) (r).marl_pbmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MARL_PBMPm_PBMPf_GET(r) (((r).marl_pbmp[0]) & 0x1fffffff)
#define BCM53128_A0_MARL_PBMPm_PBMPf_SET(r,f) (r).marl_pbmp[0]=(((r).marl_pbmp[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access MARL_PBMP.
 *
 */
#define BCM53128_A0_READ_MARL_PBMPm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_MARL_PBMPm,i,(m),4)
#define BCM53128_A0_WRITE_MARL_PBMPm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_MARL_PBMPm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARL_PBMPm BCM53128_A0_MARL_PBMPm
#define MARL_PBMPm_MIN BCM53128_A0_MARL_PBMPm_MIN
#define MARL_PBMPm_MAX BCM53128_A0_MARL_PBMPm_MAX
#define MARL_PBMPm_CMAX(u) BCM53128_A0_MARL_PBMPm_CMAX(u)
#define MARL_PBMPm_SIZE BCM53128_A0_MARL_PBMPm_SIZE
typedef BCM53128_A0_MARL_PBMPm_t MARL_PBMPm_t;
#define MARL_PBMPm_CLR BCM53128_A0_MARL_PBMPm_CLR
#define MARL_PBMPm_SET BCM53128_A0_MARL_PBMPm_SET
#define MARL_PBMPm_GET BCM53128_A0_MARL_PBMPm_GET
#define MARL_PBMPm_PBMPf_GET BCM53128_A0_MARL_PBMPm_PBMPf_GET
#define MARL_PBMPm_PBMPf_SET BCM53128_A0_MARL_PBMPm_PBMPf_SET
#define READ_MARL_PBMPm BCM53128_A0_READ_MARL_PBMPm
#define WRITE_MARL_PBMPm BCM53128_A0_WRITE_MARL_PBMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MARL_PBMPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MAX_ICMPV4_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv4 Size Register
 * SIZE:     16
 * FIELDS:
 *     MAX_ICMPV4_SIZE  MAX_ICMPv4_Size is programable between 0 and 9.6K bytes, inclusive. The default value is set to 512 bytes.
 *
 ******************************************************************************/
#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr 0x00003608

#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr_SIZE 2

/*
 * This structure should be used to declare and program MAX_ICMPV4_SIZE_REG.
 *
 */
typedef union BCM53128_A0_MAX_ICMPV4_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv4_size_reg[1];
	uint32_t _max_icmpv4_size_reg;
} BCM53128_A0_MAX_ICMPV4_SIZE_REGr_t;

#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr_CLR(r) (r).max_icmpv4_size_reg[0] = 0
#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr_SET(r,d) (r).max_icmpv4_size_reg[0] = d
#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr_GET(r) (r).max_icmpv4_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET(r) (((r).max_icmpv4_size_reg[0]) & 0xffff)
#define BCM53128_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET(r,f) (r).max_icmpv4_size_reg[0]=(((r).max_icmpv4_size_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MAX_ICMPV4_SIZE_REG.
 *
 */
#define BCM53128_A0_READ_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MAX_ICMPV4_SIZE_REGr,(r._max_icmpv4_size_reg),2)
#define BCM53128_A0_WRITE_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MAX_ICMPV4_SIZE_REGr,&(r._max_icmpv4_size_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV4_SIZE_REGr BCM53128_A0_MAX_ICMPV4_SIZE_REGr
#define MAX_ICMPV4_SIZE_REGr_SIZE BCM53128_A0_MAX_ICMPV4_SIZE_REGr_SIZE
typedef BCM53128_A0_MAX_ICMPV4_SIZE_REGr_t MAX_ICMPV4_SIZE_REGr_t;
#define MAX_ICMPV4_SIZE_REGr_CLR BCM53128_A0_MAX_ICMPV4_SIZE_REGr_CLR
#define MAX_ICMPV4_SIZE_REGr_SET BCM53128_A0_MAX_ICMPV4_SIZE_REGr_SET
#define MAX_ICMPV4_SIZE_REGr_GET BCM53128_A0_MAX_ICMPV4_SIZE_REGr_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET BCM53128_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET BCM53128_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET
#define READ_MAX_ICMPV4_SIZE_REGr BCM53128_A0_READ_MAX_ICMPV4_SIZE_REGr
#define WRITE_MAX_ICMPV4_SIZE_REGr BCM53128_A0_WRITE_MAX_ICMPV4_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MAX_ICMPV4_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MAX_ICMPV6_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv6 Size Register
 * SIZE:     16
 * FIELDS:
 *     MAX_ICMPV6_SIZE  MAX_ICMPv6_Size is programable between 0 and 9.6K bytes, inclusive. The default value is set to 512 bytes.
 *
 ******************************************************************************/
#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr 0x0000360c

#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr_SIZE 2

/*
 * This structure should be used to declare and program MAX_ICMPV6_SIZE_REG.
 *
 */
typedef union BCM53128_A0_MAX_ICMPV6_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv6_size_reg[1];
	uint32_t _max_icmpv6_size_reg;
} BCM53128_A0_MAX_ICMPV6_SIZE_REGr_t;

#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr_CLR(r) (r).max_icmpv6_size_reg[0] = 0
#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr_SET(r,d) (r).max_icmpv6_size_reg[0] = d
#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr_GET(r) (r).max_icmpv6_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET(r) (((r).max_icmpv6_size_reg[0]) & 0xffff)
#define BCM53128_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET(r,f) (r).max_icmpv6_size_reg[0]=(((r).max_icmpv6_size_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MAX_ICMPV6_SIZE_REG.
 *
 */
#define BCM53128_A0_READ_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MAX_ICMPV6_SIZE_REGr,(r._max_icmpv6_size_reg),2)
#define BCM53128_A0_WRITE_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MAX_ICMPV6_SIZE_REGr,&(r._max_icmpv6_size_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV6_SIZE_REGr BCM53128_A0_MAX_ICMPV6_SIZE_REGr
#define MAX_ICMPV6_SIZE_REGr_SIZE BCM53128_A0_MAX_ICMPV6_SIZE_REGr_SIZE
typedef BCM53128_A0_MAX_ICMPV6_SIZE_REGr_t MAX_ICMPV6_SIZE_REGr_t;
#define MAX_ICMPV6_SIZE_REGr_CLR BCM53128_A0_MAX_ICMPV6_SIZE_REGr_CLR
#define MAX_ICMPV6_SIZE_REGr_SET BCM53128_A0_MAX_ICMPV6_SIZE_REGr_SET
#define MAX_ICMPV6_SIZE_REGr_GET BCM53128_A0_MAX_ICMPV6_SIZE_REGr_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET BCM53128_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET BCM53128_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET
#define READ_MAX_ICMPV6_SIZE_REGr BCM53128_A0_READ_MAX_ICMPV6_SIZE_REGr
#define WRITE_MAX_ICMPV6_SIZE_REGr BCM53128_A0_WRITE_MAX_ICMPV6_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MAX_ICMPV6_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MDIO_IMP_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO Port IMP Address Register
 * SIZE:     8
 * FIELDS:
 *     ADDR_IMP         Port IMP MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MDIO_IMP_ADDRr 0x00000078

#define BCM53128_A0_MDIO_IMP_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_IMP_ADDR.
 *
 */
typedef union BCM53128_A0_MDIO_IMP_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_imp_addr[1];
	uint32_t _mdio_imp_addr;
} BCM53128_A0_MDIO_IMP_ADDRr_t;

#define BCM53128_A0_MDIO_IMP_ADDRr_CLR(r) (r).mdio_imp_addr[0] = 0
#define BCM53128_A0_MDIO_IMP_ADDRr_SET(r,d) (r).mdio_imp_addr[0] = d
#define BCM53128_A0_MDIO_IMP_ADDRr_GET(r) (r).mdio_imp_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MDIO_IMP_ADDRr_ADDR_IMPf_GET(r) (((r).mdio_imp_addr[0]) & 0x1f)
#define BCM53128_A0_MDIO_IMP_ADDRr_ADDR_IMPf_SET(r,f) (r).mdio_imp_addr[0]=(((r).mdio_imp_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_MDIO_IMP_ADDRr_RESERVEDf_GET(r) ((((r).mdio_imp_addr[0]) >> 5) & 0x7)
#define BCM53128_A0_MDIO_IMP_ADDRr_RESERVEDf_SET(r,f) (r).mdio_imp_addr[0]=(((r).mdio_imp_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_IMP_ADDR.
 *
 */
#define BCM53128_A0_READ_MDIO_IMP_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MDIO_IMP_ADDRr,(r._mdio_imp_addr),1)
#define BCM53128_A0_WRITE_MDIO_IMP_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MDIO_IMP_ADDRr,&(r._mdio_imp_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_IMP_ADDRr BCM53128_A0_MDIO_IMP_ADDRr
#define MDIO_IMP_ADDRr_SIZE BCM53128_A0_MDIO_IMP_ADDRr_SIZE
typedef BCM53128_A0_MDIO_IMP_ADDRr_t MDIO_IMP_ADDRr_t;
#define MDIO_IMP_ADDRr_CLR BCM53128_A0_MDIO_IMP_ADDRr_CLR
#define MDIO_IMP_ADDRr_SET BCM53128_A0_MDIO_IMP_ADDRr_SET
#define MDIO_IMP_ADDRr_GET BCM53128_A0_MDIO_IMP_ADDRr_GET
#define MDIO_IMP_ADDRr_ADDR_IMPf_GET BCM53128_A0_MDIO_IMP_ADDRr_ADDR_IMPf_GET
#define MDIO_IMP_ADDRr_ADDR_IMPf_SET BCM53128_A0_MDIO_IMP_ADDRr_ADDR_IMPf_SET
#define MDIO_IMP_ADDRr_RESERVEDf_GET BCM53128_A0_MDIO_IMP_ADDRr_RESERVEDf_GET
#define MDIO_IMP_ADDRr_RESERVEDf_SET BCM53128_A0_MDIO_IMP_ADDRr_RESERVEDf_SET
#define READ_MDIO_IMP_ADDRr BCM53128_A0_READ_MDIO_IMP_ADDRr
#define WRITE_MDIO_IMP_ADDRr BCM53128_A0_WRITE_MDIO_IMP_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MDIO_IMP_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MDIO_PORT7_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO Port7 Address Register
 * SIZE:     8
 * FIELDS:
 *     ADDR_PORT7       Port7 MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MDIO_PORT7_ADDRr 0x00000077

#define BCM53128_A0_MDIO_PORT7_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_PORT7_ADDR.
 *
 */
typedef union BCM53128_A0_MDIO_PORT7_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_port7_addr[1];
	uint32_t _mdio_port7_addr;
} BCM53128_A0_MDIO_PORT7_ADDRr_t;

#define BCM53128_A0_MDIO_PORT7_ADDRr_CLR(r) (r).mdio_port7_addr[0] = 0
#define BCM53128_A0_MDIO_PORT7_ADDRr_SET(r,d) (r).mdio_port7_addr[0] = d
#define BCM53128_A0_MDIO_PORT7_ADDRr_GET(r) (r).mdio_port7_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MDIO_PORT7_ADDRr_ADDR_PORT7f_GET(r) (((r).mdio_port7_addr[0]) & 0x1f)
#define BCM53128_A0_MDIO_PORT7_ADDRr_ADDR_PORT7f_SET(r,f) (r).mdio_port7_addr[0]=(((r).mdio_port7_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_MDIO_PORT7_ADDRr_RESERVEDf_GET(r) ((((r).mdio_port7_addr[0]) >> 5) & 0x7)
#define BCM53128_A0_MDIO_PORT7_ADDRr_RESERVEDf_SET(r,f) (r).mdio_port7_addr[0]=(((r).mdio_port7_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_PORT7_ADDR.
 *
 */
#define BCM53128_A0_READ_MDIO_PORT7_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MDIO_PORT7_ADDRr,(r._mdio_port7_addr),1)
#define BCM53128_A0_WRITE_MDIO_PORT7_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MDIO_PORT7_ADDRr,&(r._mdio_port7_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_PORT7_ADDRr BCM53128_A0_MDIO_PORT7_ADDRr
#define MDIO_PORT7_ADDRr_SIZE BCM53128_A0_MDIO_PORT7_ADDRr_SIZE
typedef BCM53128_A0_MDIO_PORT7_ADDRr_t MDIO_PORT7_ADDRr_t;
#define MDIO_PORT7_ADDRr_CLR BCM53128_A0_MDIO_PORT7_ADDRr_CLR
#define MDIO_PORT7_ADDRr_SET BCM53128_A0_MDIO_PORT7_ADDRr_SET
#define MDIO_PORT7_ADDRr_GET BCM53128_A0_MDIO_PORT7_ADDRr_GET
#define MDIO_PORT7_ADDRr_ADDR_PORT7f_GET BCM53128_A0_MDIO_PORT7_ADDRr_ADDR_PORT7f_GET
#define MDIO_PORT7_ADDRr_ADDR_PORT7f_SET BCM53128_A0_MDIO_PORT7_ADDRr_ADDR_PORT7f_SET
#define MDIO_PORT7_ADDRr_RESERVEDf_GET BCM53128_A0_MDIO_PORT7_ADDRr_RESERVEDf_GET
#define MDIO_PORT7_ADDRr_RESERVEDf_SET BCM53128_A0_MDIO_PORT7_ADDRr_RESERVEDf_SET
#define READ_MDIO_PORT7_ADDRr BCM53128_A0_READ_MDIO_PORT7_ADDRr
#define WRITE_MDIO_PORT7_ADDRr BCM53128_A0_WRITE_MDIO_PORT7_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MDIO_PORT7_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEMORY_TEST_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     ARL_TM           TM control[7:0] for ARL Table, AT0 and AT1
 *     BT_TM            TM control[7:0] for Buffer Tag, BT
 *     PB_TM            TM control[7:0] for Packet Buffer, PB
 *     TXQ_TM           TM control[7:0] for Transmit Queue, TXQ
 *     VT_TM            TM control[3:0] for VLAN Table, VT
 *     RESERVED0        Reserved
 *     CPU_RAM_TM       TM control [7:0] for 8051 RAM
 *     CPU_ROM_TM       TM control [4:0] for 8051 ROM
 *     RESERVED1        Reserved
 *     OTP_CPU_IF_EN    Enable OTP CPU Interface
 *
 ******************************************************************************/
#define BCM53128_A0_MEMORY_TEST_CTRLr 0x000000e0

#define BCM53128_A0_MEMORY_TEST_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MEMORY_TEST_CTRL.
 *
 */
typedef union BCM53128_A0_MEMORY_TEST_CTRLr_s {
	uint32_t v[2];
	uint32_t memory_test_ctrl[2];
	uint32_t _memory_test_ctrl;
} BCM53128_A0_MEMORY_TEST_CTRLr_t;

#define BCM53128_A0_MEMORY_TEST_CTRLr_CLR(r) CDK_MEMSET(&((r)._memory_test_ctrl), 0, sizeof(BCM53128_A0_MEMORY_TEST_CTRLr_t))
#define BCM53128_A0_MEMORY_TEST_CTRLr_SET(r,i,d) (r).memory_test_ctrl[i] = d
#define BCM53128_A0_MEMORY_TEST_CTRLr_GET(r,i) (r).memory_test_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEMORY_TEST_CTRLr_ARL_TMf_GET(r) (((r).memory_test_ctrl[0]) & 0xff)
#define BCM53128_A0_MEMORY_TEST_CTRLr_ARL_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_MEMORY_TEST_CTRLr_BT_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 8) & 0xff)
#define BCM53128_A0_MEMORY_TEST_CTRLr_BT_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53128_A0_MEMORY_TEST_CTRLr_PB_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 16) & 0xff)
#define BCM53128_A0_MEMORY_TEST_CTRLr_PB_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53128_A0_MEMORY_TEST_CTRLr_TXQ_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 24) & 0xff)
#define BCM53128_A0_MEMORY_TEST_CTRLr_TXQ_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53128_A0_MEMORY_TEST_CTRLr_VT_TMf_GET(r) (((r).memory_test_ctrl[1]) & 0xf)
#define BCM53128_A0_MEMORY_TEST_CTRLr_VT_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED0f_GET(r) ((((r).memory_test_ctrl[1]) >> 4) & 0xfff)
#define BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED0f_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53128_A0_MEMORY_TEST_CTRLr_CPU_RAM_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 16) & 0xff)
#define BCM53128_A0_MEMORY_TEST_CTRLr_CPU_RAM_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53128_A0_MEMORY_TEST_CTRLr_CPU_ROM_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 24) & 0x1f)
#define BCM53128_A0_MEMORY_TEST_CTRLr_CPU_ROM_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED1f_GET(r) ((((r).memory_test_ctrl[1]) >> 29) & 0x3)
#define BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED1f_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53128_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET(r) ((((r).memory_test_ctrl[1]) >> 31) & 0x1)
#define BCM53128_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MEMORY_TEST_CTRL.
 *
 */
#define BCM53128_A0_READ_MEMORY_TEST_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEMORY_TEST_CTRLr,(r._memory_test_ctrl),8)
#define BCM53128_A0_WRITE_MEMORY_TEST_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEMORY_TEST_CTRLr,&(r._memory_test_ctrl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMORY_TEST_CTRLr BCM53128_A0_MEMORY_TEST_CTRLr
#define MEMORY_TEST_CTRLr_SIZE BCM53128_A0_MEMORY_TEST_CTRLr_SIZE
typedef BCM53128_A0_MEMORY_TEST_CTRLr_t MEMORY_TEST_CTRLr_t;
#define MEMORY_TEST_CTRLr_CLR BCM53128_A0_MEMORY_TEST_CTRLr_CLR
#define MEMORY_TEST_CTRLr_SET BCM53128_A0_MEMORY_TEST_CTRLr_SET
#define MEMORY_TEST_CTRLr_GET BCM53128_A0_MEMORY_TEST_CTRLr_GET
#define MEMORY_TEST_CTRLr_ARL_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_ARL_TMf_GET
#define MEMORY_TEST_CTRLr_ARL_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_ARL_TMf_SET
#define MEMORY_TEST_CTRLr_BT_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_BT_TMf_GET
#define MEMORY_TEST_CTRLr_BT_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_BT_TMf_SET
#define MEMORY_TEST_CTRLr_PB_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_PB_TMf_GET
#define MEMORY_TEST_CTRLr_PB_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_PB_TMf_SET
#define MEMORY_TEST_CTRLr_TXQ_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_TXQ_TMf_GET
#define MEMORY_TEST_CTRLr_TXQ_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_TXQ_TMf_SET
#define MEMORY_TEST_CTRLr_VT_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_VT_TMf_GET
#define MEMORY_TEST_CTRLr_VT_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_VT_TMf_SET
#define MEMORY_TEST_CTRLr_RESERVED0f_GET BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED0f_GET
#define MEMORY_TEST_CTRLr_RESERVED0f_SET BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED0f_SET
#define MEMORY_TEST_CTRLr_CPU_RAM_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_CPU_RAM_TMf_GET
#define MEMORY_TEST_CTRLr_CPU_RAM_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_CPU_RAM_TMf_SET
#define MEMORY_TEST_CTRLr_CPU_ROM_TMf_GET BCM53128_A0_MEMORY_TEST_CTRLr_CPU_ROM_TMf_GET
#define MEMORY_TEST_CTRLr_CPU_ROM_TMf_SET BCM53128_A0_MEMORY_TEST_CTRLr_CPU_ROM_TMf_SET
#define MEMORY_TEST_CTRLr_RESERVED1f_GET BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED1f_GET
#define MEMORY_TEST_CTRLr_RESERVED1f_SET BCM53128_A0_MEMORY_TEST_CTRLr_RESERVED1f_SET
#define MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET BCM53128_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET
#define MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET BCM53128_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET
#define READ_MEMORY_TEST_CTRLr BCM53128_A0_READ_MEMORY_TEST_CTRLr
#define WRITE_MEMORY_TEST_CTRLr BCM53128_A0_WRITE_MEMORY_TEST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEMORY_TEST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_ADDR
 * BLOCKS:   SYS
 * DESC:     Memory Debug Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_ADDRr 0x00000801

#define BCM53128_A0_MEM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR.
 *
 */
typedef union BCM53128_A0_MEM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_addr[1];
	uint32_t _mem_addr;
} BCM53128_A0_MEM_ADDRr_t;

#define BCM53128_A0_MEM_ADDRr_CLR(r) (r).mem_addr[0] = 0
#define BCM53128_A0_MEM_ADDRr_SET(r,d) (r).mem_addr[0] = d
#define BCM53128_A0_MEM_ADDRr_GET(r) (r).mem_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_ADDRr_MEM_ADRf_GET(r) (((r).mem_addr[0]) & 0x3fff)
#define BCM53128_A0_MEM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53128_A0_MEM_ADDRr_MEM_RWf_GET(r) ((((r).mem_addr[0]) >> 14) & 0x1)
#define BCM53128_A0_MEM_ADDRr_MEM_RWf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_MEM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_addr[0]) >> 15) & 0x1)
#define BCM53128_A0_MEM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_ADDR.
 *
 */
#define BCM53128_A0_READ_MEM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_ADDRr,(r._mem_addr),2)
#define BCM53128_A0_WRITE_MEM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_ADDRr,&(r._mem_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDRr BCM53128_A0_MEM_ADDRr
#define MEM_ADDRr_SIZE BCM53128_A0_MEM_ADDRr_SIZE
typedef BCM53128_A0_MEM_ADDRr_t MEM_ADDRr_t;
#define MEM_ADDRr_CLR BCM53128_A0_MEM_ADDRr_CLR
#define MEM_ADDRr_SET BCM53128_A0_MEM_ADDRr_SET
#define MEM_ADDRr_GET BCM53128_A0_MEM_ADDRr_GET
#define MEM_ADDRr_MEM_ADRf_GET BCM53128_A0_MEM_ADDRr_MEM_ADRf_GET
#define MEM_ADDRr_MEM_ADRf_SET BCM53128_A0_MEM_ADDRr_MEM_ADRf_SET
#define MEM_ADDRr_MEM_RWf_GET BCM53128_A0_MEM_ADDRr_MEM_RWf_GET
#define MEM_ADDRr_MEM_RWf_SET BCM53128_A0_MEM_ADDRr_MEM_RWf_SET
#define MEM_ADDRr_MEM_STDNf_GET BCM53128_A0_MEM_ADDRr_MEM_STDNf_GET
#define MEM_ADDRr_MEM_STDNf_SET BCM53128_A0_MEM_ADDRr_MEM_STDNf_SET
#define READ_MEM_ADDRr BCM53128_A0_READ_MEM_ADDRr
#define WRITE_MEM_ADDRr BCM53128_A0_WRITE_MEM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_BFC_ADDR
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     BFC_ADDR         Specifies the next memmory address to read or write.
 *     RW_CTRL          '1' causes read operation while '0' is for write operation.
 *     MEM_REQ          Initiates the read/write operation for the Buffer Control memmory.The bit will clear one the Read/write Operation is completed.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_BFC_ADDRr 0x00000860

#define BCM53128_A0_MEM_BFC_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_BFC_ADDR.
 *
 */
typedef union BCM53128_A0_MEM_BFC_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_bfc_addr[1];
	uint32_t _mem_bfc_addr;
} BCM53128_A0_MEM_BFC_ADDRr_t;

#define BCM53128_A0_MEM_BFC_ADDRr_CLR(r) (r).mem_bfc_addr[0] = 0
#define BCM53128_A0_MEM_BFC_ADDRr_SET(r,d) (r).mem_bfc_addr[0] = d
#define BCM53128_A0_MEM_BFC_ADDRr_GET(r) (r).mem_bfc_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET(r) (((r).mem_bfc_addr[0]) & 0x3fff)
#define BCM53128_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53128_A0_MEM_BFC_ADDRr_RW_CTRLf_GET(r) ((((r).mem_bfc_addr[0]) >> 14) & 0x1)
#define BCM53128_A0_MEM_BFC_ADDRr_RW_CTRLf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_MEM_BFC_ADDRr_MEM_REQf_GET(r) ((((r).mem_bfc_addr[0]) >> 15) & 0x1)
#define BCM53128_A0_MEM_BFC_ADDRr_MEM_REQf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_BFC_ADDR.
 *
 */
#define BCM53128_A0_READ_MEM_BFC_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_BFC_ADDRr,(r._mem_bfc_addr),2)
#define BCM53128_A0_WRITE_MEM_BFC_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_BFC_ADDRr,&(r._mem_bfc_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_ADDRr BCM53128_A0_MEM_BFC_ADDRr
#define MEM_BFC_ADDRr_SIZE BCM53128_A0_MEM_BFC_ADDRr_SIZE
typedef BCM53128_A0_MEM_BFC_ADDRr_t MEM_BFC_ADDRr_t;
#define MEM_BFC_ADDRr_CLR BCM53128_A0_MEM_BFC_ADDRr_CLR
#define MEM_BFC_ADDRr_SET BCM53128_A0_MEM_BFC_ADDRr_SET
#define MEM_BFC_ADDRr_GET BCM53128_A0_MEM_BFC_ADDRr_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_GET BCM53128_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_SET BCM53128_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET
#define MEM_BFC_ADDRr_RW_CTRLf_GET BCM53128_A0_MEM_BFC_ADDRr_RW_CTRLf_GET
#define MEM_BFC_ADDRr_RW_CTRLf_SET BCM53128_A0_MEM_BFC_ADDRr_RW_CTRLf_SET
#define MEM_BFC_ADDRr_MEM_REQf_GET BCM53128_A0_MEM_BFC_ADDRr_MEM_REQf_GET
#define MEM_BFC_ADDRr_MEM_REQf_SET BCM53128_A0_MEM_BFC_ADDRr_MEM_REQf_SET
#define READ_MEM_BFC_ADDRr BCM53128_A0_READ_MEM_BFC_ADDRr
#define WRITE_MEM_BFC_ADDRr BCM53128_A0_WRITE_MEM_BFC_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_BFC_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_BFC_DATA
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Data Register
 * SIZE:     64
 * FIELDS:
 *     BFC_DATA         Privides the read from the Buffer Control memmory[63:0].
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_BFC_DATAr 0x00000862

#define BCM53128_A0_MEM_BFC_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_BFC_DATA.
 *
 */
typedef union BCM53128_A0_MEM_BFC_DATAr_s {
	uint32_t v[2];
	uint32_t mem_bfc_data[2];
	uint32_t _mem_bfc_data;
} BCM53128_A0_MEM_BFC_DATAr_t;

#define BCM53128_A0_MEM_BFC_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_bfc_data), 0, sizeof(BCM53128_A0_MEM_BFC_DATAr_t))
#define BCM53128_A0_MEM_BFC_DATAr_SET(r,i,d) (r).mem_bfc_data[i] = d
#define BCM53128_A0_MEM_BFC_DATAr_GET(r,i) (r).mem_bfc_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_BFC_DATAr_BFC_DATAf_GET(r,a) cdk_field_get((r).mem_bfc_data,0,63,a)
#define BCM53128_A0_MEM_BFC_DATAr_BFC_DATAf_SET(r,a) cdk_field_set((r).mem_bfc_data,0,63,a)

/*
 * These macros can be used to access MEM_BFC_DATA.
 *
 */
#define BCM53128_A0_READ_MEM_BFC_DATAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_BFC_DATAr,(r._mem_bfc_data),8)
#define BCM53128_A0_WRITE_MEM_BFC_DATAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_BFC_DATAr,&(r._mem_bfc_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_DATAr BCM53128_A0_MEM_BFC_DATAr
#define MEM_BFC_DATAr_SIZE BCM53128_A0_MEM_BFC_DATAr_SIZE
typedef BCM53128_A0_MEM_BFC_DATAr_t MEM_BFC_DATAr_t;
#define MEM_BFC_DATAr_CLR BCM53128_A0_MEM_BFC_DATAr_CLR
#define MEM_BFC_DATAr_SET BCM53128_A0_MEM_BFC_DATAr_SET
#define MEM_BFC_DATAr_GET BCM53128_A0_MEM_BFC_DATAr_GET
#define MEM_BFC_DATAr_BFC_DATAf_GET BCM53128_A0_MEM_BFC_DATAr_BFC_DATAf_GET
#define MEM_BFC_DATAr_BFC_DATAf_SET BCM53128_A0_MEM_BFC_DATAr_BFC_DATAf_SET
#define READ_MEM_BFC_DATAr BCM53128_A0_READ_MEM_BFC_DATAr
#define WRITE_MEM_BFC_DATAr BCM53128_A0_WRITE_MEM_BFC_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_BFC_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_BTM_DATA0
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 0
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[63:0]Note: Buffer Tag Memory Register Only For Read.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_BTM_DATA0r 0x00000850

#define BCM53128_A0_MEM_BTM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_BTM_DATA0.
 *
 */
typedef union BCM53128_A0_MEM_BTM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_btm_data0[2];
	uint32_t _mem_btm_data0;
} BCM53128_A0_MEM_BTM_DATA0r_t;

#define BCM53128_A0_MEM_BTM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_btm_data0), 0, sizeof(BCM53128_A0_MEM_BTM_DATA0r_t))
#define BCM53128_A0_MEM_BTM_DATA0r_SET(r,i,d) (r).mem_btm_data0[i] = d
#define BCM53128_A0_MEM_BTM_DATA0r_GET(r,i) (r).mem_btm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_BTM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_btm_data0,0,63,a)
#define BCM53128_A0_MEM_BTM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_btm_data0,0,63,a)

/*
 * These macros can be used to access MEM_BTM_DATA0.
 *
 */
#define BCM53128_A0_READ_MEM_BTM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_BTM_DATA0r,(r._mem_btm_data0),8)
#define BCM53128_A0_WRITE_MEM_BTM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_BTM_DATA0r,&(r._mem_btm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA0r BCM53128_A0_MEM_BTM_DATA0r
#define MEM_BTM_DATA0r_SIZE BCM53128_A0_MEM_BTM_DATA0r_SIZE
typedef BCM53128_A0_MEM_BTM_DATA0r_t MEM_BTM_DATA0r_t;
#define MEM_BTM_DATA0r_CLR BCM53128_A0_MEM_BTM_DATA0r_CLR
#define MEM_BTM_DATA0r_SET BCM53128_A0_MEM_BTM_DATA0r_SET
#define MEM_BTM_DATA0r_GET BCM53128_A0_MEM_BTM_DATA0r_GET
#define MEM_BTM_DATA0r_MEM_DATAf_GET BCM53128_A0_MEM_BTM_DATA0r_MEM_DATAf_GET
#define MEM_BTM_DATA0r_MEM_DATAf_SET BCM53128_A0_MEM_BTM_DATA0r_MEM_DATAf_SET
#define READ_MEM_BTM_DATA0r BCM53128_A0_READ_MEM_BTM_DATA0r
#define WRITE_MEM_BTM_DATA0r BCM53128_A0_WRITE_MEM_BTM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_BTM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_BTM_DATA1
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 1
 * SIZE:     16
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[77:64]Note: Buffer Tag Memory Register Only For Read.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_BTM_DATA1r 0x00000858

#define BCM53128_A0_MEM_BTM_DATA1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_BTM_DATA1.
 *
 */
typedef union BCM53128_A0_MEM_BTM_DATA1r_s {
	uint32_t v[1];
	uint32_t mem_btm_data1[1];
	uint32_t _mem_btm_data1;
} BCM53128_A0_MEM_BTM_DATA1r_t;

#define BCM53128_A0_MEM_BTM_DATA1r_CLR(r) (r).mem_btm_data1[0] = 0
#define BCM53128_A0_MEM_BTM_DATA1r_SET(r,d) (r).mem_btm_data1[0] = d
#define BCM53128_A0_MEM_BTM_DATA1r_GET(r) (r).mem_btm_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_BTM_DATA1r_MEM_DATAf_GET(r) (((r).mem_btm_data1[0]) & 0x3fff)
#define BCM53128_A0_MEM_BTM_DATA1r_MEM_DATAf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53128_A0_MEM_BTM_DATA1r_RESERVEDf_GET(r) ((((r).mem_btm_data1[0]) >> 14) & 0x3)
#define BCM53128_A0_MEM_BTM_DATA1r_RESERVEDf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access MEM_BTM_DATA1.
 *
 */
#define BCM53128_A0_READ_MEM_BTM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_BTM_DATA1r,(r._mem_btm_data1),2)
#define BCM53128_A0_WRITE_MEM_BTM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_BTM_DATA1r,&(r._mem_btm_data1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA1r BCM53128_A0_MEM_BTM_DATA1r
#define MEM_BTM_DATA1r_SIZE BCM53128_A0_MEM_BTM_DATA1r_SIZE
typedef BCM53128_A0_MEM_BTM_DATA1r_t MEM_BTM_DATA1r_t;
#define MEM_BTM_DATA1r_CLR BCM53128_A0_MEM_BTM_DATA1r_CLR
#define MEM_BTM_DATA1r_SET BCM53128_A0_MEM_BTM_DATA1r_SET
#define MEM_BTM_DATA1r_GET BCM53128_A0_MEM_BTM_DATA1r_GET
#define MEM_BTM_DATA1r_MEM_DATAf_GET BCM53128_A0_MEM_BTM_DATA1r_MEM_DATAf_GET
#define MEM_BTM_DATA1r_MEM_DATAf_SET BCM53128_A0_MEM_BTM_DATA1r_MEM_DATAf_SET
#define MEM_BTM_DATA1r_RESERVEDf_GET BCM53128_A0_MEM_BTM_DATA1r_RESERVEDf_GET
#define MEM_BTM_DATA1r_RESERVEDf_SET BCM53128_A0_MEM_BTM_DATA1r_RESERVEDf_SET
#define READ_MEM_BTM_DATA1r BCM53128_A0_READ_MEM_BTM_DATA1r
#define WRITE_MEM_BTM_DATA1r BCM53128_A0_WRITE_MEM_BTM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_BTM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *     MEM_TYPE         Indicate the memory for the Debugged memory.00 : Internal CPU(8051) ROM Memory(ROM table is Read-only)01 : Internal CPU(8051) RAM Memory10 : 1Q-VLAN Memory11 : ARL MemoryOthers : Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_CTRLr 0x00000800

#define BCM53128_A0_MEM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_CTRL.
 *
 */
typedef union BCM53128_A0_MEM_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_ctrl[1];
	uint32_t _mem_ctrl;
} BCM53128_A0_MEM_CTRLr_t;

#define BCM53128_A0_MEM_CTRLr_CLR(r) (r).mem_ctrl[0] = 0
#define BCM53128_A0_MEM_CTRLr_SET(r,d) (r).mem_ctrl[0] = d
#define BCM53128_A0_MEM_CTRLr_GET(r) (r).mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_CTRLr_RESERVED_0f_GET(r) (((r).mem_ctrl[0]) & 0xf)
#define BCM53128_A0_MEM_CTRLr_RESERVED_0f_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_MEM_CTRLr_RESERVED_1f_GET(r) ((((r).mem_ctrl[0]) >> 4) & 0x3)
#define BCM53128_A0_MEM_CTRLr_RESERVED_1f_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_MEM_CTRLr_MEM_TYPEf_GET(r) ((((r).mem_ctrl[0]) >> 6) & 0x3)
#define BCM53128_A0_MEM_CTRLr_MEM_TYPEf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MEM_CTRL.
 *
 */
#define BCM53128_A0_READ_MEM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_CTRLr,(r._mem_ctrl),1)
#define BCM53128_A0_WRITE_MEM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_CTRLr,&(r._mem_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_CTRLr BCM53128_A0_MEM_CTRLr
#define MEM_CTRLr_SIZE BCM53128_A0_MEM_CTRLr_SIZE
typedef BCM53128_A0_MEM_CTRLr_t MEM_CTRLr_t;
#define MEM_CTRLr_CLR BCM53128_A0_MEM_CTRLr_CLR
#define MEM_CTRLr_SET BCM53128_A0_MEM_CTRLr_SET
#define MEM_CTRLr_GET BCM53128_A0_MEM_CTRLr_GET
#define MEM_CTRLr_RESERVED_0f_GET BCM53128_A0_MEM_CTRLr_RESERVED_0f_GET
#define MEM_CTRLr_RESERVED_0f_SET BCM53128_A0_MEM_CTRLr_RESERVED_0f_SET
#define MEM_CTRLr_RESERVED_1f_GET BCM53128_A0_MEM_CTRLr_RESERVED_1f_GET
#define MEM_CTRLr_RESERVED_1f_SET BCM53128_A0_MEM_CTRLr_RESERVED_1f_SET
#define MEM_CTRLr_MEM_TYPEf_GET BCM53128_A0_MEM_CTRLr_MEM_TYPEf_GET
#define MEM_CTRLr_MEM_TYPEf_SET BCM53128_A0_MEM_CTRLr_MEM_TYPEf_SET
#define READ_MEM_CTRLr BCM53128_A0_READ_MEM_CTRLr
#define WRITE_MEM_CTRLr BCM53128_A0_WRITE_MEM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_DEBUG_DATA_0_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0].For ARL, this field specifies the entry 0 bit[63:0].For VLAN, this field specifies the VLAN entry [11:0].For Internal CPU(8051) RAM, this field specifies the bit[63:0].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_DEBUG_DATA_0_0r 0x00000808

#define BCM53128_A0_MEM_DEBUG_DATA_0_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_0.
 *
 */
typedef union BCM53128_A0_MEM_DEBUG_DATA_0_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_0_0[2];
	uint32_t _mem_debug_data_0_0;
} BCM53128_A0_MEM_DEBUG_DATA_0_0r_t;

#define BCM53128_A0_MEM_DEBUG_DATA_0_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_0_0), 0, sizeof(BCM53128_A0_MEM_DEBUG_DATA_0_0r_t))
#define BCM53128_A0_MEM_DEBUG_DATA_0_0r_SET(r,i,d) (r).mem_debug_data_0_0[i] = d
#define BCM53128_A0_MEM_DEBUG_DATA_0_0r_GET(r,i) (r).mem_debug_data_0_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_0_0,0,63,a)
#define BCM53128_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_0_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_0.
 *
 */
#define BCM53128_A0_READ_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_DEBUG_DATA_0_0r,(r._mem_debug_data_0_0),8)
#define BCM53128_A0_WRITE_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_DEBUG_DATA_0_0r,&(r._mem_debug_data_0_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_0r BCM53128_A0_MEM_DEBUG_DATA_0_0r
#define MEM_DEBUG_DATA_0_0r_SIZE BCM53128_A0_MEM_DEBUG_DATA_0_0r_SIZE
typedef BCM53128_A0_MEM_DEBUG_DATA_0_0r_t MEM_DEBUG_DATA_0_0r_t;
#define MEM_DEBUG_DATA_0_0r_CLR BCM53128_A0_MEM_DEBUG_DATA_0_0r_CLR
#define MEM_DEBUG_DATA_0_0r_SET BCM53128_A0_MEM_DEBUG_DATA_0_0r_SET
#define MEM_DEBUG_DATA_0_0r_GET BCM53128_A0_MEM_DEBUG_DATA_0_0r_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_GET BCM53128_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_SET BCM53128_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_0r BCM53128_A0_READ_MEM_DEBUG_DATA_0_0r
#define WRITE_MEM_DEBUG_DATA_0_0r BCM53128_A0_WRITE_MEM_DEBUG_DATA_0_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_DEBUG_DATA_0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_DEBUG_DATA_0_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory.For ARL, this field specifies the entry 0 bit[66:64].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_DEBUG_DATA_0_1r 0x00000810

#define BCM53128_A0_MEM_DEBUG_DATA_0_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_1.
 *
 */
typedef union BCM53128_A0_MEM_DEBUG_DATA_0_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_0_1[1];
	uint32_t _mem_debug_data_0_1;
} BCM53128_A0_MEM_DEBUG_DATA_0_1r_t;

#define BCM53128_A0_MEM_DEBUG_DATA_0_1r_CLR(r) (r).mem_debug_data_0_1[0] = 0
#define BCM53128_A0_MEM_DEBUG_DATA_0_1r_SET(r,d) (r).mem_debug_data_0_1[0] = d
#define BCM53128_A0_MEM_DEBUG_DATA_0_1r_GET(r) (r).mem_debug_data_0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET(r) (((r).mem_debug_data_0_1[0]) & 0xffff)
#define BCM53128_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_0_1[0]=(((r).mem_debug_data_0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_1.
 *
 */
#define BCM53128_A0_READ_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_DEBUG_DATA_0_1r,(r._mem_debug_data_0_1),2)
#define BCM53128_A0_WRITE_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_DEBUG_DATA_0_1r,&(r._mem_debug_data_0_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_1r BCM53128_A0_MEM_DEBUG_DATA_0_1r
#define MEM_DEBUG_DATA_0_1r_SIZE BCM53128_A0_MEM_DEBUG_DATA_0_1r_SIZE
typedef BCM53128_A0_MEM_DEBUG_DATA_0_1r_t MEM_DEBUG_DATA_0_1r_t;
#define MEM_DEBUG_DATA_0_1r_CLR BCM53128_A0_MEM_DEBUG_DATA_0_1r_CLR
#define MEM_DEBUG_DATA_0_1r_SET BCM53128_A0_MEM_DEBUG_DATA_0_1r_SET
#define MEM_DEBUG_DATA_0_1r_GET BCM53128_A0_MEM_DEBUG_DATA_0_1r_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_GET BCM53128_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_SET BCM53128_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_1r BCM53128_A0_READ_MEM_DEBUG_DATA_0_1r
#define WRITE_MEM_DEBUG_DATA_0_1r BCM53128_A0_WRITE_MEM_DEBUG_DATA_0_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_DEBUG_DATA_0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_DEBUG_DATA_1_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory.For ARL, this field specifies the entry 1 bit[63:0].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_DEBUG_DATA_1_0r 0x00000812

#define BCM53128_A0_MEM_DEBUG_DATA_1_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_0.
 *
 */
typedef union BCM53128_A0_MEM_DEBUG_DATA_1_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_1_0[2];
	uint32_t _mem_debug_data_1_0;
} BCM53128_A0_MEM_DEBUG_DATA_1_0r_t;

#define BCM53128_A0_MEM_DEBUG_DATA_1_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_1_0), 0, sizeof(BCM53128_A0_MEM_DEBUG_DATA_1_0r_t))
#define BCM53128_A0_MEM_DEBUG_DATA_1_0r_SET(r,i,d) (r).mem_debug_data_1_0[i] = d
#define BCM53128_A0_MEM_DEBUG_DATA_1_0r_GET(r,i) (r).mem_debug_data_1_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_1_0,0,63,a)
#define BCM53128_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_1_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_0.
 *
 */
#define BCM53128_A0_READ_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_DEBUG_DATA_1_0r,(r._mem_debug_data_1_0),8)
#define BCM53128_A0_WRITE_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_DEBUG_DATA_1_0r,&(r._mem_debug_data_1_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_0r BCM53128_A0_MEM_DEBUG_DATA_1_0r
#define MEM_DEBUG_DATA_1_0r_SIZE BCM53128_A0_MEM_DEBUG_DATA_1_0r_SIZE
typedef BCM53128_A0_MEM_DEBUG_DATA_1_0r_t MEM_DEBUG_DATA_1_0r_t;
#define MEM_DEBUG_DATA_1_0r_CLR BCM53128_A0_MEM_DEBUG_DATA_1_0r_CLR
#define MEM_DEBUG_DATA_1_0r_SET BCM53128_A0_MEM_DEBUG_DATA_1_0r_SET
#define MEM_DEBUG_DATA_1_0r_GET BCM53128_A0_MEM_DEBUG_DATA_1_0r_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_GET BCM53128_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_SET BCM53128_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_0r BCM53128_A0_READ_MEM_DEBUG_DATA_1_0r
#define WRITE_MEM_DEBUG_DATA_1_0r BCM53128_A0_WRITE_MEM_DEBUG_DATA_1_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_DEBUG_DATA_1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_DEBUG_DATA_1_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory.For ARL, this field specifies the entry 1 bit[66:64].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_DEBUG_DATA_1_1r 0x0000081a

#define BCM53128_A0_MEM_DEBUG_DATA_1_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_1.
 *
 */
typedef union BCM53128_A0_MEM_DEBUG_DATA_1_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_1_1[1];
	uint32_t _mem_debug_data_1_1;
} BCM53128_A0_MEM_DEBUG_DATA_1_1r_t;

#define BCM53128_A0_MEM_DEBUG_DATA_1_1r_CLR(r) (r).mem_debug_data_1_1[0] = 0
#define BCM53128_A0_MEM_DEBUG_DATA_1_1r_SET(r,d) (r).mem_debug_data_1_1[0] = d
#define BCM53128_A0_MEM_DEBUG_DATA_1_1r_GET(r) (r).mem_debug_data_1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET(r) (((r).mem_debug_data_1_1[0]) & 0xffff)
#define BCM53128_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_1_1[0]=(((r).mem_debug_data_1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_1.
 *
 */
#define BCM53128_A0_READ_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_DEBUG_DATA_1_1r,(r._mem_debug_data_1_1),2)
#define BCM53128_A0_WRITE_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_DEBUG_DATA_1_1r,&(r._mem_debug_data_1_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_1r BCM53128_A0_MEM_DEBUG_DATA_1_1r
#define MEM_DEBUG_DATA_1_1r_SIZE BCM53128_A0_MEM_DEBUG_DATA_1_1r_SIZE
typedef BCM53128_A0_MEM_DEBUG_DATA_1_1r_t MEM_DEBUG_DATA_1_1r_t;
#define MEM_DEBUG_DATA_1_1r_CLR BCM53128_A0_MEM_DEBUG_DATA_1_1r_CLR
#define MEM_DEBUG_DATA_1_1r_SET BCM53128_A0_MEM_DEBUG_DATA_1_1r_SET
#define MEM_DEBUG_DATA_1_1r_GET BCM53128_A0_MEM_DEBUG_DATA_1_1r_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_GET BCM53128_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_SET BCM53128_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_1r BCM53128_A0_READ_MEM_DEBUG_DATA_1_1r
#define WRITE_MEM_DEBUG_DATA_1_1r BCM53128_A0_WRITE_MEM_DEBUG_DATA_1_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_DEBUG_DATA_1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_FRM_ADDR
 * BLOCKS:   SYS
 * DESC:     Frame Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     RESERVED         Reserved
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_FRM_ADDRr 0x00000820

#define BCM53128_A0_MEM_FRM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_FRM_ADDR.
 *
 */
typedef union BCM53128_A0_MEM_FRM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_frm_addr[1];
	uint32_t _mem_frm_addr;
} BCM53128_A0_MEM_FRM_ADDRr_t;

#define BCM53128_A0_MEM_FRM_ADDRr_CLR(r) (r).mem_frm_addr[0] = 0
#define BCM53128_A0_MEM_FRM_ADDRr_SET(r,d) (r).mem_frm_addr[0] = d
#define BCM53128_A0_MEM_FRM_ADDRr_GET(r) (r).mem_frm_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_FRM_ADDRr_MEM_ADRf_GET(r) (((r).mem_frm_addr[0]) & 0x1fff)
#define BCM53128_A0_MEM_FRM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53128_A0_MEM_FRM_ADDRr_RESERVEDf_GET(r) ((((r).mem_frm_addr[0]) >> 13) & 0x1)
#define BCM53128_A0_MEM_FRM_ADDRr_RESERVEDf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_MEM_FRM_ADDRr_MEM_RWf_GET(r) ((((r).mem_frm_addr[0]) >> 14) & 0x1)
#define BCM53128_A0_MEM_FRM_ADDRr_MEM_RWf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_MEM_FRM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_frm_addr[0]) >> 15) & 0x1)
#define BCM53128_A0_MEM_FRM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_FRM_ADDR.
 *
 */
#define BCM53128_A0_READ_MEM_FRM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_FRM_ADDRr,(r._mem_frm_addr),2)
#define BCM53128_A0_WRITE_MEM_FRM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_FRM_ADDRr,&(r._mem_frm_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_ADDRr BCM53128_A0_MEM_FRM_ADDRr
#define MEM_FRM_ADDRr_SIZE BCM53128_A0_MEM_FRM_ADDRr_SIZE
typedef BCM53128_A0_MEM_FRM_ADDRr_t MEM_FRM_ADDRr_t;
#define MEM_FRM_ADDRr_CLR BCM53128_A0_MEM_FRM_ADDRr_CLR
#define MEM_FRM_ADDRr_SET BCM53128_A0_MEM_FRM_ADDRr_SET
#define MEM_FRM_ADDRr_GET BCM53128_A0_MEM_FRM_ADDRr_GET
#define MEM_FRM_ADDRr_MEM_ADRf_GET BCM53128_A0_MEM_FRM_ADDRr_MEM_ADRf_GET
#define MEM_FRM_ADDRr_MEM_ADRf_SET BCM53128_A0_MEM_FRM_ADDRr_MEM_ADRf_SET
#define MEM_FRM_ADDRr_RESERVEDf_GET BCM53128_A0_MEM_FRM_ADDRr_RESERVEDf_GET
#define MEM_FRM_ADDRr_RESERVEDf_SET BCM53128_A0_MEM_FRM_ADDRr_RESERVEDf_SET
#define MEM_FRM_ADDRr_MEM_RWf_GET BCM53128_A0_MEM_FRM_ADDRr_MEM_RWf_GET
#define MEM_FRM_ADDRr_MEM_RWf_SET BCM53128_A0_MEM_FRM_ADDRr_MEM_RWf_SET
#define MEM_FRM_ADDRr_MEM_STDNf_GET BCM53128_A0_MEM_FRM_ADDRr_MEM_STDNf_GET
#define MEM_FRM_ADDRr_MEM_STDNf_SET BCM53128_A0_MEM_FRM_ADDRr_MEM_STDNf_SET
#define READ_MEM_FRM_ADDRr BCM53128_A0_READ_MEM_FRM_ADDRr
#define WRITE_MEM_FRM_ADDRr BCM53128_A0_WRITE_MEM_FRM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_FRM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_FRM_DATA0
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 1st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[63:0].
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_FRM_DATA0r 0x00000830

#define BCM53128_A0_MEM_FRM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA0.
 *
 */
typedef union BCM53128_A0_MEM_FRM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_frm_data0[2];
	uint32_t _mem_frm_data0;
} BCM53128_A0_MEM_FRM_DATA0r_t;

#define BCM53128_A0_MEM_FRM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data0), 0, sizeof(BCM53128_A0_MEM_FRM_DATA0r_t))
#define BCM53128_A0_MEM_FRM_DATA0r_SET(r,i,d) (r).mem_frm_data0[i] = d
#define BCM53128_A0_MEM_FRM_DATA0r_GET(r,i) (r).mem_frm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_FRM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data0,0,63,a)
#define BCM53128_A0_MEM_FRM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data0,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA0.
 *
 */
#define BCM53128_A0_READ_MEM_FRM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_FRM_DATA0r,(r._mem_frm_data0),8)
#define BCM53128_A0_WRITE_MEM_FRM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_FRM_DATA0r,&(r._mem_frm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA0r BCM53128_A0_MEM_FRM_DATA0r
#define MEM_FRM_DATA0r_SIZE BCM53128_A0_MEM_FRM_DATA0r_SIZE
typedef BCM53128_A0_MEM_FRM_DATA0r_t MEM_FRM_DATA0r_t;
#define MEM_FRM_DATA0r_CLR BCM53128_A0_MEM_FRM_DATA0r_CLR
#define MEM_FRM_DATA0r_SET BCM53128_A0_MEM_FRM_DATA0r_SET
#define MEM_FRM_DATA0r_GET BCM53128_A0_MEM_FRM_DATA0r_GET
#define MEM_FRM_DATA0r_MEM_DATAf_GET BCM53128_A0_MEM_FRM_DATA0r_MEM_DATAf_GET
#define MEM_FRM_DATA0r_MEM_DATAf_SET BCM53128_A0_MEM_FRM_DATA0r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA0r BCM53128_A0_READ_MEM_FRM_DATA0r
#define WRITE_MEM_FRM_DATA0r BCM53128_A0_WRITE_MEM_FRM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_FRM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_FRM_DATA1
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 2st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[127:64].
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_FRM_DATA1r 0x00000838

#define BCM53128_A0_MEM_FRM_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA1.
 *
 */
typedef union BCM53128_A0_MEM_FRM_DATA1r_s {
	uint32_t v[2];
	uint32_t mem_frm_data1[2];
	uint32_t _mem_frm_data1;
} BCM53128_A0_MEM_FRM_DATA1r_t;

#define BCM53128_A0_MEM_FRM_DATA1r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data1), 0, sizeof(BCM53128_A0_MEM_FRM_DATA1r_t))
#define BCM53128_A0_MEM_FRM_DATA1r_SET(r,i,d) (r).mem_frm_data1[i] = d
#define BCM53128_A0_MEM_FRM_DATA1r_GET(r,i) (r).mem_frm_data1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_FRM_DATA1r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data1,0,63,a)
#define BCM53128_A0_MEM_FRM_DATA1r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data1,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA1.
 *
 */
#define BCM53128_A0_READ_MEM_FRM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_FRM_DATA1r,(r._mem_frm_data1),8)
#define BCM53128_A0_WRITE_MEM_FRM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_FRM_DATA1r,&(r._mem_frm_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA1r BCM53128_A0_MEM_FRM_DATA1r
#define MEM_FRM_DATA1r_SIZE BCM53128_A0_MEM_FRM_DATA1r_SIZE
typedef BCM53128_A0_MEM_FRM_DATA1r_t MEM_FRM_DATA1r_t;
#define MEM_FRM_DATA1r_CLR BCM53128_A0_MEM_FRM_DATA1r_CLR
#define MEM_FRM_DATA1r_SET BCM53128_A0_MEM_FRM_DATA1r_SET
#define MEM_FRM_DATA1r_GET BCM53128_A0_MEM_FRM_DATA1r_GET
#define MEM_FRM_DATA1r_MEM_DATAf_GET BCM53128_A0_MEM_FRM_DATA1r_MEM_DATAf_GET
#define MEM_FRM_DATA1r_MEM_DATAf_SET BCM53128_A0_MEM_FRM_DATA1r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA1r BCM53128_A0_READ_MEM_FRM_DATA1r
#define WRITE_MEM_FRM_DATA1r BCM53128_A0_WRITE_MEM_FRM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_FRM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_FRM_DATA2
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 3st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[191:128].
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_FRM_DATA2r 0x00000840

#define BCM53128_A0_MEM_FRM_DATA2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA2.
 *
 */
typedef union BCM53128_A0_MEM_FRM_DATA2r_s {
	uint32_t v[2];
	uint32_t mem_frm_data2[2];
	uint32_t _mem_frm_data2;
} BCM53128_A0_MEM_FRM_DATA2r_t;

#define BCM53128_A0_MEM_FRM_DATA2r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data2), 0, sizeof(BCM53128_A0_MEM_FRM_DATA2r_t))
#define BCM53128_A0_MEM_FRM_DATA2r_SET(r,i,d) (r).mem_frm_data2[i] = d
#define BCM53128_A0_MEM_FRM_DATA2r_GET(r,i) (r).mem_frm_data2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_FRM_DATA2r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data2,0,63,a)
#define BCM53128_A0_MEM_FRM_DATA2r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data2,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA2.
 *
 */
#define BCM53128_A0_READ_MEM_FRM_DATA2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_FRM_DATA2r,(r._mem_frm_data2),8)
#define BCM53128_A0_WRITE_MEM_FRM_DATA2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_FRM_DATA2r,&(r._mem_frm_data2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA2r BCM53128_A0_MEM_FRM_DATA2r
#define MEM_FRM_DATA2r_SIZE BCM53128_A0_MEM_FRM_DATA2r_SIZE
typedef BCM53128_A0_MEM_FRM_DATA2r_t MEM_FRM_DATA2r_t;
#define MEM_FRM_DATA2r_CLR BCM53128_A0_MEM_FRM_DATA2r_CLR
#define MEM_FRM_DATA2r_SET BCM53128_A0_MEM_FRM_DATA2r_SET
#define MEM_FRM_DATA2r_GET BCM53128_A0_MEM_FRM_DATA2r_GET
#define MEM_FRM_DATA2r_MEM_DATAf_GET BCM53128_A0_MEM_FRM_DATA2r_MEM_DATAf_GET
#define MEM_FRM_DATA2r_MEM_DATAf_SET BCM53128_A0_MEM_FRM_DATA2r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA2r BCM53128_A0_READ_MEM_FRM_DATA2r
#define WRITE_MEM_FRM_DATA2r BCM53128_A0_WRITE_MEM_FRM_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_FRM_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MEM_FRM_DATA3
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 4th Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[255:192].
 *
 ******************************************************************************/
#define BCM53128_A0_MEM_FRM_DATA3r 0x00000848

#define BCM53128_A0_MEM_FRM_DATA3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA3.
 *
 */
typedef union BCM53128_A0_MEM_FRM_DATA3r_s {
	uint32_t v[2];
	uint32_t mem_frm_data3[2];
	uint32_t _mem_frm_data3;
} BCM53128_A0_MEM_FRM_DATA3r_t;

#define BCM53128_A0_MEM_FRM_DATA3r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data3), 0, sizeof(BCM53128_A0_MEM_FRM_DATA3r_t))
#define BCM53128_A0_MEM_FRM_DATA3r_SET(r,i,d) (r).mem_frm_data3[i] = d
#define BCM53128_A0_MEM_FRM_DATA3r_GET(r,i) (r).mem_frm_data3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MEM_FRM_DATA3r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data3,0,63,a)
#define BCM53128_A0_MEM_FRM_DATA3r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data3,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA3.
 *
 */
#define BCM53128_A0_READ_MEM_FRM_DATA3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MEM_FRM_DATA3r,(r._mem_frm_data3),8)
#define BCM53128_A0_WRITE_MEM_FRM_DATA3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MEM_FRM_DATA3r,&(r._mem_frm_data3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA3r BCM53128_A0_MEM_FRM_DATA3r
#define MEM_FRM_DATA3r_SIZE BCM53128_A0_MEM_FRM_DATA3r_SIZE
typedef BCM53128_A0_MEM_FRM_DATA3r_t MEM_FRM_DATA3r_t;
#define MEM_FRM_DATA3r_CLR BCM53128_A0_MEM_FRM_DATA3r_CLR
#define MEM_FRM_DATA3r_SET BCM53128_A0_MEM_FRM_DATA3r_SET
#define MEM_FRM_DATA3r_GET BCM53128_A0_MEM_FRM_DATA3r_GET
#define MEM_FRM_DATA3r_MEM_DATAf_GET BCM53128_A0_MEM_FRM_DATA3r_MEM_DATAf_GET
#define MEM_FRM_DATA3r_MEM_DATAf_SET BCM53128_A0_MEM_FRM_DATA3r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA3r BCM53128_A0_READ_MEM_FRM_DATA3r
#define WRITE_MEM_FRM_DATA3r BCM53128_A0_WRITE_MEM_FRM_DATA3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MEM_FRM_DATA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIB_GD_FM_MAX_SIZE
 * BLOCKS:   SYS
 * DESC:     Jumbo MIB Good Frame Max Size Registers
 * SIZE:     16
 * FIELDS:
 *     MAX_SIZE         Standard Max. Frame Size.The Register defines the Standard MAX. Frame Size for MAC and MIB counter.The register should be either 14'd1518 or 14'd2000.When jumbo is disable, the MAC and MIB counter use this field to check for good frame size.When this field is 1518, the tagged frames will be dropped if the frame size is lager than 1522 bytes; and the untagged frames willbe dropped if the frame size is larger than 1518 bytes.when this field is 2000, both tagged or untagged frames will be dropped if the frame size is larger than 2000 bytes.when jumbo is enable, all the frames will be dropped if the frame size is larger than 9720B.The Register setting will affect those MIB counting includingin RxSAChangeRxgoodOctetsRxUnicastPktsRxMulticastPktsRxBroadcastPktsRxOverSizePkts
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr 0x00004005

#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_SIZE 2

/*
 * This structure should be used to declare and program MIB_GD_FM_MAX_SIZE.
 *
 */
typedef union BCM53128_A0_MIB_GD_FM_MAX_SIZEr_s {
	uint32_t v[1];
	uint32_t mib_gd_fm_max_size[1];
	uint32_t _mib_gd_fm_max_size;
} BCM53128_A0_MIB_GD_FM_MAX_SIZEr_t;

#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_CLR(r) (r).mib_gd_fm_max_size[0] = 0
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_SET(r,d) (r).mib_gd_fm_max_size[0] = d
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_GET(r) (r).mib_gd_fm_max_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET(r) (((r).mib_gd_fm_max_size[0]) & 0x3fff)
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET(r) ((((r).mib_gd_fm_max_size[0]) >> 14) & 0x3)
#define BCM53128_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access MIB_GD_FM_MAX_SIZE.
 *
 */
#define BCM53128_A0_READ_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIB_GD_FM_MAX_SIZEr,(r._mib_gd_fm_max_size),2)
#define BCM53128_A0_WRITE_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIB_GD_FM_MAX_SIZEr,&(r._mib_gd_fm_max_size),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_GD_FM_MAX_SIZEr BCM53128_A0_MIB_GD_FM_MAX_SIZEr
#define MIB_GD_FM_MAX_SIZEr_SIZE BCM53128_A0_MIB_GD_FM_MAX_SIZEr_SIZE
typedef BCM53128_A0_MIB_GD_FM_MAX_SIZEr_t MIB_GD_FM_MAX_SIZEr_t;
#define MIB_GD_FM_MAX_SIZEr_CLR BCM53128_A0_MIB_GD_FM_MAX_SIZEr_CLR
#define MIB_GD_FM_MAX_SIZEr_SET BCM53128_A0_MIB_GD_FM_MAX_SIZEr_SET
#define MIB_GD_FM_MAX_SIZEr_GET BCM53128_A0_MIB_GD_FM_MAX_SIZEr_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET BCM53128_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET BCM53128_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET
#define MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET BCM53128_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET
#define MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET BCM53128_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET
#define READ_MIB_GD_FM_MAX_SIZEr BCM53128_A0_READ_MIB_GD_FM_MAX_SIZEr
#define WRITE_MIB_GD_FM_MAX_SIZEr BCM53128_A0_WRITE_MIB_GD_FM_MAX_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIB_GD_FM_MAX_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Control Register
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     RESERVED         
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but data from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDONE  Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 *
 ******************************************************************************/
#define BCM53128_A0_MIB_SNAPSHOT_CTLr 0x00007000

#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 *
 */
typedef union BCM53128_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM53128_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM53128_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0xf)
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 4) & 0x3)
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 *
 */
#define BCM53128_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM53128_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM53128_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM53128_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM53128_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM53128_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM53128_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM53128_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_GET BCM53128_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_SET BCM53128_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET BCM53128_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM53128_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM53128_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIB_SNAPSHOT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_DBGCR
 * BLOCKS:   SYS
 * DESC:     Debug Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_DBGCR       Setting this register selects the debug bus to be shown in Debug Data Register (0xFF5F)0: TX DMA State1: TX Interface State2: RX DMA State3: RX Interface StateOthers: reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_DBGCRr 0x0000ff5e

#define BCM53128_A0_MIIP_DBGCRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_DBGCR.
 *
 */
typedef union BCM53128_A0_MIIP_DBGCRr_s {
	uint32_t v[1];
	uint32_t miip_dbgcr[1];
	uint32_t _miip_dbgcr;
} BCM53128_A0_MIIP_DBGCRr_t;

#define BCM53128_A0_MIIP_DBGCRr_CLR(r) (r).miip_dbgcr[0] = 0
#define BCM53128_A0_MIIP_DBGCRr_SET(r,d) (r).miip_dbgcr[0] = d
#define BCM53128_A0_MIIP_DBGCRr_GET(r) (r).miip_dbgcr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_DBGCRr_MIIP_DBGCRf_GET(r) (((r).miip_dbgcr[0]) & 0xff)
#define BCM53128_A0_MIIP_DBGCRr_MIIP_DBGCRf_SET(r,f) (r).miip_dbgcr[0]=(((r).miip_dbgcr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_DBGCR.
 *
 */
#define BCM53128_A0_READ_MIIP_DBGCRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_DBGCRr,(r._miip_dbgcr),1)
#define BCM53128_A0_WRITE_MIIP_DBGCRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_DBGCRr,&(r._miip_dbgcr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_DBGCRr BCM53128_A0_MIIP_DBGCRr
#define MIIP_DBGCRr_SIZE BCM53128_A0_MIIP_DBGCRr_SIZE
typedef BCM53128_A0_MIIP_DBGCRr_t MIIP_DBGCRr_t;
#define MIIP_DBGCRr_CLR BCM53128_A0_MIIP_DBGCRr_CLR
#define MIIP_DBGCRr_SET BCM53128_A0_MIIP_DBGCRr_SET
#define MIIP_DBGCRr_GET BCM53128_A0_MIIP_DBGCRr_GET
#define MIIP_DBGCRr_MIIP_DBGCRf_GET BCM53128_A0_MIIP_DBGCRr_MIIP_DBGCRf_GET
#define MIIP_DBGCRr_MIIP_DBGCRf_SET BCM53128_A0_MIIP_DBGCRr_MIIP_DBGCRf_SET
#define READ_MIIP_DBGCRr BCM53128_A0_READ_MIIP_DBGCRr
#define WRITE_MIIP_DBGCRr BCM53128_A0_WRITE_MIIP_DBGCRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_DBGCRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_DBGDR
 * BLOCKS:   SYS
 * DESC:     Debug Data Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_DBGDR       This register shows the debug bus selected by Debug Control Register (0xFF5E).
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_DBGDRr 0x0000ff5f

#define BCM53128_A0_MIIP_DBGDRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_DBGDR.
 *
 */
typedef union BCM53128_A0_MIIP_DBGDRr_s {
	uint32_t v[1];
	uint32_t miip_dbgdr[1];
	uint32_t _miip_dbgdr;
} BCM53128_A0_MIIP_DBGDRr_t;

#define BCM53128_A0_MIIP_DBGDRr_CLR(r) (r).miip_dbgdr[0] = 0
#define BCM53128_A0_MIIP_DBGDRr_SET(r,d) (r).miip_dbgdr[0] = d
#define BCM53128_A0_MIIP_DBGDRr_GET(r) (r).miip_dbgdr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_DBGDRr_MIIP_DBGDRf_GET(r) (((r).miip_dbgdr[0]) & 0xff)
#define BCM53128_A0_MIIP_DBGDRr_MIIP_DBGDRf_SET(r,f) (r).miip_dbgdr[0]=(((r).miip_dbgdr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_DBGDR.
 *
 */
#define BCM53128_A0_READ_MIIP_DBGDRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_DBGDRr,(r._miip_dbgdr),1)
#define BCM53128_A0_WRITE_MIIP_DBGDRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_DBGDRr,&(r._miip_dbgdr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_DBGDRr BCM53128_A0_MIIP_DBGDRr
#define MIIP_DBGDRr_SIZE BCM53128_A0_MIIP_DBGDRr_SIZE
typedef BCM53128_A0_MIIP_DBGDRr_t MIIP_DBGDRr_t;
#define MIIP_DBGDRr_CLR BCM53128_A0_MIIP_DBGDRr_CLR
#define MIIP_DBGDRr_SET BCM53128_A0_MIIP_DBGDRr_SET
#define MIIP_DBGDRr_GET BCM53128_A0_MIIP_DBGDRr_GET
#define MIIP_DBGDRr_MIIP_DBGDRf_GET BCM53128_A0_MIIP_DBGDRr_MIIP_DBGDRf_GET
#define MIIP_DBGDRr_MIIP_DBGDRf_SET BCM53128_A0_MIIP_DBGDRr_MIIP_DBGDRf_SET
#define READ_MIIP_DBGDRr BCM53128_A0_READ_MIIP_DBGDRr
#define WRITE_MIIP_DBGDRr BCM53128_A0_WRITE_MIIP_DBGDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_DBGDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_DMACR
 * BLOCKS:   SYS
 * DESC:     DMA Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved.
 *     MIIP_TXRA        TX resource available indication.=0, no resource available on IMP RX port.=1, ready to accept packets on IMP RX port.
 *     MIIP_LBSTS       Loopback mode indication=0, normal mode;=1, DMA loopback mode is enabled
 *     MIIP_ENBHI       Disable of inserting BRCM header on TX path. (this bit is for design verification only)=1, disable;=0, enable.
 *     MIIP_DISBHP      Disable of parsing BRCM header on RX path. (this bit is for design verification only)=1, disable;=0, enable.
 *     MIIP_ENIPO       Enable of DMA's TX function interpreting TX pause on from IMP (hardware flow control).=1, enable;=0, disable.
 *     MIIP_ENGPO       Enable of DMA's RX function generating TX pause on to IMP (hardware flow control).=1, enable;=0, disable.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_DMACRr 0x0000ff40

#define BCM53128_A0_MIIP_DMACRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_DMACR.
 *
 */
typedef union BCM53128_A0_MIIP_DMACRr_s {
	uint32_t v[1];
	uint32_t miip_dmacr[1];
	uint32_t _miip_dmacr;
} BCM53128_A0_MIIP_DMACRr_t;

#define BCM53128_A0_MIIP_DMACRr_CLR(r) (r).miip_dmacr[0] = 0
#define BCM53128_A0_MIIP_DMACRr_SET(r,d) (r).miip_dmacr[0] = d
#define BCM53128_A0_MIIP_DMACRr_GET(r) (r).miip_dmacr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_DMACRr_RESERVEDf_GET(r) (((r).miip_dmacr[0]) & 0x3)
#define BCM53128_A0_MIIP_DMACRr_RESERVEDf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_MIIP_DMACRr_MIIP_TXRAf_GET(r) ((((r).miip_dmacr[0]) >> 2) & 0x1)
#define BCM53128_A0_MIIP_DMACRr_MIIP_TXRAf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_MIIP_DMACRr_MIIP_LBSTSf_GET(r) ((((r).miip_dmacr[0]) >> 3) & 0x1)
#define BCM53128_A0_MIIP_DMACRr_MIIP_LBSTSf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_MIIP_DMACRr_MIIP_ENBHIf_GET(r) ((((r).miip_dmacr[0]) >> 4) & 0x1)
#define BCM53128_A0_MIIP_DMACRr_MIIP_ENBHIf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_MIIP_DMACRr_MIIP_DISBHPf_GET(r) ((((r).miip_dmacr[0]) >> 5) & 0x1)
#define BCM53128_A0_MIIP_DMACRr_MIIP_DISBHPf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_MIIP_DMACRr_MIIP_ENIPOf_GET(r) ((((r).miip_dmacr[0]) >> 6) & 0x1)
#define BCM53128_A0_MIIP_DMACRr_MIIP_ENIPOf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_MIIP_DMACRr_MIIP_ENGPOf_GET(r) ((((r).miip_dmacr[0]) >> 7) & 0x1)
#define BCM53128_A0_MIIP_DMACRr_MIIP_ENGPOf_SET(r,f) (r).miip_dmacr[0]=(((r).miip_dmacr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIIP_DMACR.
 *
 */
#define BCM53128_A0_READ_MIIP_DMACRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_DMACRr,(r._miip_dmacr),1)
#define BCM53128_A0_WRITE_MIIP_DMACRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_DMACRr,&(r._miip_dmacr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_DMACRr BCM53128_A0_MIIP_DMACRr
#define MIIP_DMACRr_SIZE BCM53128_A0_MIIP_DMACRr_SIZE
typedef BCM53128_A0_MIIP_DMACRr_t MIIP_DMACRr_t;
#define MIIP_DMACRr_CLR BCM53128_A0_MIIP_DMACRr_CLR
#define MIIP_DMACRr_SET BCM53128_A0_MIIP_DMACRr_SET
#define MIIP_DMACRr_GET BCM53128_A0_MIIP_DMACRr_GET
#define MIIP_DMACRr_RESERVEDf_GET BCM53128_A0_MIIP_DMACRr_RESERVEDf_GET
#define MIIP_DMACRr_RESERVEDf_SET BCM53128_A0_MIIP_DMACRr_RESERVEDf_SET
#define MIIP_DMACRr_MIIP_TXRAf_GET BCM53128_A0_MIIP_DMACRr_MIIP_TXRAf_GET
#define MIIP_DMACRr_MIIP_TXRAf_SET BCM53128_A0_MIIP_DMACRr_MIIP_TXRAf_SET
#define MIIP_DMACRr_MIIP_LBSTSf_GET BCM53128_A0_MIIP_DMACRr_MIIP_LBSTSf_GET
#define MIIP_DMACRr_MIIP_LBSTSf_SET BCM53128_A0_MIIP_DMACRr_MIIP_LBSTSf_SET
#define MIIP_DMACRr_MIIP_ENBHIf_GET BCM53128_A0_MIIP_DMACRr_MIIP_ENBHIf_GET
#define MIIP_DMACRr_MIIP_ENBHIf_SET BCM53128_A0_MIIP_DMACRr_MIIP_ENBHIf_SET
#define MIIP_DMACRr_MIIP_DISBHPf_GET BCM53128_A0_MIIP_DMACRr_MIIP_DISBHPf_GET
#define MIIP_DMACRr_MIIP_DISBHPf_SET BCM53128_A0_MIIP_DMACRr_MIIP_DISBHPf_SET
#define MIIP_DMACRr_MIIP_ENIPOf_GET BCM53128_A0_MIIP_DMACRr_MIIP_ENIPOf_GET
#define MIIP_DMACRr_MIIP_ENIPOf_SET BCM53128_A0_MIIP_DMACRr_MIIP_ENIPOf_SET
#define MIIP_DMACRr_MIIP_ENGPOf_GET BCM53128_A0_MIIP_DMACRr_MIIP_ENGPOf_GET
#define MIIP_DMACRr_MIIP_ENGPOf_SET BCM53128_A0_MIIP_DMACRr_MIIP_ENGPOf_SET
#define READ_MIIP_DMACRr BCM53128_A0_READ_MIIP_DMACRr
#define WRITE_MIIP_DMACRr BCM53128_A0_WRITE_MIIP_DMACRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_DMACRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_INTER
 * BLOCKS:   SYS
 * DESC:     Interrupt Enable Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_INTER       Note: for hardware debug only.See bit maps in Interrupt (unmasked) Raw Status Register
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_INTERr 0x0000ff5a

#define BCM53128_A0_MIIP_INTERr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_INTER.
 *
 */
typedef union BCM53128_A0_MIIP_INTERr_s {
	uint32_t v[1];
	uint32_t miip_inter[1];
	uint32_t _miip_inter;
} BCM53128_A0_MIIP_INTERr_t;

#define BCM53128_A0_MIIP_INTERr_CLR(r) (r).miip_inter[0] = 0
#define BCM53128_A0_MIIP_INTERr_SET(r,d) (r).miip_inter[0] = d
#define BCM53128_A0_MIIP_INTERr_GET(r) (r).miip_inter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_INTERr_MIIP_INTERf_GET(r) (((r).miip_inter[0]) & 0xff)
#define BCM53128_A0_MIIP_INTERr_MIIP_INTERf_SET(r,f) (r).miip_inter[0]=(((r).miip_inter[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_INTER.
 *
 */
#define BCM53128_A0_READ_MIIP_INTERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_INTERr,(r._miip_inter),1)
#define BCM53128_A0_WRITE_MIIP_INTERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_INTERr,&(r._miip_inter),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_INTERr BCM53128_A0_MIIP_INTERr
#define MIIP_INTERr_SIZE BCM53128_A0_MIIP_INTERr_SIZE
typedef BCM53128_A0_MIIP_INTERr_t MIIP_INTERr_t;
#define MIIP_INTERr_CLR BCM53128_A0_MIIP_INTERr_CLR
#define MIIP_INTERr_SET BCM53128_A0_MIIP_INTERr_SET
#define MIIP_INTERr_GET BCM53128_A0_MIIP_INTERr_GET
#define MIIP_INTERr_MIIP_INTERf_GET BCM53128_A0_MIIP_INTERr_MIIP_INTERf_GET
#define MIIP_INTERr_MIIP_INTERf_SET BCM53128_A0_MIIP_INTERr_MIIP_INTERf_SET
#define READ_MIIP_INTERr BCM53128_A0_READ_MIIP_INTERr
#define WRITE_MIIP_INTERr BCM53128_A0_WRITE_MIIP_INTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_INTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_INTMSTS
 * BLOCKS:   SYS
 * DESC:     Interrupt masked Status Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_INTMSTS     Note: for hardware debug only.See bits maps in Interrupt (unmasked) Raw Status Register.Writing 1 to corresponding bits clears the interrupt request.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_INTMSTSr 0x0000ff5b

#define BCM53128_A0_MIIP_INTMSTSr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_INTMSTS.
 *
 */
typedef union BCM53128_A0_MIIP_INTMSTSr_s {
	uint32_t v[1];
	uint32_t miip_intmsts[1];
	uint32_t _miip_intmsts;
} BCM53128_A0_MIIP_INTMSTSr_t;

#define BCM53128_A0_MIIP_INTMSTSr_CLR(r) (r).miip_intmsts[0] = 0
#define BCM53128_A0_MIIP_INTMSTSr_SET(r,d) (r).miip_intmsts[0] = d
#define BCM53128_A0_MIIP_INTMSTSr_GET(r) (r).miip_intmsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_INTMSTSr_MIIP_INTMSTSf_GET(r) (((r).miip_intmsts[0]) & 0xff)
#define BCM53128_A0_MIIP_INTMSTSr_MIIP_INTMSTSf_SET(r,f) (r).miip_intmsts[0]=(((r).miip_intmsts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_INTMSTS.
 *
 */
#define BCM53128_A0_READ_MIIP_INTMSTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_INTMSTSr,(r._miip_intmsts),1)
#define BCM53128_A0_WRITE_MIIP_INTMSTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_INTMSTSr,&(r._miip_intmsts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_INTMSTSr BCM53128_A0_MIIP_INTMSTSr
#define MIIP_INTMSTSr_SIZE BCM53128_A0_MIIP_INTMSTSr_SIZE
typedef BCM53128_A0_MIIP_INTMSTSr_t MIIP_INTMSTSr_t;
#define MIIP_INTMSTSr_CLR BCM53128_A0_MIIP_INTMSTSr_CLR
#define MIIP_INTMSTSr_SET BCM53128_A0_MIIP_INTMSTSr_SET
#define MIIP_INTMSTSr_GET BCM53128_A0_MIIP_INTMSTSr_GET
#define MIIP_INTMSTSr_MIIP_INTMSTSf_GET BCM53128_A0_MIIP_INTMSTSr_MIIP_INTMSTSf_GET
#define MIIP_INTMSTSr_MIIP_INTMSTSf_SET BCM53128_A0_MIIP_INTMSTSr_MIIP_INTMSTSf_SET
#define READ_MIIP_INTMSTSr BCM53128_A0_READ_MIIP_INTMSTSr
#define WRITE_MIIP_INTMSTSr BCM53128_A0_WRITE_MIIP_INTMSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_INTMSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_INTRSTS
 * BLOCKS:   SYS
 * DESC:     Interrupt (unmasked) Raw Status Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_INTRSTS     Note: for hardware debug only.This register shows the interrupt request of each event.[7:6], reserved, returns zeros to read.[5]: DMA loopback end.[4]: DMA loopback start.[3]: IMP port TX resource ready.[2]: IMP port TX resource unavailable.[1]: TX complete[0]: RX complete
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_INTRSTSr 0x0000ff59

#define BCM53128_A0_MIIP_INTRSTSr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_INTRSTS.
 *
 */
typedef union BCM53128_A0_MIIP_INTRSTSr_s {
	uint32_t v[1];
	uint32_t miip_intrsts[1];
	uint32_t _miip_intrsts;
} BCM53128_A0_MIIP_INTRSTSr_t;

#define BCM53128_A0_MIIP_INTRSTSr_CLR(r) (r).miip_intrsts[0] = 0
#define BCM53128_A0_MIIP_INTRSTSr_SET(r,d) (r).miip_intrsts[0] = d
#define BCM53128_A0_MIIP_INTRSTSr_GET(r) (r).miip_intrsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_INTRSTSr_MIIP_INTRSTSf_GET(r) (((r).miip_intrsts[0]) & 0xff)
#define BCM53128_A0_MIIP_INTRSTSr_MIIP_INTRSTSf_SET(r,f) (r).miip_intrsts[0]=(((r).miip_intrsts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_INTRSTS.
 *
 */
#define BCM53128_A0_READ_MIIP_INTRSTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_INTRSTSr,(r._miip_intrsts),1)
#define BCM53128_A0_WRITE_MIIP_INTRSTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_INTRSTSr,&(r._miip_intrsts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_INTRSTSr BCM53128_A0_MIIP_INTRSTSr
#define MIIP_INTRSTSr_SIZE BCM53128_A0_MIIP_INTRSTSr_SIZE
typedef BCM53128_A0_MIIP_INTRSTSr_t MIIP_INTRSTSr_t;
#define MIIP_INTRSTSr_CLR BCM53128_A0_MIIP_INTRSTSr_CLR
#define MIIP_INTRSTSr_SET BCM53128_A0_MIIP_INTRSTSr_SET
#define MIIP_INTRSTSr_GET BCM53128_A0_MIIP_INTRSTSr_GET
#define MIIP_INTRSTSr_MIIP_INTRSTSf_GET BCM53128_A0_MIIP_INTRSTSr_MIIP_INTRSTSf_GET
#define MIIP_INTRSTSr_MIIP_INTRSTSf_SET BCM53128_A0_MIIP_INTRSTSr_MIIP_INTRSTSf_SET
#define READ_MIIP_INTRSTSr BCM53128_A0_READ_MIIP_INTRSTSr
#define WRITE_MIIP_INTRSTSr BCM53128_A0_WRITE_MIIP_INTRSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_INTRSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXADRH
 * BLOCKS:   SYS
 * DESC:     RX Buffer Address Register, high byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXADRH      Allocated buffer's memory addressHigh byte of the 16-bit address
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXADRHr 0x0000ff4b

#define BCM53128_A0_MIIP_RXADRHr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXADRH.
 *
 */
typedef union BCM53128_A0_MIIP_RXADRHr_s {
	uint32_t v[1];
	uint32_t miip_rxadrh[1];
	uint32_t _miip_rxadrh;
} BCM53128_A0_MIIP_RXADRHr_t;

#define BCM53128_A0_MIIP_RXADRHr_CLR(r) (r).miip_rxadrh[0] = 0
#define BCM53128_A0_MIIP_RXADRHr_SET(r,d) (r).miip_rxadrh[0] = d
#define BCM53128_A0_MIIP_RXADRHr_GET(r) (r).miip_rxadrh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXADRHr_MIIP_RXADRHf_GET(r) (((r).miip_rxadrh[0]) & 0xff)
#define BCM53128_A0_MIIP_RXADRHr_MIIP_RXADRHf_SET(r,f) (r).miip_rxadrh[0]=(((r).miip_rxadrh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXADRH.
 *
 */
#define BCM53128_A0_READ_MIIP_RXADRHr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXADRHr,(r._miip_rxadrh),1)
#define BCM53128_A0_WRITE_MIIP_RXADRHr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXADRHr,&(r._miip_rxadrh),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXADRHr BCM53128_A0_MIIP_RXADRHr
#define MIIP_RXADRHr_SIZE BCM53128_A0_MIIP_RXADRHr_SIZE
typedef BCM53128_A0_MIIP_RXADRHr_t MIIP_RXADRHr_t;
#define MIIP_RXADRHr_CLR BCM53128_A0_MIIP_RXADRHr_CLR
#define MIIP_RXADRHr_SET BCM53128_A0_MIIP_RXADRHr_SET
#define MIIP_RXADRHr_GET BCM53128_A0_MIIP_RXADRHr_GET
#define MIIP_RXADRHr_MIIP_RXADRHf_GET BCM53128_A0_MIIP_RXADRHr_MIIP_RXADRHf_GET
#define MIIP_RXADRHr_MIIP_RXADRHf_SET BCM53128_A0_MIIP_RXADRHr_MIIP_RXADRHf_SET
#define READ_MIIP_RXADRHr BCM53128_A0_READ_MIIP_RXADRHr
#define WRITE_MIIP_RXADRHr BCM53128_A0_WRITE_MIIP_RXADRHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXADRHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXADRL
 * BLOCKS:   SYS
 * DESC:     RX Buffer Address Register, low byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXADRL      Allocated buffer's memory addressLow byte of the 16-bit address
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXADRLr 0x0000ff4c

#define BCM53128_A0_MIIP_RXADRLr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXADRL.
 *
 */
typedef union BCM53128_A0_MIIP_RXADRLr_s {
	uint32_t v[1];
	uint32_t miip_rxadrl[1];
	uint32_t _miip_rxadrl;
} BCM53128_A0_MIIP_RXADRLr_t;

#define BCM53128_A0_MIIP_RXADRLr_CLR(r) (r).miip_rxadrl[0] = 0
#define BCM53128_A0_MIIP_RXADRLr_SET(r,d) (r).miip_rxadrl[0] = d
#define BCM53128_A0_MIIP_RXADRLr_GET(r) (r).miip_rxadrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXADRLr_MIIP_RXADRLf_GET(r) (((r).miip_rxadrl[0]) & 0xff)
#define BCM53128_A0_MIIP_RXADRLr_MIIP_RXADRLf_SET(r,f) (r).miip_rxadrl[0]=(((r).miip_rxadrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXADRL.
 *
 */
#define BCM53128_A0_READ_MIIP_RXADRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXADRLr,(r._miip_rxadrl),1)
#define BCM53128_A0_WRITE_MIIP_RXADRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXADRLr,&(r._miip_rxadrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXADRLr BCM53128_A0_MIIP_RXADRLr
#define MIIP_RXADRLr_SIZE BCM53128_A0_MIIP_RXADRLr_SIZE
typedef BCM53128_A0_MIIP_RXADRLr_t MIIP_RXADRLr_t;
#define MIIP_RXADRLr_CLR BCM53128_A0_MIIP_RXADRLr_CLR
#define MIIP_RXADRLr_SET BCM53128_A0_MIIP_RXADRLr_SET
#define MIIP_RXADRLr_GET BCM53128_A0_MIIP_RXADRLr_GET
#define MIIP_RXADRLr_MIIP_RXADRLf_GET BCM53128_A0_MIIP_RXADRLr_MIIP_RXADRLf_GET
#define MIIP_RXADRLr_MIIP_RXADRLf_SET BCM53128_A0_MIIP_RXADRLr_MIIP_RXADRLf_SET
#define READ_MIIP_RXADRLr BCM53128_A0_READ_MIIP_RXADRLr
#define WRITE_MIIP_RXADRLr BCM53128_A0_WRITE_MIIP_RXADRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXADRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR0
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 0 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR0      The first received byte of header as presented on the header format :bits [31:24] if op-code = 3'b000, orbits [63:56] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR0r 0x0000ff51

#define BCM53128_A0_MIIP_RXBHR0r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR0.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR0r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr0[1];
	uint32_t _miip_rxbhr0;
} BCM53128_A0_MIIP_RXBHR0r_t;

#define BCM53128_A0_MIIP_RXBHR0r_CLR(r) (r).miip_rxbhr0[0] = 0
#define BCM53128_A0_MIIP_RXBHR0r_SET(r,d) (r).miip_rxbhr0[0] = d
#define BCM53128_A0_MIIP_RXBHR0r_GET(r) (r).miip_rxbhr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR0r_MIIP_RXBHR0f_GET(r) (((r).miip_rxbhr0[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR0r_MIIP_RXBHR0f_SET(r,f) (r).miip_rxbhr0[0]=(((r).miip_rxbhr0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR0.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR0r,(r._miip_rxbhr0),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR0r,&(r._miip_rxbhr0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR0r BCM53128_A0_MIIP_RXBHR0r
#define MIIP_RXBHR0r_SIZE BCM53128_A0_MIIP_RXBHR0r_SIZE
typedef BCM53128_A0_MIIP_RXBHR0r_t MIIP_RXBHR0r_t;
#define MIIP_RXBHR0r_CLR BCM53128_A0_MIIP_RXBHR0r_CLR
#define MIIP_RXBHR0r_SET BCM53128_A0_MIIP_RXBHR0r_SET
#define MIIP_RXBHR0r_GET BCM53128_A0_MIIP_RXBHR0r_GET
#define MIIP_RXBHR0r_MIIP_RXBHR0f_GET BCM53128_A0_MIIP_RXBHR0r_MIIP_RXBHR0f_GET
#define MIIP_RXBHR0r_MIIP_RXBHR0f_SET BCM53128_A0_MIIP_RXBHR0r_MIIP_RXBHR0f_SET
#define READ_MIIP_RXBHR0r BCM53128_A0_READ_MIIP_RXBHR0r
#define WRITE_MIIP_RXBHR0r BCM53128_A0_WRITE_MIIP_RXBHR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR1
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 1 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR1      The 2nd received byte of header as presented on the header format :bits [23:16] if op-code = 3'b000, orbits [55:48] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR1r 0x0000ff52

#define BCM53128_A0_MIIP_RXBHR1r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR1.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR1r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr1[1];
	uint32_t _miip_rxbhr1;
} BCM53128_A0_MIIP_RXBHR1r_t;

#define BCM53128_A0_MIIP_RXBHR1r_CLR(r) (r).miip_rxbhr1[0] = 0
#define BCM53128_A0_MIIP_RXBHR1r_SET(r,d) (r).miip_rxbhr1[0] = d
#define BCM53128_A0_MIIP_RXBHR1r_GET(r) (r).miip_rxbhr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR1r_MIIP_RXBHR1f_GET(r) (((r).miip_rxbhr1[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR1r_MIIP_RXBHR1f_SET(r,f) (r).miip_rxbhr1[0]=(((r).miip_rxbhr1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR1.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR1r,(r._miip_rxbhr1),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR1r,&(r._miip_rxbhr1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR1r BCM53128_A0_MIIP_RXBHR1r
#define MIIP_RXBHR1r_SIZE BCM53128_A0_MIIP_RXBHR1r_SIZE
typedef BCM53128_A0_MIIP_RXBHR1r_t MIIP_RXBHR1r_t;
#define MIIP_RXBHR1r_CLR BCM53128_A0_MIIP_RXBHR1r_CLR
#define MIIP_RXBHR1r_SET BCM53128_A0_MIIP_RXBHR1r_SET
#define MIIP_RXBHR1r_GET BCM53128_A0_MIIP_RXBHR1r_GET
#define MIIP_RXBHR1r_MIIP_RXBHR1f_GET BCM53128_A0_MIIP_RXBHR1r_MIIP_RXBHR1f_GET
#define MIIP_RXBHR1r_MIIP_RXBHR1f_SET BCM53128_A0_MIIP_RXBHR1r_MIIP_RXBHR1f_SET
#define READ_MIIP_RXBHR1r BCM53128_A0_READ_MIIP_RXBHR1r
#define WRITE_MIIP_RXBHR1r BCM53128_A0_WRITE_MIIP_RXBHR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR2
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 2 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR2      The 3rd received byte of header as presented on the header format :bits [15:8] if op-code = 3'b000, orbits [47:40] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR2r 0x0000ff53

#define BCM53128_A0_MIIP_RXBHR2r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR2.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR2r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr2[1];
	uint32_t _miip_rxbhr2;
} BCM53128_A0_MIIP_RXBHR2r_t;

#define BCM53128_A0_MIIP_RXBHR2r_CLR(r) (r).miip_rxbhr2[0] = 0
#define BCM53128_A0_MIIP_RXBHR2r_SET(r,d) (r).miip_rxbhr2[0] = d
#define BCM53128_A0_MIIP_RXBHR2r_GET(r) (r).miip_rxbhr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR2r_MIIP_RXBHR2f_GET(r) (((r).miip_rxbhr2[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR2r_MIIP_RXBHR2f_SET(r,f) (r).miip_rxbhr2[0]=(((r).miip_rxbhr2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR2.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR2r,(r._miip_rxbhr2),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR2r,&(r._miip_rxbhr2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR2r BCM53128_A0_MIIP_RXBHR2r
#define MIIP_RXBHR2r_SIZE BCM53128_A0_MIIP_RXBHR2r_SIZE
typedef BCM53128_A0_MIIP_RXBHR2r_t MIIP_RXBHR2r_t;
#define MIIP_RXBHR2r_CLR BCM53128_A0_MIIP_RXBHR2r_CLR
#define MIIP_RXBHR2r_SET BCM53128_A0_MIIP_RXBHR2r_SET
#define MIIP_RXBHR2r_GET BCM53128_A0_MIIP_RXBHR2r_GET
#define MIIP_RXBHR2r_MIIP_RXBHR2f_GET BCM53128_A0_MIIP_RXBHR2r_MIIP_RXBHR2f_GET
#define MIIP_RXBHR2r_MIIP_RXBHR2f_SET BCM53128_A0_MIIP_RXBHR2r_MIIP_RXBHR2f_SET
#define READ_MIIP_RXBHR2r BCM53128_A0_READ_MIIP_RXBHR2r
#define WRITE_MIIP_RXBHR2r BCM53128_A0_WRITE_MIIP_RXBHR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR3
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 3 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR3      The 4th received byte of header as presented on the header format :bits [7:0] if op-code = 3'b000, orbits [39:32] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR3r 0x0000ff54

#define BCM53128_A0_MIIP_RXBHR3r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR3.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR3r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr3[1];
	uint32_t _miip_rxbhr3;
} BCM53128_A0_MIIP_RXBHR3r_t;

#define BCM53128_A0_MIIP_RXBHR3r_CLR(r) (r).miip_rxbhr3[0] = 0
#define BCM53128_A0_MIIP_RXBHR3r_SET(r,d) (r).miip_rxbhr3[0] = d
#define BCM53128_A0_MIIP_RXBHR3r_GET(r) (r).miip_rxbhr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR3r_MIIP_RXBHR3f_GET(r) (((r).miip_rxbhr3[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR3r_MIIP_RXBHR3f_SET(r,f) (r).miip_rxbhr3[0]=(((r).miip_rxbhr3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR3.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR3r,(r._miip_rxbhr3),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR3r,&(r._miip_rxbhr3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR3r BCM53128_A0_MIIP_RXBHR3r
#define MIIP_RXBHR3r_SIZE BCM53128_A0_MIIP_RXBHR3r_SIZE
typedef BCM53128_A0_MIIP_RXBHR3r_t MIIP_RXBHR3r_t;
#define MIIP_RXBHR3r_CLR BCM53128_A0_MIIP_RXBHR3r_CLR
#define MIIP_RXBHR3r_SET BCM53128_A0_MIIP_RXBHR3r_SET
#define MIIP_RXBHR3r_GET BCM53128_A0_MIIP_RXBHR3r_GET
#define MIIP_RXBHR3r_MIIP_RXBHR3f_GET BCM53128_A0_MIIP_RXBHR3r_MIIP_RXBHR3f_GET
#define MIIP_RXBHR3r_MIIP_RXBHR3f_SET BCM53128_A0_MIIP_RXBHR3r_MIIP_RXBHR3f_SET
#define READ_MIIP_RXBHR3r BCM53128_A0_READ_MIIP_RXBHR3r
#define WRITE_MIIP_RXBHR3r BCM53128_A0_WRITE_MIIP_RXBHR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR4
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 4 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR4      The 5th received byte of header as presented on the header format :bits [31:24] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR4r 0x0000ff55

#define BCM53128_A0_MIIP_RXBHR4r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR4.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR4r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr4[1];
	uint32_t _miip_rxbhr4;
} BCM53128_A0_MIIP_RXBHR4r_t;

#define BCM53128_A0_MIIP_RXBHR4r_CLR(r) (r).miip_rxbhr4[0] = 0
#define BCM53128_A0_MIIP_RXBHR4r_SET(r,d) (r).miip_rxbhr4[0] = d
#define BCM53128_A0_MIIP_RXBHR4r_GET(r) (r).miip_rxbhr4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR4r_MIIP_RXBHR4f_GET(r) (((r).miip_rxbhr4[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR4r_MIIP_RXBHR4f_SET(r,f) (r).miip_rxbhr4[0]=(((r).miip_rxbhr4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR4.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR4r,(r._miip_rxbhr4),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR4r,&(r._miip_rxbhr4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR4r BCM53128_A0_MIIP_RXBHR4r
#define MIIP_RXBHR4r_SIZE BCM53128_A0_MIIP_RXBHR4r_SIZE
typedef BCM53128_A0_MIIP_RXBHR4r_t MIIP_RXBHR4r_t;
#define MIIP_RXBHR4r_CLR BCM53128_A0_MIIP_RXBHR4r_CLR
#define MIIP_RXBHR4r_SET BCM53128_A0_MIIP_RXBHR4r_SET
#define MIIP_RXBHR4r_GET BCM53128_A0_MIIP_RXBHR4r_GET
#define MIIP_RXBHR4r_MIIP_RXBHR4f_GET BCM53128_A0_MIIP_RXBHR4r_MIIP_RXBHR4f_GET
#define MIIP_RXBHR4r_MIIP_RXBHR4f_SET BCM53128_A0_MIIP_RXBHR4r_MIIP_RXBHR4f_SET
#define READ_MIIP_RXBHR4r BCM53128_A0_READ_MIIP_RXBHR4r
#define WRITE_MIIP_RXBHR4r BCM53128_A0_WRITE_MIIP_RXBHR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR5
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 5 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR5      The 6th received byte of header as presented on the header format :bits [23:16] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR5r 0x0000ff56

#define BCM53128_A0_MIIP_RXBHR5r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR5.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR5r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr5[1];
	uint32_t _miip_rxbhr5;
} BCM53128_A0_MIIP_RXBHR5r_t;

#define BCM53128_A0_MIIP_RXBHR5r_CLR(r) (r).miip_rxbhr5[0] = 0
#define BCM53128_A0_MIIP_RXBHR5r_SET(r,d) (r).miip_rxbhr5[0] = d
#define BCM53128_A0_MIIP_RXBHR5r_GET(r) (r).miip_rxbhr5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR5r_MIIP_RXBHR5f_GET(r) (((r).miip_rxbhr5[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR5r_MIIP_RXBHR5f_SET(r,f) (r).miip_rxbhr5[0]=(((r).miip_rxbhr5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR5.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR5r,(r._miip_rxbhr5),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR5r,&(r._miip_rxbhr5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR5r BCM53128_A0_MIIP_RXBHR5r
#define MIIP_RXBHR5r_SIZE BCM53128_A0_MIIP_RXBHR5r_SIZE
typedef BCM53128_A0_MIIP_RXBHR5r_t MIIP_RXBHR5r_t;
#define MIIP_RXBHR5r_CLR BCM53128_A0_MIIP_RXBHR5r_CLR
#define MIIP_RXBHR5r_SET BCM53128_A0_MIIP_RXBHR5r_SET
#define MIIP_RXBHR5r_GET BCM53128_A0_MIIP_RXBHR5r_GET
#define MIIP_RXBHR5r_MIIP_RXBHR5f_GET BCM53128_A0_MIIP_RXBHR5r_MIIP_RXBHR5f_GET
#define MIIP_RXBHR5r_MIIP_RXBHR5f_SET BCM53128_A0_MIIP_RXBHR5r_MIIP_RXBHR5f_SET
#define READ_MIIP_RXBHR5r BCM53128_A0_READ_MIIP_RXBHR5r
#define WRITE_MIIP_RXBHR5r BCM53128_A0_WRITE_MIIP_RXBHR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR6
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 6 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR6      The 7th received byte of header as presented on the header format :bits [15:8] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR6r 0x0000ff57

#define BCM53128_A0_MIIP_RXBHR6r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR6.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR6r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr6[1];
	uint32_t _miip_rxbhr6;
} BCM53128_A0_MIIP_RXBHR6r_t;

#define BCM53128_A0_MIIP_RXBHR6r_CLR(r) (r).miip_rxbhr6[0] = 0
#define BCM53128_A0_MIIP_RXBHR6r_SET(r,d) (r).miip_rxbhr6[0] = d
#define BCM53128_A0_MIIP_RXBHR6r_GET(r) (r).miip_rxbhr6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR6r_MIIP_RXBHR6f_GET(r) (((r).miip_rxbhr6[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR6r_MIIP_RXBHR6f_SET(r,f) (r).miip_rxbhr6[0]=(((r).miip_rxbhr6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR6.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR6r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR6r,(r._miip_rxbhr6),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR6r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR6r,&(r._miip_rxbhr6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR6r BCM53128_A0_MIIP_RXBHR6r
#define MIIP_RXBHR6r_SIZE BCM53128_A0_MIIP_RXBHR6r_SIZE
typedef BCM53128_A0_MIIP_RXBHR6r_t MIIP_RXBHR6r_t;
#define MIIP_RXBHR6r_CLR BCM53128_A0_MIIP_RXBHR6r_CLR
#define MIIP_RXBHR6r_SET BCM53128_A0_MIIP_RXBHR6r_SET
#define MIIP_RXBHR6r_GET BCM53128_A0_MIIP_RXBHR6r_GET
#define MIIP_RXBHR6r_MIIP_RXBHR6f_GET BCM53128_A0_MIIP_RXBHR6r_MIIP_RXBHR6f_GET
#define MIIP_RXBHR6r_MIIP_RXBHR6f_SET BCM53128_A0_MIIP_RXBHR6r_MIIP_RXBHR6f_SET
#define READ_MIIP_RXBHR6r BCM53128_A0_READ_MIIP_RXBHR6r
#define WRITE_MIIP_RXBHR6r BCM53128_A0_WRITE_MIIP_RXBHR6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXBHR7
 * BLOCKS:   SYS
 * DESC:     RX BRCM Header Byte 7 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXBHR7      The 8th received byte of header as presented on the header format :bits [7:0] if op-code = 3'b001.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXBHR7r 0x0000ff58

#define BCM53128_A0_MIIP_RXBHR7r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXBHR7.
 *
 */
typedef union BCM53128_A0_MIIP_RXBHR7r_s {
	uint32_t v[1];
	uint32_t miip_rxbhr7[1];
	uint32_t _miip_rxbhr7;
} BCM53128_A0_MIIP_RXBHR7r_t;

#define BCM53128_A0_MIIP_RXBHR7r_CLR(r) (r).miip_rxbhr7[0] = 0
#define BCM53128_A0_MIIP_RXBHR7r_SET(r,d) (r).miip_rxbhr7[0] = d
#define BCM53128_A0_MIIP_RXBHR7r_GET(r) (r).miip_rxbhr7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXBHR7r_MIIP_RXBHR7f_GET(r) (((r).miip_rxbhr7[0]) & 0xff)
#define BCM53128_A0_MIIP_RXBHR7r_MIIP_RXBHR7f_SET(r,f) (r).miip_rxbhr7[0]=(((r).miip_rxbhr7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXBHR7.
 *
 */
#define BCM53128_A0_READ_MIIP_RXBHR7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXBHR7r,(r._miip_rxbhr7),1)
#define BCM53128_A0_WRITE_MIIP_RXBHR7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXBHR7r,&(r._miip_rxbhr7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXBHR7r BCM53128_A0_MIIP_RXBHR7r
#define MIIP_RXBHR7r_SIZE BCM53128_A0_MIIP_RXBHR7r_SIZE
typedef BCM53128_A0_MIIP_RXBHR7r_t MIIP_RXBHR7r_t;
#define MIIP_RXBHR7r_CLR BCM53128_A0_MIIP_RXBHR7r_CLR
#define MIIP_RXBHR7r_SET BCM53128_A0_MIIP_RXBHR7r_SET
#define MIIP_RXBHR7r_GET BCM53128_A0_MIIP_RXBHR7r_GET
#define MIIP_RXBHR7r_MIIP_RXBHR7f_GET BCM53128_A0_MIIP_RXBHR7r_MIIP_RXBHR7f_GET
#define MIIP_RXBHR7r_MIIP_RXBHR7f_SET BCM53128_A0_MIIP_RXBHR7r_MIIP_RXBHR7f_SET
#define READ_MIIP_RXBHR7r BCM53128_A0_READ_MIIP_RXBHR7r
#define WRITE_MIIP_RXBHR7r BCM53128_A0_WRITE_MIIP_RXBHR7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXBHR7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXCSR
 * BLOCKS:   SYS
 * DESC:     RX DMA Control/Status Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXSTS       Receive Status[6], complete okay[5], reserved, returns 0 to read[4], Error summary. Set to 1 if any error conditions are occurred.(bits 3:0)[3], complete with CRC error. (debug only, the DV should monitor this bit, the simulation should stop and print out RX CRC Error message if this bit is set)[2], RX FIFO overflow. (debug only, the DV should monitor this bit, the simulation should stop and print out FIFO Overflow Error message if this bit is set)[1], Packet is truncated due to length exceeds the allocated buffer.[0], RX DMA corrupted due to missing packet header. (debug only, the DV should monitor this bit, the simulation should stop and print out Corrupted RX Packet Error message if this bit is set).
 *     MIIP_RXSTART     RX DMA start bit.Software can only set this bit to 1'b1, the hardware will automatically clear this bit when received a packet.Note: Writing any value to 0xFF4A set this bit.When reading this bit:=1, busy.=0, the RX DMA has received a packet and ready to accept a new one.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXCSRr 0x0000ff4a

#define BCM53128_A0_MIIP_RXCSRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXCSR.
 *
 */
typedef union BCM53128_A0_MIIP_RXCSRr_s {
	uint32_t v[1];
	uint32_t miip_rxcsr[1];
	uint32_t _miip_rxcsr;
} BCM53128_A0_MIIP_RXCSRr_t;

#define BCM53128_A0_MIIP_RXCSRr_CLR(r) (r).miip_rxcsr[0] = 0
#define BCM53128_A0_MIIP_RXCSRr_SET(r,d) (r).miip_rxcsr[0] = d
#define BCM53128_A0_MIIP_RXCSRr_GET(r) (r).miip_rxcsr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTSf_GET(r) (((r).miip_rxcsr[0]) & 0x7f)
#define BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTSf_SET(r,f) (r).miip_rxcsr[0]=(((r).miip_rxcsr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTARTf_GET(r) ((((r).miip_rxcsr[0]) >> 7) & 0x1)
#define BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTARTf_SET(r,f) (r).miip_rxcsr[0]=(((r).miip_rxcsr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIIP_RXCSR.
 *
 */
#define BCM53128_A0_READ_MIIP_RXCSRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXCSRr,(r._miip_rxcsr),1)
#define BCM53128_A0_WRITE_MIIP_RXCSRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXCSRr,&(r._miip_rxcsr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXCSRr BCM53128_A0_MIIP_RXCSRr
#define MIIP_RXCSRr_SIZE BCM53128_A0_MIIP_RXCSRr_SIZE
typedef BCM53128_A0_MIIP_RXCSRr_t MIIP_RXCSRr_t;
#define MIIP_RXCSRr_CLR BCM53128_A0_MIIP_RXCSRr_CLR
#define MIIP_RXCSRr_SET BCM53128_A0_MIIP_RXCSRr_SET
#define MIIP_RXCSRr_GET BCM53128_A0_MIIP_RXCSRr_GET
#define MIIP_RXCSRr_MIIP_RXSTSf_GET BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTSf_GET
#define MIIP_RXCSRr_MIIP_RXSTSf_SET BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTSf_SET
#define MIIP_RXCSRr_MIIP_RXSTARTf_GET BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTARTf_GET
#define MIIP_RXCSRr_MIIP_RXSTARTf_SET BCM53128_A0_MIIP_RXCSRr_MIIP_RXSTARTf_SET
#define READ_MIIP_RXCSRr BCM53128_A0_READ_MIIP_RXCSRr
#define WRITE_MIIP_RXCSRr BCM53128_A0_WRITE_MIIP_RXCSRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXCSRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXPLH
 * BLOCKS:   SYS
 * DESC:     RX Packet Length Register, high byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXPLH       This field shows the received packet's length (excluding 4 bytes of CRC)High byte of the 16-bit sizeThe length includes BRCM header if header extraction is disabled. Otherwise, header size is excluded.Note: the RX packet length filed indicates the actual received packet length regardless of whether the packet is truncated.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXPLHr 0x0000ff4f

#define BCM53128_A0_MIIP_RXPLHr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXPLH.
 *
 */
typedef union BCM53128_A0_MIIP_RXPLHr_s {
	uint32_t v[1];
	uint32_t miip_rxplh[1];
	uint32_t _miip_rxplh;
} BCM53128_A0_MIIP_RXPLHr_t;

#define BCM53128_A0_MIIP_RXPLHr_CLR(r) (r).miip_rxplh[0] = 0
#define BCM53128_A0_MIIP_RXPLHr_SET(r,d) (r).miip_rxplh[0] = d
#define BCM53128_A0_MIIP_RXPLHr_GET(r) (r).miip_rxplh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXPLHr_MIIP_RXPLHf_GET(r) (((r).miip_rxplh[0]) & 0xff)
#define BCM53128_A0_MIIP_RXPLHr_MIIP_RXPLHf_SET(r,f) (r).miip_rxplh[0]=(((r).miip_rxplh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXPLH.
 *
 */
#define BCM53128_A0_READ_MIIP_RXPLHr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXPLHr,(r._miip_rxplh),1)
#define BCM53128_A0_WRITE_MIIP_RXPLHr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXPLHr,&(r._miip_rxplh),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXPLHr BCM53128_A0_MIIP_RXPLHr
#define MIIP_RXPLHr_SIZE BCM53128_A0_MIIP_RXPLHr_SIZE
typedef BCM53128_A0_MIIP_RXPLHr_t MIIP_RXPLHr_t;
#define MIIP_RXPLHr_CLR BCM53128_A0_MIIP_RXPLHr_CLR
#define MIIP_RXPLHr_SET BCM53128_A0_MIIP_RXPLHr_SET
#define MIIP_RXPLHr_GET BCM53128_A0_MIIP_RXPLHr_GET
#define MIIP_RXPLHr_MIIP_RXPLHf_GET BCM53128_A0_MIIP_RXPLHr_MIIP_RXPLHf_GET
#define MIIP_RXPLHr_MIIP_RXPLHf_SET BCM53128_A0_MIIP_RXPLHr_MIIP_RXPLHf_SET
#define READ_MIIP_RXPLHr BCM53128_A0_READ_MIIP_RXPLHr
#define WRITE_MIIP_RXPLHr BCM53128_A0_WRITE_MIIP_RXPLHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXPLHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXPLL
 * BLOCKS:   SYS
 * DESC:     RX Packet Length Register, low byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXPLL       Low byte of the 16-bit size
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXPLLr 0x0000ff50

#define BCM53128_A0_MIIP_RXPLLr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXPLL.
 *
 */
typedef union BCM53128_A0_MIIP_RXPLLr_s {
	uint32_t v[1];
	uint32_t miip_rxpll[1];
	uint32_t _miip_rxpll;
} BCM53128_A0_MIIP_RXPLLr_t;

#define BCM53128_A0_MIIP_RXPLLr_CLR(r) (r).miip_rxpll[0] = 0
#define BCM53128_A0_MIIP_RXPLLr_SET(r,d) (r).miip_rxpll[0] = d
#define BCM53128_A0_MIIP_RXPLLr_GET(r) (r).miip_rxpll[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXPLLr_MIIP_RXPLLf_GET(r) (((r).miip_rxpll[0]) & 0xff)
#define BCM53128_A0_MIIP_RXPLLr_MIIP_RXPLLf_SET(r,f) (r).miip_rxpll[0]=(((r).miip_rxpll[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXPLL.
 *
 */
#define BCM53128_A0_READ_MIIP_RXPLLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXPLLr,(r._miip_rxpll),1)
#define BCM53128_A0_WRITE_MIIP_RXPLLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXPLLr,&(r._miip_rxpll),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXPLLr BCM53128_A0_MIIP_RXPLLr
#define MIIP_RXPLLr_SIZE BCM53128_A0_MIIP_RXPLLr_SIZE
typedef BCM53128_A0_MIIP_RXPLLr_t MIIP_RXPLLr_t;
#define MIIP_RXPLLr_CLR BCM53128_A0_MIIP_RXPLLr_CLR
#define MIIP_RXPLLr_SET BCM53128_A0_MIIP_RXPLLr_SET
#define MIIP_RXPLLr_GET BCM53128_A0_MIIP_RXPLLr_GET
#define MIIP_RXPLLr_MIIP_RXPLLf_GET BCM53128_A0_MIIP_RXPLLr_MIIP_RXPLLf_GET
#define MIIP_RXPLLr_MIIP_RXPLLf_SET BCM53128_A0_MIIP_RXPLLr_MIIP_RXPLLf_SET
#define READ_MIIP_RXPLLr BCM53128_A0_READ_MIIP_RXPLLr
#define WRITE_MIIP_RXPLLr BCM53128_A0_WRITE_MIIP_RXPLLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXPLLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXSWRR
 * BLOCKS:   SYS
 * DESC:     RX Software Reset Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXSWR       RX Software ResetWriting 1 enables the software reset.Writing 0 clears the software reset.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXSWRRr 0x0000ff5d

#define BCM53128_A0_MIIP_RXSWRRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXSWRR.
 *
 */
typedef union BCM53128_A0_MIIP_RXSWRRr_s {
	uint32_t v[1];
	uint32_t miip_rxswrr[1];
	uint32_t _miip_rxswrr;
} BCM53128_A0_MIIP_RXSWRRr_t;

#define BCM53128_A0_MIIP_RXSWRRr_CLR(r) (r).miip_rxswrr[0] = 0
#define BCM53128_A0_MIIP_RXSWRRr_SET(r,d) (r).miip_rxswrr[0] = d
#define BCM53128_A0_MIIP_RXSWRRr_GET(r) (r).miip_rxswrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXSWRRr_MIIP_RXSWRf_GET(r) (((r).miip_rxswrr[0]) & 0x1)
#define BCM53128_A0_MIIP_RXSWRRr_MIIP_RXSWRf_SET(r,f) (r).miip_rxswrr[0]=(((r).miip_rxswrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_MIIP_RXSWRRr_RESERVEDf_GET(r) ((((r).miip_rxswrr[0]) >> 1) & 0x7f)
#define BCM53128_A0_MIIP_RXSWRRr_RESERVEDf_SET(r,f) (r).miip_rxswrr[0]=(((r).miip_rxswrr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access MIIP_RXSWRR.
 *
 */
#define BCM53128_A0_READ_MIIP_RXSWRRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXSWRRr,(r._miip_rxswrr),1)
#define BCM53128_A0_WRITE_MIIP_RXSWRRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXSWRRr,&(r._miip_rxswrr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXSWRRr BCM53128_A0_MIIP_RXSWRRr
#define MIIP_RXSWRRr_SIZE BCM53128_A0_MIIP_RXSWRRr_SIZE
typedef BCM53128_A0_MIIP_RXSWRRr_t MIIP_RXSWRRr_t;
#define MIIP_RXSWRRr_CLR BCM53128_A0_MIIP_RXSWRRr_CLR
#define MIIP_RXSWRRr_SET BCM53128_A0_MIIP_RXSWRRr_SET
#define MIIP_RXSWRRr_GET BCM53128_A0_MIIP_RXSWRRr_GET
#define MIIP_RXSWRRr_MIIP_RXSWRf_GET BCM53128_A0_MIIP_RXSWRRr_MIIP_RXSWRf_GET
#define MIIP_RXSWRRr_MIIP_RXSWRf_SET BCM53128_A0_MIIP_RXSWRRr_MIIP_RXSWRf_SET
#define MIIP_RXSWRRr_RESERVEDf_GET BCM53128_A0_MIIP_RXSWRRr_RESERVEDf_GET
#define MIIP_RXSWRRr_RESERVEDf_SET BCM53128_A0_MIIP_RXSWRRr_RESERVEDf_SET
#define READ_MIIP_RXSWRRr BCM53128_A0_READ_MIIP_RXSWRRr
#define WRITE_MIIP_RXSWRRr BCM53128_A0_WRITE_MIIP_RXSWRRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXSWRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXSZH
 * BLOCKS:   SYS
 * DESC:     RX Buffer Size Register, high byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXSZH       Allocated buffer size.Note: the allocated RX buffer size should be large enough to cover CRC field and should be a multiple of 4.High byte of the 16-bit size
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXSZHr 0x0000ff4d

#define BCM53128_A0_MIIP_RXSZHr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXSZH.
 *
 */
typedef union BCM53128_A0_MIIP_RXSZHr_s {
	uint32_t v[1];
	uint32_t miip_rxszh[1];
	uint32_t _miip_rxszh;
} BCM53128_A0_MIIP_RXSZHr_t;

#define BCM53128_A0_MIIP_RXSZHr_CLR(r) (r).miip_rxszh[0] = 0
#define BCM53128_A0_MIIP_RXSZHr_SET(r,d) (r).miip_rxszh[0] = d
#define BCM53128_A0_MIIP_RXSZHr_GET(r) (r).miip_rxszh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXSZHr_MIIP_RXSZHf_GET(r) (((r).miip_rxszh[0]) & 0xff)
#define BCM53128_A0_MIIP_RXSZHr_MIIP_RXSZHf_SET(r,f) (r).miip_rxszh[0]=(((r).miip_rxszh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXSZH.
 *
 */
#define BCM53128_A0_READ_MIIP_RXSZHr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXSZHr,(r._miip_rxszh),1)
#define BCM53128_A0_WRITE_MIIP_RXSZHr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXSZHr,&(r._miip_rxszh),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXSZHr BCM53128_A0_MIIP_RXSZHr
#define MIIP_RXSZHr_SIZE BCM53128_A0_MIIP_RXSZHr_SIZE
typedef BCM53128_A0_MIIP_RXSZHr_t MIIP_RXSZHr_t;
#define MIIP_RXSZHr_CLR BCM53128_A0_MIIP_RXSZHr_CLR
#define MIIP_RXSZHr_SET BCM53128_A0_MIIP_RXSZHr_SET
#define MIIP_RXSZHr_GET BCM53128_A0_MIIP_RXSZHr_GET
#define MIIP_RXSZHr_MIIP_RXSZHf_GET BCM53128_A0_MIIP_RXSZHr_MIIP_RXSZHf_GET
#define MIIP_RXSZHr_MIIP_RXSZHf_SET BCM53128_A0_MIIP_RXSZHr_MIIP_RXSZHf_SET
#define READ_MIIP_RXSZHr BCM53128_A0_READ_MIIP_RXSZHr
#define WRITE_MIIP_RXSZHr BCM53128_A0_WRITE_MIIP_RXSZHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXSZHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_RXSZL
 * BLOCKS:   SYS
 * DESC:     RX Buffer Size Register, low byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_RXSZL       Allocated buffer size Low byte of the 16-bit size
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_RXSZLr 0x0000ff4e

#define BCM53128_A0_MIIP_RXSZLr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_RXSZL.
 *
 */
typedef union BCM53128_A0_MIIP_RXSZLr_s {
	uint32_t v[1];
	uint32_t miip_rxszl[1];
	uint32_t _miip_rxszl;
} BCM53128_A0_MIIP_RXSZLr_t;

#define BCM53128_A0_MIIP_RXSZLr_CLR(r) (r).miip_rxszl[0] = 0
#define BCM53128_A0_MIIP_RXSZLr_SET(r,d) (r).miip_rxszl[0] = d
#define BCM53128_A0_MIIP_RXSZLr_GET(r) (r).miip_rxszl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_RXSZLr_MIIP_RXSZLf_GET(r) (((r).miip_rxszl[0]) & 0xff)
#define BCM53128_A0_MIIP_RXSZLr_MIIP_RXSZLf_SET(r,f) (r).miip_rxszl[0]=(((r).miip_rxszl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_RXSZL.
 *
 */
#define BCM53128_A0_READ_MIIP_RXSZLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_RXSZLr,(r._miip_rxszl),1)
#define BCM53128_A0_WRITE_MIIP_RXSZLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_RXSZLr,&(r._miip_rxszl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_RXSZLr BCM53128_A0_MIIP_RXSZLr
#define MIIP_RXSZLr_SIZE BCM53128_A0_MIIP_RXSZLr_SIZE
typedef BCM53128_A0_MIIP_RXSZLr_t MIIP_RXSZLr_t;
#define MIIP_RXSZLr_CLR BCM53128_A0_MIIP_RXSZLr_CLR
#define MIIP_RXSZLr_SET BCM53128_A0_MIIP_RXSZLr_SET
#define MIIP_RXSZLr_GET BCM53128_A0_MIIP_RXSZLr_GET
#define MIIP_RXSZLr_MIIP_RXSZLf_GET BCM53128_A0_MIIP_RXSZLr_MIIP_RXSZLf_GET
#define MIIP_RXSZLr_MIIP_RXSZLf_SET BCM53128_A0_MIIP_RXSZLr_MIIP_RXSZLf_SET
#define READ_MIIP_RXSZLr BCM53128_A0_READ_MIIP_RXSZLr
#define WRITE_MIIP_RXSZLr BCM53128_A0_WRITE_MIIP_RXSZLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_RXSZLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXADRH
 * BLOCKS:   SYS
 * DESC:     TX Address Register, high Byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXADRH      TX Address Register. Packet's memory addressHigh byte of the 16-bit address
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXADRHr 0x0000ff42

#define BCM53128_A0_MIIP_TXADRHr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXADRH.
 *
 */
typedef union BCM53128_A0_MIIP_TXADRHr_s {
	uint32_t v[1];
	uint32_t miip_txadrh[1];
	uint32_t _miip_txadrh;
} BCM53128_A0_MIIP_TXADRHr_t;

#define BCM53128_A0_MIIP_TXADRHr_CLR(r) (r).miip_txadrh[0] = 0
#define BCM53128_A0_MIIP_TXADRHr_SET(r,d) (r).miip_txadrh[0] = d
#define BCM53128_A0_MIIP_TXADRHr_GET(r) (r).miip_txadrh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXADRHr_MIIP_TXADRHf_GET(r) (((r).miip_txadrh[0]) & 0xff)
#define BCM53128_A0_MIIP_TXADRHr_MIIP_TXADRHf_SET(r,f) (r).miip_txadrh[0]=(((r).miip_txadrh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXADRH.
 *
 */
#define BCM53128_A0_READ_MIIP_TXADRHr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXADRHr,(r._miip_txadrh),1)
#define BCM53128_A0_WRITE_MIIP_TXADRHr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXADRHr,&(r._miip_txadrh),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXADRHr BCM53128_A0_MIIP_TXADRHr
#define MIIP_TXADRHr_SIZE BCM53128_A0_MIIP_TXADRHr_SIZE
typedef BCM53128_A0_MIIP_TXADRHr_t MIIP_TXADRHr_t;
#define MIIP_TXADRHr_CLR BCM53128_A0_MIIP_TXADRHr_CLR
#define MIIP_TXADRHr_SET BCM53128_A0_MIIP_TXADRHr_SET
#define MIIP_TXADRHr_GET BCM53128_A0_MIIP_TXADRHr_GET
#define MIIP_TXADRHr_MIIP_TXADRHf_GET BCM53128_A0_MIIP_TXADRHr_MIIP_TXADRHf_GET
#define MIIP_TXADRHr_MIIP_TXADRHf_SET BCM53128_A0_MIIP_TXADRHr_MIIP_TXADRHf_SET
#define READ_MIIP_TXADRHr BCM53128_A0_READ_MIIP_TXADRHr
#define WRITE_MIIP_TXADRHr BCM53128_A0_WRITE_MIIP_TXADRHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXADRHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXADRL
 * BLOCKS:   SYS
 * DESC:     TX Address Register, low Byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXADRL      TX Address Register. Packet's memory addressLow byte of the 16-bit address
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXADRLr 0x0000ff43

#define BCM53128_A0_MIIP_TXADRLr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXADRL.
 *
 */
typedef union BCM53128_A0_MIIP_TXADRLr_s {
	uint32_t v[1];
	uint32_t miip_txadrl[1];
	uint32_t _miip_txadrl;
} BCM53128_A0_MIIP_TXADRLr_t;

#define BCM53128_A0_MIIP_TXADRLr_CLR(r) (r).miip_txadrl[0] = 0
#define BCM53128_A0_MIIP_TXADRLr_SET(r,d) (r).miip_txadrl[0] = d
#define BCM53128_A0_MIIP_TXADRLr_GET(r) (r).miip_txadrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXADRLr_MIIP_TXADRLf_GET(r) (((r).miip_txadrl[0]) & 0xff)
#define BCM53128_A0_MIIP_TXADRLr_MIIP_TXADRLf_SET(r,f) (r).miip_txadrl[0]=(((r).miip_txadrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXADRL.
 *
 */
#define BCM53128_A0_READ_MIIP_TXADRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXADRLr,(r._miip_txadrl),1)
#define BCM53128_A0_WRITE_MIIP_TXADRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXADRLr,&(r._miip_txadrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXADRLr BCM53128_A0_MIIP_TXADRLr
#define MIIP_TXADRLr_SIZE BCM53128_A0_MIIP_TXADRLr_SIZE
typedef BCM53128_A0_MIIP_TXADRLr_t MIIP_TXADRLr_t;
#define MIIP_TXADRLr_CLR BCM53128_A0_MIIP_TXADRLr_CLR
#define MIIP_TXADRLr_SET BCM53128_A0_MIIP_TXADRLr_SET
#define MIIP_TXADRLr_GET BCM53128_A0_MIIP_TXADRLr_GET
#define MIIP_TXADRLr_MIIP_TXADRLf_GET BCM53128_A0_MIIP_TXADRLr_MIIP_TXADRLf_GET
#define MIIP_TXADRLr_MIIP_TXADRLf_SET BCM53128_A0_MIIP_TXADRLr_MIIP_TXADRLf_SET
#define READ_MIIP_TXADRLr BCM53128_A0_READ_MIIP_TXADRLr
#define WRITE_MIIP_TXADRLr BCM53128_A0_WRITE_MIIP_TXADRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXADRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXBHR0
 * BLOCKS:   SYS
 * DESC:     TX BRCM Header Byte 0 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXBHR0      The first transmitted byte of header as presented on the header format, bits [31:24].
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXBHR0r 0x0000ff46

#define BCM53128_A0_MIIP_TXBHR0r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXBHR0.
 *
 */
typedef union BCM53128_A0_MIIP_TXBHR0r_s {
	uint32_t v[1];
	uint32_t miip_txbhr0[1];
	uint32_t _miip_txbhr0;
} BCM53128_A0_MIIP_TXBHR0r_t;

#define BCM53128_A0_MIIP_TXBHR0r_CLR(r) (r).miip_txbhr0[0] = 0
#define BCM53128_A0_MIIP_TXBHR0r_SET(r,d) (r).miip_txbhr0[0] = d
#define BCM53128_A0_MIIP_TXBHR0r_GET(r) (r).miip_txbhr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXBHR0r_MIIP_TXBHR0f_GET(r) (((r).miip_txbhr0[0]) & 0xff)
#define BCM53128_A0_MIIP_TXBHR0r_MIIP_TXBHR0f_SET(r,f) (r).miip_txbhr0[0]=(((r).miip_txbhr0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXBHR0.
 *
 */
#define BCM53128_A0_READ_MIIP_TXBHR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXBHR0r,(r._miip_txbhr0),1)
#define BCM53128_A0_WRITE_MIIP_TXBHR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXBHR0r,&(r._miip_txbhr0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXBHR0r BCM53128_A0_MIIP_TXBHR0r
#define MIIP_TXBHR0r_SIZE BCM53128_A0_MIIP_TXBHR0r_SIZE
typedef BCM53128_A0_MIIP_TXBHR0r_t MIIP_TXBHR0r_t;
#define MIIP_TXBHR0r_CLR BCM53128_A0_MIIP_TXBHR0r_CLR
#define MIIP_TXBHR0r_SET BCM53128_A0_MIIP_TXBHR0r_SET
#define MIIP_TXBHR0r_GET BCM53128_A0_MIIP_TXBHR0r_GET
#define MIIP_TXBHR0r_MIIP_TXBHR0f_GET BCM53128_A0_MIIP_TXBHR0r_MIIP_TXBHR0f_GET
#define MIIP_TXBHR0r_MIIP_TXBHR0f_SET BCM53128_A0_MIIP_TXBHR0r_MIIP_TXBHR0f_SET
#define READ_MIIP_TXBHR0r BCM53128_A0_READ_MIIP_TXBHR0r
#define WRITE_MIIP_TXBHR0r BCM53128_A0_WRITE_MIIP_TXBHR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXBHR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXBHR1
 * BLOCKS:   SYS
 * DESC:     TX BRCM Header Byte 1 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXBHR1      The 2nd transmitted byte of header as presented on the header format, bits [23:16].
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXBHR1r 0x0000ff47

#define BCM53128_A0_MIIP_TXBHR1r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXBHR1.
 *
 */
typedef union BCM53128_A0_MIIP_TXBHR1r_s {
	uint32_t v[1];
	uint32_t miip_txbhr1[1];
	uint32_t _miip_txbhr1;
} BCM53128_A0_MIIP_TXBHR1r_t;

#define BCM53128_A0_MIIP_TXBHR1r_CLR(r) (r).miip_txbhr1[0] = 0
#define BCM53128_A0_MIIP_TXBHR1r_SET(r,d) (r).miip_txbhr1[0] = d
#define BCM53128_A0_MIIP_TXBHR1r_GET(r) (r).miip_txbhr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXBHR1r_MIIP_TXBHR1f_GET(r) (((r).miip_txbhr1[0]) & 0xff)
#define BCM53128_A0_MIIP_TXBHR1r_MIIP_TXBHR1f_SET(r,f) (r).miip_txbhr1[0]=(((r).miip_txbhr1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXBHR1.
 *
 */
#define BCM53128_A0_READ_MIIP_TXBHR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXBHR1r,(r._miip_txbhr1),1)
#define BCM53128_A0_WRITE_MIIP_TXBHR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXBHR1r,&(r._miip_txbhr1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXBHR1r BCM53128_A0_MIIP_TXBHR1r
#define MIIP_TXBHR1r_SIZE BCM53128_A0_MIIP_TXBHR1r_SIZE
typedef BCM53128_A0_MIIP_TXBHR1r_t MIIP_TXBHR1r_t;
#define MIIP_TXBHR1r_CLR BCM53128_A0_MIIP_TXBHR1r_CLR
#define MIIP_TXBHR1r_SET BCM53128_A0_MIIP_TXBHR1r_SET
#define MIIP_TXBHR1r_GET BCM53128_A0_MIIP_TXBHR1r_GET
#define MIIP_TXBHR1r_MIIP_TXBHR1f_GET BCM53128_A0_MIIP_TXBHR1r_MIIP_TXBHR1f_GET
#define MIIP_TXBHR1r_MIIP_TXBHR1f_SET BCM53128_A0_MIIP_TXBHR1r_MIIP_TXBHR1f_SET
#define READ_MIIP_TXBHR1r BCM53128_A0_READ_MIIP_TXBHR1r
#define WRITE_MIIP_TXBHR1r BCM53128_A0_WRITE_MIIP_TXBHR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXBHR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXBHR2
 * BLOCKS:   SYS
 * DESC:     TX BRCM Header Byte 2 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXBHR2      The 3rd transmitted byte of header as presented on the header format, bits [15:8].
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXBHR2r 0x0000ff48

#define BCM53128_A0_MIIP_TXBHR2r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXBHR2.
 *
 */
typedef union BCM53128_A0_MIIP_TXBHR2r_s {
	uint32_t v[1];
	uint32_t miip_txbhr2[1];
	uint32_t _miip_txbhr2;
} BCM53128_A0_MIIP_TXBHR2r_t;

#define BCM53128_A0_MIIP_TXBHR2r_CLR(r) (r).miip_txbhr2[0] = 0
#define BCM53128_A0_MIIP_TXBHR2r_SET(r,d) (r).miip_txbhr2[0] = d
#define BCM53128_A0_MIIP_TXBHR2r_GET(r) (r).miip_txbhr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXBHR2r_MIIP_TXBHR2f_GET(r) (((r).miip_txbhr2[0]) & 0xff)
#define BCM53128_A0_MIIP_TXBHR2r_MIIP_TXBHR2f_SET(r,f) (r).miip_txbhr2[0]=(((r).miip_txbhr2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXBHR2.
 *
 */
#define BCM53128_A0_READ_MIIP_TXBHR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXBHR2r,(r._miip_txbhr2),1)
#define BCM53128_A0_WRITE_MIIP_TXBHR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXBHR2r,&(r._miip_txbhr2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXBHR2r BCM53128_A0_MIIP_TXBHR2r
#define MIIP_TXBHR2r_SIZE BCM53128_A0_MIIP_TXBHR2r_SIZE
typedef BCM53128_A0_MIIP_TXBHR2r_t MIIP_TXBHR2r_t;
#define MIIP_TXBHR2r_CLR BCM53128_A0_MIIP_TXBHR2r_CLR
#define MIIP_TXBHR2r_SET BCM53128_A0_MIIP_TXBHR2r_SET
#define MIIP_TXBHR2r_GET BCM53128_A0_MIIP_TXBHR2r_GET
#define MIIP_TXBHR2r_MIIP_TXBHR2f_GET BCM53128_A0_MIIP_TXBHR2r_MIIP_TXBHR2f_GET
#define MIIP_TXBHR2r_MIIP_TXBHR2f_SET BCM53128_A0_MIIP_TXBHR2r_MIIP_TXBHR2f_SET
#define READ_MIIP_TXBHR2r BCM53128_A0_READ_MIIP_TXBHR2r
#define WRITE_MIIP_TXBHR2r BCM53128_A0_WRITE_MIIP_TXBHR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXBHR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXBHR3
 * BLOCKS:   SYS
 * DESC:     TX BRCM Header Byte 3 Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXBHR3      The last transmitted byte of header as presented on the header format, bits [7:0].
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXBHR3r 0x0000ff49

#define BCM53128_A0_MIIP_TXBHR3r_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXBHR3.
 *
 */
typedef union BCM53128_A0_MIIP_TXBHR3r_s {
	uint32_t v[1];
	uint32_t miip_txbhr3[1];
	uint32_t _miip_txbhr3;
} BCM53128_A0_MIIP_TXBHR3r_t;

#define BCM53128_A0_MIIP_TXBHR3r_CLR(r) (r).miip_txbhr3[0] = 0
#define BCM53128_A0_MIIP_TXBHR3r_SET(r,d) (r).miip_txbhr3[0] = d
#define BCM53128_A0_MIIP_TXBHR3r_GET(r) (r).miip_txbhr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXBHR3r_MIIP_TXBHR3f_GET(r) (((r).miip_txbhr3[0]) & 0xff)
#define BCM53128_A0_MIIP_TXBHR3r_MIIP_TXBHR3f_SET(r,f) (r).miip_txbhr3[0]=(((r).miip_txbhr3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXBHR3.
 *
 */
#define BCM53128_A0_READ_MIIP_TXBHR3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXBHR3r,(r._miip_txbhr3),1)
#define BCM53128_A0_WRITE_MIIP_TXBHR3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXBHR3r,&(r._miip_txbhr3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXBHR3r BCM53128_A0_MIIP_TXBHR3r
#define MIIP_TXBHR3r_SIZE BCM53128_A0_MIIP_TXBHR3r_SIZE
typedef BCM53128_A0_MIIP_TXBHR3r_t MIIP_TXBHR3r_t;
#define MIIP_TXBHR3r_CLR BCM53128_A0_MIIP_TXBHR3r_CLR
#define MIIP_TXBHR3r_SET BCM53128_A0_MIIP_TXBHR3r_SET
#define MIIP_TXBHR3r_GET BCM53128_A0_MIIP_TXBHR3r_GET
#define MIIP_TXBHR3r_MIIP_TXBHR3f_GET BCM53128_A0_MIIP_TXBHR3r_MIIP_TXBHR3f_GET
#define MIIP_TXBHR3r_MIIP_TXBHR3f_SET BCM53128_A0_MIIP_TXBHR3r_MIIP_TXBHR3f_SET
#define READ_MIIP_TXBHR3r BCM53128_A0_READ_MIIP_TXBHR3r
#define WRITE_MIIP_TXBHR3r BCM53128_A0_WRITE_MIIP_TXBHR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXBHR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXCSR
 * BLOCKS:   SYS
 * DESC:     TX DMA Control/Status Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXSTS       Transmit Status[6], complete okay[5], reserved, returns 0 to read[4], Error summary. Set to 1 if any error conditions are occurred.(bits 3:0)[3], reserved , returns 0 to read[2], TX FIFO underrun (debug only, the DV should monitor this bit, the simulation should stop and print out FIFO Underrun Error message if this bit is set)[1], packet size error, such as a zero size is assigned. (size of packet length in TX descriptor is zero)[0], TX DMA corrupted due to missing packet header (debug only, the DV should monitor this bit, the simulation should stop and print out Corrupted TX Packet Error message if this bit is set).
 *     MIIP_TXSTART     TX DMA start bit.Software can only set this bit to 1'b1, the hardware will automatically clear this bit when transmit is done.Note: Writing any value to 0xFF41 set this bit.When reading this bit:=1, busy.=0, the TX DMA has finished transmitting a packet and ready to accept a new one.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXCSRr 0x0000ff41

#define BCM53128_A0_MIIP_TXCSRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXCSR.
 *
 */
typedef union BCM53128_A0_MIIP_TXCSRr_s {
	uint32_t v[1];
	uint32_t miip_txcsr[1];
	uint32_t _miip_txcsr;
} BCM53128_A0_MIIP_TXCSRr_t;

#define BCM53128_A0_MIIP_TXCSRr_CLR(r) (r).miip_txcsr[0] = 0
#define BCM53128_A0_MIIP_TXCSRr_SET(r,d) (r).miip_txcsr[0] = d
#define BCM53128_A0_MIIP_TXCSRr_GET(r) (r).miip_txcsr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTSf_GET(r) (((r).miip_txcsr[0]) & 0x7f)
#define BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTSf_SET(r,f) (r).miip_txcsr[0]=(((r).miip_txcsr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTARTf_GET(r) ((((r).miip_txcsr[0]) >> 7) & 0x1)
#define BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTARTf_SET(r,f) (r).miip_txcsr[0]=(((r).miip_txcsr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIIP_TXCSR.
 *
 */
#define BCM53128_A0_READ_MIIP_TXCSRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXCSRr,(r._miip_txcsr),1)
#define BCM53128_A0_WRITE_MIIP_TXCSRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXCSRr,&(r._miip_txcsr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXCSRr BCM53128_A0_MIIP_TXCSRr
#define MIIP_TXCSRr_SIZE BCM53128_A0_MIIP_TXCSRr_SIZE
typedef BCM53128_A0_MIIP_TXCSRr_t MIIP_TXCSRr_t;
#define MIIP_TXCSRr_CLR BCM53128_A0_MIIP_TXCSRr_CLR
#define MIIP_TXCSRr_SET BCM53128_A0_MIIP_TXCSRr_SET
#define MIIP_TXCSRr_GET BCM53128_A0_MIIP_TXCSRr_GET
#define MIIP_TXCSRr_MIIP_TXSTSf_GET BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTSf_GET
#define MIIP_TXCSRr_MIIP_TXSTSf_SET BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTSf_SET
#define MIIP_TXCSRr_MIIP_TXSTARTf_GET BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTARTf_GET
#define MIIP_TXCSRr_MIIP_TXSTARTf_SET BCM53128_A0_MIIP_TXCSRr_MIIP_TXSTARTf_SET
#define READ_MIIP_TXCSRr BCM53128_A0_READ_MIIP_TXCSRr
#define WRITE_MIIP_TXCSRr BCM53128_A0_WRITE_MIIP_TXCSRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXCSRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXSWRR
 * BLOCKS:   SYS
 * DESC:     TX Software Reset Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXSWR       TX Software ResetWriting 1 enables the software reset.Writing 0 clears the software reset.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXSWRRr 0x0000ff5c

#define BCM53128_A0_MIIP_TXSWRRr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXSWRR.
 *
 */
typedef union BCM53128_A0_MIIP_TXSWRRr_s {
	uint32_t v[1];
	uint32_t miip_txswrr[1];
	uint32_t _miip_txswrr;
} BCM53128_A0_MIIP_TXSWRRr_t;

#define BCM53128_A0_MIIP_TXSWRRr_CLR(r) (r).miip_txswrr[0] = 0
#define BCM53128_A0_MIIP_TXSWRRr_SET(r,d) (r).miip_txswrr[0] = d
#define BCM53128_A0_MIIP_TXSWRRr_GET(r) (r).miip_txswrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXSWRRr_MIIP_TXSWRf_GET(r) (((r).miip_txswrr[0]) & 0x1)
#define BCM53128_A0_MIIP_TXSWRRr_MIIP_TXSWRf_SET(r,f) (r).miip_txswrr[0]=(((r).miip_txswrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_MIIP_TXSWRRr_RESERVEDf_GET(r) ((((r).miip_txswrr[0]) >> 1) & 0x7f)
#define BCM53128_A0_MIIP_TXSWRRr_RESERVEDf_SET(r,f) (r).miip_txswrr[0]=(((r).miip_txswrr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access MIIP_TXSWRR.
 *
 */
#define BCM53128_A0_READ_MIIP_TXSWRRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXSWRRr,(r._miip_txswrr),1)
#define BCM53128_A0_WRITE_MIIP_TXSWRRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXSWRRr,&(r._miip_txswrr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXSWRRr BCM53128_A0_MIIP_TXSWRRr
#define MIIP_TXSWRRr_SIZE BCM53128_A0_MIIP_TXSWRRr_SIZE
typedef BCM53128_A0_MIIP_TXSWRRr_t MIIP_TXSWRRr_t;
#define MIIP_TXSWRRr_CLR BCM53128_A0_MIIP_TXSWRRr_CLR
#define MIIP_TXSWRRr_SET BCM53128_A0_MIIP_TXSWRRr_SET
#define MIIP_TXSWRRr_GET BCM53128_A0_MIIP_TXSWRRr_GET
#define MIIP_TXSWRRr_MIIP_TXSWRf_GET BCM53128_A0_MIIP_TXSWRRr_MIIP_TXSWRf_GET
#define MIIP_TXSWRRr_MIIP_TXSWRf_SET BCM53128_A0_MIIP_TXSWRRr_MIIP_TXSWRf_SET
#define MIIP_TXSWRRr_RESERVEDf_GET BCM53128_A0_MIIP_TXSWRRr_RESERVEDf_GET
#define MIIP_TXSWRRr_RESERVEDf_SET BCM53128_A0_MIIP_TXSWRRr_RESERVEDf_SET
#define READ_MIIP_TXSWRRr BCM53128_A0_READ_MIIP_TXSWRRr
#define WRITE_MIIP_TXSWRRr BCM53128_A0_WRITE_MIIP_TXSWRRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXSWRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXSZH
 * BLOCKS:   SYS
 * DESC:     TX Size Register, high byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXSZH       TX Size Register. Packet's size (excluding 4 bytes of CRC)High byte of the 16-bit sizeThe size should include BRCM header's size if header insertion is disabled. Otherwise, exclude size of BRCM header.
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXSZHr 0x0000ff44

#define BCM53128_A0_MIIP_TXSZHr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXSZH.
 *
 */
typedef union BCM53128_A0_MIIP_TXSZHr_s {
	uint32_t v[1];
	uint32_t miip_txszh[1];
	uint32_t _miip_txszh;
} BCM53128_A0_MIIP_TXSZHr_t;

#define BCM53128_A0_MIIP_TXSZHr_CLR(r) (r).miip_txszh[0] = 0
#define BCM53128_A0_MIIP_TXSZHr_SET(r,d) (r).miip_txszh[0] = d
#define BCM53128_A0_MIIP_TXSZHr_GET(r) (r).miip_txszh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXSZHr_MIIP_TXSZHf_GET(r) (((r).miip_txszh[0]) & 0xff)
#define BCM53128_A0_MIIP_TXSZHr_MIIP_TXSZHf_SET(r,f) (r).miip_txszh[0]=(((r).miip_txszh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXSZH.
 *
 */
#define BCM53128_A0_READ_MIIP_TXSZHr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXSZHr,(r._miip_txszh),1)
#define BCM53128_A0_WRITE_MIIP_TXSZHr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXSZHr,&(r._miip_txszh),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXSZHr BCM53128_A0_MIIP_TXSZHr
#define MIIP_TXSZHr_SIZE BCM53128_A0_MIIP_TXSZHr_SIZE
typedef BCM53128_A0_MIIP_TXSZHr_t MIIP_TXSZHr_t;
#define MIIP_TXSZHr_CLR BCM53128_A0_MIIP_TXSZHr_CLR
#define MIIP_TXSZHr_SET BCM53128_A0_MIIP_TXSZHr_SET
#define MIIP_TXSZHr_GET BCM53128_A0_MIIP_TXSZHr_GET
#define MIIP_TXSZHr_MIIP_TXSZHf_GET BCM53128_A0_MIIP_TXSZHr_MIIP_TXSZHf_GET
#define MIIP_TXSZHr_MIIP_TXSZHf_SET BCM53128_A0_MIIP_TXSZHr_MIIP_TXSZHf_SET
#define READ_MIIP_TXSZHr BCM53128_A0_READ_MIIP_TXSZHr
#define WRITE_MIIP_TXSZHr BCM53128_A0_WRITE_MIIP_TXSZHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXSZHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIIP_TXSZL
 * BLOCKS:   SYS
 * DESC:     TX Size Register, low byte (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MIIP_TXSZL       TX Size Register. Packet's sizeLow byte of the 16-bit size
 *
 ******************************************************************************/
#define BCM53128_A0_MIIP_TXSZLr 0x0000ff45

#define BCM53128_A0_MIIP_TXSZLr_SIZE 1

/*
 * This structure should be used to declare and program MIIP_TXSZL.
 *
 */
typedef union BCM53128_A0_MIIP_TXSZLr_s {
	uint32_t v[1];
	uint32_t miip_txszl[1];
	uint32_t _miip_txszl;
} BCM53128_A0_MIIP_TXSZLr_t;

#define BCM53128_A0_MIIP_TXSZLr_CLR(r) (r).miip_txszl[0] = 0
#define BCM53128_A0_MIIP_TXSZLr_SET(r,d) (r).miip_txszl[0] = d
#define BCM53128_A0_MIIP_TXSZLr_GET(r) (r).miip_txszl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIIP_TXSZLr_MIIP_TXSZLf_GET(r) (((r).miip_txszl[0]) & 0xff)
#define BCM53128_A0_MIIP_TXSZLr_MIIP_TXSZLf_SET(r,f) (r).miip_txszl[0]=(((r).miip_txszl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIIP_TXSZL.
 *
 */
#define BCM53128_A0_READ_MIIP_TXSZLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIIP_TXSZLr,(r._miip_txszl),1)
#define BCM53128_A0_WRITE_MIIP_TXSZLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIIP_TXSZLr,&(r._miip_txszl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIIP_TXSZLr BCM53128_A0_MIIP_TXSZLr
#define MIIP_TXSZLr_SIZE BCM53128_A0_MIIP_TXSZLr_SIZE
typedef BCM53128_A0_MIIP_TXSZLr_t MIIP_TXSZLr_t;
#define MIIP_TXSZLr_CLR BCM53128_A0_MIIP_TXSZLr_CLR
#define MIIP_TXSZLr_SET BCM53128_A0_MIIP_TXSZLr_SET
#define MIIP_TXSZLr_GET BCM53128_A0_MIIP_TXSZLr_GET
#define MIIP_TXSZLr_MIIP_TXSZLf_GET BCM53128_A0_MIIP_TXSZLr_MIIP_TXSZLf_GET
#define MIIP_TXSZLr_MIIP_TXSZLf_SET BCM53128_A0_MIIP_TXSZLr_MIIP_TXSZLf_SET
#define READ_MIIP_TXSZLr BCM53128_A0_READ_MIIP_TXSZLr
#define WRITE_MIIP_TXSZLr BCM53128_A0_WRITE_MIIP_TXSZLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIIP_TXSZLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MINIMUM_TCP_HDR_SZ
 * BLOCKS:   SYS
 * DESC:     Minimum TCP Header Size Register
 * SIZE:     8
 * FIELDS:
 *     MIN_TCP_HDR_SZ   MIN_TCP_Header_Size is programable between 0 and 255 bytes, inclusive. The default value is set to 20 bytes(TCP header without options).
 *
 ******************************************************************************/
#define BCM53128_A0_MINIMUM_TCP_HDR_SZr 0x00003604

#define BCM53128_A0_MINIMUM_TCP_HDR_SZr_SIZE 1

/*
 * This structure should be used to declare and program MINIMUM_TCP_HDR_SZ.
 *
 */
typedef union BCM53128_A0_MINIMUM_TCP_HDR_SZr_s {
	uint32_t v[1];
	uint32_t minimum_tcp_hdr_sz[1];
	uint32_t _minimum_tcp_hdr_sz;
} BCM53128_A0_MINIMUM_TCP_HDR_SZr_t;

#define BCM53128_A0_MINIMUM_TCP_HDR_SZr_CLR(r) (r).minimum_tcp_hdr_sz[0] = 0
#define BCM53128_A0_MINIMUM_TCP_HDR_SZr_SET(r,d) (r).minimum_tcp_hdr_sz[0] = d
#define BCM53128_A0_MINIMUM_TCP_HDR_SZr_GET(r) (r).minimum_tcp_hdr_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET(r) (((r).minimum_tcp_hdr_sz[0]) & 0xff)
#define BCM53128_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET(r,f) (r).minimum_tcp_hdr_sz[0]=(((r).minimum_tcp_hdr_sz[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MINIMUM_TCP_HDR_SZ.
 *
 */
#define BCM53128_A0_READ_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MINIMUM_TCP_HDR_SZr,(r._minimum_tcp_hdr_sz),1)
#define BCM53128_A0_WRITE_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MINIMUM_TCP_HDR_SZr,&(r._minimum_tcp_hdr_sz),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINIMUM_TCP_HDR_SZr BCM53128_A0_MINIMUM_TCP_HDR_SZr
#define MINIMUM_TCP_HDR_SZr_SIZE BCM53128_A0_MINIMUM_TCP_HDR_SZr_SIZE
typedef BCM53128_A0_MINIMUM_TCP_HDR_SZr_t MINIMUM_TCP_HDR_SZr_t;
#define MINIMUM_TCP_HDR_SZr_CLR BCM53128_A0_MINIMUM_TCP_HDR_SZr_CLR
#define MINIMUM_TCP_HDR_SZr_SET BCM53128_A0_MINIMUM_TCP_HDR_SZr_SET
#define MINIMUM_TCP_HDR_SZr_GET BCM53128_A0_MINIMUM_TCP_HDR_SZr_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET BCM53128_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET BCM53128_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET
#define READ_MINIMUM_TCP_HDR_SZr BCM53128_A0_READ_MINIMUM_TCP_HDR_SZr
#define WRITE_MINIMUM_TCP_HDR_SZr BCM53128_A0_WRITE_MINIMUM_TCP_HDR_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MINIMUM_TCP_HDR_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     16
 * FIELDS:
 *     SMIR_CAP_PORT    Mirror Capture Port ID.Port ID which identifies the single unique port which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *     BLK_NOT_MIR      When Enabled, all traffic to Mirror_Capture_Port will be blocked except mirror traffic.
 *     MIR_EN           Global enable/disable for all mirroring on this chip.When reset, mirroring is disabled.When set, mirroring is enabled according to the ingress and egress control rules, to the port designated by the MIRROR_CAPTURE_PORT.
 *
 ******************************************************************************/
#define BCM53128_A0_MIRCAPCTLr 0x00000210

#define BCM53128_A0_MIRCAPCTLr_SIZE 2

/*
 * This structure should be used to declare and program MIRCAPCTL.
 *
 */
typedef union BCM53128_A0_MIRCAPCTLr_s {
	uint32_t v[1];
	uint32_t mircapctl[1];
	uint32_t _mircapctl;
} BCM53128_A0_MIRCAPCTLr_t;

#define BCM53128_A0_MIRCAPCTLr_CLR(r) (r).mircapctl[0] = 0
#define BCM53128_A0_MIRCAPCTLr_SET(r,d) (r).mircapctl[0] = d
#define BCM53128_A0_MIRCAPCTLr_GET(r) (r).mircapctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET(r) (((r).mircapctl[0]) & 0xf)
#define BCM53128_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_MIRCAPCTLr_RESERVED_0f_GET(r) ((((r).mircapctl[0]) >> 4) & 0x3)
#define BCM53128_A0_MIRCAPCTLr_RESERVED_0f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_MIRCAPCTLr_RESERVED_1f_GET(r) ((((r).mircapctl[0]) >> 6) & 0xff)
#define BCM53128_A0_MIRCAPCTLr_RESERVED_1f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM53128_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET(r) ((((r).mircapctl[0]) >> 14) & 0x1)
#define BCM53128_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_MIRCAPCTLr_MIR_ENf_GET(r) ((((r).mircapctl[0]) >> 15) & 0x1)
#define BCM53128_A0_MIRCAPCTLr_MIR_ENf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIRCAPCTL.
 *
 */
#define BCM53128_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MIRCAPCTLr,(r._mircapctl),2)
#define BCM53128_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MIRCAPCTLr,&(r._mircapctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM53128_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM53128_A0_MIRCAPCTLr_SIZE
typedef BCM53128_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM53128_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM53128_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM53128_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_GET BCM53128_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_SET BCM53128_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET
#define MIRCAPCTLr_RESERVED_0f_GET BCM53128_A0_MIRCAPCTLr_RESERVED_0f_GET
#define MIRCAPCTLr_RESERVED_0f_SET BCM53128_A0_MIRCAPCTLr_RESERVED_0f_SET
#define MIRCAPCTLr_RESERVED_1f_GET BCM53128_A0_MIRCAPCTLr_RESERVED_1f_GET
#define MIRCAPCTLr_RESERVED_1f_SET BCM53128_A0_MIRCAPCTLr_RESERVED_1f_SET
#define MIRCAPCTLr_BLK_NOT_MIRf_GET BCM53128_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET
#define MIRCAPCTLr_BLK_NOT_MIRf_SET BCM53128_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET
#define MIRCAPCTLr_MIR_ENf_GET BCM53128_A0_MIRCAPCTLr_MIR_ENf_GET
#define MIRCAPCTLr_MIR_ENf_SET BCM53128_A0_MIRCAPCTLr_MIR_ENf_SET
#define READ_MIRCAPCTLr BCM53128_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM53128_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MIRCAPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MLF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Multicast Lookup Failed Forward Map Register
 * SIZE:     16
 * FIELDS:
 *     MUL_LOOKUP_FAIL_FRW_MAP Multicast Lookup Failed Forward Map.When Multicat lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register setting.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MLF_DROP_MAPr 0x00000034

#define BCM53128_A0_MLF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_DROP_MAP.
 *
 */
typedef union BCM53128_A0_MLF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_drop_map[1];
	uint32_t _mlf_drop_map;
} BCM53128_A0_MLF_DROP_MAPr_t;

#define BCM53128_A0_MLF_DROP_MAPr_CLR(r) (r).mlf_drop_map[0] = 0
#define BCM53128_A0_MLF_DROP_MAPr_SET(r,d) (r).mlf_drop_map[0] = d
#define BCM53128_A0_MLF_DROP_MAPr_GET(r) (r).mlf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET(r) (((r).mlf_drop_map[0]) & 0x1ff)
#define BCM53128_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MLF_DROP_MAPr_RESERVEDf_GET(r) ((((r).mlf_drop_map[0]) >> 9) & 0x7f)
#define BCM53128_A0_MLF_DROP_MAPr_RESERVEDf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_DROP_MAP.
 *
 */
#define BCM53128_A0_READ_MLF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MLF_DROP_MAPr,(r._mlf_drop_map),2)
#define BCM53128_A0_WRITE_MLF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MLF_DROP_MAPr,&(r._mlf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_DROP_MAPr BCM53128_A0_MLF_DROP_MAPr
#define MLF_DROP_MAPr_SIZE BCM53128_A0_MLF_DROP_MAPr_SIZE
typedef BCM53128_A0_MLF_DROP_MAPr_t MLF_DROP_MAPr_t;
#define MLF_DROP_MAPr_CLR BCM53128_A0_MLF_DROP_MAPr_CLR
#define MLF_DROP_MAPr_SET BCM53128_A0_MLF_DROP_MAPr_SET
#define MLF_DROP_MAPr_GET BCM53128_A0_MLF_DROP_MAPr_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET BCM53128_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET BCM53128_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET
#define MLF_DROP_MAPr_RESERVEDf_GET BCM53128_A0_MLF_DROP_MAPr_RESERVEDf_GET
#define MLF_DROP_MAPr_RESERVEDf_SET BCM53128_A0_MLF_DROP_MAPr_RESERVEDf_SET
#define READ_MLF_DROP_MAPr BCM53128_A0_READ_MLF_DROP_MAPr
#define WRITE_MLF_DROP_MAPr BCM53128_A0_WRITE_MLF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MLF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MLF_IPMC_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     IPMC Forward Map Register
 * SIZE:     16
 * FIELDS:
 *     MLF_IPMC_FWD_MAP IPMC Forward map.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MLF_IPMC_FWD_MAPr 0x00000036

#define BCM53128_A0_MLF_IPMC_FWD_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_IPMC_FWD_MAP.
 *
 */
typedef union BCM53128_A0_MLF_IPMC_FWD_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_ipmc_fwd_map[1];
	uint32_t _mlf_ipmc_fwd_map;
} BCM53128_A0_MLF_IPMC_FWD_MAPr_t;

#define BCM53128_A0_MLF_IPMC_FWD_MAPr_CLR(r) (r).mlf_ipmc_fwd_map[0] = 0
#define BCM53128_A0_MLF_IPMC_FWD_MAPr_SET(r,d) (r).mlf_ipmc_fwd_map[0] = d
#define BCM53128_A0_MLF_IPMC_FWD_MAPr_GET(r) (r).mlf_ipmc_fwd_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET(r) (((r).mlf_ipmc_fwd_map[0]) & 0x1ff)
#define BCM53128_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_GET(r) ((((r).mlf_ipmc_fwd_map[0]) >> 9) & 0x7f)
#define BCM53128_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_IPMC_FWD_MAP.
 *
 */
#define BCM53128_A0_READ_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MLF_IPMC_FWD_MAPr,(r._mlf_ipmc_fwd_map),2)
#define BCM53128_A0_WRITE_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MLF_IPMC_FWD_MAPr,&(r._mlf_ipmc_fwd_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_IPMC_FWD_MAPr BCM53128_A0_MLF_IPMC_FWD_MAPr
#define MLF_IPMC_FWD_MAPr_SIZE BCM53128_A0_MLF_IPMC_FWD_MAPr_SIZE
typedef BCM53128_A0_MLF_IPMC_FWD_MAPr_t MLF_IPMC_FWD_MAPr_t;
#define MLF_IPMC_FWD_MAPr_CLR BCM53128_A0_MLF_IPMC_FWD_MAPr_CLR
#define MLF_IPMC_FWD_MAPr_SET BCM53128_A0_MLF_IPMC_FWD_MAPr_SET
#define MLF_IPMC_FWD_MAPr_GET BCM53128_A0_MLF_IPMC_FWD_MAPr_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET BCM53128_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET BCM53128_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET
#define MLF_IPMC_FWD_MAPr_RESERVEDf_GET BCM53128_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_GET
#define MLF_IPMC_FWD_MAPr_RESERVEDf_SET BCM53128_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_SET
#define READ_MLF_IPMC_FWD_MAPr BCM53128_A0_READ_MLF_IPMC_FWD_MAPr
#define WRITE_MLF_IPMC_FWD_MAPr BCM53128_A0_WRITE_MLF_IPMC_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MLF_IPMC_FWD_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MODEL_ID
 * BLOCKS:   SYS
 * DESC:     Model ID Register
 * SIZE:     32
 * FIELDS:
 *     MODELID          Chip Model ID
 *
 ******************************************************************************/
#define BCM53128_A0_MODEL_IDr 0x00000230

#define BCM53128_A0_MODEL_IDr_SIZE 4

/*
 * This structure should be used to declare and program MODEL_ID.
 *
 */
typedef union BCM53128_A0_MODEL_IDr_s {
	uint32_t v[1];
	uint32_t model_id[1];
	uint32_t _model_id;
} BCM53128_A0_MODEL_IDr_t;

#define BCM53128_A0_MODEL_IDr_CLR(r) (r).model_id[0] = 0
#define BCM53128_A0_MODEL_IDr_SET(r,d) (r).model_id[0] = d
#define BCM53128_A0_MODEL_IDr_GET(r) (r).model_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MODEL_IDr_MODELIDf_GET(r) ((r).model_id[0])
#define BCM53128_A0_MODEL_IDr_MODELIDf_SET(r,f) (r).model_id[0]=((uint32_t)f)

/*
 * These macros can be used to access MODEL_ID.
 *
 */
#define BCM53128_A0_READ_MODEL_IDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MODEL_IDr,(r._model_id),4)
#define BCM53128_A0_WRITE_MODEL_IDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MODEL_IDr,&(r._model_id),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODEL_IDr BCM53128_A0_MODEL_IDr
#define MODEL_IDr_SIZE BCM53128_A0_MODEL_IDr_SIZE
typedef BCM53128_A0_MODEL_IDr_t MODEL_IDr_t;
#define MODEL_IDr_CLR BCM53128_A0_MODEL_IDr_CLR
#define MODEL_IDr_SET BCM53128_A0_MODEL_IDr_SET
#define MODEL_IDr_GET BCM53128_A0_MODEL_IDr_GET
#define MODEL_IDr_MODELIDf_GET BCM53128_A0_MODEL_IDr_MODELIDf_GET
#define MODEL_IDr_MODELIDf_SET BCM53128_A0_MODEL_IDr_MODELIDf_SET
#define READ_MODEL_IDr BCM53128_A0_READ_MODEL_IDr
#define WRITE_MODEL_IDr BCM53128_A0_WRITE_MODEL_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MODEL_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MODULE_ID0
 * BLOCKS:   SYS
 * DESC:     Module ID 0 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_SA           48 bit SA for module ID.
 *
 ******************************************************************************/
#define BCM53128_A0_MODULE_ID0r 0x00007205

#define BCM53128_A0_MODULE_ID0r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID0.
 *
 */
typedef union BCM53128_A0_MODULE_ID0r_s {
	uint32_t v[2];
	uint32_t module_id0[2];
	uint32_t _module_id0;
} BCM53128_A0_MODULE_ID0r_t;

#define BCM53128_A0_MODULE_ID0r_CLR(r) CDK_MEMSET(&((r)._module_id0), 0, sizeof(BCM53128_A0_MODULE_ID0r_t))
#define BCM53128_A0_MODULE_ID0r_SET(r,i,d) (r).module_id0[i] = d
#define BCM53128_A0_MODULE_ID0r_GET(r,i) (r).module_id0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MODULE_ID0r_MID_SAf_GET(r,a) cdk_field_get((r).module_id0,0,47,a)
#define BCM53128_A0_MODULE_ID0r_MID_SAf_SET(r,a) cdk_field_set((r).module_id0,0,47,a)

/*
 * These macros can be used to access MODULE_ID0.
 *
 */
#define BCM53128_A0_READ_MODULE_ID0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MODULE_ID0r,(r._module_id0),6)
#define BCM53128_A0_WRITE_MODULE_ID0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MODULE_ID0r,&(r._module_id0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID0r BCM53128_A0_MODULE_ID0r
#define MODULE_ID0r_SIZE BCM53128_A0_MODULE_ID0r_SIZE
typedef BCM53128_A0_MODULE_ID0r_t MODULE_ID0r_t;
#define MODULE_ID0r_CLR BCM53128_A0_MODULE_ID0r_CLR
#define MODULE_ID0r_SET BCM53128_A0_MODULE_ID0r_SET
#define MODULE_ID0r_GET BCM53128_A0_MODULE_ID0r_GET
#define MODULE_ID0r_MID_SAf_GET BCM53128_A0_MODULE_ID0r_MID_SAf_GET
#define MODULE_ID0r_MID_SAf_SET BCM53128_A0_MODULE_ID0r_MID_SAf_SET
#define READ_MODULE_ID0r BCM53128_A0_READ_MODULE_ID0r
#define WRITE_MODULE_ID0r BCM53128_A0_WRITE_MODULE_ID0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MODULE_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MODULE_ID1
 * BLOCKS:   SYS
 * DESC:     Module ID 1 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_CRC          32 bits CRC for module ID.
 *     MID_PORTNUM      8 bit portnum for module ID.
 *     RESERVED         Reserved.
 *     MID_AVAIL        module ID available , once 1 st packet received.1 : available.0 : unavailable, wait for 1st packet.
 *
 ******************************************************************************/
#define BCM53128_A0_MODULE_ID1r 0x0000720b

#define BCM53128_A0_MODULE_ID1r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID1.
 *
 */
typedef union BCM53128_A0_MODULE_ID1r_s {
	uint32_t v[2];
	uint32_t module_id1[2];
	uint32_t _module_id1;
} BCM53128_A0_MODULE_ID1r_t;

#define BCM53128_A0_MODULE_ID1r_CLR(r) CDK_MEMSET(&((r)._module_id1), 0, sizeof(BCM53128_A0_MODULE_ID1r_t))
#define BCM53128_A0_MODULE_ID1r_SET(r,i,d) (r).module_id1[i] = d
#define BCM53128_A0_MODULE_ID1r_GET(r,i) (r).module_id1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MODULE_ID1r_MID_CRCf_GET(r) ((r).module_id1[0])
#define BCM53128_A0_MODULE_ID1r_MID_CRCf_SET(r,f) (r).module_id1[0]=((uint32_t)f)
#define BCM53128_A0_MODULE_ID1r_MID_PORTNUMf_GET(r) (((r).module_id1[1]) & 0xff)
#define BCM53128_A0_MODULE_ID1r_MID_PORTNUMf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_MODULE_ID1r_RESERVEDf_GET(r) ((((r).module_id1[1]) >> 8) & 0x7f)
#define BCM53128_A0_MODULE_ID1r_RESERVEDf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM53128_A0_MODULE_ID1r_MID_AVAILf_GET(r) ((((r).module_id1[1]) >> 15) & 0x1)
#define BCM53128_A0_MODULE_ID1r_MID_AVAILf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MODULE_ID1.
 *
 */
#define BCM53128_A0_READ_MODULE_ID1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MODULE_ID1r,(r._module_id1),6)
#define BCM53128_A0_WRITE_MODULE_ID1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MODULE_ID1r,&(r._module_id1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID1r BCM53128_A0_MODULE_ID1r
#define MODULE_ID1r_SIZE BCM53128_A0_MODULE_ID1r_SIZE
typedef BCM53128_A0_MODULE_ID1r_t MODULE_ID1r_t;
#define MODULE_ID1r_CLR BCM53128_A0_MODULE_ID1r_CLR
#define MODULE_ID1r_SET BCM53128_A0_MODULE_ID1r_SET
#define MODULE_ID1r_GET BCM53128_A0_MODULE_ID1r_GET
#define MODULE_ID1r_MID_CRCf_GET BCM53128_A0_MODULE_ID1r_MID_CRCf_GET
#define MODULE_ID1r_MID_CRCf_SET BCM53128_A0_MODULE_ID1r_MID_CRCf_SET
#define MODULE_ID1r_MID_PORTNUMf_GET BCM53128_A0_MODULE_ID1r_MID_PORTNUMf_GET
#define MODULE_ID1r_MID_PORTNUMf_SET BCM53128_A0_MODULE_ID1r_MID_PORTNUMf_SET
#define MODULE_ID1r_RESERVEDf_GET BCM53128_A0_MODULE_ID1r_RESERVEDf_GET
#define MODULE_ID1r_RESERVEDf_SET BCM53128_A0_MODULE_ID1r_RESERVEDf_SET
#define MODULE_ID1r_MID_AVAILf_GET BCM53128_A0_MODULE_ID1r_MID_AVAILf_GET
#define MODULE_ID1r_MID_AVAILf_SET BCM53128_A0_MODULE_ID1r_MID_AVAILf_SET
#define READ_MODULE_ID1r BCM53128_A0_READ_MODULE_ID1r
#define WRITE_MODULE_ID1r BCM53128_A0_WRITE_MODULE_ID1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MODULE_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MPORTVEC0
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 0.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 0 register will be forwarded to each port with a bit set in the Multiport Vector 0 bit map.Bits 0-7: Port 0-7.Bit 8: Port 8 (IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MPORTVEC0r 0x00000418

#define BCM53128_A0_MPORTVEC0r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC0.
 *
 */
typedef union BCM53128_A0_MPORTVEC0r_s {
	uint32_t v[1];
	uint32_t mportvec0[1];
	uint32_t _mportvec0;
} BCM53128_A0_MPORTVEC0r_t;

#define BCM53128_A0_MPORTVEC0r_CLR(r) (r).mportvec0[0] = 0
#define BCM53128_A0_MPORTVEC0r_SET(r,d) (r).mportvec0[0] = d
#define BCM53128_A0_MPORTVEC0r_GET(r) (r).mportvec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MPORTVEC0r_PORT_VCTRf_GET(r) (((r).mportvec0[0]) & 0x1ff)
#define BCM53128_A0_MPORTVEC0r_PORT_VCTRf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MPORTVEC0r_RESERVEDf_GET(r) ((((r).mportvec0[0]) >> 9) & 0x7fffff)
#define BCM53128_A0_MPORTVEC0r_RESERVEDf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC0.
 *
 */
#define BCM53128_A0_READ_MPORTVEC0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MPORTVEC0r,(r._mportvec0),4)
#define BCM53128_A0_WRITE_MPORTVEC0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MPORTVEC0r,&(r._mportvec0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC0r BCM53128_A0_MPORTVEC0r
#define MPORTVEC0r_SIZE BCM53128_A0_MPORTVEC0r_SIZE
typedef BCM53128_A0_MPORTVEC0r_t MPORTVEC0r_t;
#define MPORTVEC0r_CLR BCM53128_A0_MPORTVEC0r_CLR
#define MPORTVEC0r_SET BCM53128_A0_MPORTVEC0r_SET
#define MPORTVEC0r_GET BCM53128_A0_MPORTVEC0r_GET
#define MPORTVEC0r_PORT_VCTRf_GET BCM53128_A0_MPORTVEC0r_PORT_VCTRf_GET
#define MPORTVEC0r_PORT_VCTRf_SET BCM53128_A0_MPORTVEC0r_PORT_VCTRf_SET
#define MPORTVEC0r_RESERVEDf_GET BCM53128_A0_MPORTVEC0r_RESERVEDf_GET
#define MPORTVEC0r_RESERVEDf_SET BCM53128_A0_MPORTVEC0r_RESERVEDf_SET
#define READ_MPORTVEC0r BCM53128_A0_READ_MPORTVEC0r
#define WRITE_MPORTVEC0r BCM53128_A0_WRITE_MPORTVEC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MPORTVEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MPORTVEC1
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 1A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 1 register will be forwarded to each port with a bit set in the Multiport Vector 1 bit map.Bits 0-7: Port 0-7.Bit 8: Port 8(IMP)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MPORTVEC1r 0x00000428

#define BCM53128_A0_MPORTVEC1r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC1.
 *
 */
typedef union BCM53128_A0_MPORTVEC1r_s {
	uint32_t v[1];
	uint32_t mportvec1[1];
	uint32_t _mportvec1;
} BCM53128_A0_MPORTVEC1r_t;

#define BCM53128_A0_MPORTVEC1r_CLR(r) (r).mportvec1[0] = 0
#define BCM53128_A0_MPORTVEC1r_SET(r,d) (r).mportvec1[0] = d
#define BCM53128_A0_MPORTVEC1r_GET(r) (r).mportvec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MPORTVEC1r_PORT_VCTRf_GET(r) (((r).mportvec1[0]) & 0x1ff)
#define BCM53128_A0_MPORTVEC1r_PORT_VCTRf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MPORTVEC1r_RESERVEDf_GET(r) ((((r).mportvec1[0]) >> 9) & 0x7fffff)
#define BCM53128_A0_MPORTVEC1r_RESERVEDf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC1.
 *
 */
#define BCM53128_A0_READ_MPORTVEC1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MPORTVEC1r,(r._mportvec1),4)
#define BCM53128_A0_WRITE_MPORTVEC1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MPORTVEC1r,&(r._mportvec1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC1r BCM53128_A0_MPORTVEC1r
#define MPORTVEC1r_SIZE BCM53128_A0_MPORTVEC1r_SIZE
typedef BCM53128_A0_MPORTVEC1r_t MPORTVEC1r_t;
#define MPORTVEC1r_CLR BCM53128_A0_MPORTVEC1r_CLR
#define MPORTVEC1r_SET BCM53128_A0_MPORTVEC1r_SET
#define MPORTVEC1r_GET BCM53128_A0_MPORTVEC1r_GET
#define MPORTVEC1r_PORT_VCTRf_GET BCM53128_A0_MPORTVEC1r_PORT_VCTRf_GET
#define MPORTVEC1r_PORT_VCTRf_SET BCM53128_A0_MPORTVEC1r_PORT_VCTRf_SET
#define MPORTVEC1r_RESERVEDf_GET BCM53128_A0_MPORTVEC1r_RESERVEDf_GET
#define MPORTVEC1r_RESERVEDf_SET BCM53128_A0_MPORTVEC1r_RESERVEDf_SET
#define READ_MPORTVEC1r BCM53128_A0_READ_MPORTVEC1r
#define WRITE_MPORTVEC1r BCM53128_A0_WRITE_MPORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MPORTVEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MPORTVEC2
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 2.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 2 register will be forwarded to each port with a bit set in the Multiport Vector 2 bit map.Bits 0-7: Port 0-7.Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MPORTVEC2r 0x00000438

#define BCM53128_A0_MPORTVEC2r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC2.
 *
 */
typedef union BCM53128_A0_MPORTVEC2r_s {
	uint32_t v[1];
	uint32_t mportvec2[1];
	uint32_t _mportvec2;
} BCM53128_A0_MPORTVEC2r_t;

#define BCM53128_A0_MPORTVEC2r_CLR(r) (r).mportvec2[0] = 0
#define BCM53128_A0_MPORTVEC2r_SET(r,d) (r).mportvec2[0] = d
#define BCM53128_A0_MPORTVEC2r_GET(r) (r).mportvec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MPORTVEC2r_PORT_VCTRf_GET(r) (((r).mportvec2[0]) & 0x1ff)
#define BCM53128_A0_MPORTVEC2r_PORT_VCTRf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MPORTVEC2r_RESERVEDf_GET(r) ((((r).mportvec2[0]) >> 9) & 0x7fffff)
#define BCM53128_A0_MPORTVEC2r_RESERVEDf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC2.
 *
 */
#define BCM53128_A0_READ_MPORTVEC2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MPORTVEC2r,(r._mportvec2),4)
#define BCM53128_A0_WRITE_MPORTVEC2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MPORTVEC2r,&(r._mportvec2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC2r BCM53128_A0_MPORTVEC2r
#define MPORTVEC2r_SIZE BCM53128_A0_MPORTVEC2r_SIZE
typedef BCM53128_A0_MPORTVEC2r_t MPORTVEC2r_t;
#define MPORTVEC2r_CLR BCM53128_A0_MPORTVEC2r_CLR
#define MPORTVEC2r_SET BCM53128_A0_MPORTVEC2r_SET
#define MPORTVEC2r_GET BCM53128_A0_MPORTVEC2r_GET
#define MPORTVEC2r_PORT_VCTRf_GET BCM53128_A0_MPORTVEC2r_PORT_VCTRf_GET
#define MPORTVEC2r_PORT_VCTRf_SET BCM53128_A0_MPORTVEC2r_PORT_VCTRf_SET
#define MPORTVEC2r_RESERVEDf_GET BCM53128_A0_MPORTVEC2r_RESERVEDf_GET
#define MPORTVEC2r_RESERVEDf_SET BCM53128_A0_MPORTVEC2r_RESERVEDf_SET
#define READ_MPORTVEC2r BCM53128_A0_READ_MPORTVEC2r
#define WRITE_MPORTVEC2r BCM53128_A0_WRITE_MPORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MPORTVEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MPORTVEC3
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 3.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 3 register will be forwarded to each port with a bit set in the Multiport Vector 3 bit map.Bits 0-7: Port 0-7.Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MPORTVEC3r 0x00000448

#define BCM53128_A0_MPORTVEC3r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC3.
 *
 */
typedef union BCM53128_A0_MPORTVEC3r_s {
	uint32_t v[1];
	uint32_t mportvec3[1];
	uint32_t _mportvec3;
} BCM53128_A0_MPORTVEC3r_t;

#define BCM53128_A0_MPORTVEC3r_CLR(r) (r).mportvec3[0] = 0
#define BCM53128_A0_MPORTVEC3r_SET(r,d) (r).mportvec3[0] = d
#define BCM53128_A0_MPORTVEC3r_GET(r) (r).mportvec3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MPORTVEC3r_PORT_VCTRf_GET(r) (((r).mportvec3[0]) & 0x1ff)
#define BCM53128_A0_MPORTVEC3r_PORT_VCTRf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MPORTVEC3r_RESERVEDf_GET(r) ((((r).mportvec3[0]) >> 9) & 0x7fffff)
#define BCM53128_A0_MPORTVEC3r_RESERVEDf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC3.
 *
 */
#define BCM53128_A0_READ_MPORTVEC3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MPORTVEC3r,(r._mportvec3),4)
#define BCM53128_A0_WRITE_MPORTVEC3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MPORTVEC3r,&(r._mportvec3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC3r BCM53128_A0_MPORTVEC3r
#define MPORTVEC3r_SIZE BCM53128_A0_MPORTVEC3r_SIZE
typedef BCM53128_A0_MPORTVEC3r_t MPORTVEC3r_t;
#define MPORTVEC3r_CLR BCM53128_A0_MPORTVEC3r_CLR
#define MPORTVEC3r_SET BCM53128_A0_MPORTVEC3r_SET
#define MPORTVEC3r_GET BCM53128_A0_MPORTVEC3r_GET
#define MPORTVEC3r_PORT_VCTRf_GET BCM53128_A0_MPORTVEC3r_PORT_VCTRf_GET
#define MPORTVEC3r_PORT_VCTRf_SET BCM53128_A0_MPORTVEC3r_PORT_VCTRf_SET
#define MPORTVEC3r_RESERVEDf_GET BCM53128_A0_MPORTVEC3r_RESERVEDf_GET
#define MPORTVEC3r_RESERVEDf_SET BCM53128_A0_MPORTVEC3r_RESERVEDf_SET
#define READ_MPORTVEC3r BCM53128_A0_READ_MPORTVEC3r
#define WRITE_MPORTVEC3r BCM53128_A0_WRITE_MPORTVEC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MPORTVEC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MPORTVEC4
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 4 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 4.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 4 register will be forwarded to each port with a bit set in the Multiport Vector 4 bit map.Bits 0-7: Port 0-7.Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MPORTVEC4r 0x00000458

#define BCM53128_A0_MPORTVEC4r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC4.
 *
 */
typedef union BCM53128_A0_MPORTVEC4r_s {
	uint32_t v[1];
	uint32_t mportvec4[1];
	uint32_t _mportvec4;
} BCM53128_A0_MPORTVEC4r_t;

#define BCM53128_A0_MPORTVEC4r_CLR(r) (r).mportvec4[0] = 0
#define BCM53128_A0_MPORTVEC4r_SET(r,d) (r).mportvec4[0] = d
#define BCM53128_A0_MPORTVEC4r_GET(r) (r).mportvec4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MPORTVEC4r_PORT_VCTRf_GET(r) (((r).mportvec4[0]) & 0x1ff)
#define BCM53128_A0_MPORTVEC4r_PORT_VCTRf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MPORTVEC4r_RESERVEDf_GET(r) ((((r).mportvec4[0]) >> 9) & 0x7fffff)
#define BCM53128_A0_MPORTVEC4r_RESERVEDf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC4.
 *
 */
#define BCM53128_A0_READ_MPORTVEC4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MPORTVEC4r,(r._mportvec4),4)
#define BCM53128_A0_WRITE_MPORTVEC4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MPORTVEC4r,&(r._mportvec4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC4r BCM53128_A0_MPORTVEC4r
#define MPORTVEC4r_SIZE BCM53128_A0_MPORTVEC4r_SIZE
typedef BCM53128_A0_MPORTVEC4r_t MPORTVEC4r_t;
#define MPORTVEC4r_CLR BCM53128_A0_MPORTVEC4r_CLR
#define MPORTVEC4r_SET BCM53128_A0_MPORTVEC4r_SET
#define MPORTVEC4r_GET BCM53128_A0_MPORTVEC4r_GET
#define MPORTVEC4r_PORT_VCTRf_GET BCM53128_A0_MPORTVEC4r_PORT_VCTRf_GET
#define MPORTVEC4r_PORT_VCTRf_SET BCM53128_A0_MPORTVEC4r_PORT_VCTRf_SET
#define MPORTVEC4r_RESERVEDf_GET BCM53128_A0_MPORTVEC4r_RESERVEDf_GET
#define MPORTVEC4r_RESERVEDf_SET BCM53128_A0_MPORTVEC4r_RESERVEDf_SET
#define READ_MPORTVEC4r BCM53128_A0_READ_MPORTVEC4r
#define WRITE_MPORTVEC4r BCM53128_A0_WRITE_MPORTVEC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MPORTVEC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MPORTVEC5
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 5 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 5.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 5 register will be forwarded to each port with a bit set in the Multiport Vector 5 bit map.Bits 0-7: Port 0-7.Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MPORTVEC5r 0x00000468

#define BCM53128_A0_MPORTVEC5r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC5.
 *
 */
typedef union BCM53128_A0_MPORTVEC5r_s {
	uint32_t v[1];
	uint32_t mportvec5[1];
	uint32_t _mportvec5;
} BCM53128_A0_MPORTVEC5r_t;

#define BCM53128_A0_MPORTVEC5r_CLR(r) (r).mportvec5[0] = 0
#define BCM53128_A0_MPORTVEC5r_SET(r,d) (r).mportvec5[0] = d
#define BCM53128_A0_MPORTVEC5r_GET(r) (r).mportvec5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MPORTVEC5r_PORT_VCTRf_GET(r) (((r).mportvec5[0]) & 0x1ff)
#define BCM53128_A0_MPORTVEC5r_PORT_VCTRf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_MPORTVEC5r_RESERVEDf_GET(r) ((((r).mportvec5[0]) >> 9) & 0x7fffff)
#define BCM53128_A0_MPORTVEC5r_RESERVEDf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC5.
 *
 */
#define BCM53128_A0_READ_MPORTVEC5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MPORTVEC5r,(r._mportvec5),4)
#define BCM53128_A0_WRITE_MPORTVEC5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MPORTVEC5r,&(r._mportvec5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC5r BCM53128_A0_MPORTVEC5r
#define MPORTVEC5r_SIZE BCM53128_A0_MPORTVEC5r_SIZE
typedef BCM53128_A0_MPORTVEC5r_t MPORTVEC5r_t;
#define MPORTVEC5r_CLR BCM53128_A0_MPORTVEC5r_CLR
#define MPORTVEC5r_SET BCM53128_A0_MPORTVEC5r_SET
#define MPORTVEC5r_GET BCM53128_A0_MPORTVEC5r_GET
#define MPORTVEC5r_PORT_VCTRf_GET BCM53128_A0_MPORTVEC5r_PORT_VCTRf_GET
#define MPORTVEC5r_PORT_VCTRf_SET BCM53128_A0_MPORTVEC5r_PORT_VCTRf_SET
#define MPORTVEC5r_RESERVEDf_GET BCM53128_A0_MPORTVEC5r_RESERVEDf_GET
#define MPORTVEC5r_RESERVEDf_SET BCM53128_A0_MPORTVEC5r_RESERVEDf_SET
#define READ_MPORTVEC5r BCM53128_A0_READ_MPORTVEC5r
#define WRITE_MPORTVEC5r BCM53128_A0_WRITE_MPORTVEC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MPORTVEC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MST_AGE
 * BLOCKS:   SYS
 * DESC:     MST Ageing Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PRT       Per-spannibg tree aging enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MST_AGEr 0x00004302

#define BCM53128_A0_MST_AGEr_SIZE 4

/*
 * This structure should be used to declare and program MST_AGE.
 *
 */
typedef union BCM53128_A0_MST_AGEr_s {
	uint32_t v[1];
	uint32_t mst_age[1];
	uint32_t _mst_age;
} BCM53128_A0_MST_AGEr_t;

#define BCM53128_A0_MST_AGEr_CLR(r) (r).mst_age[0] = 0
#define BCM53128_A0_MST_AGEr_SET(r,d) (r).mst_age[0] = d
#define BCM53128_A0_MST_AGEr_GET(r) (r).mst_age[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MST_AGEr_AGE_EN_PRTf_GET(r) (((r).mst_age[0]) & 0xff)
#define BCM53128_A0_MST_AGEr_AGE_EN_PRTf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_MST_AGEr_RESERVEDf_GET(r) ((((r).mst_age[0]) >> 8) & 0xffffff)
#define BCM53128_A0_MST_AGEr_RESERVEDf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access MST_AGE.
 *
 */
#define BCM53128_A0_READ_MST_AGEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MST_AGEr,(r._mst_age),4)
#define BCM53128_A0_WRITE_MST_AGEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MST_AGEr,&(r._mst_age),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_AGEr BCM53128_A0_MST_AGEr
#define MST_AGEr_SIZE BCM53128_A0_MST_AGEr_SIZE
typedef BCM53128_A0_MST_AGEr_t MST_AGEr_t;
#define MST_AGEr_CLR BCM53128_A0_MST_AGEr_CLR
#define MST_AGEr_SET BCM53128_A0_MST_AGEr_SET
#define MST_AGEr_GET BCM53128_A0_MST_AGEr_GET
#define MST_AGEr_AGE_EN_PRTf_GET BCM53128_A0_MST_AGEr_AGE_EN_PRTf_GET
#define MST_AGEr_AGE_EN_PRTf_SET BCM53128_A0_MST_AGEr_AGE_EN_PRTf_SET
#define MST_AGEr_RESERVEDf_GET BCM53128_A0_MST_AGEr_RESERVEDf_GET
#define MST_AGEr_RESERVEDf_SET BCM53128_A0_MST_AGEr_RESERVEDf_SET
#define READ_MST_AGEr BCM53128_A0_READ_MST_AGEr
#define WRITE_MST_AGEr BCM53128_A0_WRITE_MST_AGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MST_AGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MST Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        1: Enable 802.1s0: Only one spanning tree support
 *     EN_INVALID_VTBL_CHK To Enable the invalid VLAN Table checking in the MSTP filtering process0: Disable the invalid VLAN table checking.1: Enable the invalid VLAN table checking.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MST_CONr 0x00004300

#define BCM53128_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 *
 */
typedef union BCM53128_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM53128_A0_MST_CONr_t;

#define BCM53128_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM53128_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM53128_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM53128_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_MST_CONr_EN_INVALID_VTBL_CHKf_GET(r) ((((r).mst_con[0]) >> 1) & 0x1)
#define BCM53128_A0_MST_CONr_EN_INVALID_VTBL_CHKf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_MST_CONr_RESERVEDf_GET(r) ((((r).mst_con[0]) >> 2) & 0x3f)
#define BCM53128_A0_MST_CONr_RESERVEDf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access MST_CON.
 *
 */
#define BCM53128_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MST_CONr,(r._mst_con),1)
#define BCM53128_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM53128_A0_MST_CONr
#define MST_CONr_SIZE BCM53128_A0_MST_CONr_SIZE
typedef BCM53128_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM53128_A0_MST_CONr_CLR
#define MST_CONr_SET BCM53128_A0_MST_CONr_SET
#define MST_CONr_GET BCM53128_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM53128_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM53128_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_EN_INVALID_VTBL_CHKf_GET BCM53128_A0_MST_CONr_EN_INVALID_VTBL_CHKf_GET
#define MST_CONr_EN_INVALID_VTBL_CHKf_SET BCM53128_A0_MST_CONr_EN_INVALID_VTBL_CHKf_SET
#define MST_CONr_RESERVEDf_GET BCM53128_A0_MST_CONr_RESERVEDf_GET
#define MST_CONr_RESERVEDf_SET BCM53128_A0_MST_CONr_RESERVEDf_SET
#define READ_MST_CONr BCM53128_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM53128_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MST_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MST_TAB
 * BLOCKS:   SYS
 * DESC:     MST Table N Enable Registers
 * SIZE:     32
 * FIELDS:
 *     SPT_STA0         Spanning tree state for port 0.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA1         Spanning tree state for port 1.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA2         Spanning tree state for port 2.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA3         Spanning tree state for port 3.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA4         Spanning tree state for port 4.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA5         Spanning tree state for port 5.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA6         Spanning tree state for port 6.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA7         Spanning tree state for port 7.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     RESERVED         
 *     MST_TAB_RSRV     Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_MST_TABr 0x00004310

#define BCM53128_A0_MST_TABr_SIZE 4

/*
 * This structure should be used to declare and program MST_TAB.
 *
 */
typedef union BCM53128_A0_MST_TABr_s {
	uint32_t v[1];
	uint32_t mst_tab[1];
	uint32_t _mst_tab;
} BCM53128_A0_MST_TABr_t;

#define BCM53128_A0_MST_TABr_CLR(r) (r).mst_tab[0] = 0
#define BCM53128_A0_MST_TABr_SET(r,d) (r).mst_tab[0] = d
#define BCM53128_A0_MST_TABr_GET(r) (r).mst_tab[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MST_TABr_SPT_STA0f_GET(r) (((r).mst_tab[0]) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA0f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_MST_TABr_SPT_STA1f_GET(r) ((((r).mst_tab[0]) >> 3) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA1f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_MST_TABr_SPT_STA2f_GET(r) ((((r).mst_tab[0]) >> 6) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA2f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_MST_TABr_SPT_STA3f_GET(r) ((((r).mst_tab[0]) >> 9) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA3f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_MST_TABr_SPT_STA4f_GET(r) ((((r).mst_tab[0]) >> 12) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA4f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_MST_TABr_SPT_STA5f_GET(r) ((((r).mst_tab[0]) >> 15) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA5f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_MST_TABr_SPT_STA6f_GET(r) ((((r).mst_tab[0]) >> 18) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA6f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_MST_TABr_SPT_STA7f_GET(r) ((((r).mst_tab[0]) >> 21) & 0x7)
#define BCM53128_A0_MST_TABr_SPT_STA7f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_MST_TABr_RESERVEDf_GET(r) ((((r).mst_tab[0]) >> 24) & 0x7)
#define BCM53128_A0_MST_TABr_RESERVEDf_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53128_A0_MST_TABr_MST_TAB_RSRVf_GET(r) ((((r).mst_tab[0]) >> 27) & 0x1f)
#define BCM53128_A0_MST_TABr_MST_TAB_RSRVf_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access MST_TAB.
 *
 */
#define BCM53128_A0_READ_MST_TABr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_MST_TABr+(4*(i)),(r._mst_tab),4)
#define BCM53128_A0_WRITE_MST_TABr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_MST_TABr+(4*(i)),&(r._mst_tab),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_TABr BCM53128_A0_MST_TABr
#define MST_TABr_SIZE BCM53128_A0_MST_TABr_SIZE
typedef BCM53128_A0_MST_TABr_t MST_TABr_t;
#define MST_TABr_CLR BCM53128_A0_MST_TABr_CLR
#define MST_TABr_SET BCM53128_A0_MST_TABr_SET
#define MST_TABr_GET BCM53128_A0_MST_TABr_GET
#define MST_TABr_SPT_STA0f_GET BCM53128_A0_MST_TABr_SPT_STA0f_GET
#define MST_TABr_SPT_STA0f_SET BCM53128_A0_MST_TABr_SPT_STA0f_SET
#define MST_TABr_SPT_STA1f_GET BCM53128_A0_MST_TABr_SPT_STA1f_GET
#define MST_TABr_SPT_STA1f_SET BCM53128_A0_MST_TABr_SPT_STA1f_SET
#define MST_TABr_SPT_STA2f_GET BCM53128_A0_MST_TABr_SPT_STA2f_GET
#define MST_TABr_SPT_STA2f_SET BCM53128_A0_MST_TABr_SPT_STA2f_SET
#define MST_TABr_SPT_STA3f_GET BCM53128_A0_MST_TABr_SPT_STA3f_GET
#define MST_TABr_SPT_STA3f_SET BCM53128_A0_MST_TABr_SPT_STA3f_SET
#define MST_TABr_SPT_STA4f_GET BCM53128_A0_MST_TABr_SPT_STA4f_GET
#define MST_TABr_SPT_STA4f_SET BCM53128_A0_MST_TABr_SPT_STA4f_SET
#define MST_TABr_SPT_STA5f_GET BCM53128_A0_MST_TABr_SPT_STA5f_GET
#define MST_TABr_SPT_STA5f_SET BCM53128_A0_MST_TABr_SPT_STA5f_SET
#define MST_TABr_SPT_STA6f_GET BCM53128_A0_MST_TABr_SPT_STA6f_GET
#define MST_TABr_SPT_STA6f_SET BCM53128_A0_MST_TABr_SPT_STA6f_SET
#define MST_TABr_SPT_STA7f_GET BCM53128_A0_MST_TABr_SPT_STA7f_GET
#define MST_TABr_SPT_STA7f_SET BCM53128_A0_MST_TABr_SPT_STA7f_SET
#define MST_TABr_RESERVEDf_GET BCM53128_A0_MST_TABr_RESERVEDf_GET
#define MST_TABr_RESERVEDf_SET BCM53128_A0_MST_TABr_RESERVEDf_SET
#define MST_TABr_MST_TAB_RSRVf_GET BCM53128_A0_MST_TABr_MST_TAB_RSRVf_GET
#define MST_TABr_MST_TAB_RSRVf_SET BCM53128_A0_MST_TABr_MST_TAB_RSRVf_SET
#define READ_MST_TABr BCM53128_A0_READ_MST_TABr
#define WRITE_MST_TABr BCM53128_A0_WRITE_MST_TABr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MST_TABr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTIPORT_ADDR0
 * BLOCKS:   SYS
 * DESC:     Multiport Address 0 Register (Default for TS)
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 0.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 0Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53128_A0_MULTIPORT_ADDR0r 0x00000410

#define BCM53128_A0_MULTIPORT_ADDR0r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR0.
 *
 */
typedef union BCM53128_A0_MULTIPORT_ADDR0r_s {
	uint32_t v[2];
	uint32_t multiport_addr0[2];
	uint32_t _multiport_addr0;
} BCM53128_A0_MULTIPORT_ADDR0r_t;

#define BCM53128_A0_MULTIPORT_ADDR0r_CLR(r) CDK_MEMSET(&((r)._multiport_addr0), 0, sizeof(BCM53128_A0_MULTIPORT_ADDR0r_t))
#define BCM53128_A0_MULTIPORT_ADDR0r_SET(r,i,d) (r).multiport_addr0[i] = d
#define BCM53128_A0_MULTIPORT_ADDR0r_GET(r,i) (r).multiport_addr0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr0,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr0,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr0[1]) >> 16) & 0xffff)
#define BCM53128_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr0[1]=(((r).multiport_addr0[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR0.
 *
 */
#define BCM53128_A0_READ_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTIPORT_ADDR0r,(r._multiport_addr0),8)
#define BCM53128_A0_WRITE_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTIPORT_ADDR0r,&(r._multiport_addr0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR0r BCM53128_A0_MULTIPORT_ADDR0r
#define MULTIPORT_ADDR0r_SIZE BCM53128_A0_MULTIPORT_ADDR0r_SIZE
typedef BCM53128_A0_MULTIPORT_ADDR0r_t MULTIPORT_ADDR0r_t;
#define MULTIPORT_ADDR0r_CLR BCM53128_A0_MULTIPORT_ADDR0r_CLR
#define MULTIPORT_ADDR0r_SET BCM53128_A0_MULTIPORT_ADDR0r_SET
#define MULTIPORT_ADDR0r_GET BCM53128_A0_MULTIPORT_ADDR0r_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_GET BCM53128_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_SET BCM53128_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET BCM53128_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET BCM53128_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR0r BCM53128_A0_READ_MULTIPORT_ADDR0r
#define WRITE_MULTIPORT_ADDR0r BCM53128_A0_WRITE_MULTIPORT_ADDR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTIPORT_ADDR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTIPORT_ADDR1
 * BLOCKS:   SYS
 * DESC:     Multiport Address 1 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 1.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 1Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53128_A0_MULTIPORT_ADDR1r 0x00000420

#define BCM53128_A0_MULTIPORT_ADDR1r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR1.
 *
 */
typedef union BCM53128_A0_MULTIPORT_ADDR1r_s {
	uint32_t v[2];
	uint32_t multiport_addr1[2];
	uint32_t _multiport_addr1;
} BCM53128_A0_MULTIPORT_ADDR1r_t;

#define BCM53128_A0_MULTIPORT_ADDR1r_CLR(r) CDK_MEMSET(&((r)._multiport_addr1), 0, sizeof(BCM53128_A0_MULTIPORT_ADDR1r_t))
#define BCM53128_A0_MULTIPORT_ADDR1r_SET(r,i,d) (r).multiport_addr1[i] = d
#define BCM53128_A0_MULTIPORT_ADDR1r_GET(r,i) (r).multiport_addr1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr1,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr1,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr1[1]) >> 16) & 0xffff)
#define BCM53128_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr1[1]=(((r).multiport_addr1[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR1.
 *
 */
#define BCM53128_A0_READ_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTIPORT_ADDR1r,(r._multiport_addr1),8)
#define BCM53128_A0_WRITE_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTIPORT_ADDR1r,&(r._multiport_addr1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR1r BCM53128_A0_MULTIPORT_ADDR1r
#define MULTIPORT_ADDR1r_SIZE BCM53128_A0_MULTIPORT_ADDR1r_SIZE
typedef BCM53128_A0_MULTIPORT_ADDR1r_t MULTIPORT_ADDR1r_t;
#define MULTIPORT_ADDR1r_CLR BCM53128_A0_MULTIPORT_ADDR1r_CLR
#define MULTIPORT_ADDR1r_SET BCM53128_A0_MULTIPORT_ADDR1r_SET
#define MULTIPORT_ADDR1r_GET BCM53128_A0_MULTIPORT_ADDR1r_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_GET BCM53128_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_SET BCM53128_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET BCM53128_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET BCM53128_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR1r BCM53128_A0_READ_MULTIPORT_ADDR1r
#define WRITE_MULTIPORT_ADDR1r BCM53128_A0_WRITE_MULTIPORT_ADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTIPORT_ADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTIPORT_ADDR2
 * BLOCKS:   SYS
 * DESC:     Multiport Address 2 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 2.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 2Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53128_A0_MULTIPORT_ADDR2r 0x00000430

#define BCM53128_A0_MULTIPORT_ADDR2r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR2.
 *
 */
typedef union BCM53128_A0_MULTIPORT_ADDR2r_s {
	uint32_t v[2];
	uint32_t multiport_addr2[2];
	uint32_t _multiport_addr2;
} BCM53128_A0_MULTIPORT_ADDR2r_t;

#define BCM53128_A0_MULTIPORT_ADDR2r_CLR(r) CDK_MEMSET(&((r)._multiport_addr2), 0, sizeof(BCM53128_A0_MULTIPORT_ADDR2r_t))
#define BCM53128_A0_MULTIPORT_ADDR2r_SET(r,i,d) (r).multiport_addr2[i] = d
#define BCM53128_A0_MULTIPORT_ADDR2r_GET(r,i) (r).multiport_addr2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr2,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr2,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr2[1]) >> 16) & 0xffff)
#define BCM53128_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr2[1]=(((r).multiport_addr2[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR2.
 *
 */
#define BCM53128_A0_READ_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTIPORT_ADDR2r,(r._multiport_addr2),8)
#define BCM53128_A0_WRITE_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTIPORT_ADDR2r,&(r._multiport_addr2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR2r BCM53128_A0_MULTIPORT_ADDR2r
#define MULTIPORT_ADDR2r_SIZE BCM53128_A0_MULTIPORT_ADDR2r_SIZE
typedef BCM53128_A0_MULTIPORT_ADDR2r_t MULTIPORT_ADDR2r_t;
#define MULTIPORT_ADDR2r_CLR BCM53128_A0_MULTIPORT_ADDR2r_CLR
#define MULTIPORT_ADDR2r_SET BCM53128_A0_MULTIPORT_ADDR2r_SET
#define MULTIPORT_ADDR2r_GET BCM53128_A0_MULTIPORT_ADDR2r_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_GET BCM53128_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_SET BCM53128_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET BCM53128_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET BCM53128_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR2r BCM53128_A0_READ_MULTIPORT_ADDR2r
#define WRITE_MULTIPORT_ADDR2r BCM53128_A0_WRITE_MULTIPORT_ADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTIPORT_ADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTIPORT_ADDR3
 * BLOCKS:   SYS
 * DESC:     Multiport Address 3 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 3.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 3Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53128_A0_MULTIPORT_ADDR3r 0x00000440

#define BCM53128_A0_MULTIPORT_ADDR3r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR3.
 *
 */
typedef union BCM53128_A0_MULTIPORT_ADDR3r_s {
	uint32_t v[2];
	uint32_t multiport_addr3[2];
	uint32_t _multiport_addr3;
} BCM53128_A0_MULTIPORT_ADDR3r_t;

#define BCM53128_A0_MULTIPORT_ADDR3r_CLR(r) CDK_MEMSET(&((r)._multiport_addr3), 0, sizeof(BCM53128_A0_MULTIPORT_ADDR3r_t))
#define BCM53128_A0_MULTIPORT_ADDR3r_SET(r,i,d) (r).multiport_addr3[i] = d
#define BCM53128_A0_MULTIPORT_ADDR3r_GET(r,i) (r).multiport_addr3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr3,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr3,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr3[1]) >> 16) & 0xffff)
#define BCM53128_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr3[1]=(((r).multiport_addr3[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR3.
 *
 */
#define BCM53128_A0_READ_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTIPORT_ADDR3r,(r._multiport_addr3),8)
#define BCM53128_A0_WRITE_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTIPORT_ADDR3r,&(r._multiport_addr3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR3r BCM53128_A0_MULTIPORT_ADDR3r
#define MULTIPORT_ADDR3r_SIZE BCM53128_A0_MULTIPORT_ADDR3r_SIZE
typedef BCM53128_A0_MULTIPORT_ADDR3r_t MULTIPORT_ADDR3r_t;
#define MULTIPORT_ADDR3r_CLR BCM53128_A0_MULTIPORT_ADDR3r_CLR
#define MULTIPORT_ADDR3r_SET BCM53128_A0_MULTIPORT_ADDR3r_SET
#define MULTIPORT_ADDR3r_GET BCM53128_A0_MULTIPORT_ADDR3r_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_GET BCM53128_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_SET BCM53128_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET BCM53128_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET BCM53128_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR3r BCM53128_A0_READ_MULTIPORT_ADDR3r
#define WRITE_MULTIPORT_ADDR3r BCM53128_A0_WRITE_MULTIPORT_ADDR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTIPORT_ADDR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTIPORT_ADDR4
 * BLOCKS:   SYS
 * DESC:     Multiport Address 4 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 4.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 4Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53128_A0_MULTIPORT_ADDR4r 0x00000450

#define BCM53128_A0_MULTIPORT_ADDR4r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR4.
 *
 */
typedef union BCM53128_A0_MULTIPORT_ADDR4r_s {
	uint32_t v[2];
	uint32_t multiport_addr4[2];
	uint32_t _multiport_addr4;
} BCM53128_A0_MULTIPORT_ADDR4r_t;

#define BCM53128_A0_MULTIPORT_ADDR4r_CLR(r) CDK_MEMSET(&((r)._multiport_addr4), 0, sizeof(BCM53128_A0_MULTIPORT_ADDR4r_t))
#define BCM53128_A0_MULTIPORT_ADDR4r_SET(r,i,d) (r).multiport_addr4[i] = d
#define BCM53128_A0_MULTIPORT_ADDR4r_GET(r,i) (r).multiport_addr4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr4,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr4,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr4[1]) >> 16) & 0xffff)
#define BCM53128_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr4[1]=(((r).multiport_addr4[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR4.
 *
 */
#define BCM53128_A0_READ_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTIPORT_ADDR4r,(r._multiport_addr4),8)
#define BCM53128_A0_WRITE_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTIPORT_ADDR4r,&(r._multiport_addr4),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR4r BCM53128_A0_MULTIPORT_ADDR4r
#define MULTIPORT_ADDR4r_SIZE BCM53128_A0_MULTIPORT_ADDR4r_SIZE
typedef BCM53128_A0_MULTIPORT_ADDR4r_t MULTIPORT_ADDR4r_t;
#define MULTIPORT_ADDR4r_CLR BCM53128_A0_MULTIPORT_ADDR4r_CLR
#define MULTIPORT_ADDR4r_SET BCM53128_A0_MULTIPORT_ADDR4r_SET
#define MULTIPORT_ADDR4r_GET BCM53128_A0_MULTIPORT_ADDR4r_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_GET BCM53128_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_SET BCM53128_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET BCM53128_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET BCM53128_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR4r BCM53128_A0_READ_MULTIPORT_ADDR4r
#define WRITE_MULTIPORT_ADDR4r BCM53128_A0_WRITE_MULTIPORT_ADDR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTIPORT_ADDR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTIPORT_ADDR5
 * BLOCKS:   SYS
 * DESC:     Multiport Address 5 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 5.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 5Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53128_A0_MULTIPORT_ADDR5r 0x00000460

#define BCM53128_A0_MULTIPORT_ADDR5r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR5.
 *
 */
typedef union BCM53128_A0_MULTIPORT_ADDR5r_s {
	uint32_t v[2];
	uint32_t multiport_addr5[2];
	uint32_t _multiport_addr5;
} BCM53128_A0_MULTIPORT_ADDR5r_t;

#define BCM53128_A0_MULTIPORT_ADDR5r_CLR(r) CDK_MEMSET(&((r)._multiport_addr5), 0, sizeof(BCM53128_A0_MULTIPORT_ADDR5r_t))
#define BCM53128_A0_MULTIPORT_ADDR5r_SET(r,i,d) (r).multiport_addr5[i] = d
#define BCM53128_A0_MULTIPORT_ADDR5r_GET(r,i) (r).multiport_addr5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr5,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr5,0,47,a)
#define BCM53128_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr5[1]) >> 16) & 0xffff)
#define BCM53128_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr5[1]=(((r).multiport_addr5[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR5.
 *
 */
#define BCM53128_A0_READ_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTIPORT_ADDR5r,(r._multiport_addr5),8)
#define BCM53128_A0_WRITE_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTIPORT_ADDR5r,&(r._multiport_addr5),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR5r BCM53128_A0_MULTIPORT_ADDR5r
#define MULTIPORT_ADDR5r_SIZE BCM53128_A0_MULTIPORT_ADDR5r_SIZE
typedef BCM53128_A0_MULTIPORT_ADDR5r_t MULTIPORT_ADDR5r_t;
#define MULTIPORT_ADDR5r_CLR BCM53128_A0_MULTIPORT_ADDR5r_CLR
#define MULTIPORT_ADDR5r_SET BCM53128_A0_MULTIPORT_ADDR5r_SET
#define MULTIPORT_ADDR5r_GET BCM53128_A0_MULTIPORT_ADDR5r_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_GET BCM53128_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_SET BCM53128_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET BCM53128_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET BCM53128_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR5r BCM53128_A0_READ_MULTIPORT_ADDR5r
#define WRITE_MULTIPORT_ADDR5r BCM53128_A0_WRITE_MULTIPORT_ADDR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTIPORT_ADDR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  MULTI_PORT_CTL
 * BLOCKS:   SYS
 * DESC:     Multiport Control Register
 * SIZE:     16
 * FIELDS:
 *     MPORT_CTRL0      Multiport 0 Control .1'b00: Disable Multiport 0 Forward1'b10: Compare MPORT_ADD0 only, Forward based on MPORT_Vector 0 if matched1'b01: Compare MPORT_EYPE0 only, Forward based on MPORT_Vector 0 if matched1'b11: Compare MPORT_EYPE0 and MPORT_ADD0, Forward based on MPORT_Vector 0 if matched
 *     MPORT_CTRL1      Multiport 1 Control .1'b00: Disable Multiport 1 Forward1'b10: Compare MPORT_ADD1 only, Forward based on MPORT_Vector 1 if matched1'b01: Compare MPORT_EYPE1 only, Forward based on MPORT_Vector 1 if matched1'b11: Compare MPORT_EYPE1 and MPORT_ADD1, Forward based on MPORT_Vector 1 if matched
 *     MPORT_CTRL2      Multiport 2 Control .1'b00: Disable Multiport 2 Forward1'b10: Compare MPORT_ADD2 only, Forward based on MPORT_Vector 2 if matched1'b01: Compare MPORT_EYPE2 only, Forward based on MPORT_Vector 2 if matched1'b11: Compare MPORT_EYPE2 and MPORT_ADD2, Forward based on MPORT_Vector 2 if matched
 *     MPORT_CTRL3      Multiport 3 Control .1'b00: Disable Multiport 3 Forward1'b10: Compare MPORT_ADD3 only, Forward based on MPORT_Vector 3 if matched1'b01: Compare MPORT_EYPE3 only, Forward based on MPORT_Vector 3 if matched1'b11: Compare MPORT_EYPE3 and MPORT_ADD3, Forward based on MPORT_Vector 3 if matched
 *     MPORT_CTRL4      Multiport 4 Control .1'b00: Disable Multiport 4 Forward1'b10: Compare MPORT_ADD4 only, Forward based on MPORT_Vector 4 if matched1'b01: Compare MPORT_EYPE4 only, Forward based on MPORT_Vector 4 if matched1'b11: Compare MPORT_EYPE4 and MPORT_ADD4, Forward based on MPORT_Vector 4 if matched
 *     MPORT_CTRL5      Multiport 5 Control .1'b00: Disable Multiport 5 Forward1'b10: Compare MPORT_ADD5 only, Forward based on MPORT_Vector 5 if matched1'b01: Compare MPORT_EYPE5 only, Forward based on MPORT_Vector 5 if matched1'b11: Compare MPORT_EYPE5 and MPORT_ADD5, Forward based on MPORT_Vector 5 if matched
 *     RESERVED         Reserved
 *     MPORT0_TS_EN     Mport 0 Time Sync Enable1: Packet will be time stamped if forwarded to CPU.  MPORT_VECTOR0 should be programed to CPU only if the bit is set0: Packet will not be time-stamped
 *
 ******************************************************************************/
#define BCM53128_A0_MULTI_PORT_CTLr 0x0000040e

#define BCM53128_A0_MULTI_PORT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program MULTI_PORT_CTL.
 *
 */
typedef union BCM53128_A0_MULTI_PORT_CTLr_s {
	uint32_t v[1];
	uint32_t multi_port_ctl[1];
	uint32_t _multi_port_ctl;
} BCM53128_A0_MULTI_PORT_CTLr_t;

#define BCM53128_A0_MULTI_PORT_CTLr_CLR(r) (r).multi_port_ctl[0] = 0
#define BCM53128_A0_MULTI_PORT_CTLr_SET(r,d) (r).multi_port_ctl[0] = d
#define BCM53128_A0_MULTI_PORT_CTLr_GET(r) (r).multi_port_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET(r) (((r).multi_port_ctl[0]) & 0x3)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET(r) ((((r).multi_port_ctl[0]) >> 2) & 0x3)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET(r) ((((r).multi_port_ctl[0]) >> 4) & 0x3)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET(r) ((((r).multi_port_ctl[0]) >> 6) & 0x3)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET(r) ((((r).multi_port_ctl[0]) >> 8) & 0x3)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET(r) ((((r).multi_port_ctl[0]) >> 10) & 0x3)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53128_A0_MULTI_PORT_CTLr_RESERVEDf_GET(r) ((((r).multi_port_ctl[0]) >> 12) & 0x7)
#define BCM53128_A0_MULTI_PORT_CTLr_RESERVEDf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET(r) ((((r).multi_port_ctl[0]) >> 15) & 0x1)
#define BCM53128_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MULTI_PORT_CTL.
 *
 */
#define BCM53128_A0_READ_MULTI_PORT_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_MULTI_PORT_CTLr,(r._multi_port_ctl),2)
#define BCM53128_A0_WRITE_MULTI_PORT_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_MULTI_PORT_CTLr,&(r._multi_port_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTI_PORT_CTLr BCM53128_A0_MULTI_PORT_CTLr
#define MULTI_PORT_CTLr_SIZE BCM53128_A0_MULTI_PORT_CTLr_SIZE
typedef BCM53128_A0_MULTI_PORT_CTLr_t MULTI_PORT_CTLr_t;
#define MULTI_PORT_CTLr_CLR BCM53128_A0_MULTI_PORT_CTLr_CLR
#define MULTI_PORT_CTLr_SET BCM53128_A0_MULTI_PORT_CTLr_SET
#define MULTI_PORT_CTLr_GET BCM53128_A0_MULTI_PORT_CTLr_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET
#define MULTI_PORT_CTLr_RESERVEDf_GET BCM53128_A0_MULTI_PORT_CTLr_RESERVEDf_GET
#define MULTI_PORT_CTLr_RESERVEDf_SET BCM53128_A0_MULTI_PORT_CTLr_RESERVEDf_SET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_GET BCM53128_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_SET BCM53128_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET
#define READ_MULTI_PORT_CTLr BCM53128_A0_READ_MULTI_PORT_CTLr
#define WRITE_MULTI_PORT_CTLr BCM53128_A0_WRITE_MULTI_PORT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_MULTI_PORT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  NEW_CTRL
 * BLOCKS:   SYS
 * DESC:     New Control Register
 * SIZE:     8
 * FIELDS:
 *     IP_MC            When set to a '1' it will support the new 4K IP multicast address scheme. It is illegal to set to zero.(Not2Release)
 *     OUTRANGEERR_DISCARD Out of Range Error DiscardWhen enabled, the ingress port will discard the frames with length field between 1500 and 1536 (exclude 1500 and 1536) and with good CRC. This option only controls the length field checking but not the frame length checking.
 *     INRANGEERR_DISCARD In Range Error DiscardWhen enabled, the ingress port will discard the frames with Length field mismatch the frame length. Following is the definition of InRangeErros. InRangeErrors Frames: The frames received with good CRC and one of the following. The value of Length/Type field is between 46 and 1500 inclusive, and does not match the number of(MAC Client Data + PAD)data octets received, OR The value of Length/Type field is less than 46, and the number of data octets received is greater than 46(which does not require padding).
 *     RESERVED         Reserved
 *     UC_FWD_EN        Unicast Forward Enable when ARL Miss.1: To enable DFL packet with unicast destination address to foward to ports defined as page 0,offset 34h.
 *     MC_FWD_EN        Multicast Foward Enable when ARL Miss.1: To enable DFL packet with multicast destination address to foward to the ports defined as page 0,offset 34h.
 *
 ******************************************************************************/
#define BCM53128_A0_NEW_CTRLr 0x00000021

#define BCM53128_A0_NEW_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CTRL.
 *
 */
typedef union BCM53128_A0_NEW_CTRLr_s {
	uint32_t v[1];
	uint32_t new_ctrl[1];
	uint32_t _new_ctrl;
} BCM53128_A0_NEW_CTRLr_t;

#define BCM53128_A0_NEW_CTRLr_CLR(r) (r).new_ctrl[0] = 0
#define BCM53128_A0_NEW_CTRLr_SET(r,d) (r).new_ctrl[0] = d
#define BCM53128_A0_NEW_CTRLr_GET(r) (r).new_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_NEW_CTRLr_IP_MCf_GET(r) (((r).new_ctrl[0]) & 0x1)
#define BCM53128_A0_NEW_CTRLr_IP_MCf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_NEW_CTRLr_RESERVEDf_GET(r) ((((r).new_ctrl[0]) >> 3) & 0x7)
#define BCM53128_A0_NEW_CTRLr_RESERVEDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_NEW_CTRLr_UC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_NEW_CTRLr_UC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_NEW_CTRLr_MC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_NEW_CTRLr_MC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access NEW_CTRL.
 *
 */
#define BCM53128_A0_READ_NEW_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_NEW_CTRLr,(r._new_ctrl),1)
#define BCM53128_A0_WRITE_NEW_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_NEW_CTRLr,&(r._new_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CTRLr BCM53128_A0_NEW_CTRLr
#define NEW_CTRLr_SIZE BCM53128_A0_NEW_CTRLr_SIZE
typedef BCM53128_A0_NEW_CTRLr_t NEW_CTRLr_t;
#define NEW_CTRLr_CLR BCM53128_A0_NEW_CTRLr_CLR
#define NEW_CTRLr_SET BCM53128_A0_NEW_CTRLr_SET
#define NEW_CTRLr_GET BCM53128_A0_NEW_CTRLr_GET
#define NEW_CTRLr_IP_MCf_GET BCM53128_A0_NEW_CTRLr_IP_MCf_GET
#define NEW_CTRLr_IP_MCf_SET BCM53128_A0_NEW_CTRLr_IP_MCf_SET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_GET BCM53128_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_SET BCM53128_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET
#define NEW_CTRLr_INRANGEERR_DISCARDf_GET BCM53128_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET
#define NEW_CTRLr_INRANGEERR_DISCARDf_SET BCM53128_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET
#define NEW_CTRLr_RESERVEDf_GET BCM53128_A0_NEW_CTRLr_RESERVEDf_GET
#define NEW_CTRLr_RESERVEDf_SET BCM53128_A0_NEW_CTRLr_RESERVEDf_SET
#define NEW_CTRLr_UC_FWD_ENf_GET BCM53128_A0_NEW_CTRLr_UC_FWD_ENf_GET
#define NEW_CTRLr_UC_FWD_ENf_SET BCM53128_A0_NEW_CTRLr_UC_FWD_ENf_SET
#define NEW_CTRLr_MC_FWD_ENf_GET BCM53128_A0_NEW_CTRLr_MC_FWD_ENf_GET
#define NEW_CTRLr_MC_FWD_ENf_SET BCM53128_A0_NEW_CTRLr_MC_FWD_ENf_SET
#define READ_NEW_CTRLr BCM53128_A0_READ_NEW_CTRLr
#define WRITE_NEW_CTRLr BCM53128_A0_WRITE_NEW_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_NEW_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OTP_ADDR_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Address Registers
 * SIZE:     16
 * FIELDS:
 *     CPU_ADDR         The 16 bits CPU OTP address register provides up to 64k bit address space for OTP program,read access from CPU interface.In prog_word command, it determines the address of the entire memory row to be programmed or the data to be read
 *
 ******************************************************************************/
#define BCM53128_A0_OTP_ADDR_REGr 0x0000e004

#define BCM53128_A0_OTP_ADDR_REGr_SIZE 2

/*
 * This structure should be used to declare and program OTP_ADDR_REG.
 *
 */
typedef union BCM53128_A0_OTP_ADDR_REGr_s {
	uint32_t v[1];
	uint32_t otp_addr_reg[1];
	uint32_t _otp_addr_reg;
} BCM53128_A0_OTP_ADDR_REGr_t;

#define BCM53128_A0_OTP_ADDR_REGr_CLR(r) (r).otp_addr_reg[0] = 0
#define BCM53128_A0_OTP_ADDR_REGr_SET(r,d) (r).otp_addr_reg[0] = d
#define BCM53128_A0_OTP_ADDR_REGr_GET(r) (r).otp_addr_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_OTP_ADDR_REGr_CPU_ADDRf_GET(r) (((r).otp_addr_reg[0]) & 0xffff)
#define BCM53128_A0_OTP_ADDR_REGr_CPU_ADDRf_SET(r,f) (r).otp_addr_reg[0]=(((r).otp_addr_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access OTP_ADDR_REG.
 *
 */
#define BCM53128_A0_READ_OTP_ADDR_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_OTP_ADDR_REGr,(r._otp_addr_reg),2)
#define BCM53128_A0_WRITE_OTP_ADDR_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_OTP_ADDR_REGr,&(r._otp_addr_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_ADDR_REGr BCM53128_A0_OTP_ADDR_REGr
#define OTP_ADDR_REGr_SIZE BCM53128_A0_OTP_ADDR_REGr_SIZE
typedef BCM53128_A0_OTP_ADDR_REGr_t OTP_ADDR_REGr_t;
#define OTP_ADDR_REGr_CLR BCM53128_A0_OTP_ADDR_REGr_CLR
#define OTP_ADDR_REGr_SET BCM53128_A0_OTP_ADDR_REGr_SET
#define OTP_ADDR_REGr_GET BCM53128_A0_OTP_ADDR_REGr_GET
#define OTP_ADDR_REGr_CPU_ADDRf_GET BCM53128_A0_OTP_ADDR_REGr_CPU_ADDRf_GET
#define OTP_ADDR_REGr_CPU_ADDRf_SET BCM53128_A0_OTP_ADDR_REGr_CPU_ADDRf_SET
#define READ_OTP_ADDR_REGr BCM53128_A0_READ_OTP_ADDR_REGr
#define WRITE_OTP_ADDR_REGr BCM53128_A0_WRITE_OTP_ADDR_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OTP_ADDR_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OTP_CTL_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Control Registers
 * SIZE:     32
 * FIELDS:
 *     START            Rising edge of the signal will execute OTP command
 *     COMMAND          0: Read1: Program Bit internal clk2: Program Word3: Verify4: Init5: Set6: Reset7: OCST8: Lock9: Prescreen test10: Program bit External clock mode V field programming mode11: Program Word external clock
 *     WRP_PROG_SEL     Program select V debug only, selects which of the 2 analog bit cells to burn(bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_VSEL         verify level select V debug only (bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_PCOUNT       A FAIL was returned from the wrapper logic. The part is bad
 *     WRP_PBYP         OTP cell clock control V debug only (bit [20] of this register must be set in order to see the affect of this bits)
 *     UNUSED           
 *     WRP_SADBYP       sadbpy: senseAmp delay bypass V  debug only (bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_TIME_MARGIN  timing margin - debug only  (bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_CONTINUE_ON_FAIL 0 = OTP will hang jtag_wrapper module on fail V stay in PROG_FAIL state forever OR until reset is applied (or this bit is made 1). 1= OTP will set the FAIL status and continue to accept commands.Please note that even if this bit is 0, the jtag_otp module as such will not hang and the status indicates that there was programming failure.It is only the wrapper module that hangs.Command_done signal will be asserted even in this condition
 *     OTP_DEBUG_MODE   Causes bits [18:5] to be used for direct OTP control V used by the library group for debugging.The bits [18:5] are control bits of the OTP memory that can be programmed using software (CPU interface)
 *     OTP_PROG_EN      Only when otp_prog_en is 1, otp programming from cpu side is enabled.Set this pin to 0 will disable otp programming from cpu side.This bit is usually driven by chip pin to prevent otp programming from cpu side when chip ship to customer
 *     ACCESS_MODE      00 = Raw. This mode is used for all commands except for prog_bit and prog_word command01= manufacturing  area 10= configuration bits area 11= ram repair bits areaThe modes 01, 10 and 11 are used during prog_bit and prog_word commands
 *     BURST_STAT_SEL   Used during word program command.0=data from the OTP memory is sent out,1= FAIL returned for programmed bits is sent out (used to debug the failed bits during burst program)
 *     CPU_DEBUG_SEL    Select signal used to define if data or debug signals are sent to the o_otp_cpu_data output. 8'd0: data signals are sent to o_otp_cpu_data output8'd1: o_otp_cpu_data monitor otp_jtag_debug[31:0]8'd2: o_otp_cpu_data monitor otp_jtag_debug[63:32]8'd3: o_otp_cpu_data monitor otp_jtag_debug[95:64]8'd4: o_otp_cpu_data monitor otp_jtag_debug[127:96]8'd5: o_otp_cpu_data monitor otp_jtag_status[31:0]8'd6: o_otp_cpu_data monitor otp_jtag_status[63:32]8'd7: o_otp_cpu_data monitor otp_jtag_status[95:64]8'd8: o_otp_cpu_data monitor otp_jtag_status[127:96]Other: data signals are sent to o_otp_cpu_data output(Not2Release)
 *     RESERVED         Reserved for future expansion.
 *     BYPASS_OTP_CLK   When set, use TCK throughout the JTAG_OTP IP. This control bit affects only CPU transactions.
 *
 ******************************************************************************/
#define BCM53128_A0_OTP_CTL_REGr 0x0000e000

#define BCM53128_A0_OTP_CTL_REGr_SIZE 4

/*
 * This structure should be used to declare and program OTP_CTL_REG.
 *
 */
typedef union BCM53128_A0_OTP_CTL_REGr_s {
	uint32_t v[1];
	uint32_t otp_ctl_reg[1];
	uint32_t _otp_ctl_reg;
} BCM53128_A0_OTP_CTL_REGr_t;

#define BCM53128_A0_OTP_CTL_REGr_CLR(r) (r).otp_ctl_reg[0] = 0
#define BCM53128_A0_OTP_CTL_REGr_SET(r,d) (r).otp_ctl_reg[0] = d
#define BCM53128_A0_OTP_CTL_REGr_GET(r) (r).otp_ctl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_OTP_CTL_REGr_STARTf_GET(r) (((r).otp_ctl_reg[0]) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_STARTf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_OTP_CTL_REGr_COMMANDf_GET(r) ((((r).otp_ctl_reg[0]) >> 1) & 0xf)
#define BCM53128_A0_OTP_CTL_REGr_COMMANDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM53128_A0_OTP_CTL_REGr_WRP_PROG_SELf_GET(r) ((((r).otp_ctl_reg[0]) >> 5) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_WRP_PROG_SELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_OTP_CTL_REGr_WRP_VSELf_GET(r) ((((r).otp_ctl_reg[0]) >> 6) & 0xf)
#define BCM53128_A0_OTP_CTL_REGr_WRP_VSELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM53128_A0_OTP_CTL_REGr_WRP_PCOUNTf_GET(r) ((((r).otp_ctl_reg[0]) >> 10) & 0x7)
#define BCM53128_A0_OTP_CTL_REGr_WRP_PCOUNTf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53128_A0_OTP_CTL_REGr_WRP_PBYPf_GET(r) ((((r).otp_ctl_reg[0]) >> 13) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_WRP_PBYPf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53128_A0_OTP_CTL_REGr_UNUSEDf_GET(r) ((((r).otp_ctl_reg[0]) >> 14) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_UNUSEDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_OTP_CTL_REGr_WRP_SADBYPf_GET(r) ((((r).otp_ctl_reg[0]) >> 15) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_WRP_SADBYPf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_GET(r) ((((r).otp_ctl_reg[0]) >> 16) & 0x7)
#define BCM53128_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53128_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_GET(r) ((((r).otp_ctl_reg[0]) >> 19) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53128_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_GET(r) ((((r).otp_ctl_reg[0]) >> 20) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53128_A0_OTP_CTL_REGr_OTP_PROG_ENf_GET(r) ((((r).otp_ctl_reg[0]) >> 21) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_OTP_PROG_ENf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53128_A0_OTP_CTL_REGr_ACCESS_MODEf_GET(r) ((((r).otp_ctl_reg[0]) >> 22) & 0x3)
#define BCM53128_A0_OTP_CTL_REGr_ACCESS_MODEf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53128_A0_OTP_CTL_REGr_BURST_STAT_SELf_GET(r) ((((r).otp_ctl_reg[0]) >> 24) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_BURST_STAT_SELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53128_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_GET(r) ((((r).otp_ctl_reg[0]) >> 25) & 0xf)
#define BCM53128_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM53128_A0_OTP_CTL_REGr_RESERVEDf_GET(r) ((((r).otp_ctl_reg[0]) >> 29) & 0x3)
#define BCM53128_A0_OTP_CTL_REGr_RESERVEDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53128_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_GET(r) ((((r).otp_ctl_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access OTP_CTL_REG.
 *
 */
#define BCM53128_A0_READ_OTP_CTL_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_OTP_CTL_REGr,(r._otp_ctl_reg),4)
#define BCM53128_A0_WRITE_OTP_CTL_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_OTP_CTL_REGr,&(r._otp_ctl_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_CTL_REGr BCM53128_A0_OTP_CTL_REGr
#define OTP_CTL_REGr_SIZE BCM53128_A0_OTP_CTL_REGr_SIZE
typedef BCM53128_A0_OTP_CTL_REGr_t OTP_CTL_REGr_t;
#define OTP_CTL_REGr_CLR BCM53128_A0_OTP_CTL_REGr_CLR
#define OTP_CTL_REGr_SET BCM53128_A0_OTP_CTL_REGr_SET
#define OTP_CTL_REGr_GET BCM53128_A0_OTP_CTL_REGr_GET
#define OTP_CTL_REGr_STARTf_GET BCM53128_A0_OTP_CTL_REGr_STARTf_GET
#define OTP_CTL_REGr_STARTf_SET BCM53128_A0_OTP_CTL_REGr_STARTf_SET
#define OTP_CTL_REGr_COMMANDf_GET BCM53128_A0_OTP_CTL_REGr_COMMANDf_GET
#define OTP_CTL_REGr_COMMANDf_SET BCM53128_A0_OTP_CTL_REGr_COMMANDf_SET
#define OTP_CTL_REGr_WRP_PROG_SELf_GET BCM53128_A0_OTP_CTL_REGr_WRP_PROG_SELf_GET
#define OTP_CTL_REGr_WRP_PROG_SELf_SET BCM53128_A0_OTP_CTL_REGr_WRP_PROG_SELf_SET
#define OTP_CTL_REGr_WRP_VSELf_GET BCM53128_A0_OTP_CTL_REGr_WRP_VSELf_GET
#define OTP_CTL_REGr_WRP_VSELf_SET BCM53128_A0_OTP_CTL_REGr_WRP_VSELf_SET
#define OTP_CTL_REGr_WRP_PCOUNTf_GET BCM53128_A0_OTP_CTL_REGr_WRP_PCOUNTf_GET
#define OTP_CTL_REGr_WRP_PCOUNTf_SET BCM53128_A0_OTP_CTL_REGr_WRP_PCOUNTf_SET
#define OTP_CTL_REGr_WRP_PBYPf_GET BCM53128_A0_OTP_CTL_REGr_WRP_PBYPf_GET
#define OTP_CTL_REGr_WRP_PBYPf_SET BCM53128_A0_OTP_CTL_REGr_WRP_PBYPf_SET
#define OTP_CTL_REGr_UNUSEDf_GET BCM53128_A0_OTP_CTL_REGr_UNUSEDf_GET
#define OTP_CTL_REGr_UNUSEDf_SET BCM53128_A0_OTP_CTL_REGr_UNUSEDf_SET
#define OTP_CTL_REGr_WRP_SADBYPf_GET BCM53128_A0_OTP_CTL_REGr_WRP_SADBYPf_GET
#define OTP_CTL_REGr_WRP_SADBYPf_SET BCM53128_A0_OTP_CTL_REGr_WRP_SADBYPf_SET
#define OTP_CTL_REGr_WRP_TIME_MARGINf_GET BCM53128_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_GET
#define OTP_CTL_REGr_WRP_TIME_MARGINf_SET BCM53128_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_SET
#define OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_GET BCM53128_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_GET
#define OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_SET BCM53128_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_SET
#define OTP_CTL_REGr_OTP_DEBUG_MODEf_GET BCM53128_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_GET
#define OTP_CTL_REGr_OTP_DEBUG_MODEf_SET BCM53128_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_SET
#define OTP_CTL_REGr_OTP_PROG_ENf_GET BCM53128_A0_OTP_CTL_REGr_OTP_PROG_ENf_GET
#define OTP_CTL_REGr_OTP_PROG_ENf_SET BCM53128_A0_OTP_CTL_REGr_OTP_PROG_ENf_SET
#define OTP_CTL_REGr_ACCESS_MODEf_GET BCM53128_A0_OTP_CTL_REGr_ACCESS_MODEf_GET
#define OTP_CTL_REGr_ACCESS_MODEf_SET BCM53128_A0_OTP_CTL_REGr_ACCESS_MODEf_SET
#define OTP_CTL_REGr_BURST_STAT_SELf_GET BCM53128_A0_OTP_CTL_REGr_BURST_STAT_SELf_GET
#define OTP_CTL_REGr_BURST_STAT_SELf_SET BCM53128_A0_OTP_CTL_REGr_BURST_STAT_SELf_SET
#define OTP_CTL_REGr_CPU_DEBUG_SELf_GET BCM53128_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_GET
#define OTP_CTL_REGr_CPU_DEBUG_SELf_SET BCM53128_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_SET
#define OTP_CTL_REGr_RESERVEDf_GET BCM53128_A0_OTP_CTL_REGr_RESERVEDf_GET
#define OTP_CTL_REGr_RESERVEDf_SET BCM53128_A0_OTP_CTL_REGr_RESERVEDf_SET
#define OTP_CTL_REGr_BYPASS_OTP_CLKf_GET BCM53128_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_GET
#define OTP_CTL_REGr_BYPASS_OTP_CLKf_SET BCM53128_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_SET
#define READ_OTP_CTL_REGr BCM53128_A0_READ_OTP_CTL_REGr
#define WRITE_OTP_CTL_REGr BCM53128_A0_WRITE_OTP_CTL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OTP_CTL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OTP_RD_DATA
 * BLOCKS:   SYS
 * DESC:     CPU OTP Read Data Registers
 * SIZE:     32
 * FIELDS:
 *     CPU_RD_DATA      The 32 bit CPU OTP read data register outputs the 32 bit read data from read command of CPU interface
 *
 ******************************************************************************/
#define BCM53128_A0_OTP_RD_DATAr 0x0000e00c

#define BCM53128_A0_OTP_RD_DATAr_SIZE 4

/*
 * This structure should be used to declare and program OTP_RD_DATA.
 *
 */
typedef union BCM53128_A0_OTP_RD_DATAr_s {
	uint32_t v[1];
	uint32_t otp_rd_data[1];
	uint32_t _otp_rd_data;
} BCM53128_A0_OTP_RD_DATAr_t;

#define BCM53128_A0_OTP_RD_DATAr_CLR(r) (r).otp_rd_data[0] = 0
#define BCM53128_A0_OTP_RD_DATAr_SET(r,d) (r).otp_rd_data[0] = d
#define BCM53128_A0_OTP_RD_DATAr_GET(r) (r).otp_rd_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_OTP_RD_DATAr_CPU_RD_DATAf_GET(r) ((r).otp_rd_data[0])
#define BCM53128_A0_OTP_RD_DATAr_CPU_RD_DATAf_SET(r,f) (r).otp_rd_data[0]=((uint32_t)f)

/*
 * These macros can be used to access OTP_RD_DATA.
 *
 */
#define BCM53128_A0_READ_OTP_RD_DATAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_OTP_RD_DATAr,(r._otp_rd_data),4)
#define BCM53128_A0_WRITE_OTP_RD_DATAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_OTP_RD_DATAr,&(r._otp_rd_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_RD_DATAr BCM53128_A0_OTP_RD_DATAr
#define OTP_RD_DATAr_SIZE BCM53128_A0_OTP_RD_DATAr_SIZE
typedef BCM53128_A0_OTP_RD_DATAr_t OTP_RD_DATAr_t;
#define OTP_RD_DATAr_CLR BCM53128_A0_OTP_RD_DATAr_CLR
#define OTP_RD_DATAr_SET BCM53128_A0_OTP_RD_DATAr_SET
#define OTP_RD_DATAr_GET BCM53128_A0_OTP_RD_DATAr_GET
#define OTP_RD_DATAr_CPU_RD_DATAf_GET BCM53128_A0_OTP_RD_DATAr_CPU_RD_DATAf_GET
#define OTP_RD_DATAr_CPU_RD_DATAf_SET BCM53128_A0_OTP_RD_DATAr_CPU_RD_DATAf_SET
#define READ_OTP_RD_DATAr BCM53128_A0_READ_OTP_RD_DATAr
#define WRITE_OTP_RD_DATAr BCM53128_A0_WRITE_OTP_RD_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OTP_RD_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OTP_STS_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Status Registers
 * SIZE:     16
 * FIELDS:
 *     COMMAND_DONE     This bit is set when the state machine has returned to IDLE.This will not be set until the last bit of a WORD program is complete.
 *     WRP_DATA_READY   The wrp_dout is now valid to read.
 *     WRP_DOUT         This is the single bit data pointed to by the 12 bit address
 *     WRP_BUSY         A wrp_busy was seen V your request was started. Check command_done (bit 0) to see when it is complete
 *     WRP_FAIL         A FAIL was returned from the wrapper logic. The part is bad
 *     INVALID_PROG_REQ A program request was sent with the incorrect access mode and 12 bit address settings
 *     PROG_BLOCKED     The row is locked and the programming attempt was not allowed
 *     INIT_WAIT_DONE   Can be used to indicate when the OTP is out of RESET.Also if this bit is not a 1, there is no clock to the block OR the block is still in RESET
 *     UNUSED_1         
 *     INVALID_COMMAND  An invalid command was issued.
 *     WRP_ERROR        The wrapper module state machine went into an error state. Else returns 0.
 *     CONTROL_ERR      The control module state machine went into an error state. Else returns 0.
 *     UNUSED_0         
 *
 ******************************************************************************/
#define BCM53128_A0_OTP_STS_REGr 0x0000e006

#define BCM53128_A0_OTP_STS_REGr_SIZE 2

/*
 * This structure should be used to declare and program OTP_STS_REG.
 *
 */
typedef union BCM53128_A0_OTP_STS_REGr_s {
	uint32_t v[1];
	uint32_t otp_sts_reg[1];
	uint32_t _otp_sts_reg;
} BCM53128_A0_OTP_STS_REGr_t;

#define BCM53128_A0_OTP_STS_REGr_CLR(r) (r).otp_sts_reg[0] = 0
#define BCM53128_A0_OTP_STS_REGr_SET(r,d) (r).otp_sts_reg[0] = d
#define BCM53128_A0_OTP_STS_REGr_GET(r) (r).otp_sts_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_OTP_STS_REGr_COMMAND_DONEf_GET(r) (((r).otp_sts_reg[0]) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_COMMAND_DONEf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_OTP_STS_REGr_WRP_DATA_READYf_GET(r) ((((r).otp_sts_reg[0]) >> 1) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_WRP_DATA_READYf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_OTP_STS_REGr_WRP_DOUTf_GET(r) ((((r).otp_sts_reg[0]) >> 2) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_WRP_DOUTf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_OTP_STS_REGr_WRP_BUSYf_GET(r) ((((r).otp_sts_reg[0]) >> 3) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_WRP_BUSYf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_OTP_STS_REGr_WRP_FAILf_GET(r) ((((r).otp_sts_reg[0]) >> 4) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_WRP_FAILf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_OTP_STS_REGr_INVALID_PROG_REQf_GET(r) ((((r).otp_sts_reg[0]) >> 5) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_INVALID_PROG_REQf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_OTP_STS_REGr_PROG_BLOCKEDf_GET(r) ((((r).otp_sts_reg[0]) >> 6) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_PROG_BLOCKEDf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_OTP_STS_REGr_INIT_WAIT_DONEf_GET(r) ((((r).otp_sts_reg[0]) >> 7) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_INIT_WAIT_DONEf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_OTP_STS_REGr_UNUSED_1f_GET(r) ((((r).otp_sts_reg[0]) >> 8) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_UNUSED_1f_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_OTP_STS_REGr_INVALID_COMMANDf_GET(r) ((((r).otp_sts_reg[0]) >> 9) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_INVALID_COMMANDf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_OTP_STS_REGr_WRP_ERRORf_GET(r) ((((r).otp_sts_reg[0]) >> 10) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_WRP_ERRORf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_OTP_STS_REGr_CONTROL_ERRf_GET(r) ((((r).otp_sts_reg[0]) >> 11) & 0x1)
#define BCM53128_A0_OTP_STS_REGr_CONTROL_ERRf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_OTP_STS_REGr_UNUSED_0f_GET(r) ((((r).otp_sts_reg[0]) >> 12) & 0xf)
#define BCM53128_A0_OTP_STS_REGr_UNUSED_0f_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access OTP_STS_REG.
 *
 */
#define BCM53128_A0_READ_OTP_STS_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_OTP_STS_REGr,(r._otp_sts_reg),2)
#define BCM53128_A0_WRITE_OTP_STS_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_OTP_STS_REGr,&(r._otp_sts_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_STS_REGr BCM53128_A0_OTP_STS_REGr
#define OTP_STS_REGr_SIZE BCM53128_A0_OTP_STS_REGr_SIZE
typedef BCM53128_A0_OTP_STS_REGr_t OTP_STS_REGr_t;
#define OTP_STS_REGr_CLR BCM53128_A0_OTP_STS_REGr_CLR
#define OTP_STS_REGr_SET BCM53128_A0_OTP_STS_REGr_SET
#define OTP_STS_REGr_GET BCM53128_A0_OTP_STS_REGr_GET
#define OTP_STS_REGr_COMMAND_DONEf_GET BCM53128_A0_OTP_STS_REGr_COMMAND_DONEf_GET
#define OTP_STS_REGr_COMMAND_DONEf_SET BCM53128_A0_OTP_STS_REGr_COMMAND_DONEf_SET
#define OTP_STS_REGr_WRP_DATA_READYf_GET BCM53128_A0_OTP_STS_REGr_WRP_DATA_READYf_GET
#define OTP_STS_REGr_WRP_DATA_READYf_SET BCM53128_A0_OTP_STS_REGr_WRP_DATA_READYf_SET
#define OTP_STS_REGr_WRP_DOUTf_GET BCM53128_A0_OTP_STS_REGr_WRP_DOUTf_GET
#define OTP_STS_REGr_WRP_DOUTf_SET BCM53128_A0_OTP_STS_REGr_WRP_DOUTf_SET
#define OTP_STS_REGr_WRP_BUSYf_GET BCM53128_A0_OTP_STS_REGr_WRP_BUSYf_GET
#define OTP_STS_REGr_WRP_BUSYf_SET BCM53128_A0_OTP_STS_REGr_WRP_BUSYf_SET
#define OTP_STS_REGr_WRP_FAILf_GET BCM53128_A0_OTP_STS_REGr_WRP_FAILf_GET
#define OTP_STS_REGr_WRP_FAILf_SET BCM53128_A0_OTP_STS_REGr_WRP_FAILf_SET
#define OTP_STS_REGr_INVALID_PROG_REQf_GET BCM53128_A0_OTP_STS_REGr_INVALID_PROG_REQf_GET
#define OTP_STS_REGr_INVALID_PROG_REQf_SET BCM53128_A0_OTP_STS_REGr_INVALID_PROG_REQf_SET
#define OTP_STS_REGr_PROG_BLOCKEDf_GET BCM53128_A0_OTP_STS_REGr_PROG_BLOCKEDf_GET
#define OTP_STS_REGr_PROG_BLOCKEDf_SET BCM53128_A0_OTP_STS_REGr_PROG_BLOCKEDf_SET
#define OTP_STS_REGr_INIT_WAIT_DONEf_GET BCM53128_A0_OTP_STS_REGr_INIT_WAIT_DONEf_GET
#define OTP_STS_REGr_INIT_WAIT_DONEf_SET BCM53128_A0_OTP_STS_REGr_INIT_WAIT_DONEf_SET
#define OTP_STS_REGr_UNUSED_1f_GET BCM53128_A0_OTP_STS_REGr_UNUSED_1f_GET
#define OTP_STS_REGr_UNUSED_1f_SET BCM53128_A0_OTP_STS_REGr_UNUSED_1f_SET
#define OTP_STS_REGr_INVALID_COMMANDf_GET BCM53128_A0_OTP_STS_REGr_INVALID_COMMANDf_GET
#define OTP_STS_REGr_INVALID_COMMANDf_SET BCM53128_A0_OTP_STS_REGr_INVALID_COMMANDf_SET
#define OTP_STS_REGr_WRP_ERRORf_GET BCM53128_A0_OTP_STS_REGr_WRP_ERRORf_GET
#define OTP_STS_REGr_WRP_ERRORf_SET BCM53128_A0_OTP_STS_REGr_WRP_ERRORf_SET
#define OTP_STS_REGr_CONTROL_ERRf_GET BCM53128_A0_OTP_STS_REGr_CONTROL_ERRf_GET
#define OTP_STS_REGr_CONTROL_ERRf_SET BCM53128_A0_OTP_STS_REGr_CONTROL_ERRf_SET
#define OTP_STS_REGr_UNUSED_0f_GET BCM53128_A0_OTP_STS_REGr_UNUSED_0f_GET
#define OTP_STS_REGr_UNUSED_0f_SET BCM53128_A0_OTP_STS_REGr_UNUSED_0f_SET
#define READ_OTP_STS_REGr BCM53128_A0_READ_OTP_STS_REGr
#define WRITE_OTP_STS_REGr BCM53128_A0_WRITE_OTP_STS_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OTP_STS_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OTP_WR_DATA
 * BLOCKS:   SYS
 * DESC:     CPU OTP Write Data Registers
 * SIZE:     32
 * FIELDS:
 *     CPU_WR_DATA      The 32 bit CPU OTP write data register is used to provide write data with burst write command from CPU side.Different than the burst write from JTAG, cpu interface only supports 32 bit burst write data.This is to reduce the number of bits needed to wire to cpu interface at top level
 *
 ******************************************************************************/
#define BCM53128_A0_OTP_WR_DATAr 0x0000e008

#define BCM53128_A0_OTP_WR_DATAr_SIZE 4

/*
 * This structure should be used to declare and program OTP_WR_DATA.
 *
 */
typedef union BCM53128_A0_OTP_WR_DATAr_s {
	uint32_t v[1];
	uint32_t otp_wr_data[1];
	uint32_t _otp_wr_data;
} BCM53128_A0_OTP_WR_DATAr_t;

#define BCM53128_A0_OTP_WR_DATAr_CLR(r) (r).otp_wr_data[0] = 0
#define BCM53128_A0_OTP_WR_DATAr_SET(r,d) (r).otp_wr_data[0] = d
#define BCM53128_A0_OTP_WR_DATAr_GET(r) (r).otp_wr_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_OTP_WR_DATAr_CPU_WR_DATAf_GET(r) ((r).otp_wr_data[0])
#define BCM53128_A0_OTP_WR_DATAr_CPU_WR_DATAf_SET(r,f) (r).otp_wr_data[0]=((uint32_t)f)

/*
 * These macros can be used to access OTP_WR_DATA.
 *
 */
#define BCM53128_A0_READ_OTP_WR_DATAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_OTP_WR_DATAr,(r._otp_wr_data),4)
#define BCM53128_A0_WRITE_OTP_WR_DATAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_OTP_WR_DATAr,&(r._otp_wr_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_WR_DATAr BCM53128_A0_OTP_WR_DATAr
#define OTP_WR_DATAr_SIZE BCM53128_A0_OTP_WR_DATAr_SIZE
typedef BCM53128_A0_OTP_WR_DATAr_t OTP_WR_DATAr_t;
#define OTP_WR_DATAr_CLR BCM53128_A0_OTP_WR_DATAr_CLR
#define OTP_WR_DATAr_SET BCM53128_A0_OTP_WR_DATAr_SET
#define OTP_WR_DATAr_GET BCM53128_A0_OTP_WR_DATAr_GET
#define OTP_WR_DATAr_CPU_WR_DATAf_GET BCM53128_A0_OTP_WR_DATAr_CPU_WR_DATAf_GET
#define OTP_WR_DATAr_CPU_WR_DATAf_SET BCM53128_A0_OTP_WR_DATAr_CPU_WR_DATAf_SET
#define READ_OTP_WR_DATAr BCM53128_A0_READ_OTP_WR_DATAr
#define WRITE_OTP_WR_DATAr BCM53128_A0_WRITE_OTP_WR_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OTP_WR_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OutRangeErrCount
 * BLOCKS:   GPIC0 CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_OUTRANGEERRCOUNTr 0x000020b4

#define BCM53128_A0_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount.
 *
 */
typedef union BCM53128_A0_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount[1];
	uint32_t _outrangeerrcount;
} BCM53128_A0_OUTRANGEERRCOUNTr_t;

#define BCM53128_A0_OUTRANGEERRCOUNTr_CLR(r) (r).outrangeerrcount[0] = 0
#define BCM53128_A0_OUTRANGEERRCOUNTr_SET(r,d) (r).outrangeerrcount[0] = d
#define BCM53128_A0_OUTRANGEERRCOUNTr_GET(r) (r).outrangeerrcount[0]


/*
 * These macros can be used to access OutRangeErrCount.
 *
 */
#define BCM53128_A0_READ_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_OUTRANGEERRCOUNTr,(r._outrangeerrcount),4)
#define BCM53128_A0_WRITE_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_OUTRANGEERRCOUNTr,&(r._outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNTr BCM53128_A0_OUTRANGEERRCOUNTr
#define OUTRANGEERRCOUNTr_SIZE BCM53128_A0_OUTRANGEERRCOUNTr_SIZE
typedef BCM53128_A0_OUTRANGEERRCOUNTr_t OUTRANGEERRCOUNTr_t;
#define OUTRANGEERRCOUNTr_CLR BCM53128_A0_OUTRANGEERRCOUNTr_CLR
#define OUTRANGEERRCOUNTr_SET BCM53128_A0_OUTRANGEERRCOUNTr_SET
#define OUTRANGEERRCOUNTr_GET BCM53128_A0_OUTRANGEERRCOUNTr_GET
#define READ_OUTRANGEERRCOUNTr BCM53128_A0_READ_OUTRANGEERRCOUNTr
#define WRITE_OUTRANGEERRCOUNTr BCM53128_A0_WRITE_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  OutRangeErrCount_IMP
 * BLOCKS:   CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_OUTRANGEERRCOUNT_IMPr 0x000028b4

#define BCM53128_A0_OUTRANGEERRCOUNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount_IMP.
 *
 */
typedef union BCM53128_A0_OUTRANGEERRCOUNT_IMPr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount_imp[1];
	uint32_t _outrangeerrcount_imp;
} BCM53128_A0_OUTRANGEERRCOUNT_IMPr_t;

#define BCM53128_A0_OUTRANGEERRCOUNT_IMPr_CLR(r) (r).outrangeerrcount_imp[0] = 0
#define BCM53128_A0_OUTRANGEERRCOUNT_IMPr_SET(r,d) (r).outrangeerrcount_imp[0] = d
#define BCM53128_A0_OUTRANGEERRCOUNT_IMPr_GET(r) (r).outrangeerrcount_imp[0]


/*
 * These macros can be used to access OutRangeErrCount_IMP.
 *
 */
#define BCM53128_A0_READ_OUTRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_OUTRANGEERRCOUNT_IMPr,(r._outrangeerrcount_imp),4)
#define BCM53128_A0_WRITE_OUTRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_OUTRANGEERRCOUNT_IMPr,&(r._outrangeerrcount_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNT_IMPr BCM53128_A0_OUTRANGEERRCOUNT_IMPr
#define OUTRANGEERRCOUNT_IMPr_SIZE BCM53128_A0_OUTRANGEERRCOUNT_IMPr_SIZE
typedef BCM53128_A0_OUTRANGEERRCOUNT_IMPr_t OUTRANGEERRCOUNT_IMPr_t;
#define OUTRANGEERRCOUNT_IMPr_CLR BCM53128_A0_OUTRANGEERRCOUNT_IMPr_CLR
#define OUTRANGEERRCOUNT_IMPr_SET BCM53128_A0_OUTRANGEERRCOUNT_IMPr_SET
#define OUTRANGEERRCOUNT_IMPr_GET BCM53128_A0_OUTRANGEERRCOUNT_IMPr_GET
#define READ_OUTRANGEERRCOUNT_IMPr BCM53128_A0_READ_OUTRANGEERRCOUNT_IMPr
#define WRITE_OUTRANGEERRCOUNT_IMPr BCM53128_A0_WRITE_OUTRANGEERRCOUNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_OUTRANGEERRCOUNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PAGEREG
 * BLOCKS:   SPI
 * DESC:     PAGE Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Next Page
 *
 ******************************************************************************/
#define BCM53128_A0_PAGEREGr 0x0000ffff

#define BCM53128_A0_PAGEREGr_SIZE 1

/*
 * This structure should be used to declare and program PAGEREG.
 *
 */
typedef union BCM53128_A0_PAGEREGr_s {
	uint32_t v[1];
	uint32_t pagereg[1];
	uint32_t _pagereg;
} BCM53128_A0_PAGEREGr_t;

#define BCM53128_A0_PAGEREGr_CLR(r) (r).pagereg[0] = 0
#define BCM53128_A0_PAGEREGr_SET(r,d) (r).pagereg[0] = d
#define BCM53128_A0_PAGEREGr_GET(r) (r).pagereg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PAGEREGr_RESERVEDf_GET(r) (((r).pagereg[0]) & 0xff)
#define BCM53128_A0_PAGEREGr_RESERVEDf_SET(r,f) (r).pagereg[0]=(((r).pagereg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PAGEREG.
 *
 */
#define BCM53128_A0_READ_PAGEREGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PAGEREGr,(r._pagereg),1)
#define BCM53128_A0_WRITE_PAGEREGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PAGEREGr,&(r._pagereg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAGEREGr BCM53128_A0_PAGEREGr
#define PAGEREGr_SIZE BCM53128_A0_PAGEREGr_SIZE
typedef BCM53128_A0_PAGEREGr_t PAGEREGr_t;
#define PAGEREGr_CLR BCM53128_A0_PAGEREGr_CLR
#define PAGEREGr_SET BCM53128_A0_PAGEREGr_SET
#define PAGEREGr_GET BCM53128_A0_PAGEREGr_GET
#define PAGEREGr_RESERVEDf_GET BCM53128_A0_PAGEREGr_RESERVEDf_GET
#define PAGEREGr_RESERVEDf_SET BCM53128_A0_PAGEREGr_RESERVEDf_SET
#define READ_PAGEREGr BCM53128_A0_READ_PAGEREGr
#define WRITE_PAGEREGr BCM53128_A0_WRITE_PAGEREGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PAGEREGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PAUSESTS
 * BLOCKS:   SYS
 * DESC:     Pause Status Summary Register
 * SIZE:     32
 * FIELDS:
 *     PAUSE_STS        PAUSE State.18 bit field indicating the PAUSE state for each 10/100/1000BASE-T port and IMP port.Bit 8- 0 = IMP port, Port 7 - Port 0 Transmit Pause CapabilityBit 17-9 = IMP port, Port 7 - Port 0 Receive Pause Capability0 = Disabled1 = Enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PAUSESTSr 0x0000010a

#define BCM53128_A0_PAUSESTSr_SIZE 4

/*
 * This structure should be used to declare and program PAUSESTS.
 *
 */
typedef union BCM53128_A0_PAUSESTSr_s {
	uint32_t v[1];
	uint32_t pausests[1];
	uint32_t _pausests;
} BCM53128_A0_PAUSESTSr_t;

#define BCM53128_A0_PAUSESTSr_CLR(r) (r).pausests[0] = 0
#define BCM53128_A0_PAUSESTSr_SET(r,d) (r).pausests[0] = d
#define BCM53128_A0_PAUSESTSr_GET(r) (r).pausests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PAUSESTSr_PAUSE_STSf_GET(r) (((r).pausests[0]) & 0x3ffff)
#define BCM53128_A0_PAUSESTSr_PAUSE_STSf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53128_A0_PAUSESTSr_RESERVEDf_GET(r) ((((r).pausests[0]) >> 18) & 0x3fff)
#define BCM53128_A0_PAUSESTSr_RESERVEDf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PAUSESTS.
 *
 */
#define BCM53128_A0_READ_PAUSESTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PAUSESTSr,(r._pausests),4)
#define BCM53128_A0_WRITE_PAUSESTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PAUSESTSr,&(r._pausests),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSESTSr BCM53128_A0_PAUSESTSr
#define PAUSESTSr_SIZE BCM53128_A0_PAUSESTSr_SIZE
typedef BCM53128_A0_PAUSESTSr_t PAUSESTSr_t;
#define PAUSESTSr_CLR BCM53128_A0_PAUSESTSr_CLR
#define PAUSESTSr_SET BCM53128_A0_PAUSESTSr_SET
#define PAUSESTSr_GET BCM53128_A0_PAUSESTSr_GET
#define PAUSESTSr_PAUSE_STSf_GET BCM53128_A0_PAUSESTSr_PAUSE_STSf_GET
#define PAUSESTSr_PAUSE_STSf_SET BCM53128_A0_PAUSESTSr_PAUSE_STSf_SET
#define PAUSESTSr_RESERVEDf_GET BCM53128_A0_PAUSESTSr_RESERVEDf_GET
#define PAUSESTSr_RESERVEDf_SET BCM53128_A0_PAUSESTSr_RESERVEDf_SET
#define READ_PAUSESTSr BCM53128_A0_READ_PAUSESTSr
#define WRITE_PAUSESTSr BCM53128_A0_WRITE_PAUSESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PAUSESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PAUSE_CAP
 * BLOCKS:   SYS
 * DESC:     PAUSE Capability Register
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_CAP     Software setting for the capability of Transmitting Pause Frame.Bit 8 = Port 8.Bits 7:0 = Port 7 - Port 0.
 *     RX_PAUSE_CAP     Software setting for the capability of Receiving Pause Frame.Bit 17 = Port 8,Bits 16:9 = Port 7- Port 0.
 *     RESERVED         Reserved
 *     EN_OVERRIDE      Force the contents of the register to be used.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PAUSE_CAPr 0x00000028

#define BCM53128_A0_PAUSE_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CAP.
 *
 */
typedef union BCM53128_A0_PAUSE_CAPr_s {
	uint32_t v[1];
	uint32_t pause_cap[1];
	uint32_t _pause_cap;
} BCM53128_A0_PAUSE_CAPr_t;

#define BCM53128_A0_PAUSE_CAPr_CLR(r) (r).pause_cap[0] = 0
#define BCM53128_A0_PAUSE_CAPr_SET(r,d) (r).pause_cap[0] = d
#define BCM53128_A0_PAUSE_CAPr_GET(r) (r).pause_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET(r) (((r).pause_cap[0]) & 0x1ff)
#define BCM53128_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET(r) ((((r).pause_cap[0]) >> 9) & 0x1ff)
#define BCM53128_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53128_A0_PAUSE_CAPr_RESERVEDf_GET(r) ((((r).pause_cap[0]) >> 18) & 0x1f)
#define BCM53128_A0_PAUSE_CAPr_RESERVEDf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM53128_A0_PAUSE_CAPr_EN_OVERRIDEf_GET(r) ((((r).pause_cap[0]) >> 23) & 0x1)
#define BCM53128_A0_PAUSE_CAPr_EN_OVERRIDEf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53128_A0_PAUSE_CAPr_RESERVED_1f_GET(r) ((((r).pause_cap[0]) >> 24) & 0xff)
#define BCM53128_A0_PAUSE_CAPr_RESERVED_1f_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PAUSE_CAP.
 *
 */
#define BCM53128_A0_READ_PAUSE_CAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PAUSE_CAPr,(r._pause_cap),4)
#define BCM53128_A0_WRITE_PAUSE_CAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PAUSE_CAPr,&(r._pause_cap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CAPr BCM53128_A0_PAUSE_CAPr
#define PAUSE_CAPr_SIZE BCM53128_A0_PAUSE_CAPr_SIZE
typedef BCM53128_A0_PAUSE_CAPr_t PAUSE_CAPr_t;
#define PAUSE_CAPr_CLR BCM53128_A0_PAUSE_CAPr_CLR
#define PAUSE_CAPr_SET BCM53128_A0_PAUSE_CAPr_SET
#define PAUSE_CAPr_GET BCM53128_A0_PAUSE_CAPr_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_GET BCM53128_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_SET BCM53128_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RX_PAUSE_CAPf_GET BCM53128_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET
#define PAUSE_CAPr_RX_PAUSE_CAPf_SET BCM53128_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RESERVEDf_GET BCM53128_A0_PAUSE_CAPr_RESERVEDf_GET
#define PAUSE_CAPr_RESERVEDf_SET BCM53128_A0_PAUSE_CAPr_RESERVEDf_SET
#define PAUSE_CAPr_EN_OVERRIDEf_GET BCM53128_A0_PAUSE_CAPr_EN_OVERRIDEf_GET
#define PAUSE_CAPr_EN_OVERRIDEf_SET BCM53128_A0_PAUSE_CAPr_EN_OVERRIDEf_SET
#define PAUSE_CAPr_RESERVED_1f_GET BCM53128_A0_PAUSE_CAPr_RESERVED_1f_GET
#define PAUSE_CAPr_RESERVED_1f_SET BCM53128_A0_PAUSE_CAPr_RESERVED_1f_SET
#define READ_PAUSE_CAPr BCM53128_A0_READ_PAUSE_CAPr
#define WRITE_PAUSE_CAPr BCM53128_A0_WRITE_PAUSE_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PAUSE_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PAUSE_FRM_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause Frame Detection Control Register
 * SIZE:     8
 * FIELDS:
 *     PAUSE_IGNORE_DA  Pause_ignore_DA0: Check DA field on Pause Frame detection1: Ignore DA field on Pause Frame detection
 *     RESERVED_1       Reserved, Should SET 2'b00 for correct operation
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PAUSE_FRM_CTRLr 0x00000080

#define BCM53128_A0_PAUSE_FRM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PAUSE_FRM_CTRL.
 *
 */
typedef union BCM53128_A0_PAUSE_FRM_CTRLr_s {
	uint32_t v[1];
	uint32_t pause_frm_ctrl[1];
	uint32_t _pause_frm_ctrl;
} BCM53128_A0_PAUSE_FRM_CTRLr_t;

#define BCM53128_A0_PAUSE_FRM_CTRLr_CLR(r) (r).pause_frm_ctrl[0] = 0
#define BCM53128_A0_PAUSE_FRM_CTRLr_SET(r,d) (r).pause_frm_ctrl[0] = d
#define BCM53128_A0_PAUSE_FRM_CTRLr_GET(r) (r).pause_frm_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET(r) (((r).pause_frm_ctrl[0]) & 0x1)
#define BCM53128_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_1f_GET(r) ((((r).pause_frm_ctrl[0]) >> 1) & 0x3)
#define BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_1f_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_2f_GET(r) ((((r).pause_frm_ctrl[0]) >> 3) & 0x1f)
#define BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_2f_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PAUSE_FRM_CTRL.
 *
 */
#define BCM53128_A0_READ_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PAUSE_FRM_CTRLr,(r._pause_frm_ctrl),1)
#define BCM53128_A0_WRITE_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PAUSE_FRM_CTRLr,&(r._pause_frm_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_FRM_CTRLr BCM53128_A0_PAUSE_FRM_CTRLr
#define PAUSE_FRM_CTRLr_SIZE BCM53128_A0_PAUSE_FRM_CTRLr_SIZE
typedef BCM53128_A0_PAUSE_FRM_CTRLr_t PAUSE_FRM_CTRLr_t;
#define PAUSE_FRM_CTRLr_CLR BCM53128_A0_PAUSE_FRM_CTRLr_CLR
#define PAUSE_FRM_CTRLr_SET BCM53128_A0_PAUSE_FRM_CTRLr_SET
#define PAUSE_FRM_CTRLr_GET BCM53128_A0_PAUSE_FRM_CTRLr_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET BCM53128_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET BCM53128_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET
#define PAUSE_FRM_CTRLr_RESERVED_1f_GET BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_1f_GET
#define PAUSE_FRM_CTRLr_RESERVED_1f_SET BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_1f_SET
#define PAUSE_FRM_CTRLr_RESERVED_2f_GET BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_2f_GET
#define PAUSE_FRM_CTRLr_RESERVED_2f_SET BCM53128_A0_PAUSE_FRM_CTRLr_RESERVED_2f_SET
#define READ_PAUSE_FRM_CTRLr BCM53128_A0_READ_PAUSE_FRM_CTRLr
#define WRITE_PAUSE_FRM_CTRLr BCM53128_A0_WRITE_PAUSE_FRM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PAUSE_FRM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PAUSE_QUANTA
 * BLOCKS:   SYS
 * DESC:     PAUSE Quanta register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_QUANTA     The number of slot times that the transmitter wishes the link partner to suspend its transmission. The same value is common to all ports which have Auto-Negotiated to full duplex with flow control enabled.
 *
 ******************************************************************************/
#define BCM53128_A0_PAUSE_QUANTAr 0x0000000c

#define BCM53128_A0_PAUSE_QUANTAr_SIZE 2

/*
 * This structure should be used to declare and program PAUSE_QUANTA.
 *
 */
typedef union BCM53128_A0_PAUSE_QUANTAr_s {
	uint32_t v[1];
	uint32_t pause_quanta[1];
	uint32_t _pause_quanta;
} BCM53128_A0_PAUSE_QUANTAr_t;

#define BCM53128_A0_PAUSE_QUANTAr_CLR(r) (r).pause_quanta[0] = 0
#define BCM53128_A0_PAUSE_QUANTAr_SET(r,d) (r).pause_quanta[0] = d
#define BCM53128_A0_PAUSE_QUANTAr_GET(r) (r).pause_quanta[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET(r) (((r).pause_quanta[0]) & 0xffff)
#define BCM53128_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET(r,f) (r).pause_quanta[0]=(((r).pause_quanta[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAUSE_QUANTA.
 *
 */
#define BCM53128_A0_READ_PAUSE_QUANTAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PAUSE_QUANTAr,(r._pause_quanta),2)
#define BCM53128_A0_WRITE_PAUSE_QUANTAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PAUSE_QUANTAr,&(r._pause_quanta),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_QUANTAr BCM53128_A0_PAUSE_QUANTAr
#define PAUSE_QUANTAr_SIZE BCM53128_A0_PAUSE_QUANTAr_SIZE
typedef BCM53128_A0_PAUSE_QUANTAr_t PAUSE_QUANTAr_t;
#define PAUSE_QUANTAr_CLR BCM53128_A0_PAUSE_QUANTAr_CLR
#define PAUSE_QUANTAr_SET BCM53128_A0_PAUSE_QUANTAr_SET
#define PAUSE_QUANTAr_GET BCM53128_A0_PAUSE_QUANTAr_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_GET BCM53128_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_SET BCM53128_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET
#define READ_PAUSE_QUANTAr BCM53128_A0_READ_PAUSE_QUANTAr
#define WRITE_PAUSE_QUANTAr BCM53128_A0_WRITE_PAUSE_QUANTAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PAUSE_QUANTAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PBPTRFIFO_0
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 0(Not2Release)
 * SIZE:     48
 * FIELDS:
 *     VALID_CNT_P0     Valid Counter of pbptrfifo for Port 0
 *     VALID_CNT_P1     Valid Counter of pbptrfifo for Port 1
 *     VALID_CNT_P2     Valid Counter of pbptrfifo for Port 2
 *     VALID_CNT_P3     Valid Counter of pbptrfifo for Port 3
 *     VALID_CNT_P4     Valid Counter of pbptrfifo for Port 4
 *     VALID_CNT_P5     Valid Counter of pbptrfifo for Port 5
 *
 ******************************************************************************/
#define BCM53128_A0_PBPTRFIFO_0r 0x00000150

#define BCM53128_A0_PBPTRFIFO_0r_SIZE 6

/*
 * This structure should be used to declare and program PBPTRFIFO_0.
 *
 */
typedef union BCM53128_A0_PBPTRFIFO_0r_s {
	uint32_t v[2];
	uint32_t pbptrfifo_0[2];
	uint32_t _pbptrfifo_0;
} BCM53128_A0_PBPTRFIFO_0r_t;

#define BCM53128_A0_PBPTRFIFO_0r_CLR(r) CDK_MEMSET(&((r)._pbptrfifo_0), 0, sizeof(BCM53128_A0_PBPTRFIFO_0r_t))
#define BCM53128_A0_PBPTRFIFO_0r_SET(r,i,d) (r).pbptrfifo_0[i] = d
#define BCM53128_A0_PBPTRFIFO_0r_GET(r,i) (r).pbptrfifo_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET(r) (((r).pbptrfifo_0[0]) & 0xff)
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET(r) ((((r).pbptrfifo_0[0]) >> 8) & 0xff)
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET(r) ((((r).pbptrfifo_0[0]) >> 16) & 0xff)
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET(r) ((((r).pbptrfifo_0[0]) >> 24) & 0xff)
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET(r) (((r).pbptrfifo_0[1]) & 0xff)
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET(r) ((((r).pbptrfifo_0[1]) >> 8) & 0xff)
#define BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PBPTRFIFO_0.
 *
 */
#define BCM53128_A0_READ_PBPTRFIFO_0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_PBPTRFIFO_0r,(r._pbptrfifo_0),6)
#define BCM53128_A0_WRITE_PBPTRFIFO_0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_PBPTRFIFO_0r,&(r._pbptrfifo_0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_0r BCM53128_A0_PBPTRFIFO_0r
#define PBPTRFIFO_0r_SIZE BCM53128_A0_PBPTRFIFO_0r_SIZE
typedef BCM53128_A0_PBPTRFIFO_0r_t PBPTRFIFO_0r_t;
#define PBPTRFIFO_0r_CLR BCM53128_A0_PBPTRFIFO_0r_CLR
#define PBPTRFIFO_0r_SET BCM53128_A0_PBPTRFIFO_0r_SET
#define PBPTRFIFO_0r_GET BCM53128_A0_PBPTRFIFO_0r_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_GET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_SET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET
#define PBPTRFIFO_0r_VALID_CNT_P1f_GET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET
#define PBPTRFIFO_0r_VALID_CNT_P1f_SET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET
#define PBPTRFIFO_0r_VALID_CNT_P2f_GET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET
#define PBPTRFIFO_0r_VALID_CNT_P2f_SET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET
#define PBPTRFIFO_0r_VALID_CNT_P3f_GET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET
#define PBPTRFIFO_0r_VALID_CNT_P3f_SET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET
#define PBPTRFIFO_0r_VALID_CNT_P4f_GET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET
#define PBPTRFIFO_0r_VALID_CNT_P4f_SET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET
#define PBPTRFIFO_0r_VALID_CNT_P5f_GET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET
#define PBPTRFIFO_0r_VALID_CNT_P5f_SET BCM53128_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET
#define READ_PBPTRFIFO_0r BCM53128_A0_READ_PBPTRFIFO_0r
#define WRITE_PBPTRFIFO_0r BCM53128_A0_WRITE_PBPTRFIFO_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PBPTRFIFO_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PBPTRFIFO_1
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 1(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     VALID_CNT_P6     Valid Counter of pbptrfifo for Port 6.
 *     VALID_CNT_P7     Valid Counter of pbptrfifo for Port 7.
 *     VALID_CNT_P8     Valid Counter of pbptrfifo for Port 8(IMP Port).
 *     RESERVED         
 *
 ******************************************************************************/
#define BCM53128_A0_PBPTRFIFO_1r 0x00000156

#define BCM53128_A0_PBPTRFIFO_1r_SIZE 4

/*
 * This structure should be used to declare and program PBPTRFIFO_1.
 *
 */
typedef union BCM53128_A0_PBPTRFIFO_1r_s {
	uint32_t v[1];
	uint32_t pbptrfifo_1[1];
	uint32_t _pbptrfifo_1;
} BCM53128_A0_PBPTRFIFO_1r_t;

#define BCM53128_A0_PBPTRFIFO_1r_CLR(r) (r).pbptrfifo_1[0] = 0
#define BCM53128_A0_PBPTRFIFO_1r_SET(r,d) (r).pbptrfifo_1[0] = d
#define BCM53128_A0_PBPTRFIFO_1r_GET(r) (r).pbptrfifo_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P6f_GET(r) (((r).pbptrfifo_1[0]) & 0xff)
#define BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P6f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P7f_GET(r) ((((r).pbptrfifo_1[0]) >> 8) & 0xff)
#define BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P7f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET(r) ((((r).pbptrfifo_1[0]) >> 16) & 0xff)
#define BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53128_A0_PBPTRFIFO_1r_RESERVEDf_GET(r) ((((r).pbptrfifo_1[0]) >> 24) & 0xff)
#define BCM53128_A0_PBPTRFIFO_1r_RESERVEDf_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PBPTRFIFO_1.
 *
 */
#define BCM53128_A0_READ_PBPTRFIFO_1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_PBPTRFIFO_1r,(r._pbptrfifo_1),4)
#define BCM53128_A0_WRITE_PBPTRFIFO_1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_PBPTRFIFO_1r,&(r._pbptrfifo_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_1r BCM53128_A0_PBPTRFIFO_1r
#define PBPTRFIFO_1r_SIZE BCM53128_A0_PBPTRFIFO_1r_SIZE
typedef BCM53128_A0_PBPTRFIFO_1r_t PBPTRFIFO_1r_t;
#define PBPTRFIFO_1r_CLR BCM53128_A0_PBPTRFIFO_1r_CLR
#define PBPTRFIFO_1r_SET BCM53128_A0_PBPTRFIFO_1r_SET
#define PBPTRFIFO_1r_GET BCM53128_A0_PBPTRFIFO_1r_GET
#define PBPTRFIFO_1r_VALID_CNT_P6f_GET BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P6f_GET
#define PBPTRFIFO_1r_VALID_CNT_P6f_SET BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P6f_SET
#define PBPTRFIFO_1r_VALID_CNT_P7f_GET BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P7f_GET
#define PBPTRFIFO_1r_VALID_CNT_P7f_SET BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P7f_SET
#define PBPTRFIFO_1r_VALID_CNT_P8f_GET BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET
#define PBPTRFIFO_1r_VALID_CNT_P8f_SET BCM53128_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET
#define PBPTRFIFO_1r_RESERVEDf_GET BCM53128_A0_PBPTRFIFO_1r_RESERVEDf_GET
#define PBPTRFIFO_1r_RESERVEDf_SET BCM53128_A0_PBPTRFIFO_1r_RESERVEDf_SET
#define READ_PBPTRFIFO_1r BCM53128_A0_READ_PBPTRFIFO_1r
#define WRITE_PBPTRFIFO_1r BCM53128_A0_WRITE_PBPTRFIFO_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PBPTRFIFO_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PCP_VALUE_CTRL
 * BLOCKS:   SYS
 * DESC:     AVB PCP value Control Register
 * SIZE:     8
 * FIELDS:
 *     CLASS_A_PCP      AVB Class A pcp valueThis field is used to qualify the pcp value of AVB packet. This AVB packet will be sent to Q5.Note:CLASS_B_PCP and CLASS_A_PCP should be different.If the configuration of CLASS_B_PCP and CLASS_A_PCP are the same, the COS=COS5 for the ingress pack which PCP= CLASS_B_PCP or CLASS_A_PCP.
 *     CLASS_B_PCP      AVB Class B pcp valueThis field is used to qualify the pcp value of AVB packet. This AVB packet will be sent to Q4.Note:CLASS_B_PCP and CLASS_A_PCP should be different.If the configuration of CLASS_B_PCP and CLASS_A_PCP are the same, the COS=COS5 for the ingress pack which PCP= CLASS_B_PCP or CLASS_A_PCP.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PCP_VALUE_CTRLr 0x00009003

#define BCM53128_A0_PCP_VALUE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PCP_VALUE_CTRL.
 *
 */
typedef union BCM53128_A0_PCP_VALUE_CTRLr_s {
	uint32_t v[1];
	uint32_t pcp_value_ctrl[1];
	uint32_t _pcp_value_ctrl;
} BCM53128_A0_PCP_VALUE_CTRLr_t;

#define BCM53128_A0_PCP_VALUE_CTRLr_CLR(r) (r).pcp_value_ctrl[0] = 0
#define BCM53128_A0_PCP_VALUE_CTRLr_SET(r,d) (r).pcp_value_ctrl[0] = d
#define BCM53128_A0_PCP_VALUE_CTRLr_GET(r) (r).pcp_value_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_GET(r) (((r).pcp_value_ctrl[0]) & 0x7)
#define BCM53128_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_SET(r,f) (r).pcp_value_ctrl[0]=(((r).pcp_value_ctrl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_GET(r) ((((r).pcp_value_ctrl[0]) >> 3) & 0x7)
#define BCM53128_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_SET(r,f) (r).pcp_value_ctrl[0]=(((r).pcp_value_ctrl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_PCP_VALUE_CTRLr_RESERVEDf_GET(r) ((((r).pcp_value_ctrl[0]) >> 6) & 0x3)
#define BCM53128_A0_PCP_VALUE_CTRLr_RESERVEDf_SET(r,f) (r).pcp_value_ctrl[0]=(((r).pcp_value_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access PCP_VALUE_CTRL.
 *
 */
#define BCM53128_A0_READ_PCP_VALUE_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PCP_VALUE_CTRLr,(r._pcp_value_ctrl),1)
#define BCM53128_A0_WRITE_PCP_VALUE_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PCP_VALUE_CTRLr,&(r._pcp_value_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PCP_VALUE_CTRLr BCM53128_A0_PCP_VALUE_CTRLr
#define PCP_VALUE_CTRLr_SIZE BCM53128_A0_PCP_VALUE_CTRLr_SIZE
typedef BCM53128_A0_PCP_VALUE_CTRLr_t PCP_VALUE_CTRLr_t;
#define PCP_VALUE_CTRLr_CLR BCM53128_A0_PCP_VALUE_CTRLr_CLR
#define PCP_VALUE_CTRLr_SET BCM53128_A0_PCP_VALUE_CTRLr_SET
#define PCP_VALUE_CTRLr_GET BCM53128_A0_PCP_VALUE_CTRLr_GET
#define PCP_VALUE_CTRLr_CLASS_A_PCPf_GET BCM53128_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_GET
#define PCP_VALUE_CTRLr_CLASS_A_PCPf_SET BCM53128_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_SET
#define PCP_VALUE_CTRLr_CLASS_B_PCPf_GET BCM53128_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_GET
#define PCP_VALUE_CTRLr_CLASS_B_PCPf_SET BCM53128_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_SET
#define PCP_VALUE_CTRLr_RESERVEDf_GET BCM53128_A0_PCP_VALUE_CTRLr_RESERVEDf_GET
#define PCP_VALUE_CTRLr_RESERVEDf_SET BCM53128_A0_PCP_VALUE_CTRLr_RESERVEDf_SET
#define READ_PCP_VALUE_CTRLr BCM53128_A0_READ_PCP_VALUE_CTRLr
#define WRITE_PCP_VALUE_CTRLr BCM53128_A0_WRITE_PCP_VALUE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PCP_VALUE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PDMC_CR
 * BLOCKS:   SYS
 * DESC:     8051 Power Down Mode Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     PDMC_EN          Power down mode enableSet this bit to enable to 8051 power down mode.When this bit is set, the 8051's IDLE mode and STOP are supported, otherwise, the clk_cpuen and clk_peren have no effect on clock control.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_PDMC_CRr 0x0000ff30

#define BCM53128_A0_PDMC_CRr_SIZE 1

/*
 * This structure should be used to declare and program PDMC_CR.
 *
 */
typedef union BCM53128_A0_PDMC_CRr_s {
	uint32_t v[1];
	uint32_t pdmc_cr[1];
	uint32_t _pdmc_cr;
} BCM53128_A0_PDMC_CRr_t;

#define BCM53128_A0_PDMC_CRr_CLR(r) (r).pdmc_cr[0] = 0
#define BCM53128_A0_PDMC_CRr_SET(r,d) (r).pdmc_cr[0] = d
#define BCM53128_A0_PDMC_CRr_GET(r) (r).pdmc_cr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PDMC_CRr_PDMC_ENf_GET(r) (((r).pdmc_cr[0]) & 0x1)
#define BCM53128_A0_PDMC_CRr_PDMC_ENf_SET(r,f) (r).pdmc_cr[0]=(((r).pdmc_cr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_PDMC_CRr_RESERVEDf_GET(r) ((((r).pdmc_cr[0]) >> 1) & 0x7f)
#define BCM53128_A0_PDMC_CRr_RESERVEDf_SET(r,f) (r).pdmc_cr[0]=(((r).pdmc_cr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access PDMC_CR.
 *
 */
#define BCM53128_A0_READ_PDMC_CRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PDMC_CRr,(r._pdmc_cr),1)
#define BCM53128_A0_WRITE_PDMC_CRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PDMC_CRr,&(r._pdmc_cr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PDMC_CRr BCM53128_A0_PDMC_CRr
#define PDMC_CRr_SIZE BCM53128_A0_PDMC_CRr_SIZE
typedef BCM53128_A0_PDMC_CRr_t PDMC_CRr_t;
#define PDMC_CRr_CLR BCM53128_A0_PDMC_CRr_CLR
#define PDMC_CRr_SET BCM53128_A0_PDMC_CRr_SET
#define PDMC_CRr_GET BCM53128_A0_PDMC_CRr_GET
#define PDMC_CRr_PDMC_ENf_GET BCM53128_A0_PDMC_CRr_PDMC_ENf_GET
#define PDMC_CRr_PDMC_ENf_SET BCM53128_A0_PDMC_CRr_PDMC_ENf_SET
#define PDMC_CRr_RESERVEDf_GET BCM53128_A0_PDMC_CRr_RESERVEDf_GET
#define PDMC_CRr_RESERVEDf_SET BCM53128_A0_PDMC_CRr_RESERVEDf_SET
#define READ_PDMC_CRr BCM53128_A0_READ_PDMC_CRr
#define WRITE_PDMC_CRr BCM53128_A0_WRITE_PDMC_CRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PDMC_CRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PEAK_TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Peak Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TEMP_DATA   It keeps track the peak temperature monitor result since the last read.- It's the minimum code for the highest temperature since the last read.- After read, the register to be reset to 0x1FF.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53128_A0_PEAK_TEMP_MON_RESUr 0x00000f04

#define BCM53128_A0_PEAK_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TEMP_MON_RESU.
 *
 */
typedef union BCM53128_A0_PEAK_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t peak_temp_mon_resu[1];
	uint32_t _peak_temp_mon_resu;
} BCM53128_A0_PEAK_TEMP_MON_RESUr_t;

#define BCM53128_A0_PEAK_TEMP_MON_RESUr_CLR(r) (r).peak_temp_mon_resu[0] = 0
#define BCM53128_A0_PEAK_TEMP_MON_RESUr_SET(r,d) (r).peak_temp_mon_resu[0] = d
#define BCM53128_A0_PEAK_TEMP_MON_RESUr_GET(r) (r).peak_temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET(r) (((r).peak_temp_mon_resu[0]) & 0x1ff)
#define BCM53128_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).peak_temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM53128_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PEAK_TEMP_MON_RESU.
 *
 */
#define BCM53128_A0_READ_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PEAK_TEMP_MON_RESUr,(r._peak_temp_mon_resu),2)
#define BCM53128_A0_WRITE_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PEAK_TEMP_MON_RESUr,&(r._peak_temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TEMP_MON_RESUr BCM53128_A0_PEAK_TEMP_MON_RESUr
#define PEAK_TEMP_MON_RESUr_SIZE BCM53128_A0_PEAK_TEMP_MON_RESUr_SIZE
typedef BCM53128_A0_PEAK_TEMP_MON_RESUr_t PEAK_TEMP_MON_RESUr_t;
#define PEAK_TEMP_MON_RESUr_CLR BCM53128_A0_PEAK_TEMP_MON_RESUr_CLR
#define PEAK_TEMP_MON_RESUr_SET BCM53128_A0_PEAK_TEMP_MON_RESUr_SET
#define PEAK_TEMP_MON_RESUr_GET BCM53128_A0_PEAK_TEMP_MON_RESUr_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET BCM53128_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET BCM53128_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_GET BCM53128_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_SET BCM53128_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_PEAK_TEMP_MON_RESUr BCM53128_A0_READ_PEAK_TEMP_MON_RESUr
#define WRITE_PEAK_TEMP_MON_RESUr BCM53128_A0_WRITE_PEAK_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PEAK_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PHY_LED_FUNC
 * BLOCKS:   SYS
 * DESC:     PHY LED Control register
 * SIZE:     8
 * FIELDS:
 *     PHY_LED_FUNC0    This field is the extension of LED Func 0.Bit 3: PHYLED4 of LED Function 0Bit 2: PHYLED3 of LED Function 0Bit 1: PHYLED2 of LED Function 0Bit 0: PHYLED1 of LED Function 0default :LEDMODE = 00/01 : 4'h8LEDMODE = 10/11 : 4'h0
 *     PHY_LED_FUNC1    This field is the extension of LED Func 1.Bit 7: PHYLED4 of LED Function 1Bit 6: PHYLED3 of LED Function 1Bit 5: PHYLED2 of LED Function 1Bit 4: PHYLED1 of LED Function 1default :LEDMODE = 00/01 : 4'h8LEDMODE = 10/11 : 4'h0
 *
 ******************************************************************************/
#define BCM53128_A0_PHY_LED_FUNCr 0x0000001d

#define BCM53128_A0_PHY_LED_FUNCr_SIZE 1

/*
 * This structure should be used to declare and program PHY_LED_FUNC.
 *
 */
typedef union BCM53128_A0_PHY_LED_FUNCr_s {
	uint32_t v[1];
	uint32_t phy_led_func[1];
	uint32_t _phy_led_func;
} BCM53128_A0_PHY_LED_FUNCr_t;

#define BCM53128_A0_PHY_LED_FUNCr_CLR(r) (r).phy_led_func[0] = 0
#define BCM53128_A0_PHY_LED_FUNCr_SET(r,d) (r).phy_led_func[0] = d
#define BCM53128_A0_PHY_LED_FUNCr_GET(r) (r).phy_led_func[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC0f_GET(r) (((r).phy_led_func[0]) & 0xf)
#define BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC0f_SET(r,f) (r).phy_led_func[0]=(((r).phy_led_func[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC1f_GET(r) ((((r).phy_led_func[0]) >> 4) & 0xf)
#define BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC1f_SET(r,f) (r).phy_led_func[0]=(((r).phy_led_func[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PHY_LED_FUNC.
 *
 */
#define BCM53128_A0_READ_PHY_LED_FUNCr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PHY_LED_FUNCr,(r._phy_led_func),1)
#define BCM53128_A0_WRITE_PHY_LED_FUNCr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PHY_LED_FUNCr,&(r._phy_led_func),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_LED_FUNCr BCM53128_A0_PHY_LED_FUNCr
#define PHY_LED_FUNCr_SIZE BCM53128_A0_PHY_LED_FUNCr_SIZE
typedef BCM53128_A0_PHY_LED_FUNCr_t PHY_LED_FUNCr_t;
#define PHY_LED_FUNCr_CLR BCM53128_A0_PHY_LED_FUNCr_CLR
#define PHY_LED_FUNCr_SET BCM53128_A0_PHY_LED_FUNCr_SET
#define PHY_LED_FUNCr_GET BCM53128_A0_PHY_LED_FUNCr_GET
#define PHY_LED_FUNCr_PHY_LED_FUNC0f_GET BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC0f_GET
#define PHY_LED_FUNCr_PHY_LED_FUNC0f_SET BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC0f_SET
#define PHY_LED_FUNCr_PHY_LED_FUNC1f_GET BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC1f_GET
#define PHY_LED_FUNCr_PHY_LED_FUNC1f_SET BCM53128_A0_PHY_LED_FUNCr_PHY_LED_FUNC1f_SET
#define READ_PHY_LED_FUNCr BCM53128_A0_READ_PHY_LED_FUNCr
#define WRITE_PHY_LED_FUNCr BCM53128_A0_WRITE_PHY_LED_FUNCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PHY_LED_FUNCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PHY_PWR_DOWN
 * BLOCKS:   SYS
 * DESC:     PHY Power Down Mode Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     EXT_PWR_DOWN_PHY_EN PHY PWR_DOWN mode settingSet this bit to enable ext_pwrdown of GPHY. When ext_pwrdown is applied the clocks will be shutdown. The statemachines will remain in the same state before the clocks will be shutdown. Once user want to come out of the ext_pwrdown mode then user need to apply soft reset so the statemachines will be reset and link will establish again.bit[7:0]: port7-0.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_PHY_PWR_DOWNr 0x0000004c

#define BCM53128_A0_PHY_PWR_DOWNr_SIZE 2

/*
 * This structure should be used to declare and program PHY_PWR_DOWN.
 *
 */
typedef union BCM53128_A0_PHY_PWR_DOWNr_s {
	uint32_t v[1];
	uint32_t phy_pwr_down[1];
	uint32_t _phy_pwr_down;
} BCM53128_A0_PHY_PWR_DOWNr_t;

#define BCM53128_A0_PHY_PWR_DOWNr_CLR(r) (r).phy_pwr_down[0] = 0
#define BCM53128_A0_PHY_PWR_DOWNr_SET(r,d) (r).phy_pwr_down[0] = d
#define BCM53128_A0_PHY_PWR_DOWNr_GET(r) (r).phy_pwr_down[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_GET(r) (((r).phy_pwr_down[0]) & 0xff)
#define BCM53128_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PHY_PWR_DOWNr_RESERVEDf_GET(r) ((((r).phy_pwr_down[0]) >> 8) & 0xff)
#define BCM53128_A0_PHY_PWR_DOWNr_RESERVEDf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PHY_PWR_DOWN.
 *
 */
#define BCM53128_A0_READ_PHY_PWR_DOWNr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PHY_PWR_DOWNr,(r._phy_pwr_down),2)
#define BCM53128_A0_WRITE_PHY_PWR_DOWNr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PHY_PWR_DOWNr,&(r._phy_pwr_down),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_PWR_DOWNr BCM53128_A0_PHY_PWR_DOWNr
#define PHY_PWR_DOWNr_SIZE BCM53128_A0_PHY_PWR_DOWNr_SIZE
typedef BCM53128_A0_PHY_PWR_DOWNr_t PHY_PWR_DOWNr_t;
#define PHY_PWR_DOWNr_CLR BCM53128_A0_PHY_PWR_DOWNr_CLR
#define PHY_PWR_DOWNr_SET BCM53128_A0_PHY_PWR_DOWNr_SET
#define PHY_PWR_DOWNr_GET BCM53128_A0_PHY_PWR_DOWNr_GET
#define PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_GET BCM53128_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_GET
#define PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_SET BCM53128_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_SET
#define PHY_PWR_DOWNr_RESERVEDf_GET BCM53128_A0_PHY_PWR_DOWNr_RESERVEDf_GET
#define PHY_PWR_DOWNr_RESERVEDf_SET BCM53128_A0_PHY_PWR_DOWNr_RESERVEDf_SET
#define READ_PHY_PWR_DOWNr BCM53128_A0_READ_PHY_PWR_DOWNr
#define WRITE_PHY_PWR_DOWNr BCM53128_A0_WRITE_PHY_PWR_DOWNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PHY_PWR_DOWNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PLL_CTRL
 * BLOCKS:   SYS
 * DESC:     PLL Control Register
 * SIZE:     8
 * FIELDS:
 *     PLL_LP_CTRL      PLL power down controlbit[4]: PLL global power downbit[3]: clock comparator power downbit[2]: channel 1 power downbit[1]: channel 2 power downbit[0]: channel 3 power down
 *     RESERVED         RESERVED
 *     PLL_DRESET       PLL digital resetSoftware must reset the analog/digital circuit when releasing PLL global power down or releasing PLL clock comparator power down.
 *     PLL_ARESET       PLL analog resetSoftware must reset the analog/digital circuit when releasing PLL global power down or releasing PLL clock comparator power down.
 *
 ******************************************************************************/
#define BCM53128_A0_PLL_CTRLr 0x000000dc

#define BCM53128_A0_PLL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PLL_CTRL.
 *
 */
typedef union BCM53128_A0_PLL_CTRLr_s {
	uint32_t v[1];
	uint32_t pll_ctrl[1];
	uint32_t _pll_ctrl;
} BCM53128_A0_PLL_CTRLr_t;

#define BCM53128_A0_PLL_CTRLr_CLR(r) (r).pll_ctrl[0] = 0
#define BCM53128_A0_PLL_CTRLr_SET(r,d) (r).pll_ctrl[0] = d
#define BCM53128_A0_PLL_CTRLr_GET(r) (r).pll_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PLL_CTRLr_PLL_LP_CTRLf_GET(r) (((r).pll_ctrl[0]) & 0x1f)
#define BCM53128_A0_PLL_CTRLr_PLL_LP_CTRLf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53128_A0_PLL_CTRLr_RESERVEDf_GET(r) ((((r).pll_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_PLL_CTRLr_RESERVEDf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_PLL_CTRLr_PLL_DRESETf_GET(r) ((((r).pll_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_PLL_CTRLr_PLL_DRESETf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_PLL_CTRLr_PLL_ARESETf_GET(r) ((((r).pll_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_PLL_CTRLr_PLL_ARESETf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_CTRL.
 *
 */
#define BCM53128_A0_READ_PLL_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PLL_CTRLr,(r._pll_ctrl),1)
#define BCM53128_A0_WRITE_PLL_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PLL_CTRLr,&(r._pll_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRLr BCM53128_A0_PLL_CTRLr
#define PLL_CTRLr_SIZE BCM53128_A0_PLL_CTRLr_SIZE
typedef BCM53128_A0_PLL_CTRLr_t PLL_CTRLr_t;
#define PLL_CTRLr_CLR BCM53128_A0_PLL_CTRLr_CLR
#define PLL_CTRLr_SET BCM53128_A0_PLL_CTRLr_SET
#define PLL_CTRLr_GET BCM53128_A0_PLL_CTRLr_GET
#define PLL_CTRLr_PLL_LP_CTRLf_GET BCM53128_A0_PLL_CTRLr_PLL_LP_CTRLf_GET
#define PLL_CTRLr_PLL_LP_CTRLf_SET BCM53128_A0_PLL_CTRLr_PLL_LP_CTRLf_SET
#define PLL_CTRLr_RESERVEDf_GET BCM53128_A0_PLL_CTRLr_RESERVEDf_GET
#define PLL_CTRLr_RESERVEDf_SET BCM53128_A0_PLL_CTRLr_RESERVEDf_SET
#define PLL_CTRLr_PLL_DRESETf_GET BCM53128_A0_PLL_CTRLr_PLL_DRESETf_GET
#define PLL_CTRLr_PLL_DRESETf_SET BCM53128_A0_PLL_CTRLr_PLL_DRESETf_SET
#define PLL_CTRLr_PLL_ARESETf_GET BCM53128_A0_PLL_CTRLr_PLL_ARESETf_GET
#define PLL_CTRLr_PLL_ARESETf_SET BCM53128_A0_PLL_CTRLr_PLL_ARESETf_SET
#define READ_PLL_CTRLr BCM53128_A0_READ_PLL_CTRLr
#define WRITE_PLL_CTRLr BCM53128_A0_WRITE_PLL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PLL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PLL_FREQ_SEL
 * BLOCKS:   SYS
 * DESC:     PLL System Clock Frequency Selector Register
 * SIZE:     32
 * FIELDS:
 *     CLKSET_KEY1      This field must be written with 0x68
 *     CLKSET_KEY2      This field must be written with 0xEA
 *     CLKSET_MDIV      Writting this field changes PLL channel 2's clock frequency for system clock, Valid when bit 32 is set to 1.The frequence is determined by this formula.F=VCO/CLKSET_MDIV, where VCO is fixed to 1Ghz, the divider should be larger than or equal to 9(decimal).
 *     RESERVED         Reserved, must be written with all zeros.
 *     CLKSET_RST       Setting this bit to 1'b1 triggers a reset on PLL. Valid, when bit 31 is set to 1. Once the PLL reset is triggered, it requires 500us for PLL to lock. To modify system clock at run time a reset to PLL is not required.
 *     CLKSET_SPI       Setting this bit to 1 enables frequency control of PLL channel 2(system clock).Note: This register is effective only full 32-bit is written. The followings are for Blackbird2 configuration,111Mhz : 32'hC0_09_EA_68100Mhz : 32'hC0_0A_EA_68(Default)90Mhz : 32'hC0_0B_EA_6883.33Mhz : 32'hC0_0C_EA_68(bit30, CLKSET_RST is optional)
 *
 ******************************************************************************/
#define BCM53128_A0_PLL_FREQ_SELr 0x000000d8

#define BCM53128_A0_PLL_FREQ_SELr_SIZE 4

/*
 * This structure should be used to declare and program PLL_FREQ_SEL.
 *
 */
typedef union BCM53128_A0_PLL_FREQ_SELr_s {
	uint32_t v[1];
	uint32_t pll_freq_sel[1];
	uint32_t _pll_freq_sel;
} BCM53128_A0_PLL_FREQ_SELr_t;

#define BCM53128_A0_PLL_FREQ_SELr_CLR(r) (r).pll_freq_sel[0] = 0
#define BCM53128_A0_PLL_FREQ_SELr_SET(r,d) (r).pll_freq_sel[0] = d
#define BCM53128_A0_PLL_FREQ_SELr_GET(r) (r).pll_freq_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY1f_GET(r) (((r).pll_freq_sel[0]) & 0xff)
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY1f_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY2f_GET(r) ((((r).pll_freq_sel[0]) >> 8) & 0xff)
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY2f_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_MDIVf_GET(r) ((((r).pll_freq_sel[0]) >> 16) & 0xff)
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_MDIVf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53128_A0_PLL_FREQ_SELr_RESERVEDf_GET(r) ((((r).pll_freq_sel[0]) >> 24) & 0x3f)
#define BCM53128_A0_PLL_FREQ_SELr_RESERVEDf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_RSTf_GET(r) ((((r).pll_freq_sel[0]) >> 30) & 0x1)
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_RSTf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_SPIf_GET(r) ((((r).pll_freq_sel[0]) >> 31) & 0x1)
#define BCM53128_A0_PLL_FREQ_SELr_CLKSET_SPIf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PLL_FREQ_SEL.
 *
 */
#define BCM53128_A0_READ_PLL_FREQ_SELr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PLL_FREQ_SELr,(r._pll_freq_sel),4)
#define BCM53128_A0_WRITE_PLL_FREQ_SELr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PLL_FREQ_SELr,&(r._pll_freq_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_FREQ_SELr BCM53128_A0_PLL_FREQ_SELr
#define PLL_FREQ_SELr_SIZE BCM53128_A0_PLL_FREQ_SELr_SIZE
typedef BCM53128_A0_PLL_FREQ_SELr_t PLL_FREQ_SELr_t;
#define PLL_FREQ_SELr_CLR BCM53128_A0_PLL_FREQ_SELr_CLR
#define PLL_FREQ_SELr_SET BCM53128_A0_PLL_FREQ_SELr_SET
#define PLL_FREQ_SELr_GET BCM53128_A0_PLL_FREQ_SELr_GET
#define PLL_FREQ_SELr_CLKSET_KEY1f_GET BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY1f_GET
#define PLL_FREQ_SELr_CLKSET_KEY1f_SET BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY1f_SET
#define PLL_FREQ_SELr_CLKSET_KEY2f_GET BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY2f_GET
#define PLL_FREQ_SELr_CLKSET_KEY2f_SET BCM53128_A0_PLL_FREQ_SELr_CLKSET_KEY2f_SET
#define PLL_FREQ_SELr_CLKSET_MDIVf_GET BCM53128_A0_PLL_FREQ_SELr_CLKSET_MDIVf_GET
#define PLL_FREQ_SELr_CLKSET_MDIVf_SET BCM53128_A0_PLL_FREQ_SELr_CLKSET_MDIVf_SET
#define PLL_FREQ_SELr_RESERVEDf_GET BCM53128_A0_PLL_FREQ_SELr_RESERVEDf_GET
#define PLL_FREQ_SELr_RESERVEDf_SET BCM53128_A0_PLL_FREQ_SELr_RESERVEDf_SET
#define PLL_FREQ_SELr_CLKSET_RSTf_GET BCM53128_A0_PLL_FREQ_SELr_CLKSET_RSTf_GET
#define PLL_FREQ_SELr_CLKSET_RSTf_SET BCM53128_A0_PLL_FREQ_SELr_CLKSET_RSTf_SET
#define PLL_FREQ_SELr_CLKSET_SPIf_GET BCM53128_A0_PLL_FREQ_SELr_CLKSET_SPIf_GET
#define PLL_FREQ_SELr_CLKSET_SPIf_SET BCM53128_A0_PLL_FREQ_SELr_CLKSET_SPIf_SET
#define READ_PLL_FREQ_SELr BCM53128_A0_READ_PLL_FREQ_SELr
#define WRITE_PLL_FREQ_SELr BCM53128_A0_WRITE_PLL_FREQ_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PLL_FREQ_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PLL_STS
 * BLOCKS:   SYS
 * DESC:     PLL Status Register
 * SIZE:     8
 * FIELDS:
 *     PLL_LOCK         This bit indicates the PLL lock status
 *     GPHY_PLL_LOCK_0  port0-port3 qual-PHY PLL lock status
 *     GPHY_PLL_LOCK_1  port4-port7 qual-PHY PLL lock status
 *     RESERVED         RESERVED
 *
 ******************************************************************************/
#define BCM53128_A0_PLL_STSr 0x000000dd

#define BCM53128_A0_PLL_STSr_SIZE 1

/*
 * This structure should be used to declare and program PLL_STS.
 *
 */
typedef union BCM53128_A0_PLL_STSr_s {
	uint32_t v[1];
	uint32_t pll_sts[1];
	uint32_t _pll_sts;
} BCM53128_A0_PLL_STSr_t;

#define BCM53128_A0_PLL_STSr_CLR(r) (r).pll_sts[0] = 0
#define BCM53128_A0_PLL_STSr_SET(r,d) (r).pll_sts[0] = d
#define BCM53128_A0_PLL_STSr_GET(r) (r).pll_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PLL_STSr_PLL_LOCKf_GET(r) (((r).pll_sts[0]) & 0x1)
#define BCM53128_A0_PLL_STSr_PLL_LOCKf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_0f_GET(r) ((((r).pll_sts[0]) >> 1) & 0x1)
#define BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_0f_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_1f_GET(r) ((((r).pll_sts[0]) >> 2) & 0x1)
#define BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_1f_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_PLL_STSr_RESERVEDf_GET(r) ((((r).pll_sts[0]) >> 3) & 0x1f)
#define BCM53128_A0_PLL_STSr_RESERVEDf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PLL_STS.
 *
 */
#define BCM53128_A0_READ_PLL_STSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PLL_STSr,(r._pll_sts),1)
#define BCM53128_A0_WRITE_PLL_STSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PLL_STSr,&(r._pll_sts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_STSr BCM53128_A0_PLL_STSr
#define PLL_STSr_SIZE BCM53128_A0_PLL_STSr_SIZE
typedef BCM53128_A0_PLL_STSr_t PLL_STSr_t;
#define PLL_STSr_CLR BCM53128_A0_PLL_STSr_CLR
#define PLL_STSr_SET BCM53128_A0_PLL_STSr_SET
#define PLL_STSr_GET BCM53128_A0_PLL_STSr_GET
#define PLL_STSr_PLL_LOCKf_GET BCM53128_A0_PLL_STSr_PLL_LOCKf_GET
#define PLL_STSr_PLL_LOCKf_SET BCM53128_A0_PLL_STSr_PLL_LOCKf_SET
#define PLL_STSr_GPHY_PLL_LOCK_0f_GET BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_0f_GET
#define PLL_STSr_GPHY_PLL_LOCK_0f_SET BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_0f_SET
#define PLL_STSr_GPHY_PLL_LOCK_1f_GET BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_1f_GET
#define PLL_STSr_GPHY_PLL_LOCK_1f_SET BCM53128_A0_PLL_STSr_GPHY_PLL_LOCK_1f_SET
#define PLL_STSr_RESERVEDf_GET BCM53128_A0_PLL_STSr_RESERVEDf_GET
#define PLL_STSr_RESERVEDf_SET BCM53128_A0_PLL_STSr_RESERVEDf_SET
#define READ_PLL_STSr BCM53128_A0_READ_PLL_STSr
#define WRITE_PLL_STSr BCM53128_A0_WRITE_PLL_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PLL_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PLL_TEST_CTRL_I
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register I Registrer (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     PLL_SW_RST       
 *     PLL_TEST_EN      
 *     PLL_TEST_SEL     
 *     PLL_VCO_RNG      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PLL_TEST_CTRL_Ir 0x000000d0

#define BCM53128_A0_PLL_TEST_CTRL_Ir_SIZE 1

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_I.
 *
 */
typedef union BCM53128_A0_PLL_TEST_CTRL_Ir_s {
	uint32_t v[1];
	uint32_t pll_test_ctrl_i[1];
	uint32_t _pll_test_ctrl_i;
} BCM53128_A0_PLL_TEST_CTRL_Ir_t;

#define BCM53128_A0_PLL_TEST_CTRL_Ir_CLR(r) (r).pll_test_ctrl_i[0] = 0
#define BCM53128_A0_PLL_TEST_CTRL_Ir_SET(r,d) (r).pll_test_ctrl_i[0] = d
#define BCM53128_A0_PLL_TEST_CTRL_Ir_GET(r) (r).pll_test_ctrl_i[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET(r) (((r).pll_test_ctrl_i[0]) & 0x1)
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 1) & 0x1)
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 2) & 0x7)
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 5) & 0x3)
#define BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53128_A0_PLL_TEST_CTRL_Ir_RESERVEDf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 7) & 0x1)
#define BCM53128_A0_PLL_TEST_CTRL_Ir_RESERVEDf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_TEST_CTRL_I.
 *
 */
#define BCM53128_A0_READ_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_read(u,BCM53128_A0_PLL_TEST_CTRL_Ir,(r._pll_test_ctrl_i),1)
#define BCM53128_A0_WRITE_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_write(u,BCM53128_A0_PLL_TEST_CTRL_Ir,&(r._pll_test_ctrl_i),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_Ir BCM53128_A0_PLL_TEST_CTRL_Ir
#define PLL_TEST_CTRL_Ir_SIZE BCM53128_A0_PLL_TEST_CTRL_Ir_SIZE
typedef BCM53128_A0_PLL_TEST_CTRL_Ir_t PLL_TEST_CTRL_Ir_t;
#define PLL_TEST_CTRL_Ir_CLR BCM53128_A0_PLL_TEST_CTRL_Ir_CLR
#define PLL_TEST_CTRL_Ir_SET BCM53128_A0_PLL_TEST_CTRL_Ir_SET
#define PLL_TEST_CTRL_Ir_GET BCM53128_A0_PLL_TEST_CTRL_Ir_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET BCM53128_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET
#define PLL_TEST_CTRL_Ir_RESERVEDf_GET BCM53128_A0_PLL_TEST_CTRL_Ir_RESERVEDf_GET
#define PLL_TEST_CTRL_Ir_RESERVEDf_SET BCM53128_A0_PLL_TEST_CTRL_Ir_RESERVEDf_SET
#define READ_PLL_TEST_CTRL_Ir BCM53128_A0_READ_PLL_TEST_CTRL_Ir
#define WRITE_PLL_TEST_CTRL_Ir BCM53128_A0_WRITE_PLL_TEST_CTRL_Ir

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PLL_TEST_CTRL_Ir'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PLL_TEST_CTRL_II
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register II Registrer (Not2Release)
 * SIZE:     48
 * FIELDS:
 *     PLL_TEST_CTRL    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PLL_TEST_CTRL_IIr 0x000000d1

#define BCM53128_A0_PLL_TEST_CTRL_IIr_SIZE 6

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_II.
 *
 */
typedef union BCM53128_A0_PLL_TEST_CTRL_IIr_s {
	uint32_t v[2];
	uint32_t pll_test_ctrl_ii[2];
	uint32_t _pll_test_ctrl_ii;
} BCM53128_A0_PLL_TEST_CTRL_IIr_t;

#define BCM53128_A0_PLL_TEST_CTRL_IIr_CLR(r) CDK_MEMSET(&((r)._pll_test_ctrl_ii), 0, sizeof(BCM53128_A0_PLL_TEST_CTRL_IIr_t))
#define BCM53128_A0_PLL_TEST_CTRL_IIr_SET(r,i,d) (r).pll_test_ctrl_ii[i] = d
#define BCM53128_A0_PLL_TEST_CTRL_IIr_GET(r,i) (r).pll_test_ctrl_ii[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET(r,a) cdk_field_get((r).pll_test_ctrl_ii,0,37,a)
#define BCM53128_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET(r,a) cdk_field_set((r).pll_test_ctrl_ii,0,37,a)
#define BCM53128_A0_PLL_TEST_CTRL_IIr_RESERVEDf_GET(r) ((((r).pll_test_ctrl_ii[1]) >> 6) & 0x3ff)
#define BCM53128_A0_PLL_TEST_CTRL_IIr_RESERVEDf_SET(r,f) (r).pll_test_ctrl_ii[1]=(((r).pll_test_ctrl_ii[1] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access PLL_TEST_CTRL_II.
 *
 */
#define BCM53128_A0_READ_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PLL_TEST_CTRL_IIr,(r._pll_test_ctrl_ii),6)
#define BCM53128_A0_WRITE_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PLL_TEST_CTRL_IIr,&(r._pll_test_ctrl_ii),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_IIr BCM53128_A0_PLL_TEST_CTRL_IIr
#define PLL_TEST_CTRL_IIr_SIZE BCM53128_A0_PLL_TEST_CTRL_IIr_SIZE
typedef BCM53128_A0_PLL_TEST_CTRL_IIr_t PLL_TEST_CTRL_IIr_t;
#define PLL_TEST_CTRL_IIr_CLR BCM53128_A0_PLL_TEST_CTRL_IIr_CLR
#define PLL_TEST_CTRL_IIr_SET BCM53128_A0_PLL_TEST_CTRL_IIr_SET
#define PLL_TEST_CTRL_IIr_GET BCM53128_A0_PLL_TEST_CTRL_IIr_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET BCM53128_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET BCM53128_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET
#define PLL_TEST_CTRL_IIr_RESERVEDf_GET BCM53128_A0_PLL_TEST_CTRL_IIr_RESERVEDf_GET
#define PLL_TEST_CTRL_IIr_RESERVEDf_SET BCM53128_A0_PLL_TEST_CTRL_IIr_RESERVEDf_SET
#define READ_PLL_TEST_CTRL_IIr BCM53128_A0_READ_PLL_TEST_CTRL_IIr
#define WRITE_PLL_TEST_CTRL_IIr BCM53128_A0_WRITE_PLL_TEST_CTRL_IIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PLL_TEST_CTRL_IIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PN_PCP2TC
 * BLOCKS:   CPIC GPIC0
 * DESC:     Port N(0~7) PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PN_PCP2TCr 0x00003010

#define BCM53128_A0_PN_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program PN_PCP2TC.
 *
 */
typedef union BCM53128_A0_PN_PCP2TCr_s {
	uint32_t v[1];
	uint32_t pn_pcp2tc[1];
	uint32_t _pn_pcp2tc;
} BCM53128_A0_PN_PCP2TCr_t;

#define BCM53128_A0_PN_PCP2TCr_CLR(r) (r).pn_pcp2tc[0] = 0
#define BCM53128_A0_PN_PCP2TCr_SET(r,d) (r).pn_pcp2tc[0] = d
#define BCM53128_A0_PN_PCP2TCr_GET(r) (r).pn_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).pn_pcp2tc[0]) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 3) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 6) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 9) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 12) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 15) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 18) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 21) & 0x7)
#define BCM53128_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_PN_PCP2TCr_RESERVEDf_GET(r) ((((r).pn_pcp2tc[0]) >> 24) & 0xff)
#define BCM53128_A0_PN_PCP2TCr_RESERVEDf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PN_PCP2TC.
 *
 */
#define BCM53128_A0_READ_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PN_PCP2TCr,(r._pn_pcp2tc),4)
#define BCM53128_A0_WRITE_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PN_PCP2TCr,&(r._pn_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_PCP2TCr BCM53128_A0_PN_PCP2TCr
#define PN_PCP2TCr_SIZE BCM53128_A0_PN_PCP2TCr_SIZE
typedef BCM53128_A0_PN_PCP2TCr_t PN_PCP2TCr_t;
#define PN_PCP2TCr_CLR BCM53128_A0_PN_PCP2TCr_CLR
#define PN_PCP2TCr_SET BCM53128_A0_PN_PCP2TCr_SET
#define PN_PCP2TCr_GET BCM53128_A0_PN_PCP2TCr_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET
#define PN_PCP2TCr_TAG001_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET
#define PN_PCP2TCr_TAG001_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET
#define PN_PCP2TCr_TAG010_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET
#define PN_PCP2TCr_TAG010_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET
#define PN_PCP2TCr_TAG011_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET
#define PN_PCP2TCr_TAG011_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET
#define PN_PCP2TCr_TAG100_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET
#define PN_PCP2TCr_TAG100_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET
#define PN_PCP2TCr_TAG101_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET
#define PN_PCP2TCr_TAG101_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET
#define PN_PCP2TCr_TAG110_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET
#define PN_PCP2TCr_TAG110_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET
#define PN_PCP2TCr_TAG111_PRI_MAPf_GET BCM53128_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET
#define PN_PCP2TCr_TAG111_PRI_MAPf_SET BCM53128_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET
#define PN_PCP2TCr_RESERVEDf_GET BCM53128_A0_PN_PCP2TCr_RESERVEDf_GET
#define PN_PCP2TCr_RESERVEDf_SET BCM53128_A0_PN_PCP2TCr_RESERVEDf_SET
#define READ_PN_PCP2TCr BCM53128_A0_READ_PN_PCP2TCr
#define WRITE_PN_PCP2TCr BCM53128_A0_WRITE_PN_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PN_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT7_RGMII_CTL_GP
 * BLOCKS:   CPIC
 * DESC:     Port 7 RGMII Control register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_RGMII_DLL_TXC 1: RGMII tx_clk delayed timing mode(Delay Mode)0: RGMII tx_clk aligned timing mode(Normal Mode)
 *     EN_RGMII_DLL_RXC 1: clock delay by DLL is enabled(Delay Mode)0: clock delay by DLL is disabled (Normal Mode)
 *     BYPASS_2NS_DEL   1: bypass dll65_2ns_del IP0: use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affected by bit[0] and bit[1]{Bit[2], Bit[0]}= 2'b10, Bypass tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b11, use tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b0X, use tx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b10, Bypass rx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b11, use rx side dll65_2ns_del IP{Bit[2], Bit[1}= 2'b0X, use rx side dll65_2ns_del IP
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PORT7_RGMII_CTL_GPr 0x00000067

#define BCM53128_A0_PORT7_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program PORT7_RGMII_CTL_GP.
 *
 */
typedef union BCM53128_A0_PORT7_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t port7_rgmii_ctl_gp[1];
	uint32_t _port7_rgmii_ctl_gp;
} BCM53128_A0_PORT7_RGMII_CTL_GPr_t;

#define BCM53128_A0_PORT7_RGMII_CTL_GPr_CLR(r) (r).port7_rgmii_ctl_gp[0] = 0
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_SET(r,d) (r).port7_rgmii_ctl_gp[0] = d
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_GET(r) (r).port7_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET(r) (((r).port7_rgmii_ctl_gp[0]) & 0x1)
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET(r,f) (r).port7_rgmii_ctl_gp[0]=(((r).port7_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET(r) ((((r).port7_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET(r,f) (r).port7_rgmii_ctl_gp[0]=(((r).port7_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET(r) ((((r).port7_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET(r,f) (r).port7_rgmii_ctl_gp[0]=(((r).port7_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_RESERVEDf_GET(r) ((((r).port7_rgmii_ctl_gp[0]) >> 3) & 0x1f)
#define BCM53128_A0_PORT7_RGMII_CTL_GPr_RESERVEDf_SET(r,f) (r).port7_rgmii_ctl_gp[0]=(((r).port7_rgmii_ctl_gp[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PORT7_RGMII_CTL_GP.
 *
 */
#define BCM53128_A0_READ_PORT7_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PORT7_RGMII_CTL_GPr,(r._port7_rgmii_ctl_gp),1)
#define BCM53128_A0_WRITE_PORT7_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PORT7_RGMII_CTL_GPr,&(r._port7_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT7_RGMII_CTL_GPr BCM53128_A0_PORT7_RGMII_CTL_GPr
#define PORT7_RGMII_CTL_GPr_SIZE BCM53128_A0_PORT7_RGMII_CTL_GPr_SIZE
typedef BCM53128_A0_PORT7_RGMII_CTL_GPr_t PORT7_RGMII_CTL_GPr_t;
#define PORT7_RGMII_CTL_GPr_CLR BCM53128_A0_PORT7_RGMII_CTL_GPr_CLR
#define PORT7_RGMII_CTL_GPr_SET BCM53128_A0_PORT7_RGMII_CTL_GPr_SET
#define PORT7_RGMII_CTL_GPr_GET BCM53128_A0_PORT7_RGMII_CTL_GPr_GET
#define PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET
#define PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET
#define PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET
#define PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET BCM53128_A0_PORT7_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET
#define PORT7_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET BCM53128_A0_PORT7_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET
#define PORT7_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET BCM53128_A0_PORT7_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET
#define PORT7_RGMII_CTL_GPr_RESERVEDf_GET BCM53128_A0_PORT7_RGMII_CTL_GPr_RESERVEDf_GET
#define PORT7_RGMII_CTL_GPr_RESERVEDf_SET BCM53128_A0_PORT7_RGMII_CTL_GPr_RESERVEDf_SET
#define READ_PORT7_RGMII_CTL_GPr BCM53128_A0_READ_PORT7_RGMII_CTL_GPr
#define WRITE_PORT7_RGMII_CTL_GPr BCM53128_A0_WRITE_PORT7_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT7_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT7_RGMII_TIME_DLY_GP
 * BLOCKS:   CPIC
 * DESC:     PORT7 RGMII TIMING DELAY register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr 0x0000006f

#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program PORT7_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t port7_rgmii_time_dly_gp[1];
	uint32_t _port7_rgmii_time_dly_gp;
} BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_t;

#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_CLR(r) (r).port7_rgmii_time_dly_gp[0] = 0
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_SET(r,d) (r).port7_rgmii_time_dly_gp[0] = d
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_GET(r) (r).port7_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).port7_rgmii_time_dly_gp[0]) & 0xf)
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).port7_rgmii_time_dly_gp[0]=(((r).port7_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).port7_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).port7_rgmii_time_dly_gp[0]=(((r).port7_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).port7_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).port7_rgmii_time_dly_gp[0]=(((r).port7_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PORT7_RGMII_TIME_DLY_GP.
 *
 */
#define BCM53128_A0_READ_PORT7_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr,(r._port7_rgmii_time_dly_gp),1)
#define BCM53128_A0_WRITE_PORT7_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr,&(r._port7_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT7_RGMII_TIME_DLY_GPr BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr
#define PORT7_RGMII_TIME_DLY_GPr_SIZE BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_SIZE
typedef BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_t PORT7_RGMII_TIME_DLY_GPr_t;
#define PORT7_RGMII_TIME_DLY_GPr_CLR BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_CLR
#define PORT7_RGMII_TIME_DLY_GPr_SET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_SET
#define PORT7_RGMII_TIME_DLY_GPr_GET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_GET
#define PORT7_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define PORT7_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define PORT7_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define PORT7_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define PORT7_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define PORT7_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_PORT7_RGMII_TIME_DLY_GPr BCM53128_A0_READ_PORT7_RGMII_TIME_DLY_GPr
#define WRITE_PORT7_RGMII_TIME_DLY_GPr BCM53128_A0_WRITE_PORT7_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT7_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT_CROSS_CONNECT
 * BLOCKS:   SYS
 * DESC:     Port N Cross Connect Destination Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PCC_DEST         Per bit per port cross connect destination registerA bit mask corresponding to the physical ports on the chip.  When the receive port is configured to be in the cross connect mode, all received packets are forwarded to the destination port(s) that is specified by this register, regardless of the result of layer 2 lookup operation. Setting the corresponding bit to `1` indicates it is the destination port.Bit8: port 8.Bit0-7: port 0-7.
 *     RESERVED         Reserved
 *     PCC_ENABLE       Per port cross connect enable registerSetting this field to `1` enables the port to operate in cross connect mode.The port-cross-connect decision will overrule all the ARL decisions. Therefore MAC-LAND(MACDA=MACSA) packets which are originally dropped by ARL will pass through in port-cross-connect mode.However, dos-attack drop and ACL will still take effect when enabled.It is recommended that user should also configure disable-learning and preserve-ingress-packet-format registers for port-cross-connect function.
 *
 ******************************************************************************/
#define BCM53128_A0_PORT_CROSS_CONNECTr 0x00000490

#define BCM53128_A0_PORT_CROSS_CONNECTr_SIZE 2

/*
 * This structure should be used to declare and program PORT_CROSS_CONNECT.
 *
 */
typedef union BCM53128_A0_PORT_CROSS_CONNECTr_s {
	uint32_t v[1];
	uint32_t port_cross_connect[1];
	uint32_t _port_cross_connect;
} BCM53128_A0_PORT_CROSS_CONNECTr_t;

#define BCM53128_A0_PORT_CROSS_CONNECTr_CLR(r) (r).port_cross_connect[0] = 0
#define BCM53128_A0_PORT_CROSS_CONNECTr_SET(r,d) (r).port_cross_connect[0] = d
#define BCM53128_A0_PORT_CROSS_CONNECTr_GET(r) (r).port_cross_connect[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT_CROSS_CONNECTr_PCC_DESTf_GET(r) (((r).port_cross_connect[0]) & 0x1ff)
#define BCM53128_A0_PORT_CROSS_CONNECTr_PCC_DESTf_SET(r,f) (r).port_cross_connect[0]=(((r).port_cross_connect[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PORT_CROSS_CONNECTr_RESERVEDf_GET(r) ((((r).port_cross_connect[0]) >> 9) & 0x3f)
#define BCM53128_A0_PORT_CROSS_CONNECTr_RESERVEDf_SET(r,f) (r).port_cross_connect[0]=(((r).port_cross_connect[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM53128_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_GET(r) ((((r).port_cross_connect[0]) >> 15) & 0x1)
#define BCM53128_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_SET(r,f) (r).port_cross_connect[0]=(((r).port_cross_connect[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PORT_CROSS_CONNECT.
 *
 */
#define BCM53128_A0_READ_PORT_CROSS_CONNECTr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_PORT_CROSS_CONNECTr+(2*(i)),(r._port_cross_connect),2)
#define BCM53128_A0_WRITE_PORT_CROSS_CONNECTr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_PORT_CROSS_CONNECTr+(2*(i)),&(r._port_cross_connect),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_CROSS_CONNECTr BCM53128_A0_PORT_CROSS_CONNECTr
#define PORT_CROSS_CONNECTr_SIZE BCM53128_A0_PORT_CROSS_CONNECTr_SIZE
typedef BCM53128_A0_PORT_CROSS_CONNECTr_t PORT_CROSS_CONNECTr_t;
#define PORT_CROSS_CONNECTr_CLR BCM53128_A0_PORT_CROSS_CONNECTr_CLR
#define PORT_CROSS_CONNECTr_SET BCM53128_A0_PORT_CROSS_CONNECTr_SET
#define PORT_CROSS_CONNECTr_GET BCM53128_A0_PORT_CROSS_CONNECTr_GET
#define PORT_CROSS_CONNECTr_PCC_DESTf_GET BCM53128_A0_PORT_CROSS_CONNECTr_PCC_DESTf_GET
#define PORT_CROSS_CONNECTr_PCC_DESTf_SET BCM53128_A0_PORT_CROSS_CONNECTr_PCC_DESTf_SET
#define PORT_CROSS_CONNECTr_RESERVEDf_GET BCM53128_A0_PORT_CROSS_CONNECTr_RESERVEDf_GET
#define PORT_CROSS_CONNECTr_RESERVEDf_SET BCM53128_A0_PORT_CROSS_CONNECTr_RESERVEDf_SET
#define PORT_CROSS_CONNECTr_PCC_ENABLEf_GET BCM53128_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_GET
#define PORT_CROSS_CONNECTr_PCC_ENABLEf_SET BCM53128_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_SET
#define READ_PORT_CROSS_CONNECTr BCM53128_A0_READ_PORT_CROSS_CONNECTr
#define WRITE_PORT_CROSS_CONNECTr BCM53128_A0_WRITE_PORT_CROSS_CONNECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT_CROSS_CONNECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT_EAP_CON
 * BLOCKS:   GPIC0
 * DESC:     Port N EAP Configuration Registers
 * SIZE:     64
 * FIELDS:
 *     EAP_UNI_DA       EAP frame DA register.
 *     EAP_EN_UNI_DA    enable EAP frame with DA.
 *     EAP_BLK_MODE     00: Do not check EAP_BLK_MODE.01: Check EAP_BLK_MODE on ingress port, only frame defined in EAP_GCFG will be forwarded. Otherwise frame will be dropped.10: Reserved11: Check EAP_BLK_MODE on both ingress and egress port, only frame defined in EAP_GCFG will be forwarded. Especially, the forwarding process will check whether each egress port is at block mode or not.
 *     EAP_MODE         00 : Basic mode, do not check SA,01 : Reserved.10 : Extend mode, check SA & port-number. Drop if SA is unknown.11 : Simplified mode, check SA & port-number. Trap to mgnt-port if SA is unknown.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PORT_EAP_CONr 0x00004220

#define BCM53128_A0_PORT_EAP_CONr_SIZE 8

/*
 * This structure should be used to declare and program PORT_EAP_CON.
 *
 */
typedef union BCM53128_A0_PORT_EAP_CONr_s {
	uint32_t v[2];
	uint32_t port_eap_con[2];
	uint32_t _port_eap_con;
} BCM53128_A0_PORT_EAP_CONr_t;

#define BCM53128_A0_PORT_EAP_CONr_CLR(r) CDK_MEMSET(&((r)._port_eap_con), 0, sizeof(BCM53128_A0_PORT_EAP_CONr_t))
#define BCM53128_A0_PORT_EAP_CONr_SET(r,i,d) (r).port_eap_con[i] = d
#define BCM53128_A0_PORT_EAP_CONr_GET(r,i) (r).port_eap_con[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_con,0,47,a)
#define BCM53128_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_con,0,47,a)
#define BCM53128_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET(r) ((((r).port_eap_con[1]) >> 16) & 0x1)
#define BCM53128_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET(r) ((((r).port_eap_con[1]) >> 17) & 0x3)
#define BCM53128_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53128_A0_PORT_EAP_CONr_EAP_MODEf_GET(r) ((((r).port_eap_con[1]) >> 19) & 0x3)
#define BCM53128_A0_PORT_EAP_CONr_EAP_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53128_A0_PORT_EAP_CONr_RESERVEDf_GET(r) ((((r).port_eap_con[1]) >> 21) & 0x7ff)
#define BCM53128_A0_PORT_EAP_CONr_RESERVEDf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORT_EAP_CON.
 *
 */
#define BCM53128_A0_READ_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PORT_EAP_CONr,(r._port_eap_con),8)
#define BCM53128_A0_WRITE_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PORT_EAP_CONr,&(r._port_eap_con),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_CONr BCM53128_A0_PORT_EAP_CONr
#define PORT_EAP_CONr_SIZE BCM53128_A0_PORT_EAP_CONr_SIZE
typedef BCM53128_A0_PORT_EAP_CONr_t PORT_EAP_CONr_t;
#define PORT_EAP_CONr_CLR BCM53128_A0_PORT_EAP_CONr_CLR
#define PORT_EAP_CONr_SET BCM53128_A0_PORT_EAP_CONr_SET
#define PORT_EAP_CONr_GET BCM53128_A0_PORT_EAP_CONr_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_GET BCM53128_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_SET BCM53128_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_GET BCM53128_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_SET BCM53128_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_BLK_MODEf_GET BCM53128_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET
#define PORT_EAP_CONr_EAP_BLK_MODEf_SET BCM53128_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET
#define PORT_EAP_CONr_EAP_MODEf_GET BCM53128_A0_PORT_EAP_CONr_EAP_MODEf_GET
#define PORT_EAP_CONr_EAP_MODEf_SET BCM53128_A0_PORT_EAP_CONr_EAP_MODEf_SET
#define PORT_EAP_CONr_RESERVEDf_GET BCM53128_A0_PORT_EAP_CONr_RESERVEDf_GET
#define PORT_EAP_CONr_RESERVEDf_SET BCM53128_A0_PORT_EAP_CONr_RESERVEDf_SET
#define READ_PORT_EAP_CONr BCM53128_A0_READ_PORT_EAP_CONr
#define WRITE_PORT_EAP_CONr BCM53128_A0_WRITE_PORT_EAP_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT_EAP_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT_ERC_CON
 * BLOCKS:   CPIC GPIC0
 * DESC:     Port N Egress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNT          Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 500K bytes
 *     EGRESS_RC_EN     Egress Rate control Enable(Absolute Bit Rate).
 *     PORT_ERC_CON_RSRV2 Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PORT_ERC_CONr 0x00004180

#define BCM53128_A0_PORT_ERC_CONr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON.
 *
 */
typedef union BCM53128_A0_PORT_ERC_CONr_s {
	uint32_t v[1];
	uint32_t port_erc_con[1];
	uint32_t _port_erc_con;
} BCM53128_A0_PORT_ERC_CONr_t;

#define BCM53128_A0_PORT_ERC_CONr_CLR(r) (r).port_erc_con[0] = 0
#define BCM53128_A0_PORT_ERC_CONr_SET(r,d) (r).port_erc_con[0] = d
#define BCM53128_A0_PORT_ERC_CONr_GET(r) (r).port_erc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT_ERC_CONr_REF_CNTf_GET(r) (((r).port_erc_con[0]) & 0xff)
#define BCM53128_A0_PORT_ERC_CONr_REF_CNTf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con[0]) >> 8) & 0x7)
#define BCM53128_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53128_A0_PORT_ERC_CONr_EGRESS_RC_ENf_GET(r) ((((r).port_erc_con[0]) >> 11) & 0x1)
#define BCM53128_A0_PORT_ERC_CONr_EGRESS_RC_ENf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET(r) ((((r).port_erc_con[0]) >> 12) & 0xf)
#define BCM53128_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON.
 *
 */
#define BCM53128_A0_READ_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PORT_ERC_CONr,(r._port_erc_con),2)
#define BCM53128_A0_WRITE_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PORT_ERC_CONr,&(r._port_erc_con),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CONr BCM53128_A0_PORT_ERC_CONr
#define PORT_ERC_CONr_SIZE BCM53128_A0_PORT_ERC_CONr_SIZE
typedef BCM53128_A0_PORT_ERC_CONr_t PORT_ERC_CONr_t;
#define PORT_ERC_CONr_CLR BCM53128_A0_PORT_ERC_CONr_CLR
#define PORT_ERC_CONr_SET BCM53128_A0_PORT_ERC_CONr_SET
#define PORT_ERC_CONr_GET BCM53128_A0_PORT_ERC_CONr_GET
#define PORT_ERC_CONr_REF_CNTf_GET BCM53128_A0_PORT_ERC_CONr_REF_CNTf_GET
#define PORT_ERC_CONr_REF_CNTf_SET BCM53128_A0_PORT_ERC_CONr_REF_CNTf_SET
#define PORT_ERC_CONr_BUCKET_SIZEf_GET BCM53128_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET
#define PORT_ERC_CONr_BUCKET_SIZEf_SET BCM53128_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET
#define PORT_ERC_CONr_EGRESS_RC_ENf_GET BCM53128_A0_PORT_ERC_CONr_EGRESS_RC_ENf_GET
#define PORT_ERC_CONr_EGRESS_RC_ENf_SET BCM53128_A0_PORT_ERC_CONr_EGRESS_RC_ENf_SET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET BCM53128_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET BCM53128_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET
#define READ_PORT_ERC_CONr BCM53128_A0_READ_PORT_ERC_CONr
#define WRITE_PORT_ERC_CONr BCM53128_A0_WRITE_PORT_ERC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT_ERC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT_ERC_CON_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Egress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNT          Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 500K bytes
 *     EGRESS_RC_EN     Egress Rate control Enable(Absolute Bit Rate).
 *     PORT_ERC_CON_RSRV2 Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PORT_ERC_CON_IMPr 0x00004190

#define BCM53128_A0_PORT_ERC_CON_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON_IMP.
 *
 */
typedef union BCM53128_A0_PORT_ERC_CON_IMPr_s {
	uint32_t v[1];
	uint32_t port_erc_con_imp[1];
	uint32_t _port_erc_con_imp;
} BCM53128_A0_PORT_ERC_CON_IMPr_t;

#define BCM53128_A0_PORT_ERC_CON_IMPr_CLR(r) (r).port_erc_con_imp[0] = 0
#define BCM53128_A0_PORT_ERC_CON_IMPr_SET(r,d) (r).port_erc_con_imp[0] = d
#define BCM53128_A0_PORT_ERC_CON_IMPr_GET(r) (r).port_erc_con_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT_ERC_CON_IMPr_REF_CNTf_GET(r) (((r).port_erc_con_imp[0]) & 0xff)
#define BCM53128_A0_PORT_ERC_CON_IMPr_REF_CNTf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con_imp[0]) >> 8) & 0x7)
#define BCM53128_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53128_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET(r) ((((r).port_erc_con_imp[0]) >> 11) & 0x1)
#define BCM53128_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET(r) ((((r).port_erc_con_imp[0]) >> 12) & 0xf)
#define BCM53128_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON_IMP.
 *
 */
#define BCM53128_A0_READ_PORT_ERC_CON_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PORT_ERC_CON_IMPr,(r._port_erc_con_imp),2)
#define BCM53128_A0_WRITE_PORT_ERC_CON_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PORT_ERC_CON_IMPr,&(r._port_erc_con_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CON_IMPr BCM53128_A0_PORT_ERC_CON_IMPr
#define PORT_ERC_CON_IMPr_SIZE BCM53128_A0_PORT_ERC_CON_IMPr_SIZE
typedef BCM53128_A0_PORT_ERC_CON_IMPr_t PORT_ERC_CON_IMPr_t;
#define PORT_ERC_CON_IMPr_CLR BCM53128_A0_PORT_ERC_CON_IMPr_CLR
#define PORT_ERC_CON_IMPr_SET BCM53128_A0_PORT_ERC_CON_IMPr_SET
#define PORT_ERC_CON_IMPr_GET BCM53128_A0_PORT_ERC_CON_IMPr_GET
#define PORT_ERC_CON_IMPr_REF_CNTf_GET BCM53128_A0_PORT_ERC_CON_IMPr_REF_CNTf_GET
#define PORT_ERC_CON_IMPr_REF_CNTf_SET BCM53128_A0_PORT_ERC_CON_IMPr_REF_CNTf_SET
#define PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET BCM53128_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET
#define PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET BCM53128_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET
#define PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET BCM53128_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET
#define PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET BCM53128_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET
#define PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET BCM53128_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET
#define PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET BCM53128_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET
#define READ_PORT_ERC_CON_IMPr BCM53128_A0_READ_PORT_ERC_CON_IMPr
#define WRITE_PORT_ERC_CON_IMPr BCM53128_A0_WRITE_PORT_ERC_CON_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT_ERC_CON_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT_VLAN_CTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     PORT N VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to '1' to enable forwarding to the egress port. Set '0' inhibit the forwarding.Bit 8: IMP port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PORT_VLAN_CTLr 0x00003100

#define BCM53128_A0_PORT_VLAN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL.
 *
 */
typedef union BCM53128_A0_PORT_VLAN_CTLr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl[1];
	uint32_t _port_vlan_ctl;
} BCM53128_A0_PORT_VLAN_CTLr_t;

#define BCM53128_A0_PORT_VLAN_CTLr_CLR(r) (r).port_vlan_ctl[0] = 0
#define BCM53128_A0_PORT_VLAN_CTLr_SET(r,d) (r).port_vlan_ctl[0] = d
#define BCM53128_A0_PORT_VLAN_CTLr_GET(r) (r).port_vlan_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl[0]) & 0x1ff)
#define BCM53128_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PORT_VLAN_CTLr_RESERVEDf_GET(r) ((((r).port_vlan_ctl[0]) >> 9) & 0x7f)
#define BCM53128_A0_PORT_VLAN_CTLr_RESERVEDf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL.
 *
 */
#define BCM53128_A0_READ_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PORT_VLAN_CTLr,(r._port_vlan_ctl),2)
#define BCM53128_A0_WRITE_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PORT_VLAN_CTLr,&(r._port_vlan_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTLr BCM53128_A0_PORT_VLAN_CTLr
#define PORT_VLAN_CTLr_SIZE BCM53128_A0_PORT_VLAN_CTLr_SIZE
typedef BCM53128_A0_PORT_VLAN_CTLr_t PORT_VLAN_CTLr_t;
#define PORT_VLAN_CTLr_CLR BCM53128_A0_PORT_VLAN_CTLr_CLR
#define PORT_VLAN_CTLr_SET BCM53128_A0_PORT_VLAN_CTLr_SET
#define PORT_VLAN_CTLr_GET BCM53128_A0_PORT_VLAN_CTLr_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET BCM53128_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET BCM53128_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTLr_RESERVEDf_GET BCM53128_A0_PORT_VLAN_CTLr_RESERVEDf_GET
#define PORT_VLAN_CTLr_RESERVEDf_SET BCM53128_A0_PORT_VLAN_CTLr_RESERVEDf_SET
#define READ_PORT_VLAN_CTLr BCM53128_A0_READ_PORT_VLAN_CTLr
#define WRITE_PORT_VLAN_CTLr BCM53128_A0_WRITE_PORT_VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT_VLAN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PORT_VLAN_CTL_IMP
 * BLOCKS:   CPIC
 * DESC:     PORT 8 VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to '1' to enable forwarding to the egress port. Set '0' inhibit the forwarding.Bit 8: IMP port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PORT_VLAN_CTL_IMPr 0x00003110

#define BCM53128_A0_PORT_VLAN_CTL_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL_IMP.
 *
 */
typedef union BCM53128_A0_PORT_VLAN_CTL_IMPr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl_imp[1];
	uint32_t _port_vlan_ctl_imp;
} BCM53128_A0_PORT_VLAN_CTL_IMPr_t;

#define BCM53128_A0_PORT_VLAN_CTL_IMPr_CLR(r) (r).port_vlan_ctl_imp[0] = 0
#define BCM53128_A0_PORT_VLAN_CTL_IMPr_SET(r,d) (r).port_vlan_ctl_imp[0] = d
#define BCM53128_A0_PORT_VLAN_CTL_IMPr_GET(r) (r).port_vlan_ctl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl_imp[0]) & 0x1ff)
#define BCM53128_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_GET(r) ((((r).port_vlan_ctl_imp[0]) >> 9) & 0x7f)
#define BCM53128_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL_IMP.
 *
 */
#define BCM53128_A0_READ_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PORT_VLAN_CTL_IMPr,(r._port_vlan_ctl_imp),2)
#define BCM53128_A0_WRITE_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PORT_VLAN_CTL_IMPr,&(r._port_vlan_ctl_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTL_IMPr BCM53128_A0_PORT_VLAN_CTL_IMPr
#define PORT_VLAN_CTL_IMPr_SIZE BCM53128_A0_PORT_VLAN_CTL_IMPr_SIZE
typedef BCM53128_A0_PORT_VLAN_CTL_IMPr_t PORT_VLAN_CTL_IMPr_t;
#define PORT_VLAN_CTL_IMPr_CLR BCM53128_A0_PORT_VLAN_CTL_IMPr_CLR
#define PORT_VLAN_CTL_IMPr_SET BCM53128_A0_PORT_VLAN_CTL_IMPr_SET
#define PORT_VLAN_CTL_IMPr_GET BCM53128_A0_PORT_VLAN_CTL_IMPr_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET BCM53128_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET BCM53128_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTL_IMPr_RESERVEDf_GET BCM53128_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_GET
#define PORT_VLAN_CTL_IMPr_RESERVEDf_SET BCM53128_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_SET
#define READ_PORT_VLAN_CTL_IMPr BCM53128_A0_READ_PORT_VLAN_CTL_IMPr
#define WRITE_PORT_VLAN_CTL_IMPr BCM53128_A0_WRITE_PORT_VLAN_CTL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PORT_VLAN_CTL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PRESERVE_PKT_FORMAT
 * BLOCKS:   SYS
 * DESC:      Preserve Ingress Packet format Control Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PRESERVE_PACKET_FORMAT Preserve Ingress packet format.This register is a per-port configuration. User should also set this register for the ingress and egress port which is in port-cross-connect mode.When enable, the ingress frame format is preserved without being affected by 1Q/double-tag normalization process on the ingress logic and tag/untag process on the egrss logici.e. untag in -- untag out	1Q/1p tag in -- 1Q/1p tag out	double tags in -- double tags out[8]: port8[7:0]: port7-port0However, the ingress logic can still insert time stamp if required.And if broadcom header enabled, the egress logic is still able to inserted broadcom header, and the ingress logic is able to remove broadcom header.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PRESERVE_PKT_FORMATr 0x00000022

#define BCM53128_A0_PRESERVE_PKT_FORMATr_SIZE 2

/*
 * This structure should be used to declare and program PRESERVE_PKT_FORMAT.
 *
 */
typedef union BCM53128_A0_PRESERVE_PKT_FORMATr_s {
	uint32_t v[1];
	uint32_t preserve_pkt_format[1];
	uint32_t _preserve_pkt_format;
} BCM53128_A0_PRESERVE_PKT_FORMATr_t;

#define BCM53128_A0_PRESERVE_PKT_FORMATr_CLR(r) (r).preserve_pkt_format[0] = 0
#define BCM53128_A0_PRESERVE_PKT_FORMATr_SET(r,d) (r).preserve_pkt_format[0] = d
#define BCM53128_A0_PRESERVE_PKT_FORMATr_GET(r) (r).preserve_pkt_format[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_GET(r) (((r).preserve_pkt_format[0]) & 0x1ff)
#define BCM53128_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_SET(r,f) (r).preserve_pkt_format[0]=(((r).preserve_pkt_format[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PRESERVE_PKT_FORMATr_RESERVEDf_GET(r) ((((r).preserve_pkt_format[0]) >> 9) & 0x7f)
#define BCM53128_A0_PRESERVE_PKT_FORMATr_RESERVEDf_SET(r,f) (r).preserve_pkt_format[0]=(((r).preserve_pkt_format[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PRESERVE_PKT_FORMAT.
 *
 */
#define BCM53128_A0_READ_PRESERVE_PKT_FORMATr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PRESERVE_PKT_FORMATr,(r._preserve_pkt_format),2)
#define BCM53128_A0_WRITE_PRESERVE_PKT_FORMATr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PRESERVE_PKT_FORMATr,&(r._preserve_pkt_format),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRESERVE_PKT_FORMATr BCM53128_A0_PRESERVE_PKT_FORMATr
#define PRESERVE_PKT_FORMATr_SIZE BCM53128_A0_PRESERVE_PKT_FORMATr_SIZE
typedef BCM53128_A0_PRESERVE_PKT_FORMATr_t PRESERVE_PKT_FORMATr_t;
#define PRESERVE_PKT_FORMATr_CLR BCM53128_A0_PRESERVE_PKT_FORMATr_CLR
#define PRESERVE_PKT_FORMATr_SET BCM53128_A0_PRESERVE_PKT_FORMATr_SET
#define PRESERVE_PKT_FORMATr_GET BCM53128_A0_PRESERVE_PKT_FORMATr_GET
#define PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_GET BCM53128_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_GET
#define PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_SET BCM53128_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_SET
#define PRESERVE_PKT_FORMATr_RESERVEDf_GET BCM53128_A0_PRESERVE_PKT_FORMATr_RESERVEDf_GET
#define PRESERVE_PKT_FORMATr_RESERVEDf_SET BCM53128_A0_PRESERVE_PKT_FORMATr_RESERVEDf_SET
#define READ_PRESERVE_PKT_FORMATr BCM53128_A0_READ_PRESERVE_PKT_FORMATr
#define WRITE_PRESERVE_PKT_FORMATr BCM53128_A0_WRITE_PRESERVE_PKT_FORMATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PRESERVE_PKT_FORMATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PROTECTED_SEL
 * BLOCKS:   SYS
 * DESC:     Protected Port Select Register
 * SIZE:     16
 * FIELDS:
 *     PORT_SEL         Protected Port Selection.When set, the Port will be the protected Port.Protected Ports will not be able to Transmit/Receive Frame to/from each other.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PROTECTED_SELr 0x00000024

#define BCM53128_A0_PROTECTED_SELr_SIZE 2

/*
 * This structure should be used to declare and program PROTECTED_SEL.
 *
 */
typedef union BCM53128_A0_PROTECTED_SELr_s {
	uint32_t v[1];
	uint32_t protected_sel[1];
	uint32_t _protected_sel;
} BCM53128_A0_PROTECTED_SELr_t;

#define BCM53128_A0_PROTECTED_SELr_CLR(r) (r).protected_sel[0] = 0
#define BCM53128_A0_PROTECTED_SELr_SET(r,d) (r).protected_sel[0] = d
#define BCM53128_A0_PROTECTED_SELr_GET(r) (r).protected_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PROTECTED_SELr_PORT_SELf_GET(r) (((r).protected_sel[0]) & 0x1ff)
#define BCM53128_A0_PROTECTED_SELr_PORT_SELf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_PROTECTED_SELr_RESERVEDf_GET(r) ((((r).protected_sel[0]) >> 9) & 0x7f)
#define BCM53128_A0_PROTECTED_SELr_RESERVEDf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PROTECTED_SEL.
 *
 */
#define BCM53128_A0_READ_PROTECTED_SELr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PROTECTED_SELr,(r._protected_sel),2)
#define BCM53128_A0_WRITE_PROTECTED_SELr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PROTECTED_SELr,&(r._protected_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTECTED_SELr BCM53128_A0_PROTECTED_SELr
#define PROTECTED_SELr_SIZE BCM53128_A0_PROTECTED_SELr_SIZE
typedef BCM53128_A0_PROTECTED_SELr_t PROTECTED_SELr_t;
#define PROTECTED_SELr_CLR BCM53128_A0_PROTECTED_SELr_CLR
#define PROTECTED_SELr_SET BCM53128_A0_PROTECTED_SELr_SET
#define PROTECTED_SELr_GET BCM53128_A0_PROTECTED_SELr_GET
#define PROTECTED_SELr_PORT_SELf_GET BCM53128_A0_PROTECTED_SELr_PORT_SELf_GET
#define PROTECTED_SELr_PORT_SELf_SET BCM53128_A0_PROTECTED_SELr_PORT_SELf_SET
#define PROTECTED_SELr_RESERVEDf_GET BCM53128_A0_PROTECTED_SELr_RESERVEDf_GET
#define PROTECTED_SELr_RESERVEDf_SET BCM53128_A0_PROTECTED_SELr_RESERVEDf_SET
#define READ_PROTECTED_SELr BCM53128_A0_READ_PROTECTED_SELr
#define WRITE_PROTECTED_SELr BCM53128_A0_WRITE_PROTECTED_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PROTECTED_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PRS_FIFO_DEBUG_CTRL
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     PRS_FIFO_DBG_CTRL Control the prs_fifo_debug bus muxing[3:2]'d0: slice 0'd1: slice 1'd2: slice 2'd3: slice 3[1:0]'d0: slice[63:0]'d1: slice[127:64]'d2: slice[191:128]'d3: {23'h0,ipv6_vld,ipv4_vld,slice[229:192]}
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr 0x00000870

#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_CTRL.
 *
 */
typedef union BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_s {
	uint32_t v[1];
	uint32_t prs_fifo_debug_ctrl[1];
	uint32_t _prs_fifo_debug_ctrl;
} BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_t;

#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_CLR(r) (r).prs_fifo_debug_ctrl[0] = 0
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_SET(r,d) (r).prs_fifo_debug_ctrl[0] = d
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_GET(r) (r).prs_fifo_debug_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET(r) (((r).prs_fifo_debug_ctrl[0]) & 0xf)
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET(r) ((((r).prs_fifo_debug_ctrl[0]) >> 4) & 0xf)
#define BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PRS_FIFO_DEBUG_CTRL.
 *
 */
#define BCM53128_A0_READ_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PRS_FIFO_DEBUG_CTRLr,(r._prs_fifo_debug_ctrl),1)
#define BCM53128_A0_WRITE_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PRS_FIFO_DEBUG_CTRLr,&(r._prs_fifo_debug_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_CTRLr BCM53128_A0_PRS_FIFO_DEBUG_CTRLr
#define PRS_FIFO_DEBUG_CTRLr_SIZE BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_SIZE
typedef BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_t PRS_FIFO_DEBUG_CTRLr_t;
#define PRS_FIFO_DEBUG_CTRLr_CLR BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_CLR
#define PRS_FIFO_DEBUG_CTRLr_SET BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_SET
#define PRS_FIFO_DEBUG_CTRLr_GET BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET
#define PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET
#define PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET BCM53128_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET
#define READ_PRS_FIFO_DEBUG_CTRLr BCM53128_A0_READ_PRS_FIFO_DEBUG_CTRLr
#define WRITE_PRS_FIFO_DEBUG_CTRLr BCM53128_A0_WRITE_PRS_FIFO_DEBUG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PRS_FIFO_DEBUG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  PRS_FIFO_DEBUG_DATA
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Data Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     PRS_FIFO_DBG_DATA Provide 64 bits prs_fifo debug bus data according to the PRS_FIFO_DBG_CTRL.
 *
 ******************************************************************************/
#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr 0x00000871

#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr_SIZE 8

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_DATA.
 *
 */
typedef union BCM53128_A0_PRS_FIFO_DEBUG_DATAr_s {
	uint32_t v[2];
	uint32_t prs_fifo_debug_data[2];
	uint32_t _prs_fifo_debug_data;
} BCM53128_A0_PRS_FIFO_DEBUG_DATAr_t;

#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr_CLR(r) CDK_MEMSET(&((r)._prs_fifo_debug_data), 0, sizeof(BCM53128_A0_PRS_FIFO_DEBUG_DATAr_t))
#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr_SET(r,i,d) (r).prs_fifo_debug_data[i] = d
#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr_GET(r,i) (r).prs_fifo_debug_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET(r,a) cdk_field_get((r).prs_fifo_debug_data,0,63,a)
#define BCM53128_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET(r,a) cdk_field_set((r).prs_fifo_debug_data,0,63,a)

/*
 * These macros can be used to access PRS_FIFO_DEBUG_DATA.
 *
 */
#define BCM53128_A0_READ_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PRS_FIFO_DEBUG_DATAr,(r._prs_fifo_debug_data),8)
#define BCM53128_A0_WRITE_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PRS_FIFO_DEBUG_DATAr,&(r._prs_fifo_debug_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_DATAr BCM53128_A0_PRS_FIFO_DEBUG_DATAr
#define PRS_FIFO_DEBUG_DATAr_SIZE BCM53128_A0_PRS_FIFO_DEBUG_DATAr_SIZE
typedef BCM53128_A0_PRS_FIFO_DEBUG_DATAr_t PRS_FIFO_DEBUG_DATAr_t;
#define PRS_FIFO_DEBUG_DATAr_CLR BCM53128_A0_PRS_FIFO_DEBUG_DATAr_CLR
#define PRS_FIFO_DEBUG_DATAr_SET BCM53128_A0_PRS_FIFO_DEBUG_DATAr_SET
#define PRS_FIFO_DEBUG_DATAr_GET BCM53128_A0_PRS_FIFO_DEBUG_DATAr_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET BCM53128_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET BCM53128_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET
#define READ_PRS_FIFO_DEBUG_DATAr BCM53128_A0_READ_PRS_FIFO_DEBUG_DATAr
#define WRITE_PRS_FIFO_DEBUG_DATAr BCM53128_A0_WRITE_PRS_FIFO_DEBUG_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PRS_FIFO_DEBUG_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts1024toMaxPktOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS1024TOMAXPKTOCTETSr 0x00002074

#define BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets[1];
	uint32_t _pkts1024tomaxpktoctets;
} BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).pkts1024tomaxpktoctets[0] = 0
#define BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).pkts1024tomaxpktoctets[0] = d
#define BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).pkts1024tomaxpktoctets[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets.
 *
 */
#define BCM53128_A0_READ_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PKTS1024TOMAXPKTOCTETSr,(r._pkts1024tomaxpktoctets),4)
#define BCM53128_A0_WRITE_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PKTS1024TOMAXPKTOCTETSr,&(r._pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETSr BCM53128_A0_PKTS1024TOMAXPKTOCTETSr
#define PKTS1024TOMAXPKTOCTETSr_SIZE BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_t PKTS1024TOMAXPKTOCTETSr_t;
#define PKTS1024TOMAXPKTOCTETSr_CLR BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_CLR
#define PKTS1024TOMAXPKTOCTETSr_SET BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_SET
#define PKTS1024TOMAXPKTOCTETSr_GET BCM53128_A0_PKTS1024TOMAXPKTOCTETSr_GET
#define READ_PKTS1024TOMAXPKTOCTETSr BCM53128_A0_READ_PKTS1024TOMAXPKTOCTETSr
#define WRITE_PKTS1024TOMAXPKTOCTETSr BCM53128_A0_WRITE_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts1024toMaxPktOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr 0x00002874

#define BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets_IMP.
 *
 */
typedef union BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets_imp[1];
	uint32_t _pkts1024tomaxpktoctets_imp;
} BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_t;

#define BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_CLR(r) (r).pkts1024tomaxpktoctets_imp[0] = 0
#define BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SET(r,d) (r).pkts1024tomaxpktoctets_imp[0] = d
#define BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_GET(r) (r).pkts1024tomaxpktoctets_imp[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets_IMP.
 *
 */
#define BCM53128_A0_READ_PKTS1024TOMAXPKTOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr,(r._pkts1024tomaxpktoctets_imp),4)
#define BCM53128_A0_WRITE_PKTS1024TOMAXPKTOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr,&(r._pkts1024tomaxpktoctets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETS_IMPr BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr
#define PKTS1024TOMAXPKTOCTETS_IMPr_SIZE BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SIZE
typedef BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_t PKTS1024TOMAXPKTOCTETS_IMPr_t;
#define PKTS1024TOMAXPKTOCTETS_IMPr_CLR BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_CLR
#define PKTS1024TOMAXPKTOCTETS_IMPr_SET BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SET
#define PKTS1024TOMAXPKTOCTETS_IMPr_GET BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr_GET
#define READ_PKTS1024TOMAXPKTOCTETS_IMPr BCM53128_A0_READ_PKTS1024TOMAXPKTOCTETS_IMPr
#define WRITE_PKTS1024TOMAXPKTOCTETS_IMPr BCM53128_A0_WRITE_PKTS1024TOMAXPKTOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS1024TOMAXPKTOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts128to255Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS128TO255OCTETSr 0x00002068

#define BCM53128_A0_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets.
 *
 */
typedef union BCM53128_A0_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets[1];
	uint32_t _pkts128to255octets;
} BCM53128_A0_PKTS128TO255OCTETSr_t;

#define BCM53128_A0_PKTS128TO255OCTETSr_CLR(r) (r).pkts128to255octets[0] = 0
#define BCM53128_A0_PKTS128TO255OCTETSr_SET(r,d) (r).pkts128to255octets[0] = d
#define BCM53128_A0_PKTS128TO255OCTETSr_GET(r) (r).pkts128to255octets[0]


/*
 * These macros can be used to access Pkts128to255Octets.
 *
 */
#define BCM53128_A0_READ_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PKTS128TO255OCTETSr,(r._pkts128to255octets),4)
#define BCM53128_A0_WRITE_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PKTS128TO255OCTETSr,&(r._pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETSr BCM53128_A0_PKTS128TO255OCTETSr
#define PKTS128TO255OCTETSr_SIZE BCM53128_A0_PKTS128TO255OCTETSr_SIZE
typedef BCM53128_A0_PKTS128TO255OCTETSr_t PKTS128TO255OCTETSr_t;
#define PKTS128TO255OCTETSr_CLR BCM53128_A0_PKTS128TO255OCTETSr_CLR
#define PKTS128TO255OCTETSr_SET BCM53128_A0_PKTS128TO255OCTETSr_SET
#define PKTS128TO255OCTETSr_GET BCM53128_A0_PKTS128TO255OCTETSr_GET
#define READ_PKTS128TO255OCTETSr BCM53128_A0_READ_PKTS128TO255OCTETSr
#define WRITE_PKTS128TO255OCTETSr BCM53128_A0_WRITE_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts128to255Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS128TO255OCTETS_IMPr 0x00002868

#define BCM53128_A0_PKTS128TO255OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets_IMP.
 *
 */
typedef union BCM53128_A0_PKTS128TO255OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets_imp[1];
	uint32_t _pkts128to255octets_imp;
} BCM53128_A0_PKTS128TO255OCTETS_IMPr_t;

#define BCM53128_A0_PKTS128TO255OCTETS_IMPr_CLR(r) (r).pkts128to255octets_imp[0] = 0
#define BCM53128_A0_PKTS128TO255OCTETS_IMPr_SET(r,d) (r).pkts128to255octets_imp[0] = d
#define BCM53128_A0_PKTS128TO255OCTETS_IMPr_GET(r) (r).pkts128to255octets_imp[0]


/*
 * These macros can be used to access Pkts128to255Octets_IMP.
 *
 */
#define BCM53128_A0_READ_PKTS128TO255OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PKTS128TO255OCTETS_IMPr,(r._pkts128to255octets_imp),4)
#define BCM53128_A0_WRITE_PKTS128TO255OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PKTS128TO255OCTETS_IMPr,&(r._pkts128to255octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETS_IMPr BCM53128_A0_PKTS128TO255OCTETS_IMPr
#define PKTS128TO255OCTETS_IMPr_SIZE BCM53128_A0_PKTS128TO255OCTETS_IMPr_SIZE
typedef BCM53128_A0_PKTS128TO255OCTETS_IMPr_t PKTS128TO255OCTETS_IMPr_t;
#define PKTS128TO255OCTETS_IMPr_CLR BCM53128_A0_PKTS128TO255OCTETS_IMPr_CLR
#define PKTS128TO255OCTETS_IMPr_SET BCM53128_A0_PKTS128TO255OCTETS_IMPr_SET
#define PKTS128TO255OCTETS_IMPr_GET BCM53128_A0_PKTS128TO255OCTETS_IMPr_GET
#define READ_PKTS128TO255OCTETS_IMPr BCM53128_A0_READ_PKTS128TO255OCTETS_IMPr
#define WRITE_PKTS128TO255OCTETS_IMPr BCM53128_A0_WRITE_PKTS128TO255OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS128TO255OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts256to511Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS256TO511OCTETSr 0x0000206c

#define BCM53128_A0_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets.
 *
 */
typedef union BCM53128_A0_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets[1];
	uint32_t _pkts256to511octets;
} BCM53128_A0_PKTS256TO511OCTETSr_t;

#define BCM53128_A0_PKTS256TO511OCTETSr_CLR(r) (r).pkts256to511octets[0] = 0
#define BCM53128_A0_PKTS256TO511OCTETSr_SET(r,d) (r).pkts256to511octets[0] = d
#define BCM53128_A0_PKTS256TO511OCTETSr_GET(r) (r).pkts256to511octets[0]


/*
 * These macros can be used to access Pkts256to511Octets.
 *
 */
#define BCM53128_A0_READ_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PKTS256TO511OCTETSr,(r._pkts256to511octets),4)
#define BCM53128_A0_WRITE_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PKTS256TO511OCTETSr,&(r._pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETSr BCM53128_A0_PKTS256TO511OCTETSr
#define PKTS256TO511OCTETSr_SIZE BCM53128_A0_PKTS256TO511OCTETSr_SIZE
typedef BCM53128_A0_PKTS256TO511OCTETSr_t PKTS256TO511OCTETSr_t;
#define PKTS256TO511OCTETSr_CLR BCM53128_A0_PKTS256TO511OCTETSr_CLR
#define PKTS256TO511OCTETSr_SET BCM53128_A0_PKTS256TO511OCTETSr_SET
#define PKTS256TO511OCTETSr_GET BCM53128_A0_PKTS256TO511OCTETSr_GET
#define READ_PKTS256TO511OCTETSr BCM53128_A0_READ_PKTS256TO511OCTETSr
#define WRITE_PKTS256TO511OCTETSr BCM53128_A0_WRITE_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts256to511Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS256TO511OCTETS_IMPr 0x0000286c

#define BCM53128_A0_PKTS256TO511OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets_IMP.
 *
 */
typedef union BCM53128_A0_PKTS256TO511OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets_imp[1];
	uint32_t _pkts256to511octets_imp;
} BCM53128_A0_PKTS256TO511OCTETS_IMPr_t;

#define BCM53128_A0_PKTS256TO511OCTETS_IMPr_CLR(r) (r).pkts256to511octets_imp[0] = 0
#define BCM53128_A0_PKTS256TO511OCTETS_IMPr_SET(r,d) (r).pkts256to511octets_imp[0] = d
#define BCM53128_A0_PKTS256TO511OCTETS_IMPr_GET(r) (r).pkts256to511octets_imp[0]


/*
 * These macros can be used to access Pkts256to511Octets_IMP.
 *
 */
#define BCM53128_A0_READ_PKTS256TO511OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PKTS256TO511OCTETS_IMPr,(r._pkts256to511octets_imp),4)
#define BCM53128_A0_WRITE_PKTS256TO511OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PKTS256TO511OCTETS_IMPr,&(r._pkts256to511octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETS_IMPr BCM53128_A0_PKTS256TO511OCTETS_IMPr
#define PKTS256TO511OCTETS_IMPr_SIZE BCM53128_A0_PKTS256TO511OCTETS_IMPr_SIZE
typedef BCM53128_A0_PKTS256TO511OCTETS_IMPr_t PKTS256TO511OCTETS_IMPr_t;
#define PKTS256TO511OCTETS_IMPr_CLR BCM53128_A0_PKTS256TO511OCTETS_IMPr_CLR
#define PKTS256TO511OCTETS_IMPr_SET BCM53128_A0_PKTS256TO511OCTETS_IMPr_SET
#define PKTS256TO511OCTETS_IMPr_GET BCM53128_A0_PKTS256TO511OCTETS_IMPr_GET
#define READ_PKTS256TO511OCTETS_IMPr BCM53128_A0_READ_PKTS256TO511OCTETS_IMPr
#define WRITE_PKTS256TO511OCTETS_IMPr BCM53128_A0_WRITE_PKTS256TO511OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS256TO511OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts512to1023Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS512TO1023OCTETSr 0x00002070

#define BCM53128_A0_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets.
 *
 */
typedef union BCM53128_A0_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets[1];
	uint32_t _pkts512to1023octets;
} BCM53128_A0_PKTS512TO1023OCTETSr_t;

#define BCM53128_A0_PKTS512TO1023OCTETSr_CLR(r) (r).pkts512to1023octets[0] = 0
#define BCM53128_A0_PKTS512TO1023OCTETSr_SET(r,d) (r).pkts512to1023octets[0] = d
#define BCM53128_A0_PKTS512TO1023OCTETSr_GET(r) (r).pkts512to1023octets[0]


/*
 * These macros can be used to access Pkts512to1023Octets.
 *
 */
#define BCM53128_A0_READ_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PKTS512TO1023OCTETSr,(r._pkts512to1023octets),4)
#define BCM53128_A0_WRITE_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PKTS512TO1023OCTETSr,&(r._pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETSr BCM53128_A0_PKTS512TO1023OCTETSr
#define PKTS512TO1023OCTETSr_SIZE BCM53128_A0_PKTS512TO1023OCTETSr_SIZE
typedef BCM53128_A0_PKTS512TO1023OCTETSr_t PKTS512TO1023OCTETSr_t;
#define PKTS512TO1023OCTETSr_CLR BCM53128_A0_PKTS512TO1023OCTETSr_CLR
#define PKTS512TO1023OCTETSr_SET BCM53128_A0_PKTS512TO1023OCTETSr_SET
#define PKTS512TO1023OCTETSr_GET BCM53128_A0_PKTS512TO1023OCTETSr_GET
#define READ_PKTS512TO1023OCTETSr BCM53128_A0_READ_PKTS512TO1023OCTETSr
#define WRITE_PKTS512TO1023OCTETSr BCM53128_A0_WRITE_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts512to1023Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS512TO1023OCTETS_IMPr 0x00002870

#define BCM53128_A0_PKTS512TO1023OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets_IMP.
 *
 */
typedef union BCM53128_A0_PKTS512TO1023OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets_imp[1];
	uint32_t _pkts512to1023octets_imp;
} BCM53128_A0_PKTS512TO1023OCTETS_IMPr_t;

#define BCM53128_A0_PKTS512TO1023OCTETS_IMPr_CLR(r) (r).pkts512to1023octets_imp[0] = 0
#define BCM53128_A0_PKTS512TO1023OCTETS_IMPr_SET(r,d) (r).pkts512to1023octets_imp[0] = d
#define BCM53128_A0_PKTS512TO1023OCTETS_IMPr_GET(r) (r).pkts512to1023octets_imp[0]


/*
 * These macros can be used to access Pkts512to1023Octets_IMP.
 *
 */
#define BCM53128_A0_READ_PKTS512TO1023OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PKTS512TO1023OCTETS_IMPr,(r._pkts512to1023octets_imp),4)
#define BCM53128_A0_WRITE_PKTS512TO1023OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PKTS512TO1023OCTETS_IMPr,&(r._pkts512to1023octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETS_IMPr BCM53128_A0_PKTS512TO1023OCTETS_IMPr
#define PKTS512TO1023OCTETS_IMPr_SIZE BCM53128_A0_PKTS512TO1023OCTETS_IMPr_SIZE
typedef BCM53128_A0_PKTS512TO1023OCTETS_IMPr_t PKTS512TO1023OCTETS_IMPr_t;
#define PKTS512TO1023OCTETS_IMPr_CLR BCM53128_A0_PKTS512TO1023OCTETS_IMPr_CLR
#define PKTS512TO1023OCTETS_IMPr_SET BCM53128_A0_PKTS512TO1023OCTETS_IMPr_SET
#define PKTS512TO1023OCTETS_IMPr_GET BCM53128_A0_PKTS512TO1023OCTETS_IMPr_GET
#define READ_PKTS512TO1023OCTETS_IMPr BCM53128_A0_READ_PKTS512TO1023OCTETS_IMPr
#define WRITE_PKTS512TO1023OCTETS_IMPr BCM53128_A0_WRITE_PKTS512TO1023OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS512TO1023OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts64Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS64OCTETSr 0x00002060

#define BCM53128_A0_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets.
 *
 */
typedef union BCM53128_A0_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts64octets[1];
	uint32_t _pkts64octets;
} BCM53128_A0_PKTS64OCTETSr_t;

#define BCM53128_A0_PKTS64OCTETSr_CLR(r) (r).pkts64octets[0] = 0
#define BCM53128_A0_PKTS64OCTETSr_SET(r,d) (r).pkts64octets[0] = d
#define BCM53128_A0_PKTS64OCTETSr_GET(r) (r).pkts64octets[0]


/*
 * These macros can be used to access Pkts64Octets.
 *
 */
#define BCM53128_A0_READ_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PKTS64OCTETSr,(r._pkts64octets),4)
#define BCM53128_A0_WRITE_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PKTS64OCTETSr,&(r._pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETSr BCM53128_A0_PKTS64OCTETSr
#define PKTS64OCTETSr_SIZE BCM53128_A0_PKTS64OCTETSr_SIZE
typedef BCM53128_A0_PKTS64OCTETSr_t PKTS64OCTETSr_t;
#define PKTS64OCTETSr_CLR BCM53128_A0_PKTS64OCTETSr_CLR
#define PKTS64OCTETSr_SET BCM53128_A0_PKTS64OCTETSr_SET
#define PKTS64OCTETSr_GET BCM53128_A0_PKTS64OCTETSr_GET
#define READ_PKTS64OCTETSr BCM53128_A0_READ_PKTS64OCTETSr
#define WRITE_PKTS64OCTETSr BCM53128_A0_WRITE_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts64Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS64OCTETS_IMPr 0x00002860

#define BCM53128_A0_PKTS64OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets_IMP.
 *
 */
typedef union BCM53128_A0_PKTS64OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts64octets_imp[1];
	uint32_t _pkts64octets_imp;
} BCM53128_A0_PKTS64OCTETS_IMPr_t;

#define BCM53128_A0_PKTS64OCTETS_IMPr_CLR(r) (r).pkts64octets_imp[0] = 0
#define BCM53128_A0_PKTS64OCTETS_IMPr_SET(r,d) (r).pkts64octets_imp[0] = d
#define BCM53128_A0_PKTS64OCTETS_IMPr_GET(r) (r).pkts64octets_imp[0]


/*
 * These macros can be used to access Pkts64Octets_IMP.
 *
 */
#define BCM53128_A0_READ_PKTS64OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PKTS64OCTETS_IMPr,(r._pkts64octets_imp),4)
#define BCM53128_A0_WRITE_PKTS64OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PKTS64OCTETS_IMPr,&(r._pkts64octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETS_IMPr BCM53128_A0_PKTS64OCTETS_IMPr
#define PKTS64OCTETS_IMPr_SIZE BCM53128_A0_PKTS64OCTETS_IMPr_SIZE
typedef BCM53128_A0_PKTS64OCTETS_IMPr_t PKTS64OCTETS_IMPr_t;
#define PKTS64OCTETS_IMPr_CLR BCM53128_A0_PKTS64OCTETS_IMPr_CLR
#define PKTS64OCTETS_IMPr_SET BCM53128_A0_PKTS64OCTETS_IMPr_SET
#define PKTS64OCTETS_IMPr_GET BCM53128_A0_PKTS64OCTETS_IMPr_GET
#define READ_PKTS64OCTETS_IMPr BCM53128_A0_READ_PKTS64OCTETS_IMPr
#define WRITE_PKTS64OCTETS_IMPr BCM53128_A0_WRITE_PKTS64OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS64OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts65to127Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS65TO127OCTETSr 0x00002064

#define BCM53128_A0_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets.
 *
 */
typedef union BCM53128_A0_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets[1];
	uint32_t _pkts65to127octets;
} BCM53128_A0_PKTS65TO127OCTETSr_t;

#define BCM53128_A0_PKTS65TO127OCTETSr_CLR(r) (r).pkts65to127octets[0] = 0
#define BCM53128_A0_PKTS65TO127OCTETSr_SET(r,d) (r).pkts65to127octets[0] = d
#define BCM53128_A0_PKTS65TO127OCTETSr_GET(r) (r).pkts65to127octets[0]


/*
 * These macros can be used to access Pkts65to127Octets.
 *
 */
#define BCM53128_A0_READ_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_PKTS65TO127OCTETSr,(r._pkts65to127octets),4)
#define BCM53128_A0_WRITE_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_PKTS65TO127OCTETSr,&(r._pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETSr BCM53128_A0_PKTS65TO127OCTETSr
#define PKTS65TO127OCTETSr_SIZE BCM53128_A0_PKTS65TO127OCTETSr_SIZE
typedef BCM53128_A0_PKTS65TO127OCTETSr_t PKTS65TO127OCTETSr_t;
#define PKTS65TO127OCTETSr_CLR BCM53128_A0_PKTS65TO127OCTETSr_CLR
#define PKTS65TO127OCTETSr_SET BCM53128_A0_PKTS65TO127OCTETSr_SET
#define PKTS65TO127OCTETSr_GET BCM53128_A0_PKTS65TO127OCTETSr_GET
#define READ_PKTS65TO127OCTETSr BCM53128_A0_READ_PKTS65TO127OCTETSr
#define WRITE_PKTS65TO127OCTETSr BCM53128_A0_WRITE_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  Pkts65to127Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_PKTS65TO127OCTETS_IMPr 0x00002864

#define BCM53128_A0_PKTS65TO127OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets_IMP.
 *
 */
typedef union BCM53128_A0_PKTS65TO127OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets_imp[1];
	uint32_t _pkts65to127octets_imp;
} BCM53128_A0_PKTS65TO127OCTETS_IMPr_t;

#define BCM53128_A0_PKTS65TO127OCTETS_IMPr_CLR(r) (r).pkts65to127octets_imp[0] = 0
#define BCM53128_A0_PKTS65TO127OCTETS_IMPr_SET(r,d) (r).pkts65to127octets_imp[0] = d
#define BCM53128_A0_PKTS65TO127OCTETS_IMPr_GET(r) (r).pkts65to127octets_imp[0]


/*
 * These macros can be used to access Pkts65to127Octets_IMP.
 *
 */
#define BCM53128_A0_READ_PKTS65TO127OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_PKTS65TO127OCTETS_IMPr,(r._pkts65to127octets_imp),4)
#define BCM53128_A0_WRITE_PKTS65TO127OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_PKTS65TO127OCTETS_IMPr,&(r._pkts65to127octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETS_IMPr BCM53128_A0_PKTS65TO127OCTETS_IMPr
#define PKTS65TO127OCTETS_IMPr_SIZE BCM53128_A0_PKTS65TO127OCTETS_IMPr_SIZE
typedef BCM53128_A0_PKTS65TO127OCTETS_IMPr_t PKTS65TO127OCTETS_IMPr_t;
#define PKTS65TO127OCTETS_IMPr_CLR BCM53128_A0_PKTS65TO127OCTETS_IMPr_CLR
#define PKTS65TO127OCTETS_IMPr_SET BCM53128_A0_PKTS65TO127OCTETS_IMPr_SET
#define PKTS65TO127OCTETS_IMPr_GET BCM53128_A0_PKTS65TO127OCTETS_IMPr_GET
#define READ_PKTS65TO127OCTETS_IMPr BCM53128_A0_READ_PKTS65TO127OCTETS_IMPr
#define WRITE_PKTS65TO127OCTETS_IMPr BCM53128_A0_WRITE_PKTS65TO127OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_PKTS65TO127OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_1P_EN
 * BLOCKS:   SYS
 * DESC:     QoS 802.1P Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_1P_EN        Enable 802.1p priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_1P_ENr 0x00003004

#define BCM53128_A0_QOS_1P_ENr_SIZE 2

/*
 * This structure should be used to declare and program QOS_1P_EN.
 *
 */
typedef union BCM53128_A0_QOS_1P_ENr_s {
	uint32_t v[1];
	uint32_t qos_1p_en[1];
	uint32_t _qos_1p_en;
} BCM53128_A0_QOS_1P_ENr_t;

#define BCM53128_A0_QOS_1P_ENr_CLR(r) (r).qos_1p_en[0] = 0
#define BCM53128_A0_QOS_1P_ENr_SET(r,d) (r).qos_1p_en[0] = d
#define BCM53128_A0_QOS_1P_ENr_GET(r) (r).qos_1p_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_1P_ENr_QOS_1P_ENf_GET(r) (((r).qos_1p_en[0]) & 0x1ff)
#define BCM53128_A0_QOS_1P_ENr_QOS_1P_ENf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_QOS_1P_ENr_RESERVEDf_GET(r) ((((r).qos_1p_en[0]) >> 9) & 0x7f)
#define BCM53128_A0_QOS_1P_ENr_RESERVEDf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_1P_EN.
 *
 */
#define BCM53128_A0_READ_QOS_1P_ENr(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_1P_ENr,(r._qos_1p_en),2)
#define BCM53128_A0_WRITE_QOS_1P_ENr(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_1P_ENr,&(r._qos_1p_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P_ENr BCM53128_A0_QOS_1P_ENr
#define QOS_1P_ENr_SIZE BCM53128_A0_QOS_1P_ENr_SIZE
typedef BCM53128_A0_QOS_1P_ENr_t QOS_1P_ENr_t;
#define QOS_1P_ENr_CLR BCM53128_A0_QOS_1P_ENr_CLR
#define QOS_1P_ENr_SET BCM53128_A0_QOS_1P_ENr_SET
#define QOS_1P_ENr_GET BCM53128_A0_QOS_1P_ENr_GET
#define QOS_1P_ENr_QOS_1P_ENf_GET BCM53128_A0_QOS_1P_ENr_QOS_1P_ENf_GET
#define QOS_1P_ENr_QOS_1P_ENf_SET BCM53128_A0_QOS_1P_ENr_QOS_1P_ENf_SET
#define QOS_1P_ENr_RESERVEDf_GET BCM53128_A0_QOS_1P_ENr_RESERVEDf_GET
#define QOS_1P_ENr_RESERVEDf_SET BCM53128_A0_QOS_1P_ENr_RESERVEDf_SET
#define READ_QOS_1P_ENr BCM53128_A0_READ_QOS_1P_ENr
#define WRITE_QOS_1P_ENr BCM53128_A0_WRITE_QOS_1P_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_1P_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_DIFF_DSCP0
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 0 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_000000  DiffServ DSCP== 000000 to Priority ID map Register.
 *     PRI_DSCP_000001  DiffServ DSCP== 000001 to Priority ID map Register.
 *     PRI_DSCP_000010  DiffServ DSCP== 000010 to Priority ID map Register.
 *     PRI_DSCP_000011  DiffServ DSCP== 000011 to Priority ID map Register.
 *     PRI_DSCP_000100  DiffServ DSCP== 000100 to Priority ID map Register.
 *     PRI_DSCP_000101  DiffServ DSCP== 000101 to Priority ID map Register.
 *     PRI_DSCP_000110  DiffServ DSCP== 000110 to Priority ID map Register.
 *     PRI_DSCP_000111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_001000  DiffServ DSCP== 001000 to Priority ID map Register.
 *     PRI_DSCP_001001  DiffServ DSCP== 001001 to Priority ID map Register.
 *     PRI_DSCP_001010  DiffServ DSCP== 001010 to Priority ID map Register.
 *     PRI_DSCP_001011  DiffServ DSCP== 001011 to Priority ID map Register.
 *     PRI_DSCP_001100  DiffServ DSCP== 001100 to Priority ID map Register.
 *     PRI_DSCP_001101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_001110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_001111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_DIFF_DSCP0r 0x00003040

#define BCM53128_A0_QOS_DIFF_DSCP0r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP0.
 *
 */
typedef union BCM53128_A0_QOS_DIFF_DSCP0r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp0[2];
	uint32_t _qos_diff_dscp0;
} BCM53128_A0_QOS_DIFF_DSCP0r_t;

#define BCM53128_A0_QOS_DIFF_DSCP0r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp0), 0, sizeof(BCM53128_A0_QOS_DIFF_DSCP0r_t))
#define BCM53128_A0_QOS_DIFF_DSCP0r_SET(r,i,d) (r).qos_diff_dscp0[i] = d
#define BCM53128_A0_QOS_DIFF_DSCP0r_GET(r,i) (r).qos_diff_dscp0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET(r) (((r).qos_diff_dscp0[0]) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 3) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET(r) ((((r).qos_diff_dscp0[0]) >> 6) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET(r) ((((r).qos_diff_dscp0[0]) >> 9) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET(r) ((((r).qos_diff_dscp0[0]) >> 12) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET(r) ((((r).qos_diff_dscp0[0]) >> 15) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET(r) ((((r).qos_diff_dscp0[0]) >> 18) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET(r) ((((r).qos_diff_dscp0[0]) >> 21) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET(r) ((((r).qos_diff_dscp0[0]) >> 24) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 27) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET(r) cdk_field32_get((r).qos_diff_dscp0,30,32)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp0,30,32,f)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET(r) ((((r).qos_diff_dscp0[1]) >> 1) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET(r) ((((r).qos_diff_dscp0[1]) >> 4) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET(r) ((((r).qos_diff_dscp0[1]) >> 7) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET(r) ((((r).qos_diff_dscp0[1]) >> 10) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET(r) ((((r).qos_diff_dscp0[1]) >> 13) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP0.
 *
 */
#define BCM53128_A0_READ_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_DIFF_DSCP0r,(r._qos_diff_dscp0),6)
#define BCM53128_A0_WRITE_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_DIFF_DSCP0r,&(r._qos_diff_dscp0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP0r BCM53128_A0_QOS_DIFF_DSCP0r
#define QOS_DIFF_DSCP0r_SIZE BCM53128_A0_QOS_DIFF_DSCP0r_SIZE
typedef BCM53128_A0_QOS_DIFF_DSCP0r_t QOS_DIFF_DSCP0r_t;
#define QOS_DIFF_DSCP0r_CLR BCM53128_A0_QOS_DIFF_DSCP0r_CLR
#define QOS_DIFF_DSCP0r_SET BCM53128_A0_QOS_DIFF_DSCP0r_SET
#define QOS_DIFF_DSCP0r_GET BCM53128_A0_QOS_DIFF_DSCP0r_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET BCM53128_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET
#define READ_QOS_DIFF_DSCP0r BCM53128_A0_READ_QOS_DIFF_DSCP0r
#define WRITE_QOS_DIFF_DSCP0r BCM53128_A0_WRITE_QOS_DIFF_DSCP0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_DIFF_DSCP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_DIFF_DSCP1
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 1 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_010000  DiffServ DSCP== 010000 to Priority ID map Register.
 *     PRI_DSCP_010001  DiffServ DSCP== 010001 to Priority ID map Register.
 *     PRI_DSCP_010010  DiffServ DSCP== 010010 to Priority ID map Register.
 *     PRI_DSCP_010011  DiffServ DSCP== 010011 to Priority ID map Register.
 *     PRI_DSCP_010100  DiffServ DSCP== 010100 to Priority ID map Register.
 *     PRI_DSCP_010101  DiffServ DSCP== 010101 to Priority ID map Register.
 *     PRI_DSCP_010110  DiffServ DSCP== 010110 to Priority ID map Register.
 *     PRI_DSCP_010111  DiffServ DSCP== 010111 to Priority ID map Register.
 *     PRI_DSCP_011000  DiffServ DSCP== 011000 to Priority ID map Register.
 *     PRI_DSCP_011001  DiffServ DSCP== 011001 to Priority ID map Register.
 *     PRI_DSCP_011010  DiffServ DSCP== 011010 to Priority ID map Register.
 *     PRI_DSCP_011011  DiffServ DSCP== 011011 to Priority ID map Register.
 *     PRI_DSCP_011100  DiffServ DSCP== 011100 to Priority ID map Register.
 *     PRI_DSCP_011101  DiffServ DSCP== 011101 to Priority ID map Register.
 *     PRI_DSCP_011110  DiffServ DSCP== 011110 to Priority ID map Register.
 *     PRI_DSCP_011111  DiffServ DSCP== 011111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_DIFF_DSCP1r 0x00003046

#define BCM53128_A0_QOS_DIFF_DSCP1r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP1.
 *
 */
typedef union BCM53128_A0_QOS_DIFF_DSCP1r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp1[2];
	uint32_t _qos_diff_dscp1;
} BCM53128_A0_QOS_DIFF_DSCP1r_t;

#define BCM53128_A0_QOS_DIFF_DSCP1r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp1), 0, sizeof(BCM53128_A0_QOS_DIFF_DSCP1r_t))
#define BCM53128_A0_QOS_DIFF_DSCP1r_SET(r,i,d) (r).qos_diff_dscp1[i] = d
#define BCM53128_A0_QOS_DIFF_DSCP1r_GET(r,i) (r).qos_diff_dscp1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET(r) (((r).qos_diff_dscp1[0]) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 3) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 6) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 9) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 12) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 15) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 18) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 21) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET(r) ((((r).qos_diff_dscp1[0]) >> 24) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 27) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET(r) cdk_field32_get((r).qos_diff_dscp1,30,32)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp1,30,32,f)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 1) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 4) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 7) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 10) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 13) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP1.
 *
 */
#define BCM53128_A0_READ_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_DIFF_DSCP1r,(r._qos_diff_dscp1),6)
#define BCM53128_A0_WRITE_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_DIFF_DSCP1r,&(r._qos_diff_dscp1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP1r BCM53128_A0_QOS_DIFF_DSCP1r
#define QOS_DIFF_DSCP1r_SIZE BCM53128_A0_QOS_DIFF_DSCP1r_SIZE
typedef BCM53128_A0_QOS_DIFF_DSCP1r_t QOS_DIFF_DSCP1r_t;
#define QOS_DIFF_DSCP1r_CLR BCM53128_A0_QOS_DIFF_DSCP1r_CLR
#define QOS_DIFF_DSCP1r_SET BCM53128_A0_QOS_DIFF_DSCP1r_SET
#define QOS_DIFF_DSCP1r_GET BCM53128_A0_QOS_DIFF_DSCP1r_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET BCM53128_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET
#define READ_QOS_DIFF_DSCP1r BCM53128_A0_READ_QOS_DIFF_DSCP1r
#define WRITE_QOS_DIFF_DSCP1r BCM53128_A0_WRITE_QOS_DIFF_DSCP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_DIFF_DSCP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_DIFF_DSCP2
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 2 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_100000  DiffServ DSCP== 100000 to Priority ID map Register.
 *     PRI_DSCP_100001  DiffServ DSCP== 100001 to Priority ID map Register.
 *     PRI_DSCP_100010  DiffServ DSCP== 100010 to Priority ID map Register.
 *     PRI_DSCP_100011  DiffServ DSCP== 100011 to Priority ID map Register.
 *     PRI_DSCP_100100  DiffServ DSCP== 100100 to Priority ID map Register.
 *     PRI_DSCP_100101  DiffServ DSCP== 100101 to Priority ID map Register.
 *     PRI_DSCP_100110  DiffServ DSCP== 100110 to Priority ID map Register.
 *     PRI_DSCP_100111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_101000  DiffServ DSCP== 101000 to Priority ID map Register.
 *     PRI_DSCP_101001  DiffServ DSCP== 101001 to Priority ID map Register.
 *     PRI_DSCP_101010  DiffServ DSCP== 101010 to Priority ID map Register.
 *     PRI_DSCP_101011  DiffServ DSCP== 101011 to Priority ID map Register.
 *     PRI_DSCP_101100  DiffServ DSCP== 101100 to Priority ID map Register.
 *     PRI_DSCP_101101  DiffServ DSCP== 101101 to Priority ID map Register.
 *     PRI_DSCP_101110  DiffServ DSCP== 101110 to Priority ID map Register.
 *     PRI_DSCP_101111  DiffServ DSCP== 101111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_DIFF_DSCP2r 0x0000304c

#define BCM53128_A0_QOS_DIFF_DSCP2r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP2.
 *
 */
typedef union BCM53128_A0_QOS_DIFF_DSCP2r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp2[2];
	uint32_t _qos_diff_dscp2;
} BCM53128_A0_QOS_DIFF_DSCP2r_t;

#define BCM53128_A0_QOS_DIFF_DSCP2r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp2), 0, sizeof(BCM53128_A0_QOS_DIFF_DSCP2r_t))
#define BCM53128_A0_QOS_DIFF_DSCP2r_SET(r,i,d) (r).qos_diff_dscp2[i] = d
#define BCM53128_A0_QOS_DIFF_DSCP2r_GET(r,i) (r).qos_diff_dscp2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET(r) (((r).qos_diff_dscp2[0]) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 3) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 6) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 9) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 12) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 15) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 18) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 21) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET(r) ((((r).qos_diff_dscp2[0]) >> 24) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 27) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET(r) cdk_field32_get((r).qos_diff_dscp2,30,32)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp2,30,32,f)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 1) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 4) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 7) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 10) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 13) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP2.
 *
 */
#define BCM53128_A0_READ_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_DIFF_DSCP2r,(r._qos_diff_dscp2),6)
#define BCM53128_A0_WRITE_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_DIFF_DSCP2r,&(r._qos_diff_dscp2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP2r BCM53128_A0_QOS_DIFF_DSCP2r
#define QOS_DIFF_DSCP2r_SIZE BCM53128_A0_QOS_DIFF_DSCP2r_SIZE
typedef BCM53128_A0_QOS_DIFF_DSCP2r_t QOS_DIFF_DSCP2r_t;
#define QOS_DIFF_DSCP2r_CLR BCM53128_A0_QOS_DIFF_DSCP2r_CLR
#define QOS_DIFF_DSCP2r_SET BCM53128_A0_QOS_DIFF_DSCP2r_SET
#define QOS_DIFF_DSCP2r_GET BCM53128_A0_QOS_DIFF_DSCP2r_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET BCM53128_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET
#define READ_QOS_DIFF_DSCP2r BCM53128_A0_READ_QOS_DIFF_DSCP2r
#define WRITE_QOS_DIFF_DSCP2r BCM53128_A0_WRITE_QOS_DIFF_DSCP2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_DIFF_DSCP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_DIFF_DSCP3
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 3 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_110000  DiffServ DSCP== 110000 to Priority ID map Register.
 *     PRI_DSCP_110001  DiffServ DSCP== 110001 to Priority ID map Register.
 *     PRI_DSCP_110010  DiffServ DSCP== 110010 to Priority ID map Register.
 *     PRI_DSCP_110011  DiffServ DSCP== 110011 to Priority ID map Register.
 *     PRI_DSCP_110100  DiffServ DSCP== 110100 to Priority ID map Register.
 *     PRI_DSCP_110101  DiffServ DSCP== 110101 to Priority ID map Register.
 *     PRI_DSCP_110110  DiffServ DSCP== 110110 to Priority ID map Register.
 *     PRI_DSCP_110111  DiffServ DSCP== 110111 to Priority ID map Register.
 *     PRI_DSCP_111000  DiffServ DSCP== 111000 to Priority ID map Register.
 *     PRI_DSCP_111001  DiffServ DSCP== 111001 to Priority ID map Register.
 *     PRI_DSCP_111010  DiffServ DSCP== 111010 to Priority ID map Register.
 *     PRI_DSCP_111011  DiffServ DSCP== 111011 to Priority ID map Register.
 *     PRI_DSCP_111100  DiffServ DSCP== 111100 to Priority ID map Register.
 *     PRI_DSCP_111101  DiffServ DSCP== 111101 to Priority ID map Register.
 *     PRI_DSCP_111110  DiffServ DSCP== 111110 to Priority ID map Register.
 *     PRI_DSCP_111111  DiffServ DSCP== 111111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_DIFF_DSCP3r 0x00003052

#define BCM53128_A0_QOS_DIFF_DSCP3r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP3.
 *
 */
typedef union BCM53128_A0_QOS_DIFF_DSCP3r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp3[2];
	uint32_t _qos_diff_dscp3;
} BCM53128_A0_QOS_DIFF_DSCP3r_t;

#define BCM53128_A0_QOS_DIFF_DSCP3r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp3), 0, sizeof(BCM53128_A0_QOS_DIFF_DSCP3r_t))
#define BCM53128_A0_QOS_DIFF_DSCP3r_SET(r,i,d) (r).qos_diff_dscp3[i] = d
#define BCM53128_A0_QOS_DIFF_DSCP3r_GET(r,i) (r).qos_diff_dscp3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET(r) (((r).qos_diff_dscp3[0]) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 3) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET(r) ((((r).qos_diff_dscp3[0]) >> 6) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET(r) ((((r).qos_diff_dscp3[0]) >> 9) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET(r) ((((r).qos_diff_dscp3[0]) >> 12) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET(r) ((((r).qos_diff_dscp3[0]) >> 15) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET(r) ((((r).qos_diff_dscp3[0]) >> 18) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET(r) ((((r).qos_diff_dscp3[0]) >> 21) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET(r) ((((r).qos_diff_dscp3[0]) >> 24) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 27) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET(r) cdk_field32_get((r).qos_diff_dscp3,30,32)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp3,30,32,f)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET(r) ((((r).qos_diff_dscp3[1]) >> 1) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET(r) ((((r).qos_diff_dscp3[1]) >> 4) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET(r) ((((r).qos_diff_dscp3[1]) >> 7) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET(r) ((((r).qos_diff_dscp3[1]) >> 10) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET(r) ((((r).qos_diff_dscp3[1]) >> 13) & 0x7)
#define BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP3.
 *
 */
#define BCM53128_A0_READ_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_DIFF_DSCP3r,(r._qos_diff_dscp3),6)
#define BCM53128_A0_WRITE_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_DIFF_DSCP3r,&(r._qos_diff_dscp3),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP3r BCM53128_A0_QOS_DIFF_DSCP3r
#define QOS_DIFF_DSCP3r_SIZE BCM53128_A0_QOS_DIFF_DSCP3r_SIZE
typedef BCM53128_A0_QOS_DIFF_DSCP3r_t QOS_DIFF_DSCP3r_t;
#define QOS_DIFF_DSCP3r_CLR BCM53128_A0_QOS_DIFF_DSCP3r_CLR
#define QOS_DIFF_DSCP3r_SET BCM53128_A0_QOS_DIFF_DSCP3r_SET
#define QOS_DIFF_DSCP3r_GET BCM53128_A0_QOS_DIFF_DSCP3r_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET BCM53128_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET
#define READ_QOS_DIFF_DSCP3r BCM53128_A0_READ_QOS_DIFF_DSCP3r
#define WRITE_QOS_DIFF_DSCP3r BCM53128_A0_WRITE_QOS_DIFF_DSCP3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_DIFF_DSCP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_EN_DIFFSERV
 * BLOCKS:   SYS
 * DESC:     QOS DiffServ Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_EN_DIFFSERV  Enable DiffServ priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_EN_DIFFSERVr 0x00003006

#define BCM53128_A0_QOS_EN_DIFFSERVr_SIZE 2

/*
 * This structure should be used to declare and program QOS_EN_DIFFSERV.
 *
 */
typedef union BCM53128_A0_QOS_EN_DIFFSERVr_s {
	uint32_t v[1];
	uint32_t qos_en_diffserv[1];
	uint32_t _qos_en_diffserv;
} BCM53128_A0_QOS_EN_DIFFSERVr_t;

#define BCM53128_A0_QOS_EN_DIFFSERVr_CLR(r) (r).qos_en_diffserv[0] = 0
#define BCM53128_A0_QOS_EN_DIFFSERVr_SET(r,d) (r).qos_en_diffserv[0] = d
#define BCM53128_A0_QOS_EN_DIFFSERVr_GET(r) (r).qos_en_diffserv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET(r) (((r).qos_en_diffserv[0]) & 0x1ff)
#define BCM53128_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_QOS_EN_DIFFSERVr_RESERVEDf_GET(r) ((((r).qos_en_diffserv[0]) >> 9) & 0x7f)
#define BCM53128_A0_QOS_EN_DIFFSERVr_RESERVEDf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_EN_DIFFSERV.
 *
 */
#define BCM53128_A0_READ_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_EN_DIFFSERVr,(r._qos_en_diffserv),2)
#define BCM53128_A0_WRITE_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_EN_DIFFSERVr,&(r._qos_en_diffserv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_EN_DIFFSERVr BCM53128_A0_QOS_EN_DIFFSERVr
#define QOS_EN_DIFFSERVr_SIZE BCM53128_A0_QOS_EN_DIFFSERVr_SIZE
typedef BCM53128_A0_QOS_EN_DIFFSERVr_t QOS_EN_DIFFSERVr_t;
#define QOS_EN_DIFFSERVr_CLR BCM53128_A0_QOS_EN_DIFFSERVr_CLR
#define QOS_EN_DIFFSERVr_SET BCM53128_A0_QOS_EN_DIFFSERVr_SET
#define QOS_EN_DIFFSERVr_GET BCM53128_A0_QOS_EN_DIFFSERVr_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET BCM53128_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET BCM53128_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET
#define QOS_EN_DIFFSERVr_RESERVEDf_GET BCM53128_A0_QOS_EN_DIFFSERVr_RESERVEDf_GET
#define QOS_EN_DIFFSERVr_RESERVEDf_SET BCM53128_A0_QOS_EN_DIFFSERVr_RESERVEDf_SET
#define READ_QOS_EN_DIFFSERVr BCM53128_A0_READ_QOS_EN_DIFFSERVr
#define WRITE_QOS_EN_DIFFSERVr BCM53128_A0_WRITE_QOS_EN_DIFFSERVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_EN_DIFFSERVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_GLOBAL_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS Global Control Register
 * SIZE:     8
 * FIELDS:
 *     MIB_QOS_MON_SEL  SelMIB QOS Monitor Selection2'b00: Queue 02'b01: Queue 12'b10: Queue 22'b11: Queue 3
 *     QOS_LAYER_SEL    QOS IP Layer/Mac Layer Selection.2'b00: Layer 2 QOS only.       Select 802.1p if enabled and the RX frame is tagged, otherwise select mac-based2'b01: IP QOS only Select Diffserv if enabled, otherwise priority=0.2'b10: If (IP) then IP QOS ELSE LAYER2 QOS For IP frame, select Diffserv (0 if Diffserv is off), for L2 frames, select 802.1p if enabled and tagged, otherwise mac-based2'b11: Max Priority of All QOS algorithm Select max priority from port-based, Diffserv if enabled, 802.1p if enabled,
 *     RESERVED_0       Reserved
 *     PORT_QOS_EN      Port Based QOS Enable.When Set, Priority of Packet of individual Port can be assigned by Default Priority bits in Defualt 802.1Q Tag Register (Page:34h Address 10h-21h,26-27h)If Port-based QOS is enabled, it overrides all other priorities except the case of qos_layer_sel=11.Default value by Strap pin qos_en.
 *     AGGREGATION_MODE When set the IMP operated as the uplink port to the upstream network processor and the COS is decided from the TC based the normal packet classification flow. Otherwise, the IMP operates as the interface to the management CPU, and the COS is decided based on the reasons for forwarding the packet to the CPU.
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_GLOBAL_CTRLr 0x00003000

#define BCM53128_A0_QOS_GLOBAL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_GLOBAL_CTRL.
 *
 */
typedef union BCM53128_A0_QOS_GLOBAL_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_global_ctrl[1];
	uint32_t _qos_global_ctrl;
} BCM53128_A0_QOS_GLOBAL_CTRLr_t;

#define BCM53128_A0_QOS_GLOBAL_CTRLr_CLR(r) (r).qos_global_ctrl[0] = 0
#define BCM53128_A0_QOS_GLOBAL_CTRLr_SET(r,d) (r).qos_global_ctrl[0] = d
#define BCM53128_A0_QOS_GLOBAL_CTRLr_GET(r) (r).qos_global_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET(r) (((r).qos_global_ctrl[0]) & 0x3)
#define BCM53128_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET(r) ((((r).qos_global_ctrl[0]) >> 2) & 0x3)
#define BCM53128_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_GET(r) ((((r).qos_global_ctrl[0]) >> 4) & 0x3)
#define BCM53128_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET(r) ((((r).qos_global_ctrl[0]) >> 6) & 0x1)
#define BCM53128_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET(r) ((((r).qos_global_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access QOS_GLOBAL_CTRL.
 *
 */
#define BCM53128_A0_READ_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_GLOBAL_CTRLr,(r._qos_global_ctrl),1)
#define BCM53128_A0_WRITE_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_GLOBAL_CTRLr,&(r._qos_global_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_GLOBAL_CTRLr BCM53128_A0_QOS_GLOBAL_CTRLr
#define QOS_GLOBAL_CTRLr_SIZE BCM53128_A0_QOS_GLOBAL_CTRLr_SIZE
typedef BCM53128_A0_QOS_GLOBAL_CTRLr_t QOS_GLOBAL_CTRLr_t;
#define QOS_GLOBAL_CTRLr_CLR BCM53128_A0_QOS_GLOBAL_CTRLr_CLR
#define QOS_GLOBAL_CTRLr_SET BCM53128_A0_QOS_GLOBAL_CTRLr_SET
#define QOS_GLOBAL_CTRLr_GET BCM53128_A0_QOS_GLOBAL_CTRLr_GET
#define QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET BCM53128_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET
#define QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET BCM53128_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET BCM53128_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET BCM53128_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET
#define QOS_GLOBAL_CTRLr_RESERVED_0f_GET BCM53128_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_GET
#define QOS_GLOBAL_CTRLr_RESERVED_0f_SET BCM53128_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_SET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET BCM53128_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET BCM53128_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET
#define QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET BCM53128_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET
#define QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET BCM53128_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET
#define READ_QOS_GLOBAL_CTRLr BCM53128_A0_READ_QOS_GLOBAL_CTRLr
#define WRITE_QOS_GLOBAL_CTRLr BCM53128_A0_WRITE_QOS_GLOBAL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_GLOBAL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_TX_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS TX Control Register
 * SIZE:     8
 * FIELDS:
 *     QOS_PRIORITY_CTRL Best Effort Queues Priority ControlThis field controls the scheduling priority of the best effort queues. It does not affect the behavior of Q4 and Q5.00: all queues are weighted round robin01: Q3 is strict priority, Q2-Q0  are weighted round robin.10: Q3 and Q2 is strict priority, Q1-Q0 are weighted round robin.11: Q3, Q2, Q1 and Q0 are in strict priority.Strict priority: When it is in strict priority, the priority is Q3 > Q2 > Q1 > Q0. The G_TXPORT will always serve the higher queue first if it is not empty. In this mode, the service weight are don't care.Weighted round robin: When it is in weighted round robin mode, thequeues are scheduled in a round robin way according to the serviceweight of each queue.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_TX_CTRLr 0x00003080

#define BCM53128_A0_QOS_TX_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_TX_CTRL.
 *
 */
typedef union BCM53128_A0_QOS_TX_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_tx_ctrl[1];
	uint32_t _qos_tx_ctrl;
} BCM53128_A0_QOS_TX_CTRLr_t;

#define BCM53128_A0_QOS_TX_CTRLr_CLR(r) (r).qos_tx_ctrl[0] = 0
#define BCM53128_A0_QOS_TX_CTRLr_SET(r,d) (r).qos_tx_ctrl[0] = d
#define BCM53128_A0_QOS_TX_CTRLr_GET(r) (r).qos_tx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET(r) (((r).qos_tx_ctrl[0]) & 0x3)
#define BCM53128_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_QOS_TX_CTRLr_RESERVED_1f_GET(r) ((((r).qos_tx_ctrl[0]) >> 2) & 0x3f)
#define BCM53128_A0_QOS_TX_CTRLr_RESERVED_1f_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access QOS_TX_CTRL.
 *
 */
#define BCM53128_A0_READ_QOS_TX_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_TX_CTRLr,(r._qos_tx_ctrl),1)
#define BCM53128_A0_WRITE_QOS_TX_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_TX_CTRLr,&(r._qos_tx_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TX_CTRLr BCM53128_A0_QOS_TX_CTRLr
#define QOS_TX_CTRLr_SIZE BCM53128_A0_QOS_TX_CTRLr_SIZE
typedef BCM53128_A0_QOS_TX_CTRLr_t QOS_TX_CTRLr_t;
#define QOS_TX_CTRLr_CLR BCM53128_A0_QOS_TX_CTRLr_CLR
#define QOS_TX_CTRLr_SET BCM53128_A0_QOS_TX_CTRLr_SET
#define QOS_TX_CTRLr_GET BCM53128_A0_QOS_TX_CTRLr_GET
#define QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET BCM53128_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET
#define QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET BCM53128_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET
#define QOS_TX_CTRLr_RESERVED_1f_GET BCM53128_A0_QOS_TX_CTRLr_RESERVED_1f_GET
#define QOS_TX_CTRLr_RESERVED_1f_SET BCM53128_A0_QOS_TX_CTRLr_RESERVED_1f_SET
#define READ_QOS_TX_CTRLr BCM53128_A0_READ_QOS_TX_CTRLr
#define WRITE_QOS_TX_CTRLr BCM53128_A0_WRITE_QOS_TX_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_TX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Queue N Weight Register
 * SIZE:     8
 * FIELDS:
 *     WEIGHTS          Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program breg_q3_weight>=breg_q2_weight>=breg_q1_weight>=breg_q0_weight. And this field mustn't be programmed as zero.
 *
 ******************************************************************************/
#define BCM53128_A0_QOS_WEIGHTr 0x00003081

#define BCM53128_A0_QOS_WEIGHTr_SIZE 1

/*
 * This structure should be used to declare and program QOS_WEIGHT.
 *
 */
typedef union BCM53128_A0_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t qos_weight[1];
	uint32_t _qos_weight;
} BCM53128_A0_QOS_WEIGHTr_t;

#define BCM53128_A0_QOS_WEIGHTr_CLR(r) (r).qos_weight[0] = 0
#define BCM53128_A0_QOS_WEIGHTr_SET(r,d) (r).qos_weight[0] = d
#define BCM53128_A0_QOS_WEIGHTr_GET(r) (r).qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_QOS_WEIGHTr_WEIGHTSf_GET(r) (((r).qos_weight[0]) & 0xff)
#define BCM53128_A0_QOS_WEIGHTr_WEIGHTSf_SET(r,f) (r).qos_weight[0]=(((r).qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access QOS_WEIGHT.
 *
 */
#define BCM53128_A0_READ_QOS_WEIGHTr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_QOS_WEIGHTr+(1*(i)),(r._qos_weight),1)
#define BCM53128_A0_WRITE_QOS_WEIGHTr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_QOS_WEIGHTr+(1*(i)),&(r._qos_weight),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_WEIGHTr BCM53128_A0_QOS_WEIGHTr
#define QOS_WEIGHTr_SIZE BCM53128_A0_QOS_WEIGHTr_SIZE
typedef BCM53128_A0_QOS_WEIGHTr_t QOS_WEIGHTr_t;
#define QOS_WEIGHTr_CLR BCM53128_A0_QOS_WEIGHTr_CLR
#define QOS_WEIGHTr_SET BCM53128_A0_QOS_WEIGHTr_SET
#define QOS_WEIGHTr_GET BCM53128_A0_QOS_WEIGHTr_GET
#define QOS_WEIGHTr_WEIGHTSf_GET BCM53128_A0_QOS_WEIGHTr_WEIGHTSf_GET
#define QOS_WEIGHTr_WEIGHTSf_SET BCM53128_A0_QOS_WEIGHTr_WEIGHTSf_SET
#define READ_QOS_WEIGHTr BCM53128_A0_READ_QOS_WEIGHTr
#define WRITE_QOS_WEIGHTr BCM53128_A0_WRITE_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RA_CR
 * BLOCKS:   SYS
 * DESC:     Resource Arbiter Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     RAC_GNT          Grant of resource arbitration.
 *     RAC_REQ          Request of resource arbitrationWriting 1 issues request to resource arbiter.Writing 0 clear request to resource arbiter
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_RA_CRr 0x0000ff20

#define BCM53128_A0_RA_CRr_SIZE 1

/*
 * This structure should be used to declare and program RA_CR.
 *
 */
typedef union BCM53128_A0_RA_CRr_s {
	uint32_t v[1];
	uint32_t ra_cr[1];
	uint32_t _ra_cr;
} BCM53128_A0_RA_CRr_t;

#define BCM53128_A0_RA_CRr_CLR(r) (r).ra_cr[0] = 0
#define BCM53128_A0_RA_CRr_SET(r,d) (r).ra_cr[0] = d
#define BCM53128_A0_RA_CRr_GET(r) (r).ra_cr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_RA_CRr_RAC_GNTf_GET(r) (((r).ra_cr[0]) & 0x1)
#define BCM53128_A0_RA_CRr_RAC_GNTf_SET(r,f) (r).ra_cr[0]=(((r).ra_cr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_RA_CRr_RAC_REQf_GET(r) ((((r).ra_cr[0]) >> 1) & 0x1)
#define BCM53128_A0_RA_CRr_RAC_REQf_SET(r,f) (r).ra_cr[0]=(((r).ra_cr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_RA_CRr_RESERVEDf_GET(r) ((((r).ra_cr[0]) >> 2) & 0x3f)
#define BCM53128_A0_RA_CRr_RESERVEDf_SET(r,f) (r).ra_cr[0]=(((r).ra_cr[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access RA_CR.
 *
 */
#define BCM53128_A0_READ_RA_CRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RA_CRr,(r._ra_cr),1)
#define BCM53128_A0_WRITE_RA_CRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RA_CRr,&(r._ra_cr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RA_CRr BCM53128_A0_RA_CRr
#define RA_CRr_SIZE BCM53128_A0_RA_CRr_SIZE
typedef BCM53128_A0_RA_CRr_t RA_CRr_t;
#define RA_CRr_CLR BCM53128_A0_RA_CRr_CLR
#define RA_CRr_SET BCM53128_A0_RA_CRr_SET
#define RA_CRr_GET BCM53128_A0_RA_CRr_GET
#define RA_CRr_RAC_GNTf_GET BCM53128_A0_RA_CRr_RAC_GNTf_GET
#define RA_CRr_RAC_GNTf_SET BCM53128_A0_RA_CRr_RAC_GNTf_SET
#define RA_CRr_RAC_REQf_GET BCM53128_A0_RA_CRr_RAC_REQf_GET
#define RA_CRr_RAC_REQf_SET BCM53128_A0_RA_CRr_RAC_REQf_SET
#define RA_CRr_RESERVEDf_GET BCM53128_A0_RA_CRr_RESERVEDf_GET
#define RA_CRr_RESERVEDf_SET BCM53128_A0_RA_CRr_RESERVEDf_SET
#define READ_RA_CRr BCM53128_A0_READ_RA_CRr
#define WRITE_RA_CRr BCM53128_A0_WRITE_RA_CRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RA_CRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RMONSTEER
 * BLOCKS:   SYS
 * DESC:     RMON MIB Steering Register
 * SIZE:     16
 * FIELDS:
 *     OR_RMON_RCV      Forces the RMON MIB counters from the normal default of snooping on the receive side of the MAC, to the transmit side.  This allows the RMON MIB counters to snoop either transmit or receive, allowing full duplex MAC support.Bit 0-7: Port0-7Bit 8: Port 8(IMP port) Following are RMON MIB counters: Pkts64Octets Pkts65to127Octets Pkts128to255Octets Pkts256to511Octets Pkts512to1023Octets Pkts1024toMaxPktOctets
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_RMONSTEERr 0x00000204

#define BCM53128_A0_RMONSTEERr_SIZE 2

/*
 * This structure should be used to declare and program RMONSTEER.
 *
 */
typedef union BCM53128_A0_RMONSTEERr_s {
	uint32_t v[1];
	uint32_t rmonsteer[1];
	uint32_t _rmonsteer;
} BCM53128_A0_RMONSTEERr_t;

#define BCM53128_A0_RMONSTEERr_CLR(r) (r).rmonsteer[0] = 0
#define BCM53128_A0_RMONSTEERr_SET(r,d) (r).rmonsteer[0] = d
#define BCM53128_A0_RMONSTEERr_GET(r) (r).rmonsteer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_RMONSTEERr_OR_RMON_RCVf_GET(r) (((r).rmonsteer[0]) & 0x1ff)
#define BCM53128_A0_RMONSTEERr_OR_RMON_RCVf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_RMONSTEERr_RESERVEDf_GET(r) ((((r).rmonsteer[0]) >> 9) & 0x7f)
#define BCM53128_A0_RMONSTEERr_RESERVEDf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RMONSTEER.
 *
 */
#define BCM53128_A0_READ_RMONSTEERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RMONSTEERr,(r._rmonsteer),2)
#define BCM53128_A0_WRITE_RMONSTEERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RMONSTEERr,&(r._rmonsteer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RMONSTEERr BCM53128_A0_RMONSTEERr
#define RMONSTEERr_SIZE BCM53128_A0_RMONSTEERr_SIZE
typedef BCM53128_A0_RMONSTEERr_t RMONSTEERr_t;
#define RMONSTEERr_CLR BCM53128_A0_RMONSTEERr_CLR
#define RMONSTEERr_SET BCM53128_A0_RMONSTEERr_SET
#define RMONSTEERr_GET BCM53128_A0_RMONSTEERr_GET
#define RMONSTEERr_OR_RMON_RCVf_GET BCM53128_A0_RMONSTEERr_OR_RMON_RCVf_GET
#define RMONSTEERr_OR_RMON_RCVf_SET BCM53128_A0_RMONSTEERr_OR_RMON_RCVf_SET
#define RMONSTEERr_RESERVEDf_GET BCM53128_A0_RMONSTEERr_RESERVEDf_GET
#define RMONSTEERr_RESERVEDf_SET BCM53128_A0_RMONSTEERr_RESERVEDf_SET
#define READ_RMONSTEERr BCM53128_A0_READ_RMONSTEERr
#define WRITE_RMONSTEERr BCM53128_A0_WRITE_RMONSTEERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RMONSTEERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RSV_MCAST_CTRL
 * BLOCKS:   SYS
 * DESC:     Reserved Multicast Register
 * SIZE:     8
 * FIELDS:
 *     EN_MUL_0         bit[0] :01-80-C2-00-00-00.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_1         bit[1] :01-80-C2-00-00-02 ~ 01-80-C2-00-00-0F.(Can be set in Unmanaged mode only)0: Forward1: Drop (default)
 *     EN_MUL_2         bit[2] :01-80-C2-00-00-10.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_3         bit[3] :01-80-C2-00-00-11 ~ 01-80-C2-00-00-1F.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_4         bit[4] :01-80-C2-00-00-20 ~ 01-80-C2-00-00-2F.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     RESERVED         Reserved
 *     EN_RES_MUL_LEARN bit[7] : en_reserved_McastDA_learn.(Can be set in Unmanaged mode only)0: Don't learn (default )1: Learn
 *
 ******************************************************************************/
#define BCM53128_A0_RSV_MCAST_CTRLr 0x0000002f

#define BCM53128_A0_RSV_MCAST_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program RSV_MCAST_CTRL.
 *
 */
typedef union BCM53128_A0_RSV_MCAST_CTRLr_s {
	uint32_t v[1];
	uint32_t rsv_mcast_ctrl[1];
	uint32_t _rsv_mcast_ctrl;
} BCM53128_A0_RSV_MCAST_CTRLr_t;

#define BCM53128_A0_RSV_MCAST_CTRLr_CLR(r) (r).rsv_mcast_ctrl[0] = 0
#define BCM53128_A0_RSV_MCAST_CTRLr_SET(r,d) (r).rsv_mcast_ctrl[0] = d
#define BCM53128_A0_RSV_MCAST_CTRLr_GET(r) (r).rsv_mcast_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET(r) (((r).rsv_mcast_ctrl[0]) & 0x1)
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_RSV_MCAST_CTRLr_RESERVEDf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 5) & 0x3)
#define BCM53128_A0_RSV_MCAST_CTRLr_RESERVEDf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RSV_MCAST_CTRL.
 *
 */
#define BCM53128_A0_READ_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RSV_MCAST_CTRLr,(r._rsv_mcast_ctrl),1)
#define BCM53128_A0_WRITE_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RSV_MCAST_CTRLr,&(r._rsv_mcast_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_MCAST_CTRLr BCM53128_A0_RSV_MCAST_CTRLr
#define RSV_MCAST_CTRLr_SIZE BCM53128_A0_RSV_MCAST_CTRLr_SIZE
typedef BCM53128_A0_RSV_MCAST_CTRLr_t RSV_MCAST_CTRLr_t;
#define RSV_MCAST_CTRLr_CLR BCM53128_A0_RSV_MCAST_CTRLr_CLR
#define RSV_MCAST_CTRLr_SET BCM53128_A0_RSV_MCAST_CTRLr_SET
#define RSV_MCAST_CTRLr_GET BCM53128_A0_RSV_MCAST_CTRLr_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_GET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_SET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET
#define RSV_MCAST_CTRLr_EN_MUL_1f_GET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET
#define RSV_MCAST_CTRLr_EN_MUL_1f_SET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET
#define RSV_MCAST_CTRLr_EN_MUL_2f_GET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET
#define RSV_MCAST_CTRLr_EN_MUL_2f_SET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET
#define RSV_MCAST_CTRLr_EN_MUL_3f_GET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET
#define RSV_MCAST_CTRLr_EN_MUL_3f_SET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET
#define RSV_MCAST_CTRLr_EN_MUL_4f_GET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET
#define RSV_MCAST_CTRLr_EN_MUL_4f_SET BCM53128_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET
#define RSV_MCAST_CTRLr_RESERVEDf_GET BCM53128_A0_RSV_MCAST_CTRLr_RESERVEDf_GET
#define RSV_MCAST_CTRLr_RESERVEDf_SET BCM53128_A0_RSV_MCAST_CTRLr_RESERVEDf_SET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET BCM53128_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET BCM53128_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET
#define READ_RSV_MCAST_CTRLr BCM53128_A0_READ_RSV_MCAST_CTRLr
#define WRITE_RSV_MCAST_CTRLr BCM53128_A0_WRITE_RSV_MCAST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RSV_MCAST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RXDISCARD
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXDISCARDr 0x000020c0

#define BCM53128_A0_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD.
 *
 */
typedef union BCM53128_A0_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t rxdiscard[1];
	uint32_t _rxdiscard;
} BCM53128_A0_RXDISCARDr_t;

#define BCM53128_A0_RXDISCARDr_CLR(r) (r).rxdiscard[0] = 0
#define BCM53128_A0_RXDISCARDr_SET(r,d) (r).rxdiscard[0] = d
#define BCM53128_A0_RXDISCARDr_GET(r) (r).rxdiscard[0]


/*
 * These macros can be used to access RXDISCARD.
 *
 */
#define BCM53128_A0_READ_RXDISCARDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXDISCARDr,(r._rxdiscard),4)
#define BCM53128_A0_WRITE_RXDISCARDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXDISCARDr,&(r._rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARDr BCM53128_A0_RXDISCARDr
#define RXDISCARDr_SIZE BCM53128_A0_RXDISCARDr_SIZE
typedef BCM53128_A0_RXDISCARDr_t RXDISCARDr_t;
#define RXDISCARDr_CLR BCM53128_A0_RXDISCARDr_CLR
#define RXDISCARDr_SET BCM53128_A0_RXDISCARDr_SET
#define RXDISCARDr_GET BCM53128_A0_RXDISCARDr_GET
#define READ_RXDISCARDr BCM53128_A0_READ_RXDISCARDr
#define WRITE_RXDISCARDr BCM53128_A0_WRITE_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RXDISCARD_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXDISCARD_IMPr 0x000028c0

#define BCM53128_A0_RXDISCARD_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD_IMP.
 *
 */
typedef union BCM53128_A0_RXDISCARD_IMPr_s {
	uint32_t v[1];
	uint32_t rxdiscard_imp[1];
	uint32_t _rxdiscard_imp;
} BCM53128_A0_RXDISCARD_IMPr_t;

#define BCM53128_A0_RXDISCARD_IMPr_CLR(r) (r).rxdiscard_imp[0] = 0
#define BCM53128_A0_RXDISCARD_IMPr_SET(r,d) (r).rxdiscard_imp[0] = d
#define BCM53128_A0_RXDISCARD_IMPr_GET(r) (r).rxdiscard_imp[0]


/*
 * These macros can be used to access RXDISCARD_IMP.
 *
 */
#define BCM53128_A0_READ_RXDISCARD_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXDISCARD_IMPr,(r._rxdiscard_imp),4)
#define BCM53128_A0_WRITE_RXDISCARD_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXDISCARD_IMPr,&(r._rxdiscard_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARD_IMPr BCM53128_A0_RXDISCARD_IMPr
#define RXDISCARD_IMPr_SIZE BCM53128_A0_RXDISCARD_IMPr_SIZE
typedef BCM53128_A0_RXDISCARD_IMPr_t RXDISCARD_IMPr_t;
#define RXDISCARD_IMPr_CLR BCM53128_A0_RXDISCARD_IMPr_CLR
#define RXDISCARD_IMPr_SET BCM53128_A0_RXDISCARD_IMPr_SET
#define RXDISCARD_IMPr_GET BCM53128_A0_RXDISCARD_IMPr_GET
#define READ_RXDISCARD_IMPr BCM53128_A0_READ_RXDISCARD_IMPr
#define WRITE_RXDISCARD_IMPr BCM53128_A0_WRITE_RXDISCARD_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXDISCARD_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RXSymblErr
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXSYMBLERRr 0x000020ac

#define BCM53128_A0_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr.
 *
 */
typedef union BCM53128_A0_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t rxsymblerr[1];
	uint32_t _rxsymblerr;
} BCM53128_A0_RXSYMBLERRr_t;

#define BCM53128_A0_RXSYMBLERRr_CLR(r) (r).rxsymblerr[0] = 0
#define BCM53128_A0_RXSYMBLERRr_SET(r,d) (r).rxsymblerr[0] = d
#define BCM53128_A0_RXSYMBLERRr_GET(r) (r).rxsymblerr[0]


/*
 * These macros can be used to access RXSymblErr.
 *
 */
#define BCM53128_A0_READ_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXSYMBLERRr,(r._rxsymblerr),4)
#define BCM53128_A0_WRITE_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXSYMBLERRr,&(r._rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERRr BCM53128_A0_RXSYMBLERRr
#define RXSYMBLERRr_SIZE BCM53128_A0_RXSYMBLERRr_SIZE
typedef BCM53128_A0_RXSYMBLERRr_t RXSYMBLERRr_t;
#define RXSYMBLERRr_CLR BCM53128_A0_RXSYMBLERRr_CLR
#define RXSYMBLERRr_SET BCM53128_A0_RXSYMBLERRr_SET
#define RXSYMBLERRr_GET BCM53128_A0_RXSYMBLERRr_GET
#define READ_RXSYMBLERRr BCM53128_A0_READ_RXSYMBLERRr
#define WRITE_RXSYMBLERRr BCM53128_A0_WRITE_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RXSymblErr_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXSYMBLERR_IMPr 0x000028ac

#define BCM53128_A0_RXSYMBLERR_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr_IMP.
 *
 */
typedef union BCM53128_A0_RXSYMBLERR_IMPr_s {
	uint32_t v[1];
	uint32_t rxsymblerr_imp[1];
	uint32_t _rxsymblerr_imp;
} BCM53128_A0_RXSYMBLERR_IMPr_t;

#define BCM53128_A0_RXSYMBLERR_IMPr_CLR(r) (r).rxsymblerr_imp[0] = 0
#define BCM53128_A0_RXSYMBLERR_IMPr_SET(r,d) (r).rxsymblerr_imp[0] = d
#define BCM53128_A0_RXSYMBLERR_IMPr_GET(r) (r).rxsymblerr_imp[0]


/*
 * These macros can be used to access RXSymblErr_IMP.
 *
 */
#define BCM53128_A0_READ_RXSYMBLERR_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXSYMBLERR_IMPr,(r._rxsymblerr_imp),4)
#define BCM53128_A0_WRITE_RXSYMBLERR_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXSYMBLERR_IMPr,&(r._rxsymblerr_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERR_IMPr BCM53128_A0_RXSYMBLERR_IMPr
#define RXSYMBLERR_IMPr_SIZE BCM53128_A0_RXSYMBLERR_IMPr_SIZE
typedef BCM53128_A0_RXSYMBLERR_IMPr_t RXSYMBLERR_IMPr_t;
#define RXSYMBLERR_IMPr_CLR BCM53128_A0_RXSYMBLERR_IMPr_CLR
#define RXSYMBLERR_IMPr_SET BCM53128_A0_RXSYMBLERR_IMPr_SET
#define RXSYMBLERR_IMPr_GET BCM53128_A0_RXSYMBLERR_IMPr_GET
#define READ_RXSYMBLERR_IMPr BCM53128_A0_READ_RXSYMBLERR_IMPr
#define WRITE_RXSYMBLERR_IMPr BCM53128_A0_WRITE_RXSYMBLERR_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXSYMBLERR_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RX_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     RX Global Control register
 * SIZE:     8
 * FIELDS:
 *     FMOK_LATENCY_CNT fmok latency counter.
 *     DIS_CRC_CHK      Disable Ingress CRC check.
 *     DIS_ECC_CHK      Disable ECC check for all SRAM which implement the ECC, except Buffer Tag and TXQ.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_RX_GLOBAL_CTLr 0x0000000a

#define BCM53128_A0_RX_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RX_GLOBAL_CTL.
 *
 */
typedef union BCM53128_A0_RX_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_global_ctl[1];
	uint32_t _rx_global_ctl;
} BCM53128_A0_RX_GLOBAL_CTLr_t;

#define BCM53128_A0_RX_GLOBAL_CTLr_CLR(r) (r).rx_global_ctl[0] = 0
#define BCM53128_A0_RX_GLOBAL_CTLr_SET(r,d) (r).rx_global_ctl[0] = d
#define BCM53128_A0_RX_GLOBAL_CTLr_GET(r) (r).rx_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET(r) (((r).rx_global_ctl[0]) & 0xf)
#define BCM53128_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53128_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 5) & 0x1)
#define BCM53128_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_RX_GLOBAL_CTLr_RESERVEDf_GET(r) ((((r).rx_global_ctl[0]) >> 6) & 0x3)
#define BCM53128_A0_RX_GLOBAL_CTLr_RESERVEDf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RX_GLOBAL_CTL.
 *
 */
#define BCM53128_A0_READ_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RX_GLOBAL_CTLr,(r._rx_global_ctl),1)
#define BCM53128_A0_WRITE_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RX_GLOBAL_CTLr,&(r._rx_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_GLOBAL_CTLr BCM53128_A0_RX_GLOBAL_CTLr
#define RX_GLOBAL_CTLr_SIZE BCM53128_A0_RX_GLOBAL_CTLr_SIZE
typedef BCM53128_A0_RX_GLOBAL_CTLr_t RX_GLOBAL_CTLr_t;
#define RX_GLOBAL_CTLr_CLR BCM53128_A0_RX_GLOBAL_CTLr_CLR
#define RX_GLOBAL_CTLr_SET BCM53128_A0_RX_GLOBAL_CTLr_SET
#define RX_GLOBAL_CTLr_GET BCM53128_A0_RX_GLOBAL_CTLr_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET BCM53128_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET BCM53128_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET BCM53128_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET BCM53128_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET BCM53128_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET BCM53128_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET
#define RX_GLOBAL_CTLr_RESERVEDf_GET BCM53128_A0_RX_GLOBAL_CTLr_RESERVEDf_GET
#define RX_GLOBAL_CTLr_RESERVEDf_SET BCM53128_A0_RX_GLOBAL_CTLr_RESERVEDf_SET
#define READ_RX_GLOBAL_CTLr BCM53128_A0_READ_RX_GLOBAL_CTLr
#define WRITE_RX_GLOBAL_CTLr BCM53128_A0_WRITE_RX_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RX_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for RX Register
 * SIZE:     16
 * FIELDS:
 *     RX_PAUSE_PASS    RX pause pass through map.bit[7:0] : Port 7-01 : ignore 802.3x.0 : comply with 802.3x pause frame receiving.
 *     RESERVED_0       Reserved, it is illegal to write to '1'.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_RX_PAUSE_PASSr 0x00000038

#define BCM53128_A0_RX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program RX_PAUSE_PASS.
 *
 */
typedef union BCM53128_A0_RX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t rx_pause_pass[1];
	uint32_t _rx_pause_pass;
} BCM53128_A0_RX_PAUSE_PASSr_t;

#define BCM53128_A0_RX_PAUSE_PASSr_CLR(r) (r).rx_pause_pass[0] = 0
#define BCM53128_A0_RX_PAUSE_PASSr_SET(r,d) (r).rx_pause_pass[0] = d
#define BCM53128_A0_RX_PAUSE_PASSr_GET(r) (r).rx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET(r) (((r).rx_pause_pass[0]) & 0xff)
#define BCM53128_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_RX_PAUSE_PASSr_RESERVED_0f_GET(r) ((((r).rx_pause_pass[0]) >> 8) & 0x1)
#define BCM53128_A0_RX_PAUSE_PASSr_RESERVED_0f_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_RX_PAUSE_PASSr_RESERVED_1f_GET(r) ((((r).rx_pause_pass[0]) >> 9) & 0x7f)
#define BCM53128_A0_RX_PAUSE_PASSr_RESERVED_1f_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RX_PAUSE_PASS.
 *
 */
#define BCM53128_A0_READ_RX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RX_PAUSE_PASSr,(r._rx_pause_pass),2)
#define BCM53128_A0_WRITE_RX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RX_PAUSE_PASSr,&(r._rx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PAUSE_PASSr BCM53128_A0_RX_PAUSE_PASSr
#define RX_PAUSE_PASSr_SIZE BCM53128_A0_RX_PAUSE_PASSr_SIZE
typedef BCM53128_A0_RX_PAUSE_PASSr_t RX_PAUSE_PASSr_t;
#define RX_PAUSE_PASSr_CLR BCM53128_A0_RX_PAUSE_PASSr_CLR
#define RX_PAUSE_PASSr_SET BCM53128_A0_RX_PAUSE_PASSr_SET
#define RX_PAUSE_PASSr_GET BCM53128_A0_RX_PAUSE_PASSr_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET BCM53128_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET BCM53128_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET
#define RX_PAUSE_PASSr_RESERVED_0f_GET BCM53128_A0_RX_PAUSE_PASSr_RESERVED_0f_GET
#define RX_PAUSE_PASSr_RESERVED_0f_SET BCM53128_A0_RX_PAUSE_PASSr_RESERVED_0f_SET
#define RX_PAUSE_PASSr_RESERVED_1f_GET BCM53128_A0_RX_PAUSE_PASSr_RESERVED_1f_GET
#define RX_PAUSE_PASSr_RESERVED_1f_SET BCM53128_A0_RX_PAUSE_PASSr_RESERVED_1f_SET
#define READ_RX_PAUSE_PASSr BCM53128_A0_READ_RX_PAUSE_PASSr
#define WRITE_RX_PAUSE_PASSr BCM53128_A0_WRITE_RX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXALIGNMENTERRORSr 0x00002080

#define BCM53128_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 *
 */
typedef union BCM53128_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM53128_A0_RXALIGNMENTERRORSr_t;

#define BCM53128_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM53128_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM53128_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 *
 */
#define BCM53128_A0_READ_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM53128_A0_WRITE_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM53128_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM53128_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM53128_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM53128_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM53128_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM53128_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM53128_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM53128_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxAlignmentErrors_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXALIGNMENTERRORS_IMPr 0x00002880

#define BCM53128_A0_RXALIGNMENTERRORS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors_IMP.
 *
 */
typedef union BCM53128_A0_RXALIGNMENTERRORS_IMPr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors_imp[1];
	uint32_t _rxalignmenterrors_imp;
} BCM53128_A0_RXALIGNMENTERRORS_IMPr_t;

#define BCM53128_A0_RXALIGNMENTERRORS_IMPr_CLR(r) (r).rxalignmenterrors_imp[0] = 0
#define BCM53128_A0_RXALIGNMENTERRORS_IMPr_SET(r,d) (r).rxalignmenterrors_imp[0] = d
#define BCM53128_A0_RXALIGNMENTERRORS_IMPr_GET(r) (r).rxalignmenterrors_imp[0]


/*
 * These macros can be used to access RxAlignmentErrors_IMP.
 *
 */
#define BCM53128_A0_READ_RXALIGNMENTERRORS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXALIGNMENTERRORS_IMPr,(r._rxalignmenterrors_imp),4)
#define BCM53128_A0_WRITE_RXALIGNMENTERRORS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXALIGNMENTERRORS_IMPr,&(r._rxalignmenterrors_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORS_IMPr BCM53128_A0_RXALIGNMENTERRORS_IMPr
#define RXALIGNMENTERRORS_IMPr_SIZE BCM53128_A0_RXALIGNMENTERRORS_IMPr_SIZE
typedef BCM53128_A0_RXALIGNMENTERRORS_IMPr_t RXALIGNMENTERRORS_IMPr_t;
#define RXALIGNMENTERRORS_IMPr_CLR BCM53128_A0_RXALIGNMENTERRORS_IMPr_CLR
#define RXALIGNMENTERRORS_IMPr_SET BCM53128_A0_RXALIGNMENTERRORS_IMPr_SET
#define RXALIGNMENTERRORS_IMPr_GET BCM53128_A0_RXALIGNMENTERRORS_IMPr_GET
#define READ_RXALIGNMENTERRORS_IMPr BCM53128_A0_READ_RXALIGNMENTERRORS_IMPr
#define WRITE_RXALIGNMENTERRORS_IMPr BCM53128_A0_WRITE_RXALIGNMENTERRORS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXALIGNMENTERRORS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxBroadcastPkt
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXBROADCASTPKTr 0x0000209c

#define BCM53128_A0_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt.
 *
 */
typedef union BCM53128_A0_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt[1];
	uint32_t _rxbroadcastpkt;
} BCM53128_A0_RXBROADCASTPKTr_t;

#define BCM53128_A0_RXBROADCASTPKTr_CLR(r) (r).rxbroadcastpkt[0] = 0
#define BCM53128_A0_RXBROADCASTPKTr_SET(r,d) (r).rxbroadcastpkt[0] = d
#define BCM53128_A0_RXBROADCASTPKTr_GET(r) (r).rxbroadcastpkt[0]


/*
 * These macros can be used to access RxBroadcastPkt.
 *
 */
#define BCM53128_A0_READ_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXBROADCASTPKTr,(r._rxbroadcastpkt),4)
#define BCM53128_A0_WRITE_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXBROADCASTPKTr,&(r._rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTr BCM53128_A0_RXBROADCASTPKTr
#define RXBROADCASTPKTr_SIZE BCM53128_A0_RXBROADCASTPKTr_SIZE
typedef BCM53128_A0_RXBROADCASTPKTr_t RXBROADCASTPKTr_t;
#define RXBROADCASTPKTr_CLR BCM53128_A0_RXBROADCASTPKTr_CLR
#define RXBROADCASTPKTr_SET BCM53128_A0_RXBROADCASTPKTr_SET
#define RXBROADCASTPKTr_GET BCM53128_A0_RXBROADCASTPKTr_GET
#define READ_RXBROADCASTPKTr BCM53128_A0_READ_RXBROADCASTPKTr
#define WRITE_RXBROADCASTPKTr BCM53128_A0_WRITE_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxBroadcastPkt_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXBROADCASTPKT_IMPr 0x0000289c

#define BCM53128_A0_RXBROADCASTPKT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt_IMP.
 *
 */
typedef union BCM53128_A0_RXBROADCASTPKT_IMPr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt_imp[1];
	uint32_t _rxbroadcastpkt_imp;
} BCM53128_A0_RXBROADCASTPKT_IMPr_t;

#define BCM53128_A0_RXBROADCASTPKT_IMPr_CLR(r) (r).rxbroadcastpkt_imp[0] = 0
#define BCM53128_A0_RXBROADCASTPKT_IMPr_SET(r,d) (r).rxbroadcastpkt_imp[0] = d
#define BCM53128_A0_RXBROADCASTPKT_IMPr_GET(r) (r).rxbroadcastpkt_imp[0]


/*
 * These macros can be used to access RxBroadcastPkt_IMP.
 *
 */
#define BCM53128_A0_READ_RXBROADCASTPKT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXBROADCASTPKT_IMPr,(r._rxbroadcastpkt_imp),4)
#define BCM53128_A0_WRITE_RXBROADCASTPKT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXBROADCASTPKT_IMPr,&(r._rxbroadcastpkt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKT_IMPr BCM53128_A0_RXBROADCASTPKT_IMPr
#define RXBROADCASTPKT_IMPr_SIZE BCM53128_A0_RXBROADCASTPKT_IMPr_SIZE
typedef BCM53128_A0_RXBROADCASTPKT_IMPr_t RXBROADCASTPKT_IMPr_t;
#define RXBROADCASTPKT_IMPr_CLR BCM53128_A0_RXBROADCASTPKT_IMPr_CLR
#define RXBROADCASTPKT_IMPr_SET BCM53128_A0_RXBROADCASTPKT_IMPr_SET
#define RXBROADCASTPKT_IMPr_GET BCM53128_A0_RXBROADCASTPKT_IMPr_GET
#define READ_RXBROADCASTPKT_IMPr BCM53128_A0_READ_RXBROADCASTPKT_IMPr
#define WRITE_RXBROADCASTPKT_IMPr BCM53128_A0_WRITE_RXBROADCASTPKT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXBROADCASTPKT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXDROPPKTSr 0x00002090

#define BCM53128_A0_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts.
 *
 */
typedef union BCM53128_A0_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t rxdroppkts[1];
	uint32_t _rxdroppkts;
} BCM53128_A0_RXDROPPKTSr_t;

#define BCM53128_A0_RXDROPPKTSr_CLR(r) (r).rxdroppkts[0] = 0
#define BCM53128_A0_RXDROPPKTSr_SET(r,d) (r).rxdroppkts[0] = d
#define BCM53128_A0_RXDROPPKTSr_GET(r) (r).rxdroppkts[0]


/*
 * These macros can be used to access RxDropPkts.
 *
 */
#define BCM53128_A0_READ_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXDROPPKTSr,(r._rxdroppkts),4)
#define BCM53128_A0_WRITE_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXDROPPKTSr,&(r._rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTSr BCM53128_A0_RXDROPPKTSr
#define RXDROPPKTSr_SIZE BCM53128_A0_RXDROPPKTSr_SIZE
typedef BCM53128_A0_RXDROPPKTSr_t RXDROPPKTSr_t;
#define RXDROPPKTSr_CLR BCM53128_A0_RXDROPPKTSr_CLR
#define RXDROPPKTSr_SET BCM53128_A0_RXDROPPKTSr_SET
#define RXDROPPKTSr_GET BCM53128_A0_RXDROPPKTSr_GET
#define READ_RXDROPPKTSr BCM53128_A0_READ_RXDROPPKTSr
#define WRITE_RXDROPPKTSr BCM53128_A0_WRITE_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxDropPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXDROPPKTS_IMPr 0x00002890

#define BCM53128_A0_RXDROPPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts_IMP.
 *
 */
typedef union BCM53128_A0_RXDROPPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxdroppkts_imp[1];
	uint32_t _rxdroppkts_imp;
} BCM53128_A0_RXDROPPKTS_IMPr_t;

#define BCM53128_A0_RXDROPPKTS_IMPr_CLR(r) (r).rxdroppkts_imp[0] = 0
#define BCM53128_A0_RXDROPPKTS_IMPr_SET(r,d) (r).rxdroppkts_imp[0] = d
#define BCM53128_A0_RXDROPPKTS_IMPr_GET(r) (r).rxdroppkts_imp[0]


/*
 * These macros can be used to access RxDropPkts_IMP.
 *
 */
#define BCM53128_A0_READ_RXDROPPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXDROPPKTS_IMPr,(r._rxdroppkts_imp),4)
#define BCM53128_A0_WRITE_RXDROPPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXDROPPKTS_IMPr,&(r._rxdroppkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTS_IMPr BCM53128_A0_RXDROPPKTS_IMPr
#define RXDROPPKTS_IMPr_SIZE BCM53128_A0_RXDROPPKTS_IMPr_SIZE
typedef BCM53128_A0_RXDROPPKTS_IMPr_t RXDROPPKTS_IMPr_t;
#define RXDROPPKTS_IMPr_CLR BCM53128_A0_RXDROPPKTS_IMPr_CLR
#define RXDROPPKTS_IMPr_SET BCM53128_A0_RXDROPPKTS_IMPr_SET
#define RXDROPPKTS_IMPr_GET BCM53128_A0_RXDROPPKTS_IMPr_GET
#define READ_RXDROPPKTS_IMPr BCM53128_A0_READ_RXDROPPKTS_IMPr
#define WRITE_RXDROPPKTS_IMPr BCM53128_A0_WRITE_RXDROPPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXDROPPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXFCSERRORSr 0x00002084

#define BCM53128_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 *
 */
typedef union BCM53128_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM53128_A0_RXFCSERRORSr_t;

#define BCM53128_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM53128_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM53128_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 *
 */
#define BCM53128_A0_READ_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM53128_A0_WRITE_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM53128_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM53128_A0_RXFCSERRORSr_SIZE
typedef BCM53128_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM53128_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM53128_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM53128_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM53128_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM53128_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxFCSErrors_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXFCSERRORS_IMPr 0x00002884

#define BCM53128_A0_RXFCSERRORS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors_IMP.
 *
 */
typedef union BCM53128_A0_RXFCSERRORS_IMPr_s {
	uint32_t v[1];
	uint32_t rxfcserrors_imp[1];
	uint32_t _rxfcserrors_imp;
} BCM53128_A0_RXFCSERRORS_IMPr_t;

#define BCM53128_A0_RXFCSERRORS_IMPr_CLR(r) (r).rxfcserrors_imp[0] = 0
#define BCM53128_A0_RXFCSERRORS_IMPr_SET(r,d) (r).rxfcserrors_imp[0] = d
#define BCM53128_A0_RXFCSERRORS_IMPr_GET(r) (r).rxfcserrors_imp[0]


/*
 * These macros can be used to access RxFCSErrors_IMP.
 *
 */
#define BCM53128_A0_READ_RXFCSERRORS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXFCSERRORS_IMPr,(r._rxfcserrors_imp),4)
#define BCM53128_A0_WRITE_RXFCSERRORS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXFCSERRORS_IMPr,&(r._rxfcserrors_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORS_IMPr BCM53128_A0_RXFCSERRORS_IMPr
#define RXFCSERRORS_IMPr_SIZE BCM53128_A0_RXFCSERRORS_IMPr_SIZE
typedef BCM53128_A0_RXFCSERRORS_IMPr_t RXFCSERRORS_IMPr_t;
#define RXFCSERRORS_IMPr_CLR BCM53128_A0_RXFCSERRORS_IMPr_CLR
#define RXFCSERRORS_IMPr_SET BCM53128_A0_RXFCSERRORS_IMPr_SET
#define RXFCSERRORS_IMPr_GET BCM53128_A0_RXFCSERRORS_IMPr_GET
#define READ_RXFCSERRORS_IMPr BCM53128_A0_READ_RXFCSERRORS_IMPr
#define WRITE_RXFCSERRORS_IMPr BCM53128_A0_WRITE_RXFCSERRORS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXFCSERRORS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxFragments
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXFRAGMENTSr 0x000020a4

#define BCM53128_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 *
 */
typedef union BCM53128_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM53128_A0_RXFRAGMENTSr_t;

#define BCM53128_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM53128_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM53128_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 *
 */
#define BCM53128_A0_READ_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM53128_A0_WRITE_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM53128_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM53128_A0_RXFRAGMENTSr_SIZE
typedef BCM53128_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM53128_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM53128_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM53128_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM53128_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM53128_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxFragments_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXFRAGMENTS_IMPr 0x000028a4

#define BCM53128_A0_RXFRAGMENTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments_IMP.
 *
 */
typedef union BCM53128_A0_RXFRAGMENTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxfragments_imp[1];
	uint32_t _rxfragments_imp;
} BCM53128_A0_RXFRAGMENTS_IMPr_t;

#define BCM53128_A0_RXFRAGMENTS_IMPr_CLR(r) (r).rxfragments_imp[0] = 0
#define BCM53128_A0_RXFRAGMENTS_IMPr_SET(r,d) (r).rxfragments_imp[0] = d
#define BCM53128_A0_RXFRAGMENTS_IMPr_GET(r) (r).rxfragments_imp[0]


/*
 * These macros can be used to access RxFragments_IMP.
 *
 */
#define BCM53128_A0_READ_RXFRAGMENTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXFRAGMENTS_IMPr,(r._rxfragments_imp),4)
#define BCM53128_A0_WRITE_RXFRAGMENTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXFRAGMENTS_IMPr,&(r._rxfragments_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTS_IMPr BCM53128_A0_RXFRAGMENTS_IMPr
#define RXFRAGMENTS_IMPr_SIZE BCM53128_A0_RXFRAGMENTS_IMPr_SIZE
typedef BCM53128_A0_RXFRAGMENTS_IMPr_t RXFRAGMENTS_IMPr_t;
#define RXFRAGMENTS_IMPr_CLR BCM53128_A0_RXFRAGMENTS_IMPr_CLR
#define RXFRAGMENTS_IMPr_SET BCM53128_A0_RXFRAGMENTS_IMPr_SET
#define RXFRAGMENTS_IMPr_GET BCM53128_A0_RXFRAGMENTS_IMPr_GET
#define READ_RXFRAGMENTS_IMPr BCM53128_A0_READ_RXFRAGMENTS_IMPr
#define WRITE_RXFRAGMENTS_IMPr BCM53128_A0_WRITE_RXFRAGMENTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXFRAGMENTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53128_A0_RXGOODOCTETSr 0x00002088

#define BCM53128_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 *
 */
typedef union BCM53128_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM53128_A0_RXGOODOCTETSr_t;

#define BCM53128_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM53128_A0_RXGOODOCTETSr_t))
#define BCM53128_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM53128_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 *
 */
#define BCM53128_A0_READ_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM53128_A0_WRITE_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM53128_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM53128_A0_RXGOODOCTETSr_SIZE
typedef BCM53128_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM53128_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM53128_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM53128_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM53128_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM53128_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxGoodOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53128_A0_RXGOODOCTETS_IMPr 0x00002888

#define BCM53128_A0_RXGOODOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets_IMP.
 *
 */
typedef union BCM53128_A0_RXGOODOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets_imp[2];
	uint32_t _rxgoodoctets_imp;
} BCM53128_A0_RXGOODOCTETS_IMPr_t;

#define BCM53128_A0_RXGOODOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets_imp), 0, sizeof(BCM53128_A0_RXGOODOCTETS_IMPr_t))
#define BCM53128_A0_RXGOODOCTETS_IMPr_SET(r,i,d) (r).rxgoodoctets_imp[i] = d
#define BCM53128_A0_RXGOODOCTETS_IMPr_GET(r,i) (r).rxgoodoctets_imp[i]


/*
 * These macros can be used to access RxGoodOctets_IMP.
 *
 */
#define BCM53128_A0_READ_RXGOODOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXGOODOCTETS_IMPr,(r._rxgoodoctets_imp),8)
#define BCM53128_A0_WRITE_RXGOODOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXGOODOCTETS_IMPr,&(r._rxgoodoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETS_IMPr BCM53128_A0_RXGOODOCTETS_IMPr
#define RXGOODOCTETS_IMPr_SIZE BCM53128_A0_RXGOODOCTETS_IMPr_SIZE
typedef BCM53128_A0_RXGOODOCTETS_IMPr_t RXGOODOCTETS_IMPr_t;
#define RXGOODOCTETS_IMPr_CLR BCM53128_A0_RXGOODOCTETS_IMPr_CLR
#define RXGOODOCTETS_IMPr_SET BCM53128_A0_RXGOODOCTETS_IMPr_SET
#define RXGOODOCTETS_IMPr_GET BCM53128_A0_RXGOODOCTETS_IMPr_GET
#define READ_RXGOODOCTETS_IMPr BCM53128_A0_READ_RXGOODOCTETS_IMPr
#define WRITE_RXGOODOCTETS_IMPr BCM53128_A0_WRITE_RXGOODOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXGOODOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxJabbers
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXJABBERSr 0x0000207c

#define BCM53128_A0_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers.
 *
 */
typedef union BCM53128_A0_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t rxjabbers[1];
	uint32_t _rxjabbers;
} BCM53128_A0_RXJABBERSr_t;

#define BCM53128_A0_RXJABBERSr_CLR(r) (r).rxjabbers[0] = 0
#define BCM53128_A0_RXJABBERSr_SET(r,d) (r).rxjabbers[0] = d
#define BCM53128_A0_RXJABBERSr_GET(r) (r).rxjabbers[0]


/*
 * These macros can be used to access RxJabbers.
 *
 */
#define BCM53128_A0_READ_RXJABBERSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXJABBERSr,(r._rxjabbers),4)
#define BCM53128_A0_WRITE_RXJABBERSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXJABBERSr,&(r._rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERSr BCM53128_A0_RXJABBERSr
#define RXJABBERSr_SIZE BCM53128_A0_RXJABBERSr_SIZE
typedef BCM53128_A0_RXJABBERSr_t RXJABBERSr_t;
#define RXJABBERSr_CLR BCM53128_A0_RXJABBERSr_CLR
#define RXJABBERSr_SET BCM53128_A0_RXJABBERSr_SET
#define RXJABBERSr_GET BCM53128_A0_RXJABBERSr_GET
#define READ_RXJABBERSr BCM53128_A0_READ_RXJABBERSr
#define WRITE_RXJABBERSr BCM53128_A0_WRITE_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxJabbers_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXJABBERS_IMPr 0x0000287c

#define BCM53128_A0_RXJABBERS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers_IMP.
 *
 */
typedef union BCM53128_A0_RXJABBERS_IMPr_s {
	uint32_t v[1];
	uint32_t rxjabbers_imp[1];
	uint32_t _rxjabbers_imp;
} BCM53128_A0_RXJABBERS_IMPr_t;

#define BCM53128_A0_RXJABBERS_IMPr_CLR(r) (r).rxjabbers_imp[0] = 0
#define BCM53128_A0_RXJABBERS_IMPr_SET(r,d) (r).rxjabbers_imp[0] = d
#define BCM53128_A0_RXJABBERS_IMPr_GET(r) (r).rxjabbers_imp[0]


/*
 * These macros can be used to access RxJabbers_IMP.
 *
 */
#define BCM53128_A0_READ_RXJABBERS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXJABBERS_IMPr,(r._rxjabbers_imp),4)
#define BCM53128_A0_WRITE_RXJABBERS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXJABBERS_IMPr,&(r._rxjabbers_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERS_IMPr BCM53128_A0_RXJABBERS_IMPr
#define RXJABBERS_IMPr_SIZE BCM53128_A0_RXJABBERS_IMPr_SIZE
typedef BCM53128_A0_RXJABBERS_IMPr_t RXJABBERS_IMPr_t;
#define RXJABBERS_IMPr_CLR BCM53128_A0_RXJABBERS_IMPr_CLR
#define RXJABBERS_IMPr_SET BCM53128_A0_RXJABBERS_IMPr_SET
#define RXJABBERS_IMPr_GET BCM53128_A0_RXJABBERS_IMPr_GET
#define READ_RXJABBERS_IMPr BCM53128_A0_READ_RXJABBERS_IMPr
#define WRITE_RXJABBERS_IMPr BCM53128_A0_WRITE_RXJABBERS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXJABBERS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXMULTICASTPKTSr 0x00002098

#define BCM53128_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 *
 */
typedef union BCM53128_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM53128_A0_RXMULTICASTPKTSr_t;

#define BCM53128_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM53128_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM53128_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 *
 */
#define BCM53128_A0_READ_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM53128_A0_WRITE_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM53128_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM53128_A0_RXMULTICASTPKTSr_SIZE
typedef BCM53128_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM53128_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM53128_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM53128_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM53128_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM53128_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxMulticastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXMULTICASTPKTS_IMPr 0x00002898

#define BCM53128_A0_RXMULTICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts_IMP.
 *
 */
typedef union BCM53128_A0_RXMULTICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts_imp[1];
	uint32_t _rxmulticastpkts_imp;
} BCM53128_A0_RXMULTICASTPKTS_IMPr_t;

#define BCM53128_A0_RXMULTICASTPKTS_IMPr_CLR(r) (r).rxmulticastpkts_imp[0] = 0
#define BCM53128_A0_RXMULTICASTPKTS_IMPr_SET(r,d) (r).rxmulticastpkts_imp[0] = d
#define BCM53128_A0_RXMULTICASTPKTS_IMPr_GET(r) (r).rxmulticastpkts_imp[0]


/*
 * These macros can be used to access RxMulticastPkts_IMP.
 *
 */
#define BCM53128_A0_READ_RXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXMULTICASTPKTS_IMPr,(r._rxmulticastpkts_imp),4)
#define BCM53128_A0_WRITE_RXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXMULTICASTPKTS_IMPr,&(r._rxmulticastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTS_IMPr BCM53128_A0_RXMULTICASTPKTS_IMPr
#define RXMULTICASTPKTS_IMPr_SIZE BCM53128_A0_RXMULTICASTPKTS_IMPr_SIZE
typedef BCM53128_A0_RXMULTICASTPKTS_IMPr_t RXMULTICASTPKTS_IMPr_t;
#define RXMULTICASTPKTS_IMPr_CLR BCM53128_A0_RXMULTICASTPKTS_IMPr_CLR
#define RXMULTICASTPKTS_IMPr_SET BCM53128_A0_RXMULTICASTPKTS_IMPr_SET
#define RXMULTICASTPKTS_IMPr_GET BCM53128_A0_RXMULTICASTPKTS_IMPr_GET
#define READ_RXMULTICASTPKTS_IMPr BCM53128_A0_READ_RXMULTICASTPKTS_IMPr
#define WRITE_RXMULTICASTPKTS_IMPr BCM53128_A0_WRITE_RXMULTICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXMULTICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53128_A0_RXOCTETSr 0x00002050

#define BCM53128_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 *
 */
typedef union BCM53128_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM53128_A0_RXOCTETSr_t;

#define BCM53128_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM53128_A0_RXOCTETSr_t))
#define BCM53128_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM53128_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 *
 */
#define BCM53128_A0_READ_RXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM53128_A0_WRITE_RXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM53128_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM53128_A0_RXOCTETSr_SIZE
typedef BCM53128_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM53128_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM53128_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM53128_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM53128_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM53128_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53128_A0_RXOCTETS_IMPr 0x00002850

#define BCM53128_A0_RXOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets_IMP.
 *
 */
typedef union BCM53128_A0_RXOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t rxoctets_imp[2];
	uint32_t _rxoctets_imp;
} BCM53128_A0_RXOCTETS_IMPr_t;

#define BCM53128_A0_RXOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._rxoctets_imp), 0, sizeof(BCM53128_A0_RXOCTETS_IMPr_t))
#define BCM53128_A0_RXOCTETS_IMPr_SET(r,i,d) (r).rxoctets_imp[i] = d
#define BCM53128_A0_RXOCTETS_IMPr_GET(r,i) (r).rxoctets_imp[i]


/*
 * These macros can be used to access RxOctets_IMP.
 *
 */
#define BCM53128_A0_READ_RXOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXOCTETS_IMPr,(r._rxoctets_imp),8)
#define BCM53128_A0_WRITE_RXOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXOCTETS_IMPr,&(r._rxoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETS_IMPr BCM53128_A0_RXOCTETS_IMPr
#define RXOCTETS_IMPr_SIZE BCM53128_A0_RXOCTETS_IMPr_SIZE
typedef BCM53128_A0_RXOCTETS_IMPr_t RXOCTETS_IMPr_t;
#define RXOCTETS_IMPr_CLR BCM53128_A0_RXOCTETS_IMPr_CLR
#define RXOCTETS_IMPr_SET BCM53128_A0_RXOCTETS_IMPr_SET
#define RXOCTETS_IMPr_GET BCM53128_A0_RXOCTETS_IMPr_GET
#define READ_RXOCTETS_IMPr BCM53128_A0_READ_RXOCTETS_IMPr
#define WRITE_RXOCTETS_IMPr BCM53128_A0_WRITE_RXOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXOVERSIZEPKTSr 0x00002078

#define BCM53128_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 *
 */
typedef union BCM53128_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM53128_A0_RXOVERSIZEPKTSr_t;

#define BCM53128_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM53128_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM53128_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 *
 */
#define BCM53128_A0_READ_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM53128_A0_WRITE_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM53128_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM53128_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM53128_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM53128_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM53128_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM53128_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM53128_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM53128_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxOversizePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXOVERSIZEPKTS_IMPr 0x00002878

#define BCM53128_A0_RXOVERSIZEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts_IMP.
 *
 */
typedef union BCM53128_A0_RXOVERSIZEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts_imp[1];
	uint32_t _rxoversizepkts_imp;
} BCM53128_A0_RXOVERSIZEPKTS_IMPr_t;

#define BCM53128_A0_RXOVERSIZEPKTS_IMPr_CLR(r) (r).rxoversizepkts_imp[0] = 0
#define BCM53128_A0_RXOVERSIZEPKTS_IMPr_SET(r,d) (r).rxoversizepkts_imp[0] = d
#define BCM53128_A0_RXOVERSIZEPKTS_IMPr_GET(r) (r).rxoversizepkts_imp[0]


/*
 * These macros can be used to access RxOversizePkts_IMP.
 *
 */
#define BCM53128_A0_READ_RXOVERSIZEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXOVERSIZEPKTS_IMPr,(r._rxoversizepkts_imp),4)
#define BCM53128_A0_WRITE_RXOVERSIZEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXOVERSIZEPKTS_IMPr,&(r._rxoversizepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTS_IMPr BCM53128_A0_RXOVERSIZEPKTS_IMPr
#define RXOVERSIZEPKTS_IMPr_SIZE BCM53128_A0_RXOVERSIZEPKTS_IMPr_SIZE
typedef BCM53128_A0_RXOVERSIZEPKTS_IMPr_t RXOVERSIZEPKTS_IMPr_t;
#define RXOVERSIZEPKTS_IMPr_CLR BCM53128_A0_RXOVERSIZEPKTS_IMPr_CLR
#define RXOVERSIZEPKTS_IMPr_SET BCM53128_A0_RXOVERSIZEPKTS_IMPr_SET
#define RXOVERSIZEPKTS_IMPr_GET BCM53128_A0_RXOVERSIZEPKTS_IMPr_GET
#define READ_RXOVERSIZEPKTS_IMPr BCM53128_A0_READ_RXOVERSIZEPKTS_IMPr
#define WRITE_RXOVERSIZEPKTS_IMPr BCM53128_A0_WRITE_RXOVERSIZEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXOVERSIZEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXPAUSEPKTSr 0x0000205c

#define BCM53128_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 *
 */
typedef union BCM53128_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM53128_A0_RXPAUSEPKTSr_t;

#define BCM53128_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM53128_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM53128_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 *
 */
#define BCM53128_A0_READ_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM53128_A0_WRITE_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM53128_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM53128_A0_RXPAUSEPKTSr_SIZE
typedef BCM53128_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM53128_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM53128_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM53128_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM53128_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM53128_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxPausePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXPAUSEPKTS_IMPr 0x0000285c

#define BCM53128_A0_RXPAUSEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts_IMP.
 *
 */
typedef union BCM53128_A0_RXPAUSEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxpausepkts_imp[1];
	uint32_t _rxpausepkts_imp;
} BCM53128_A0_RXPAUSEPKTS_IMPr_t;

#define BCM53128_A0_RXPAUSEPKTS_IMPr_CLR(r) (r).rxpausepkts_imp[0] = 0
#define BCM53128_A0_RXPAUSEPKTS_IMPr_SET(r,d) (r).rxpausepkts_imp[0] = d
#define BCM53128_A0_RXPAUSEPKTS_IMPr_GET(r) (r).rxpausepkts_imp[0]


/*
 * These macros can be used to access RxPausePkts_IMP.
 *
 */
#define BCM53128_A0_READ_RXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXPAUSEPKTS_IMPr,(r._rxpausepkts_imp),4)
#define BCM53128_A0_WRITE_RXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXPAUSEPKTS_IMPr,&(r._rxpausepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTS_IMPr BCM53128_A0_RXPAUSEPKTS_IMPr
#define RXPAUSEPKTS_IMPr_SIZE BCM53128_A0_RXPAUSEPKTS_IMPr_SIZE
typedef BCM53128_A0_RXPAUSEPKTS_IMPr_t RXPAUSEPKTS_IMPr_t;
#define RXPAUSEPKTS_IMPr_CLR BCM53128_A0_RXPAUSEPKTS_IMPr_CLR
#define RXPAUSEPKTS_IMPr_SET BCM53128_A0_RXPAUSEPKTS_IMPr_SET
#define RXPAUSEPKTS_IMPr_GET BCM53128_A0_RXPAUSEPKTS_IMPr_GET
#define READ_RXPAUSEPKTS_IMPr BCM53128_A0_READ_RXPAUSEPKTS_IMPr
#define WRITE_RXPAUSEPKTS_IMPr BCM53128_A0_WRITE_RXPAUSEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXPAUSEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxSAChanges
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXSACHANGESr 0x000020a0

#define BCM53128_A0_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges.
 *
 */
typedef union BCM53128_A0_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t rxsachanges[1];
	uint32_t _rxsachanges;
} BCM53128_A0_RXSACHANGESr_t;

#define BCM53128_A0_RXSACHANGESr_CLR(r) (r).rxsachanges[0] = 0
#define BCM53128_A0_RXSACHANGESr_SET(r,d) (r).rxsachanges[0] = d
#define BCM53128_A0_RXSACHANGESr_GET(r) (r).rxsachanges[0]


/*
 * These macros can be used to access RxSAChanges.
 *
 */
#define BCM53128_A0_READ_RXSACHANGESr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXSACHANGESr,(r._rxsachanges),4)
#define BCM53128_A0_WRITE_RXSACHANGESr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXSACHANGESr,&(r._rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGESr BCM53128_A0_RXSACHANGESr
#define RXSACHANGESr_SIZE BCM53128_A0_RXSACHANGESr_SIZE
typedef BCM53128_A0_RXSACHANGESr_t RXSACHANGESr_t;
#define RXSACHANGESr_CLR BCM53128_A0_RXSACHANGESr_CLR
#define RXSACHANGESr_SET BCM53128_A0_RXSACHANGESr_SET
#define RXSACHANGESr_GET BCM53128_A0_RXSACHANGESr_GET
#define READ_RXSACHANGESr BCM53128_A0_READ_RXSACHANGESr
#define WRITE_RXSACHANGESr BCM53128_A0_WRITE_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxSAChanges_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXSACHANGES_IMPr 0x000028a0

#define BCM53128_A0_RXSACHANGES_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges_IMP.
 *
 */
typedef union BCM53128_A0_RXSACHANGES_IMPr_s {
	uint32_t v[1];
	uint32_t rxsachanges_imp[1];
	uint32_t _rxsachanges_imp;
} BCM53128_A0_RXSACHANGES_IMPr_t;

#define BCM53128_A0_RXSACHANGES_IMPr_CLR(r) (r).rxsachanges_imp[0] = 0
#define BCM53128_A0_RXSACHANGES_IMPr_SET(r,d) (r).rxsachanges_imp[0] = d
#define BCM53128_A0_RXSACHANGES_IMPr_GET(r) (r).rxsachanges_imp[0]


/*
 * These macros can be used to access RxSAChanges_IMP.
 *
 */
#define BCM53128_A0_READ_RXSACHANGES_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXSACHANGES_IMPr,(r._rxsachanges_imp),4)
#define BCM53128_A0_WRITE_RXSACHANGES_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXSACHANGES_IMPr,&(r._rxsachanges_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGES_IMPr BCM53128_A0_RXSACHANGES_IMPr
#define RXSACHANGES_IMPr_SIZE BCM53128_A0_RXSACHANGES_IMPr_SIZE
typedef BCM53128_A0_RXSACHANGES_IMPr_t RXSACHANGES_IMPr_t;
#define RXSACHANGES_IMPr_CLR BCM53128_A0_RXSACHANGES_IMPr_CLR
#define RXSACHANGES_IMPr_SET BCM53128_A0_RXSACHANGES_IMPr_SET
#define RXSACHANGES_IMPr_GET BCM53128_A0_RXSACHANGES_IMPr_GET
#define READ_RXSACHANGES_IMPr BCM53128_A0_READ_RXSACHANGES_IMPr
#define WRITE_RXSACHANGES_IMPr BCM53128_A0_WRITE_RXSACHANGES_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXSACHANGES_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXUNDERSIZEPKTSr 0x00002058

#define BCM53128_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 *
 */
typedef union BCM53128_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM53128_A0_RXUNDERSIZEPKTSr_t;

#define BCM53128_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM53128_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM53128_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 *
 */
#define BCM53128_A0_READ_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM53128_A0_WRITE_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM53128_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM53128_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM53128_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM53128_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM53128_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM53128_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM53128_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM53128_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxUndersizePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXUNDERSIZEPKTS_IMPr 0x00002858

#define BCM53128_A0_RXUNDERSIZEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts_IMP.
 *
 */
typedef union BCM53128_A0_RXUNDERSIZEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts_imp[1];
	uint32_t _rxundersizepkts_imp;
} BCM53128_A0_RXUNDERSIZEPKTS_IMPr_t;

#define BCM53128_A0_RXUNDERSIZEPKTS_IMPr_CLR(r) (r).rxundersizepkts_imp[0] = 0
#define BCM53128_A0_RXUNDERSIZEPKTS_IMPr_SET(r,d) (r).rxundersizepkts_imp[0] = d
#define BCM53128_A0_RXUNDERSIZEPKTS_IMPr_GET(r) (r).rxundersizepkts_imp[0]


/*
 * These macros can be used to access RxUndersizePkts_IMP.
 *
 */
#define BCM53128_A0_READ_RXUNDERSIZEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXUNDERSIZEPKTS_IMPr,(r._rxundersizepkts_imp),4)
#define BCM53128_A0_WRITE_RXUNDERSIZEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXUNDERSIZEPKTS_IMPr,&(r._rxundersizepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTS_IMPr BCM53128_A0_RXUNDERSIZEPKTS_IMPr
#define RXUNDERSIZEPKTS_IMPr_SIZE BCM53128_A0_RXUNDERSIZEPKTS_IMPr_SIZE
typedef BCM53128_A0_RXUNDERSIZEPKTS_IMPr_t RXUNDERSIZEPKTS_IMPr_t;
#define RXUNDERSIZEPKTS_IMPr_CLR BCM53128_A0_RXUNDERSIZEPKTS_IMPr_CLR
#define RXUNDERSIZEPKTS_IMPr_SET BCM53128_A0_RXUNDERSIZEPKTS_IMPr_SET
#define RXUNDERSIZEPKTS_IMPr_GET BCM53128_A0_RXUNDERSIZEPKTS_IMPr_GET
#define READ_RXUNDERSIZEPKTS_IMPr BCM53128_A0_READ_RXUNDERSIZEPKTS_IMPr
#define WRITE_RXUNDERSIZEPKTS_IMPr BCM53128_A0_WRITE_RXUNDERSIZEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXUNDERSIZEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXUNICASTPKTSr 0x00002094

#define BCM53128_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 *
 */
typedef union BCM53128_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM53128_A0_RXUNICASTPKTSr_t;

#define BCM53128_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM53128_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM53128_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 *
 */
#define BCM53128_A0_READ_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM53128_A0_WRITE_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM53128_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM53128_A0_RXUNICASTPKTSr_SIZE
typedef BCM53128_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM53128_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM53128_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM53128_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM53128_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM53128_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  RxUnicastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_RXUNICASTPKTS_IMPr 0x00002894

#define BCM53128_A0_RXUNICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts_IMP.
 *
 */
typedef union BCM53128_A0_RXUNICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts_imp[1];
	uint32_t _rxunicastpkts_imp;
} BCM53128_A0_RXUNICASTPKTS_IMPr_t;

#define BCM53128_A0_RXUNICASTPKTS_IMPr_CLR(r) (r).rxunicastpkts_imp[0] = 0
#define BCM53128_A0_RXUNICASTPKTS_IMPr_SET(r,d) (r).rxunicastpkts_imp[0] = d
#define BCM53128_A0_RXUNICASTPKTS_IMPr_GET(r) (r).rxunicastpkts_imp[0]


/*
 * These macros can be used to access RxUnicastPkts_IMP.
 *
 */
#define BCM53128_A0_READ_RXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_RXUNICASTPKTS_IMPr,(r._rxunicastpkts_imp),4)
#define BCM53128_A0_WRITE_RXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_RXUNICASTPKTS_IMPr,&(r._rxunicastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTS_IMPr BCM53128_A0_RXUNICASTPKTS_IMPr
#define RXUNICASTPKTS_IMPr_SIZE BCM53128_A0_RXUNICASTPKTS_IMPr_SIZE
typedef BCM53128_A0_RXUNICASTPKTS_IMPr_t RXUNICASTPKTS_IMPr_t;
#define RXUNICASTPKTS_IMPr_CLR BCM53128_A0_RXUNICASTPKTS_IMPr_CLR
#define RXUNICASTPKTS_IMPr_SET BCM53128_A0_RXUNICASTPKTS_IMPr_SET
#define RXUNICASTPKTS_IMPr_GET BCM53128_A0_RXUNICASTPKTS_IMPr_GET
#define READ_RXUNICASTPKTS_IMPr BCM53128_A0_READ_RXUNICASTPKTS_IMPr
#define WRITE_RXUNICASTPKTS_IMPr BCM53128_A0_WRITE_RXUNICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_RXUNICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SFT_LRN_CTL
 * BLOCKS:   SYS
 * DESC:     Software Learning Control
 * SIZE:     16
 * FIELDS:
 *     SW_LEARN_CNTL    bit[8:0] : Port 8-0.1: Software learning control enabled.The behaviors are as follows. a. Forwarding behavior: Incoming packet with unknown SA will be copied to CPU port. b. Learning behavior: Alow S/W to decide whether incoming packet learn or not. In S/W learning mode, the H/W learning mechnism will be disabled automatically. c. Refreshed behavior: Allow refreshed mechnism to operate properly even through the H/W learning had been disabled.This field makes no effect if the disable learning is enable(page 00h, addr 3Ch)It is not allowed to enable software learning for WAN port, since all frames from WAN port are already sent to IMP port.0: Software learning control disabled.Forwarding/Learning/Refreshed behavior to keep hardware operation.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SFT_LRN_CTLr 0x0000003e

#define BCM53128_A0_SFT_LRN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program SFT_LRN_CTL.
 *
 */
typedef union BCM53128_A0_SFT_LRN_CTLr_s {
	uint32_t v[1];
	uint32_t sft_lrn_ctl[1];
	uint32_t _sft_lrn_ctl;
} BCM53128_A0_SFT_LRN_CTLr_t;

#define BCM53128_A0_SFT_LRN_CTLr_CLR(r) (r).sft_lrn_ctl[0] = 0
#define BCM53128_A0_SFT_LRN_CTLr_SET(r,d) (r).sft_lrn_ctl[0] = d
#define BCM53128_A0_SFT_LRN_CTLr_GET(r) (r).sft_lrn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET(r) (((r).sft_lrn_ctl[0]) & 0x1ff)
#define BCM53128_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_SFT_LRN_CTLr_RESERVEDf_GET(r) ((((r).sft_lrn_ctl[0]) >> 9) & 0x7f)
#define BCM53128_A0_SFT_LRN_CTLr_RESERVEDf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SFT_LRN_CTL.
 *
 */
#define BCM53128_A0_READ_SFT_LRN_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SFT_LRN_CTLr,(r._sft_lrn_ctl),2)
#define BCM53128_A0_WRITE_SFT_LRN_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SFT_LRN_CTLr,&(r._sft_lrn_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFT_LRN_CTLr BCM53128_A0_SFT_LRN_CTLr
#define SFT_LRN_CTLr_SIZE BCM53128_A0_SFT_LRN_CTLr_SIZE
typedef BCM53128_A0_SFT_LRN_CTLr_t SFT_LRN_CTLr_t;
#define SFT_LRN_CTLr_CLR BCM53128_A0_SFT_LRN_CTLr_CLR
#define SFT_LRN_CTLr_SET BCM53128_A0_SFT_LRN_CTLr_SET
#define SFT_LRN_CTLr_GET BCM53128_A0_SFT_LRN_CTLr_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_GET BCM53128_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_SET BCM53128_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET
#define SFT_LRN_CTLr_RESERVEDf_GET BCM53128_A0_SFT_LRN_CTLr_RESERVEDf_GET
#define SFT_LRN_CTLr_RESERVEDf_SET BCM53128_A0_SFT_LRN_CTLr_RESERVEDf_SET
#define READ_SFT_LRN_CTLr BCM53128_A0_READ_SFT_LRN_CTLr
#define WRITE_SFT_LRN_CTLr BCM53128_A0_WRITE_SFT_LRN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SFT_LRN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SIP_REG
 * BLOCKS:   SYS
 * DESC:     SIP Registers
 * SIZE:     32
 * FIELDS:
 *     SIP_REG          per-port SIP enable. 1: enable.0: disable.
 *     RESERVED         Reserved.
 *     UDP_WCM_EN       udpWildcardMatchEnable.When '1', if the packet is using the UDP protocol and none of the rule's in the KEY 0 ~ 15 match the packet, then the actions associated with the wildcard function are executed.
 *
 ******************************************************************************/
#define BCM53128_A0_SIP_REGr 0x0000a200

#define BCM53128_A0_SIP_REGr_SIZE 4

/*
 * This structure should be used to declare and program SIP_REG.
 *
 */
typedef union BCM53128_A0_SIP_REGr_s {
	uint32_t v[1];
	uint32_t sip_reg[1];
	uint32_t _sip_reg;
} BCM53128_A0_SIP_REGr_t;

#define BCM53128_A0_SIP_REGr_CLR(r) (r).sip_reg[0] = 0
#define BCM53128_A0_SIP_REGr_SET(r,d) (r).sip_reg[0] = d
#define BCM53128_A0_SIP_REGr_GET(r) (r).sip_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SIP_REGr_SIP_REGf_GET(r) (((r).sip_reg[0]) & 0x1ff)
#define BCM53128_A0_SIP_REGr_SIP_REGf_SET(r,f) (r).sip_reg[0]=(((r).sip_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_SIP_REGr_RESERVEDf_GET(r) ((((r).sip_reg[0]) >> 9) & 0x3fffff)
#define BCM53128_A0_SIP_REGr_RESERVEDf_SET(r,f) (r).sip_reg[0]=(((r).sip_reg[0] & ~((uint32_t)0x3fffff << 9)) | ((((uint32_t)f) & 0x3fffff) << 9))
#define BCM53128_A0_SIP_REGr_UDP_WCM_ENf_GET(r) ((((r).sip_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_SIP_REGr_UDP_WCM_ENf_SET(r,f) (r).sip_reg[0]=(((r).sip_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SIP_REG.
 *
 */
#define BCM53128_A0_READ_SIP_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SIP_REGr,(r._sip_reg),4)
#define BCM53128_A0_WRITE_SIP_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SIP_REGr,&(r._sip_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SIP_REGr BCM53128_A0_SIP_REGr
#define SIP_REGr_SIZE BCM53128_A0_SIP_REGr_SIZE
typedef BCM53128_A0_SIP_REGr_t SIP_REGr_t;
#define SIP_REGr_CLR BCM53128_A0_SIP_REGr_CLR
#define SIP_REGr_SET BCM53128_A0_SIP_REGr_SET
#define SIP_REGr_GET BCM53128_A0_SIP_REGr_GET
#define SIP_REGr_SIP_REGf_GET BCM53128_A0_SIP_REGr_SIP_REGf_GET
#define SIP_REGr_SIP_REGf_SET BCM53128_A0_SIP_REGr_SIP_REGf_SET
#define SIP_REGr_RESERVEDf_GET BCM53128_A0_SIP_REGr_RESERVEDf_GET
#define SIP_REGr_RESERVEDf_SET BCM53128_A0_SIP_REGr_RESERVEDf_SET
#define SIP_REGr_UDP_WCM_ENf_GET BCM53128_A0_SIP_REGr_UDP_WCM_ENf_GET
#define SIP_REGr_UDP_WCM_ENf_SET BCM53128_A0_SIP_REGr_UDP_WCM_ENf_SET
#define READ_SIP_REGr BCM53128_A0_READ_SIP_REGr
#define WRITE_SIP_REGr BCM53128_A0_WRITE_SIP_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SIP_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     5
 * FIELDS:
 *     CPIC             Software Block Flag for CPIC
 *     EXP              Software Block Flag for EXP
 *     GPIC             Software Block Flag for GPIC
 *     SPI              Software Block Flag for SPI
 *     SYS              Software Block Flag for SYS
 *
 ******************************************************************************/
#define BCM53128_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM53128_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM53128_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM53128_A0_SOFTWARE_BLOCKMAP_t;

#define BCM53128_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM53128_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM53128_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM53128_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM53128_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_SOFTWARE_BLOCKMAP_GPICf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM53128_A0_SOFTWARE_BLOCKMAP_GPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM53128_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM53128_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM53128_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM53128_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM53128_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM53128_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM53128_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM53128_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM53128_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM53128_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM53128_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM53128_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_GPICf_GET BCM53128_A0_SOFTWARE_BLOCKMAP_GPICf_GET
#define SOFTWARE_BLOCKMAP_GPICf_SET BCM53128_A0_SOFTWARE_BLOCKMAP_GPICf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM53128_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM53128_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM53128_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM53128_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define READ_SOFTWARE_BLOCKMAP BCM53128_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM53128_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     32
 * FIELDS:
 *     PORT_SPD         Port Speed.18 bit field indicating the operating speed for each 10/100/1000BASE-T port.Bit 17:16 = Port 8 (IMP Port)Bit 15:0 = Port 7 - Port 0(Bit[1:0] for Port 0, and Bit[15:14] for Port 7)00 = 10 Mb/s01 = 100 Mb/s10 = 1000 Mb/s11 = 200Mb/s(for Port 7/Port 8 TMII mode only)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SPDSTSr 0x00000104

#define BCM53128_A0_SPDSTSr_SIZE 4

/*
 * This structure should be used to declare and program SPDSTS.
 *
 */
typedef union BCM53128_A0_SPDSTSr_s {
	uint32_t v[1];
	uint32_t spdsts[1];
	uint32_t _spdsts;
} BCM53128_A0_SPDSTSr_t;

#define BCM53128_A0_SPDSTSr_CLR(r) (r).spdsts[0] = 0
#define BCM53128_A0_SPDSTSr_SET(r,d) (r).spdsts[0] = d
#define BCM53128_A0_SPDSTSr_GET(r) (r).spdsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPDSTSr_PORT_SPDf_GET(r) (((r).spdsts[0]) & 0x3ffff)
#define BCM53128_A0_SPDSTSr_PORT_SPDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53128_A0_SPDSTSr_RESERVEDf_GET(r) ((((r).spdsts[0]) >> 18) & 0x3fff)
#define BCM53128_A0_SPDSTSr_RESERVEDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access SPDSTS.
 *
 */
#define BCM53128_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPDSTSr,(r._spdsts),4)
#define BCM53128_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPDSTSr,&(r._spdsts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM53128_A0_SPDSTSr
#define SPDSTSr_SIZE BCM53128_A0_SPDSTSr_SIZE
typedef BCM53128_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM53128_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM53128_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM53128_A0_SPDSTSr_GET
#define SPDSTSr_PORT_SPDf_GET BCM53128_A0_SPDSTSr_PORT_SPDf_GET
#define SPDSTSr_PORT_SPDf_SET BCM53128_A0_SPDSTSr_PORT_SPDf_SET
#define SPDSTSr_RESERVEDf_GET BCM53128_A0_SPDSTSr_RESERVEDf_GET
#define SPDSTSr_RESERVEDf_SET BCM53128_A0_SPDSTSr_RESERVEDf_SET
#define READ_SPDSTSr BCM53128_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM53128_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPDSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO0
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 0
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 0
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO0r 0x0000fff0

#define BCM53128_A0_SPIDIO0r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO0.
 *
 */
typedef union BCM53128_A0_SPIDIO0r_s {
	uint32_t v[1];
	uint32_t spidio0[1];
	uint32_t _spidio0;
} BCM53128_A0_SPIDIO0r_t;

#define BCM53128_A0_SPIDIO0r_CLR(r) (r).spidio0[0] = 0
#define BCM53128_A0_SPIDIO0r_SET(r,d) (r).spidio0[0] = d
#define BCM53128_A0_SPIDIO0r_GET(r) (r).spidio0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO0r_RESERVEDf_GET(r) (((r).spidio0[0]) & 0xff)
#define BCM53128_A0_SPIDIO0r_RESERVEDf_SET(r,f) (r).spidio0[0]=(((r).spidio0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO0.
 *
 */
#define BCM53128_A0_READ_SPIDIO0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO0r,(r._spidio0),1)
#define BCM53128_A0_WRITE_SPIDIO0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO0r,&(r._spidio0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO0r BCM53128_A0_SPIDIO0r
#define SPIDIO0r_SIZE BCM53128_A0_SPIDIO0r_SIZE
typedef BCM53128_A0_SPIDIO0r_t SPIDIO0r_t;
#define SPIDIO0r_CLR BCM53128_A0_SPIDIO0r_CLR
#define SPIDIO0r_SET BCM53128_A0_SPIDIO0r_SET
#define SPIDIO0r_GET BCM53128_A0_SPIDIO0r_GET
#define SPIDIO0r_RESERVEDf_GET BCM53128_A0_SPIDIO0r_RESERVEDf_GET
#define SPIDIO0r_RESERVEDf_SET BCM53128_A0_SPIDIO0r_RESERVEDf_SET
#define READ_SPIDIO0r BCM53128_A0_READ_SPIDIO0r
#define WRITE_SPIDIO0r BCM53128_A0_WRITE_SPIDIO0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO1
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 1
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 1
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO1r 0x0000fff1

#define BCM53128_A0_SPIDIO1r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO1.
 *
 */
typedef union BCM53128_A0_SPIDIO1r_s {
	uint32_t v[1];
	uint32_t spidio1[1];
	uint32_t _spidio1;
} BCM53128_A0_SPIDIO1r_t;

#define BCM53128_A0_SPIDIO1r_CLR(r) (r).spidio1[0] = 0
#define BCM53128_A0_SPIDIO1r_SET(r,d) (r).spidio1[0] = d
#define BCM53128_A0_SPIDIO1r_GET(r) (r).spidio1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO1r_RESERVEDf_GET(r) (((r).spidio1[0]) & 0xff)
#define BCM53128_A0_SPIDIO1r_RESERVEDf_SET(r,f) (r).spidio1[0]=(((r).spidio1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO1.
 *
 */
#define BCM53128_A0_READ_SPIDIO1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO1r,(r._spidio1),1)
#define BCM53128_A0_WRITE_SPIDIO1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO1r,&(r._spidio1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO1r BCM53128_A0_SPIDIO1r
#define SPIDIO1r_SIZE BCM53128_A0_SPIDIO1r_SIZE
typedef BCM53128_A0_SPIDIO1r_t SPIDIO1r_t;
#define SPIDIO1r_CLR BCM53128_A0_SPIDIO1r_CLR
#define SPIDIO1r_SET BCM53128_A0_SPIDIO1r_SET
#define SPIDIO1r_GET BCM53128_A0_SPIDIO1r_GET
#define SPIDIO1r_RESERVEDf_GET BCM53128_A0_SPIDIO1r_RESERVEDf_GET
#define SPIDIO1r_RESERVEDf_SET BCM53128_A0_SPIDIO1r_RESERVEDf_SET
#define READ_SPIDIO1r BCM53128_A0_READ_SPIDIO1r
#define WRITE_SPIDIO1r BCM53128_A0_WRITE_SPIDIO1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO2
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 2
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 2
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO2r 0x0000fff2

#define BCM53128_A0_SPIDIO2r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO2.
 *
 */
typedef union BCM53128_A0_SPIDIO2r_s {
	uint32_t v[1];
	uint32_t spidio2[1];
	uint32_t _spidio2;
} BCM53128_A0_SPIDIO2r_t;

#define BCM53128_A0_SPIDIO2r_CLR(r) (r).spidio2[0] = 0
#define BCM53128_A0_SPIDIO2r_SET(r,d) (r).spidio2[0] = d
#define BCM53128_A0_SPIDIO2r_GET(r) (r).spidio2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO2r_RESERVEDf_GET(r) (((r).spidio2[0]) & 0xff)
#define BCM53128_A0_SPIDIO2r_RESERVEDf_SET(r,f) (r).spidio2[0]=(((r).spidio2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO2.
 *
 */
#define BCM53128_A0_READ_SPIDIO2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO2r,(r._spidio2),1)
#define BCM53128_A0_WRITE_SPIDIO2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO2r,&(r._spidio2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO2r BCM53128_A0_SPIDIO2r
#define SPIDIO2r_SIZE BCM53128_A0_SPIDIO2r_SIZE
typedef BCM53128_A0_SPIDIO2r_t SPIDIO2r_t;
#define SPIDIO2r_CLR BCM53128_A0_SPIDIO2r_CLR
#define SPIDIO2r_SET BCM53128_A0_SPIDIO2r_SET
#define SPIDIO2r_GET BCM53128_A0_SPIDIO2r_GET
#define SPIDIO2r_RESERVEDf_GET BCM53128_A0_SPIDIO2r_RESERVEDf_GET
#define SPIDIO2r_RESERVEDf_SET BCM53128_A0_SPIDIO2r_RESERVEDf_SET
#define READ_SPIDIO2r BCM53128_A0_READ_SPIDIO2r
#define WRITE_SPIDIO2r BCM53128_A0_WRITE_SPIDIO2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO3
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 3
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 3
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO3r 0x0000fff3

#define BCM53128_A0_SPIDIO3r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO3.
 *
 */
typedef union BCM53128_A0_SPIDIO3r_s {
	uint32_t v[1];
	uint32_t spidio3[1];
	uint32_t _spidio3;
} BCM53128_A0_SPIDIO3r_t;

#define BCM53128_A0_SPIDIO3r_CLR(r) (r).spidio3[0] = 0
#define BCM53128_A0_SPIDIO3r_SET(r,d) (r).spidio3[0] = d
#define BCM53128_A0_SPIDIO3r_GET(r) (r).spidio3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO3r_RESERVEDf_GET(r) (((r).spidio3[0]) & 0xff)
#define BCM53128_A0_SPIDIO3r_RESERVEDf_SET(r,f) (r).spidio3[0]=(((r).spidio3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO3.
 *
 */
#define BCM53128_A0_READ_SPIDIO3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO3r,(r._spidio3),1)
#define BCM53128_A0_WRITE_SPIDIO3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO3r,&(r._spidio3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO3r BCM53128_A0_SPIDIO3r
#define SPIDIO3r_SIZE BCM53128_A0_SPIDIO3r_SIZE
typedef BCM53128_A0_SPIDIO3r_t SPIDIO3r_t;
#define SPIDIO3r_CLR BCM53128_A0_SPIDIO3r_CLR
#define SPIDIO3r_SET BCM53128_A0_SPIDIO3r_SET
#define SPIDIO3r_GET BCM53128_A0_SPIDIO3r_GET
#define SPIDIO3r_RESERVEDf_GET BCM53128_A0_SPIDIO3r_RESERVEDf_GET
#define SPIDIO3r_RESERVEDf_SET BCM53128_A0_SPIDIO3r_RESERVEDf_SET
#define READ_SPIDIO3r BCM53128_A0_READ_SPIDIO3r
#define WRITE_SPIDIO3r BCM53128_A0_WRITE_SPIDIO3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO4
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 4
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 4
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO4r 0x0000fff4

#define BCM53128_A0_SPIDIO4r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO4.
 *
 */
typedef union BCM53128_A0_SPIDIO4r_s {
	uint32_t v[1];
	uint32_t spidio4[1];
	uint32_t _spidio4;
} BCM53128_A0_SPIDIO4r_t;

#define BCM53128_A0_SPIDIO4r_CLR(r) (r).spidio4[0] = 0
#define BCM53128_A0_SPIDIO4r_SET(r,d) (r).spidio4[0] = d
#define BCM53128_A0_SPIDIO4r_GET(r) (r).spidio4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO4r_RESERVEDf_GET(r) (((r).spidio4[0]) & 0xff)
#define BCM53128_A0_SPIDIO4r_RESERVEDf_SET(r,f) (r).spidio4[0]=(((r).spidio4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO4.
 *
 */
#define BCM53128_A0_READ_SPIDIO4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO4r,(r._spidio4),1)
#define BCM53128_A0_WRITE_SPIDIO4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO4r,&(r._spidio4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO4r BCM53128_A0_SPIDIO4r
#define SPIDIO4r_SIZE BCM53128_A0_SPIDIO4r_SIZE
typedef BCM53128_A0_SPIDIO4r_t SPIDIO4r_t;
#define SPIDIO4r_CLR BCM53128_A0_SPIDIO4r_CLR
#define SPIDIO4r_SET BCM53128_A0_SPIDIO4r_SET
#define SPIDIO4r_GET BCM53128_A0_SPIDIO4r_GET
#define SPIDIO4r_RESERVEDf_GET BCM53128_A0_SPIDIO4r_RESERVEDf_GET
#define SPIDIO4r_RESERVEDf_SET BCM53128_A0_SPIDIO4r_RESERVEDf_SET
#define READ_SPIDIO4r BCM53128_A0_READ_SPIDIO4r
#define WRITE_SPIDIO4r BCM53128_A0_WRITE_SPIDIO4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO5
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 5
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 5
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO5r 0x0000fff5

#define BCM53128_A0_SPIDIO5r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO5.
 *
 */
typedef union BCM53128_A0_SPIDIO5r_s {
	uint32_t v[1];
	uint32_t spidio5[1];
	uint32_t _spidio5;
} BCM53128_A0_SPIDIO5r_t;

#define BCM53128_A0_SPIDIO5r_CLR(r) (r).spidio5[0] = 0
#define BCM53128_A0_SPIDIO5r_SET(r,d) (r).spidio5[0] = d
#define BCM53128_A0_SPIDIO5r_GET(r) (r).spidio5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO5r_RESERVEDf_GET(r) (((r).spidio5[0]) & 0xff)
#define BCM53128_A0_SPIDIO5r_RESERVEDf_SET(r,f) (r).spidio5[0]=(((r).spidio5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO5.
 *
 */
#define BCM53128_A0_READ_SPIDIO5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO5r,(r._spidio5),1)
#define BCM53128_A0_WRITE_SPIDIO5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO5r,&(r._spidio5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO5r BCM53128_A0_SPIDIO5r
#define SPIDIO5r_SIZE BCM53128_A0_SPIDIO5r_SIZE
typedef BCM53128_A0_SPIDIO5r_t SPIDIO5r_t;
#define SPIDIO5r_CLR BCM53128_A0_SPIDIO5r_CLR
#define SPIDIO5r_SET BCM53128_A0_SPIDIO5r_SET
#define SPIDIO5r_GET BCM53128_A0_SPIDIO5r_GET
#define SPIDIO5r_RESERVEDf_GET BCM53128_A0_SPIDIO5r_RESERVEDf_GET
#define SPIDIO5r_RESERVEDf_SET BCM53128_A0_SPIDIO5r_RESERVEDf_SET
#define READ_SPIDIO5r BCM53128_A0_READ_SPIDIO5r
#define WRITE_SPIDIO5r BCM53128_A0_WRITE_SPIDIO5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO6
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 6
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 6
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO6r 0x0000fff6

#define BCM53128_A0_SPIDIO6r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO6.
 *
 */
typedef union BCM53128_A0_SPIDIO6r_s {
	uint32_t v[1];
	uint32_t spidio6[1];
	uint32_t _spidio6;
} BCM53128_A0_SPIDIO6r_t;

#define BCM53128_A0_SPIDIO6r_CLR(r) (r).spidio6[0] = 0
#define BCM53128_A0_SPIDIO6r_SET(r,d) (r).spidio6[0] = d
#define BCM53128_A0_SPIDIO6r_GET(r) (r).spidio6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO6r_RESERVEDf_GET(r) (((r).spidio6[0]) & 0xff)
#define BCM53128_A0_SPIDIO6r_RESERVEDf_SET(r,f) (r).spidio6[0]=(((r).spidio6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO6.
 *
 */
#define BCM53128_A0_READ_SPIDIO6r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO6r,(r._spidio6),1)
#define BCM53128_A0_WRITE_SPIDIO6r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO6r,&(r._spidio6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO6r BCM53128_A0_SPIDIO6r
#define SPIDIO6r_SIZE BCM53128_A0_SPIDIO6r_SIZE
typedef BCM53128_A0_SPIDIO6r_t SPIDIO6r_t;
#define SPIDIO6r_CLR BCM53128_A0_SPIDIO6r_CLR
#define SPIDIO6r_SET BCM53128_A0_SPIDIO6r_SET
#define SPIDIO6r_GET BCM53128_A0_SPIDIO6r_GET
#define SPIDIO6r_RESERVEDf_GET BCM53128_A0_SPIDIO6r_RESERVEDf_GET
#define SPIDIO6r_RESERVEDf_SET BCM53128_A0_SPIDIO6r_RESERVEDf_SET
#define READ_SPIDIO6r BCM53128_A0_READ_SPIDIO6r
#define WRITE_SPIDIO6r BCM53128_A0_WRITE_SPIDIO6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPIDIO7
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 7
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 7
 *
 ******************************************************************************/
#define BCM53128_A0_SPIDIO7r 0x0000fff7

#define BCM53128_A0_SPIDIO7r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO7.
 *
 */
typedef union BCM53128_A0_SPIDIO7r_s {
	uint32_t v[1];
	uint32_t spidio7[1];
	uint32_t _spidio7;
} BCM53128_A0_SPIDIO7r_t;

#define BCM53128_A0_SPIDIO7r_CLR(r) (r).spidio7[0] = 0
#define BCM53128_A0_SPIDIO7r_SET(r,d) (r).spidio7[0] = d
#define BCM53128_A0_SPIDIO7r_GET(r) (r).spidio7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPIDIO7r_RESERVEDf_GET(r) (((r).spidio7[0]) & 0xff)
#define BCM53128_A0_SPIDIO7r_RESERVEDf_SET(r,f) (r).spidio7[0]=(((r).spidio7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO7.
 *
 */
#define BCM53128_A0_READ_SPIDIO7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPIDIO7r,(r._spidio7),1)
#define BCM53128_A0_WRITE_SPIDIO7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPIDIO7r,&(r._spidio7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO7r BCM53128_A0_SPIDIO7r
#define SPIDIO7r_SIZE BCM53128_A0_SPIDIO7r_SIZE
typedef BCM53128_A0_SPIDIO7r_t SPIDIO7r_t;
#define SPIDIO7r_CLR BCM53128_A0_SPIDIO7r_CLR
#define SPIDIO7r_SET BCM53128_A0_SPIDIO7r_SET
#define SPIDIO7r_GET BCM53128_A0_SPIDIO7r_GET
#define SPIDIO7r_RESERVEDf_GET BCM53128_A0_SPIDIO7r_RESERVEDf_GET
#define SPIDIO7r_RESERVEDf_SET BCM53128_A0_SPIDIO7r_RESERVEDf_SET
#define READ_SPIDIO7r BCM53128_A0_READ_SPIDIO7r
#define WRITE_SPIDIO7r BCM53128_A0_WRITE_SPIDIO7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPIDIO7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPISTS
 * BLOCKS:   SPI
 * DESC:     SPI Status Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         bit[7](SPIF) : SPI Read/Write Complete Flagbit[6](RESERVED_1) : Reservedbit[5](RACK) : SPI Read Data Ready Acknowledgement(self-Cleaing)bit[4:0](RESERVED_0) : Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SPISTSr 0x0000fffe

#define BCM53128_A0_SPISTSr_SIZE 1

/*
 * This structure should be used to declare and program SPISTS.
 *
 */
typedef union BCM53128_A0_SPISTSr_s {
	uint32_t v[1];
	uint32_t spists[1];
	uint32_t _spists;
} BCM53128_A0_SPISTSr_t;

#define BCM53128_A0_SPISTSr_CLR(r) (r).spists[0] = 0
#define BCM53128_A0_SPISTSr_SET(r,d) (r).spists[0] = d
#define BCM53128_A0_SPISTSr_GET(r) (r).spists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPISTSr_RESERVEDf_GET(r) (((r).spists[0]) & 0xff)
#define BCM53128_A0_SPISTSr_RESERVEDf_SET(r,f) (r).spists[0]=(((r).spists[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPISTS.
 *
 */
#define BCM53128_A0_READ_SPISTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPISTSr,(r._spists),1)
#define BCM53128_A0_WRITE_SPISTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPISTSr,&(r._spists),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPISTSr BCM53128_A0_SPISTSr
#define SPISTSr_SIZE BCM53128_A0_SPISTSr_SIZE
typedef BCM53128_A0_SPISTSr_t SPISTSr_t;
#define SPISTSr_CLR BCM53128_A0_SPISTSr_CLR
#define SPISTSr_SET BCM53128_A0_SPISTSr_SET
#define SPISTSr_GET BCM53128_A0_SPISTSr_GET
#define SPISTSr_RESERVEDf_GET BCM53128_A0_SPISTSr_RESERVEDf_GET
#define SPISTSr_RESERVEDf_SET BCM53128_A0_SPISTSr_RESERVEDf_SET
#define READ_SPISTSr BCM53128_A0_READ_SPISTSr
#define WRITE_SPISTSr BCM53128_A0_WRITE_SPISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in seconds for dynamicallylearned address. Maximum age time is 1,048,575s. Note that while 802.1D specifies a range of values of 10 - 1,000,000 s, this register does not enforce this range. Setting the AGE_TIME to zero disables the aging process.
 *     AGE_CHANGE_EN    Set 1 to Change Aging Timer by AGE_TIME[19:0].
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SPTAGTr 0x00000206

#define BCM53128_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 *
 */
typedef union BCM53128_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM53128_A0_SPTAGTr_t;

#define BCM53128_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM53128_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM53128_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM53128_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53128_A0_SPTAGTr_AGE_CHANGE_ENf_GET(r) ((((r).sptagt[0]) >> 20) & 0x1)
#define BCM53128_A0_SPTAGTr_AGE_CHANGE_ENf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53128_A0_SPTAGTr_RESERVEDf_GET(r) ((((r).sptagt[0]) >> 21) & 0x7ff)
#define BCM53128_A0_SPTAGTr_RESERVEDf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access SPTAGT.
 *
 */
#define BCM53128_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPTAGTr,(r._sptagt),4)
#define BCM53128_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM53128_A0_SPTAGTr
#define SPTAGTr_SIZE BCM53128_A0_SPTAGTr_SIZE
typedef BCM53128_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM53128_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM53128_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM53128_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM53128_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM53128_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_AGE_CHANGE_ENf_GET BCM53128_A0_SPTAGTr_AGE_CHANGE_ENf_GET
#define SPTAGTr_AGE_CHANGE_ENf_SET BCM53128_A0_SPTAGTr_AGE_CHANGE_ENf_SET
#define SPTAGTr_RESERVEDf_GET BCM53128_A0_SPTAGTr_RESERVEDf_GET
#define SPTAGTr_RESERVEDf_SET BCM53128_A0_SPTAGTr_RESERVEDf_SET
#define READ_SPTAGTr BCM53128_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM53128_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPTAGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SPT_MULTI_ADDR_BPS_CTRL
 * BLOCKS:   SYS
 * DESC:     STP Multiport Address Bypass Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_BYPASS_SPT 1'b0: The MPORT_ADD0 will not be checked by SPT Status1'b1: The MPORT_ADD0 will  be checked by SPT Status
 *     EN_MPORT1_BYPASS_SPT 1'b0: The MPORT_ADD1 will not be checked by SPT Status1'b1: The MPORT_ADD1 will  be checked by SPT Status
 *     EN_MPORT2_BYPASS_SPT 1'b0: The MPORT_ADD2 will not be checked by SPT Status1'b1: The MPORT_ADD2 will  be checked by SPT Status
 *     EN_MPORT3_BYPASS_SPT 1'b0: The MPORT_ADD3 will not be checked by SPT Status1'b1: The MPORT_ADD3 will  be checked by SPT Status
 *     EN_MPORT4_BYPASS_SPT 1'b0: The MPORT_ADD4 will not be checked by SPT Status1'b1: The MPORT_ADD4 will  be checked by SPT Status
 *     EN_MPORT5_BYPASS_SPT 1'b0: The MPORT_ADD5 will not be checked by SPT Status1'b1: The MPORT_ADD5 will  be checked by SPT Status
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr 0x00004350

#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
typedef union BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_s {
	uint32_t v[1];
	uint32_t spt_multi_addr_bps_ctrl[1];
	uint32_t _spt_multi_addr_bps_ctrl;
} BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_t;

#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR(r) (r).spt_multi_addr_bps_ctrl[0] = 0
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET(r,d) (r).spt_multi_addr_bps_ctrl[0] = d
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET(r) (r).spt_multi_addr_bps_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET(r) (((r).spt_multi_addr_bps_ctrl[0]) & 0x1)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 5) & 0x1)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 6) & 0x3ff)
#define BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
#define BCM53128_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr,(r._spt_multi_addr_bps_ctrl),2)
#define BCM53128_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr,&(r._spt_multi_addr_bps_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPT_MULTI_ADDR_BPS_CTRLr BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr
#define SPT_MULTI_ADDR_BPS_CTRLr_SIZE BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE
typedef BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_t SPT_MULTI_ADDR_BPS_CTRLr_t;
#define SPT_MULTI_ADDR_BPS_CTRLr_CLR BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR
#define SPT_MULTI_ADDR_BPS_CTRLr_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET
#define READ_SPT_MULTI_ADDR_BPS_CTRLr BCM53128_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr
#define WRITE_SPT_MULTI_ADDR_BPS_CTRLr BCM53128_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SPT_MULTI_ADDR_BPS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRCADRCHG
 * BLOCKS:   SYS
 * DESC:     Source Address Change Register
 * SIZE:     16
 * FIELDS:
 *     SRC_ADDR_CHANGE  Source Address Change.9 bit field indicating that the value loaded into the Last Source Address register was not the same 48-bit value as the previous value. A 1 value indicates a dedicated link degment, a value greater than 1 generally indicates a mixing (repeatered) segment. Upon change of SA, a bit remains set until cleared by a read operation.0 = Source Address Constant1 = Source Address Changed
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SRCADRCHGr 0x0000010e

#define BCM53128_A0_SRCADRCHGr_SIZE 2

/*
 * This structure should be used to declare and program SRCADRCHG.
 *
 */
typedef union BCM53128_A0_SRCADRCHGr_s {
	uint32_t v[1];
	uint32_t srcadrchg[1];
	uint32_t _srcadrchg;
} BCM53128_A0_SRCADRCHGr_t;

#define BCM53128_A0_SRCADRCHGr_CLR(r) (r).srcadrchg[0] = 0
#define BCM53128_A0_SRCADRCHGr_SET(r,d) (r).srcadrchg[0] = d
#define BCM53128_A0_SRCADRCHGr_GET(r) (r).srcadrchg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET(r) (((r).srcadrchg[0]) & 0x1ff)
#define BCM53128_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_SRCADRCHGr_RESERVEDf_GET(r) ((((r).srcadrchg[0]) >> 9) & 0x7f)
#define BCM53128_A0_SRCADRCHGr_RESERVEDf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SRCADRCHG.
 *
 */
#define BCM53128_A0_READ_SRCADRCHGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRCADRCHGr,(r._srcadrchg),2)
#define BCM53128_A0_WRITE_SRCADRCHGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRCADRCHGr,&(r._srcadrchg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRCADRCHGr BCM53128_A0_SRCADRCHGr
#define SRCADRCHGr_SIZE BCM53128_A0_SRCADRCHGr_SIZE
typedef BCM53128_A0_SRCADRCHGr_t SRCADRCHGr_t;
#define SRCADRCHGr_CLR BCM53128_A0_SRCADRCHGr_CLR
#define SRCADRCHGr_SET BCM53128_A0_SRCADRCHGr_SET
#define SRCADRCHGr_GET BCM53128_A0_SRCADRCHGr_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_GET BCM53128_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_SET BCM53128_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET
#define SRCADRCHGr_RESERVEDf_GET BCM53128_A0_SRCADRCHGr_RESERVEDf_GET
#define SRCADRCHGr_RESERVEDf_SET BCM53128_A0_SRCADRCHGr_RESERVEDf_SET
#define READ_SRCADRCHGr BCM53128_A0_READ_SRCADRCHGr
#define WRITE_SRCADRCHGr BCM53128_A0_WRITE_SRCADRCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRCADRCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_CR
 * BLOCKS:   SYS
 * DESC:     Switch Register Interface Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_RW          Read/Write command=0, read=1, write
 *     SRIF_BEDN        Data Format=0, little-endian in Data Registers=1, big-endian in Data Registers
 *     RESERVED         Reserved.
 *     SRIF_START       Access Start Writing 1 starts the switch register access.  Hardware will clear this bit when the access is done.Reading this bit returns the status of the access.=1, busy.=0, done
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_CRr 0x0000ff21

#define BCM53128_A0_SRIF_CRr_SIZE 1

/*
 * This structure should be used to declare and program SRIF_CR.
 *
 */
typedef union BCM53128_A0_SRIF_CRr_s {
	uint32_t v[1];
	uint32_t srif_cr[1];
	uint32_t _srif_cr;
} BCM53128_A0_SRIF_CRr_t;

#define BCM53128_A0_SRIF_CRr_CLR(r) (r).srif_cr[0] = 0
#define BCM53128_A0_SRIF_CRr_SET(r,d) (r).srif_cr[0] = d
#define BCM53128_A0_SRIF_CRr_GET(r) (r).srif_cr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_CRr_SRIF_RWf_GET(r) (((r).srif_cr[0]) & 0x1)
#define BCM53128_A0_SRIF_CRr_SRIF_RWf_SET(r,f) (r).srif_cr[0]=(((r).srif_cr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SRIF_CRr_SRIF_BEDNf_GET(r) ((((r).srif_cr[0]) >> 1) & 0x1)
#define BCM53128_A0_SRIF_CRr_SRIF_BEDNf_SET(r,f) (r).srif_cr[0]=(((r).srif_cr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_SRIF_CRr_RESERVEDf_GET(r) ((((r).srif_cr[0]) >> 2) & 0x1f)
#define BCM53128_A0_SRIF_CRr_RESERVEDf_SET(r,f) (r).srif_cr[0]=(((r).srif_cr[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53128_A0_SRIF_CRr_SRIF_STARTf_GET(r) ((((r).srif_cr[0]) >> 7) & 0x1)
#define BCM53128_A0_SRIF_CRr_SRIF_STARTf_SET(r,f) (r).srif_cr[0]=(((r).srif_cr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SRIF_CR.
 *
 */
#define BCM53128_A0_READ_SRIF_CRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_CRr,(r._srif_cr),1)
#define BCM53128_A0_WRITE_SRIF_CRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_CRr,&(r._srif_cr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_CRr BCM53128_A0_SRIF_CRr
#define SRIF_CRr_SIZE BCM53128_A0_SRIF_CRr_SIZE
typedef BCM53128_A0_SRIF_CRr_t SRIF_CRr_t;
#define SRIF_CRr_CLR BCM53128_A0_SRIF_CRr_CLR
#define SRIF_CRr_SET BCM53128_A0_SRIF_CRr_SET
#define SRIF_CRr_GET BCM53128_A0_SRIF_CRr_GET
#define SRIF_CRr_SRIF_RWf_GET BCM53128_A0_SRIF_CRr_SRIF_RWf_GET
#define SRIF_CRr_SRIF_RWf_SET BCM53128_A0_SRIF_CRr_SRIF_RWf_SET
#define SRIF_CRr_SRIF_BEDNf_GET BCM53128_A0_SRIF_CRr_SRIF_BEDNf_GET
#define SRIF_CRr_SRIF_BEDNf_SET BCM53128_A0_SRIF_CRr_SRIF_BEDNf_SET
#define SRIF_CRr_RESERVEDf_GET BCM53128_A0_SRIF_CRr_RESERVEDf_GET
#define SRIF_CRr_RESERVEDf_SET BCM53128_A0_SRIF_CRr_RESERVEDf_SET
#define SRIF_CRr_SRIF_STARTf_GET BCM53128_A0_SRIF_CRr_SRIF_STARTf_GET
#define SRIF_CRr_SRIF_STARTf_SET BCM53128_A0_SRIF_CRr_SRIF_STARTf_SET
#define READ_SRIF_CRr BCM53128_A0_READ_SRIF_CRr
#define WRITE_SRIF_CRr BCM53128_A0_WRITE_SRIF_CRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_CRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR0
 * BLOCKS:   SYS
 * DESC:     Data Register 0 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR0         This field contains bits 7:0 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 63:56 
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR0r 0x0000ff24

#define BCM53128_A0_SRIF_DR0r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR0.
 *
 */
typedef union BCM53128_A0_SRIF_DR0r_s {
	uint32_t v[1];
	uint32_t srif_dr0[1];
	uint32_t _srif_dr0;
} BCM53128_A0_SRIF_DR0r_t;

#define BCM53128_A0_SRIF_DR0r_CLR(r) (r).srif_dr0[0] = 0
#define BCM53128_A0_SRIF_DR0r_SET(r,d) (r).srif_dr0[0] = d
#define BCM53128_A0_SRIF_DR0r_GET(r) (r).srif_dr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR0r_SRIF_DR0f_GET(r) (((r).srif_dr0[0]) & 0xff)
#define BCM53128_A0_SRIF_DR0r_SRIF_DR0f_SET(r,f) (r).srif_dr0[0]=(((r).srif_dr0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR0.
 *
 */
#define BCM53128_A0_READ_SRIF_DR0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR0r,(r._srif_dr0),1)
#define BCM53128_A0_WRITE_SRIF_DR0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR0r,&(r._srif_dr0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR0r BCM53128_A0_SRIF_DR0r
#define SRIF_DR0r_SIZE BCM53128_A0_SRIF_DR0r_SIZE
typedef BCM53128_A0_SRIF_DR0r_t SRIF_DR0r_t;
#define SRIF_DR0r_CLR BCM53128_A0_SRIF_DR0r_CLR
#define SRIF_DR0r_SET BCM53128_A0_SRIF_DR0r_SET
#define SRIF_DR0r_GET BCM53128_A0_SRIF_DR0r_GET
#define SRIF_DR0r_SRIF_DR0f_GET BCM53128_A0_SRIF_DR0r_SRIF_DR0f_GET
#define SRIF_DR0r_SRIF_DR0f_SET BCM53128_A0_SRIF_DR0r_SRIF_DR0f_SET
#define READ_SRIF_DR0r BCM53128_A0_READ_SRIF_DR0r
#define WRITE_SRIF_DR0r BCM53128_A0_WRITE_SRIF_DR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR1
 * BLOCKS:   SYS
 * DESC:     Data Register 1 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR1         This field contains bits 15:8 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 55:48
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR1r 0x0000ff25

#define BCM53128_A0_SRIF_DR1r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR1.
 *
 */
typedef union BCM53128_A0_SRIF_DR1r_s {
	uint32_t v[1];
	uint32_t srif_dr1[1];
	uint32_t _srif_dr1;
} BCM53128_A0_SRIF_DR1r_t;

#define BCM53128_A0_SRIF_DR1r_CLR(r) (r).srif_dr1[0] = 0
#define BCM53128_A0_SRIF_DR1r_SET(r,d) (r).srif_dr1[0] = d
#define BCM53128_A0_SRIF_DR1r_GET(r) (r).srif_dr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR1r_SRIF_DR1f_GET(r) (((r).srif_dr1[0]) & 0xff)
#define BCM53128_A0_SRIF_DR1r_SRIF_DR1f_SET(r,f) (r).srif_dr1[0]=(((r).srif_dr1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR1.
 *
 */
#define BCM53128_A0_READ_SRIF_DR1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR1r,(r._srif_dr1),1)
#define BCM53128_A0_WRITE_SRIF_DR1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR1r,&(r._srif_dr1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR1r BCM53128_A0_SRIF_DR1r
#define SRIF_DR1r_SIZE BCM53128_A0_SRIF_DR1r_SIZE
typedef BCM53128_A0_SRIF_DR1r_t SRIF_DR1r_t;
#define SRIF_DR1r_CLR BCM53128_A0_SRIF_DR1r_CLR
#define SRIF_DR1r_SET BCM53128_A0_SRIF_DR1r_SET
#define SRIF_DR1r_GET BCM53128_A0_SRIF_DR1r_GET
#define SRIF_DR1r_SRIF_DR1f_GET BCM53128_A0_SRIF_DR1r_SRIF_DR1f_GET
#define SRIF_DR1r_SRIF_DR1f_SET BCM53128_A0_SRIF_DR1r_SRIF_DR1f_SET
#define READ_SRIF_DR1r BCM53128_A0_READ_SRIF_DR1r
#define WRITE_SRIF_DR1r BCM53128_A0_WRITE_SRIF_DR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR2
 * BLOCKS:   SYS
 * DESC:     Data Register 2 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR2         This field contains bits 23:16 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 47:40
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR2r 0x0000ff26

#define BCM53128_A0_SRIF_DR2r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR2.
 *
 */
typedef union BCM53128_A0_SRIF_DR2r_s {
	uint32_t v[1];
	uint32_t srif_dr2[1];
	uint32_t _srif_dr2;
} BCM53128_A0_SRIF_DR2r_t;

#define BCM53128_A0_SRIF_DR2r_CLR(r) (r).srif_dr2[0] = 0
#define BCM53128_A0_SRIF_DR2r_SET(r,d) (r).srif_dr2[0] = d
#define BCM53128_A0_SRIF_DR2r_GET(r) (r).srif_dr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR2r_SRIF_DR2f_GET(r) (((r).srif_dr2[0]) & 0xff)
#define BCM53128_A0_SRIF_DR2r_SRIF_DR2f_SET(r,f) (r).srif_dr2[0]=(((r).srif_dr2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR2.
 *
 */
#define BCM53128_A0_READ_SRIF_DR2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR2r,(r._srif_dr2),1)
#define BCM53128_A0_WRITE_SRIF_DR2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR2r,&(r._srif_dr2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR2r BCM53128_A0_SRIF_DR2r
#define SRIF_DR2r_SIZE BCM53128_A0_SRIF_DR2r_SIZE
typedef BCM53128_A0_SRIF_DR2r_t SRIF_DR2r_t;
#define SRIF_DR2r_CLR BCM53128_A0_SRIF_DR2r_CLR
#define SRIF_DR2r_SET BCM53128_A0_SRIF_DR2r_SET
#define SRIF_DR2r_GET BCM53128_A0_SRIF_DR2r_GET
#define SRIF_DR2r_SRIF_DR2f_GET BCM53128_A0_SRIF_DR2r_SRIF_DR2f_GET
#define SRIF_DR2r_SRIF_DR2f_SET BCM53128_A0_SRIF_DR2r_SRIF_DR2f_SET
#define READ_SRIF_DR2r BCM53128_A0_READ_SRIF_DR2r
#define WRITE_SRIF_DR2r BCM53128_A0_WRITE_SRIF_DR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR3
 * BLOCKS:   SYS
 * DESC:     Data Register 3 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR3         This field contains bits 31:24 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 39:32
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR3r 0x0000ff27

#define BCM53128_A0_SRIF_DR3r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR3.
 *
 */
typedef union BCM53128_A0_SRIF_DR3r_s {
	uint32_t v[1];
	uint32_t srif_dr3[1];
	uint32_t _srif_dr3;
} BCM53128_A0_SRIF_DR3r_t;

#define BCM53128_A0_SRIF_DR3r_CLR(r) (r).srif_dr3[0] = 0
#define BCM53128_A0_SRIF_DR3r_SET(r,d) (r).srif_dr3[0] = d
#define BCM53128_A0_SRIF_DR3r_GET(r) (r).srif_dr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR3r_SRIF_DR3f_GET(r) (((r).srif_dr3[0]) & 0xff)
#define BCM53128_A0_SRIF_DR3r_SRIF_DR3f_SET(r,f) (r).srif_dr3[0]=(((r).srif_dr3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR3.
 *
 */
#define BCM53128_A0_READ_SRIF_DR3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR3r,(r._srif_dr3),1)
#define BCM53128_A0_WRITE_SRIF_DR3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR3r,&(r._srif_dr3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR3r BCM53128_A0_SRIF_DR3r
#define SRIF_DR3r_SIZE BCM53128_A0_SRIF_DR3r_SIZE
typedef BCM53128_A0_SRIF_DR3r_t SRIF_DR3r_t;
#define SRIF_DR3r_CLR BCM53128_A0_SRIF_DR3r_CLR
#define SRIF_DR3r_SET BCM53128_A0_SRIF_DR3r_SET
#define SRIF_DR3r_GET BCM53128_A0_SRIF_DR3r_GET
#define SRIF_DR3r_SRIF_DR3f_GET BCM53128_A0_SRIF_DR3r_SRIF_DR3f_GET
#define SRIF_DR3r_SRIF_DR3f_SET BCM53128_A0_SRIF_DR3r_SRIF_DR3f_SET
#define READ_SRIF_DR3r BCM53128_A0_READ_SRIF_DR3r
#define WRITE_SRIF_DR3r BCM53128_A0_WRITE_SRIF_DR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR4
 * BLOCKS:   SYS
 * DESC:     Data Register 4 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR4         This field contains bits 39:32 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 31:24
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR4r 0x0000ff28

#define BCM53128_A0_SRIF_DR4r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR4.
 *
 */
typedef union BCM53128_A0_SRIF_DR4r_s {
	uint32_t v[1];
	uint32_t srif_dr4[1];
	uint32_t _srif_dr4;
} BCM53128_A0_SRIF_DR4r_t;

#define BCM53128_A0_SRIF_DR4r_CLR(r) (r).srif_dr4[0] = 0
#define BCM53128_A0_SRIF_DR4r_SET(r,d) (r).srif_dr4[0] = d
#define BCM53128_A0_SRIF_DR4r_GET(r) (r).srif_dr4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR4r_SRIF_DR4f_GET(r) (((r).srif_dr4[0]) & 0xff)
#define BCM53128_A0_SRIF_DR4r_SRIF_DR4f_SET(r,f) (r).srif_dr4[0]=(((r).srif_dr4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR4.
 *
 */
#define BCM53128_A0_READ_SRIF_DR4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR4r,(r._srif_dr4),1)
#define BCM53128_A0_WRITE_SRIF_DR4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR4r,&(r._srif_dr4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR4r BCM53128_A0_SRIF_DR4r
#define SRIF_DR4r_SIZE BCM53128_A0_SRIF_DR4r_SIZE
typedef BCM53128_A0_SRIF_DR4r_t SRIF_DR4r_t;
#define SRIF_DR4r_CLR BCM53128_A0_SRIF_DR4r_CLR
#define SRIF_DR4r_SET BCM53128_A0_SRIF_DR4r_SET
#define SRIF_DR4r_GET BCM53128_A0_SRIF_DR4r_GET
#define SRIF_DR4r_SRIF_DR4f_GET BCM53128_A0_SRIF_DR4r_SRIF_DR4f_GET
#define SRIF_DR4r_SRIF_DR4f_SET BCM53128_A0_SRIF_DR4r_SRIF_DR4f_SET
#define READ_SRIF_DR4r BCM53128_A0_READ_SRIF_DR4r
#define WRITE_SRIF_DR4r BCM53128_A0_WRITE_SRIF_DR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR5
 * BLOCKS:   SYS
 * DESC:     Data Register 5 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR5         This field contains bits 47:40 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 23:16
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR5r 0x0000ff29

#define BCM53128_A0_SRIF_DR5r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR5.
 *
 */
typedef union BCM53128_A0_SRIF_DR5r_s {
	uint32_t v[1];
	uint32_t srif_dr5[1];
	uint32_t _srif_dr5;
} BCM53128_A0_SRIF_DR5r_t;

#define BCM53128_A0_SRIF_DR5r_CLR(r) (r).srif_dr5[0] = 0
#define BCM53128_A0_SRIF_DR5r_SET(r,d) (r).srif_dr5[0] = d
#define BCM53128_A0_SRIF_DR5r_GET(r) (r).srif_dr5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR5r_SRIF_DR5f_GET(r) (((r).srif_dr5[0]) & 0xff)
#define BCM53128_A0_SRIF_DR5r_SRIF_DR5f_SET(r,f) (r).srif_dr5[0]=(((r).srif_dr5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR5.
 *
 */
#define BCM53128_A0_READ_SRIF_DR5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR5r,(r._srif_dr5),1)
#define BCM53128_A0_WRITE_SRIF_DR5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR5r,&(r._srif_dr5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR5r BCM53128_A0_SRIF_DR5r
#define SRIF_DR5r_SIZE BCM53128_A0_SRIF_DR5r_SIZE
typedef BCM53128_A0_SRIF_DR5r_t SRIF_DR5r_t;
#define SRIF_DR5r_CLR BCM53128_A0_SRIF_DR5r_CLR
#define SRIF_DR5r_SET BCM53128_A0_SRIF_DR5r_SET
#define SRIF_DR5r_GET BCM53128_A0_SRIF_DR5r_GET
#define SRIF_DR5r_SRIF_DR5f_GET BCM53128_A0_SRIF_DR5r_SRIF_DR5f_GET
#define SRIF_DR5r_SRIF_DR5f_SET BCM53128_A0_SRIF_DR5r_SRIF_DR5f_SET
#define READ_SRIF_DR5r BCM53128_A0_READ_SRIF_DR5r
#define WRITE_SRIF_DR5r BCM53128_A0_WRITE_SRIF_DR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR6
 * BLOCKS:   SYS
 * DESC:     Data Register 6 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR6         This field contains bits 55:48 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 15:8
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR6r 0x0000ff2a

#define BCM53128_A0_SRIF_DR6r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR6.
 *
 */
typedef union BCM53128_A0_SRIF_DR6r_s {
	uint32_t v[1];
	uint32_t srif_dr6[1];
	uint32_t _srif_dr6;
} BCM53128_A0_SRIF_DR6r_t;

#define BCM53128_A0_SRIF_DR6r_CLR(r) (r).srif_dr6[0] = 0
#define BCM53128_A0_SRIF_DR6r_SET(r,d) (r).srif_dr6[0] = d
#define BCM53128_A0_SRIF_DR6r_GET(r) (r).srif_dr6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR6r_SRIF_DR6f_GET(r) (((r).srif_dr6[0]) & 0xff)
#define BCM53128_A0_SRIF_DR6r_SRIF_DR6f_SET(r,f) (r).srif_dr6[0]=(((r).srif_dr6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR6.
 *
 */
#define BCM53128_A0_READ_SRIF_DR6r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR6r,(r._srif_dr6),1)
#define BCM53128_A0_WRITE_SRIF_DR6r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR6r,&(r._srif_dr6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR6r BCM53128_A0_SRIF_DR6r
#define SRIF_DR6r_SIZE BCM53128_A0_SRIF_DR6r_SIZE
typedef BCM53128_A0_SRIF_DR6r_t SRIF_DR6r_t;
#define SRIF_DR6r_CLR BCM53128_A0_SRIF_DR6r_CLR
#define SRIF_DR6r_SET BCM53128_A0_SRIF_DR6r_SET
#define SRIF_DR6r_GET BCM53128_A0_SRIF_DR6r_GET
#define SRIF_DR6r_SRIF_DR6f_GET BCM53128_A0_SRIF_DR6r_SRIF_DR6f_GET
#define SRIF_DR6r_SRIF_DR6f_SET BCM53128_A0_SRIF_DR6r_SRIF_DR6f_SET
#define READ_SRIF_DR6r BCM53128_A0_READ_SRIF_DR6r
#define WRITE_SRIF_DR6r BCM53128_A0_WRITE_SRIF_DR6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_DR7
 * BLOCKS:   SYS
 * DESC:     Data Register 7 (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_DR7         This field contains bits 63:56 of 64-bit data format of switch register for little-endian, otherwise, it contains bits 7:0
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_DR7r 0x0000ff2b

#define BCM53128_A0_SRIF_DR7r_SIZE 1

/*
 * This structure should be used to declare and program SRIF_DR7.
 *
 */
typedef union BCM53128_A0_SRIF_DR7r_s {
	uint32_t v[1];
	uint32_t srif_dr7[1];
	uint32_t _srif_dr7;
} BCM53128_A0_SRIF_DR7r_t;

#define BCM53128_A0_SRIF_DR7r_CLR(r) (r).srif_dr7[0] = 0
#define BCM53128_A0_SRIF_DR7r_SET(r,d) (r).srif_dr7[0] = d
#define BCM53128_A0_SRIF_DR7r_GET(r) (r).srif_dr7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_DR7r_SRIF_DR7f_GET(r) (((r).srif_dr7[0]) & 0xff)
#define BCM53128_A0_SRIF_DR7r_SRIF_DR7f_SET(r,f) (r).srif_dr7[0]=(((r).srif_dr7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_DR7.
 *
 */
#define BCM53128_A0_READ_SRIF_DR7r(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_DR7r,(r._srif_dr7),1)
#define BCM53128_A0_WRITE_SRIF_DR7r(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_DR7r,&(r._srif_dr7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_DR7r BCM53128_A0_SRIF_DR7r
#define SRIF_DR7r_SIZE BCM53128_A0_SRIF_DR7r_SIZE
typedef BCM53128_A0_SRIF_DR7r_t SRIF_DR7r_t;
#define SRIF_DR7r_CLR BCM53128_A0_SRIF_DR7r_CLR
#define SRIF_DR7r_SET BCM53128_A0_SRIF_DR7r_SET
#define SRIF_DR7r_GET BCM53128_A0_SRIF_DR7r_GET
#define SRIF_DR7r_SRIF_DR7f_GET BCM53128_A0_SRIF_DR7r_SRIF_DR7f_GET
#define SRIF_DR7r_SRIF_DR7f_SET BCM53128_A0_SRIF_DR7r_SRIF_DR7f_SET
#define READ_SRIF_DR7r BCM53128_A0_READ_SRIF_DR7r
#define WRITE_SRIF_DR7r BCM53128_A0_WRITE_SRIF_DR7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_DR7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_OFFSR
 * BLOCKS:   SYS
 * DESC:     Offset Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_OFFSR       This field sets the offset address.
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_OFFSRr 0x0000ff23

#define BCM53128_A0_SRIF_OFFSRr_SIZE 1

/*
 * This structure should be used to declare and program SRIF_OFFSR.
 *
 */
typedef union BCM53128_A0_SRIF_OFFSRr_s {
	uint32_t v[1];
	uint32_t srif_offsr[1];
	uint32_t _srif_offsr;
} BCM53128_A0_SRIF_OFFSRr_t;

#define BCM53128_A0_SRIF_OFFSRr_CLR(r) (r).srif_offsr[0] = 0
#define BCM53128_A0_SRIF_OFFSRr_SET(r,d) (r).srif_offsr[0] = d
#define BCM53128_A0_SRIF_OFFSRr_GET(r) (r).srif_offsr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_OFFSRr_SRIF_OFFSRf_GET(r) (((r).srif_offsr[0]) & 0xff)
#define BCM53128_A0_SRIF_OFFSRr_SRIF_OFFSRf_SET(r,f) (r).srif_offsr[0]=(((r).srif_offsr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_OFFSR.
 *
 */
#define BCM53128_A0_READ_SRIF_OFFSRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_OFFSRr,(r._srif_offsr),1)
#define BCM53128_A0_WRITE_SRIF_OFFSRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_OFFSRr,&(r._srif_offsr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_OFFSRr BCM53128_A0_SRIF_OFFSRr
#define SRIF_OFFSRr_SIZE BCM53128_A0_SRIF_OFFSRr_SIZE
typedef BCM53128_A0_SRIF_OFFSRr_t SRIF_OFFSRr_t;
#define SRIF_OFFSRr_CLR BCM53128_A0_SRIF_OFFSRr_CLR
#define SRIF_OFFSRr_SET BCM53128_A0_SRIF_OFFSRr_SET
#define SRIF_OFFSRr_GET BCM53128_A0_SRIF_OFFSRr_GET
#define SRIF_OFFSRr_SRIF_OFFSRf_GET BCM53128_A0_SRIF_OFFSRr_SRIF_OFFSRf_GET
#define SRIF_OFFSRr_SRIF_OFFSRf_SET BCM53128_A0_SRIF_OFFSRr_SRIF_OFFSRf_SET
#define READ_SRIF_OFFSRr BCM53128_A0_READ_SRIF_OFFSRr
#define WRITE_SRIF_OFFSRr BCM53128_A0_WRITE_SRIF_OFFSRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_OFFSRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SRIF_PAGER
 * BLOCKS:   SYS
 * DESC:     Page Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SRIF_PAGER       Note: The SPI related registers (0xF0-0xFF) are not available.This field sets the page address.
 *
 ******************************************************************************/
#define BCM53128_A0_SRIF_PAGERr 0x0000ff22

#define BCM53128_A0_SRIF_PAGERr_SIZE 1

/*
 * This structure should be used to declare and program SRIF_PAGER.
 *
 */
typedef union BCM53128_A0_SRIF_PAGERr_s {
	uint32_t v[1];
	uint32_t srif_pager[1];
	uint32_t _srif_pager;
} BCM53128_A0_SRIF_PAGERr_t;

#define BCM53128_A0_SRIF_PAGERr_CLR(r) (r).srif_pager[0] = 0
#define BCM53128_A0_SRIF_PAGERr_SET(r,d) (r).srif_pager[0] = d
#define BCM53128_A0_SRIF_PAGERr_GET(r) (r).srif_pager[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SRIF_PAGERr_SRIF_PAGERf_GET(r) (((r).srif_pager[0]) & 0xff)
#define BCM53128_A0_SRIF_PAGERr_SRIF_PAGERf_SET(r,f) (r).srif_pager[0]=(((r).srif_pager[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SRIF_PAGER.
 *
 */
#define BCM53128_A0_READ_SRIF_PAGERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SRIF_PAGERr,(r._srif_pager),1)
#define BCM53128_A0_WRITE_SRIF_PAGERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SRIF_PAGERr,&(r._srif_pager),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRIF_PAGERr BCM53128_A0_SRIF_PAGERr
#define SRIF_PAGERr_SIZE BCM53128_A0_SRIF_PAGERr_SIZE
typedef BCM53128_A0_SRIF_PAGERr_t SRIF_PAGERr_t;
#define SRIF_PAGERr_CLR BCM53128_A0_SRIF_PAGERr_CLR
#define SRIF_PAGERr_SET BCM53128_A0_SRIF_PAGERr_SET
#define SRIF_PAGERr_GET BCM53128_A0_SRIF_PAGERr_GET
#define SRIF_PAGERr_SRIF_PAGERf_GET BCM53128_A0_SRIF_PAGERr_SRIF_PAGERf_GET
#define SRIF_PAGERr_SRIF_PAGERf_SET BCM53128_A0_SRIF_PAGERr_SRIF_PAGERf_SET
#define READ_SRIF_PAGERr BCM53128_A0_READ_SRIF_PAGERr
#define WRITE_SRIF_PAGERr BCM53128_A0_WRITE_SRIF_PAGERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SRIF_PAGERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  STRAP_PIN_STATUS
 * BLOCKS:   SYS
 * DESC:     Strap Pin Status Register (Not2Release)
 * SIZE:     48
 * FIELDS:
 *     BC_SUPP_EN       bc_supp_en_strap,
 *     BIST_CLRMEM      bist_clrmem_sel,
 *     SYSFREQ          clock freq[1:0],
 *     CPU_EPROM        cpu_eprom_sel,
 *     EN_CLK25_OUT     enable clk25 outout.
 *     EN_CLK50_OUT     enable clk50 outout.
 *     DIS_IMP          
 *     ENEXTCLK         enextclk.
 *     EN_LPDET         
 *     ENFDXFLOW        enfdxflow,
 *     ENHDXFLOW        enhdxflow,
 *     EEPROM_TYPE      eprom_type[1:0],
 *     IMP_TXC_DELAY    
 *     IMP_RXC_DELAY    
 *     HW_FWDG_EN       hw_fwdg_en,
 *     IMP_MODE         IMP mode,
 *     LEDMODE          ledmode[1:0],
 *     LP_IMP_SEL       
 *     MII_DUMP_FWDG    
 *     SKIP_SRAMBIST    skip_srambist,
 *     WD_CLR_EN        bypass_imp_2ns_del,
 *     GREEN_EN         strap_en_green,
 *     GMII_MODE        GMII mode,
 *     GMII_VOL_SEL     GMII voltage select,
 *     EN_EEE           Enable EEE capability,
 *     EN_8051_TXRX     Enable 8051 TX/RX,
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_STRAP_PIN_STATUSr 0x00000170

#define BCM53128_A0_STRAP_PIN_STATUSr_SIZE 6

/*
 * This structure should be used to declare and program STRAP_PIN_STATUS.
 *
 */
typedef union BCM53128_A0_STRAP_PIN_STATUSr_s {
	uint32_t v[2];
	uint32_t strap_pin_status[2];
	uint32_t _strap_pin_status;
} BCM53128_A0_STRAP_PIN_STATUSr_t;

#define BCM53128_A0_STRAP_PIN_STATUSr_CLR(r) CDK_MEMSET(&((r)._strap_pin_status), 0, sizeof(BCM53128_A0_STRAP_PIN_STATUSr_t))
#define BCM53128_A0_STRAP_PIN_STATUSr_SET(r,i,d) (r).strap_pin_status[i] = d
#define BCM53128_A0_STRAP_PIN_STATUSr_GET(r,i) (r).strap_pin_status[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_STRAP_PIN_STATUSr_BC_SUPP_ENf_GET(r) (((r).strap_pin_status[0]) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_BC_SUPP_ENf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_STRAP_PIN_STATUSr_BIST_CLRMEMf_GET(r) ((((r).strap_pin_status[0]) >> 1) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_BIST_CLRMEMf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_STRAP_PIN_STATUSr_SYSFREQf_GET(r) ((((r).strap_pin_status[0]) >> 2) & 0x3)
#define BCM53128_A0_STRAP_PIN_STATUSr_SYSFREQf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_STRAP_PIN_STATUSr_CPU_EPROMf_GET(r) ((((r).strap_pin_status[0]) >> 4) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_CPU_EPROMf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK25_OUTf_GET(r) ((((r).strap_pin_status[0]) >> 5) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK25_OUTf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK50_OUTf_GET(r) ((((r).strap_pin_status[0]) >> 6) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK50_OUTf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_STRAP_PIN_STATUSr_DIS_IMPf_GET(r) ((((r).strap_pin_status[0]) >> 7) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_DIS_IMPf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_STRAP_PIN_STATUSr_ENEXTCLKf_GET(r) ((((r).strap_pin_status[0]) >> 8) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_ENEXTCLKf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_LPDETf_GET(r) ((((r).strap_pin_status[0]) >> 9) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_LPDETf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_STRAP_PIN_STATUSr_ENFDXFLOWf_GET(r) ((((r).strap_pin_status[0]) >> 10) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_ENFDXFLOWf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_STRAP_PIN_STATUSr_ENHDXFLOWf_GET(r) ((((r).strap_pin_status[0]) >> 11) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_ENHDXFLOWf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_STRAP_PIN_STATUSr_EEPROM_TYPEf_GET(r) ((((r).strap_pin_status[0]) >> 12) & 0x3)
#define BCM53128_A0_STRAP_PIN_STATUSr_EEPROM_TYPEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53128_A0_STRAP_PIN_STATUSr_IMP_TXC_DELAYf_GET(r) ((((r).strap_pin_status[0]) >> 14) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_IMP_TXC_DELAYf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53128_A0_STRAP_PIN_STATUSr_IMP_RXC_DELAYf_GET(r) ((((r).strap_pin_status[0]) >> 15) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_IMP_RXC_DELAYf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53128_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_GET(r) ((((r).strap_pin_status[0]) >> 16) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53128_A0_STRAP_PIN_STATUSr_IMP_MODEf_GET(r) ((((r).strap_pin_status[0]) >> 17) & 0x3)
#define BCM53128_A0_STRAP_PIN_STATUSr_IMP_MODEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53128_A0_STRAP_PIN_STATUSr_LEDMODEf_GET(r) ((((r).strap_pin_status[0]) >> 19) & 0x3)
#define BCM53128_A0_STRAP_PIN_STATUSr_LEDMODEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53128_A0_STRAP_PIN_STATUSr_LP_IMP_SELf_GET(r) ((((r).strap_pin_status[0]) >> 21) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_LP_IMP_SELf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53128_A0_STRAP_PIN_STATUSr_MII_DUMP_FWDGf_GET(r) ((((r).strap_pin_status[0]) >> 22) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_MII_DUMP_FWDGf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53128_A0_STRAP_PIN_STATUSr_SKIP_SRAMBISTf_GET(r) ((((r).strap_pin_status[0]) >> 23) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_SKIP_SRAMBISTf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53128_A0_STRAP_PIN_STATUSr_WD_CLR_ENf_GET(r) ((((r).strap_pin_status[0]) >> 24) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_WD_CLR_ENf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53128_A0_STRAP_PIN_STATUSr_GREEN_ENf_GET(r) ((((r).strap_pin_status[0]) >> 25) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_GREEN_ENf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53128_A0_STRAP_PIN_STATUSr_GMII_MODEf_GET(r) ((((r).strap_pin_status[0]) >> 26) & 0x3)
#define BCM53128_A0_STRAP_PIN_STATUSr_GMII_MODEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53128_A0_STRAP_PIN_STATUSr_GMII_VOL_SELf_GET(r) ((((r).strap_pin_status[0]) >> 28) & 0x3)
#define BCM53128_A0_STRAP_PIN_STATUSr_GMII_VOL_SELf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_EEEf_GET(r) ((((r).strap_pin_status[0]) >> 30) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_EEEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_8051_TXRXf_GET(r) ((((r).strap_pin_status[0]) >> 31) & 0x1)
#define BCM53128_A0_STRAP_PIN_STATUSr_EN_8051_TXRXf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53128_A0_STRAP_PIN_STATUSr_RESERVEDf_GET(r) (((r).strap_pin_status[1]) & 0xffff)
#define BCM53128_A0_STRAP_PIN_STATUSr_RESERVEDf_SET(r,f) (r).strap_pin_status[1]=(((r).strap_pin_status[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access STRAP_PIN_STATUS.
 *
 */
#define BCM53128_A0_READ_STRAP_PIN_STATUSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_STRAP_PIN_STATUSr,(r._strap_pin_status),6)
#define BCM53128_A0_WRITE_STRAP_PIN_STATUSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_STRAP_PIN_STATUSr,&(r._strap_pin_status),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_PIN_STATUSr BCM53128_A0_STRAP_PIN_STATUSr
#define STRAP_PIN_STATUSr_SIZE BCM53128_A0_STRAP_PIN_STATUSr_SIZE
typedef BCM53128_A0_STRAP_PIN_STATUSr_t STRAP_PIN_STATUSr_t;
#define STRAP_PIN_STATUSr_CLR BCM53128_A0_STRAP_PIN_STATUSr_CLR
#define STRAP_PIN_STATUSr_SET BCM53128_A0_STRAP_PIN_STATUSr_SET
#define STRAP_PIN_STATUSr_GET BCM53128_A0_STRAP_PIN_STATUSr_GET
#define STRAP_PIN_STATUSr_BC_SUPP_ENf_GET BCM53128_A0_STRAP_PIN_STATUSr_BC_SUPP_ENf_GET
#define STRAP_PIN_STATUSr_BC_SUPP_ENf_SET BCM53128_A0_STRAP_PIN_STATUSr_BC_SUPP_ENf_SET
#define STRAP_PIN_STATUSr_BIST_CLRMEMf_GET BCM53128_A0_STRAP_PIN_STATUSr_BIST_CLRMEMf_GET
#define STRAP_PIN_STATUSr_BIST_CLRMEMf_SET BCM53128_A0_STRAP_PIN_STATUSr_BIST_CLRMEMf_SET
#define STRAP_PIN_STATUSr_SYSFREQf_GET BCM53128_A0_STRAP_PIN_STATUSr_SYSFREQf_GET
#define STRAP_PIN_STATUSr_SYSFREQf_SET BCM53128_A0_STRAP_PIN_STATUSr_SYSFREQf_SET
#define STRAP_PIN_STATUSr_CPU_EPROMf_GET BCM53128_A0_STRAP_PIN_STATUSr_CPU_EPROMf_GET
#define STRAP_PIN_STATUSr_CPU_EPROMf_SET BCM53128_A0_STRAP_PIN_STATUSr_CPU_EPROMf_SET
#define STRAP_PIN_STATUSr_EN_CLK25_OUTf_GET BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK25_OUTf_GET
#define STRAP_PIN_STATUSr_EN_CLK25_OUTf_SET BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK25_OUTf_SET
#define STRAP_PIN_STATUSr_EN_CLK50_OUTf_GET BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK50_OUTf_GET
#define STRAP_PIN_STATUSr_EN_CLK50_OUTf_SET BCM53128_A0_STRAP_PIN_STATUSr_EN_CLK50_OUTf_SET
#define STRAP_PIN_STATUSr_DIS_IMPf_GET BCM53128_A0_STRAP_PIN_STATUSr_DIS_IMPf_GET
#define STRAP_PIN_STATUSr_DIS_IMPf_SET BCM53128_A0_STRAP_PIN_STATUSr_DIS_IMPf_SET
#define STRAP_PIN_STATUSr_ENEXTCLKf_GET BCM53128_A0_STRAP_PIN_STATUSr_ENEXTCLKf_GET
#define STRAP_PIN_STATUSr_ENEXTCLKf_SET BCM53128_A0_STRAP_PIN_STATUSr_ENEXTCLKf_SET
#define STRAP_PIN_STATUSr_EN_LPDETf_GET BCM53128_A0_STRAP_PIN_STATUSr_EN_LPDETf_GET
#define STRAP_PIN_STATUSr_EN_LPDETf_SET BCM53128_A0_STRAP_PIN_STATUSr_EN_LPDETf_SET
#define STRAP_PIN_STATUSr_ENFDXFLOWf_GET BCM53128_A0_STRAP_PIN_STATUSr_ENFDXFLOWf_GET
#define STRAP_PIN_STATUSr_ENFDXFLOWf_SET BCM53128_A0_STRAP_PIN_STATUSr_ENFDXFLOWf_SET
#define STRAP_PIN_STATUSr_ENHDXFLOWf_GET BCM53128_A0_STRAP_PIN_STATUSr_ENHDXFLOWf_GET
#define STRAP_PIN_STATUSr_ENHDXFLOWf_SET BCM53128_A0_STRAP_PIN_STATUSr_ENHDXFLOWf_SET
#define STRAP_PIN_STATUSr_EEPROM_TYPEf_GET BCM53128_A0_STRAP_PIN_STATUSr_EEPROM_TYPEf_GET
#define STRAP_PIN_STATUSr_EEPROM_TYPEf_SET BCM53128_A0_STRAP_PIN_STATUSr_EEPROM_TYPEf_SET
#define STRAP_PIN_STATUSr_IMP_TXC_DELAYf_GET BCM53128_A0_STRAP_PIN_STATUSr_IMP_TXC_DELAYf_GET
#define STRAP_PIN_STATUSr_IMP_TXC_DELAYf_SET BCM53128_A0_STRAP_PIN_STATUSr_IMP_TXC_DELAYf_SET
#define STRAP_PIN_STATUSr_IMP_RXC_DELAYf_GET BCM53128_A0_STRAP_PIN_STATUSr_IMP_RXC_DELAYf_GET
#define STRAP_PIN_STATUSr_IMP_RXC_DELAYf_SET BCM53128_A0_STRAP_PIN_STATUSr_IMP_RXC_DELAYf_SET
#define STRAP_PIN_STATUSr_HW_FWDG_ENf_GET BCM53128_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_GET
#define STRAP_PIN_STATUSr_HW_FWDG_ENf_SET BCM53128_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_SET
#define STRAP_PIN_STATUSr_IMP_MODEf_GET BCM53128_A0_STRAP_PIN_STATUSr_IMP_MODEf_GET
#define STRAP_PIN_STATUSr_IMP_MODEf_SET BCM53128_A0_STRAP_PIN_STATUSr_IMP_MODEf_SET
#define STRAP_PIN_STATUSr_LEDMODEf_GET BCM53128_A0_STRAP_PIN_STATUSr_LEDMODEf_GET
#define STRAP_PIN_STATUSr_LEDMODEf_SET BCM53128_A0_STRAP_PIN_STATUSr_LEDMODEf_SET
#define STRAP_PIN_STATUSr_LP_IMP_SELf_GET BCM53128_A0_STRAP_PIN_STATUSr_LP_IMP_SELf_GET
#define STRAP_PIN_STATUSr_LP_IMP_SELf_SET BCM53128_A0_STRAP_PIN_STATUSr_LP_IMP_SELf_SET
#define STRAP_PIN_STATUSr_MII_DUMP_FWDGf_GET BCM53128_A0_STRAP_PIN_STATUSr_MII_DUMP_FWDGf_GET
#define STRAP_PIN_STATUSr_MII_DUMP_FWDGf_SET BCM53128_A0_STRAP_PIN_STATUSr_MII_DUMP_FWDGf_SET
#define STRAP_PIN_STATUSr_SKIP_SRAMBISTf_GET BCM53128_A0_STRAP_PIN_STATUSr_SKIP_SRAMBISTf_GET
#define STRAP_PIN_STATUSr_SKIP_SRAMBISTf_SET BCM53128_A0_STRAP_PIN_STATUSr_SKIP_SRAMBISTf_SET
#define STRAP_PIN_STATUSr_WD_CLR_ENf_GET BCM53128_A0_STRAP_PIN_STATUSr_WD_CLR_ENf_GET
#define STRAP_PIN_STATUSr_WD_CLR_ENf_SET BCM53128_A0_STRAP_PIN_STATUSr_WD_CLR_ENf_SET
#define STRAP_PIN_STATUSr_GREEN_ENf_GET BCM53128_A0_STRAP_PIN_STATUSr_GREEN_ENf_GET
#define STRAP_PIN_STATUSr_GREEN_ENf_SET BCM53128_A0_STRAP_PIN_STATUSr_GREEN_ENf_SET
#define STRAP_PIN_STATUSr_GMII_MODEf_GET BCM53128_A0_STRAP_PIN_STATUSr_GMII_MODEf_GET
#define STRAP_PIN_STATUSr_GMII_MODEf_SET BCM53128_A0_STRAP_PIN_STATUSr_GMII_MODEf_SET
#define STRAP_PIN_STATUSr_GMII_VOL_SELf_GET BCM53128_A0_STRAP_PIN_STATUSr_GMII_VOL_SELf_GET
#define STRAP_PIN_STATUSr_GMII_VOL_SELf_SET BCM53128_A0_STRAP_PIN_STATUSr_GMII_VOL_SELf_SET
#define STRAP_PIN_STATUSr_EN_EEEf_GET BCM53128_A0_STRAP_PIN_STATUSr_EN_EEEf_GET
#define STRAP_PIN_STATUSr_EN_EEEf_SET BCM53128_A0_STRAP_PIN_STATUSr_EN_EEEf_SET
#define STRAP_PIN_STATUSr_EN_8051_TXRXf_GET BCM53128_A0_STRAP_PIN_STATUSr_EN_8051_TXRXf_GET
#define STRAP_PIN_STATUSr_EN_8051_TXRXf_SET BCM53128_A0_STRAP_PIN_STATUSr_EN_8051_TXRXf_SET
#define STRAP_PIN_STATUSr_RESERVEDf_GET BCM53128_A0_STRAP_PIN_STATUSr_RESERVEDf_GET
#define STRAP_PIN_STATUSr_RESERVEDf_SET BCM53128_A0_STRAP_PIN_STATUSr_RESERVEDf_SET
#define READ_STRAP_PIN_STATUSr BCM53128_A0_READ_STRAP_PIN_STATUSr
#define WRITE_STRAP_PIN_STATUSr BCM53128_A0_WRITE_STRAP_PIN_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_STRAP_PIN_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  STS_OVERRIDE_GMIIP
 * BLOCKS:   GPIC0
 * DESC:     Port N States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Software Port Speed setting2'b10 : 1000M2'b01 : 100M2'b00 : 10M2'b11 : 200Mbps(for Port 7 and IMP Port TMII mode only) 
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_OVERRIDE      CPU set software Override bit to 1 to make bit [5:0] affected.PHY scan register will be override.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_STS_OVERRIDE_GMIIPr 0x00000058

#define BCM53128_A0_STS_OVERRIDE_GMIIPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GMIIP.
 *
 */
typedef union BCM53128_A0_STS_OVERRIDE_GMIIPr_s {
	uint32_t v[1];
	uint32_t sts_override_gmiip[1];
	uint32_t _sts_override_gmiip;
} BCM53128_A0_STS_OVERRIDE_GMIIPr_t;

#define BCM53128_A0_STS_OVERRIDE_GMIIPr_CLR(r) (r).sts_override_gmiip[0] = 0
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_SET(r,d) (r).sts_override_gmiip[0] = d
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_GET(r) (r).sts_override_gmiip[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET(r) (((r).sts_override_gmiip[0]) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gmiip[0]) >> 1) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_SPEEDf_GET(r) ((((r).sts_override_gmiip[0]) >> 2) & 0x3)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_SPEEDf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 4) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 5) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET(r) ((((r).sts_override_gmiip[0]) >> 6) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_GET(r) ((((r).sts_override_gmiip[0]) >> 7) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GMIIP.
 *
 */
#define BCM53128_A0_READ_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_STS_OVERRIDE_GMIIPr,(r._sts_override_gmiip),1)
#define BCM53128_A0_WRITE_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_STS_OVERRIDE_GMIIPr,&(r._sts_override_gmiip),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GMIIPr BCM53128_A0_STS_OVERRIDE_GMIIPr
#define STS_OVERRIDE_GMIIPr_SIZE BCM53128_A0_STS_OVERRIDE_GMIIPr_SIZE
typedef BCM53128_A0_STS_OVERRIDE_GMIIPr_t STS_OVERRIDE_GMIIPr_t;
#define STS_OVERRIDE_GMIIPr_CLR BCM53128_A0_STS_OVERRIDE_GMIIPr_CLR
#define STS_OVERRIDE_GMIIPr_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_SET
#define STS_OVERRIDE_GMIIPr_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GMIIPr_SPEEDf_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_SPEEDf_GET
#define STS_OVERRIDE_GMIIPr_SPEEDf_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_SPEEDf_SET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET
#define STS_OVERRIDE_GMIIPr_RESERVED_1f_GET BCM53128_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_GET
#define STS_OVERRIDE_GMIIPr_RESERVED_1f_SET BCM53128_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_SET
#define READ_STS_OVERRIDE_GMIIPr BCM53128_A0_READ_STS_OVERRIDE_GMIIPr
#define WRITE_STS_OVERRIDE_GMIIPr BCM53128_A0_WRITE_STS_OVERRIDE_GMIIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_STS_OVERRIDE_GMIIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status0: Link fail1: Link pass
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Speed00: 10 Mbps01: 100 Mbps10: 1000Mbps11: 200Mbps(for TMII mode only)
 *     RXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     TXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     RESERVED_1       Reserved
 *     MII_SW_OR        MII Software Override0: Use MII hardware pin status1: Use contents of this register
 *
 ******************************************************************************/
#define BCM53128_A0_STS_OVERRIDE_IMPr 0x0000000e

#define BCM53128_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 *
 */
typedef union BCM53128_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM53128_A0_STS_OVERRIDE_IMPr_t;

#define BCM53128_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM53128_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM53128_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_STS_OVERRIDE_IMPr_SPEEDf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM53128_A0_STS_OVERRIDE_IMPr_SPEEDf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_STS_OVERRIDE_IMPr_RESERVED_1f_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_IMPr_RESERVED_1f_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM53128_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 *
 */
#define BCM53128_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM53128_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM53128_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM53128_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM53128_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM53128_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM53128_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM53128_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM53128_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM53128_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM53128_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM53128_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_SPEEDf_GET BCM53128_A0_STS_OVERRIDE_IMPr_SPEEDf_GET
#define STS_OVERRIDE_IMPr_SPEEDf_SET BCM53128_A0_STS_OVERRIDE_IMPr_SPEEDf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM53128_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM53128_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET BCM53128_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET BCM53128_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_RESERVED_1f_GET BCM53128_A0_STS_OVERRIDE_IMPr_RESERVED_1f_GET
#define STS_OVERRIDE_IMPr_RESERVED_1f_SET BCM53128_A0_STS_OVERRIDE_IMPr_RESERVED_1f_SET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_GET BCM53128_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_SET BCM53128_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET
#define READ_STS_OVERRIDE_IMPr BCM53128_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM53128_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_STS_OVERRIDE_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SUBS_CSSR
 * BLOCKS:   SYS
 * DESC:     Code Segment Select Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SUBS_CSSR0       This bit is decided by HW if SF is detected, or controlled by external CPU when code downloaded from MEM registers.=0, from ROM=1, from RAMcontrols address space of 0x0000~0x1FFF
 *     SUBS_CSSR        Each bit controls the program source.=0, from ROM=1, from RAM (default)[7]: controls address space of 0xE000~0xFFFF[6]: controls address space of 0xC000~0xDFFF[5]: controls address space of 0xA000~0xBFFF[4]: controls address space of 0x8000~0x9FFF[3]: controls address space of 0x6000~0x7FFF[2]: controls address space of 0x4000~0x5FFF[1]: controls address space of 0x2000~0x3FFFNote that these bits are valid only if bit 0 is 1.
 *
 ******************************************************************************/
#define BCM53128_A0_SUBS_CSSRr 0x0000ff32

#define BCM53128_A0_SUBS_CSSRr_SIZE 1

/*
 * This structure should be used to declare and program SUBS_CSSR.
 *
 */
typedef union BCM53128_A0_SUBS_CSSRr_s {
	uint32_t v[1];
	uint32_t subs_cssr[1];
	uint32_t _subs_cssr;
} BCM53128_A0_SUBS_CSSRr_t;

#define BCM53128_A0_SUBS_CSSRr_CLR(r) (r).subs_cssr[0] = 0
#define BCM53128_A0_SUBS_CSSRr_SET(r,d) (r).subs_cssr[0] = d
#define BCM53128_A0_SUBS_CSSRr_GET(r) (r).subs_cssr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SUBS_CSSRr_SUBS_CSSR0f_GET(r) (((r).subs_cssr[0]) & 0x1)
#define BCM53128_A0_SUBS_CSSRr_SUBS_CSSR0f_SET(r,f) (r).subs_cssr[0]=(((r).subs_cssr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SUBS_CSSRr_SUBS_CSSRf_GET(r) ((((r).subs_cssr[0]) >> 1) & 0x7f)
#define BCM53128_A0_SUBS_CSSRr_SUBS_CSSRf_SET(r,f) (r).subs_cssr[0]=(((r).subs_cssr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access SUBS_CSSR.
 *
 */
#define BCM53128_A0_READ_SUBS_CSSRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SUBS_CSSRr,(r._subs_cssr),1)
#define BCM53128_A0_WRITE_SUBS_CSSRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SUBS_CSSRr,&(r._subs_cssr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SUBS_CSSRr BCM53128_A0_SUBS_CSSRr
#define SUBS_CSSRr_SIZE BCM53128_A0_SUBS_CSSRr_SIZE
typedef BCM53128_A0_SUBS_CSSRr_t SUBS_CSSRr_t;
#define SUBS_CSSRr_CLR BCM53128_A0_SUBS_CSSRr_CLR
#define SUBS_CSSRr_SET BCM53128_A0_SUBS_CSSRr_SET
#define SUBS_CSSRr_GET BCM53128_A0_SUBS_CSSRr_GET
#define SUBS_CSSRr_SUBS_CSSR0f_GET BCM53128_A0_SUBS_CSSRr_SUBS_CSSR0f_GET
#define SUBS_CSSRr_SUBS_CSSR0f_SET BCM53128_A0_SUBS_CSSRr_SUBS_CSSR0f_SET
#define SUBS_CSSRr_SUBS_CSSRf_GET BCM53128_A0_SUBS_CSSRr_SUBS_CSSRf_GET
#define SUBS_CSSRr_SUBS_CSSRf_SET BCM53128_A0_SUBS_CSSRr_SUBS_CSSRf_SET
#define READ_SUBS_CSSRr BCM53128_A0_READ_SUBS_CSSRr
#define WRITE_SUBS_CSSRr BCM53128_A0_WRITE_SUBS_CSSRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SUBS_CSSRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SUBS_MISCR
 * BLOCKS:   SYS
 * DESC:     Subsystem Miscellaneous Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SUBS_T0CEN       Enable of timer 0 external sourceWriting 1'b1 to this bit  enables timer 0's external source1'b1: 1us event1'b0: disabled
 *     SUBS_T1CEN       Enable of timer 1 external sourceWriting 1'b1 to this bit  enables timer 1's external source1'b1: 1us event1'b0: disabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_SUBS_MISCRr 0x0000ff33

#define BCM53128_A0_SUBS_MISCRr_SIZE 1

/*
 * This structure should be used to declare and program SUBS_MISCR.
 *
 */
typedef union BCM53128_A0_SUBS_MISCRr_s {
	uint32_t v[1];
	uint32_t subs_miscr[1];
	uint32_t _subs_miscr;
} BCM53128_A0_SUBS_MISCRr_t;

#define BCM53128_A0_SUBS_MISCRr_CLR(r) (r).subs_miscr[0] = 0
#define BCM53128_A0_SUBS_MISCRr_SET(r,d) (r).subs_miscr[0] = d
#define BCM53128_A0_SUBS_MISCRr_GET(r) (r).subs_miscr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SUBS_MISCRr_SUBS_T0CENf_GET(r) (((r).subs_miscr[0]) & 0x1)
#define BCM53128_A0_SUBS_MISCRr_SUBS_T0CENf_SET(r,f) (r).subs_miscr[0]=(((r).subs_miscr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SUBS_MISCRr_SUBS_T1CENf_GET(r) ((((r).subs_miscr[0]) >> 1) & 0x1)
#define BCM53128_A0_SUBS_MISCRr_SUBS_T1CENf_SET(r,f) (r).subs_miscr[0]=(((r).subs_miscr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_SUBS_MISCRr_RESERVEDf_GET(r) ((((r).subs_miscr[0]) >> 2) & 0x3f)
#define BCM53128_A0_SUBS_MISCRr_RESERVEDf_SET(r,f) (r).subs_miscr[0]=(((r).subs_miscr[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access SUBS_MISCR.
 *
 */
#define BCM53128_A0_READ_SUBS_MISCRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SUBS_MISCRr,(r._subs_miscr),1)
#define BCM53128_A0_WRITE_SUBS_MISCRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SUBS_MISCRr,&(r._subs_miscr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SUBS_MISCRr BCM53128_A0_SUBS_MISCRr
#define SUBS_MISCRr_SIZE BCM53128_A0_SUBS_MISCRr_SIZE
typedef BCM53128_A0_SUBS_MISCRr_t SUBS_MISCRr_t;
#define SUBS_MISCRr_CLR BCM53128_A0_SUBS_MISCRr_CLR
#define SUBS_MISCRr_SET BCM53128_A0_SUBS_MISCRr_SET
#define SUBS_MISCRr_GET BCM53128_A0_SUBS_MISCRr_GET
#define SUBS_MISCRr_SUBS_T0CENf_GET BCM53128_A0_SUBS_MISCRr_SUBS_T0CENf_GET
#define SUBS_MISCRr_SUBS_T0CENf_SET BCM53128_A0_SUBS_MISCRr_SUBS_T0CENf_SET
#define SUBS_MISCRr_SUBS_T1CENf_GET BCM53128_A0_SUBS_MISCRr_SUBS_T1CENf_GET
#define SUBS_MISCRr_SUBS_T1CENf_SET BCM53128_A0_SUBS_MISCRr_SUBS_T1CENf_SET
#define SUBS_MISCRr_RESERVEDf_GET BCM53128_A0_SUBS_MISCRr_RESERVEDf_GET
#define SUBS_MISCRr_RESERVEDf_SET BCM53128_A0_SUBS_MISCRr_RESERVEDf_SET
#define READ_SUBS_MISCRr BCM53128_A0_READ_SUBS_MISCRr
#define WRITE_SUBS_MISCRr BCM53128_A0_WRITE_SUBS_MISCRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SUBS_MISCRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SUBS_SR
 * BLOCKS:   SYS
 * DESC:     Subsystem Status Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SUBS_MIIEN       MII port Enable (this register reflects the state of strapping pin en_8051_txrx)=0, MII port is disabled=1, MII port is enabled.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_SUBS_SRr 0x0000ff31

#define BCM53128_A0_SUBS_SRr_SIZE 1

/*
 * This structure should be used to declare and program SUBS_SR.
 *
 */
typedef union BCM53128_A0_SUBS_SRr_s {
	uint32_t v[1];
	uint32_t subs_sr[1];
	uint32_t _subs_sr;
} BCM53128_A0_SUBS_SRr_t;

#define BCM53128_A0_SUBS_SRr_CLR(r) (r).subs_sr[0] = 0
#define BCM53128_A0_SUBS_SRr_SET(r,d) (r).subs_sr[0] = d
#define BCM53128_A0_SUBS_SRr_GET(r) (r).subs_sr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SUBS_SRr_SUBS_MIIENf_GET(r) (((r).subs_sr[0]) & 0x1)
#define BCM53128_A0_SUBS_SRr_SUBS_MIIENf_SET(r,f) (r).subs_sr[0]=(((r).subs_sr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SUBS_SRr_RESERVEDf_GET(r) ((((r).subs_sr[0]) >> 1) & 0x7f)
#define BCM53128_A0_SUBS_SRr_RESERVEDf_SET(r,f) (r).subs_sr[0]=(((r).subs_sr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access SUBS_SR.
 *
 */
#define BCM53128_A0_READ_SUBS_SRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SUBS_SRr,(r._subs_sr),1)
#define BCM53128_A0_WRITE_SUBS_SRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SUBS_SRr,&(r._subs_sr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SUBS_SRr BCM53128_A0_SUBS_SRr
#define SUBS_SRr_SIZE BCM53128_A0_SUBS_SRr_SIZE
typedef BCM53128_A0_SUBS_SRr_t SUBS_SRr_t;
#define SUBS_SRr_CLR BCM53128_A0_SUBS_SRr_CLR
#define SUBS_SRr_SET BCM53128_A0_SUBS_SRr_SET
#define SUBS_SRr_GET BCM53128_A0_SUBS_SRr_GET
#define SUBS_SRr_SUBS_MIIENf_GET BCM53128_A0_SUBS_SRr_SUBS_MIIENf_GET
#define SUBS_SRr_SUBS_MIIENf_SET BCM53128_A0_SUBS_SRr_SUBS_MIIENf_SET
#define SUBS_SRr_RESERVEDf_GET BCM53128_A0_SUBS_SRr_RESERVEDf_GET
#define SUBS_SRr_RESERVEDf_SET BCM53128_A0_SUBS_SRr_RESERVEDf_SET
#define READ_SUBS_SRr BCM53128_A0_READ_SUBS_SRr
#define WRITE_SUBS_SRr BCM53128_A0_WRITE_SUBS_SRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SUBS_SRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.Strapped from the inverse of the HW_FWDG_EN pin at power-on. Can be overwritten subsequently.0 = Unmanaged Mode.1 = Managed ModeThe ARL treats Reserved Multicast addresses differently dependent on this selection. See Table 3 for a precise definition.
 *     SW_FWDG_EN       Software Forwarding EnableSW_FWDG_EN=1: Frame forwarding is enabled.SW_FWDG_EN=0: Frame forwarding is disabled.Read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently. For managed switch implementations (5388 mode), the switch should be configured to disable forwarding on power-on, to allow the processor to configure the internal address table and other parameters, before frame forwarding is enabled.
 *     RTRY_LMT_DIS     SwitchGeneralMode.RetryLimitDisable.When set, disables the Retry limit on all MAC ports (10/100BASE-T and MII ports). Causes a MAC port in half duplex operation, to continue to retry the same packet regardless of the number of collision attempts.It's illegal to set this bit to '0'.(Not2Release)
 *     FAST_TXDESC_RERURN Controls which algorithm is used to release packets when a link goes down.It's illegal to set this bit to '1'.(Not2Release)
 *     NOBLKCD          Always not to block carrier detected signal.1'b1: Not to block. txport will always defer to CRS.1'b0: Block CD(compatiable with BCM5328).It's illegal to set this bit to '1'.(Not2Release)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_SWMODEr 0x0000000b

#define BCM53128_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 *
 */
typedef union BCM53128_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM53128_A0_SWMODEr_t;

#define BCM53128_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM53128_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM53128_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM53128_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM53128_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_SWMODEr_RTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM53128_A0_SWMODEr_RTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_SWMODEr_FAST_TXDESC_RERURNf_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM53128_A0_SWMODEr_FAST_TXDESC_RERURNf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_SWMODEr_NOBLKCDf_GET(r) ((((r).swmode[0]) >> 4) & 0x1)
#define BCM53128_A0_SWMODEr_NOBLKCDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_SWMODEr_RESERVEDf_GET(r) ((((r).swmode[0]) >> 5) & 0x7)
#define BCM53128_A0_SWMODEr_RESERVEDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SWMODE.
 *
 */
#define BCM53128_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_SWMODEr,(r._swmode),1)
#define BCM53128_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM53128_A0_SWMODEr
#define SWMODEr_SIZE BCM53128_A0_SWMODEr_SIZE
typedef BCM53128_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM53128_A0_SWMODEr_CLR
#define SWMODEr_SET BCM53128_A0_SWMODEr_SET
#define SWMODEr_GET BCM53128_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM53128_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM53128_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM53128_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM53128_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_RTRY_LMT_DISf_GET BCM53128_A0_SWMODEr_RTRY_LMT_DISf_GET
#define SWMODEr_RTRY_LMT_DISf_SET BCM53128_A0_SWMODEr_RTRY_LMT_DISf_SET
#define SWMODEr_FAST_TXDESC_RERURNf_GET BCM53128_A0_SWMODEr_FAST_TXDESC_RERURNf_GET
#define SWMODEr_FAST_TXDESC_RERURNf_SET BCM53128_A0_SWMODEr_FAST_TXDESC_RERURNf_SET
#define SWMODEr_NOBLKCDf_GET BCM53128_A0_SWMODEr_NOBLKCDf_GET
#define SWMODEr_NOBLKCDf_SET BCM53128_A0_SWMODEr_NOBLKCDf_SET
#define SWMODEr_RESERVEDf_GET BCM53128_A0_SWMODEr_RESERVEDf_GET
#define SWMODEr_RESERVEDf_SET BCM53128_A0_SWMODEr_RESERVEDf_SET
#define READ_SWMODEr BCM53128_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM53128_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_SWMODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_EEE_LPI_DURATION
 * BLOCKS:   SYS
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 * FIELDS:
 *     COUNT            EEE low-power idle duration.This counter accumulates the number of microseconds that the associated MAC/PHY is in the low-power idle state.The unit is 1 usec
 *
 ******************************************************************************/
#define BCM53128_A0_S_EEE_LPI_DURATIONr 0x000071bc

#define BCM53128_A0_S_EEE_LPI_DURATIONr_SIZE 4

/*
 * This structure should be used to declare and program S_EEE_LPI_DURATION.
 *
 */
typedef union BCM53128_A0_S_EEE_LPI_DURATIONr_s {
	uint32_t v[1];
	uint32_t s_eee_lpi_duration[1];
	uint32_t _s_eee_lpi_duration;
} BCM53128_A0_S_EEE_LPI_DURATIONr_t;

#define BCM53128_A0_S_EEE_LPI_DURATIONr_CLR(r) (r).s_eee_lpi_duration[0] = 0
#define BCM53128_A0_S_EEE_LPI_DURATIONr_SET(r,d) (r).s_eee_lpi_duration[0] = d
#define BCM53128_A0_S_EEE_LPI_DURATIONr_GET(r) (r).s_eee_lpi_duration[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_EEE_LPI_DURATIONr_COUNTf_GET(r) ((r).s_eee_lpi_duration[0])
#define BCM53128_A0_S_EEE_LPI_DURATIONr_COUNTf_SET(r,f) (r).s_eee_lpi_duration[0]=((uint32_t)f)

/*
 * These macros can be used to access S_EEE_LPI_DURATION.
 *
 */
#define BCM53128_A0_READ_S_EEE_LPI_DURATIONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_EEE_LPI_DURATIONr,(r._s_eee_lpi_duration),4)
#define BCM53128_A0_WRITE_S_EEE_LPI_DURATIONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_EEE_LPI_DURATIONr,&(r._s_eee_lpi_duration),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_EEE_LPI_DURATIONr BCM53128_A0_S_EEE_LPI_DURATIONr
#define S_EEE_LPI_DURATIONr_SIZE BCM53128_A0_S_EEE_LPI_DURATIONr_SIZE
typedef BCM53128_A0_S_EEE_LPI_DURATIONr_t S_EEE_LPI_DURATIONr_t;
#define S_EEE_LPI_DURATIONr_CLR BCM53128_A0_S_EEE_LPI_DURATIONr_CLR
#define S_EEE_LPI_DURATIONr_SET BCM53128_A0_S_EEE_LPI_DURATIONr_SET
#define S_EEE_LPI_DURATIONr_GET BCM53128_A0_S_EEE_LPI_DURATIONr_GET
#define S_EEE_LPI_DURATIONr_COUNTf_GET BCM53128_A0_S_EEE_LPI_DURATIONr_COUNTf_GET
#define S_EEE_LPI_DURATIONr_COUNTf_SET BCM53128_A0_S_EEE_LPI_DURATIONr_COUNTf_SET
#define READ_S_EEE_LPI_DURATIONr BCM53128_A0_READ_S_EEE_LPI_DURATIONr
#define WRITE_S_EEE_LPI_DURATIONr BCM53128_A0_WRITE_S_EEE_LPI_DURATIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_EEE_LPI_DURATIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_EEE_LPI_EVENT
 * BLOCKS:   SYS
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 * FIELDS:
 *     COUNT            EEE low-power idle eventIn asymmetric mode, this is simply a count of the number of times that the lowPowerAssert control signal has been asserted for each MAC. In symmetric mode, this is the count of the number of times both lowPowerAssert and the lowPowerIndicate(from the receive path) are asserted simultaneously.
 *
 ******************************************************************************/
#define BCM53128_A0_S_EEE_LPI_EVENTr 0x000071b8

#define BCM53128_A0_S_EEE_LPI_EVENTr_SIZE 4

/*
 * This structure should be used to declare and program S_EEE_LPI_EVENT.
 *
 */
typedef union BCM53128_A0_S_EEE_LPI_EVENTr_s {
	uint32_t v[1];
	uint32_t s_eee_lpi_event[1];
	uint32_t _s_eee_lpi_event;
} BCM53128_A0_S_EEE_LPI_EVENTr_t;

#define BCM53128_A0_S_EEE_LPI_EVENTr_CLR(r) (r).s_eee_lpi_event[0] = 0
#define BCM53128_A0_S_EEE_LPI_EVENTr_SET(r,d) (r).s_eee_lpi_event[0] = d
#define BCM53128_A0_S_EEE_LPI_EVENTr_GET(r) (r).s_eee_lpi_event[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_EEE_LPI_EVENTr_COUNTf_GET(r) ((r).s_eee_lpi_event[0])
#define BCM53128_A0_S_EEE_LPI_EVENTr_COUNTf_SET(r,f) (r).s_eee_lpi_event[0]=((uint32_t)f)

/*
 * These macros can be used to access S_EEE_LPI_EVENT.
 *
 */
#define BCM53128_A0_READ_S_EEE_LPI_EVENTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_EEE_LPI_EVENTr,(r._s_eee_lpi_event),4)
#define BCM53128_A0_WRITE_S_EEE_LPI_EVENTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_EEE_LPI_EVENTr,&(r._s_eee_lpi_event),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_EEE_LPI_EVENTr BCM53128_A0_S_EEE_LPI_EVENTr
#define S_EEE_LPI_EVENTr_SIZE BCM53128_A0_S_EEE_LPI_EVENTr_SIZE
typedef BCM53128_A0_S_EEE_LPI_EVENTr_t S_EEE_LPI_EVENTr_t;
#define S_EEE_LPI_EVENTr_CLR BCM53128_A0_S_EEE_LPI_EVENTr_CLR
#define S_EEE_LPI_EVENTr_SET BCM53128_A0_S_EEE_LPI_EVENTr_SET
#define S_EEE_LPI_EVENTr_GET BCM53128_A0_S_EEE_LPI_EVENTr_GET
#define S_EEE_LPI_EVENTr_COUNTf_GET BCM53128_A0_S_EEE_LPI_EVENTr_COUNTf_GET
#define S_EEE_LPI_EVENTr_COUNTf_SET BCM53128_A0_S_EEE_LPI_EVENTr_COUNTf_SET
#define READ_S_EEE_LPI_EVENTr BCM53128_A0_READ_S_EEE_LPI_EVENTr
#define WRITE_S_EEE_LPI_EVENTr BCM53128_A0_WRITE_S_EEE_LPI_EVENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_EEE_LPI_EVENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_InRangeErrCount
 * BLOCKS:   SYS
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_INRANGEERRCOUNTr 0x000071b0

#define BCM53128_A0_S_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_InRangeErrCount.
 *
 */
typedef union BCM53128_A0_S_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_inrangeerrcount[1];
	uint32_t _s_inrangeerrcount;
} BCM53128_A0_S_INRANGEERRCOUNTr_t;

#define BCM53128_A0_S_INRANGEERRCOUNTr_CLR(r) (r).s_inrangeerrcount[0] = 0
#define BCM53128_A0_S_INRANGEERRCOUNTr_SET(r,d) (r).s_inrangeerrcount[0] = d
#define BCM53128_A0_S_INRANGEERRCOUNTr_GET(r) (r).s_inrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_INRANGEERRCOUNTr_COUNTf_GET(r) ((r).s_inrangeerrcount[0])
#define BCM53128_A0_S_INRANGEERRCOUNTr_COUNTf_SET(r,f) (r).s_inrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_InRangeErrCount.
 *
 */
#define BCM53128_A0_READ_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_INRANGEERRCOUNTr,(r._s_inrangeerrcount),4)
#define BCM53128_A0_WRITE_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_INRANGEERRCOUNTr,&(r._s_inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_INRANGEERRCOUNTr BCM53128_A0_S_INRANGEERRCOUNTr
#define S_INRANGEERRCOUNTr_SIZE BCM53128_A0_S_INRANGEERRCOUNTr_SIZE
typedef BCM53128_A0_S_INRANGEERRCOUNTr_t S_INRANGEERRCOUNTr_t;
#define S_INRANGEERRCOUNTr_CLR BCM53128_A0_S_INRANGEERRCOUNTr_CLR
#define S_INRANGEERRCOUNTr_SET BCM53128_A0_S_INRANGEERRCOUNTr_SET
#define S_INRANGEERRCOUNTr_GET BCM53128_A0_S_INRANGEERRCOUNTr_GET
#define S_INRANGEERRCOUNTr_COUNTf_GET BCM53128_A0_S_INRANGEERRCOUNTr_COUNTf_GET
#define S_INRANGEERRCOUNTr_COUNTf_SET BCM53128_A0_S_INRANGEERRCOUNTr_COUNTf_SET
#define READ_S_INRANGEERRCOUNTr BCM53128_A0_READ_S_INRANGEERRCOUNTr
#define WRITE_S_INRANGEERRCOUNTr BCM53128_A0_WRITE_S_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_JumboPkt
 * BLOCKS:   SYS
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_JUMBOPKTr 0x000071a8

#define BCM53128_A0_S_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_JumboPkt.
 *
 */
typedef union BCM53128_A0_S_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t s_jumbopkt[1];
	uint32_t _s_jumbopkt;
} BCM53128_A0_S_JUMBOPKTr_t;

#define BCM53128_A0_S_JUMBOPKTr_CLR(r) (r).s_jumbopkt[0] = 0
#define BCM53128_A0_S_JUMBOPKTr_SET(r,d) (r).s_jumbopkt[0] = d
#define BCM53128_A0_S_JUMBOPKTr_GET(r) (r).s_jumbopkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_JUMBOPKTr_COUNTf_GET(r) ((r).s_jumbopkt[0])
#define BCM53128_A0_S_JUMBOPKTr_COUNTf_SET(r,f) (r).s_jumbopkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_JumboPkt.
 *
 */
#define BCM53128_A0_READ_S_JUMBOPKTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_JUMBOPKTr,(r._s_jumbopkt),4)
#define BCM53128_A0_WRITE_S_JUMBOPKTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_JUMBOPKTr,&(r._s_jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_JUMBOPKTr BCM53128_A0_S_JUMBOPKTr
#define S_JUMBOPKTr_SIZE BCM53128_A0_S_JUMBOPKTr_SIZE
typedef BCM53128_A0_S_JUMBOPKTr_t S_JUMBOPKTr_t;
#define S_JUMBOPKTr_CLR BCM53128_A0_S_JUMBOPKTr_CLR
#define S_JUMBOPKTr_SET BCM53128_A0_S_JUMBOPKTr_SET
#define S_JUMBOPKTr_GET BCM53128_A0_S_JUMBOPKTr_GET
#define S_JUMBOPKTr_COUNTf_GET BCM53128_A0_S_JUMBOPKTr_COUNTf_GET
#define S_JUMBOPKTr_COUNTf_SET BCM53128_A0_S_JUMBOPKTr_COUNTf_SET
#define READ_S_JUMBOPKTr BCM53128_A0_READ_S_JUMBOPKTr
#define WRITE_S_JUMBOPKTr BCM53128_A0_WRITE_S_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_OutRangeErrCount
 * BLOCKS:   SYS
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_OUTRANGEERRCOUNTr 0x000071b4

#define BCM53128_A0_S_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_OutRangeErrCount.
 *
 */
typedef union BCM53128_A0_S_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_outrangeerrcount[1];
	uint32_t _s_outrangeerrcount;
} BCM53128_A0_S_OUTRANGEERRCOUNTr_t;

#define BCM53128_A0_S_OUTRANGEERRCOUNTr_CLR(r) (r).s_outrangeerrcount[0] = 0
#define BCM53128_A0_S_OUTRANGEERRCOUNTr_SET(r,d) (r).s_outrangeerrcount[0] = d
#define BCM53128_A0_S_OUTRANGEERRCOUNTr_GET(r) (r).s_outrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_OUTRANGEERRCOUNTr_COUNTf_GET(r) ((r).s_outrangeerrcount[0])
#define BCM53128_A0_S_OUTRANGEERRCOUNTr_COUNTf_SET(r,f) (r).s_outrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_OutRangeErrCount.
 *
 */
#define BCM53128_A0_READ_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_OUTRANGEERRCOUNTr,(r._s_outrangeerrcount),4)
#define BCM53128_A0_WRITE_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_OUTRANGEERRCOUNTr,&(r._s_outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_OUTRANGEERRCOUNTr BCM53128_A0_S_OUTRANGEERRCOUNTr
#define S_OUTRANGEERRCOUNTr_SIZE BCM53128_A0_S_OUTRANGEERRCOUNTr_SIZE
typedef BCM53128_A0_S_OUTRANGEERRCOUNTr_t S_OUTRANGEERRCOUNTr_t;
#define S_OUTRANGEERRCOUNTr_CLR BCM53128_A0_S_OUTRANGEERRCOUNTr_CLR
#define S_OUTRANGEERRCOUNTr_SET BCM53128_A0_S_OUTRANGEERRCOUNTr_SET
#define S_OUTRANGEERRCOUNTr_GET BCM53128_A0_S_OUTRANGEERRCOUNTr_GET
#define S_OUTRANGEERRCOUNTr_COUNTf_GET BCM53128_A0_S_OUTRANGEERRCOUNTr_COUNTf_GET
#define S_OUTRANGEERRCOUNTr_COUNTf_SET BCM53128_A0_S_OUTRANGEERRCOUNTr_COUNTf_SET
#define READ_S_OUTRANGEERRCOUNTr BCM53128_A0_READ_S_OUTRANGEERRCOUNTr
#define WRITE_S_OUTRANGEERRCOUNTr BCM53128_A0_WRITE_S_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_Pkts1024toMaxPktOctets
 * BLOCKS:   SYS
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr 0x00007174

#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts1024tomaxpktoctets[1];
	uint32_t _s_pkts1024tomaxpktoctets;
} BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).s_pkts1024tomaxpktoctets[0] = 0
#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).s_pkts1024tomaxpktoctets[0] = d
#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).s_pkts1024tomaxpktoctets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET(r) ((r).s_pkts1024tomaxpktoctets[0])
#define BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET(r,f) (r).s_pkts1024tomaxpktoctets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1024toMaxPktOctets.
 *
 */
#define BCM53128_A0_READ_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr,(r._s_pkts1024tomaxpktoctets),4)
#define BCM53128_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr,&(r._s_pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1024TOMAXPKTOCTETSr BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr
#define S_PKTS1024TOMAXPKTOCTETSr_SIZE BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_t S_PKTS1024TOMAXPKTOCTETSr_t;
#define S_PKTS1024TOMAXPKTOCTETSr_CLR BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR
#define S_PKTS1024TOMAXPKTOCTETSr_SET BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_SET
#define S_PKTS1024TOMAXPKTOCTETSr_GET BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET
#define READ_S_PKTS1024TOMAXPKTOCTETSr BCM53128_A0_READ_S_PKTS1024TOMAXPKTOCTETSr
#define WRITE_S_PKTS1024TOMAXPKTOCTETSr BCM53128_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_Pkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_PKTS128TO255OCTETSr 0x00007168

#define BCM53128_A0_S_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts128to255Octets.
 *
 */
typedef union BCM53128_A0_S_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts128to255octets[1];
	uint32_t _s_pkts128to255octets;
} BCM53128_A0_S_PKTS128TO255OCTETSr_t;

#define BCM53128_A0_S_PKTS128TO255OCTETSr_CLR(r) (r).s_pkts128to255octets[0] = 0
#define BCM53128_A0_S_PKTS128TO255OCTETSr_SET(r,d) (r).s_pkts128to255octets[0] = d
#define BCM53128_A0_S_PKTS128TO255OCTETSr_GET(r) (r).s_pkts128to255octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_PKTS128TO255OCTETSr_COUNTf_GET(r) ((r).s_pkts128to255octets[0])
#define BCM53128_A0_S_PKTS128TO255OCTETSr_COUNTf_SET(r,f) (r).s_pkts128to255octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts128to255Octets.
 *
 */
#define BCM53128_A0_READ_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_PKTS128TO255OCTETSr,(r._s_pkts128to255octets),4)
#define BCM53128_A0_WRITE_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_PKTS128TO255OCTETSr,&(r._s_pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS128TO255OCTETSr BCM53128_A0_S_PKTS128TO255OCTETSr
#define S_PKTS128TO255OCTETSr_SIZE BCM53128_A0_S_PKTS128TO255OCTETSr_SIZE
typedef BCM53128_A0_S_PKTS128TO255OCTETSr_t S_PKTS128TO255OCTETSr_t;
#define S_PKTS128TO255OCTETSr_CLR BCM53128_A0_S_PKTS128TO255OCTETSr_CLR
#define S_PKTS128TO255OCTETSr_SET BCM53128_A0_S_PKTS128TO255OCTETSr_SET
#define S_PKTS128TO255OCTETSr_GET BCM53128_A0_S_PKTS128TO255OCTETSr_GET
#define S_PKTS128TO255OCTETSr_COUNTf_GET BCM53128_A0_S_PKTS128TO255OCTETSr_COUNTf_GET
#define S_PKTS128TO255OCTETSr_COUNTf_SET BCM53128_A0_S_PKTS128TO255OCTETSr_COUNTf_SET
#define READ_S_PKTS128TO255OCTETSr BCM53128_A0_READ_S_PKTS128TO255OCTETSr
#define WRITE_S_PKTS128TO255OCTETSr BCM53128_A0_WRITE_S_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_Pkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_PKTS256TO511OCTETSr 0x0000716c

#define BCM53128_A0_S_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts256to511Octets.
 *
 */
typedef union BCM53128_A0_S_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts256to511octets[1];
	uint32_t _s_pkts256to511octets;
} BCM53128_A0_S_PKTS256TO511OCTETSr_t;

#define BCM53128_A0_S_PKTS256TO511OCTETSr_CLR(r) (r).s_pkts256to511octets[0] = 0
#define BCM53128_A0_S_PKTS256TO511OCTETSr_SET(r,d) (r).s_pkts256to511octets[0] = d
#define BCM53128_A0_S_PKTS256TO511OCTETSr_GET(r) (r).s_pkts256to511octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_PKTS256TO511OCTETSr_COUNTf_GET(r) ((r).s_pkts256to511octets[0])
#define BCM53128_A0_S_PKTS256TO511OCTETSr_COUNTf_SET(r,f) (r).s_pkts256to511octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts256to511Octets.
 *
 */
#define BCM53128_A0_READ_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_PKTS256TO511OCTETSr,(r._s_pkts256to511octets),4)
#define BCM53128_A0_WRITE_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_PKTS256TO511OCTETSr,&(r._s_pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS256TO511OCTETSr BCM53128_A0_S_PKTS256TO511OCTETSr
#define S_PKTS256TO511OCTETSr_SIZE BCM53128_A0_S_PKTS256TO511OCTETSr_SIZE
typedef BCM53128_A0_S_PKTS256TO511OCTETSr_t S_PKTS256TO511OCTETSr_t;
#define S_PKTS256TO511OCTETSr_CLR BCM53128_A0_S_PKTS256TO511OCTETSr_CLR
#define S_PKTS256TO511OCTETSr_SET BCM53128_A0_S_PKTS256TO511OCTETSr_SET
#define S_PKTS256TO511OCTETSr_GET BCM53128_A0_S_PKTS256TO511OCTETSr_GET
#define S_PKTS256TO511OCTETSr_COUNTf_GET BCM53128_A0_S_PKTS256TO511OCTETSr_COUNTf_GET
#define S_PKTS256TO511OCTETSr_COUNTf_SET BCM53128_A0_S_PKTS256TO511OCTETSr_COUNTf_SET
#define READ_S_PKTS256TO511OCTETSr BCM53128_A0_READ_S_PKTS256TO511OCTETSr
#define WRITE_S_PKTS256TO511OCTETSr BCM53128_A0_WRITE_S_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_Pkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_PKTS512TO1023OCTETSr 0x00007170

#define BCM53128_A0_S_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts512to1023Octets.
 *
 */
typedef union BCM53128_A0_S_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts512to1023octets[1];
	uint32_t _s_pkts512to1023octets;
} BCM53128_A0_S_PKTS512TO1023OCTETSr_t;

#define BCM53128_A0_S_PKTS512TO1023OCTETSr_CLR(r) (r).s_pkts512to1023octets[0] = 0
#define BCM53128_A0_S_PKTS512TO1023OCTETSr_SET(r,d) (r).s_pkts512to1023octets[0] = d
#define BCM53128_A0_S_PKTS512TO1023OCTETSr_GET(r) (r).s_pkts512to1023octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_PKTS512TO1023OCTETSr_COUNTf_GET(r) ((r).s_pkts512to1023octets[0])
#define BCM53128_A0_S_PKTS512TO1023OCTETSr_COUNTf_SET(r,f) (r).s_pkts512to1023octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts512to1023Octets.
 *
 */
#define BCM53128_A0_READ_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_PKTS512TO1023OCTETSr,(r._s_pkts512to1023octets),4)
#define BCM53128_A0_WRITE_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_PKTS512TO1023OCTETSr,&(r._s_pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS512TO1023OCTETSr BCM53128_A0_S_PKTS512TO1023OCTETSr
#define S_PKTS512TO1023OCTETSr_SIZE BCM53128_A0_S_PKTS512TO1023OCTETSr_SIZE
typedef BCM53128_A0_S_PKTS512TO1023OCTETSr_t S_PKTS512TO1023OCTETSr_t;
#define S_PKTS512TO1023OCTETSr_CLR BCM53128_A0_S_PKTS512TO1023OCTETSr_CLR
#define S_PKTS512TO1023OCTETSr_SET BCM53128_A0_S_PKTS512TO1023OCTETSr_SET
#define S_PKTS512TO1023OCTETSr_GET BCM53128_A0_S_PKTS512TO1023OCTETSr_GET
#define S_PKTS512TO1023OCTETSr_COUNTf_GET BCM53128_A0_S_PKTS512TO1023OCTETSr_COUNTf_GET
#define S_PKTS512TO1023OCTETSr_COUNTf_SET BCM53128_A0_S_PKTS512TO1023OCTETSr_COUNTf_SET
#define READ_S_PKTS512TO1023OCTETSr BCM53128_A0_READ_S_PKTS512TO1023OCTETSr
#define WRITE_S_PKTS512TO1023OCTETSr BCM53128_A0_WRITE_S_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_Pkts64Octets
 * BLOCKS:   SYS
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_PKTS64OCTETSr 0x00007160

#define BCM53128_A0_S_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts64Octets.
 *
 */
typedef union BCM53128_A0_S_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts64octets[1];
	uint32_t _s_pkts64octets;
} BCM53128_A0_S_PKTS64OCTETSr_t;

#define BCM53128_A0_S_PKTS64OCTETSr_CLR(r) (r).s_pkts64octets[0] = 0
#define BCM53128_A0_S_PKTS64OCTETSr_SET(r,d) (r).s_pkts64octets[0] = d
#define BCM53128_A0_S_PKTS64OCTETSr_GET(r) (r).s_pkts64octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_PKTS64OCTETSr_COUNTf_GET(r) ((r).s_pkts64octets[0])
#define BCM53128_A0_S_PKTS64OCTETSr_COUNTf_SET(r,f) (r).s_pkts64octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts64Octets.
 *
 */
#define BCM53128_A0_READ_S_PKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_PKTS64OCTETSr,(r._s_pkts64octets),4)
#define BCM53128_A0_WRITE_S_PKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_PKTS64OCTETSr,&(r._s_pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS64OCTETSr BCM53128_A0_S_PKTS64OCTETSr
#define S_PKTS64OCTETSr_SIZE BCM53128_A0_S_PKTS64OCTETSr_SIZE
typedef BCM53128_A0_S_PKTS64OCTETSr_t S_PKTS64OCTETSr_t;
#define S_PKTS64OCTETSr_CLR BCM53128_A0_S_PKTS64OCTETSr_CLR
#define S_PKTS64OCTETSr_SET BCM53128_A0_S_PKTS64OCTETSr_SET
#define S_PKTS64OCTETSr_GET BCM53128_A0_S_PKTS64OCTETSr_GET
#define S_PKTS64OCTETSr_COUNTf_GET BCM53128_A0_S_PKTS64OCTETSr_COUNTf_GET
#define S_PKTS64OCTETSr_COUNTf_SET BCM53128_A0_S_PKTS64OCTETSr_COUNTf_SET
#define READ_S_PKTS64OCTETSr BCM53128_A0_READ_S_PKTS64OCTETSr
#define WRITE_S_PKTS64OCTETSr BCM53128_A0_WRITE_S_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_Pkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_PKTS65TO127OCTETSr 0x00007164

#define BCM53128_A0_S_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts65to127Octets.
 *
 */
typedef union BCM53128_A0_S_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts65to127octets[1];
	uint32_t _s_pkts65to127octets;
} BCM53128_A0_S_PKTS65TO127OCTETSr_t;

#define BCM53128_A0_S_PKTS65TO127OCTETSr_CLR(r) (r).s_pkts65to127octets[0] = 0
#define BCM53128_A0_S_PKTS65TO127OCTETSr_SET(r,d) (r).s_pkts65to127octets[0] = d
#define BCM53128_A0_S_PKTS65TO127OCTETSr_GET(r) (r).s_pkts65to127octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_PKTS65TO127OCTETSr_COUNTf_GET(r) ((r).s_pkts65to127octets[0])
#define BCM53128_A0_S_PKTS65TO127OCTETSr_COUNTf_SET(r,f) (r).s_pkts65to127octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts65to127Octets.
 *
 */
#define BCM53128_A0_READ_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_PKTS65TO127OCTETSr,(r._s_pkts65to127octets),4)
#define BCM53128_A0_WRITE_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_PKTS65TO127OCTETSr,&(r._s_pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS65TO127OCTETSr BCM53128_A0_S_PKTS65TO127OCTETSr
#define S_PKTS65TO127OCTETSr_SIZE BCM53128_A0_S_PKTS65TO127OCTETSr_SIZE
typedef BCM53128_A0_S_PKTS65TO127OCTETSr_t S_PKTS65TO127OCTETSr_t;
#define S_PKTS65TO127OCTETSr_CLR BCM53128_A0_S_PKTS65TO127OCTETSr_CLR
#define S_PKTS65TO127OCTETSr_SET BCM53128_A0_S_PKTS65TO127OCTETSr_SET
#define S_PKTS65TO127OCTETSr_GET BCM53128_A0_S_PKTS65TO127OCTETSr_GET
#define S_PKTS65TO127OCTETSr_COUNTf_GET BCM53128_A0_S_PKTS65TO127OCTETSr_COUNTf_GET
#define S_PKTS65TO127OCTETSr_COUNTf_SET BCM53128_A0_S_PKTS65TO127OCTETSr_COUNTf_SET
#define READ_S_PKTS65TO127OCTETSr BCM53128_A0_READ_S_PKTS65TO127OCTETSr
#define WRITE_S_PKTS65TO127OCTETSr BCM53128_A0_WRITE_S_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RXDISCARD
 * BLOCKS:   SYS
 * DESC:     Rx Discard Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXDISCARDr 0x000071c0

#define BCM53128_A0_S_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program S_RXDISCARD.
 *
 */
typedef union BCM53128_A0_S_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t s_rxdiscard[1];
	uint32_t _s_rxdiscard;
} BCM53128_A0_S_RXDISCARDr_t;

#define BCM53128_A0_S_RXDISCARDr_CLR(r) (r).s_rxdiscard[0] = 0
#define BCM53128_A0_S_RXDISCARDr_SET(r,d) (r).s_rxdiscard[0] = d
#define BCM53128_A0_S_RXDISCARDr_GET(r) (r).s_rxdiscard[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXDISCARDr_COUNTf_GET(r) ((r).s_rxdiscard[0])
#define BCM53128_A0_S_RXDISCARDr_COUNTf_SET(r,f) (r).s_rxdiscard[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXDISCARD.
 *
 */
#define BCM53128_A0_READ_S_RXDISCARDr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXDISCARDr,(r._s_rxdiscard),4)
#define BCM53128_A0_WRITE_S_RXDISCARDr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXDISCARDr,&(r._s_rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDISCARDr BCM53128_A0_S_RXDISCARDr
#define S_RXDISCARDr_SIZE BCM53128_A0_S_RXDISCARDr_SIZE
typedef BCM53128_A0_S_RXDISCARDr_t S_RXDISCARDr_t;
#define S_RXDISCARDr_CLR BCM53128_A0_S_RXDISCARDr_CLR
#define S_RXDISCARDr_SET BCM53128_A0_S_RXDISCARDr_SET
#define S_RXDISCARDr_GET BCM53128_A0_S_RXDISCARDr_GET
#define S_RXDISCARDr_COUNTf_GET BCM53128_A0_S_RXDISCARDr_COUNTf_GET
#define S_RXDISCARDr_COUNTf_SET BCM53128_A0_S_RXDISCARDr_COUNTf_SET
#define READ_S_RXDISCARDr BCM53128_A0_READ_S_RXDISCARDr
#define WRITE_S_RXDISCARDr BCM53128_A0_WRITE_S_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RXSymblErr
 * BLOCKS:   SYS
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXSYMBLERRr 0x000071ac

#define BCM53128_A0_S_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RXSymblErr.
 *
 */
typedef union BCM53128_A0_S_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymblerr[1];
	uint32_t _s_rxsymblerr;
} BCM53128_A0_S_RXSYMBLERRr_t;

#define BCM53128_A0_S_RXSYMBLERRr_CLR(r) (r).s_rxsymblerr[0] = 0
#define BCM53128_A0_S_RXSYMBLERRr_SET(r,d) (r).s_rxsymblerr[0] = d
#define BCM53128_A0_S_RXSYMBLERRr_GET(r) (r).s_rxsymblerr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXSYMBLERRr_COUNTf_GET(r) ((r).s_rxsymblerr[0])
#define BCM53128_A0_S_RXSYMBLERRr_COUNTf_SET(r,f) (r).s_rxsymblerr[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXSymblErr.
 *
 */
#define BCM53128_A0_READ_S_RXSYMBLERRr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXSYMBLERRr,(r._s_rxsymblerr),4)
#define BCM53128_A0_WRITE_S_RXSYMBLERRr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXSYMBLERRr,&(r._s_rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBLERRr BCM53128_A0_S_RXSYMBLERRr
#define S_RXSYMBLERRr_SIZE BCM53128_A0_S_RXSYMBLERRr_SIZE
typedef BCM53128_A0_S_RXSYMBLERRr_t S_RXSYMBLERRr_t;
#define S_RXSYMBLERRr_CLR BCM53128_A0_S_RXSYMBLERRr_CLR
#define S_RXSYMBLERRr_SET BCM53128_A0_S_RXSYMBLERRr_SET
#define S_RXSYMBLERRr_GET BCM53128_A0_S_RXSYMBLERRr_GET
#define S_RXSYMBLERRr_COUNTf_GET BCM53128_A0_S_RXSYMBLERRr_COUNTf_GET
#define S_RXSYMBLERRr_COUNTf_SET BCM53128_A0_S_RXSYMBLERRr_COUNTf_SET
#define READ_S_RXSYMBLERRr BCM53128_A0_READ_S_RXSYMBLERRr
#define WRITE_S_RXSYMBLERRr BCM53128_A0_WRITE_S_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXALIGNMENTERRORSr 0x00007180

#define BCM53128_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 *
 */
typedef union BCM53128_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM53128_A0_S_RXALIGNMENTERRORSr_t;

#define BCM53128_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM53128_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM53128_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXALIGNMENTERRORSr_COUNTf_GET(r) ((r).s_rxalignmenterrors[0])
#define BCM53128_A0_S_RXALIGNMENTERRORSr_COUNTf_SET(r,f) (r).s_rxalignmenterrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxAlignmentErrors.
 *
 */
#define BCM53128_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM53128_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM53128_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM53128_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM53128_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM53128_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM53128_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM53128_A0_S_RXALIGNMENTERRORSr_GET
#define S_RXALIGNMENTERRORSr_COUNTf_GET BCM53128_A0_S_RXALIGNMENTERRORSr_COUNTf_GET
#define S_RXALIGNMENTERRORSr_COUNTf_SET BCM53128_A0_S_RXALIGNMENTERRORSr_COUNTf_SET
#define READ_S_RXALIGNMENTERRORSr BCM53128_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM53128_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxBroadcastPkt
 * BLOCKS:   SYS
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXBROADCASTPKTr 0x0000719c

#define BCM53128_A0_S_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkt.
 *
 */
typedef union BCM53128_A0_S_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkt[1];
	uint32_t _s_rxbroadcastpkt;
} BCM53128_A0_S_RXBROADCASTPKTr_t;

#define BCM53128_A0_S_RXBROADCASTPKTr_CLR(r) (r).s_rxbroadcastpkt[0] = 0
#define BCM53128_A0_S_RXBROADCASTPKTr_SET(r,d) (r).s_rxbroadcastpkt[0] = d
#define BCM53128_A0_S_RXBROADCASTPKTr_GET(r) (r).s_rxbroadcastpkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXBROADCASTPKTr_COUNTf_GET(r) ((r).s_rxbroadcastpkt[0])
#define BCM53128_A0_S_RXBROADCASTPKTr_COUNTf_SET(r,f) (r).s_rxbroadcastpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxBroadcastPkt.
 *
 */
#define BCM53128_A0_READ_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXBROADCASTPKTr,(r._s_rxbroadcastpkt),4)
#define BCM53128_A0_WRITE_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXBROADCASTPKTr,&(r._s_rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTr BCM53128_A0_S_RXBROADCASTPKTr
#define S_RXBROADCASTPKTr_SIZE BCM53128_A0_S_RXBROADCASTPKTr_SIZE
typedef BCM53128_A0_S_RXBROADCASTPKTr_t S_RXBROADCASTPKTr_t;
#define S_RXBROADCASTPKTr_CLR BCM53128_A0_S_RXBROADCASTPKTr_CLR
#define S_RXBROADCASTPKTr_SET BCM53128_A0_S_RXBROADCASTPKTr_SET
#define S_RXBROADCASTPKTr_GET BCM53128_A0_S_RXBROADCASTPKTr_GET
#define S_RXBROADCASTPKTr_COUNTf_GET BCM53128_A0_S_RXBROADCASTPKTr_COUNTf_GET
#define S_RXBROADCASTPKTr_COUNTf_SET BCM53128_A0_S_RXBROADCASTPKTr_COUNTf_SET
#define READ_S_RXBROADCASTPKTr BCM53128_A0_READ_S_RXBROADCASTPKTr
#define WRITE_S_RXBROADCASTPKTr BCM53128_A0_WRITE_S_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxDropPkts
 * BLOCKS:   SYS
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXDROPPKTSr 0x00007190

#define BCM53128_A0_S_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxDropPkts.
 *
 */
typedef union BCM53128_A0_S_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxdroppkts[1];
	uint32_t _s_rxdroppkts;
} BCM53128_A0_S_RXDROPPKTSr_t;

#define BCM53128_A0_S_RXDROPPKTSr_CLR(r) (r).s_rxdroppkts[0] = 0
#define BCM53128_A0_S_RXDROPPKTSr_SET(r,d) (r).s_rxdroppkts[0] = d
#define BCM53128_A0_S_RXDROPPKTSr_GET(r) (r).s_rxdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXDROPPKTSr_COUNTf_GET(r) ((r).s_rxdroppkts[0])
#define BCM53128_A0_S_RXDROPPKTSr_COUNTf_SET(r,f) (r).s_rxdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxDropPkts.
 *
 */
#define BCM53128_A0_READ_S_RXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXDROPPKTSr,(r._s_rxdroppkts),4)
#define BCM53128_A0_WRITE_S_RXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXDROPPKTSr,&(r._s_rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDROPPKTSr BCM53128_A0_S_RXDROPPKTSr
#define S_RXDROPPKTSr_SIZE BCM53128_A0_S_RXDROPPKTSr_SIZE
typedef BCM53128_A0_S_RXDROPPKTSr_t S_RXDROPPKTSr_t;
#define S_RXDROPPKTSr_CLR BCM53128_A0_S_RXDROPPKTSr_CLR
#define S_RXDROPPKTSr_SET BCM53128_A0_S_RXDROPPKTSr_SET
#define S_RXDROPPKTSr_GET BCM53128_A0_S_RXDROPPKTSr_GET
#define S_RXDROPPKTSr_COUNTf_GET BCM53128_A0_S_RXDROPPKTSr_COUNTf_GET
#define S_RXDROPPKTSr_COUNTf_SET BCM53128_A0_S_RXDROPPKTSr_COUNTf_SET
#define READ_S_RXDROPPKTSr BCM53128_A0_READ_S_RXDROPPKTSr
#define WRITE_S_RXDROPPKTSr BCM53128_A0_WRITE_S_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXFCSERRORSr 0x00007184

#define BCM53128_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 *
 */
typedef union BCM53128_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM53128_A0_S_RXFCSERRORSr_t;

#define BCM53128_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM53128_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM53128_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXFCSERRORSr_COUNTf_GET(r) ((r).s_rxfcserrors[0])
#define BCM53128_A0_S_RXFCSERRORSr_COUNTf_SET(r,f) (r).s_rxfcserrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFCSErrors.
 *
 */
#define BCM53128_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM53128_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM53128_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM53128_A0_S_RXFCSERRORSr_SIZE
typedef BCM53128_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM53128_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM53128_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM53128_A0_S_RXFCSERRORSr_GET
#define S_RXFCSERRORSr_COUNTf_GET BCM53128_A0_S_RXFCSERRORSr_COUNTf_GET
#define S_RXFCSERRORSr_COUNTf_SET BCM53128_A0_S_RXFCSERRORSr_COUNTf_SET
#define READ_S_RXFCSERRORSr BCM53128_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM53128_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXFRAGMENTSr 0x000071a4

#define BCM53128_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 *
 */
typedef union BCM53128_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM53128_A0_S_RXFRAGMENTSr_t;

#define BCM53128_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM53128_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM53128_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXFRAGMENTSr_COUNTf_GET(r) ((r).s_rxfragments[0])
#define BCM53128_A0_S_RXFRAGMENTSr_COUNTf_SET(r,f) (r).s_rxfragments[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFragments.
 *
 */
#define BCM53128_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM53128_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM53128_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM53128_A0_S_RXFRAGMENTSr_SIZE
typedef BCM53128_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM53128_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM53128_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM53128_A0_S_RXFRAGMENTSr_GET
#define S_RXFRAGMENTSr_COUNTf_GET BCM53128_A0_S_RXFRAGMENTSr_COUNTf_GET
#define S_RXFRAGMENTSr_COUNTf_SET BCM53128_A0_S_RXFRAGMENTSr_COUNTf_SET
#define READ_S_RXFRAGMENTSr BCM53128_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM53128_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXGOODOCTETSr 0x00007188

#define BCM53128_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 *
 */
typedef union BCM53128_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM53128_A0_S_RXGOODOCTETSr_t;

#define BCM53128_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM53128_A0_S_RXGOODOCTETSr_t))
#define BCM53128_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM53128_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXGOODOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_rxgoodoctets,0,63,a)
#define BCM53128_A0_S_RXGOODOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_rxgoodoctets,0,63,a)

/*
 * These macros can be used to access S_RxGoodOctets.
 *
 */
#define BCM53128_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM53128_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM53128_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM53128_A0_S_RXGOODOCTETSr_SIZE
typedef BCM53128_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM53128_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM53128_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM53128_A0_S_RXGOODOCTETSr_GET
#define S_RXGOODOCTETSr_COUNTf_GET BCM53128_A0_S_RXGOODOCTETSr_COUNTf_GET
#define S_RXGOODOCTETSr_COUNTf_SET BCM53128_A0_S_RXGOODOCTETSr_COUNTf_SET
#define READ_S_RXGOODOCTETSr BCM53128_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM53128_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxJabbers
 * BLOCKS:   SYS
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXJABBERSr 0x0000717c

#define BCM53128_A0_S_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabbers.
 *
 */
typedef union BCM53128_A0_S_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t s_rxjabbers[1];
	uint32_t _s_rxjabbers;
} BCM53128_A0_S_RXJABBERSr_t;

#define BCM53128_A0_S_RXJABBERSr_CLR(r) (r).s_rxjabbers[0] = 0
#define BCM53128_A0_S_RXJABBERSr_SET(r,d) (r).s_rxjabbers[0] = d
#define BCM53128_A0_S_RXJABBERSr_GET(r) (r).s_rxjabbers[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXJABBERSr_COUNTf_GET(r) ((r).s_rxjabbers[0])
#define BCM53128_A0_S_RXJABBERSr_COUNTf_SET(r,f) (r).s_rxjabbers[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxJabbers.
 *
 */
#define BCM53128_A0_READ_S_RXJABBERSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXJABBERSr,(r._s_rxjabbers),4)
#define BCM53128_A0_WRITE_S_RXJABBERSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXJABBERSr,&(r._s_rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERSr BCM53128_A0_S_RXJABBERSr
#define S_RXJABBERSr_SIZE BCM53128_A0_S_RXJABBERSr_SIZE
typedef BCM53128_A0_S_RXJABBERSr_t S_RXJABBERSr_t;
#define S_RXJABBERSr_CLR BCM53128_A0_S_RXJABBERSr_CLR
#define S_RXJABBERSr_SET BCM53128_A0_S_RXJABBERSr_SET
#define S_RXJABBERSr_GET BCM53128_A0_S_RXJABBERSr_GET
#define S_RXJABBERSr_COUNTf_GET BCM53128_A0_S_RXJABBERSr_COUNTf_GET
#define S_RXJABBERSr_COUNTf_SET BCM53128_A0_S_RXJABBERSr_COUNTf_SET
#define READ_S_RXJABBERSr BCM53128_A0_READ_S_RXJABBERSr
#define WRITE_S_RXJABBERSr BCM53128_A0_WRITE_S_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXMULTICASTPKTSr 0x00007198

#define BCM53128_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 *
 */
typedef union BCM53128_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM53128_A0_S_RXMULTICASTPKTSr_t;

#define BCM53128_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM53128_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM53128_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXMULTICASTPKTSr_COUNTf_GET(r) ((r).s_rxmulticastpkts[0])
#define BCM53128_A0_S_RXMULTICASTPKTSr_COUNTf_SET(r,f) (r).s_rxmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxMulticastPkts.
 *
 */
#define BCM53128_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM53128_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM53128_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM53128_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM53128_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM53128_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM53128_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM53128_A0_S_RXMULTICASTPKTSr_GET
#define S_RXMULTICASTPKTSr_COUNTf_GET BCM53128_A0_S_RXMULTICASTPKTSr_COUNTf_GET
#define S_RXMULTICASTPKTSr_COUNTf_SET BCM53128_A0_S_RXMULTICASTPKTSr_COUNTf_SET
#define READ_S_RXMULTICASTPKTSr BCM53128_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM53128_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXOCTETSr 0x00007150

#define BCM53128_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 *
 */
typedef union BCM53128_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM53128_A0_S_RXOCTETSr_t;

#define BCM53128_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM53128_A0_S_RXOCTETSr_t))
#define BCM53128_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM53128_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_rxoctets,0,63,a)
#define BCM53128_A0_S_RXOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_rxoctets,0,63,a)

/*
 * These macros can be used to access S_RxOctets.
 *
 */
#define BCM53128_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM53128_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM53128_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM53128_A0_S_RXOCTETSr_SIZE
typedef BCM53128_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM53128_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM53128_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM53128_A0_S_RXOCTETSr_GET
#define S_RXOCTETSr_COUNTf_GET BCM53128_A0_S_RXOCTETSr_COUNTf_GET
#define S_RXOCTETSr_COUNTf_SET BCM53128_A0_S_RXOCTETSr_COUNTf_SET
#define READ_S_RXOCTETSr BCM53128_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM53128_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXOVERSIZEPKTSr 0x00007178

#define BCM53128_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 *
 */
typedef union BCM53128_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM53128_A0_S_RXOVERSIZEPKTSr_t;

#define BCM53128_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM53128_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM53128_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXOVERSIZEPKTSr_COUNTf_GET(r) ((r).s_rxoversizepkts[0])
#define BCM53128_A0_S_RXOVERSIZEPKTSr_COUNTf_SET(r,f) (r).s_rxoversizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxOversizePkts.
 *
 */
#define BCM53128_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM53128_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM53128_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM53128_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM53128_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM53128_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM53128_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM53128_A0_S_RXOVERSIZEPKTSr_GET
#define S_RXOVERSIZEPKTSr_COUNTf_GET BCM53128_A0_S_RXOVERSIZEPKTSr_COUNTf_GET
#define S_RXOVERSIZEPKTSr_COUNTf_SET BCM53128_A0_S_RXOVERSIZEPKTSr_COUNTf_SET
#define READ_S_RXOVERSIZEPKTSr BCM53128_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM53128_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXPAUSEPKTSr 0x0000715c

#define BCM53128_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 *
 */
typedef union BCM53128_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM53128_A0_S_RXPAUSEPKTSr_t;

#define BCM53128_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM53128_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM53128_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXPAUSEPKTSr_COUNTf_GET(r) ((r).s_rxpausepkts[0])
#define BCM53128_A0_S_RXPAUSEPKTSr_COUNTf_SET(r,f) (r).s_rxpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxPausePkts.
 *
 */
#define BCM53128_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM53128_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM53128_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM53128_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM53128_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM53128_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM53128_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM53128_A0_S_RXPAUSEPKTSr_GET
#define S_RXPAUSEPKTSr_COUNTf_GET BCM53128_A0_S_RXPAUSEPKTSr_COUNTf_GET
#define S_RXPAUSEPKTSr_COUNTf_SET BCM53128_A0_S_RXPAUSEPKTSr_COUNTf_SET
#define READ_S_RXPAUSEPKTSr BCM53128_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM53128_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxSAChanges
 * BLOCKS:   SYS
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXSACHANGESr 0x000071a0

#define BCM53128_A0_S_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSAChanges.
 *
 */
typedef union BCM53128_A0_S_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t s_rxsachanges[1];
	uint32_t _s_rxsachanges;
} BCM53128_A0_S_RXSACHANGESr_t;

#define BCM53128_A0_S_RXSACHANGESr_CLR(r) (r).s_rxsachanges[0] = 0
#define BCM53128_A0_S_RXSACHANGESr_SET(r,d) (r).s_rxsachanges[0] = d
#define BCM53128_A0_S_RXSACHANGESr_GET(r) (r).s_rxsachanges[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXSACHANGESr_COUNTf_GET(r) ((r).s_rxsachanges[0])
#define BCM53128_A0_S_RXSACHANGESr_COUNTf_SET(r,f) (r).s_rxsachanges[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxSAChanges.
 *
 */
#define BCM53128_A0_READ_S_RXSACHANGESr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXSACHANGESr,(r._s_rxsachanges),4)
#define BCM53128_A0_WRITE_S_RXSACHANGESr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXSACHANGESr,&(r._s_rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSACHANGESr BCM53128_A0_S_RXSACHANGESr
#define S_RXSACHANGESr_SIZE BCM53128_A0_S_RXSACHANGESr_SIZE
typedef BCM53128_A0_S_RXSACHANGESr_t S_RXSACHANGESr_t;
#define S_RXSACHANGESr_CLR BCM53128_A0_S_RXSACHANGESr_CLR
#define S_RXSACHANGESr_SET BCM53128_A0_S_RXSACHANGESr_SET
#define S_RXSACHANGESr_GET BCM53128_A0_S_RXSACHANGESr_GET
#define S_RXSACHANGESr_COUNTf_GET BCM53128_A0_S_RXSACHANGESr_COUNTf_GET
#define S_RXSACHANGESr_COUNTf_SET BCM53128_A0_S_RXSACHANGESr_COUNTf_SET
#define READ_S_RXSACHANGESr BCM53128_A0_READ_S_RXSACHANGESr
#define WRITE_S_RXSACHANGESr BCM53128_A0_WRITE_S_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXUNDERSIZEPKTSr 0x00007158

#define BCM53128_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 *
 */
typedef union BCM53128_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM53128_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM53128_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM53128_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM53128_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXUNDERSIZEPKTSr_COUNTf_GET(r) ((r).s_rxundersizepkts[0])
#define BCM53128_A0_S_RXUNDERSIZEPKTSr_COUNTf_SET(r,f) (r).s_rxundersizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUndersizePkts.
 *
 */
#define BCM53128_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM53128_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM53128_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM53128_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM53128_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM53128_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM53128_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM53128_A0_S_RXUNDERSIZEPKTSr_GET
#define S_RXUNDERSIZEPKTSr_COUNTf_GET BCM53128_A0_S_RXUNDERSIZEPKTSr_COUNTf_GET
#define S_RXUNDERSIZEPKTSr_COUNTf_SET BCM53128_A0_S_RXUNDERSIZEPKTSr_COUNTf_SET
#define READ_S_RXUNDERSIZEPKTSr BCM53128_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM53128_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_RXUNICASTPKTSr 0x00007194

#define BCM53128_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 *
 */
typedef union BCM53128_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM53128_A0_S_RXUNICASTPKTSr_t;

#define BCM53128_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM53128_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM53128_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_RXUNICASTPKTSr_COUNTf_GET(r) ((r).s_rxunicastpkts[0])
#define BCM53128_A0_S_RXUNICASTPKTSr_COUNTf_SET(r,f) (r).s_rxunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUnicastPkts.
 *
 */
#define BCM53128_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM53128_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM53128_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM53128_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM53128_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM53128_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM53128_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM53128_A0_S_RXUNICASTPKTSr_GET
#define S_RXUNICASTPKTSr_COUNTf_GET BCM53128_A0_S_RXUNICASTPKTSr_COUNTf_GET
#define S_RXUNICASTPKTSr_COUNTf_SET BCM53128_A0_S_RXUNICASTPKTSr_COUNTf_SET
#define READ_S_RXUNICASTPKTSr BCM53128_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM53128_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXBROADCASTPKTSr 0x00007110

#define BCM53128_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 *
 */
typedef union BCM53128_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM53128_A0_S_TXBROADCASTPKTSr_t;

#define BCM53128_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM53128_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM53128_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXBROADCASTPKTSr_COUNTf_GET(r) ((r).s_txbroadcastpkts[0])
#define BCM53128_A0_S_TXBROADCASTPKTSr_COUNTf_SET(r,f) (r).s_txbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxBroadcastPkts.
 *
 */
#define BCM53128_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM53128_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM53128_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM53128_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM53128_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM53128_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM53128_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM53128_A0_S_TXBROADCASTPKTSr_GET
#define S_TXBROADCASTPKTSr_COUNTf_GET BCM53128_A0_S_TXBROADCASTPKTSr_COUNTf_GET
#define S_TXBROADCASTPKTSr_COUNTf_SET BCM53128_A0_S_TXBROADCASTPKTSr_COUNTf_SET
#define READ_S_TXBROADCASTPKTSr BCM53128_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM53128_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     Tx Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXCOLLISIONSr 0x0000711c

#define BCM53128_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 *
 */
typedef union BCM53128_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM53128_A0_S_TXCOLLISIONSr_t;

#define BCM53128_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM53128_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM53128_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXCOLLISIONSr_COUNTf_GET(r) ((r).s_txcollisions[0])
#define BCM53128_A0_S_TXCOLLISIONSr_COUNTf_SET(r,f) (r).s_txcollisions[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxCollisions.
 *
 */
#define BCM53128_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM53128_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM53128_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM53128_A0_S_TXCOLLISIONSr_SIZE
typedef BCM53128_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM53128_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM53128_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM53128_A0_S_TXCOLLISIONSr_GET
#define S_TXCOLLISIONSr_COUNTf_GET BCM53128_A0_S_TXCOLLISIONSr_COUNTf_GET
#define S_TXCOLLISIONSr_COUNTf_SET BCM53128_A0_S_TXCOLLISIONSr_COUNTf_SET
#define READ_S_TXCOLLISIONSr BCM53128_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM53128_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXDEFERREDTRANSMITr 0x00007128

#define BCM53128_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 *
 */
typedef union BCM53128_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM53128_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM53128_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM53128_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM53128_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXDEFERREDTRANSMITr_COUNTf_GET(r) ((r).s_txdeferredtransmit[0])
#define BCM53128_A0_S_TXDEFERREDTRANSMITr_COUNTf_SET(r,f) (r).s_txdeferredtransmit[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDeferredTransmit.
 *
 */
#define BCM53128_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM53128_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM53128_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM53128_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM53128_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM53128_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM53128_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM53128_A0_S_TXDEFERREDTRANSMITr_GET
#define S_TXDEFERREDTRANSMITr_COUNTf_GET BCM53128_A0_S_TXDEFERREDTRANSMITr_COUNTf_GET
#define S_TXDEFERREDTRANSMITr_COUNTf_SET BCM53128_A0_S_TXDEFERREDTRANSMITr_COUNTf_SET
#define READ_S_TXDEFERREDTRANSMITr BCM53128_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM53128_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxDropPkts
 * BLOCKS:   SYS
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXDROPPKTSr 0x00007108

#define BCM53128_A0_S_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDropPkts.
 *
 */
typedef union BCM53128_A0_S_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_txdroppkts[1];
	uint32_t _s_txdroppkts;
} BCM53128_A0_S_TXDROPPKTSr_t;

#define BCM53128_A0_S_TXDROPPKTSr_CLR(r) (r).s_txdroppkts[0] = 0
#define BCM53128_A0_S_TXDROPPKTSr_SET(r,d) (r).s_txdroppkts[0] = d
#define BCM53128_A0_S_TXDROPPKTSr_GET(r) (r).s_txdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXDROPPKTSr_COUNTf_GET(r) ((r).s_txdroppkts[0])
#define BCM53128_A0_S_TXDROPPKTSr_COUNTf_SET(r,f) (r).s_txdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDropPkts.
 *
 */
#define BCM53128_A0_READ_S_TXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXDROPPKTSr,(r._s_txdroppkts),4)
#define BCM53128_A0_WRITE_S_TXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXDROPPKTSr,&(r._s_txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDROPPKTSr BCM53128_A0_S_TXDROPPKTSr
#define S_TXDROPPKTSr_SIZE BCM53128_A0_S_TXDROPPKTSr_SIZE
typedef BCM53128_A0_S_TXDROPPKTSr_t S_TXDROPPKTSr_t;
#define S_TXDROPPKTSr_CLR BCM53128_A0_S_TXDROPPKTSr_CLR
#define S_TXDROPPKTSr_SET BCM53128_A0_S_TXDROPPKTSr_SET
#define S_TXDROPPKTSr_GET BCM53128_A0_S_TXDROPPKTSr_GET
#define S_TXDROPPKTSr_COUNTf_GET BCM53128_A0_S_TXDROPPKTSr_COUNTf_GET
#define S_TXDROPPKTSr_COUNTf_SET BCM53128_A0_S_TXDROPPKTSr_COUNTf_SET
#define READ_S_TXDROPPKTSr BCM53128_A0_READ_S_TXDROPPKTSr
#define WRITE_S_TXDROPPKTSr BCM53128_A0_WRITE_S_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr 0x00007130

#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 *
 */
typedef union BCM53128_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM53128_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_GET(r) ((r).s_txexcessivecollision[0])
#define BCM53128_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_SET(r,f) (r).s_txexcessivecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxExcessiveCollision.
 *
 */
#define BCM53128_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM53128_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM53128_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM53128_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53128_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM53128_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM53128_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM53128_A0_S_TXEXCESSIVECOLLISIONr_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTf_GET BCM53128_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTf_SET BCM53128_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_SET
#define READ_S_TXEXCESSIVECOLLISIONr BCM53128_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM53128_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxFrameInDisc
 * BLOCKS:   SYS
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXFRAMEINDISCr 0x00007134

#define BCM53128_A0_S_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_TxFrameInDisc.
 *
 */
typedef union BCM53128_A0_S_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t s_txframeindisc[1];
	uint32_t _s_txframeindisc;
} BCM53128_A0_S_TXFRAMEINDISCr_t;

#define BCM53128_A0_S_TXFRAMEINDISCr_CLR(r) (r).s_txframeindisc[0] = 0
#define BCM53128_A0_S_TXFRAMEINDISCr_SET(r,d) (r).s_txframeindisc[0] = d
#define BCM53128_A0_S_TXFRAMEINDISCr_GET(r) (r).s_txframeindisc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXFRAMEINDISCr_COUNTf_GET(r) ((r).s_txframeindisc[0])
#define BCM53128_A0_S_TXFRAMEINDISCr_COUNTf_SET(r,f) (r).s_txframeindisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxFrameInDisc.
 *
 */
#define BCM53128_A0_READ_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXFRAMEINDISCr,(r._s_txframeindisc),4)
#define BCM53128_A0_WRITE_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXFRAMEINDISCr,&(r._s_txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXFRAMEINDISCr BCM53128_A0_S_TXFRAMEINDISCr
#define S_TXFRAMEINDISCr_SIZE BCM53128_A0_S_TXFRAMEINDISCr_SIZE
typedef BCM53128_A0_S_TXFRAMEINDISCr_t S_TXFRAMEINDISCr_t;
#define S_TXFRAMEINDISCr_CLR BCM53128_A0_S_TXFRAMEINDISCr_CLR
#define S_TXFRAMEINDISCr_SET BCM53128_A0_S_TXFRAMEINDISCr_SET
#define S_TXFRAMEINDISCr_GET BCM53128_A0_S_TXFRAMEINDISCr_GET
#define S_TXFRAMEINDISCr_COUNTf_GET BCM53128_A0_S_TXFRAMEINDISCr_COUNTf_GET
#define S_TXFRAMEINDISCr_COUNTf_SET BCM53128_A0_S_TXFRAMEINDISCr_COUNTf_SET
#define READ_S_TXFRAMEINDISCr BCM53128_A0_READ_S_TXFRAMEINDISCr
#define WRITE_S_TXFRAMEINDISCr BCM53128_A0_WRITE_S_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXLATECOLLISIONr 0x0000712c

#define BCM53128_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 *
 */
typedef union BCM53128_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM53128_A0_S_TXLATECOLLISIONr_t;

#define BCM53128_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM53128_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM53128_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXLATECOLLISIONr_COUNTf_GET(r) ((r).s_txlatecollision[0])
#define BCM53128_A0_S_TXLATECOLLISIONr_COUNTf_SET(r,f) (r).s_txlatecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxLateCollision.
 *
 */
#define BCM53128_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM53128_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM53128_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM53128_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM53128_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM53128_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM53128_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM53128_A0_S_TXLATECOLLISIONr_GET
#define S_TXLATECOLLISIONr_COUNTf_GET BCM53128_A0_S_TXLATECOLLISIONr_COUNTf_GET
#define S_TXLATECOLLISIONr_COUNTf_SET BCM53128_A0_S_TXLATECOLLISIONr_COUNTf_SET
#define READ_S_TXLATECOLLISIONr BCM53128_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM53128_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXMULTICASTPKTSr 0x00007114

#define BCM53128_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 *
 */
typedef union BCM53128_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM53128_A0_S_TXMULTICASTPKTSr_t;

#define BCM53128_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM53128_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM53128_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXMULTICASTPKTSr_COUNTf_GET(r) ((r).s_txmulticastpkts[0])
#define BCM53128_A0_S_TXMULTICASTPKTSr_COUNTf_SET(r,f) (r).s_txmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMulticastPkts.
 *
 */
#define BCM53128_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM53128_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM53128_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM53128_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM53128_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM53128_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM53128_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM53128_A0_S_TXMULTICASTPKTSr_GET
#define S_TXMULTICASTPKTSr_COUNTf_GET BCM53128_A0_S_TXMULTICASTPKTSr_COUNTf_GET
#define S_TXMULTICASTPKTSr_COUNTf_SET BCM53128_A0_S_TXMULTICASTPKTSr_COUNTf_SET
#define READ_S_TXMULTICASTPKTSr BCM53128_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM53128_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxMultipleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXMULTIPLECOLLISIONr 0x00007124

#define BCM53128_A0_S_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollision.
 *
 */
typedef union BCM53128_A0_S_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollision[1];
	uint32_t _s_txmultiplecollision;
} BCM53128_A0_S_TXMULTIPLECOLLISIONr_t;

#define BCM53128_A0_S_TXMULTIPLECOLLISIONr_CLR(r) (r).s_txmultiplecollision[0] = 0
#define BCM53128_A0_S_TXMULTIPLECOLLISIONr_SET(r,d) (r).s_txmultiplecollision[0] = d
#define BCM53128_A0_S_TXMULTIPLECOLLISIONr_GET(r) (r).s_txmultiplecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXMULTIPLECOLLISIONr_COUNTf_GET(r) ((r).s_txmultiplecollision[0])
#define BCM53128_A0_S_TXMULTIPLECOLLISIONr_COUNTf_SET(r,f) (r).s_txmultiplecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMultipleCollision.
 *
 */
#define BCM53128_A0_READ_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXMULTIPLECOLLISIONr,(r._s_txmultiplecollision),4)
#define BCM53128_A0_WRITE_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXMULTIPLECOLLISIONr,&(r._s_txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONr BCM53128_A0_S_TXMULTIPLECOLLISIONr
#define S_TXMULTIPLECOLLISIONr_SIZE BCM53128_A0_S_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53128_A0_S_TXMULTIPLECOLLISIONr_t S_TXMULTIPLECOLLISIONr_t;
#define S_TXMULTIPLECOLLISIONr_CLR BCM53128_A0_S_TXMULTIPLECOLLISIONr_CLR
#define S_TXMULTIPLECOLLISIONr_SET BCM53128_A0_S_TXMULTIPLECOLLISIONr_SET
#define S_TXMULTIPLECOLLISIONr_GET BCM53128_A0_S_TXMULTIPLECOLLISIONr_GET
#define S_TXMULTIPLECOLLISIONr_COUNTf_GET BCM53128_A0_S_TXMULTIPLECOLLISIONr_COUNTf_GET
#define S_TXMULTIPLECOLLISIONr_COUNTf_SET BCM53128_A0_S_TXMULTIPLECOLLISIONr_COUNTf_SET
#define READ_S_TXMULTIPLECOLLISIONr BCM53128_A0_READ_S_TXMULTIPLECOLLISIONr
#define WRITE_S_TXMULTIPLECOLLISIONr BCM53128_A0_WRITE_S_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     Tx Octets
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXOCTETSr 0x00007100

#define BCM53128_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 *
 */
typedef union BCM53128_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM53128_A0_S_TXOCTETSr_t;

#define BCM53128_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM53128_A0_S_TXOCTETSr_t))
#define BCM53128_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM53128_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_txoctets,0,63,a)
#define BCM53128_A0_S_TXOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_txoctets,0,63,a)

/*
 * These macros can be used to access S_TxOctets.
 *
 */
#define BCM53128_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM53128_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM53128_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM53128_A0_S_TXOCTETSr_SIZE
typedef BCM53128_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM53128_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM53128_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM53128_A0_S_TXOCTETSr_GET
#define S_TXOCTETSr_COUNTf_GET BCM53128_A0_S_TXOCTETSr_COUNTf_GET
#define S_TXOCTETSr_COUNTf_SET BCM53128_A0_S_TXOCTETSr_COUNTf_SET
#define READ_S_TXOCTETSr BCM53128_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM53128_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXPAUSEPKTSr 0x00007138

#define BCM53128_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 *
 */
typedef union BCM53128_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM53128_A0_S_TXPAUSEPKTSr_t;

#define BCM53128_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM53128_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM53128_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXPAUSEPKTSr_COUNTf_GET(r) ((r).s_txpausepkts[0])
#define BCM53128_A0_S_TXPAUSEPKTSr_COUNTf_SET(r,f) (r).s_txpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxPausePkts.
 *
 */
#define BCM53128_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM53128_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM53128_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM53128_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM53128_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM53128_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM53128_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM53128_A0_S_TXPAUSEPKTSr_GET
#define S_TXPAUSEPKTSr_COUNTf_GET BCM53128_A0_S_TXPAUSEPKTSr_COUNTf_GET
#define S_TXPAUSEPKTSr_COUNTf_SET BCM53128_A0_S_TXPAUSEPKTSr_COUNTf_SET
#define READ_S_TXPAUSEPKTSr BCM53128_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM53128_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxQPKTQ0
 * BLOCKS:   SYS
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXQPKTQ0r 0x0000710c

#define BCM53128_A0_S_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ0.
 *
 */
typedef union BCM53128_A0_S_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t s_txqpktq0[1];
	uint32_t _s_txqpktq0;
} BCM53128_A0_S_TXQPKTQ0r_t;

#define BCM53128_A0_S_TXQPKTQ0r_CLR(r) (r).s_txqpktq0[0] = 0
#define BCM53128_A0_S_TXQPKTQ0r_SET(r,d) (r).s_txqpktq0[0] = d
#define BCM53128_A0_S_TXQPKTQ0r_GET(r) (r).s_txqpktq0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXQPKTQ0r_COUNTf_GET(r) ((r).s_txqpktq0[0])
#define BCM53128_A0_S_TXQPKTQ0r_COUNTf_SET(r,f) (r).s_txqpktq0[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ0.
 *
 */
#define BCM53128_A0_READ_S_TXQPKTQ0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXQPKTQ0r,(r._s_txqpktq0),4)
#define BCM53128_A0_WRITE_S_TXQPKTQ0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXQPKTQ0r,&(r._s_txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ0r BCM53128_A0_S_TXQPKTQ0r
#define S_TXQPKTQ0r_SIZE BCM53128_A0_S_TXQPKTQ0r_SIZE
typedef BCM53128_A0_S_TXQPKTQ0r_t S_TXQPKTQ0r_t;
#define S_TXQPKTQ0r_CLR BCM53128_A0_S_TXQPKTQ0r_CLR
#define S_TXQPKTQ0r_SET BCM53128_A0_S_TXQPKTQ0r_SET
#define S_TXQPKTQ0r_GET BCM53128_A0_S_TXQPKTQ0r_GET
#define S_TXQPKTQ0r_COUNTf_GET BCM53128_A0_S_TXQPKTQ0r_COUNTf_GET
#define S_TXQPKTQ0r_COUNTf_SET BCM53128_A0_S_TXQPKTQ0r_COUNTf_SET
#define READ_S_TXQPKTQ0r BCM53128_A0_READ_S_TXQPKTQ0r
#define WRITE_S_TXQPKTQ0r BCM53128_A0_WRITE_S_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxQPKTQ1
 * BLOCKS:   SYS
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXQPKTQ1r 0x0000713c

#define BCM53128_A0_S_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ1.
 *
 */
typedef union BCM53128_A0_S_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t s_txqpktq1[1];
	uint32_t _s_txqpktq1;
} BCM53128_A0_S_TXQPKTQ1r_t;

#define BCM53128_A0_S_TXQPKTQ1r_CLR(r) (r).s_txqpktq1[0] = 0
#define BCM53128_A0_S_TXQPKTQ1r_SET(r,d) (r).s_txqpktq1[0] = d
#define BCM53128_A0_S_TXQPKTQ1r_GET(r) (r).s_txqpktq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXQPKTQ1r_COUNTf_GET(r) ((r).s_txqpktq1[0])
#define BCM53128_A0_S_TXQPKTQ1r_COUNTf_SET(r,f) (r).s_txqpktq1[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ1.
 *
 */
#define BCM53128_A0_READ_S_TXQPKTQ1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXQPKTQ1r,(r._s_txqpktq1),4)
#define BCM53128_A0_WRITE_S_TXQPKTQ1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXQPKTQ1r,&(r._s_txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ1r BCM53128_A0_S_TXQPKTQ1r
#define S_TXQPKTQ1r_SIZE BCM53128_A0_S_TXQPKTQ1r_SIZE
typedef BCM53128_A0_S_TXQPKTQ1r_t S_TXQPKTQ1r_t;
#define S_TXQPKTQ1r_CLR BCM53128_A0_S_TXQPKTQ1r_CLR
#define S_TXQPKTQ1r_SET BCM53128_A0_S_TXQPKTQ1r_SET
#define S_TXQPKTQ1r_GET BCM53128_A0_S_TXQPKTQ1r_GET
#define S_TXQPKTQ1r_COUNTf_GET BCM53128_A0_S_TXQPKTQ1r_COUNTf_GET
#define S_TXQPKTQ1r_COUNTf_SET BCM53128_A0_S_TXQPKTQ1r_COUNTf_SET
#define READ_S_TXQPKTQ1r BCM53128_A0_READ_S_TXQPKTQ1r
#define WRITE_S_TXQPKTQ1r BCM53128_A0_WRITE_S_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxQPKTQ2
 * BLOCKS:   SYS
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXQPKTQ2r 0x00007140

#define BCM53128_A0_S_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ2.
 *
 */
typedef union BCM53128_A0_S_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t s_txqpktq2[1];
	uint32_t _s_txqpktq2;
} BCM53128_A0_S_TXQPKTQ2r_t;

#define BCM53128_A0_S_TXQPKTQ2r_CLR(r) (r).s_txqpktq2[0] = 0
#define BCM53128_A0_S_TXQPKTQ2r_SET(r,d) (r).s_txqpktq2[0] = d
#define BCM53128_A0_S_TXQPKTQ2r_GET(r) (r).s_txqpktq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXQPKTQ2r_COUNTf_GET(r) ((r).s_txqpktq2[0])
#define BCM53128_A0_S_TXQPKTQ2r_COUNTf_SET(r,f) (r).s_txqpktq2[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ2.
 *
 */
#define BCM53128_A0_READ_S_TXQPKTQ2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXQPKTQ2r,(r._s_txqpktq2),4)
#define BCM53128_A0_WRITE_S_TXQPKTQ2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXQPKTQ2r,&(r._s_txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ2r BCM53128_A0_S_TXQPKTQ2r
#define S_TXQPKTQ2r_SIZE BCM53128_A0_S_TXQPKTQ2r_SIZE
typedef BCM53128_A0_S_TXQPKTQ2r_t S_TXQPKTQ2r_t;
#define S_TXQPKTQ2r_CLR BCM53128_A0_S_TXQPKTQ2r_CLR
#define S_TXQPKTQ2r_SET BCM53128_A0_S_TXQPKTQ2r_SET
#define S_TXQPKTQ2r_GET BCM53128_A0_S_TXQPKTQ2r_GET
#define S_TXQPKTQ2r_COUNTf_GET BCM53128_A0_S_TXQPKTQ2r_COUNTf_GET
#define S_TXQPKTQ2r_COUNTf_SET BCM53128_A0_S_TXQPKTQ2r_COUNTf_SET
#define READ_S_TXQPKTQ2r BCM53128_A0_READ_S_TXQPKTQ2r
#define WRITE_S_TXQPKTQ2r BCM53128_A0_WRITE_S_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxQPKTQ3
 * BLOCKS:   SYS
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXQPKTQ3r 0x00007144

#define BCM53128_A0_S_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ3.
 *
 */
typedef union BCM53128_A0_S_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t s_txqpktq3[1];
	uint32_t _s_txqpktq3;
} BCM53128_A0_S_TXQPKTQ3r_t;

#define BCM53128_A0_S_TXQPKTQ3r_CLR(r) (r).s_txqpktq3[0] = 0
#define BCM53128_A0_S_TXQPKTQ3r_SET(r,d) (r).s_txqpktq3[0] = d
#define BCM53128_A0_S_TXQPKTQ3r_GET(r) (r).s_txqpktq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXQPKTQ3r_COUNTf_GET(r) ((r).s_txqpktq3[0])
#define BCM53128_A0_S_TXQPKTQ3r_COUNTf_SET(r,f) (r).s_txqpktq3[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ3.
 *
 */
#define BCM53128_A0_READ_S_TXQPKTQ3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXQPKTQ3r,(r._s_txqpktq3),4)
#define BCM53128_A0_WRITE_S_TXQPKTQ3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXQPKTQ3r,&(r._s_txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ3r BCM53128_A0_S_TXQPKTQ3r
#define S_TXQPKTQ3r_SIZE BCM53128_A0_S_TXQPKTQ3r_SIZE
typedef BCM53128_A0_S_TXQPKTQ3r_t S_TXQPKTQ3r_t;
#define S_TXQPKTQ3r_CLR BCM53128_A0_S_TXQPKTQ3r_CLR
#define S_TXQPKTQ3r_SET BCM53128_A0_S_TXQPKTQ3r_SET
#define S_TXQPKTQ3r_GET BCM53128_A0_S_TXQPKTQ3r_GET
#define S_TXQPKTQ3r_COUNTf_GET BCM53128_A0_S_TXQPKTQ3r_COUNTf_GET
#define S_TXQPKTQ3r_COUNTf_SET BCM53128_A0_S_TXQPKTQ3r_COUNTf_SET
#define READ_S_TXQPKTQ3r BCM53128_A0_READ_S_TXQPKTQ3r
#define WRITE_S_TXQPKTQ3r BCM53128_A0_WRITE_S_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxQPKTQ4
 * BLOCKS:   SYS
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXQPKTQ4r 0x00007148

#define BCM53128_A0_S_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ4.
 *
 */
typedef union BCM53128_A0_S_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t s_txqpktq4[1];
	uint32_t _s_txqpktq4;
} BCM53128_A0_S_TXQPKTQ4r_t;

#define BCM53128_A0_S_TXQPKTQ4r_CLR(r) (r).s_txqpktq4[0] = 0
#define BCM53128_A0_S_TXQPKTQ4r_SET(r,d) (r).s_txqpktq4[0] = d
#define BCM53128_A0_S_TXQPKTQ4r_GET(r) (r).s_txqpktq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXQPKTQ4r_COUNTf_GET(r) ((r).s_txqpktq4[0])
#define BCM53128_A0_S_TXQPKTQ4r_COUNTf_SET(r,f) (r).s_txqpktq4[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ4.
 *
 */
#define BCM53128_A0_READ_S_TXQPKTQ4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXQPKTQ4r,(r._s_txqpktq4),4)
#define BCM53128_A0_WRITE_S_TXQPKTQ4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXQPKTQ4r,&(r._s_txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ4r BCM53128_A0_S_TXQPKTQ4r
#define S_TXQPKTQ4r_SIZE BCM53128_A0_S_TXQPKTQ4r_SIZE
typedef BCM53128_A0_S_TXQPKTQ4r_t S_TXQPKTQ4r_t;
#define S_TXQPKTQ4r_CLR BCM53128_A0_S_TXQPKTQ4r_CLR
#define S_TXQPKTQ4r_SET BCM53128_A0_S_TXQPKTQ4r_SET
#define S_TXQPKTQ4r_GET BCM53128_A0_S_TXQPKTQ4r_GET
#define S_TXQPKTQ4r_COUNTf_GET BCM53128_A0_S_TXQPKTQ4r_COUNTf_GET
#define S_TXQPKTQ4r_COUNTf_SET BCM53128_A0_S_TXQPKTQ4r_COUNTf_SET
#define READ_S_TXQPKTQ4r BCM53128_A0_READ_S_TXQPKTQ4r
#define WRITE_S_TXQPKTQ4r BCM53128_A0_WRITE_S_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxQPKTQ5
 * BLOCKS:   SYS
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXQPKTQ5r 0x0000714c

#define BCM53128_A0_S_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ5.
 *
 */
typedef union BCM53128_A0_S_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t s_txqpktq5[1];
	uint32_t _s_txqpktq5;
} BCM53128_A0_S_TXQPKTQ5r_t;

#define BCM53128_A0_S_TXQPKTQ5r_CLR(r) (r).s_txqpktq5[0] = 0
#define BCM53128_A0_S_TXQPKTQ5r_SET(r,d) (r).s_txqpktq5[0] = d
#define BCM53128_A0_S_TXQPKTQ5r_GET(r) (r).s_txqpktq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXQPKTQ5r_COUNTf_GET(r) ((r).s_txqpktq5[0])
#define BCM53128_A0_S_TXQPKTQ5r_COUNTf_SET(r,f) (r).s_txqpktq5[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ5.
 *
 */
#define BCM53128_A0_READ_S_TXQPKTQ5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXQPKTQ5r,(r._s_txqpktq5),4)
#define BCM53128_A0_WRITE_S_TXQPKTQ5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXQPKTQ5r,&(r._s_txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ5r BCM53128_A0_S_TXQPKTQ5r
#define S_TXQPKTQ5r_SIZE BCM53128_A0_S_TXQPKTQ5r_SIZE
typedef BCM53128_A0_S_TXQPKTQ5r_t S_TXQPKTQ5r_t;
#define S_TXQPKTQ5r_CLR BCM53128_A0_S_TXQPKTQ5r_CLR
#define S_TXQPKTQ5r_SET BCM53128_A0_S_TXQPKTQ5r_SET
#define S_TXQPKTQ5r_GET BCM53128_A0_S_TXQPKTQ5r_GET
#define S_TXQPKTQ5r_COUNTf_GET BCM53128_A0_S_TXQPKTQ5r_COUNTf_GET
#define S_TXQPKTQ5r_COUNTf_SET BCM53128_A0_S_TXQPKTQ5r_COUNTf_SET
#define READ_S_TXQPKTQ5r BCM53128_A0_READ_S_TXQPKTQ5r
#define WRITE_S_TXQPKTQ5r BCM53128_A0_WRITE_S_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxSingleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXSINGLECOLLISIONr 0x00007120

#define BCM53128_A0_S_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollision.
 *
 */
typedef union BCM53128_A0_S_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollision[1];
	uint32_t _s_txsinglecollision;
} BCM53128_A0_S_TXSINGLECOLLISIONr_t;

#define BCM53128_A0_S_TXSINGLECOLLISIONr_CLR(r) (r).s_txsinglecollision[0] = 0
#define BCM53128_A0_S_TXSINGLECOLLISIONr_SET(r,d) (r).s_txsinglecollision[0] = d
#define BCM53128_A0_S_TXSINGLECOLLISIONr_GET(r) (r).s_txsinglecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXSINGLECOLLISIONr_COUNTf_GET(r) ((r).s_txsinglecollision[0])
#define BCM53128_A0_S_TXSINGLECOLLISIONr_COUNTf_SET(r,f) (r).s_txsinglecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxSingleCollision.
 *
 */
#define BCM53128_A0_READ_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXSINGLECOLLISIONr,(r._s_txsinglecollision),4)
#define BCM53128_A0_WRITE_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXSINGLECOLLISIONr,&(r._s_txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONr BCM53128_A0_S_TXSINGLECOLLISIONr
#define S_TXSINGLECOLLISIONr_SIZE BCM53128_A0_S_TXSINGLECOLLISIONr_SIZE
typedef BCM53128_A0_S_TXSINGLECOLLISIONr_t S_TXSINGLECOLLISIONr_t;
#define S_TXSINGLECOLLISIONr_CLR BCM53128_A0_S_TXSINGLECOLLISIONr_CLR
#define S_TXSINGLECOLLISIONr_SET BCM53128_A0_S_TXSINGLECOLLISIONr_SET
#define S_TXSINGLECOLLISIONr_GET BCM53128_A0_S_TXSINGLECOLLISIONr_GET
#define S_TXSINGLECOLLISIONr_COUNTf_GET BCM53128_A0_S_TXSINGLECOLLISIONr_COUNTf_GET
#define S_TXSINGLECOLLISIONr_COUNTf_SET BCM53128_A0_S_TXSINGLECOLLISIONr_COUNTf_SET
#define READ_S_TXSINGLECOLLISIONr BCM53128_A0_READ_S_TXSINGLECOLLISIONr
#define WRITE_S_TXSINGLECOLLISIONr BCM53128_A0_WRITE_S_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53128_A0_S_TXUNICASTPKTSr 0x00007118

#define BCM53128_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 *
 */
typedef union BCM53128_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM53128_A0_S_TXUNICASTPKTSr_t;

#define BCM53128_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM53128_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM53128_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_S_TXUNICASTPKTSr_COUNTf_GET(r) ((r).s_txunicastpkts[0])
#define BCM53128_A0_S_TXUNICASTPKTSr_COUNTf_SET(r,f) (r).s_txunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxUnicastPkts.
 *
 */
#define BCM53128_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM53128_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM53128_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM53128_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM53128_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM53128_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM53128_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM53128_A0_S_TXUNICASTPKTSr_GET
#define S_TXUNICASTPKTSr_COUNTf_GET BCM53128_A0_S_TXUNICASTPKTSr_COUNTf_GET
#define S_TXUNICASTPKTSr_COUNTf_SET BCM53128_A0_S_TXUNICASTPKTSr_COUNTf_SET
#define READ_S_TXUNICASTPKTSr BCM53128_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM53128_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_S_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     TC to COS Mapping Register
 * SIZE:     16
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.
 *     PRT111_TO_QID    *** Note that ***Queue ID 0: 00Queue ID 1: 01Queue ID 2: 10Queue ID 3: 11Priority ID 111 mapped to TX Queue ID.
 *
 ******************************************************************************/
#define BCM53128_A0_TC2COS_MAPr 0x00003062

#define BCM53128_A0_TC2COS_MAPr_SIZE 2

/*
 * This structure should be used to declare and program TC2COS_MAP.
 *
 */
typedef union BCM53128_A0_TC2COS_MAPr_s {
	uint32_t v[1];
	uint32_t tc2cos_map[1];
	uint32_t _tc2cos_map;
} BCM53128_A0_TC2COS_MAPr_t;

#define BCM53128_A0_TC2COS_MAPr_CLR(r) (r).tc2cos_map[0] = 0
#define BCM53128_A0_TC2COS_MAPr_SET(r,d) (r).tc2cos_map[0] = d
#define BCM53128_A0_TC2COS_MAPr_GET(r) (r).tc2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TC2COS_MAPr_PRT000_TO_QIDf_GET(r) (((r).tc2cos_map[0]) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT000_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_TC2COS_MAPr_PRT001_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 2) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT001_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_TC2COS_MAPr_PRT010_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 4) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT010_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53128_A0_TC2COS_MAPr_PRT011_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 6) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT011_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53128_A0_TC2COS_MAPr_PRT100_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 8) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT100_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53128_A0_TC2COS_MAPr_PRT101_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 10) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT101_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53128_A0_TC2COS_MAPr_PRT110_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 12) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT110_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53128_A0_TC2COS_MAPr_PRT111_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 14) & 0x3)
#define BCM53128_A0_TC2COS_MAPr_PRT111_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access TC2COS_MAP.
 *
 */
#define BCM53128_A0_READ_TC2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TC2COS_MAPr,(r._tc2cos_map),2)
#define BCM53128_A0_WRITE_TC2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TC2COS_MAPr,&(r._tc2cos_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TC2COS_MAPr BCM53128_A0_TC2COS_MAPr
#define TC2COS_MAPr_SIZE BCM53128_A0_TC2COS_MAPr_SIZE
typedef BCM53128_A0_TC2COS_MAPr_t TC2COS_MAPr_t;
#define TC2COS_MAPr_CLR BCM53128_A0_TC2COS_MAPr_CLR
#define TC2COS_MAPr_SET BCM53128_A0_TC2COS_MAPr_SET
#define TC2COS_MAPr_GET BCM53128_A0_TC2COS_MAPr_GET
#define TC2COS_MAPr_PRT000_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT000_TO_QIDf_GET
#define TC2COS_MAPr_PRT000_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT000_TO_QIDf_SET
#define TC2COS_MAPr_PRT001_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT001_TO_QIDf_GET
#define TC2COS_MAPr_PRT001_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT001_TO_QIDf_SET
#define TC2COS_MAPr_PRT010_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT010_TO_QIDf_GET
#define TC2COS_MAPr_PRT010_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT010_TO_QIDf_SET
#define TC2COS_MAPr_PRT011_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT011_TO_QIDf_GET
#define TC2COS_MAPr_PRT011_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT011_TO_QIDf_SET
#define TC2COS_MAPr_PRT100_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT100_TO_QIDf_GET
#define TC2COS_MAPr_PRT100_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT100_TO_QIDf_SET
#define TC2COS_MAPr_PRT101_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT101_TO_QIDf_GET
#define TC2COS_MAPr_PRT101_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT101_TO_QIDf_SET
#define TC2COS_MAPr_PRT110_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT110_TO_QIDf_GET
#define TC2COS_MAPr_PRT110_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT110_TO_QIDf_SET
#define TC2COS_MAPr_PRT111_TO_QIDf_GET BCM53128_A0_TC2COS_MAPr_PRT111_TO_QIDf_GET
#define TC2COS_MAPr_PRT111_TO_QIDf_SET BCM53128_A0_TC2COS_MAPr_PRT111_TO_QIDf_SET
#define READ_TC2COS_MAPr BCM53128_A0_READ_TC2COS_MAPr
#define WRITE_TC2COS_MAPr BCM53128_A0_WRITE_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION0_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 0 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION0_REGr 0x0000a280

#define BCM53128_A0_TCP_UDP_ACTION0_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION0_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION0_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action0_reg[1];
	uint32_t _tcp_udp_action0_reg;
} BCM53128_A0_TCP_UDP_ACTION0_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION0_REGr_CLR(r) (r).tcp_udp_action0_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_SET(r,d) (r).tcp_udp_action0_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_GET(r) (r).tcp_udp_action0_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action0_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action0_reg[0]=(((r).tcp_udp_action0_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action0_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action0_reg[0]=(((r).tcp_udp_action0_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action0_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action0_reg[0]=(((r).tcp_udp_action0_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action0_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action0_reg[0]=(((r).tcp_udp_action0_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_TCf_GET(r) ((((r).tcp_udp_action0_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_TCf_SET(r,f) (r).tcp_udp_action0_reg[0]=(((r).tcp_udp_action0_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action0_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action0_reg[0]=(((r).tcp_udp_action0_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION0_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION0_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION0_REGr,(r._tcp_udp_action0_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION0_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION0_REGr,&(r._tcp_udp_action0_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION0_REGr BCM53128_A0_TCP_UDP_ACTION0_REGr
#define TCP_UDP_ACTION0_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION0_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION0_REGr_t TCP_UDP_ACTION0_REGr_t;
#define TCP_UDP_ACTION0_REGr_CLR BCM53128_A0_TCP_UDP_ACTION0_REGr_CLR
#define TCP_UDP_ACTION0_REGr_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_SET
#define TCP_UDP_ACTION0_REGr_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_GET
#define TCP_UDP_ACTION0_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION0_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION0_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION0_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION0_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION0_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION0_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION0_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION0_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_TCf_GET
#define TCP_UDP_ACTION0_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_TCf_SET
#define TCP_UDP_ACTION0_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION0_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION0_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION0_REGr BCM53128_A0_READ_TCP_UDP_ACTION0_REGr
#define WRITE_TCP_UDP_ACTION0_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION0_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION0_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION10_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 10 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION10_REGr 0x0000a2a8

#define BCM53128_A0_TCP_UDP_ACTION10_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION10_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION10_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action10_reg[1];
	uint32_t _tcp_udp_action10_reg;
} BCM53128_A0_TCP_UDP_ACTION10_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION10_REGr_CLR(r) (r).tcp_udp_action10_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_SET(r,d) (r).tcp_udp_action10_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_GET(r) (r).tcp_udp_action10_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action10_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action10_reg[0]=(((r).tcp_udp_action10_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action10_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action10_reg[0]=(((r).tcp_udp_action10_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action10_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action10_reg[0]=(((r).tcp_udp_action10_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action10_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action10_reg[0]=(((r).tcp_udp_action10_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_TCf_GET(r) ((((r).tcp_udp_action10_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_TCf_SET(r,f) (r).tcp_udp_action10_reg[0]=(((r).tcp_udp_action10_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action10_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action10_reg[0]=(((r).tcp_udp_action10_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION10_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION10_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION10_REGr,(r._tcp_udp_action10_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION10_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION10_REGr,&(r._tcp_udp_action10_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION10_REGr BCM53128_A0_TCP_UDP_ACTION10_REGr
#define TCP_UDP_ACTION10_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION10_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION10_REGr_t TCP_UDP_ACTION10_REGr_t;
#define TCP_UDP_ACTION10_REGr_CLR BCM53128_A0_TCP_UDP_ACTION10_REGr_CLR
#define TCP_UDP_ACTION10_REGr_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_SET
#define TCP_UDP_ACTION10_REGr_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_GET
#define TCP_UDP_ACTION10_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION10_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION10_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION10_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION10_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION10_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION10_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION10_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION10_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_TCf_GET
#define TCP_UDP_ACTION10_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_TCf_SET
#define TCP_UDP_ACTION10_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION10_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION10_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION10_REGr BCM53128_A0_READ_TCP_UDP_ACTION10_REGr
#define WRITE_TCP_UDP_ACTION10_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION10_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION10_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION11_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 11 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION11_REGr 0x0000a2ac

#define BCM53128_A0_TCP_UDP_ACTION11_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION11_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION11_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action11_reg[1];
	uint32_t _tcp_udp_action11_reg;
} BCM53128_A0_TCP_UDP_ACTION11_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION11_REGr_CLR(r) (r).tcp_udp_action11_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_SET(r,d) (r).tcp_udp_action11_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_GET(r) (r).tcp_udp_action11_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action11_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action11_reg[0]=(((r).tcp_udp_action11_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action11_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action11_reg[0]=(((r).tcp_udp_action11_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action11_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action11_reg[0]=(((r).tcp_udp_action11_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action11_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action11_reg[0]=(((r).tcp_udp_action11_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_TCf_GET(r) ((((r).tcp_udp_action11_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_TCf_SET(r,f) (r).tcp_udp_action11_reg[0]=(((r).tcp_udp_action11_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action11_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action11_reg[0]=(((r).tcp_udp_action11_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION11_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION11_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION11_REGr,(r._tcp_udp_action11_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION11_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION11_REGr,&(r._tcp_udp_action11_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION11_REGr BCM53128_A0_TCP_UDP_ACTION11_REGr
#define TCP_UDP_ACTION11_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION11_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION11_REGr_t TCP_UDP_ACTION11_REGr_t;
#define TCP_UDP_ACTION11_REGr_CLR BCM53128_A0_TCP_UDP_ACTION11_REGr_CLR
#define TCP_UDP_ACTION11_REGr_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_SET
#define TCP_UDP_ACTION11_REGr_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_GET
#define TCP_UDP_ACTION11_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION11_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION11_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION11_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION11_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION11_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION11_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION11_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION11_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_TCf_GET
#define TCP_UDP_ACTION11_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_TCf_SET
#define TCP_UDP_ACTION11_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION11_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION11_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION11_REGr BCM53128_A0_READ_TCP_UDP_ACTION11_REGr
#define WRITE_TCP_UDP_ACTION11_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION11_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION11_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION12_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 12 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION12_REGr 0x0000a2b0

#define BCM53128_A0_TCP_UDP_ACTION12_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION12_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION12_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action12_reg[1];
	uint32_t _tcp_udp_action12_reg;
} BCM53128_A0_TCP_UDP_ACTION12_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION12_REGr_CLR(r) (r).tcp_udp_action12_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_SET(r,d) (r).tcp_udp_action12_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_GET(r) (r).tcp_udp_action12_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action12_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action12_reg[0]=(((r).tcp_udp_action12_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action12_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action12_reg[0]=(((r).tcp_udp_action12_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action12_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action12_reg[0]=(((r).tcp_udp_action12_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action12_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action12_reg[0]=(((r).tcp_udp_action12_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_TCf_GET(r) ((((r).tcp_udp_action12_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_TCf_SET(r,f) (r).tcp_udp_action12_reg[0]=(((r).tcp_udp_action12_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action12_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action12_reg[0]=(((r).tcp_udp_action12_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION12_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION12_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION12_REGr,(r._tcp_udp_action12_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION12_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION12_REGr,&(r._tcp_udp_action12_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION12_REGr BCM53128_A0_TCP_UDP_ACTION12_REGr
#define TCP_UDP_ACTION12_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION12_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION12_REGr_t TCP_UDP_ACTION12_REGr_t;
#define TCP_UDP_ACTION12_REGr_CLR BCM53128_A0_TCP_UDP_ACTION12_REGr_CLR
#define TCP_UDP_ACTION12_REGr_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_SET
#define TCP_UDP_ACTION12_REGr_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_GET
#define TCP_UDP_ACTION12_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION12_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION12_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION12_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION12_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION12_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION12_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION12_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION12_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_TCf_GET
#define TCP_UDP_ACTION12_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_TCf_SET
#define TCP_UDP_ACTION12_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION12_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION12_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION12_REGr BCM53128_A0_READ_TCP_UDP_ACTION12_REGr
#define WRITE_TCP_UDP_ACTION12_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION12_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION12_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION13_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 13 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION13_REGr 0x0000a2b4

#define BCM53128_A0_TCP_UDP_ACTION13_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION13_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION13_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action13_reg[1];
	uint32_t _tcp_udp_action13_reg;
} BCM53128_A0_TCP_UDP_ACTION13_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION13_REGr_CLR(r) (r).tcp_udp_action13_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_SET(r,d) (r).tcp_udp_action13_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_GET(r) (r).tcp_udp_action13_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action13_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action13_reg[0]=(((r).tcp_udp_action13_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action13_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action13_reg[0]=(((r).tcp_udp_action13_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action13_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action13_reg[0]=(((r).tcp_udp_action13_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action13_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action13_reg[0]=(((r).tcp_udp_action13_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_TCf_GET(r) ((((r).tcp_udp_action13_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_TCf_SET(r,f) (r).tcp_udp_action13_reg[0]=(((r).tcp_udp_action13_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action13_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action13_reg[0]=(((r).tcp_udp_action13_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION13_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION13_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION13_REGr,(r._tcp_udp_action13_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION13_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION13_REGr,&(r._tcp_udp_action13_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION13_REGr BCM53128_A0_TCP_UDP_ACTION13_REGr
#define TCP_UDP_ACTION13_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION13_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION13_REGr_t TCP_UDP_ACTION13_REGr_t;
#define TCP_UDP_ACTION13_REGr_CLR BCM53128_A0_TCP_UDP_ACTION13_REGr_CLR
#define TCP_UDP_ACTION13_REGr_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_SET
#define TCP_UDP_ACTION13_REGr_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_GET
#define TCP_UDP_ACTION13_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION13_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION13_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION13_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION13_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION13_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION13_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION13_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION13_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_TCf_GET
#define TCP_UDP_ACTION13_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_TCf_SET
#define TCP_UDP_ACTION13_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION13_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION13_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION13_REGr BCM53128_A0_READ_TCP_UDP_ACTION13_REGr
#define WRITE_TCP_UDP_ACTION13_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION13_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION13_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION14_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 14 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION14_REGr 0x0000a2b8

#define BCM53128_A0_TCP_UDP_ACTION14_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION14_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION14_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action14_reg[1];
	uint32_t _tcp_udp_action14_reg;
} BCM53128_A0_TCP_UDP_ACTION14_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION14_REGr_CLR(r) (r).tcp_udp_action14_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_SET(r,d) (r).tcp_udp_action14_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_GET(r) (r).tcp_udp_action14_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action14_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action14_reg[0]=(((r).tcp_udp_action14_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action14_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action14_reg[0]=(((r).tcp_udp_action14_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action14_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action14_reg[0]=(((r).tcp_udp_action14_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action14_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action14_reg[0]=(((r).tcp_udp_action14_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_TCf_GET(r) ((((r).tcp_udp_action14_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_TCf_SET(r,f) (r).tcp_udp_action14_reg[0]=(((r).tcp_udp_action14_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action14_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action14_reg[0]=(((r).tcp_udp_action14_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION14_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION14_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION14_REGr,(r._tcp_udp_action14_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION14_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION14_REGr,&(r._tcp_udp_action14_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION14_REGr BCM53128_A0_TCP_UDP_ACTION14_REGr
#define TCP_UDP_ACTION14_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION14_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION14_REGr_t TCP_UDP_ACTION14_REGr_t;
#define TCP_UDP_ACTION14_REGr_CLR BCM53128_A0_TCP_UDP_ACTION14_REGr_CLR
#define TCP_UDP_ACTION14_REGr_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_SET
#define TCP_UDP_ACTION14_REGr_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_GET
#define TCP_UDP_ACTION14_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION14_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION14_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION14_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION14_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION14_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION14_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION14_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION14_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_TCf_GET
#define TCP_UDP_ACTION14_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_TCf_SET
#define TCP_UDP_ACTION14_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION14_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION14_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION14_REGr BCM53128_A0_READ_TCP_UDP_ACTION14_REGr
#define WRITE_TCP_UDP_ACTION14_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION14_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION14_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION15_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 15 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION15_REGr 0x0000a2bc

#define BCM53128_A0_TCP_UDP_ACTION15_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION15_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION15_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action15_reg[1];
	uint32_t _tcp_udp_action15_reg;
} BCM53128_A0_TCP_UDP_ACTION15_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION15_REGr_CLR(r) (r).tcp_udp_action15_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_SET(r,d) (r).tcp_udp_action15_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_GET(r) (r).tcp_udp_action15_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action15_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action15_reg[0]=(((r).tcp_udp_action15_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action15_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action15_reg[0]=(((r).tcp_udp_action15_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action15_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action15_reg[0]=(((r).tcp_udp_action15_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action15_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action15_reg[0]=(((r).tcp_udp_action15_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_TCf_GET(r) ((((r).tcp_udp_action15_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_TCf_SET(r,f) (r).tcp_udp_action15_reg[0]=(((r).tcp_udp_action15_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action15_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action15_reg[0]=(((r).tcp_udp_action15_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION15_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION15_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION15_REGr,(r._tcp_udp_action15_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION15_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION15_REGr,&(r._tcp_udp_action15_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION15_REGr BCM53128_A0_TCP_UDP_ACTION15_REGr
#define TCP_UDP_ACTION15_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION15_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION15_REGr_t TCP_UDP_ACTION15_REGr_t;
#define TCP_UDP_ACTION15_REGr_CLR BCM53128_A0_TCP_UDP_ACTION15_REGr_CLR
#define TCP_UDP_ACTION15_REGr_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_SET
#define TCP_UDP_ACTION15_REGr_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_GET
#define TCP_UDP_ACTION15_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION15_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION15_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION15_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION15_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION15_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION15_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION15_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION15_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_TCf_GET
#define TCP_UDP_ACTION15_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_TCf_SET
#define TCP_UDP_ACTION15_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION15_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION15_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION15_REGr BCM53128_A0_READ_TCP_UDP_ACTION15_REGr
#define WRITE_TCP_UDP_ACTION15_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION15_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION15_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION1_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 1 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION1_REGr 0x0000a284

#define BCM53128_A0_TCP_UDP_ACTION1_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION1_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION1_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action1_reg[1];
	uint32_t _tcp_udp_action1_reg;
} BCM53128_A0_TCP_UDP_ACTION1_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION1_REGr_CLR(r) (r).tcp_udp_action1_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_SET(r,d) (r).tcp_udp_action1_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_GET(r) (r).tcp_udp_action1_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action1_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action1_reg[0]=(((r).tcp_udp_action1_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action1_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action1_reg[0]=(((r).tcp_udp_action1_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action1_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action1_reg[0]=(((r).tcp_udp_action1_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action1_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action1_reg[0]=(((r).tcp_udp_action1_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_TCf_GET(r) ((((r).tcp_udp_action1_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_TCf_SET(r,f) (r).tcp_udp_action1_reg[0]=(((r).tcp_udp_action1_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action1_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action1_reg[0]=(((r).tcp_udp_action1_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION1_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION1_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION1_REGr,(r._tcp_udp_action1_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION1_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION1_REGr,&(r._tcp_udp_action1_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION1_REGr BCM53128_A0_TCP_UDP_ACTION1_REGr
#define TCP_UDP_ACTION1_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION1_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION1_REGr_t TCP_UDP_ACTION1_REGr_t;
#define TCP_UDP_ACTION1_REGr_CLR BCM53128_A0_TCP_UDP_ACTION1_REGr_CLR
#define TCP_UDP_ACTION1_REGr_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_SET
#define TCP_UDP_ACTION1_REGr_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_GET
#define TCP_UDP_ACTION1_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION1_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION1_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION1_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION1_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION1_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION1_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION1_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION1_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_TCf_GET
#define TCP_UDP_ACTION1_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_TCf_SET
#define TCP_UDP_ACTION1_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION1_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION1_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION1_REGr BCM53128_A0_READ_TCP_UDP_ACTION1_REGr
#define WRITE_TCP_UDP_ACTION1_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION1_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION1_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION2_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 2 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION2_REGr 0x0000a288

#define BCM53128_A0_TCP_UDP_ACTION2_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION2_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION2_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action2_reg[1];
	uint32_t _tcp_udp_action2_reg;
} BCM53128_A0_TCP_UDP_ACTION2_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION2_REGr_CLR(r) (r).tcp_udp_action2_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_SET(r,d) (r).tcp_udp_action2_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_GET(r) (r).tcp_udp_action2_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action2_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action2_reg[0]=(((r).tcp_udp_action2_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action2_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action2_reg[0]=(((r).tcp_udp_action2_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action2_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action2_reg[0]=(((r).tcp_udp_action2_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action2_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action2_reg[0]=(((r).tcp_udp_action2_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_TCf_GET(r) ((((r).tcp_udp_action2_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_TCf_SET(r,f) (r).tcp_udp_action2_reg[0]=(((r).tcp_udp_action2_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action2_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action2_reg[0]=(((r).tcp_udp_action2_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION2_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION2_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION2_REGr,(r._tcp_udp_action2_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION2_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION2_REGr,&(r._tcp_udp_action2_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION2_REGr BCM53128_A0_TCP_UDP_ACTION2_REGr
#define TCP_UDP_ACTION2_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION2_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION2_REGr_t TCP_UDP_ACTION2_REGr_t;
#define TCP_UDP_ACTION2_REGr_CLR BCM53128_A0_TCP_UDP_ACTION2_REGr_CLR
#define TCP_UDP_ACTION2_REGr_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_SET
#define TCP_UDP_ACTION2_REGr_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_GET
#define TCP_UDP_ACTION2_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION2_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION2_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION2_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION2_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION2_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION2_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION2_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION2_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_TCf_GET
#define TCP_UDP_ACTION2_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_TCf_SET
#define TCP_UDP_ACTION2_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION2_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION2_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION2_REGr BCM53128_A0_READ_TCP_UDP_ACTION2_REGr
#define WRITE_TCP_UDP_ACTION2_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION2_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION2_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION3_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 3 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION3_REGr 0x0000a28c

#define BCM53128_A0_TCP_UDP_ACTION3_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION3_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION3_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action3_reg[1];
	uint32_t _tcp_udp_action3_reg;
} BCM53128_A0_TCP_UDP_ACTION3_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION3_REGr_CLR(r) (r).tcp_udp_action3_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_SET(r,d) (r).tcp_udp_action3_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_GET(r) (r).tcp_udp_action3_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action3_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action3_reg[0]=(((r).tcp_udp_action3_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action3_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action3_reg[0]=(((r).tcp_udp_action3_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action3_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action3_reg[0]=(((r).tcp_udp_action3_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action3_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action3_reg[0]=(((r).tcp_udp_action3_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_TCf_GET(r) ((((r).tcp_udp_action3_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_TCf_SET(r,f) (r).tcp_udp_action3_reg[0]=(((r).tcp_udp_action3_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action3_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action3_reg[0]=(((r).tcp_udp_action3_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION3_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION3_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION3_REGr,(r._tcp_udp_action3_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION3_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION3_REGr,&(r._tcp_udp_action3_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION3_REGr BCM53128_A0_TCP_UDP_ACTION3_REGr
#define TCP_UDP_ACTION3_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION3_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION3_REGr_t TCP_UDP_ACTION3_REGr_t;
#define TCP_UDP_ACTION3_REGr_CLR BCM53128_A0_TCP_UDP_ACTION3_REGr_CLR
#define TCP_UDP_ACTION3_REGr_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_SET
#define TCP_UDP_ACTION3_REGr_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_GET
#define TCP_UDP_ACTION3_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION3_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION3_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION3_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION3_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION3_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION3_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION3_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION3_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_TCf_GET
#define TCP_UDP_ACTION3_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_TCf_SET
#define TCP_UDP_ACTION3_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION3_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION3_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION3_REGr BCM53128_A0_READ_TCP_UDP_ACTION3_REGr
#define WRITE_TCP_UDP_ACTION3_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION3_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION3_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION4_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 4 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION4_REGr 0x0000a290

#define BCM53128_A0_TCP_UDP_ACTION4_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION4_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION4_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action4_reg[1];
	uint32_t _tcp_udp_action4_reg;
} BCM53128_A0_TCP_UDP_ACTION4_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION4_REGr_CLR(r) (r).tcp_udp_action4_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_SET(r,d) (r).tcp_udp_action4_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_GET(r) (r).tcp_udp_action4_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action4_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action4_reg[0]=(((r).tcp_udp_action4_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action4_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action4_reg[0]=(((r).tcp_udp_action4_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action4_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action4_reg[0]=(((r).tcp_udp_action4_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action4_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action4_reg[0]=(((r).tcp_udp_action4_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_TCf_GET(r) ((((r).tcp_udp_action4_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_TCf_SET(r,f) (r).tcp_udp_action4_reg[0]=(((r).tcp_udp_action4_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action4_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action4_reg[0]=(((r).tcp_udp_action4_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION4_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION4_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION4_REGr,(r._tcp_udp_action4_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION4_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION4_REGr,&(r._tcp_udp_action4_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION4_REGr BCM53128_A0_TCP_UDP_ACTION4_REGr
#define TCP_UDP_ACTION4_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION4_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION4_REGr_t TCP_UDP_ACTION4_REGr_t;
#define TCP_UDP_ACTION4_REGr_CLR BCM53128_A0_TCP_UDP_ACTION4_REGr_CLR
#define TCP_UDP_ACTION4_REGr_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_SET
#define TCP_UDP_ACTION4_REGr_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_GET
#define TCP_UDP_ACTION4_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION4_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION4_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION4_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION4_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION4_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION4_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION4_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION4_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_TCf_GET
#define TCP_UDP_ACTION4_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_TCf_SET
#define TCP_UDP_ACTION4_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION4_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION4_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION4_REGr BCM53128_A0_READ_TCP_UDP_ACTION4_REGr
#define WRITE_TCP_UDP_ACTION4_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION4_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION4_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION5_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 5 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION5_REGr 0x0000a294

#define BCM53128_A0_TCP_UDP_ACTION5_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION5_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION5_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action5_reg[1];
	uint32_t _tcp_udp_action5_reg;
} BCM53128_A0_TCP_UDP_ACTION5_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION5_REGr_CLR(r) (r).tcp_udp_action5_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_SET(r,d) (r).tcp_udp_action5_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_GET(r) (r).tcp_udp_action5_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action5_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action5_reg[0]=(((r).tcp_udp_action5_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action5_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action5_reg[0]=(((r).tcp_udp_action5_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action5_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action5_reg[0]=(((r).tcp_udp_action5_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action5_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action5_reg[0]=(((r).tcp_udp_action5_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_TCf_GET(r) ((((r).tcp_udp_action5_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_TCf_SET(r,f) (r).tcp_udp_action5_reg[0]=(((r).tcp_udp_action5_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action5_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action5_reg[0]=(((r).tcp_udp_action5_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION5_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION5_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION5_REGr,(r._tcp_udp_action5_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION5_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION5_REGr,&(r._tcp_udp_action5_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION5_REGr BCM53128_A0_TCP_UDP_ACTION5_REGr
#define TCP_UDP_ACTION5_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION5_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION5_REGr_t TCP_UDP_ACTION5_REGr_t;
#define TCP_UDP_ACTION5_REGr_CLR BCM53128_A0_TCP_UDP_ACTION5_REGr_CLR
#define TCP_UDP_ACTION5_REGr_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_SET
#define TCP_UDP_ACTION5_REGr_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_GET
#define TCP_UDP_ACTION5_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION5_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION5_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION5_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION5_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION5_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION5_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION5_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION5_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_TCf_GET
#define TCP_UDP_ACTION5_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_TCf_SET
#define TCP_UDP_ACTION5_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION5_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION5_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION5_REGr BCM53128_A0_READ_TCP_UDP_ACTION5_REGr
#define WRITE_TCP_UDP_ACTION5_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION5_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION5_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION6_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 6 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION6_REGr 0x0000a298

#define BCM53128_A0_TCP_UDP_ACTION6_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION6_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION6_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action6_reg[1];
	uint32_t _tcp_udp_action6_reg;
} BCM53128_A0_TCP_UDP_ACTION6_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION6_REGr_CLR(r) (r).tcp_udp_action6_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_SET(r,d) (r).tcp_udp_action6_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_GET(r) (r).tcp_udp_action6_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action6_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action6_reg[0]=(((r).tcp_udp_action6_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action6_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action6_reg[0]=(((r).tcp_udp_action6_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action6_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action6_reg[0]=(((r).tcp_udp_action6_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action6_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action6_reg[0]=(((r).tcp_udp_action6_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_TCf_GET(r) ((((r).tcp_udp_action6_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_TCf_SET(r,f) (r).tcp_udp_action6_reg[0]=(((r).tcp_udp_action6_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action6_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action6_reg[0]=(((r).tcp_udp_action6_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION6_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION6_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION6_REGr,(r._tcp_udp_action6_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION6_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION6_REGr,&(r._tcp_udp_action6_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION6_REGr BCM53128_A0_TCP_UDP_ACTION6_REGr
#define TCP_UDP_ACTION6_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION6_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION6_REGr_t TCP_UDP_ACTION6_REGr_t;
#define TCP_UDP_ACTION6_REGr_CLR BCM53128_A0_TCP_UDP_ACTION6_REGr_CLR
#define TCP_UDP_ACTION6_REGr_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_SET
#define TCP_UDP_ACTION6_REGr_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_GET
#define TCP_UDP_ACTION6_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION6_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION6_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION6_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION6_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION6_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION6_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION6_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION6_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_TCf_GET
#define TCP_UDP_ACTION6_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_TCf_SET
#define TCP_UDP_ACTION6_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION6_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION6_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION6_REGr BCM53128_A0_READ_TCP_UDP_ACTION6_REGr
#define WRITE_TCP_UDP_ACTION6_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION6_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION6_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION7_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 7 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION7_REGr 0x0000a29c

#define BCM53128_A0_TCP_UDP_ACTION7_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION7_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION7_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action7_reg[1];
	uint32_t _tcp_udp_action7_reg;
} BCM53128_A0_TCP_UDP_ACTION7_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION7_REGr_CLR(r) (r).tcp_udp_action7_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_SET(r,d) (r).tcp_udp_action7_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_GET(r) (r).tcp_udp_action7_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action7_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action7_reg[0]=(((r).tcp_udp_action7_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action7_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action7_reg[0]=(((r).tcp_udp_action7_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action7_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action7_reg[0]=(((r).tcp_udp_action7_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action7_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action7_reg[0]=(((r).tcp_udp_action7_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_TCf_GET(r) ((((r).tcp_udp_action7_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_TCf_SET(r,f) (r).tcp_udp_action7_reg[0]=(((r).tcp_udp_action7_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action7_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action7_reg[0]=(((r).tcp_udp_action7_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION7_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION7_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION7_REGr,(r._tcp_udp_action7_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION7_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION7_REGr,&(r._tcp_udp_action7_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION7_REGr BCM53128_A0_TCP_UDP_ACTION7_REGr
#define TCP_UDP_ACTION7_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION7_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION7_REGr_t TCP_UDP_ACTION7_REGr_t;
#define TCP_UDP_ACTION7_REGr_CLR BCM53128_A0_TCP_UDP_ACTION7_REGr_CLR
#define TCP_UDP_ACTION7_REGr_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_SET
#define TCP_UDP_ACTION7_REGr_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_GET
#define TCP_UDP_ACTION7_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION7_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION7_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION7_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION7_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION7_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION7_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION7_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION7_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_TCf_GET
#define TCP_UDP_ACTION7_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_TCf_SET
#define TCP_UDP_ACTION7_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION7_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION7_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION7_REGr BCM53128_A0_READ_TCP_UDP_ACTION7_REGr
#define WRITE_TCP_UDP_ACTION7_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION7_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION7_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION8_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 8 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION8_REGr 0x0000a2a0

#define BCM53128_A0_TCP_UDP_ACTION8_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION8_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION8_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action8_reg[1];
	uint32_t _tcp_udp_action8_reg;
} BCM53128_A0_TCP_UDP_ACTION8_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION8_REGr_CLR(r) (r).tcp_udp_action8_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_SET(r,d) (r).tcp_udp_action8_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_GET(r) (r).tcp_udp_action8_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action8_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action8_reg[0]=(((r).tcp_udp_action8_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action8_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action8_reg[0]=(((r).tcp_udp_action8_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action8_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action8_reg[0]=(((r).tcp_udp_action8_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action8_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action8_reg[0]=(((r).tcp_udp_action8_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_TCf_GET(r) ((((r).tcp_udp_action8_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_TCf_SET(r,f) (r).tcp_udp_action8_reg[0]=(((r).tcp_udp_action8_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action8_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action8_reg[0]=(((r).tcp_udp_action8_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION8_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION8_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION8_REGr,(r._tcp_udp_action8_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION8_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION8_REGr,&(r._tcp_udp_action8_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION8_REGr BCM53128_A0_TCP_UDP_ACTION8_REGr
#define TCP_UDP_ACTION8_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION8_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION8_REGr_t TCP_UDP_ACTION8_REGr_t;
#define TCP_UDP_ACTION8_REGr_CLR BCM53128_A0_TCP_UDP_ACTION8_REGr_CLR
#define TCP_UDP_ACTION8_REGr_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_SET
#define TCP_UDP_ACTION8_REGr_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_GET
#define TCP_UDP_ACTION8_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION8_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION8_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION8_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION8_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION8_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION8_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION8_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION8_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_TCf_GET
#define TCP_UDP_ACTION8_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_TCf_SET
#define TCP_UDP_ACTION8_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION8_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION8_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION8_REGr BCM53128_A0_READ_TCP_UDP_ACTION8_REGr
#define WRITE_TCP_UDP_ACTION8_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION8_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION8_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_ACTION9_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP ACTION 9 Registers
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_ACTION9_REGr 0x0000a2a4

#define BCM53128_A0_TCP_UDP_ACTION9_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_ACTION9_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_ACTION9_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_action9_reg[1];
	uint32_t _tcp_udp_action9_reg;
} BCM53128_A0_TCP_UDP_ACTION9_REGr_t;

#define BCM53128_A0_TCP_UDP_ACTION9_REGr_CLR(r) (r).tcp_udp_action9_reg[0] = 0
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_SET(r,d) (r).tcp_udp_action9_reg[0] = d
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_GET(r) (r).tcp_udp_action9_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_action9_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_action9_reg[0]=(((r).tcp_udp_action9_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_action9_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_action9_reg[0]=(((r).tcp_udp_action9_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_action9_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_action9_reg[0]=(((r).tcp_udp_action9_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_action9_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_action9_reg[0]=(((r).tcp_udp_action9_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_TCf_GET(r) ((((r).tcp_udp_action9_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_TCf_SET(r,f) (r).tcp_udp_action9_reg[0]=(((r).tcp_udp_action9_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_action9_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_action9_reg[0]=(((r).tcp_udp_action9_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_ACTION9_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_ACTION9_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_ACTION9_REGr,(r._tcp_udp_action9_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_ACTION9_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_ACTION9_REGr,&(r._tcp_udp_action9_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_ACTION9_REGr BCM53128_A0_TCP_UDP_ACTION9_REGr
#define TCP_UDP_ACTION9_REGr_SIZE BCM53128_A0_TCP_UDP_ACTION9_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_ACTION9_REGr_t TCP_UDP_ACTION9_REGr_t;
#define TCP_UDP_ACTION9_REGr_CLR BCM53128_A0_TCP_UDP_ACTION9_REGr_CLR
#define TCP_UDP_ACTION9_REGr_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_SET
#define TCP_UDP_ACTION9_REGr_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_GET
#define TCP_UDP_ACTION9_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_DEST_MAPf_GET
#define TCP_UDP_ACTION9_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_DEST_MAPf_SET
#define TCP_UDP_ACTION9_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_0f_GET
#define TCP_UDP_ACTION9_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_0f_SET
#define TCP_UDP_ACTION9_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_FWD_MODf_GET
#define TCP_UDP_ACTION9_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_FWD_MODf_SET
#define TCP_UDP_ACTION9_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_CHG_TCf_GET
#define TCP_UDP_ACTION9_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_CHG_TCf_SET
#define TCP_UDP_ACTION9_REGr_TCf_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_TCf_GET
#define TCP_UDP_ACTION9_REGr_TCf_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_TCf_SET
#define TCP_UDP_ACTION9_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_1f_GET
#define TCP_UDP_ACTION9_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_ACTION9_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_ACTION9_REGr BCM53128_A0_READ_TCP_UDP_ACTION9_REGr
#define WRITE_TCP_UDP_ACTION9_REGr BCM53128_A0_WRITE_TCP_UDP_ACTION9_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_ACTION9_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_HIT_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP HIT Register
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_HIT_REG  These bits record the corresponding actions have been taken. It is cleared when software writes '1'.bit[16] : udpWildcardMatchbit[15:0] : key 15~0
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_HIT_REGr 0x0000a208

#define BCM53128_A0_TCP_UDP_HIT_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_HIT_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_HIT_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_hit_reg[1];
	uint32_t _tcp_udp_hit_reg;
} BCM53128_A0_TCP_UDP_HIT_REGr_t;

#define BCM53128_A0_TCP_UDP_HIT_REGr_CLR(r) (r).tcp_udp_hit_reg[0] = 0
#define BCM53128_A0_TCP_UDP_HIT_REGr_SET(r,d) (r).tcp_udp_hit_reg[0] = d
#define BCM53128_A0_TCP_UDP_HIT_REGr_GET(r) (r).tcp_udp_hit_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_HIT_REGr_TCP_UDP_HIT_REGf_GET(r) (((r).tcp_udp_hit_reg[0]) & 0x1ffff)
#define BCM53128_A0_TCP_UDP_HIT_REGr_TCP_UDP_HIT_REGf_SET(r,f) (r).tcp_udp_hit_reg[0]=(((r).tcp_udp_hit_reg[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53128_A0_TCP_UDP_HIT_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_hit_reg[0]) >> 17) & 0x7fff)
#define BCM53128_A0_TCP_UDP_HIT_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_hit_reg[0]=(((r).tcp_udp_hit_reg[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access TCP_UDP_HIT_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_HIT_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_HIT_REGr,(r._tcp_udp_hit_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_HIT_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_HIT_REGr,&(r._tcp_udp_hit_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_HIT_REGr BCM53128_A0_TCP_UDP_HIT_REGr
#define TCP_UDP_HIT_REGr_SIZE BCM53128_A0_TCP_UDP_HIT_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_HIT_REGr_t TCP_UDP_HIT_REGr_t;
#define TCP_UDP_HIT_REGr_CLR BCM53128_A0_TCP_UDP_HIT_REGr_CLR
#define TCP_UDP_HIT_REGr_SET BCM53128_A0_TCP_UDP_HIT_REGr_SET
#define TCP_UDP_HIT_REGr_GET BCM53128_A0_TCP_UDP_HIT_REGr_GET
#define TCP_UDP_HIT_REGr_TCP_UDP_HIT_REGf_GET BCM53128_A0_TCP_UDP_HIT_REGr_TCP_UDP_HIT_REGf_GET
#define TCP_UDP_HIT_REGr_TCP_UDP_HIT_REGf_SET BCM53128_A0_TCP_UDP_HIT_REGr_TCP_UDP_HIT_REGf_SET
#define TCP_UDP_HIT_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_HIT_REGr_RESERVEDf_GET
#define TCP_UDP_HIT_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_HIT_REGr_RESERVEDf_SET
#define READ_TCP_UDP_HIT_REGr BCM53128_A0_READ_TCP_UDP_HIT_REGr
#define WRITE_TCP_UDP_HIT_REGr BCM53128_A0_WRITE_TCP_UDP_HIT_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_HIT_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY0_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 0 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY0_REGr 0x0000a210

#define BCM53128_A0_TCP_UDP_KEY0_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY0_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY0_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key0_reg[1];
	uint32_t _tcp_udp_key0_reg;
} BCM53128_A0_TCP_UDP_KEY0_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY0_REGr_CLR(r) (r).tcp_udp_key0_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY0_REGr_SET(r,d) (r).tcp_udp_key0_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY0_REGr_GET(r) (r).tcp_udp_key0_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY0_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key0_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY0_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key0_reg[0]=(((r).tcp_udp_key0_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY0_REGr_CTRLf_GET(r) ((((r).tcp_udp_key0_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY0_REGr_CTRLf_SET(r,f) (r).tcp_udp_key0_reg[0]=(((r).tcp_udp_key0_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY0_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key0_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY0_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key0_reg[0]=(((r).tcp_udp_key0_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY0_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY0_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY0_REGr,(r._tcp_udp_key0_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY0_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY0_REGr,&(r._tcp_udp_key0_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY0_REGr BCM53128_A0_TCP_UDP_KEY0_REGr
#define TCP_UDP_KEY0_REGr_SIZE BCM53128_A0_TCP_UDP_KEY0_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY0_REGr_t TCP_UDP_KEY0_REGr_t;
#define TCP_UDP_KEY0_REGr_CLR BCM53128_A0_TCP_UDP_KEY0_REGr_CLR
#define TCP_UDP_KEY0_REGr_SET BCM53128_A0_TCP_UDP_KEY0_REGr_SET
#define TCP_UDP_KEY0_REGr_GET BCM53128_A0_TCP_UDP_KEY0_REGr_GET
#define TCP_UDP_KEY0_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY0_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY0_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY0_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY0_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY0_REGr_CTRLf_GET
#define TCP_UDP_KEY0_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY0_REGr_CTRLf_SET
#define TCP_UDP_KEY0_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY0_REGr_RESERVEDf_GET
#define TCP_UDP_KEY0_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY0_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY0_REGr BCM53128_A0_READ_TCP_UDP_KEY0_REGr
#define WRITE_TCP_UDP_KEY0_REGr BCM53128_A0_WRITE_TCP_UDP_KEY0_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY0_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY10_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 10 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY10_REGr 0x0000a238

#define BCM53128_A0_TCP_UDP_KEY10_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY10_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY10_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key10_reg[1];
	uint32_t _tcp_udp_key10_reg;
} BCM53128_A0_TCP_UDP_KEY10_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY10_REGr_CLR(r) (r).tcp_udp_key10_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY10_REGr_SET(r,d) (r).tcp_udp_key10_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY10_REGr_GET(r) (r).tcp_udp_key10_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY10_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key10_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY10_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key10_reg[0]=(((r).tcp_udp_key10_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY10_REGr_CTRLf_GET(r) ((((r).tcp_udp_key10_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY10_REGr_CTRLf_SET(r,f) (r).tcp_udp_key10_reg[0]=(((r).tcp_udp_key10_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY10_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key10_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY10_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key10_reg[0]=(((r).tcp_udp_key10_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY10_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY10_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY10_REGr,(r._tcp_udp_key10_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY10_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY10_REGr,&(r._tcp_udp_key10_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY10_REGr BCM53128_A0_TCP_UDP_KEY10_REGr
#define TCP_UDP_KEY10_REGr_SIZE BCM53128_A0_TCP_UDP_KEY10_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY10_REGr_t TCP_UDP_KEY10_REGr_t;
#define TCP_UDP_KEY10_REGr_CLR BCM53128_A0_TCP_UDP_KEY10_REGr_CLR
#define TCP_UDP_KEY10_REGr_SET BCM53128_A0_TCP_UDP_KEY10_REGr_SET
#define TCP_UDP_KEY10_REGr_GET BCM53128_A0_TCP_UDP_KEY10_REGr_GET
#define TCP_UDP_KEY10_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY10_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY10_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY10_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY10_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY10_REGr_CTRLf_GET
#define TCP_UDP_KEY10_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY10_REGr_CTRLf_SET
#define TCP_UDP_KEY10_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY10_REGr_RESERVEDf_GET
#define TCP_UDP_KEY10_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY10_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY10_REGr BCM53128_A0_READ_TCP_UDP_KEY10_REGr
#define WRITE_TCP_UDP_KEY10_REGr BCM53128_A0_WRITE_TCP_UDP_KEY10_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY10_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY11_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 11 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY11_REGr 0x0000a23c

#define BCM53128_A0_TCP_UDP_KEY11_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY11_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY11_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key11_reg[1];
	uint32_t _tcp_udp_key11_reg;
} BCM53128_A0_TCP_UDP_KEY11_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY11_REGr_CLR(r) (r).tcp_udp_key11_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY11_REGr_SET(r,d) (r).tcp_udp_key11_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY11_REGr_GET(r) (r).tcp_udp_key11_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY11_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key11_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY11_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key11_reg[0]=(((r).tcp_udp_key11_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY11_REGr_CTRLf_GET(r) ((((r).tcp_udp_key11_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY11_REGr_CTRLf_SET(r,f) (r).tcp_udp_key11_reg[0]=(((r).tcp_udp_key11_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY11_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key11_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY11_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key11_reg[0]=(((r).tcp_udp_key11_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY11_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY11_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY11_REGr,(r._tcp_udp_key11_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY11_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY11_REGr,&(r._tcp_udp_key11_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY11_REGr BCM53128_A0_TCP_UDP_KEY11_REGr
#define TCP_UDP_KEY11_REGr_SIZE BCM53128_A0_TCP_UDP_KEY11_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY11_REGr_t TCP_UDP_KEY11_REGr_t;
#define TCP_UDP_KEY11_REGr_CLR BCM53128_A0_TCP_UDP_KEY11_REGr_CLR
#define TCP_UDP_KEY11_REGr_SET BCM53128_A0_TCP_UDP_KEY11_REGr_SET
#define TCP_UDP_KEY11_REGr_GET BCM53128_A0_TCP_UDP_KEY11_REGr_GET
#define TCP_UDP_KEY11_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY11_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY11_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY11_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY11_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY11_REGr_CTRLf_GET
#define TCP_UDP_KEY11_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY11_REGr_CTRLf_SET
#define TCP_UDP_KEY11_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY11_REGr_RESERVEDf_GET
#define TCP_UDP_KEY11_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY11_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY11_REGr BCM53128_A0_READ_TCP_UDP_KEY11_REGr
#define WRITE_TCP_UDP_KEY11_REGr BCM53128_A0_WRITE_TCP_UDP_KEY11_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY11_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY12_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 12 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY12_REGr 0x0000a240

#define BCM53128_A0_TCP_UDP_KEY12_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY12_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY12_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key12_reg[1];
	uint32_t _tcp_udp_key12_reg;
} BCM53128_A0_TCP_UDP_KEY12_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY12_REGr_CLR(r) (r).tcp_udp_key12_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY12_REGr_SET(r,d) (r).tcp_udp_key12_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY12_REGr_GET(r) (r).tcp_udp_key12_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY12_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key12_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY12_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key12_reg[0]=(((r).tcp_udp_key12_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY12_REGr_CTRLf_GET(r) ((((r).tcp_udp_key12_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY12_REGr_CTRLf_SET(r,f) (r).tcp_udp_key12_reg[0]=(((r).tcp_udp_key12_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY12_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key12_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY12_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key12_reg[0]=(((r).tcp_udp_key12_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY12_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY12_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY12_REGr,(r._tcp_udp_key12_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY12_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY12_REGr,&(r._tcp_udp_key12_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY12_REGr BCM53128_A0_TCP_UDP_KEY12_REGr
#define TCP_UDP_KEY12_REGr_SIZE BCM53128_A0_TCP_UDP_KEY12_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY12_REGr_t TCP_UDP_KEY12_REGr_t;
#define TCP_UDP_KEY12_REGr_CLR BCM53128_A0_TCP_UDP_KEY12_REGr_CLR
#define TCP_UDP_KEY12_REGr_SET BCM53128_A0_TCP_UDP_KEY12_REGr_SET
#define TCP_UDP_KEY12_REGr_GET BCM53128_A0_TCP_UDP_KEY12_REGr_GET
#define TCP_UDP_KEY12_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY12_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY12_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY12_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY12_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY12_REGr_CTRLf_GET
#define TCP_UDP_KEY12_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY12_REGr_CTRLf_SET
#define TCP_UDP_KEY12_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY12_REGr_RESERVEDf_GET
#define TCP_UDP_KEY12_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY12_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY12_REGr BCM53128_A0_READ_TCP_UDP_KEY12_REGr
#define WRITE_TCP_UDP_KEY12_REGr BCM53128_A0_WRITE_TCP_UDP_KEY12_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY12_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY13_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 13 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY13_REGr 0x0000a244

#define BCM53128_A0_TCP_UDP_KEY13_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY13_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY13_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key13_reg[1];
	uint32_t _tcp_udp_key13_reg;
} BCM53128_A0_TCP_UDP_KEY13_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY13_REGr_CLR(r) (r).tcp_udp_key13_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY13_REGr_SET(r,d) (r).tcp_udp_key13_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY13_REGr_GET(r) (r).tcp_udp_key13_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY13_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key13_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY13_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key13_reg[0]=(((r).tcp_udp_key13_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY13_REGr_CTRLf_GET(r) ((((r).tcp_udp_key13_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY13_REGr_CTRLf_SET(r,f) (r).tcp_udp_key13_reg[0]=(((r).tcp_udp_key13_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY13_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key13_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY13_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key13_reg[0]=(((r).tcp_udp_key13_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY13_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY13_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY13_REGr,(r._tcp_udp_key13_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY13_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY13_REGr,&(r._tcp_udp_key13_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY13_REGr BCM53128_A0_TCP_UDP_KEY13_REGr
#define TCP_UDP_KEY13_REGr_SIZE BCM53128_A0_TCP_UDP_KEY13_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY13_REGr_t TCP_UDP_KEY13_REGr_t;
#define TCP_UDP_KEY13_REGr_CLR BCM53128_A0_TCP_UDP_KEY13_REGr_CLR
#define TCP_UDP_KEY13_REGr_SET BCM53128_A0_TCP_UDP_KEY13_REGr_SET
#define TCP_UDP_KEY13_REGr_GET BCM53128_A0_TCP_UDP_KEY13_REGr_GET
#define TCP_UDP_KEY13_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY13_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY13_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY13_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY13_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY13_REGr_CTRLf_GET
#define TCP_UDP_KEY13_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY13_REGr_CTRLf_SET
#define TCP_UDP_KEY13_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY13_REGr_RESERVEDf_GET
#define TCP_UDP_KEY13_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY13_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY13_REGr BCM53128_A0_READ_TCP_UDP_KEY13_REGr
#define WRITE_TCP_UDP_KEY13_REGr BCM53128_A0_WRITE_TCP_UDP_KEY13_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY13_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY14_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 14 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY14_REGr 0x0000a248

#define BCM53128_A0_TCP_UDP_KEY14_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY14_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY14_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key14_reg[1];
	uint32_t _tcp_udp_key14_reg;
} BCM53128_A0_TCP_UDP_KEY14_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY14_REGr_CLR(r) (r).tcp_udp_key14_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY14_REGr_SET(r,d) (r).tcp_udp_key14_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY14_REGr_GET(r) (r).tcp_udp_key14_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY14_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key14_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY14_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key14_reg[0]=(((r).tcp_udp_key14_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY14_REGr_CTRLf_GET(r) ((((r).tcp_udp_key14_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY14_REGr_CTRLf_SET(r,f) (r).tcp_udp_key14_reg[0]=(((r).tcp_udp_key14_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY14_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key14_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY14_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key14_reg[0]=(((r).tcp_udp_key14_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY14_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY14_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY14_REGr,(r._tcp_udp_key14_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY14_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY14_REGr,&(r._tcp_udp_key14_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY14_REGr BCM53128_A0_TCP_UDP_KEY14_REGr
#define TCP_UDP_KEY14_REGr_SIZE BCM53128_A0_TCP_UDP_KEY14_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY14_REGr_t TCP_UDP_KEY14_REGr_t;
#define TCP_UDP_KEY14_REGr_CLR BCM53128_A0_TCP_UDP_KEY14_REGr_CLR
#define TCP_UDP_KEY14_REGr_SET BCM53128_A0_TCP_UDP_KEY14_REGr_SET
#define TCP_UDP_KEY14_REGr_GET BCM53128_A0_TCP_UDP_KEY14_REGr_GET
#define TCP_UDP_KEY14_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY14_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY14_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY14_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY14_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY14_REGr_CTRLf_GET
#define TCP_UDP_KEY14_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY14_REGr_CTRLf_SET
#define TCP_UDP_KEY14_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY14_REGr_RESERVEDf_GET
#define TCP_UDP_KEY14_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY14_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY14_REGr BCM53128_A0_READ_TCP_UDP_KEY14_REGr
#define WRITE_TCP_UDP_KEY14_REGr BCM53128_A0_WRITE_TCP_UDP_KEY14_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY14_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY15_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 15 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY15_REGr 0x0000a24c

#define BCM53128_A0_TCP_UDP_KEY15_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY15_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY15_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key15_reg[1];
	uint32_t _tcp_udp_key15_reg;
} BCM53128_A0_TCP_UDP_KEY15_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY15_REGr_CLR(r) (r).tcp_udp_key15_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY15_REGr_SET(r,d) (r).tcp_udp_key15_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY15_REGr_GET(r) (r).tcp_udp_key15_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY15_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key15_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY15_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key15_reg[0]=(((r).tcp_udp_key15_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY15_REGr_CTRLf_GET(r) ((((r).tcp_udp_key15_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY15_REGr_CTRLf_SET(r,f) (r).tcp_udp_key15_reg[0]=(((r).tcp_udp_key15_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY15_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key15_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY15_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key15_reg[0]=(((r).tcp_udp_key15_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY15_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY15_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY15_REGr,(r._tcp_udp_key15_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY15_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY15_REGr,&(r._tcp_udp_key15_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY15_REGr BCM53128_A0_TCP_UDP_KEY15_REGr
#define TCP_UDP_KEY15_REGr_SIZE BCM53128_A0_TCP_UDP_KEY15_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY15_REGr_t TCP_UDP_KEY15_REGr_t;
#define TCP_UDP_KEY15_REGr_CLR BCM53128_A0_TCP_UDP_KEY15_REGr_CLR
#define TCP_UDP_KEY15_REGr_SET BCM53128_A0_TCP_UDP_KEY15_REGr_SET
#define TCP_UDP_KEY15_REGr_GET BCM53128_A0_TCP_UDP_KEY15_REGr_GET
#define TCP_UDP_KEY15_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY15_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY15_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY15_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY15_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY15_REGr_CTRLf_GET
#define TCP_UDP_KEY15_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY15_REGr_CTRLf_SET
#define TCP_UDP_KEY15_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY15_REGr_RESERVEDf_GET
#define TCP_UDP_KEY15_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY15_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY15_REGr BCM53128_A0_READ_TCP_UDP_KEY15_REGr
#define WRITE_TCP_UDP_KEY15_REGr BCM53128_A0_WRITE_TCP_UDP_KEY15_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY15_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY1_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 1 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY1_REGr 0x0000a214

#define BCM53128_A0_TCP_UDP_KEY1_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY1_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY1_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key1_reg[1];
	uint32_t _tcp_udp_key1_reg;
} BCM53128_A0_TCP_UDP_KEY1_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY1_REGr_CLR(r) (r).tcp_udp_key1_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY1_REGr_SET(r,d) (r).tcp_udp_key1_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY1_REGr_GET(r) (r).tcp_udp_key1_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY1_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key1_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY1_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key1_reg[0]=(((r).tcp_udp_key1_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY1_REGr_CTRLf_GET(r) ((((r).tcp_udp_key1_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY1_REGr_CTRLf_SET(r,f) (r).tcp_udp_key1_reg[0]=(((r).tcp_udp_key1_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY1_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key1_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY1_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key1_reg[0]=(((r).tcp_udp_key1_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY1_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY1_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY1_REGr,(r._tcp_udp_key1_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY1_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY1_REGr,&(r._tcp_udp_key1_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY1_REGr BCM53128_A0_TCP_UDP_KEY1_REGr
#define TCP_UDP_KEY1_REGr_SIZE BCM53128_A0_TCP_UDP_KEY1_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY1_REGr_t TCP_UDP_KEY1_REGr_t;
#define TCP_UDP_KEY1_REGr_CLR BCM53128_A0_TCP_UDP_KEY1_REGr_CLR
#define TCP_UDP_KEY1_REGr_SET BCM53128_A0_TCP_UDP_KEY1_REGr_SET
#define TCP_UDP_KEY1_REGr_GET BCM53128_A0_TCP_UDP_KEY1_REGr_GET
#define TCP_UDP_KEY1_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY1_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY1_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY1_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY1_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY1_REGr_CTRLf_GET
#define TCP_UDP_KEY1_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY1_REGr_CTRLf_SET
#define TCP_UDP_KEY1_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY1_REGr_RESERVEDf_GET
#define TCP_UDP_KEY1_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY1_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY1_REGr BCM53128_A0_READ_TCP_UDP_KEY1_REGr
#define WRITE_TCP_UDP_KEY1_REGr BCM53128_A0_WRITE_TCP_UDP_KEY1_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY1_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY2_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 2 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY2_REGr 0x0000a218

#define BCM53128_A0_TCP_UDP_KEY2_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY2_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY2_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key2_reg[1];
	uint32_t _tcp_udp_key2_reg;
} BCM53128_A0_TCP_UDP_KEY2_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY2_REGr_CLR(r) (r).tcp_udp_key2_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY2_REGr_SET(r,d) (r).tcp_udp_key2_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY2_REGr_GET(r) (r).tcp_udp_key2_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY2_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key2_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY2_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key2_reg[0]=(((r).tcp_udp_key2_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY2_REGr_CTRLf_GET(r) ((((r).tcp_udp_key2_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY2_REGr_CTRLf_SET(r,f) (r).tcp_udp_key2_reg[0]=(((r).tcp_udp_key2_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY2_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key2_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY2_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key2_reg[0]=(((r).tcp_udp_key2_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY2_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY2_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY2_REGr,(r._tcp_udp_key2_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY2_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY2_REGr,&(r._tcp_udp_key2_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY2_REGr BCM53128_A0_TCP_UDP_KEY2_REGr
#define TCP_UDP_KEY2_REGr_SIZE BCM53128_A0_TCP_UDP_KEY2_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY2_REGr_t TCP_UDP_KEY2_REGr_t;
#define TCP_UDP_KEY2_REGr_CLR BCM53128_A0_TCP_UDP_KEY2_REGr_CLR
#define TCP_UDP_KEY2_REGr_SET BCM53128_A0_TCP_UDP_KEY2_REGr_SET
#define TCP_UDP_KEY2_REGr_GET BCM53128_A0_TCP_UDP_KEY2_REGr_GET
#define TCP_UDP_KEY2_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY2_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY2_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY2_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY2_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY2_REGr_CTRLf_GET
#define TCP_UDP_KEY2_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY2_REGr_CTRLf_SET
#define TCP_UDP_KEY2_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY2_REGr_RESERVEDf_GET
#define TCP_UDP_KEY2_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY2_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY2_REGr BCM53128_A0_READ_TCP_UDP_KEY2_REGr
#define WRITE_TCP_UDP_KEY2_REGr BCM53128_A0_WRITE_TCP_UDP_KEY2_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY2_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY3_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 3 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY3_REGr 0x0000a21c

#define BCM53128_A0_TCP_UDP_KEY3_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY3_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY3_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key3_reg[1];
	uint32_t _tcp_udp_key3_reg;
} BCM53128_A0_TCP_UDP_KEY3_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY3_REGr_CLR(r) (r).tcp_udp_key3_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY3_REGr_SET(r,d) (r).tcp_udp_key3_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY3_REGr_GET(r) (r).tcp_udp_key3_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY3_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key3_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY3_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key3_reg[0]=(((r).tcp_udp_key3_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY3_REGr_CTRLf_GET(r) ((((r).tcp_udp_key3_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY3_REGr_CTRLf_SET(r,f) (r).tcp_udp_key3_reg[0]=(((r).tcp_udp_key3_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY3_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key3_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY3_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key3_reg[0]=(((r).tcp_udp_key3_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY3_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY3_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY3_REGr,(r._tcp_udp_key3_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY3_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY3_REGr,&(r._tcp_udp_key3_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY3_REGr BCM53128_A0_TCP_UDP_KEY3_REGr
#define TCP_UDP_KEY3_REGr_SIZE BCM53128_A0_TCP_UDP_KEY3_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY3_REGr_t TCP_UDP_KEY3_REGr_t;
#define TCP_UDP_KEY3_REGr_CLR BCM53128_A0_TCP_UDP_KEY3_REGr_CLR
#define TCP_UDP_KEY3_REGr_SET BCM53128_A0_TCP_UDP_KEY3_REGr_SET
#define TCP_UDP_KEY3_REGr_GET BCM53128_A0_TCP_UDP_KEY3_REGr_GET
#define TCP_UDP_KEY3_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY3_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY3_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY3_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY3_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY3_REGr_CTRLf_GET
#define TCP_UDP_KEY3_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY3_REGr_CTRLf_SET
#define TCP_UDP_KEY3_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY3_REGr_RESERVEDf_GET
#define TCP_UDP_KEY3_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY3_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY3_REGr BCM53128_A0_READ_TCP_UDP_KEY3_REGr
#define WRITE_TCP_UDP_KEY3_REGr BCM53128_A0_WRITE_TCP_UDP_KEY3_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY3_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY4_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 4 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY4_REGr 0x0000a220

#define BCM53128_A0_TCP_UDP_KEY4_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY4_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY4_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key4_reg[1];
	uint32_t _tcp_udp_key4_reg;
} BCM53128_A0_TCP_UDP_KEY4_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY4_REGr_CLR(r) (r).tcp_udp_key4_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY4_REGr_SET(r,d) (r).tcp_udp_key4_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY4_REGr_GET(r) (r).tcp_udp_key4_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY4_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key4_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY4_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key4_reg[0]=(((r).tcp_udp_key4_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY4_REGr_CTRLf_GET(r) ((((r).tcp_udp_key4_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY4_REGr_CTRLf_SET(r,f) (r).tcp_udp_key4_reg[0]=(((r).tcp_udp_key4_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY4_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key4_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY4_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key4_reg[0]=(((r).tcp_udp_key4_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY4_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY4_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY4_REGr,(r._tcp_udp_key4_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY4_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY4_REGr,&(r._tcp_udp_key4_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY4_REGr BCM53128_A0_TCP_UDP_KEY4_REGr
#define TCP_UDP_KEY4_REGr_SIZE BCM53128_A0_TCP_UDP_KEY4_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY4_REGr_t TCP_UDP_KEY4_REGr_t;
#define TCP_UDP_KEY4_REGr_CLR BCM53128_A0_TCP_UDP_KEY4_REGr_CLR
#define TCP_UDP_KEY4_REGr_SET BCM53128_A0_TCP_UDP_KEY4_REGr_SET
#define TCP_UDP_KEY4_REGr_GET BCM53128_A0_TCP_UDP_KEY4_REGr_GET
#define TCP_UDP_KEY4_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY4_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY4_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY4_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY4_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY4_REGr_CTRLf_GET
#define TCP_UDP_KEY4_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY4_REGr_CTRLf_SET
#define TCP_UDP_KEY4_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY4_REGr_RESERVEDf_GET
#define TCP_UDP_KEY4_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY4_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY4_REGr BCM53128_A0_READ_TCP_UDP_KEY4_REGr
#define WRITE_TCP_UDP_KEY4_REGr BCM53128_A0_WRITE_TCP_UDP_KEY4_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY4_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY5_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 5 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY5_REGr 0x0000a224

#define BCM53128_A0_TCP_UDP_KEY5_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY5_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY5_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key5_reg[1];
	uint32_t _tcp_udp_key5_reg;
} BCM53128_A0_TCP_UDP_KEY5_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY5_REGr_CLR(r) (r).tcp_udp_key5_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY5_REGr_SET(r,d) (r).tcp_udp_key5_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY5_REGr_GET(r) (r).tcp_udp_key5_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY5_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key5_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY5_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key5_reg[0]=(((r).tcp_udp_key5_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY5_REGr_CTRLf_GET(r) ((((r).tcp_udp_key5_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY5_REGr_CTRLf_SET(r,f) (r).tcp_udp_key5_reg[0]=(((r).tcp_udp_key5_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY5_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key5_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY5_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key5_reg[0]=(((r).tcp_udp_key5_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY5_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY5_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY5_REGr,(r._tcp_udp_key5_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY5_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY5_REGr,&(r._tcp_udp_key5_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY5_REGr BCM53128_A0_TCP_UDP_KEY5_REGr
#define TCP_UDP_KEY5_REGr_SIZE BCM53128_A0_TCP_UDP_KEY5_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY5_REGr_t TCP_UDP_KEY5_REGr_t;
#define TCP_UDP_KEY5_REGr_CLR BCM53128_A0_TCP_UDP_KEY5_REGr_CLR
#define TCP_UDP_KEY5_REGr_SET BCM53128_A0_TCP_UDP_KEY5_REGr_SET
#define TCP_UDP_KEY5_REGr_GET BCM53128_A0_TCP_UDP_KEY5_REGr_GET
#define TCP_UDP_KEY5_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY5_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY5_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY5_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY5_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY5_REGr_CTRLf_GET
#define TCP_UDP_KEY5_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY5_REGr_CTRLf_SET
#define TCP_UDP_KEY5_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY5_REGr_RESERVEDf_GET
#define TCP_UDP_KEY5_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY5_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY5_REGr BCM53128_A0_READ_TCP_UDP_KEY5_REGr
#define WRITE_TCP_UDP_KEY5_REGr BCM53128_A0_WRITE_TCP_UDP_KEY5_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY5_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY6_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 6 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY6_REGr 0x0000a228

#define BCM53128_A0_TCP_UDP_KEY6_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY6_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY6_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key6_reg[1];
	uint32_t _tcp_udp_key6_reg;
} BCM53128_A0_TCP_UDP_KEY6_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY6_REGr_CLR(r) (r).tcp_udp_key6_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY6_REGr_SET(r,d) (r).tcp_udp_key6_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY6_REGr_GET(r) (r).tcp_udp_key6_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY6_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key6_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY6_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key6_reg[0]=(((r).tcp_udp_key6_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY6_REGr_CTRLf_GET(r) ((((r).tcp_udp_key6_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY6_REGr_CTRLf_SET(r,f) (r).tcp_udp_key6_reg[0]=(((r).tcp_udp_key6_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY6_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key6_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY6_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key6_reg[0]=(((r).tcp_udp_key6_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY6_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY6_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY6_REGr,(r._tcp_udp_key6_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY6_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY6_REGr,&(r._tcp_udp_key6_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY6_REGr BCM53128_A0_TCP_UDP_KEY6_REGr
#define TCP_UDP_KEY6_REGr_SIZE BCM53128_A0_TCP_UDP_KEY6_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY6_REGr_t TCP_UDP_KEY6_REGr_t;
#define TCP_UDP_KEY6_REGr_CLR BCM53128_A0_TCP_UDP_KEY6_REGr_CLR
#define TCP_UDP_KEY6_REGr_SET BCM53128_A0_TCP_UDP_KEY6_REGr_SET
#define TCP_UDP_KEY6_REGr_GET BCM53128_A0_TCP_UDP_KEY6_REGr_GET
#define TCP_UDP_KEY6_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY6_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY6_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY6_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY6_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY6_REGr_CTRLf_GET
#define TCP_UDP_KEY6_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY6_REGr_CTRLf_SET
#define TCP_UDP_KEY6_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY6_REGr_RESERVEDf_GET
#define TCP_UDP_KEY6_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY6_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY6_REGr BCM53128_A0_READ_TCP_UDP_KEY6_REGr
#define WRITE_TCP_UDP_KEY6_REGr BCM53128_A0_WRITE_TCP_UDP_KEY6_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY6_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY7_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 7 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY7_REGr 0x0000a22c

#define BCM53128_A0_TCP_UDP_KEY7_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY7_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY7_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key7_reg[1];
	uint32_t _tcp_udp_key7_reg;
} BCM53128_A0_TCP_UDP_KEY7_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY7_REGr_CLR(r) (r).tcp_udp_key7_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY7_REGr_SET(r,d) (r).tcp_udp_key7_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY7_REGr_GET(r) (r).tcp_udp_key7_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY7_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key7_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY7_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key7_reg[0]=(((r).tcp_udp_key7_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY7_REGr_CTRLf_GET(r) ((((r).tcp_udp_key7_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY7_REGr_CTRLf_SET(r,f) (r).tcp_udp_key7_reg[0]=(((r).tcp_udp_key7_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY7_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key7_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY7_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key7_reg[0]=(((r).tcp_udp_key7_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY7_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY7_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY7_REGr,(r._tcp_udp_key7_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY7_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY7_REGr,&(r._tcp_udp_key7_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY7_REGr BCM53128_A0_TCP_UDP_KEY7_REGr
#define TCP_UDP_KEY7_REGr_SIZE BCM53128_A0_TCP_UDP_KEY7_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY7_REGr_t TCP_UDP_KEY7_REGr_t;
#define TCP_UDP_KEY7_REGr_CLR BCM53128_A0_TCP_UDP_KEY7_REGr_CLR
#define TCP_UDP_KEY7_REGr_SET BCM53128_A0_TCP_UDP_KEY7_REGr_SET
#define TCP_UDP_KEY7_REGr_GET BCM53128_A0_TCP_UDP_KEY7_REGr_GET
#define TCP_UDP_KEY7_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY7_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY7_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY7_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY7_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY7_REGr_CTRLf_GET
#define TCP_UDP_KEY7_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY7_REGr_CTRLf_SET
#define TCP_UDP_KEY7_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY7_REGr_RESERVEDf_GET
#define TCP_UDP_KEY7_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY7_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY7_REGr BCM53128_A0_READ_TCP_UDP_KEY7_REGr
#define WRITE_TCP_UDP_KEY7_REGr BCM53128_A0_WRITE_TCP_UDP_KEY7_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY7_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY8_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 8 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY8_REGr 0x0000a230

#define BCM53128_A0_TCP_UDP_KEY8_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY8_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY8_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key8_reg[1];
	uint32_t _tcp_udp_key8_reg;
} BCM53128_A0_TCP_UDP_KEY8_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY8_REGr_CLR(r) (r).tcp_udp_key8_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY8_REGr_SET(r,d) (r).tcp_udp_key8_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY8_REGr_GET(r) (r).tcp_udp_key8_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY8_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key8_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY8_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key8_reg[0]=(((r).tcp_udp_key8_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY8_REGr_CTRLf_GET(r) ((((r).tcp_udp_key8_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY8_REGr_CTRLf_SET(r,f) (r).tcp_udp_key8_reg[0]=(((r).tcp_udp_key8_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY8_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key8_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY8_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key8_reg[0]=(((r).tcp_udp_key8_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY8_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY8_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY8_REGr,(r._tcp_udp_key8_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY8_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY8_REGr,&(r._tcp_udp_key8_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY8_REGr BCM53128_A0_TCP_UDP_KEY8_REGr
#define TCP_UDP_KEY8_REGr_SIZE BCM53128_A0_TCP_UDP_KEY8_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY8_REGr_t TCP_UDP_KEY8_REGr_t;
#define TCP_UDP_KEY8_REGr_CLR BCM53128_A0_TCP_UDP_KEY8_REGr_CLR
#define TCP_UDP_KEY8_REGr_SET BCM53128_A0_TCP_UDP_KEY8_REGr_SET
#define TCP_UDP_KEY8_REGr_GET BCM53128_A0_TCP_UDP_KEY8_REGr_GET
#define TCP_UDP_KEY8_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY8_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY8_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY8_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY8_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY8_REGr_CTRLf_GET
#define TCP_UDP_KEY8_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY8_REGr_CTRLf_SET
#define TCP_UDP_KEY8_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY8_REGr_RESERVEDf_GET
#define TCP_UDP_KEY8_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY8_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY8_REGr BCM53128_A0_READ_TCP_UDP_KEY8_REGr
#define WRITE_TCP_UDP_KEY8_REGr BCM53128_A0_WRITE_TCP_UDP_KEY8_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY8_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_KEY9_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP KEY 9 Registers
 * SIZE:     32
 * FIELDS:
 *     TCP_UDP_PORTNUM  the key to match the ingress packets
 *     CTRL             00: invalid key01: tcpUdpDestinationPortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP destination port number) 10: tcpUdpSourcePortMatchEnable (enables the matching of the port number key against the packet's TCP or UDP source port number) 11: either tcpUdpSourcePortMatchEnable or tcpUdpDestinationPortMatchEnable
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_KEY9_REGr 0x0000a234

#define BCM53128_A0_TCP_UDP_KEY9_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_KEY9_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_KEY9_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_key9_reg[1];
	uint32_t _tcp_udp_key9_reg;
} BCM53128_A0_TCP_UDP_KEY9_REGr_t;

#define BCM53128_A0_TCP_UDP_KEY9_REGr_CLR(r) (r).tcp_udp_key9_reg[0] = 0
#define BCM53128_A0_TCP_UDP_KEY9_REGr_SET(r,d) (r).tcp_udp_key9_reg[0] = d
#define BCM53128_A0_TCP_UDP_KEY9_REGr_GET(r) (r).tcp_udp_key9_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_KEY9_REGr_TCP_UDP_PORTNUMf_GET(r) (((r).tcp_udp_key9_reg[0]) & 0xffff)
#define BCM53128_A0_TCP_UDP_KEY9_REGr_TCP_UDP_PORTNUMf_SET(r,f) (r).tcp_udp_key9_reg[0]=(((r).tcp_udp_key9_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TCP_UDP_KEY9_REGr_CTRLf_GET(r) ((((r).tcp_udp_key9_reg[0]) >> 16) & 0x3)
#define BCM53128_A0_TCP_UDP_KEY9_REGr_CTRLf_SET(r,f) (r).tcp_udp_key9_reg[0]=(((r).tcp_udp_key9_reg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53128_A0_TCP_UDP_KEY9_REGr_RESERVEDf_GET(r) ((((r).tcp_udp_key9_reg[0]) >> 18) & 0x3fff)
#define BCM53128_A0_TCP_UDP_KEY9_REGr_RESERVEDf_SET(r,f) (r).tcp_udp_key9_reg[0]=(((r).tcp_udp_key9_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TCP_UDP_KEY9_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_KEY9_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_KEY9_REGr,(r._tcp_udp_key9_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_KEY9_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_KEY9_REGr,&(r._tcp_udp_key9_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_KEY9_REGr BCM53128_A0_TCP_UDP_KEY9_REGr
#define TCP_UDP_KEY9_REGr_SIZE BCM53128_A0_TCP_UDP_KEY9_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_KEY9_REGr_t TCP_UDP_KEY9_REGr_t;
#define TCP_UDP_KEY9_REGr_CLR BCM53128_A0_TCP_UDP_KEY9_REGr_CLR
#define TCP_UDP_KEY9_REGr_SET BCM53128_A0_TCP_UDP_KEY9_REGr_SET
#define TCP_UDP_KEY9_REGr_GET BCM53128_A0_TCP_UDP_KEY9_REGr_GET
#define TCP_UDP_KEY9_REGr_TCP_UDP_PORTNUMf_GET BCM53128_A0_TCP_UDP_KEY9_REGr_TCP_UDP_PORTNUMf_GET
#define TCP_UDP_KEY9_REGr_TCP_UDP_PORTNUMf_SET BCM53128_A0_TCP_UDP_KEY9_REGr_TCP_UDP_PORTNUMf_SET
#define TCP_UDP_KEY9_REGr_CTRLf_GET BCM53128_A0_TCP_UDP_KEY9_REGr_CTRLf_GET
#define TCP_UDP_KEY9_REGr_CTRLf_SET BCM53128_A0_TCP_UDP_KEY9_REGr_CTRLf_SET
#define TCP_UDP_KEY9_REGr_RESERVEDf_GET BCM53128_A0_TCP_UDP_KEY9_REGr_RESERVEDf_GET
#define TCP_UDP_KEY9_REGr_RESERVEDf_SET BCM53128_A0_TCP_UDP_KEY9_REGr_RESERVEDf_SET
#define READ_TCP_UDP_KEY9_REGr BCM53128_A0_READ_TCP_UDP_KEY9_REGr
#define WRITE_TCP_UDP_KEY9_REGr BCM53128_A0_WRITE_TCP_UDP_KEY9_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_KEY9_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TCP_UDP_WILDCARD_ACTION_REG
 * BLOCKS:   SYS
 * DESC:     TCP UDP WILDCARD ACTION Register
 * SIZE:     32
 * FIELDS:
 *     DEST_MAP         used as destination portmap when fwd_mod[1] is 1.
 *     RESERVED_0       Reserved.
 *     FWD_MOD          10: newDestinations (if asserted, the destination port map associated with the matching key overrides the normal ARL destinations (if any). 11: additionalDestinations (if asserted, the destination port map associated with the matching key is added to (bitwise OR) the normal ARL). 0x : No destination changes to the ARL derived destinations.
 *     CHG_TC           newPriority (if asserted, the packet is given a new priority value)
 *     TC               priority[2:0] (the priority value to use if newPriority is asserted for a matching multiport table entry)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr 0x0000a204

#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_SIZE 4

/*
 * This structure should be used to declare and program TCP_UDP_WILDCARD_ACTION_REG.
 *
 */
typedef union BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_s {
	uint32_t v[1];
	uint32_t tcp_udp_wildcard_action_reg[1];
	uint32_t _tcp_udp_wildcard_action_reg;
} BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_t;

#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_CLR(r) (r).tcp_udp_wildcard_action_reg[0] = 0
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_SET(r,d) (r).tcp_udp_wildcard_action_reg[0] = d
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_GET(r) (r).tcp_udp_wildcard_action_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_DEST_MAPf_GET(r) (((r).tcp_udp_wildcard_action_reg[0]) & 0x1ff)
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_DEST_MAPf_SET(r,f) (r).tcp_udp_wildcard_action_reg[0]=(((r).tcp_udp_wildcard_action_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_0f_GET(r) ((((r).tcp_udp_wildcard_action_reg[0]) >> 9) & 0xffff)
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_0f_SET(r,f) (r).tcp_udp_wildcard_action_reg[0]=(((r).tcp_udp_wildcard_action_reg[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_FWD_MODf_GET(r) ((((r).tcp_udp_wildcard_action_reg[0]) >> 25) & 0x3)
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_FWD_MODf_SET(r,f) (r).tcp_udp_wildcard_action_reg[0]=(((r).tcp_udp_wildcard_action_reg[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_CHG_TCf_GET(r) ((((r).tcp_udp_wildcard_action_reg[0]) >> 27) & 0x1)
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_CHG_TCf_SET(r,f) (r).tcp_udp_wildcard_action_reg[0]=(((r).tcp_udp_wildcard_action_reg[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_TCf_GET(r) ((((r).tcp_udp_wildcard_action_reg[0]) >> 28) & 0x7)
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_TCf_SET(r,f) (r).tcp_udp_wildcard_action_reg[0]=(((r).tcp_udp_wildcard_action_reg[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_1f_GET(r) ((((r).tcp_udp_wildcard_action_reg[0]) >> 31) & 0x1)
#define BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_1f_SET(r,f) (r).tcp_udp_wildcard_action_reg[0]=(((r).tcp_udp_wildcard_action_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCP_UDP_WILDCARD_ACTION_REG.
 *
 */
#define BCM53128_A0_READ_TCP_UDP_WILDCARD_ACTION_REGr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr,(r._tcp_udp_wildcard_action_reg),4)
#define BCM53128_A0_WRITE_TCP_UDP_WILDCARD_ACTION_REGr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr,&(r._tcp_udp_wildcard_action_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCP_UDP_WILDCARD_ACTION_REGr BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr
#define TCP_UDP_WILDCARD_ACTION_REGr_SIZE BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_SIZE
typedef BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_t TCP_UDP_WILDCARD_ACTION_REGr_t;
#define TCP_UDP_WILDCARD_ACTION_REGr_CLR BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_CLR
#define TCP_UDP_WILDCARD_ACTION_REGr_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_SET
#define TCP_UDP_WILDCARD_ACTION_REGr_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_DEST_MAPf_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_DEST_MAPf_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_DEST_MAPf_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_DEST_MAPf_SET
#define TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_0f_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_0f_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_0f_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_0f_SET
#define TCP_UDP_WILDCARD_ACTION_REGr_FWD_MODf_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_FWD_MODf_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_FWD_MODf_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_FWD_MODf_SET
#define TCP_UDP_WILDCARD_ACTION_REGr_CHG_TCf_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_CHG_TCf_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_CHG_TCf_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_CHG_TCf_SET
#define TCP_UDP_WILDCARD_ACTION_REGr_TCf_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_TCf_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_TCf_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_TCf_SET
#define TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_1f_GET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_1f_GET
#define TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_1f_SET BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr_RESERVED_1f_SET
#define READ_TCP_UDP_WILDCARD_ACTION_REGr BCM53128_A0_READ_TCP_UDP_WILDCARD_ACTION_REGr
#define WRITE_TCP_UDP_WILDCARD_ACTION_REGr BCM53128_A0_WRITE_TCP_UDP_WILDCARD_ACTION_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TCP_UDP_WILDCARD_ACTION_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TEMP_MON_CAL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Calibration Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA_25C    Temperature measure code at 25oC. The default value is loaded from OTPmemory and the value is changeable if required.Note: Temperature(oC) = (measure code - TEMP_DATA_25)*(-0.69)+25oC.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53128_A0_TEMP_MON_CALr 0x00000f06

#define BCM53128_A0_TEMP_MON_CALr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_CAL.
 *
 */
typedef union BCM53128_A0_TEMP_MON_CALr_s {
	uint32_t v[1];
	uint32_t temp_mon_cal[1];
	uint32_t _temp_mon_cal;
} BCM53128_A0_TEMP_MON_CALr_t;

#define BCM53128_A0_TEMP_MON_CALr_CLR(r) (r).temp_mon_cal[0] = 0
#define BCM53128_A0_TEMP_MON_CALr_SET(r,d) (r).temp_mon_cal[0] = d
#define BCM53128_A0_TEMP_MON_CALr_GET(r) (r).temp_mon_cal[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET(r) (((r).temp_mon_cal[0]) & 0x1ff)
#define BCM53128_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TEMP_MON_CALr_RESERVEDf_GET(r) ((((r).temp_mon_cal[0]) >> 9) & 0x7f)
#define BCM53128_A0_TEMP_MON_CALr_RESERVEDf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_CAL.
 *
 */
#define BCM53128_A0_READ_TEMP_MON_CALr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TEMP_MON_CALr,(r._temp_mon_cal),2)
#define BCM53128_A0_WRITE_TEMP_MON_CALr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TEMP_MON_CALr,&(r._temp_mon_cal),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CALr BCM53128_A0_TEMP_MON_CALr
#define TEMP_MON_CALr_SIZE BCM53128_A0_TEMP_MON_CALr_SIZE
typedef BCM53128_A0_TEMP_MON_CALr_t TEMP_MON_CALr_t;
#define TEMP_MON_CALr_CLR BCM53128_A0_TEMP_MON_CALr_CLR
#define TEMP_MON_CALr_SET BCM53128_A0_TEMP_MON_CALr_SET
#define TEMP_MON_CALr_GET BCM53128_A0_TEMP_MON_CALr_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_GET BCM53128_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_SET BCM53128_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET
#define TEMP_MON_CALr_RESERVEDf_GET BCM53128_A0_TEMP_MON_CALr_RESERVEDf_GET
#define TEMP_MON_CALr_RESERVEDf_SET BCM53128_A0_TEMP_MON_CALr_RESERVEDf_SET
#define READ_TEMP_MON_CALr BCM53128_A0_READ_TEMP_MON_CALr
#define WRITE_TEMP_MON_CALr BCM53128_A0_WRITE_TEMP_MON_CALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TEMP_MON_CALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TEMP_MON_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     ADC_TEST_EN      1 = Temp monitor normal mode.0 = SAR ADC test mode.(Not2Release)
 *     BIAS_ADJUST      Analog bias adjustments.(Not2Release)
 *
 ******************************************************************************/
#define BCM53128_A0_TEMP_MON_CTLr 0x00000f00

#define BCM53128_A0_TEMP_MON_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_CTL.
 *
 */
typedef union BCM53128_A0_TEMP_MON_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_ctl[1];
	uint32_t _temp_mon_ctl;
} BCM53128_A0_TEMP_MON_CTLr_t;

#define BCM53128_A0_TEMP_MON_CTLr_CLR(r) (r).temp_mon_ctl[0] = 0
#define BCM53128_A0_TEMP_MON_CTLr_SET(r,d) (r).temp_mon_ctl[0] = d
#define BCM53128_A0_TEMP_MON_CTLr_GET(r) (r).temp_mon_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET(r) (((r).temp_mon_ctl[0]) & 0x1)
#define BCM53128_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET(r) ((((r).temp_mon_ctl[0]) >> 1) & 0x7f)
#define BCM53128_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_CTL.
 *
 */
#define BCM53128_A0_READ_TEMP_MON_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TEMP_MON_CTLr,(r._temp_mon_ctl),1)
#define BCM53128_A0_WRITE_TEMP_MON_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TEMP_MON_CTLr,&(r._temp_mon_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CTLr BCM53128_A0_TEMP_MON_CTLr
#define TEMP_MON_CTLr_SIZE BCM53128_A0_TEMP_MON_CTLr_SIZE
typedef BCM53128_A0_TEMP_MON_CTLr_t TEMP_MON_CTLr_t;
#define TEMP_MON_CTLr_CLR BCM53128_A0_TEMP_MON_CTLr_CLR
#define TEMP_MON_CTLr_SET BCM53128_A0_TEMP_MON_CTLr_SET
#define TEMP_MON_CTLr_GET BCM53128_A0_TEMP_MON_CTLr_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_GET BCM53128_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_SET BCM53128_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_GET BCM53128_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_SET BCM53128_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET
#define READ_TEMP_MON_CTLr BCM53128_A0_READ_TEMP_MON_CTLr
#define WRITE_TEMP_MON_CTLr BCM53128_A0_WRITE_TEMP_MON_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TEMP_MON_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA        Temperature monitor result. When the temperature is higher, the measure code is lower.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53128_A0_TEMP_MON_RESUr 0x00000f02

#define BCM53128_A0_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_RESU.
 *
 */
typedef union BCM53128_A0_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t temp_mon_resu[1];
	uint32_t _temp_mon_resu;
} BCM53128_A0_TEMP_MON_RESUr_t;

#define BCM53128_A0_TEMP_MON_RESUr_CLR(r) (r).temp_mon_resu[0] = 0
#define BCM53128_A0_TEMP_MON_RESUr_SET(r,d) (r).temp_mon_resu[0] = d
#define BCM53128_A0_TEMP_MON_RESUr_GET(r) (r).temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TEMP_MON_RESUr_TEMP_DATAf_GET(r) (((r).temp_mon_resu[0]) & 0x1ff)
#define BCM53128_A0_TEMP_MON_RESUr_TEMP_DATAf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM53128_A0_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_RESU.
 *
 */
#define BCM53128_A0_READ_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TEMP_MON_RESUr,(r._temp_mon_resu),2)
#define BCM53128_A0_WRITE_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TEMP_MON_RESUr,&(r._temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_RESUr BCM53128_A0_TEMP_MON_RESUr
#define TEMP_MON_RESUr_SIZE BCM53128_A0_TEMP_MON_RESUr_SIZE
typedef BCM53128_A0_TEMP_MON_RESUr_t TEMP_MON_RESUr_t;
#define TEMP_MON_RESUr_CLR BCM53128_A0_TEMP_MON_RESUr_CLR
#define TEMP_MON_RESUr_SET BCM53128_A0_TEMP_MON_RESUr_SET
#define TEMP_MON_RESUr_GET BCM53128_A0_TEMP_MON_RESUr_GET
#define TEMP_MON_RESUr_TEMP_DATAf_GET BCM53128_A0_TEMP_MON_RESUr_TEMP_DATAf_GET
#define TEMP_MON_RESUr_TEMP_DATAf_SET BCM53128_A0_TEMP_MON_RESUr_TEMP_DATAf_SET
#define TEMP_MON_RESUr_RESERVEDf_GET BCM53128_A0_TEMP_MON_RESUr_RESERVEDf_GET
#define TEMP_MON_RESUr_RESERVEDf_SET BCM53128_A0_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_TEMP_MON_RESUr BCM53128_A0_READ_TEMP_MON_RESUr
#define WRITE_TEMP_MON_RESUr BCM53128_A0_WRITE_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TEMP_MON_SPEC_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Special Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     TEMP_PWRDN       1=Set temperature monitor in power down condition.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53128_A0_TEMP_MON_SPEC_CTLr 0x00000f08

#define BCM53128_A0_TEMP_MON_SPEC_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_SPEC_CTL.
 *
 */
typedef union BCM53128_A0_TEMP_MON_SPEC_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_spec_ctl[1];
	uint32_t _temp_mon_spec_ctl;
} BCM53128_A0_TEMP_MON_SPEC_CTLr_t;

#define BCM53128_A0_TEMP_MON_SPEC_CTLr_CLR(r) (r).temp_mon_spec_ctl[0] = 0
#define BCM53128_A0_TEMP_MON_SPEC_CTLr_SET(r,d) (r).temp_mon_spec_ctl[0] = d
#define BCM53128_A0_TEMP_MON_SPEC_CTLr_GET(r) (r).temp_mon_spec_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET(r) (((r).temp_mon_spec_ctl[0]) & 0x1)
#define BCM53128_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET(r) ((((r).temp_mon_spec_ctl[0]) >> 1) & 0x7f)
#define BCM53128_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_SPEC_CTL.
 *
 */
#define BCM53128_A0_READ_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TEMP_MON_SPEC_CTLr,(r._temp_mon_spec_ctl),1)
#define BCM53128_A0_WRITE_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TEMP_MON_SPEC_CTLr,&(r._temp_mon_spec_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_SPEC_CTLr BCM53128_A0_TEMP_MON_SPEC_CTLr
#define TEMP_MON_SPEC_CTLr_SIZE BCM53128_A0_TEMP_MON_SPEC_CTLr_SIZE
typedef BCM53128_A0_TEMP_MON_SPEC_CTLr_t TEMP_MON_SPEC_CTLr_t;
#define TEMP_MON_SPEC_CTLr_CLR BCM53128_A0_TEMP_MON_SPEC_CTLr_CLR
#define TEMP_MON_SPEC_CTLr_SET BCM53128_A0_TEMP_MON_SPEC_CTLr_SET
#define TEMP_MON_SPEC_CTLr_GET BCM53128_A0_TEMP_MON_SPEC_CTLr_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET BCM53128_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET BCM53128_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_GET BCM53128_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_SET BCM53128_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET
#define READ_TEMP_MON_SPEC_CTLr BCM53128_A0_READ_TEMP_MON_SPEC_CTLr
#define WRITE_TEMP_MON_SPEC_CTLr BCM53128_A0_WRITE_TEMP_MON_SPEC_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TEMP_MON_SPEC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TM_STAMP_RPT_CTRL
 * BLOCKS:   SYS
 * DESC:     AVB Time Stamp Report Control Register
 * SIZE:     8
 * FIELDS:
 *     TSRPT_PKT_EN     tsrpt_pkt_enThis field is to allow "Time Stamp Reporting Packet" to IMP when the time sync. packet transmitted on egress port .
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_TM_STAMP_RPT_CTRLr 0x00009002

#define BCM53128_A0_TM_STAMP_RPT_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program TM_STAMP_RPT_CTRL.
 *
 */
typedef union BCM53128_A0_TM_STAMP_RPT_CTRLr_s {
	uint32_t v[1];
	uint32_t tm_stamp_rpt_ctrl[1];
	uint32_t _tm_stamp_rpt_ctrl;
} BCM53128_A0_TM_STAMP_RPT_CTRLr_t;

#define BCM53128_A0_TM_STAMP_RPT_CTRLr_CLR(r) (r).tm_stamp_rpt_ctrl[0] = 0
#define BCM53128_A0_TM_STAMP_RPT_CTRLr_SET(r,d) (r).tm_stamp_rpt_ctrl[0] = d
#define BCM53128_A0_TM_STAMP_RPT_CTRLr_GET(r) (r).tm_stamp_rpt_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET(r) (((r).tm_stamp_rpt_ctrl[0]) & 0x1)
#define BCM53128_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET(r,f) (r).tm_stamp_rpt_ctrl[0]=(((r).tm_stamp_rpt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_GET(r) ((((r).tm_stamp_rpt_ctrl[0]) >> 1) & 0x7f)
#define BCM53128_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_SET(r,f) (r).tm_stamp_rpt_ctrl[0]=(((r).tm_stamp_rpt_ctrl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TM_STAMP_RPT_CTRL.
 *
 */
#define BCM53128_A0_READ_TM_STAMP_RPT_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TM_STAMP_RPT_CTRLr,(r._tm_stamp_rpt_ctrl),1)
#define BCM53128_A0_WRITE_TM_STAMP_RPT_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TM_STAMP_RPT_CTRLr,&(r._tm_stamp_rpt_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TM_STAMP_RPT_CTRLr BCM53128_A0_TM_STAMP_RPT_CTRLr
#define TM_STAMP_RPT_CTRLr_SIZE BCM53128_A0_TM_STAMP_RPT_CTRLr_SIZE
typedef BCM53128_A0_TM_STAMP_RPT_CTRLr_t TM_STAMP_RPT_CTRLr_t;
#define TM_STAMP_RPT_CTRLr_CLR BCM53128_A0_TM_STAMP_RPT_CTRLr_CLR
#define TM_STAMP_RPT_CTRLr_SET BCM53128_A0_TM_STAMP_RPT_CTRLr_SET
#define TM_STAMP_RPT_CTRLr_GET BCM53128_A0_TM_STAMP_RPT_CTRLr_GET
#define TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET BCM53128_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET
#define TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET BCM53128_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET
#define TM_STAMP_RPT_CTRLr_RESERVEDf_GET BCM53128_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_GET
#define TM_STAMP_RPT_CTRLr_RESERVEDf_SET BCM53128_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_SET
#define READ_TM_STAMP_RPT_CTRLr BCM53128_A0_READ_TM_STAMP_RPT_CTRLr
#define WRITE_TM_STAMP_RPT_CTRLr BCM53128_A0_WRITE_TM_STAMP_RPT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TM_STAMP_RPT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TM_STAMP_STATUS
 * BLOCKS:   SYS
 * DESC:     AVB Egress Time Stamp Status Register
 * SIZE:     8
 * FIELDS:
 *     VALID_STATUS     Valid Status5 bit field indicating  the Valid Status for each Time Stamp Register.  Once AVB Egress Time Stamp Register  read out by SPI, the Valid Status will be cleared respectively.
 *
 ******************************************************************************/
#define BCM53128_A0_TM_STAMP_STATUSr 0x000090d0

#define BCM53128_A0_TM_STAMP_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program TM_STAMP_STATUS.
 *
 */
typedef union BCM53128_A0_TM_STAMP_STATUSr_s {
	uint32_t v[1];
	uint32_t tm_stamp_status[1];
	uint32_t _tm_stamp_status;
} BCM53128_A0_TM_STAMP_STATUSr_t;

#define BCM53128_A0_TM_STAMP_STATUSr_CLR(r) (r).tm_stamp_status[0] = 0
#define BCM53128_A0_TM_STAMP_STATUSr_SET(r,d) (r).tm_stamp_status[0] = d
#define BCM53128_A0_TM_STAMP_STATUSr_GET(r) (r).tm_stamp_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TM_STAMP_STATUSr_VALID_STATUSf_GET(r) (((r).tm_stamp_status[0]) & 0xff)
#define BCM53128_A0_TM_STAMP_STATUSr_VALID_STATUSf_SET(r,f) (r).tm_stamp_status[0]=(((r).tm_stamp_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TM_STAMP_STATUS.
 *
 */
#define BCM53128_A0_READ_TM_STAMP_STATUSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TM_STAMP_STATUSr,(r._tm_stamp_status),1)
#define BCM53128_A0_WRITE_TM_STAMP_STATUSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TM_STAMP_STATUSr,&(r._tm_stamp_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TM_STAMP_STATUSr BCM53128_A0_TM_STAMP_STATUSr
#define TM_STAMP_STATUSr_SIZE BCM53128_A0_TM_STAMP_STATUSr_SIZE
typedef BCM53128_A0_TM_STAMP_STATUSr_t TM_STAMP_STATUSr_t;
#define TM_STAMP_STATUSr_CLR BCM53128_A0_TM_STAMP_STATUSr_CLR
#define TM_STAMP_STATUSr_SET BCM53128_A0_TM_STAMP_STATUSr_SET
#define TM_STAMP_STATUSr_GET BCM53128_A0_TM_STAMP_STATUSr_GET
#define TM_STAMP_STATUSr_VALID_STATUSf_GET BCM53128_A0_TM_STAMP_STATUSr_VALID_STATUSf_GET
#define TM_STAMP_STATUSr_VALID_STATUSf_SET BCM53128_A0_TM_STAMP_STATUSr_VALID_STATUSf_SET
#define READ_TM_STAMP_STATUSr BCM53128_A0_READ_TM_STAMP_STATUSr
#define WRITE_TM_STAMP_STATUSr BCM53128_A0_WRITE_TM_STAMP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TM_STAMP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TRREG_CTRL
 * BLOCKS:   SYS
 * DESC:     Traffic Remarking Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_0       Reserved
 *     PCP_RMK_EN       PCP Remarking EnableThis signal enable the PCP remarking function.Bit[24]: P8(IMP port)Bit[23:16]: P7-P0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_TRREG_CTRLr 0x00009100

#define BCM53128_A0_TRREG_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program TRREG_CTRL.
 *
 */
typedef union BCM53128_A0_TRREG_CTRLr_s {
	uint32_t v[1];
	uint32_t trreg_ctrl[1];
	uint32_t _trreg_ctrl;
} BCM53128_A0_TRREG_CTRLr_t;

#define BCM53128_A0_TRREG_CTRLr_CLR(r) (r).trreg_ctrl[0] = 0
#define BCM53128_A0_TRREG_CTRLr_SET(r,d) (r).trreg_ctrl[0] = d
#define BCM53128_A0_TRREG_CTRLr_GET(r) (r).trreg_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TRREG_CTRLr_RESERVED_0f_GET(r) (((r).trreg_ctrl[0]) & 0xffff)
#define BCM53128_A0_TRREG_CTRLr_RESERVED_0f_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53128_A0_TRREG_CTRLr_PCP_RMK_ENf_GET(r) ((((r).trreg_ctrl[0]) >> 16) & 0x1ff)
#define BCM53128_A0_TRREG_CTRLr_PCP_RMK_ENf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff << 16)) | ((((uint32_t)f) & 0x1ff) << 16))
#define BCM53128_A0_TRREG_CTRLr_RESERVED_1f_GET(r) ((((r).trreg_ctrl[0]) >> 25) & 0x7f)
#define BCM53128_A0_TRREG_CTRLr_RESERVED_1f_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access TRREG_CTRL.
 *
 */
#define BCM53128_A0_READ_TRREG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TRREG_CTRLr,(r._trreg_ctrl),4)
#define BCM53128_A0_WRITE_TRREG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TRREG_CTRLr,&(r._trreg_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRREG_CTRLr BCM53128_A0_TRREG_CTRLr
#define TRREG_CTRLr_SIZE BCM53128_A0_TRREG_CTRLr_SIZE
typedef BCM53128_A0_TRREG_CTRLr_t TRREG_CTRLr_t;
#define TRREG_CTRLr_CLR BCM53128_A0_TRREG_CTRLr_CLR
#define TRREG_CTRLr_SET BCM53128_A0_TRREG_CTRLr_SET
#define TRREG_CTRLr_GET BCM53128_A0_TRREG_CTRLr_GET
#define TRREG_CTRLr_RESERVED_0f_GET BCM53128_A0_TRREG_CTRLr_RESERVED_0f_GET
#define TRREG_CTRLr_RESERVED_0f_SET BCM53128_A0_TRREG_CTRLr_RESERVED_0f_SET
#define TRREG_CTRLr_PCP_RMK_ENf_GET BCM53128_A0_TRREG_CTRLr_PCP_RMK_ENf_GET
#define TRREG_CTRLr_PCP_RMK_ENf_SET BCM53128_A0_TRREG_CTRLr_PCP_RMK_ENf_SET
#define TRREG_CTRLr_RESERVED_1f_GET BCM53128_A0_TRREG_CTRLr_RESERVED_1f_GET
#define TRREG_CTRLr_RESERVED_1f_SET BCM53128_A0_TRREG_CTRLr_RESERVED_1f_SET
#define READ_TRREG_CTRLr BCM53128_A0_READ_TRREG_CTRLr
#define WRITE_TRREG_CTRLr BCM53128_A0_WRITE_TRREG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TRREG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TRUNK_GRP_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TRUNK_GRP     Trunk Group Enable1 = Enable trunk group.0 = Disable trunk_groupBit 8: IMP port.For Blackbird2 bits[7:0] correspond to ports [7:0], respectively.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_TRUNK_GRP_CTLr 0x00003210

#define BCM53128_A0_TRUNK_GRP_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP_CTL.
 *
 */
typedef union BCM53128_A0_TRUNK_GRP_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_ctl[1];
	uint32_t _trunk_grp_ctl;
} BCM53128_A0_TRUNK_GRP_CTLr_t;

#define BCM53128_A0_TRUNK_GRP_CTLr_CLR(r) (r).trunk_grp_ctl[0] = 0
#define BCM53128_A0_TRUNK_GRP_CTLr_SET(r,d) (r).trunk_grp_ctl[0] = d
#define BCM53128_A0_TRUNK_GRP_CTLr_GET(r) (r).trunk_grp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET(r) (((r).trunk_grp_ctl[0]) & 0x1ff)
#define BCM53128_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TRUNK_GRP_CTLr_RESERVEDf_GET(r) ((((r).trunk_grp_ctl[0]) >> 9) & 0x7f)
#define BCM53128_A0_TRUNK_GRP_CTLr_RESERVEDf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP_CTL.
 *
 */
#define BCM53128_A0_READ_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_read(u,BCM53128_A0_TRUNK_GRP_CTLr+(2*(i)),(r._trunk_grp_ctl),2)
#define BCM53128_A0_WRITE_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_write(u,BCM53128_A0_TRUNK_GRP_CTLr+(2*(i)),&(r._trunk_grp_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_CTLr BCM53128_A0_TRUNK_GRP_CTLr
#define TRUNK_GRP_CTLr_SIZE BCM53128_A0_TRUNK_GRP_CTLr_SIZE
typedef BCM53128_A0_TRUNK_GRP_CTLr_t TRUNK_GRP_CTLr_t;
#define TRUNK_GRP_CTLr_CLR BCM53128_A0_TRUNK_GRP_CTLr_CLR
#define TRUNK_GRP_CTLr_SET BCM53128_A0_TRUNK_GRP_CTLr_SET
#define TRUNK_GRP_CTLr_GET BCM53128_A0_TRUNK_GRP_CTLr_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET BCM53128_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET BCM53128_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET
#define TRUNK_GRP_CTLr_RESERVEDf_GET BCM53128_A0_TRUNK_GRP_CTLr_RESERVEDf_GET
#define TRUNK_GRP_CTLr_RESERVEDf_SET BCM53128_A0_TRUNK_GRP_CTLr_RESERVEDf_SET
#define READ_TRUNK_GRP_CTLr BCM53128_A0_READ_TRUNK_GRP_CTLr
#define WRITE_TRUNK_GRP_CTLr BCM53128_A0_WRITE_TRUNK_GRP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TRUNK_GRP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TXQ_FLUSH_MODE
 * BLOCKS:   SYS
 * DESC:     TxQ Flush Mode Control Register (Not2Release)
 * SIZE:     8
 * FIELDS:
 *     BYPASS_FASTTXDSC_PATH Bypass Fast Txdsc Path.
 *     DIS_NEW_TXDIS    Disable new tx disable.
 *     EN_LCOL_FLUSH    Enable Lcol Flush.
 *     EN_RELOAD_ERR_PATH Enable Reload Error Path.
 *     EN_LCOL_TXFM_MASK bit[4] = enable_lcol_txfm_mask (default = 0)Description:- When enabled, Blackbird2 drops the TX frame upon a latecollision.  (collisions detected beyond 64th byte including the preamble)- When disabled, Blackbird2 transmits TX frames regardless of late-collision occurrence.
 *     EN_ECOL_TXFM_MASK PortCollisionModeCollisionTransmitMaskEnablebit[5] = enable_ecol_txfm_mask (default = 1)This bit affect the behavior of the register Retry_Lmt_Dis (Switch Mode reg 00:0Bh bit2) as follows:- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 1,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and stay at 15 until the next normal frame transmission.- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 0,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and loops back to 0and repeats this until the next normal frame transmission.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 1,TX frame is retried up to 15 times, and the frame gets dropped upon the 16th consecutive early collision.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 0,This mode is only engineering purpose, and prohibited for customers (ENGINEERING NOTE: This mode sets Blackbird2 to the old mode, where we observed the tx ports hang. Don't show this in the customer datasheet).(Not2Release)
 *     EN_LATECOL65_DROP enable_latecol65_drop.Enable old frame drop when a late collision occurs at 65th byte from start of preamble. When enabled, Blackbird2 goes back to old mode by turning off the fix for Cisco TX Hang.Default is 0(Not2Release)
 *     EN_NEW_BOFF_SEED 1'b1:backoff seed refer to port mumber.1'b0:backoff seed used default fix mumber.
 *
 ******************************************************************************/
#define BCM53128_A0_TXQ_FLUSH_MODEr 0x00000031

#define BCM53128_A0_TXQ_FLUSH_MODEr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_FLUSH_MODE.
 *
 */
typedef union BCM53128_A0_TXQ_FLUSH_MODEr_s {
	uint32_t v[1];
	uint32_t txq_flush_mode[1];
	uint32_t _txq_flush_mode;
} BCM53128_A0_TXQ_FLUSH_MODEr_t;

#define BCM53128_A0_TXQ_FLUSH_MODEr_CLR(r) (r).txq_flush_mode[0] = 0
#define BCM53128_A0_TXQ_FLUSH_MODEr_SET(r,d) (r).txq_flush_mode[0] = d
#define BCM53128_A0_TXQ_FLUSH_MODEr_GET(r) (r).txq_flush_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET(r) (((r).txq_flush_mode[0]) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET(r) ((((r).txq_flush_mode[0]) >> 1) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET(r) ((((r).txq_flush_mode[0]) >> 2) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET(r) ((((r).txq_flush_mode[0]) >> 3) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 4) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 5) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET(r) ((((r).txq_flush_mode[0]) >> 6) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET(r) ((((r).txq_flush_mode[0]) >> 7) & 0x1)
#define BCM53128_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_FLUSH_MODE.
 *
 */
#define BCM53128_A0_READ_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQ_FLUSH_MODEr,(r._txq_flush_mode),1)
#define BCM53128_A0_WRITE_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQ_FLUSH_MODEr,&(r._txq_flush_mode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_FLUSH_MODEr BCM53128_A0_TXQ_FLUSH_MODEr
#define TXQ_FLUSH_MODEr_SIZE BCM53128_A0_TXQ_FLUSH_MODEr_SIZE
typedef BCM53128_A0_TXQ_FLUSH_MODEr_t TXQ_FLUSH_MODEr_t;
#define TXQ_FLUSH_MODEr_CLR BCM53128_A0_TXQ_FLUSH_MODEr_CLR
#define TXQ_FLUSH_MODEr_SET BCM53128_A0_TXQ_FLUSH_MODEr_SET
#define TXQ_FLUSH_MODEr_GET BCM53128_A0_TXQ_FLUSH_MODEr_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET BCM53128_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET BCM53128_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET BCM53128_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET BCM53128_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET BCM53128_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET BCM53128_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET BCM53128_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET BCM53128_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET BCM53128_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET BCM53128_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET BCM53128_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET BCM53128_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET BCM53128_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET
#define READ_TXQ_FLUSH_MODEr BCM53128_A0_READ_TXQ_FLUSH_MODEr
#define WRITE_TXQ_FLUSH_MODEr BCM53128_A0_WRITE_TXQ_FLUSH_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQ_FLUSH_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for TX Register
 * SIZE:     16
 * FIELDS:
 *     TX_PAUSE_PASS    TX pause pass through map.bit[8:0] : Port 8-01 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_TX_PAUSE_PASSr 0x0000003a

#define BCM53128_A0_TX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program TX_PAUSE_PASS.
 *
 */
typedef union BCM53128_A0_TX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t tx_pause_pass[1];
	uint32_t _tx_pause_pass;
} BCM53128_A0_TX_PAUSE_PASSr_t;

#define BCM53128_A0_TX_PAUSE_PASSr_CLR(r) (r).tx_pause_pass[0] = 0
#define BCM53128_A0_TX_PAUSE_PASSr_SET(r,d) (r).tx_pause_pass[0] = d
#define BCM53128_A0_TX_PAUSE_PASSr_GET(r) (r).tx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET(r) (((r).tx_pause_pass[0]) & 0x1ff)
#define BCM53128_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_TX_PAUSE_PASSr_RESERVEDf_GET(r) ((((r).tx_pause_pass[0]) >> 9) & 0x7f)
#define BCM53128_A0_TX_PAUSE_PASSr_RESERVEDf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TX_PAUSE_PASS.
 *
 */
#define BCM53128_A0_READ_TX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TX_PAUSE_PASSr,(r._tx_pause_pass),2)
#define BCM53128_A0_WRITE_TX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TX_PAUSE_PASSr,&(r._tx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PAUSE_PASSr BCM53128_A0_TX_PAUSE_PASSr
#define TX_PAUSE_PASSr_SIZE BCM53128_A0_TX_PAUSE_PASSr_SIZE
typedef BCM53128_A0_TX_PAUSE_PASSr_t TX_PAUSE_PASSr_t;
#define TX_PAUSE_PASSr_CLR BCM53128_A0_TX_PAUSE_PASSr_CLR
#define TX_PAUSE_PASSr_SET BCM53128_A0_TX_PAUSE_PASSr_SET
#define TX_PAUSE_PASSr_GET BCM53128_A0_TX_PAUSE_PASSr_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET BCM53128_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET BCM53128_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET
#define TX_PAUSE_PASSr_RESERVEDf_GET BCM53128_A0_TX_PAUSE_PASSr_RESERVEDf_GET
#define TX_PAUSE_PASSr_RESERVEDf_SET BCM53128_A0_TX_PAUSE_PASSr_RESERVEDf_SET
#define READ_TX_PAUSE_PASSr BCM53128_A0_READ_TX_PAUSE_PASSr
#define WRITE_TX_PAUSE_PASSr BCM53128_A0_WRITE_TX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXBROADCASTPKTSr 0x00002010

#define BCM53128_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 *
 */
typedef union BCM53128_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM53128_A0_TXBROADCASTPKTSr_t;

#define BCM53128_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM53128_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM53128_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 *
 */
#define BCM53128_A0_READ_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM53128_A0_WRITE_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM53128_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM53128_A0_TXBROADCASTPKTSr_SIZE
typedef BCM53128_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM53128_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM53128_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM53128_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM53128_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM53128_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxBroadcastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXBROADCASTPKTS_IMPr 0x00002810

#define BCM53128_A0_TXBROADCASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts_IMP.
 *
 */
typedef union BCM53128_A0_TXBROADCASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts_imp[1];
	uint32_t _txbroadcastpkts_imp;
} BCM53128_A0_TXBROADCASTPKTS_IMPr_t;

#define BCM53128_A0_TXBROADCASTPKTS_IMPr_CLR(r) (r).txbroadcastpkts_imp[0] = 0
#define BCM53128_A0_TXBROADCASTPKTS_IMPr_SET(r,d) (r).txbroadcastpkts_imp[0] = d
#define BCM53128_A0_TXBROADCASTPKTS_IMPr_GET(r) (r).txbroadcastpkts_imp[0]


/*
 * These macros can be used to access TxBroadcastPkts_IMP.
 *
 */
#define BCM53128_A0_READ_TXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXBROADCASTPKTS_IMPr,(r._txbroadcastpkts_imp),4)
#define BCM53128_A0_WRITE_TXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXBROADCASTPKTS_IMPr,&(r._txbroadcastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTS_IMPr BCM53128_A0_TXBROADCASTPKTS_IMPr
#define TXBROADCASTPKTS_IMPr_SIZE BCM53128_A0_TXBROADCASTPKTS_IMPr_SIZE
typedef BCM53128_A0_TXBROADCASTPKTS_IMPr_t TXBROADCASTPKTS_IMPr_t;
#define TXBROADCASTPKTS_IMPr_CLR BCM53128_A0_TXBROADCASTPKTS_IMPr_CLR
#define TXBROADCASTPKTS_IMPr_SET BCM53128_A0_TXBROADCASTPKTS_IMPr_SET
#define TXBROADCASTPKTS_IMPr_GET BCM53128_A0_TXBROADCASTPKTS_IMPr_GET
#define READ_TXBROADCASTPKTS_IMPr BCM53128_A0_READ_TXBROADCASTPKTS_IMPr
#define WRITE_TXBROADCASTPKTS_IMPr BCM53128_A0_WRITE_TXBROADCASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXBROADCASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXCOLLISIONSr 0x0000201c

#define BCM53128_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 *
 */
typedef union BCM53128_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM53128_A0_TXCOLLISIONSr_t;

#define BCM53128_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM53128_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM53128_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 *
 */
#define BCM53128_A0_READ_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM53128_A0_WRITE_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM53128_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM53128_A0_TXCOLLISIONSr_SIZE
typedef BCM53128_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM53128_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM53128_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM53128_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM53128_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM53128_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxCollisions_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXCOLLISIONS_IMPr 0x0000281c

#define BCM53128_A0_TXCOLLISIONS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions_IMP.
 *
 */
typedef union BCM53128_A0_TXCOLLISIONS_IMPr_s {
	uint32_t v[1];
	uint32_t txcollisions_imp[1];
	uint32_t _txcollisions_imp;
} BCM53128_A0_TXCOLLISIONS_IMPr_t;

#define BCM53128_A0_TXCOLLISIONS_IMPr_CLR(r) (r).txcollisions_imp[0] = 0
#define BCM53128_A0_TXCOLLISIONS_IMPr_SET(r,d) (r).txcollisions_imp[0] = d
#define BCM53128_A0_TXCOLLISIONS_IMPr_GET(r) (r).txcollisions_imp[0]


/*
 * These macros can be used to access TxCollisions_IMP.
 *
 */
#define BCM53128_A0_READ_TXCOLLISIONS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXCOLLISIONS_IMPr,(r._txcollisions_imp),4)
#define BCM53128_A0_WRITE_TXCOLLISIONS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXCOLLISIONS_IMPr,&(r._txcollisions_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONS_IMPr BCM53128_A0_TXCOLLISIONS_IMPr
#define TXCOLLISIONS_IMPr_SIZE BCM53128_A0_TXCOLLISIONS_IMPr_SIZE
typedef BCM53128_A0_TXCOLLISIONS_IMPr_t TXCOLLISIONS_IMPr_t;
#define TXCOLLISIONS_IMPr_CLR BCM53128_A0_TXCOLLISIONS_IMPr_CLR
#define TXCOLLISIONS_IMPr_SET BCM53128_A0_TXCOLLISIONS_IMPr_SET
#define TXCOLLISIONS_IMPr_GET BCM53128_A0_TXCOLLISIONS_IMPr_GET
#define READ_TXCOLLISIONS_IMPr BCM53128_A0_READ_TXCOLLISIONS_IMPr
#define WRITE_TXCOLLISIONS_IMPr BCM53128_A0_WRITE_TXCOLLISIONS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXCOLLISIONS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXDEFERREDTRANSMITr 0x00002028

#define BCM53128_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 *
 */
typedef union BCM53128_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM53128_A0_TXDEFERREDTRANSMITr_t;

#define BCM53128_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM53128_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM53128_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 *
 */
#define BCM53128_A0_READ_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM53128_A0_WRITE_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM53128_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM53128_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM53128_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM53128_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM53128_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM53128_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM53128_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM53128_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxDeferredTransmit_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXDEFERREDTRANSMIT_IMPr 0x00002828

#define BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit_IMP.
 *
 */
typedef union BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit_imp[1];
	uint32_t _txdeferredtransmit_imp;
} BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_t;

#define BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_CLR(r) (r).txdeferredtransmit_imp[0] = 0
#define BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_SET(r,d) (r).txdeferredtransmit_imp[0] = d
#define BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_GET(r) (r).txdeferredtransmit_imp[0]


/*
 * These macros can be used to access TxDeferredTransmit_IMP.
 *
 */
#define BCM53128_A0_READ_TXDEFERREDTRANSMIT_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXDEFERREDTRANSMIT_IMPr,(r._txdeferredtransmit_imp),4)
#define BCM53128_A0_WRITE_TXDEFERREDTRANSMIT_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXDEFERREDTRANSMIT_IMPr,&(r._txdeferredtransmit_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMIT_IMPr BCM53128_A0_TXDEFERREDTRANSMIT_IMPr
#define TXDEFERREDTRANSMIT_IMPr_SIZE BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_SIZE
typedef BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_t TXDEFERREDTRANSMIT_IMPr_t;
#define TXDEFERREDTRANSMIT_IMPr_CLR BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_CLR
#define TXDEFERREDTRANSMIT_IMPr_SET BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_SET
#define TXDEFERREDTRANSMIT_IMPr_GET BCM53128_A0_TXDEFERREDTRANSMIT_IMPr_GET
#define READ_TXDEFERREDTRANSMIT_IMPr BCM53128_A0_READ_TXDEFERREDTRANSMIT_IMPr
#define WRITE_TXDEFERREDTRANSMIT_IMPr BCM53128_A0_WRITE_TXDEFERREDTRANSMIT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXDEFERREDTRANSMIT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXDROPPKTSr 0x00002008

#define BCM53128_A0_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts.
 *
 */
typedef union BCM53128_A0_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t txdroppkts[1];
	uint32_t _txdroppkts;
} BCM53128_A0_TXDROPPKTSr_t;

#define BCM53128_A0_TXDROPPKTSr_CLR(r) (r).txdroppkts[0] = 0
#define BCM53128_A0_TXDROPPKTSr_SET(r,d) (r).txdroppkts[0] = d
#define BCM53128_A0_TXDROPPKTSr_GET(r) (r).txdroppkts[0]


/*
 * These macros can be used to access TxDropPkts.
 *
 */
#define BCM53128_A0_READ_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXDROPPKTSr,(r._txdroppkts),4)
#define BCM53128_A0_WRITE_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXDROPPKTSr,&(r._txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTSr BCM53128_A0_TXDROPPKTSr
#define TXDROPPKTSr_SIZE BCM53128_A0_TXDROPPKTSr_SIZE
typedef BCM53128_A0_TXDROPPKTSr_t TXDROPPKTSr_t;
#define TXDROPPKTSr_CLR BCM53128_A0_TXDROPPKTSr_CLR
#define TXDROPPKTSr_SET BCM53128_A0_TXDROPPKTSr_SET
#define TXDROPPKTSr_GET BCM53128_A0_TXDROPPKTSr_GET
#define READ_TXDROPPKTSr BCM53128_A0_READ_TXDROPPKTSr
#define WRITE_TXDROPPKTSr BCM53128_A0_WRITE_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxDropPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXDROPPKTS_IMPr 0x00002808

#define BCM53128_A0_TXDROPPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts_IMP.
 *
 */
typedef union BCM53128_A0_TXDROPPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txdroppkts_imp[1];
	uint32_t _txdroppkts_imp;
} BCM53128_A0_TXDROPPKTS_IMPr_t;

#define BCM53128_A0_TXDROPPKTS_IMPr_CLR(r) (r).txdroppkts_imp[0] = 0
#define BCM53128_A0_TXDROPPKTS_IMPr_SET(r,d) (r).txdroppkts_imp[0] = d
#define BCM53128_A0_TXDROPPKTS_IMPr_GET(r) (r).txdroppkts_imp[0]


/*
 * These macros can be used to access TxDropPkts_IMP.
 *
 */
#define BCM53128_A0_READ_TXDROPPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXDROPPKTS_IMPr,(r._txdroppkts_imp),4)
#define BCM53128_A0_WRITE_TXDROPPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXDROPPKTS_IMPr,&(r._txdroppkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTS_IMPr BCM53128_A0_TXDROPPKTS_IMPr
#define TXDROPPKTS_IMPr_SIZE BCM53128_A0_TXDROPPKTS_IMPr_SIZE
typedef BCM53128_A0_TXDROPPKTS_IMPr_t TXDROPPKTS_IMPr_t;
#define TXDROPPKTS_IMPr_CLR BCM53128_A0_TXDROPPKTS_IMPr_CLR
#define TXDROPPKTS_IMPr_SET BCM53128_A0_TXDROPPKTS_IMPr_SET
#define TXDROPPKTS_IMPr_GET BCM53128_A0_TXDROPPKTS_IMPr_GET
#define READ_TXDROPPKTS_IMPr BCM53128_A0_READ_TXDROPPKTS_IMPr
#define WRITE_TXDROPPKTS_IMPr BCM53128_A0_WRITE_TXDROPPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXDROPPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXEXCESSIVECOLLISIONr 0x00002030

#define BCM53128_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 *
 */
typedef union BCM53128_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM53128_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM53128_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM53128_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM53128_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 *
 */
#define BCM53128_A0_READ_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM53128_A0_WRITE_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM53128_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM53128_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53128_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM53128_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM53128_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM53128_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM53128_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM53128_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxExcessiveCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXEXCESSIVECOLLISION_IMPr 0x00002830

#define BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision_IMP.
 *
 */
typedef union BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision_imp[1];
	uint32_t _txexcessivecollision_imp;
} BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_t;

#define BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_CLR(r) (r).txexcessivecollision_imp[0] = 0
#define BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_SET(r,d) (r).txexcessivecollision_imp[0] = d
#define BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_GET(r) (r).txexcessivecollision_imp[0]


/*
 * These macros can be used to access TxExcessiveCollision_IMP.
 *
 */
#define BCM53128_A0_READ_TXEXCESSIVECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXEXCESSIVECOLLISION_IMPr,(r._txexcessivecollision_imp),4)
#define BCM53128_A0_WRITE_TXEXCESSIVECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXEXCESSIVECOLLISION_IMPr,&(r._txexcessivecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISION_IMPr BCM53128_A0_TXEXCESSIVECOLLISION_IMPr
#define TXEXCESSIVECOLLISION_IMPr_SIZE BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_SIZE
typedef BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_t TXEXCESSIVECOLLISION_IMPr_t;
#define TXEXCESSIVECOLLISION_IMPr_CLR BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_CLR
#define TXEXCESSIVECOLLISION_IMPr_SET BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_SET
#define TXEXCESSIVECOLLISION_IMPr_GET BCM53128_A0_TXEXCESSIVECOLLISION_IMPr_GET
#define READ_TXEXCESSIVECOLLISION_IMPr BCM53128_A0_READ_TXEXCESSIVECOLLISION_IMPr
#define WRITE_TXEXCESSIVECOLLISION_IMPr BCM53128_A0_WRITE_TXEXCESSIVECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXEXCESSIVECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxFrameInDisc
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXFRAMEINDISCr 0x00002034

#define BCM53128_A0_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc.
 *
 */
typedef union BCM53128_A0_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t txframeindisc[1];
	uint32_t _txframeindisc;
} BCM53128_A0_TXFRAMEINDISCr_t;

#define BCM53128_A0_TXFRAMEINDISCr_CLR(r) (r).txframeindisc[0] = 0
#define BCM53128_A0_TXFRAMEINDISCr_SET(r,d) (r).txframeindisc[0] = d
#define BCM53128_A0_TXFRAMEINDISCr_GET(r) (r).txframeindisc[0]


/*
 * These macros can be used to access TxFrameInDisc.
 *
 */
#define BCM53128_A0_READ_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXFRAMEINDISCr,(r._txframeindisc),4)
#define BCM53128_A0_WRITE_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXFRAMEINDISCr,&(r._txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISCr BCM53128_A0_TXFRAMEINDISCr
#define TXFRAMEINDISCr_SIZE BCM53128_A0_TXFRAMEINDISCr_SIZE
typedef BCM53128_A0_TXFRAMEINDISCr_t TXFRAMEINDISCr_t;
#define TXFRAMEINDISCr_CLR BCM53128_A0_TXFRAMEINDISCr_CLR
#define TXFRAMEINDISCr_SET BCM53128_A0_TXFRAMEINDISCr_SET
#define TXFRAMEINDISCr_GET BCM53128_A0_TXFRAMEINDISCr_GET
#define READ_TXFRAMEINDISCr BCM53128_A0_READ_TXFRAMEINDISCr
#define WRITE_TXFRAMEINDISCr BCM53128_A0_WRITE_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxFrameInDisc_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXFRAMEINDISC_IMPr 0x00002834

#define BCM53128_A0_TXFRAMEINDISC_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc_IMP.
 *
 */
typedef union BCM53128_A0_TXFRAMEINDISC_IMPr_s {
	uint32_t v[1];
	uint32_t txframeindisc_imp[1];
	uint32_t _txframeindisc_imp;
} BCM53128_A0_TXFRAMEINDISC_IMPr_t;

#define BCM53128_A0_TXFRAMEINDISC_IMPr_CLR(r) (r).txframeindisc_imp[0] = 0
#define BCM53128_A0_TXFRAMEINDISC_IMPr_SET(r,d) (r).txframeindisc_imp[0] = d
#define BCM53128_A0_TXFRAMEINDISC_IMPr_GET(r) (r).txframeindisc_imp[0]


/*
 * These macros can be used to access TxFrameInDisc_IMP.
 *
 */
#define BCM53128_A0_READ_TXFRAMEINDISC_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXFRAMEINDISC_IMPr,(r._txframeindisc_imp),4)
#define BCM53128_A0_WRITE_TXFRAMEINDISC_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXFRAMEINDISC_IMPr,&(r._txframeindisc_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISC_IMPr BCM53128_A0_TXFRAMEINDISC_IMPr
#define TXFRAMEINDISC_IMPr_SIZE BCM53128_A0_TXFRAMEINDISC_IMPr_SIZE
typedef BCM53128_A0_TXFRAMEINDISC_IMPr_t TXFRAMEINDISC_IMPr_t;
#define TXFRAMEINDISC_IMPr_CLR BCM53128_A0_TXFRAMEINDISC_IMPr_CLR
#define TXFRAMEINDISC_IMPr_SET BCM53128_A0_TXFRAMEINDISC_IMPr_SET
#define TXFRAMEINDISC_IMPr_GET BCM53128_A0_TXFRAMEINDISC_IMPr_GET
#define READ_TXFRAMEINDISC_IMPr BCM53128_A0_READ_TXFRAMEINDISC_IMPr
#define WRITE_TXFRAMEINDISC_IMPr BCM53128_A0_WRITE_TXFRAMEINDISC_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXFRAMEINDISC_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXLATECOLLISIONr 0x0000202c

#define BCM53128_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 *
 */
typedef union BCM53128_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM53128_A0_TXLATECOLLISIONr_t;

#define BCM53128_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM53128_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM53128_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 *
 */
#define BCM53128_A0_READ_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM53128_A0_WRITE_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM53128_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM53128_A0_TXLATECOLLISIONr_SIZE
typedef BCM53128_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM53128_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM53128_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM53128_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM53128_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM53128_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxLateCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXLATECOLLISION_IMPr 0x0000282c

#define BCM53128_A0_TXLATECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision_IMP.
 *
 */
typedef union BCM53128_A0_TXLATECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txlatecollision_imp[1];
	uint32_t _txlatecollision_imp;
} BCM53128_A0_TXLATECOLLISION_IMPr_t;

#define BCM53128_A0_TXLATECOLLISION_IMPr_CLR(r) (r).txlatecollision_imp[0] = 0
#define BCM53128_A0_TXLATECOLLISION_IMPr_SET(r,d) (r).txlatecollision_imp[0] = d
#define BCM53128_A0_TXLATECOLLISION_IMPr_GET(r) (r).txlatecollision_imp[0]


/*
 * These macros can be used to access TxLateCollision_IMP.
 *
 */
#define BCM53128_A0_READ_TXLATECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXLATECOLLISION_IMPr,(r._txlatecollision_imp),4)
#define BCM53128_A0_WRITE_TXLATECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXLATECOLLISION_IMPr,&(r._txlatecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISION_IMPr BCM53128_A0_TXLATECOLLISION_IMPr
#define TXLATECOLLISION_IMPr_SIZE BCM53128_A0_TXLATECOLLISION_IMPr_SIZE
typedef BCM53128_A0_TXLATECOLLISION_IMPr_t TXLATECOLLISION_IMPr_t;
#define TXLATECOLLISION_IMPr_CLR BCM53128_A0_TXLATECOLLISION_IMPr_CLR
#define TXLATECOLLISION_IMPr_SET BCM53128_A0_TXLATECOLLISION_IMPr_SET
#define TXLATECOLLISION_IMPr_GET BCM53128_A0_TXLATECOLLISION_IMPr_GET
#define READ_TXLATECOLLISION_IMPr BCM53128_A0_READ_TXLATECOLLISION_IMPr
#define WRITE_TXLATECOLLISION_IMPr BCM53128_A0_WRITE_TXLATECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXLATECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXMULTICASTPKTSr 0x00002014

#define BCM53128_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 *
 */
typedef union BCM53128_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM53128_A0_TXMULTICASTPKTSr_t;

#define BCM53128_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM53128_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM53128_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 *
 */
#define BCM53128_A0_READ_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM53128_A0_WRITE_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM53128_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM53128_A0_TXMULTICASTPKTSr_SIZE
typedef BCM53128_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM53128_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM53128_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM53128_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM53128_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM53128_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxMulticastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXMULTICASTPKTS_IMPr 0x00002814

#define BCM53128_A0_TXMULTICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts_IMP.
 *
 */
typedef union BCM53128_A0_TXMULTICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts_imp[1];
	uint32_t _txmulticastpkts_imp;
} BCM53128_A0_TXMULTICASTPKTS_IMPr_t;

#define BCM53128_A0_TXMULTICASTPKTS_IMPr_CLR(r) (r).txmulticastpkts_imp[0] = 0
#define BCM53128_A0_TXMULTICASTPKTS_IMPr_SET(r,d) (r).txmulticastpkts_imp[0] = d
#define BCM53128_A0_TXMULTICASTPKTS_IMPr_GET(r) (r).txmulticastpkts_imp[0]


/*
 * These macros can be used to access TxMulticastPkts_IMP.
 *
 */
#define BCM53128_A0_READ_TXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXMULTICASTPKTS_IMPr,(r._txmulticastpkts_imp),4)
#define BCM53128_A0_WRITE_TXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXMULTICASTPKTS_IMPr,&(r._txmulticastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTS_IMPr BCM53128_A0_TXMULTICASTPKTS_IMPr
#define TXMULTICASTPKTS_IMPr_SIZE BCM53128_A0_TXMULTICASTPKTS_IMPr_SIZE
typedef BCM53128_A0_TXMULTICASTPKTS_IMPr_t TXMULTICASTPKTS_IMPr_t;
#define TXMULTICASTPKTS_IMPr_CLR BCM53128_A0_TXMULTICASTPKTS_IMPr_CLR
#define TXMULTICASTPKTS_IMPr_SET BCM53128_A0_TXMULTICASTPKTS_IMPr_SET
#define TXMULTICASTPKTS_IMPr_GET BCM53128_A0_TXMULTICASTPKTS_IMPr_GET
#define READ_TXMULTICASTPKTS_IMPr BCM53128_A0_READ_TXMULTICASTPKTS_IMPr
#define WRITE_TXMULTICASTPKTS_IMPr BCM53128_A0_WRITE_TXMULTICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXMULTICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxMultipleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXMULTIPLECOLLISIONr 0x00002024

#define BCM53128_A0_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision.
 *
 */
typedef union BCM53128_A0_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision[1];
	uint32_t _txmultiplecollision;
} BCM53128_A0_TXMULTIPLECOLLISIONr_t;

#define BCM53128_A0_TXMULTIPLECOLLISIONr_CLR(r) (r).txmultiplecollision[0] = 0
#define BCM53128_A0_TXMULTIPLECOLLISIONr_SET(r,d) (r).txmultiplecollision[0] = d
#define BCM53128_A0_TXMULTIPLECOLLISIONr_GET(r) (r).txmultiplecollision[0]


/*
 * These macros can be used to access TxMultipleCollision.
 *
 */
#define BCM53128_A0_READ_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXMULTIPLECOLLISIONr,(r._txmultiplecollision),4)
#define BCM53128_A0_WRITE_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXMULTIPLECOLLISIONr,&(r._txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONr BCM53128_A0_TXMULTIPLECOLLISIONr
#define TXMULTIPLECOLLISIONr_SIZE BCM53128_A0_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53128_A0_TXMULTIPLECOLLISIONr_t TXMULTIPLECOLLISIONr_t;
#define TXMULTIPLECOLLISIONr_CLR BCM53128_A0_TXMULTIPLECOLLISIONr_CLR
#define TXMULTIPLECOLLISIONr_SET BCM53128_A0_TXMULTIPLECOLLISIONr_SET
#define TXMULTIPLECOLLISIONr_GET BCM53128_A0_TXMULTIPLECOLLISIONr_GET
#define READ_TXMULTIPLECOLLISIONr BCM53128_A0_READ_TXMULTIPLECOLLISIONr
#define WRITE_TXMULTIPLECOLLISIONr BCM53128_A0_WRITE_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxMultipleCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXMULTIPLECOLLISION_IMPr 0x00002824

#define BCM53128_A0_TXMULTIPLECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision_IMP.
 *
 */
typedef union BCM53128_A0_TXMULTIPLECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision_imp[1];
	uint32_t _txmultiplecollision_imp;
} BCM53128_A0_TXMULTIPLECOLLISION_IMPr_t;

#define BCM53128_A0_TXMULTIPLECOLLISION_IMPr_CLR(r) (r).txmultiplecollision_imp[0] = 0
#define BCM53128_A0_TXMULTIPLECOLLISION_IMPr_SET(r,d) (r).txmultiplecollision_imp[0] = d
#define BCM53128_A0_TXMULTIPLECOLLISION_IMPr_GET(r) (r).txmultiplecollision_imp[0]


/*
 * These macros can be used to access TxMultipleCollision_IMP.
 *
 */
#define BCM53128_A0_READ_TXMULTIPLECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXMULTIPLECOLLISION_IMPr,(r._txmultiplecollision_imp),4)
#define BCM53128_A0_WRITE_TXMULTIPLECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXMULTIPLECOLLISION_IMPr,&(r._txmultiplecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISION_IMPr BCM53128_A0_TXMULTIPLECOLLISION_IMPr
#define TXMULTIPLECOLLISION_IMPr_SIZE BCM53128_A0_TXMULTIPLECOLLISION_IMPr_SIZE
typedef BCM53128_A0_TXMULTIPLECOLLISION_IMPr_t TXMULTIPLECOLLISION_IMPr_t;
#define TXMULTIPLECOLLISION_IMPr_CLR BCM53128_A0_TXMULTIPLECOLLISION_IMPr_CLR
#define TXMULTIPLECOLLISION_IMPr_SET BCM53128_A0_TXMULTIPLECOLLISION_IMPr_SET
#define TXMULTIPLECOLLISION_IMPr_GET BCM53128_A0_TXMULTIPLECOLLISION_IMPr_GET
#define READ_TXMULTIPLECOLLISION_IMPr BCM53128_A0_READ_TXMULTIPLECOLLISION_IMPr
#define WRITE_TXMULTIPLECOLLISION_IMPr BCM53128_A0_WRITE_TXMULTIPLECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXMULTIPLECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53128_A0_TXOCTETSr 0x00002000

#define BCM53128_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 *
 */
typedef union BCM53128_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM53128_A0_TXOCTETSr_t;

#define BCM53128_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM53128_A0_TXOCTETSr_t))
#define BCM53128_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM53128_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 *
 */
#define BCM53128_A0_READ_TXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXOCTETSr,(r._txoctets),8)
#define BCM53128_A0_WRITE_TXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM53128_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM53128_A0_TXOCTETSr_SIZE
typedef BCM53128_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM53128_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM53128_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM53128_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM53128_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM53128_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53128_A0_TXOCTETS_IMPr 0x00002800

#define BCM53128_A0_TXOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets_IMP.
 *
 */
typedef union BCM53128_A0_TXOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t txoctets_imp[2];
	uint32_t _txoctets_imp;
} BCM53128_A0_TXOCTETS_IMPr_t;

#define BCM53128_A0_TXOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._txoctets_imp), 0, sizeof(BCM53128_A0_TXOCTETS_IMPr_t))
#define BCM53128_A0_TXOCTETS_IMPr_SET(r,i,d) (r).txoctets_imp[i] = d
#define BCM53128_A0_TXOCTETS_IMPr_GET(r,i) (r).txoctets_imp[i]


/*
 * These macros can be used to access TxOctets_IMP.
 *
 */
#define BCM53128_A0_READ_TXOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXOCTETS_IMPr,(r._txoctets_imp),8)
#define BCM53128_A0_WRITE_TXOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXOCTETS_IMPr,&(r._txoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETS_IMPr BCM53128_A0_TXOCTETS_IMPr
#define TXOCTETS_IMPr_SIZE BCM53128_A0_TXOCTETS_IMPr_SIZE
typedef BCM53128_A0_TXOCTETS_IMPr_t TXOCTETS_IMPr_t;
#define TXOCTETS_IMPr_CLR BCM53128_A0_TXOCTETS_IMPr_CLR
#define TXOCTETS_IMPr_SET BCM53128_A0_TXOCTETS_IMPr_SET
#define TXOCTETS_IMPr_GET BCM53128_A0_TXOCTETS_IMPr_GET
#define READ_TXOCTETS_IMPr BCM53128_A0_READ_TXOCTETS_IMPr
#define WRITE_TXOCTETS_IMPr BCM53128_A0_WRITE_TXOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXPAUSEPKTSr 0x00002038

#define BCM53128_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 *
 */
typedef union BCM53128_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM53128_A0_TXPAUSEPKTSr_t;

#define BCM53128_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM53128_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM53128_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 *
 */
#define BCM53128_A0_READ_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM53128_A0_WRITE_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM53128_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM53128_A0_TXPAUSEPKTSr_SIZE
typedef BCM53128_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM53128_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM53128_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM53128_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM53128_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM53128_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxPausePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXPAUSEPKTS_IMPr 0x00002838

#define BCM53128_A0_TXPAUSEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts_IMP.
 *
 */
typedef union BCM53128_A0_TXPAUSEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txpausepkts_imp[1];
	uint32_t _txpausepkts_imp;
} BCM53128_A0_TXPAUSEPKTS_IMPr_t;

#define BCM53128_A0_TXPAUSEPKTS_IMPr_CLR(r) (r).txpausepkts_imp[0] = 0
#define BCM53128_A0_TXPAUSEPKTS_IMPr_SET(r,d) (r).txpausepkts_imp[0] = d
#define BCM53128_A0_TXPAUSEPKTS_IMPr_GET(r) (r).txpausepkts_imp[0]


/*
 * These macros can be used to access TxPausePkts_IMP.
 *
 */
#define BCM53128_A0_READ_TXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXPAUSEPKTS_IMPr,(r._txpausepkts_imp),4)
#define BCM53128_A0_WRITE_TXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXPAUSEPKTS_IMPr,&(r._txpausepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTS_IMPr BCM53128_A0_TXPAUSEPKTS_IMPr
#define TXPAUSEPKTS_IMPr_SIZE BCM53128_A0_TXPAUSEPKTS_IMPr_SIZE
typedef BCM53128_A0_TXPAUSEPKTS_IMPr_t TXPAUSEPKTS_IMPr_t;
#define TXPAUSEPKTS_IMPr_CLR BCM53128_A0_TXPAUSEPKTS_IMPr_CLR
#define TXPAUSEPKTS_IMPr_SET BCM53128_A0_TXPAUSEPKTS_IMPr_SET
#define TXPAUSEPKTS_IMPr_GET BCM53128_A0_TXPAUSEPKTS_IMPr_GET
#define READ_TXPAUSEPKTS_IMPr BCM53128_A0_READ_TXPAUSEPKTS_IMPr
#define WRITE_TXPAUSEPKTS_IMPr BCM53128_A0_WRITE_TXPAUSEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXPAUSEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ0
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ0r 0x0000200c

#define BCM53128_A0_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0.
 *
 */
typedef union BCM53128_A0_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t txqpktq0[1];
	uint32_t _txqpktq0;
} BCM53128_A0_TXQPKTQ0r_t;

#define BCM53128_A0_TXQPKTQ0r_CLR(r) (r).txqpktq0[0] = 0
#define BCM53128_A0_TXQPKTQ0r_SET(r,d) (r).txqpktq0[0] = d
#define BCM53128_A0_TXQPKTQ0r_GET(r) (r).txqpktq0[0]


/*
 * These macros can be used to access TxQPKTQ0.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXQPKTQ0r,(r._txqpktq0),4)
#define BCM53128_A0_WRITE_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXQPKTQ0r,&(r._txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0r BCM53128_A0_TXQPKTQ0r
#define TXQPKTQ0r_SIZE BCM53128_A0_TXQPKTQ0r_SIZE
typedef BCM53128_A0_TXQPKTQ0r_t TXQPKTQ0r_t;
#define TXQPKTQ0r_CLR BCM53128_A0_TXQPKTQ0r_CLR
#define TXQPKTQ0r_SET BCM53128_A0_TXQPKTQ0r_SET
#define TXQPKTQ0r_GET BCM53128_A0_TXQPKTQ0r_GET
#define READ_TXQPKTQ0r BCM53128_A0_READ_TXQPKTQ0r
#define WRITE_TXQPKTQ0r BCM53128_A0_WRITE_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ0_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ0_IMPr 0x0000280c

#define BCM53128_A0_TXQPKTQ0_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0_IMP.
 *
 */
typedef union BCM53128_A0_TXQPKTQ0_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq0_imp[1];
	uint32_t _txqpktq0_imp;
} BCM53128_A0_TXQPKTQ0_IMPr_t;

#define BCM53128_A0_TXQPKTQ0_IMPr_CLR(r) (r).txqpktq0_imp[0] = 0
#define BCM53128_A0_TXQPKTQ0_IMPr_SET(r,d) (r).txqpktq0_imp[0] = d
#define BCM53128_A0_TXQPKTQ0_IMPr_GET(r) (r).txqpktq0_imp[0]


/*
 * These macros can be used to access TxQPKTQ0_IMP.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ0_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQPKTQ0_IMPr,(r._txqpktq0_imp),4)
#define BCM53128_A0_WRITE_TXQPKTQ0_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQPKTQ0_IMPr,&(r._txqpktq0_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0_IMPr BCM53128_A0_TXQPKTQ0_IMPr
#define TXQPKTQ0_IMPr_SIZE BCM53128_A0_TXQPKTQ0_IMPr_SIZE
typedef BCM53128_A0_TXQPKTQ0_IMPr_t TXQPKTQ0_IMPr_t;
#define TXQPKTQ0_IMPr_CLR BCM53128_A0_TXQPKTQ0_IMPr_CLR
#define TXQPKTQ0_IMPr_SET BCM53128_A0_TXQPKTQ0_IMPr_SET
#define TXQPKTQ0_IMPr_GET BCM53128_A0_TXQPKTQ0_IMPr_GET
#define READ_TXQPKTQ0_IMPr BCM53128_A0_READ_TXQPKTQ0_IMPr
#define WRITE_TXQPKTQ0_IMPr BCM53128_A0_WRITE_TXQPKTQ0_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ0_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ1
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ1r 0x0000203c

#define BCM53128_A0_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1.
 *
 */
typedef union BCM53128_A0_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t txqpktq1[1];
	uint32_t _txqpktq1;
} BCM53128_A0_TXQPKTQ1r_t;

#define BCM53128_A0_TXQPKTQ1r_CLR(r) (r).txqpktq1[0] = 0
#define BCM53128_A0_TXQPKTQ1r_SET(r,d) (r).txqpktq1[0] = d
#define BCM53128_A0_TXQPKTQ1r_GET(r) (r).txqpktq1[0]


/*
 * These macros can be used to access TxQPKTQ1.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXQPKTQ1r,(r._txqpktq1),4)
#define BCM53128_A0_WRITE_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXQPKTQ1r,&(r._txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1r BCM53128_A0_TXQPKTQ1r
#define TXQPKTQ1r_SIZE BCM53128_A0_TXQPKTQ1r_SIZE
typedef BCM53128_A0_TXQPKTQ1r_t TXQPKTQ1r_t;
#define TXQPKTQ1r_CLR BCM53128_A0_TXQPKTQ1r_CLR
#define TXQPKTQ1r_SET BCM53128_A0_TXQPKTQ1r_SET
#define TXQPKTQ1r_GET BCM53128_A0_TXQPKTQ1r_GET
#define READ_TXQPKTQ1r BCM53128_A0_READ_TXQPKTQ1r
#define WRITE_TXQPKTQ1r BCM53128_A0_WRITE_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ1_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ1_IMPr 0x0000283c

#define BCM53128_A0_TXQPKTQ1_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1_IMP.
 *
 */
typedef union BCM53128_A0_TXQPKTQ1_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq1_imp[1];
	uint32_t _txqpktq1_imp;
} BCM53128_A0_TXQPKTQ1_IMPr_t;

#define BCM53128_A0_TXQPKTQ1_IMPr_CLR(r) (r).txqpktq1_imp[0] = 0
#define BCM53128_A0_TXQPKTQ1_IMPr_SET(r,d) (r).txqpktq1_imp[0] = d
#define BCM53128_A0_TXQPKTQ1_IMPr_GET(r) (r).txqpktq1_imp[0]


/*
 * These macros can be used to access TxQPKTQ1_IMP.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ1_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQPKTQ1_IMPr,(r._txqpktq1_imp),4)
#define BCM53128_A0_WRITE_TXQPKTQ1_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQPKTQ1_IMPr,&(r._txqpktq1_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1_IMPr BCM53128_A0_TXQPKTQ1_IMPr
#define TXQPKTQ1_IMPr_SIZE BCM53128_A0_TXQPKTQ1_IMPr_SIZE
typedef BCM53128_A0_TXQPKTQ1_IMPr_t TXQPKTQ1_IMPr_t;
#define TXQPKTQ1_IMPr_CLR BCM53128_A0_TXQPKTQ1_IMPr_CLR
#define TXQPKTQ1_IMPr_SET BCM53128_A0_TXQPKTQ1_IMPr_SET
#define TXQPKTQ1_IMPr_GET BCM53128_A0_TXQPKTQ1_IMPr_GET
#define READ_TXQPKTQ1_IMPr BCM53128_A0_READ_TXQPKTQ1_IMPr
#define WRITE_TXQPKTQ1_IMPr BCM53128_A0_WRITE_TXQPKTQ1_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ1_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ2
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ2r 0x00002040

#define BCM53128_A0_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2.
 *
 */
typedef union BCM53128_A0_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t txqpktq2[1];
	uint32_t _txqpktq2;
} BCM53128_A0_TXQPKTQ2r_t;

#define BCM53128_A0_TXQPKTQ2r_CLR(r) (r).txqpktq2[0] = 0
#define BCM53128_A0_TXQPKTQ2r_SET(r,d) (r).txqpktq2[0] = d
#define BCM53128_A0_TXQPKTQ2r_GET(r) (r).txqpktq2[0]


/*
 * These macros can be used to access TxQPKTQ2.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXQPKTQ2r,(r._txqpktq2),4)
#define BCM53128_A0_WRITE_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXQPKTQ2r,&(r._txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2r BCM53128_A0_TXQPKTQ2r
#define TXQPKTQ2r_SIZE BCM53128_A0_TXQPKTQ2r_SIZE
typedef BCM53128_A0_TXQPKTQ2r_t TXQPKTQ2r_t;
#define TXQPKTQ2r_CLR BCM53128_A0_TXQPKTQ2r_CLR
#define TXQPKTQ2r_SET BCM53128_A0_TXQPKTQ2r_SET
#define TXQPKTQ2r_GET BCM53128_A0_TXQPKTQ2r_GET
#define READ_TXQPKTQ2r BCM53128_A0_READ_TXQPKTQ2r
#define WRITE_TXQPKTQ2r BCM53128_A0_WRITE_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ2_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ2_IMPr 0x00002840

#define BCM53128_A0_TXQPKTQ2_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2_IMP.
 *
 */
typedef union BCM53128_A0_TXQPKTQ2_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq2_imp[1];
	uint32_t _txqpktq2_imp;
} BCM53128_A0_TXQPKTQ2_IMPr_t;

#define BCM53128_A0_TXQPKTQ2_IMPr_CLR(r) (r).txqpktq2_imp[0] = 0
#define BCM53128_A0_TXQPKTQ2_IMPr_SET(r,d) (r).txqpktq2_imp[0] = d
#define BCM53128_A0_TXQPKTQ2_IMPr_GET(r) (r).txqpktq2_imp[0]


/*
 * These macros can be used to access TxQPKTQ2_IMP.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ2_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQPKTQ2_IMPr,(r._txqpktq2_imp),4)
#define BCM53128_A0_WRITE_TXQPKTQ2_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQPKTQ2_IMPr,&(r._txqpktq2_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2_IMPr BCM53128_A0_TXQPKTQ2_IMPr
#define TXQPKTQ2_IMPr_SIZE BCM53128_A0_TXQPKTQ2_IMPr_SIZE
typedef BCM53128_A0_TXQPKTQ2_IMPr_t TXQPKTQ2_IMPr_t;
#define TXQPKTQ2_IMPr_CLR BCM53128_A0_TXQPKTQ2_IMPr_CLR
#define TXQPKTQ2_IMPr_SET BCM53128_A0_TXQPKTQ2_IMPr_SET
#define TXQPKTQ2_IMPr_GET BCM53128_A0_TXQPKTQ2_IMPr_GET
#define READ_TXQPKTQ2_IMPr BCM53128_A0_READ_TXQPKTQ2_IMPr
#define WRITE_TXQPKTQ2_IMPr BCM53128_A0_WRITE_TXQPKTQ2_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ2_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ3
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ3r 0x00002044

#define BCM53128_A0_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3.
 *
 */
typedef union BCM53128_A0_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t txqpktq3[1];
	uint32_t _txqpktq3;
} BCM53128_A0_TXQPKTQ3r_t;

#define BCM53128_A0_TXQPKTQ3r_CLR(r) (r).txqpktq3[0] = 0
#define BCM53128_A0_TXQPKTQ3r_SET(r,d) (r).txqpktq3[0] = d
#define BCM53128_A0_TXQPKTQ3r_GET(r) (r).txqpktq3[0]


/*
 * These macros can be used to access TxQPKTQ3.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXQPKTQ3r,(r._txqpktq3),4)
#define BCM53128_A0_WRITE_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXQPKTQ3r,&(r._txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3r BCM53128_A0_TXQPKTQ3r
#define TXQPKTQ3r_SIZE BCM53128_A0_TXQPKTQ3r_SIZE
typedef BCM53128_A0_TXQPKTQ3r_t TXQPKTQ3r_t;
#define TXQPKTQ3r_CLR BCM53128_A0_TXQPKTQ3r_CLR
#define TXQPKTQ3r_SET BCM53128_A0_TXQPKTQ3r_SET
#define TXQPKTQ3r_GET BCM53128_A0_TXQPKTQ3r_GET
#define READ_TXQPKTQ3r BCM53128_A0_READ_TXQPKTQ3r
#define WRITE_TXQPKTQ3r BCM53128_A0_WRITE_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ3_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ3_IMPr 0x00002844

#define BCM53128_A0_TXQPKTQ3_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3_IMP.
 *
 */
typedef union BCM53128_A0_TXQPKTQ3_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq3_imp[1];
	uint32_t _txqpktq3_imp;
} BCM53128_A0_TXQPKTQ3_IMPr_t;

#define BCM53128_A0_TXQPKTQ3_IMPr_CLR(r) (r).txqpktq3_imp[0] = 0
#define BCM53128_A0_TXQPKTQ3_IMPr_SET(r,d) (r).txqpktq3_imp[0] = d
#define BCM53128_A0_TXQPKTQ3_IMPr_GET(r) (r).txqpktq3_imp[0]


/*
 * These macros can be used to access TxQPKTQ3_IMP.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ3_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQPKTQ3_IMPr,(r._txqpktq3_imp),4)
#define BCM53128_A0_WRITE_TXQPKTQ3_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQPKTQ3_IMPr,&(r._txqpktq3_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3_IMPr BCM53128_A0_TXQPKTQ3_IMPr
#define TXQPKTQ3_IMPr_SIZE BCM53128_A0_TXQPKTQ3_IMPr_SIZE
typedef BCM53128_A0_TXQPKTQ3_IMPr_t TXQPKTQ3_IMPr_t;
#define TXQPKTQ3_IMPr_CLR BCM53128_A0_TXQPKTQ3_IMPr_CLR
#define TXQPKTQ3_IMPr_SET BCM53128_A0_TXQPKTQ3_IMPr_SET
#define TXQPKTQ3_IMPr_GET BCM53128_A0_TXQPKTQ3_IMPr_GET
#define READ_TXQPKTQ3_IMPr BCM53128_A0_READ_TXQPKTQ3_IMPr
#define WRITE_TXQPKTQ3_IMPr BCM53128_A0_WRITE_TXQPKTQ3_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ3_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ4
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ4r 0x00002048

#define BCM53128_A0_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4.
 *
 */
typedef union BCM53128_A0_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t txqpktq4[1];
	uint32_t _txqpktq4;
} BCM53128_A0_TXQPKTQ4r_t;

#define BCM53128_A0_TXQPKTQ4r_CLR(r) (r).txqpktq4[0] = 0
#define BCM53128_A0_TXQPKTQ4r_SET(r,d) (r).txqpktq4[0] = d
#define BCM53128_A0_TXQPKTQ4r_GET(r) (r).txqpktq4[0]


/*
 * These macros can be used to access TxQPKTQ4.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXQPKTQ4r,(r._txqpktq4),4)
#define BCM53128_A0_WRITE_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXQPKTQ4r,&(r._txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4r BCM53128_A0_TXQPKTQ4r
#define TXQPKTQ4r_SIZE BCM53128_A0_TXQPKTQ4r_SIZE
typedef BCM53128_A0_TXQPKTQ4r_t TXQPKTQ4r_t;
#define TXQPKTQ4r_CLR BCM53128_A0_TXQPKTQ4r_CLR
#define TXQPKTQ4r_SET BCM53128_A0_TXQPKTQ4r_SET
#define TXQPKTQ4r_GET BCM53128_A0_TXQPKTQ4r_GET
#define READ_TXQPKTQ4r BCM53128_A0_READ_TXQPKTQ4r
#define WRITE_TXQPKTQ4r BCM53128_A0_WRITE_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ4_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ4_IMPr 0x00002848

#define BCM53128_A0_TXQPKTQ4_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4_IMP.
 *
 */
typedef union BCM53128_A0_TXQPKTQ4_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq4_imp[1];
	uint32_t _txqpktq4_imp;
} BCM53128_A0_TXQPKTQ4_IMPr_t;

#define BCM53128_A0_TXQPKTQ4_IMPr_CLR(r) (r).txqpktq4_imp[0] = 0
#define BCM53128_A0_TXQPKTQ4_IMPr_SET(r,d) (r).txqpktq4_imp[0] = d
#define BCM53128_A0_TXQPKTQ4_IMPr_GET(r) (r).txqpktq4_imp[0]


/*
 * These macros can be used to access TxQPKTQ4_IMP.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ4_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQPKTQ4_IMPr,(r._txqpktq4_imp),4)
#define BCM53128_A0_WRITE_TXQPKTQ4_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQPKTQ4_IMPr,&(r._txqpktq4_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4_IMPr BCM53128_A0_TXQPKTQ4_IMPr
#define TXQPKTQ4_IMPr_SIZE BCM53128_A0_TXQPKTQ4_IMPr_SIZE
typedef BCM53128_A0_TXQPKTQ4_IMPr_t TXQPKTQ4_IMPr_t;
#define TXQPKTQ4_IMPr_CLR BCM53128_A0_TXQPKTQ4_IMPr_CLR
#define TXQPKTQ4_IMPr_SET BCM53128_A0_TXQPKTQ4_IMPr_SET
#define TXQPKTQ4_IMPr_GET BCM53128_A0_TXQPKTQ4_IMPr_GET
#define READ_TXQPKTQ4_IMPr BCM53128_A0_READ_TXQPKTQ4_IMPr
#define WRITE_TXQPKTQ4_IMPr BCM53128_A0_WRITE_TXQPKTQ4_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ4_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ5
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ5r 0x0000204c

#define BCM53128_A0_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5.
 *
 */
typedef union BCM53128_A0_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t txqpktq5[1];
	uint32_t _txqpktq5;
} BCM53128_A0_TXQPKTQ5r_t;

#define BCM53128_A0_TXQPKTQ5r_CLR(r) (r).txqpktq5[0] = 0
#define BCM53128_A0_TXQPKTQ5r_SET(r,d) (r).txqpktq5[0] = d
#define BCM53128_A0_TXQPKTQ5r_GET(r) (r).txqpktq5[0]


/*
 * These macros can be used to access TxQPKTQ5.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXQPKTQ5r,(r._txqpktq5),4)
#define BCM53128_A0_WRITE_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXQPKTQ5r,&(r._txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5r BCM53128_A0_TXQPKTQ5r
#define TXQPKTQ5r_SIZE BCM53128_A0_TXQPKTQ5r_SIZE
typedef BCM53128_A0_TXQPKTQ5r_t TXQPKTQ5r_t;
#define TXQPKTQ5r_CLR BCM53128_A0_TXQPKTQ5r_CLR
#define TXQPKTQ5r_SET BCM53128_A0_TXQPKTQ5r_SET
#define TXQPKTQ5r_GET BCM53128_A0_TXQPKTQ5r_GET
#define READ_TXQPKTQ5r BCM53128_A0_READ_TXQPKTQ5r
#define WRITE_TXQPKTQ5r BCM53128_A0_WRITE_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxQPKTQ5_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXQPKTQ5_IMPr 0x0000284c

#define BCM53128_A0_TXQPKTQ5_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5_IMP.
 *
 */
typedef union BCM53128_A0_TXQPKTQ5_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq5_imp[1];
	uint32_t _txqpktq5_imp;
} BCM53128_A0_TXQPKTQ5_IMPr_t;

#define BCM53128_A0_TXQPKTQ5_IMPr_CLR(r) (r).txqpktq5_imp[0] = 0
#define BCM53128_A0_TXQPKTQ5_IMPr_SET(r,d) (r).txqpktq5_imp[0] = d
#define BCM53128_A0_TXQPKTQ5_IMPr_GET(r) (r).txqpktq5_imp[0]


/*
 * These macros can be used to access TxQPKTQ5_IMP.
 *
 */
#define BCM53128_A0_READ_TXQPKTQ5_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXQPKTQ5_IMPr,(r._txqpktq5_imp),4)
#define BCM53128_A0_WRITE_TXQPKTQ5_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXQPKTQ5_IMPr,&(r._txqpktq5_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5_IMPr BCM53128_A0_TXQPKTQ5_IMPr
#define TXQPKTQ5_IMPr_SIZE BCM53128_A0_TXQPKTQ5_IMPr_SIZE
typedef BCM53128_A0_TXQPKTQ5_IMPr_t TXQPKTQ5_IMPr_t;
#define TXQPKTQ5_IMPr_CLR BCM53128_A0_TXQPKTQ5_IMPr_CLR
#define TXQPKTQ5_IMPr_SET BCM53128_A0_TXQPKTQ5_IMPr_SET
#define TXQPKTQ5_IMPr_GET BCM53128_A0_TXQPKTQ5_IMPr_GET
#define READ_TXQPKTQ5_IMPr BCM53128_A0_READ_TXQPKTQ5_IMPr
#define WRITE_TXQPKTQ5_IMPr BCM53128_A0_WRITE_TXQPKTQ5_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXQPKTQ5_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxSingleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXSINGLECOLLISIONr 0x00002020

#define BCM53128_A0_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision.
 *
 */
typedef union BCM53128_A0_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txsinglecollision[1];
	uint32_t _txsinglecollision;
} BCM53128_A0_TXSINGLECOLLISIONr_t;

#define BCM53128_A0_TXSINGLECOLLISIONr_CLR(r) (r).txsinglecollision[0] = 0
#define BCM53128_A0_TXSINGLECOLLISIONr_SET(r,d) (r).txsinglecollision[0] = d
#define BCM53128_A0_TXSINGLECOLLISIONr_GET(r) (r).txsinglecollision[0]


/*
 * These macros can be used to access TxSingleCollision.
 *
 */
#define BCM53128_A0_READ_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXSINGLECOLLISIONr,(r._txsinglecollision),4)
#define BCM53128_A0_WRITE_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXSINGLECOLLISIONr,&(r._txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONr BCM53128_A0_TXSINGLECOLLISIONr
#define TXSINGLECOLLISIONr_SIZE BCM53128_A0_TXSINGLECOLLISIONr_SIZE
typedef BCM53128_A0_TXSINGLECOLLISIONr_t TXSINGLECOLLISIONr_t;
#define TXSINGLECOLLISIONr_CLR BCM53128_A0_TXSINGLECOLLISIONr_CLR
#define TXSINGLECOLLISIONr_SET BCM53128_A0_TXSINGLECOLLISIONr_SET
#define TXSINGLECOLLISIONr_GET BCM53128_A0_TXSINGLECOLLISIONr_GET
#define READ_TXSINGLECOLLISIONr BCM53128_A0_READ_TXSINGLECOLLISIONr
#define WRITE_TXSINGLECOLLISIONr BCM53128_A0_WRITE_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxSingleCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXSINGLECOLLISION_IMPr 0x00002820

#define BCM53128_A0_TXSINGLECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision_IMP.
 *
 */
typedef union BCM53128_A0_TXSINGLECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txsinglecollision_imp[1];
	uint32_t _txsinglecollision_imp;
} BCM53128_A0_TXSINGLECOLLISION_IMPr_t;

#define BCM53128_A0_TXSINGLECOLLISION_IMPr_CLR(r) (r).txsinglecollision_imp[0] = 0
#define BCM53128_A0_TXSINGLECOLLISION_IMPr_SET(r,d) (r).txsinglecollision_imp[0] = d
#define BCM53128_A0_TXSINGLECOLLISION_IMPr_GET(r) (r).txsinglecollision_imp[0]


/*
 * These macros can be used to access TxSingleCollision_IMP.
 *
 */
#define BCM53128_A0_READ_TXSINGLECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXSINGLECOLLISION_IMPr,(r._txsinglecollision_imp),4)
#define BCM53128_A0_WRITE_TXSINGLECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXSINGLECOLLISION_IMPr,&(r._txsinglecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISION_IMPr BCM53128_A0_TXSINGLECOLLISION_IMPr
#define TXSINGLECOLLISION_IMPr_SIZE BCM53128_A0_TXSINGLECOLLISION_IMPr_SIZE
typedef BCM53128_A0_TXSINGLECOLLISION_IMPr_t TXSINGLECOLLISION_IMPr_t;
#define TXSINGLECOLLISION_IMPr_CLR BCM53128_A0_TXSINGLECOLLISION_IMPr_CLR
#define TXSINGLECOLLISION_IMPr_SET BCM53128_A0_TXSINGLECOLLISION_IMPr_SET
#define TXSINGLECOLLISION_IMPr_GET BCM53128_A0_TXSINGLECOLLISION_IMPr_GET
#define READ_TXSINGLECOLLISION_IMPr BCM53128_A0_READ_TXSINGLECOLLISION_IMPr
#define WRITE_TXSINGLECOLLISION_IMPr BCM53128_A0_WRITE_TXSINGLECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXSINGLECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXUNICASTPKTSr 0x00002018

#define BCM53128_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 *
 */
typedef union BCM53128_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM53128_A0_TXUNICASTPKTSr_t;

#define BCM53128_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM53128_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM53128_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 *
 */
#define BCM53128_A0_READ_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53128_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM53128_A0_WRITE_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53128_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM53128_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM53128_A0_TXUNICASTPKTSr_SIZE
typedef BCM53128_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM53128_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM53128_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM53128_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM53128_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM53128_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  TxUnicastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53128_A0_TXUNICASTPKTS_IMPr 0x00002818

#define BCM53128_A0_TXUNICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts_IMP.
 *
 */
typedef union BCM53128_A0_TXUNICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txunicastpkts_imp[1];
	uint32_t _txunicastpkts_imp;
} BCM53128_A0_TXUNICASTPKTS_IMPr_t;

#define BCM53128_A0_TXUNICASTPKTS_IMPr_CLR(r) (r).txunicastpkts_imp[0] = 0
#define BCM53128_A0_TXUNICASTPKTS_IMPr_SET(r,d) (r).txunicastpkts_imp[0] = d
#define BCM53128_A0_TXUNICASTPKTS_IMPr_GET(r) (r).txunicastpkts_imp[0]


/*
 * These macros can be used to access TxUnicastPkts_IMP.
 *
 */
#define BCM53128_A0_READ_TXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_TXUNICASTPKTS_IMPr,(r._txunicastpkts_imp),4)
#define BCM53128_A0_WRITE_TXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_TXUNICASTPKTS_IMPr,&(r._txunicastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTS_IMPr BCM53128_A0_TXUNICASTPKTS_IMPr
#define TXUNICASTPKTS_IMPr_SIZE BCM53128_A0_TXUNICASTPKTS_IMPr_SIZE
typedef BCM53128_A0_TXUNICASTPKTS_IMPr_t TXUNICASTPKTS_IMPr_t;
#define TXUNICASTPKTS_IMPr_CLR BCM53128_A0_TXUNICASTPKTS_IMPr_CLR
#define TXUNICASTPKTS_IMPr_SET BCM53128_A0_TXUNICASTPKTS_IMPr_SET
#define TXUNICASTPKTS_IMPr_GET BCM53128_A0_TXUNICASTPKTS_IMPr_GET
#define READ_TXUNICASTPKTS_IMPr BCM53128_A0_READ_TXUNICASTPKTS_IMPr
#define WRITE_TXUNICASTPKTS_IMPr BCM53128_A0_WRITE_TXUNICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_TXUNICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  ULF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Unicast Lookup Failed Forward Map Register
 * SIZE:     16
 * FIELDS:
 *     UNI_LOOPUP_FAIL_FWD_MAP Unicast Lookup Failed Forward Map.When unicast lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_ULF_DROP_MAPr 0x00000032

#define BCM53128_A0_ULF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program ULF_DROP_MAP.
 *
 */
typedef union BCM53128_A0_ULF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t ulf_drop_map[1];
	uint32_t _ulf_drop_map;
} BCM53128_A0_ULF_DROP_MAPr_t;

#define BCM53128_A0_ULF_DROP_MAPr_CLR(r) (r).ulf_drop_map[0] = 0
#define BCM53128_A0_ULF_DROP_MAPr_SET(r,d) (r).ulf_drop_map[0] = d
#define BCM53128_A0_ULF_DROP_MAPr_GET(r) (r).ulf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET(r) (((r).ulf_drop_map[0]) & 0x1ff)
#define BCM53128_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_ULF_DROP_MAPr_RESERVEDf_GET(r) ((((r).ulf_drop_map[0]) >> 9) & 0x7f)
#define BCM53128_A0_ULF_DROP_MAPr_RESERVEDf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ULF_DROP_MAP.
 *
 */
#define BCM53128_A0_READ_ULF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53128_A0_ULF_DROP_MAPr,(r._ulf_drop_map),2)
#define BCM53128_A0_WRITE_ULF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53128_A0_ULF_DROP_MAPr,&(r._ulf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ULF_DROP_MAPr BCM53128_A0_ULF_DROP_MAPr
#define ULF_DROP_MAPr_SIZE BCM53128_A0_ULF_DROP_MAPr_SIZE
typedef BCM53128_A0_ULF_DROP_MAPr_t ULF_DROP_MAPr_t;
#define ULF_DROP_MAPr_CLR BCM53128_A0_ULF_DROP_MAPr_CLR
#define ULF_DROP_MAPr_SET BCM53128_A0_ULF_DROP_MAPr_SET
#define ULF_DROP_MAPr_GET BCM53128_A0_ULF_DROP_MAPr_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET BCM53128_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET BCM53128_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET
#define ULF_DROP_MAPr_RESERVEDf_GET BCM53128_A0_ULF_DROP_MAPr_RESERVEDf_GET
#define ULF_DROP_MAPr_RESERVEDf_SET BCM53128_A0_ULF_DROP_MAPr_RESERVEDf_SET
#define READ_ULF_DROP_MAPr BCM53128_A0_READ_ULF_DROP_MAPr
#define WRITE_ULF_DROP_MAPr BCM53128_A0_WRITE_ULF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_ULF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     32
 * FIELDS:
 *     FORWARD_MAP      Untag port bitmapBits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     UNTAG_MAP        Untag port bitmapBits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     MSPT_ID          MSTP ID
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_1Qm 0x20000580

#define BCM53128_A0_VLAN_1Qm_MIN 0
#define BCM53128_A0_VLAN_1Qm_MAX 4095
#define BCM53128_A0_VLAN_1Qm_CMAX(u) 4095
#define BCM53128_A0_VLAN_1Qm_SIZE 4

/*
 * This structure should be used to declare and program VLAN_1Q.
 *
 */
typedef union BCM53128_A0_VLAN_1Qm_s {
	uint32_t v[1];
	uint32_t vlan_1q[1];
	uint32_t _vlan_1q;
} BCM53128_A0_VLAN_1Qm_t;

#define BCM53128_A0_VLAN_1Qm_CLR(r) (r).vlan_1q[0] = 0
#define BCM53128_A0_VLAN_1Qm_SET(r,d) (r).vlan_1q[0] = d
#define BCM53128_A0_VLAN_1Qm_GET(r) (r).vlan_1q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) (((r).vlan_1q[0]) & 0x1ff)
#define BCM53128_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_VLAN_1Qm_UNTAG_MAPf_GET(r) ((((r).vlan_1q[0]) >> 9) & 0x1ff)
#define BCM53128_A0_VLAN_1Qm_UNTAG_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53128_A0_VLAN_1Qm_MSPT_IDf_GET(r) ((((r).vlan_1q[0]) >> 18) & 0x7)
#define BCM53128_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53128_A0_VLAN_1Qm_FWD_MODEf_GET(r) ((((r).vlan_1q[0]) >> 21) & 0x1)
#define BCM53128_A0_VLAN_1Qm_FWD_MODEf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53128_A0_VLAN_1Qm_RESERVEDf_GET(r) ((((r).vlan_1q[0]) >> 22) & 0x3ff)
#define BCM53128_A0_VLAN_1Qm_RESERVEDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access VLAN_1Q.
 *
 */
#define BCM53128_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM53128_A0_VLAN_1Qm,i,(m),4)
#define BCM53128_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM53128_A0_VLAN_1Qm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM53128_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM53128_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM53128_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_CMAX(u) BCM53128_A0_VLAN_1Qm_CMAX(u)
#define VLAN_1Qm_SIZE BCM53128_A0_VLAN_1Qm_SIZE
typedef BCM53128_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM53128_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM53128_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM53128_A0_VLAN_1Qm_GET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM53128_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM53128_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_UNTAG_MAPf_GET BCM53128_A0_VLAN_1Qm_UNTAG_MAPf_GET
#define VLAN_1Qm_UNTAG_MAPf_SET BCM53128_A0_VLAN_1Qm_UNTAG_MAPf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM53128_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM53128_A0_VLAN_1Qm_MSPT_IDf_SET
#define VLAN_1Qm_FWD_MODEf_GET BCM53128_A0_VLAN_1Qm_FWD_MODEf_GET
#define VLAN_1Qm_FWD_MODEf_SET BCM53128_A0_VLAN_1Qm_FWD_MODEf_SET
#define VLAN_1Qm_RESERVEDf_GET BCM53128_A0_VLAN_1Qm_RESERVEDf_GET
#define VLAN_1Qm_RESERVEDf_SET BCM53128_A0_VLAN_1Qm_RESERVEDf_SET
#define READ_VLAN_1Qm BCM53128_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM53128_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_1Qm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL0
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 0 Registers
 * SIZE:     8
 * FIELDS:
 *     CHANGE_1P_VID_INNER Change Inner 1P VID to PVIDThis bit controls whether to replace Ingress Inner 1P VID.(ingress VID=12'h000) to PVIDFor exampleWhen this bit is zero:(Falcon DT mode compatible)Do not change the Inner tag VIDwhen this bit is one:For a double tag frame with the inner tag VID==0, chnage the innr tag VID to PVID.
 *     CHANGE_1P_VID_OUTER Change Outer 1P VID to PVIDThis bit controls whether to replace Ingress Outer 1P VID.(ingress VID=12'h000) to PVIDFor exampleWhen this bit is zero:Do not change the Outer tag VIDwhen this bit is one:a.For a single tag frame with VID==0, change the VID to PVIDb.For a double tag frame with VID==0, chnage the outer tag VID to PVID.
 *     RESERVED_0       Reserved.
 *     CHANGE_1Q_VID    Change 1Q VID to PVIDThis bit controls whether to replace 1Q VID to PVID.(This bit can't to set in iDT_mode)For exampleWhen this bit is zero:No change for 1Q/ISP tag if VID/=0when this bit is one:a.For a single tag frame with VID==0, change the VID to PVIDb.For a double tag frame with VID==0, chnage the outer tag VID to PVID.
 *     RESERVED_1       Reserved.
 *     VLAN_LEARN_MODE  00: SVL( Shared VLAN Learning Mode)(MAC used to hash ARL table).11:IVL(Individual VLAN Learning Mode) (MAC and VID used to hash ARL table).10= illegal Setting.01= illegal Setting.This rule applies to 1Q enable mode, and dt_mode.
 *     VLAN_EN          When set to 1, the 802.1Q VLAN function will be enabled.This bit must be set if double tagging(dt_mode) is enable.
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL0r 0x00003400

#define BCM53128_A0_VLAN_CTRL0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL0.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL0r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl0[1];
	uint32_t _vlan_ctrl0;
} BCM53128_A0_VLAN_CTRL0r_t;

#define BCM53128_A0_VLAN_CTRL0r_CLR(r) (r).vlan_ctrl0[0] = 0
#define BCM53128_A0_VLAN_CTRL0r_SET(r,d) (r).vlan_ctrl0[0] = d
#define BCM53128_A0_VLAN_CTRL0r_GET(r) (r).vlan_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET(r) (((r).vlan_ctrl0[0]) & 0x1)
#define BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET(r) ((((r).vlan_ctrl0[0]) >> 1) & 0x1)
#define BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_VLAN_CTRL0r_RESERVED_0f_GET(r) ((((r).vlan_ctrl0[0]) >> 2) & 0x1)
#define BCM53128_A0_VLAN_CTRL0r_RESERVED_0f_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET(r) ((((r).vlan_ctrl0[0]) >> 3) & 0x1)
#define BCM53128_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_VLAN_CTRL0r_RESERVED_1f_GET(r) ((((r).vlan_ctrl0[0]) >> 4) & 0x1)
#define BCM53128_A0_VLAN_CTRL0r_RESERVED_1f_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET(r) ((((r).vlan_ctrl0[0]) >> 5) & 0x3)
#define BCM53128_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53128_A0_VLAN_CTRL0r_VLAN_ENf_GET(r) ((((r).vlan_ctrl0[0]) >> 7) & 0x1)
#define BCM53128_A0_VLAN_CTRL0r_VLAN_ENf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL0.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL0r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL0r,(r._vlan_ctrl0),1)
#define BCM53128_A0_WRITE_VLAN_CTRL0r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL0r,&(r._vlan_ctrl0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL0r BCM53128_A0_VLAN_CTRL0r
#define VLAN_CTRL0r_SIZE BCM53128_A0_VLAN_CTRL0r_SIZE
typedef BCM53128_A0_VLAN_CTRL0r_t VLAN_CTRL0r_t;
#define VLAN_CTRL0r_CLR BCM53128_A0_VLAN_CTRL0r_CLR
#define VLAN_CTRL0r_SET BCM53128_A0_VLAN_CTRL0r_SET
#define VLAN_CTRL0r_GET BCM53128_A0_VLAN_CTRL0r_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET BCM53128_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET
#define VLAN_CTRL0r_RESERVED_0f_GET BCM53128_A0_VLAN_CTRL0r_RESERVED_0f_GET
#define VLAN_CTRL0r_RESERVED_0f_SET BCM53128_A0_VLAN_CTRL0r_RESERVED_0f_SET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_GET BCM53128_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_SET BCM53128_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET
#define VLAN_CTRL0r_RESERVED_1f_GET BCM53128_A0_VLAN_CTRL0r_RESERVED_1f_GET
#define VLAN_CTRL0r_RESERVED_1f_SET BCM53128_A0_VLAN_CTRL0r_RESERVED_1f_SET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_GET BCM53128_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_SET BCM53128_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET
#define VLAN_CTRL0r_VLAN_ENf_GET BCM53128_A0_VLAN_CTRL0r_VLAN_ENf_GET
#define VLAN_CTRL0r_VLAN_ENf_SET BCM53128_A0_VLAN_CTRL0r_VLAN_ENf_SET
#define READ_VLAN_CTRL0r BCM53128_A0_READ_VLAN_CTRL0r
#define WRITE_VLAN_CTRL0r BCM53128_A0_WRITE_VLAN_CTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL1
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 1 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     RESERVED_1       Reserved.It's illegal to set 0.
 *     EN_RSV_MCAST_FWDMAP When asserted, reserved multicast frames (except GMRP and GVRP) will be checked by v_fwdmap.**This rule applies to 1Q enable, and dt_mode.
 *     EN_RSV_MCAST_UNTAG When asserted, reserved multicast frames tag/untag will be controlled by v_untagmap.When deasserted, reserved multicast frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage.**Reserved multicast frames except GMRP amd GVRP.
 *     RESERVED_2       Reserved.It's illegal to set 1.
 *     EN_IPMC_BYPASS_FWDMAP When asserted will not check IPMC frame with V_fwdmap.This rule applies to 1Q enable, and dt_mode.
 *     EN_IPMC_BYPASS_UNTAG When deasserted, the IPMC frames tag/untag will be controlled by V_untagmap.When asserted, The IPMC frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage.
 *     RESERVED_3       Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL1r 0x00003401

#define BCM53128_A0_VLAN_CTRL1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL1.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL1r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl1[1];
	uint32_t _vlan_ctrl1;
} BCM53128_A0_VLAN_CTRL1r_t;

#define BCM53128_A0_VLAN_CTRL1r_CLR(r) (r).vlan_ctrl1[0] = 0
#define BCM53128_A0_VLAN_CTRL1r_SET(r,d) (r).vlan_ctrl1[0] = d
#define BCM53128_A0_VLAN_CTRL1r_GET(r) (r).vlan_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_0f_GET(r) (((r).vlan_ctrl1[0]) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_0f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_1f_GET(r) ((((r).vlan_ctrl1[0]) >> 1) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_1f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 2) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 3) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_2f_GET(r) ((((r).vlan_ctrl1[0]) >> 4) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_2f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 5) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 6) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_3f_GET(r) ((((r).vlan_ctrl1[0]) >> 7) & 0x1)
#define BCM53128_A0_VLAN_CTRL1r_RESERVED_3f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL1.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL1r,(r._vlan_ctrl1),1)
#define BCM53128_A0_WRITE_VLAN_CTRL1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL1r,&(r._vlan_ctrl1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL1r BCM53128_A0_VLAN_CTRL1r
#define VLAN_CTRL1r_SIZE BCM53128_A0_VLAN_CTRL1r_SIZE
typedef BCM53128_A0_VLAN_CTRL1r_t VLAN_CTRL1r_t;
#define VLAN_CTRL1r_CLR BCM53128_A0_VLAN_CTRL1r_CLR
#define VLAN_CTRL1r_SET BCM53128_A0_VLAN_CTRL1r_SET
#define VLAN_CTRL1r_GET BCM53128_A0_VLAN_CTRL1r_GET
#define VLAN_CTRL1r_RESERVED_0f_GET BCM53128_A0_VLAN_CTRL1r_RESERVED_0f_GET
#define VLAN_CTRL1r_RESERVED_0f_SET BCM53128_A0_VLAN_CTRL1r_RESERVED_0f_SET
#define VLAN_CTRL1r_RESERVED_1f_GET BCM53128_A0_VLAN_CTRL1r_RESERVED_1f_GET
#define VLAN_CTRL1r_RESERVED_1f_SET BCM53128_A0_VLAN_CTRL1r_RESERVED_1f_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET BCM53128_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_2f_GET BCM53128_A0_VLAN_CTRL1r_RESERVED_2f_GET
#define VLAN_CTRL1r_RESERVED_2f_SET BCM53128_A0_VLAN_CTRL1r_RESERVED_2f_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET BCM53128_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_3f_GET BCM53128_A0_VLAN_CTRL1r_RESERVED_3f_GET
#define VLAN_CTRL1r_RESERVED_3f_SET BCM53128_A0_VLAN_CTRL1r_RESERVED_3f_SET
#define READ_VLAN_CTRL1r BCM53128_A0_READ_VLAN_CTRL1r
#define WRITE_VLAN_CTRL1r BCM53128_A0_WRITE_VLAN_CTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL2
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 2 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     EN_MIIM_BYPASS_V_FWDMAP When set to 1, frames reveived by MII_manage port will bypass V_fwdmap checking.**This rule applies to 1Q enable, and dt_mode.
 *     RESERVED_2       Reserved.
 *     EN_GMRP_GVRP_V_FWDMAP When set to 1, GMRP,GVRP will be checked by v_fwdmap.** this rule do not apply to MII_manage EXP and SPI ports.
 *     EN_GMRP_GVRP_UNTAG_MAP When asserted, GMRP/GVRP frames tag/untag will be controlled by v_untagmap.When deasserted,GMRP/GVRP  frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage.
 *     RESERVED         
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL2r 0x00003402

#define BCM53128_A0_VLAN_CTRL2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL2.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL2r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl2[1];
	uint32_t _vlan_ctrl2;
} BCM53128_A0_VLAN_CTRL2r_t;

#define BCM53128_A0_VLAN_CTRL2r_CLR(r) (r).vlan_ctrl2[0] = 0
#define BCM53128_A0_VLAN_CTRL2r_SET(r,d) (r).vlan_ctrl2[0] = d
#define BCM53128_A0_VLAN_CTRL2r_GET(r) (r).vlan_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL2r_RESERVED_0f_GET(r) (((r).vlan_ctrl2[0]) & 0x3)
#define BCM53128_A0_VLAN_CTRL2r_RESERVED_0f_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53128_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 2) & 0x1)
#define BCM53128_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_VLAN_CTRL2r_RESERVED_2f_GET(r) ((((r).vlan_ctrl2[0]) >> 3) & 0x3)
#define BCM53128_A0_VLAN_CTRL2r_RESERVED_2f_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 5) & 0x1)
#define BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 6) & 0x1)
#define BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_VLAN_CTRL2r_RESERVEDf_GET(r) ((((r).vlan_ctrl2[0]) >> 7) & 0x1)
#define BCM53128_A0_VLAN_CTRL2r_RESERVEDf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL2.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL2r,(r._vlan_ctrl2),1)
#define BCM53128_A0_WRITE_VLAN_CTRL2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL2r,&(r._vlan_ctrl2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL2r BCM53128_A0_VLAN_CTRL2r
#define VLAN_CTRL2r_SIZE BCM53128_A0_VLAN_CTRL2r_SIZE
typedef BCM53128_A0_VLAN_CTRL2r_t VLAN_CTRL2r_t;
#define VLAN_CTRL2r_CLR BCM53128_A0_VLAN_CTRL2r_CLR
#define VLAN_CTRL2r_SET BCM53128_A0_VLAN_CTRL2r_SET
#define VLAN_CTRL2r_GET BCM53128_A0_VLAN_CTRL2r_GET
#define VLAN_CTRL2r_RESERVED_0f_GET BCM53128_A0_VLAN_CTRL2r_RESERVED_0f_GET
#define VLAN_CTRL2r_RESERVED_0f_SET BCM53128_A0_VLAN_CTRL2r_RESERVED_0f_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET BCM53128_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET BCM53128_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET
#define VLAN_CTRL2r_RESERVED_2f_GET BCM53128_A0_VLAN_CTRL2r_RESERVED_2f_GET
#define VLAN_CTRL2r_RESERVED_2f_SET BCM53128_A0_VLAN_CTRL2r_RESERVED_2f_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET BCM53128_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET
#define VLAN_CTRL2r_RESERVEDf_GET BCM53128_A0_VLAN_CTRL2r_RESERVEDf_GET
#define VLAN_CTRL2r_RESERVEDf_SET BCM53128_A0_VLAN_CTRL2r_RESERVEDf_SET
#define READ_VLAN_CTRL2r BCM53128_A0_READ_VLAN_CTRL2r
#define WRITE_VLAN_CTRL2r BCM53128_A0_WRITE_VLAN_CTRL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL3
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 3 Registers
 * SIZE:     16
 * FIELDS:
 *     EN_DROP_NON1Q    When enabled , any non_1Q frame will be dropped by this port. Ports 8-0 respectively. This field makes no effect under the double tagging modes. This field is ignored by IMP port(s), the IMP port(s) won't drop non 1Q frames even this field is set.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL3r 0x00003403

#define BCM53128_A0_VLAN_CTRL3r_SIZE 2

/*
 * This structure should be used to declare and program VLAN_CTRL3.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL3r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl3[1];
	uint32_t _vlan_ctrl3;
} BCM53128_A0_VLAN_CTRL3r_t;

#define BCM53128_A0_VLAN_CTRL3r_CLR(r) (r).vlan_ctrl3[0] = 0
#define BCM53128_A0_VLAN_CTRL3r_SET(r,d) (r).vlan_ctrl3[0] = d
#define BCM53128_A0_VLAN_CTRL3r_GET(r) (r).vlan_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET(r) (((r).vlan_ctrl3[0]) & 0x1ff)
#define BCM53128_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_VLAN_CTRL3r_RESERVEDf_GET(r) ((((r).vlan_ctrl3[0]) >> 9) & 0x7f)
#define BCM53128_A0_VLAN_CTRL3r_RESERVEDf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_CTRL3.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL3r,(r._vlan_ctrl3),2)
#define BCM53128_A0_WRITE_VLAN_CTRL3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL3r,&(r._vlan_ctrl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL3r BCM53128_A0_VLAN_CTRL3r
#define VLAN_CTRL3r_SIZE BCM53128_A0_VLAN_CTRL3r_SIZE
typedef BCM53128_A0_VLAN_CTRL3r_t VLAN_CTRL3r_t;
#define VLAN_CTRL3r_CLR BCM53128_A0_VLAN_CTRL3r_CLR
#define VLAN_CTRL3r_SET BCM53128_A0_VLAN_CTRL3r_SET
#define VLAN_CTRL3r_GET BCM53128_A0_VLAN_CTRL3r_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_GET BCM53128_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_SET BCM53128_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET
#define VLAN_CTRL3r_RESERVEDf_GET BCM53128_A0_VLAN_CTRL3r_RESERVEDf_GET
#define VLAN_CTRL3r_RESERVEDf_SET BCM53128_A0_VLAN_CTRL3r_RESERVEDf_SET
#define READ_VLAN_CTRL3r BCM53128_A0_READ_VLAN_CTRL3r
#define WRITE_VLAN_CTRL3r BCM53128_A0_WRITE_VLAN_CTRL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL4
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 4 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1       Reserved.
 *     RESV_MCAST_FLOOD When chip is programmed as double tag mode(dt_mode) and management mode.1 : flood(include all data port and CPU) reserved mcast based on the VLAN rule.0 : trap reserved mcast to CPU.reserved multicast include 01-80-c2-00-00-(00,02-2f)
 *     EN_DOUBLE_TAG    Enable double taggging mode.0:Disable double tagging mode01:Enable dt_mode(Falcon double tagging mode)#10:Enable idt_mode(intelligent double tagging mode in Vulcan)#when idt_mode is enable, egress VID remarking is achieved by CFP classification ID.others:Reserved
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame. In multiple chip system, a GMRP frmae received by a chip without CPU will pass it to expansion port, and eventually it will be forward to CPU.
 *     EN_MGE_REV_GVRP  When set to 1. management port ( the port with CPU) will be the destination port of GVRP frame.
 *     INGR_VID_CHK     00: forward ingress VID violation frame( VID is not in v_fwdmap). But do not learn in ARL table.01: Drop frame if frame has VID violation, not Learned.10: Do not check ingress VID violation.(Forward and Learn as no violation case)11:Forward ingress VIO violation frame to IMP, but not learn(default)**This field is ignored by IMP port(s), the IMP port(s) won't check ingress VID violation frames.
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL4r 0x00003405

#define BCM53128_A0_VLAN_CTRL4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL4.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL4r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl4[1];
	uint32_t _vlan_ctrl4;
} BCM53128_A0_VLAN_CTRL4r_t;

#define BCM53128_A0_VLAN_CTRL4r_CLR(r) (r).vlan_ctrl4[0] = 0
#define BCM53128_A0_VLAN_CTRL4r_SET(r,d) (r).vlan_ctrl4[0] = d
#define BCM53128_A0_VLAN_CTRL4r_GET(r) (r).vlan_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL4r_RESERVED_1f_GET(r) (((r).vlan_ctrl4[0]) & 0x1)
#define BCM53128_A0_VLAN_CTRL4r_RESERVED_1f_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET(r) ((((r).vlan_ctrl4[0]) >> 1) & 0x1)
#define BCM53128_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET(r) ((((r).vlan_ctrl4[0]) >> 2) & 0x3)
#define BCM53128_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 4) & 0x1)
#define BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 5) & 0x1)
#define BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET(r) ((((r).vlan_ctrl4[0]) >> 6) & 0x3)
#define BCM53128_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_CTRL4.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL4r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL4r,(r._vlan_ctrl4),1)
#define BCM53128_A0_WRITE_VLAN_CTRL4r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL4r,&(r._vlan_ctrl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL4r BCM53128_A0_VLAN_CTRL4r
#define VLAN_CTRL4r_SIZE BCM53128_A0_VLAN_CTRL4r_SIZE
typedef BCM53128_A0_VLAN_CTRL4r_t VLAN_CTRL4r_t;
#define VLAN_CTRL4r_CLR BCM53128_A0_VLAN_CTRL4r_CLR
#define VLAN_CTRL4r_SET BCM53128_A0_VLAN_CTRL4r_SET
#define VLAN_CTRL4r_GET BCM53128_A0_VLAN_CTRL4r_GET
#define VLAN_CTRL4r_RESERVED_1f_GET BCM53128_A0_VLAN_CTRL4r_RESERVED_1f_GET
#define VLAN_CTRL4r_RESERVED_1f_SET BCM53128_A0_VLAN_CTRL4r_RESERVED_1f_SET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_GET BCM53128_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_SET BCM53128_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_GET BCM53128_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_SET BCM53128_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET BCM53128_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET
#define VLAN_CTRL4r_INGR_VID_CHKf_GET BCM53128_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET
#define VLAN_CTRL4r_INGR_VID_CHKf_SET BCM53128_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET
#define READ_VLAN_CTRL4r BCM53128_A0_READ_VLAN_CTRL4r
#define WRITE_VLAN_CTRL4r BCM53128_A0_WRITE_VLAN_CTRL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL5
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 5 Registers
 * SIZE:     8
 * FIELDS:
 *     EN_CPU_RX_BYP_INNER_CRCCHK 1:The management port(IMP) will ignore CRC check.0:The management port(IMP) with CPU on it will check the CRC.
 *     RESERVED         Reserved
 *     EN_VID_FFF_FWD   0 : comply with standard, drop frame.1: forwaed frame.
 *     DROP_VTABLE_MISS When set to 1, a frame with V_table miss will be dropped.When set to 0, a frame with V_table miss will be fowarded to IMP.
 *     EGRESS_DIR_FRM_BYPASS_TRUNK_EN Egress Directed Frame Bypass Trunking Re-direction EnableSet to 1 : Egress Directed Frame From Management Port will bypass Re-Trunking Re-directed RuleSet to 0: Egress Directed Frame will From Management Port will follow Trunking Re-directed Rule.
 *     RESERVED_0       Reserved
 *     PRESV_NON1Q      - en_preserv_non_1q_frame: (default 0)When set to 1, regardless of untag map in VLAN table, non-1Q frames(including 802.1p frames) will not be changed at TX. This field makes no effect under the double tagged modes(dt_mode).
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL5r 0x00003406

#define BCM53128_A0_VLAN_CTRL5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL5.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL5r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl5[1];
	uint32_t _vlan_ctrl5;
} BCM53128_A0_VLAN_CTRL5r_t;

#define BCM53128_A0_VLAN_CTRL5r_CLR(r) (r).vlan_ctrl5[0] = 0
#define BCM53128_A0_VLAN_CTRL5r_SET(r,d) (r).vlan_ctrl5[0] = d
#define BCM53128_A0_VLAN_CTRL5r_GET(r) (r).vlan_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET(r) (((r).vlan_ctrl5[0]) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_VLAN_CTRL5r_RESERVEDf_GET(r) ((((r).vlan_ctrl5[0]) >> 1) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_RESERVEDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET(r) ((((r).vlan_ctrl5[0]) >> 2) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET(r) ((((r).vlan_ctrl5[0]) >> 3) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET(r) ((((r).vlan_ctrl5[0]) >> 4) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_VLAN_CTRL5r_RESERVED_0f_GET(r) ((((r).vlan_ctrl5[0]) >> 5) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_RESERVED_0f_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET(r) ((((r).vlan_ctrl5[0]) >> 6) & 0x1)
#define BCM53128_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access VLAN_CTRL5.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL5r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL5r,(r._vlan_ctrl5),1)
#define BCM53128_A0_WRITE_VLAN_CTRL5r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL5r,&(r._vlan_ctrl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL5r BCM53128_A0_VLAN_CTRL5r
#define VLAN_CTRL5r_SIZE BCM53128_A0_VLAN_CTRL5r_SIZE
typedef BCM53128_A0_VLAN_CTRL5r_t VLAN_CTRL5r_t;
#define VLAN_CTRL5r_CLR BCM53128_A0_VLAN_CTRL5r_CLR
#define VLAN_CTRL5r_SET BCM53128_A0_VLAN_CTRL5r_SET
#define VLAN_CTRL5r_GET BCM53128_A0_VLAN_CTRL5r_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET BCM53128_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET BCM53128_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET
#define VLAN_CTRL5r_RESERVEDf_GET BCM53128_A0_VLAN_CTRL5r_RESERVEDf_GET
#define VLAN_CTRL5r_RESERVEDf_SET BCM53128_A0_VLAN_CTRL5r_RESERVEDf_SET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_GET BCM53128_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_SET BCM53128_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_GET BCM53128_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_SET BCM53128_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET BCM53128_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET BCM53128_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET
#define VLAN_CTRL5r_RESERVED_0f_GET BCM53128_A0_VLAN_CTRL5r_RESERVED_0f_GET
#define VLAN_CTRL5r_RESERVED_0f_SET BCM53128_A0_VLAN_CTRL5r_RESERVED_0f_SET
#define VLAN_CTRL5r_PRESV_NON1Qf_GET BCM53128_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET
#define VLAN_CTRL5r_PRESV_NON1Qf_SET BCM53128_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET
#define READ_VLAN_CTRL5r BCM53128_A0_READ_VLAN_CTRL5r
#define WRITE_VLAN_CTRL5r BCM53128_A0_WRITE_VLAN_CTRL5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_CTRL6
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 6 Registers
 * SIZE:     8
 * FIELDS:
 *     STRICT_SFD_DETECT use_strict_sfd_detectWhen enabled, Blackbird2 drops frames with no preamble and start with SFD regardless of the phase rx clk at which nibble data of SFD is received.When disabled (dfault), Blackbird2 drops such frames only at certain phase of the nibble data of SFD.NOTE: This register turns on a bug fix, so should be hidden in the customer datasheet. We decided to turn it off by default for safety purpose.(Not2Release)
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_CTRL6r 0x00003407

#define BCM53128_A0_VLAN_CTRL6r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL6.
 *
 */
typedef union BCM53128_A0_VLAN_CTRL6r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl6[1];
	uint32_t _vlan_ctrl6;
} BCM53128_A0_VLAN_CTRL6r_t;

#define BCM53128_A0_VLAN_CTRL6r_CLR(r) (r).vlan_ctrl6[0] = 0
#define BCM53128_A0_VLAN_CTRL6r_SET(r,d) (r).vlan_ctrl6[0] = d
#define BCM53128_A0_VLAN_CTRL6r_GET(r) (r).vlan_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET(r) (((r).vlan_ctrl6[0]) & 0x1)
#define BCM53128_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_VLAN_CTRL6r_RESERVEDf_GET(r) ((((r).vlan_ctrl6[0]) >> 1) & 0x7f)
#define BCM53128_A0_VLAN_CTRL6r_RESERVEDf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access VLAN_CTRL6.
 *
 */
#define BCM53128_A0_READ_VLAN_CTRL6r(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_CTRL6r,(r._vlan_ctrl6),1)
#define BCM53128_A0_WRITE_VLAN_CTRL6r(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_CTRL6r,&(r._vlan_ctrl6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL6r BCM53128_A0_VLAN_CTRL6r
#define VLAN_CTRL6r_SIZE BCM53128_A0_VLAN_CTRL6r_SIZE
typedef BCM53128_A0_VLAN_CTRL6r_t VLAN_CTRL6r_t;
#define VLAN_CTRL6r_CLR BCM53128_A0_VLAN_CTRL6r_CLR
#define VLAN_CTRL6r_SET BCM53128_A0_VLAN_CTRL6r_SET
#define VLAN_CTRL6r_GET BCM53128_A0_VLAN_CTRL6r_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_GET BCM53128_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_SET BCM53128_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET
#define VLAN_CTRL6r_RESERVEDf_GET BCM53128_A0_VLAN_CTRL6r_RESERVEDf_GET
#define VLAN_CTRL6r_RESERVEDf_SET BCM53128_A0_VLAN_CTRL6r_RESERVEDf_SET
#define READ_VLAN_CTRL6r BCM53128_A0_READ_VLAN_CTRL6r
#define WRITE_VLAN_CTRL6r BCM53128_A0_WRITE_VLAN_CTRL6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  VLAN_MULTI_PORT_ADDR_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN Multiport Address Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_V_FWD_MAP When set to 1, MPORT_ADD0 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT0_UTG_MAP When set to 1, MPORT_ADD0 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT1_V_FWD_MAP When set to 1, MPORT_ADD1 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT1_UTG_MAP When set to 1, MPORT_ADD1 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT2_V_FWD_MAP When set to 1, MPORT_ADD2 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT2_UTG_MAP When set to 1, MPORT_ADD2 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT3_V_FWD_MAP When set to 1, MPORT_ADD3 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT3_UTG_MAP When set to 1, MPORT_ADD3 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT4_V_FWD_MAP When set to 1, MPORT_ADD4 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT4_UTG_MAP When set to 1, MPORT_ADD4 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT5_V_FWD_MAP When set to 1, MPORT_ADD5 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT5_UTG_MAP When set to 1, MPORT_ADD5 will be checked by v_untagmap** this rule do not apply to MII_manage.** When set to 0, MPORT_ADDx frames will be preserved tagged type of frames as follows,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frames on ingress -> tagges frames on egress.3.1p frame on ingress -> 1Q frame on egress.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr 0x0000340a

#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE 2

/*
 * This structure should be used to declare and program VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
typedef union BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_s {
	uint32_t v[1];
	uint32_t vlan_multi_port_addr_ctl[1];
	uint32_t _vlan_multi_port_addr_ctl;
} BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_t;

#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR(r) (r).vlan_multi_port_addr_ctl[0] = 0
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET(r,d) (r).vlan_multi_port_addr_ctl[0] = d
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET(r) (r).vlan_multi_port_addr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET(r) (((r).vlan_multi_port_addr_ctl[0]) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 1) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 2) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 3) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 4) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 5) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 6) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 7) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 8) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 9) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 10) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 11) & 0x1)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 12) & 0xf)
#define BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
#define BCM53128_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr,(r._vlan_multi_port_addr_ctl),2)
#define BCM53128_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr,&(r._vlan_multi_port_addr_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MULTI_PORT_ADDR_CTLr BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr
#define VLAN_MULTI_PORT_ADDR_CTLr_SIZE BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE
typedef BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_t VLAN_MULTI_PORT_ADDR_CTLr_t;
#define VLAN_MULTI_PORT_ADDR_CTLr_CLR BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR
#define VLAN_MULTI_PORT_ADDR_CTLr_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET
#define READ_VLAN_MULTI_PORT_ADDR_CTLr BCM53128_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr
#define WRITE_VLAN_MULTI_PORT_ADDR_CTLr BCM53128_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_VLAN_MULTI_PORT_ADDR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  WAN_PORT_SEL
 * BLOCKS:   SYS
 * DESC:     WAN Port select Register
 * SIZE:     16
 * FIELDS:
 *     WAN_SELECT       WAN Ports SelectionThis field selects the WAN ports. When set to '1', the corresponding port is the WAN port.
 *     RESERVED_0       Reserved
 *     EN_MAN2WAN       0: mgmt-port only uses egress direct frame to WAN-port.1: mgmt-port could send non-egress direct frame to WAN-port.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_WAN_PORT_SELr 0x00000026

#define BCM53128_A0_WAN_PORT_SELr_SIZE 2

/*
 * This structure should be used to declare and program WAN_PORT_SEL.
 *
 */
typedef union BCM53128_A0_WAN_PORT_SELr_s {
	uint32_t v[1];
	uint32_t wan_port_sel[1];
	uint32_t _wan_port_sel;
} BCM53128_A0_WAN_PORT_SELr_t;

#define BCM53128_A0_WAN_PORT_SELr_CLR(r) (r).wan_port_sel[0] = 0
#define BCM53128_A0_WAN_PORT_SELr_SET(r,d) (r).wan_port_sel[0] = d
#define BCM53128_A0_WAN_PORT_SELr_GET(r) (r).wan_port_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_WAN_PORT_SELr_WAN_SELECTf_GET(r) (((r).wan_port_sel[0]) & 0xff)
#define BCM53128_A0_WAN_PORT_SELr_WAN_SELECTf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53128_A0_WAN_PORT_SELr_RESERVED_0f_GET(r) ((((r).wan_port_sel[0]) >> 8) & 0x1)
#define BCM53128_A0_WAN_PORT_SELr_RESERVED_0f_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53128_A0_WAN_PORT_SELr_EN_MAN2WANf_GET(r) ((((r).wan_port_sel[0]) >> 9) & 0x1)
#define BCM53128_A0_WAN_PORT_SELr_EN_MAN2WANf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53128_A0_WAN_PORT_SELr_RESERVED_1f_GET(r) ((((r).wan_port_sel[0]) >> 10) & 0x3f)
#define BCM53128_A0_WAN_PORT_SELr_RESERVED_1f_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access WAN_PORT_SEL.
 *
 */
#define BCM53128_A0_READ_WAN_PORT_SELr(u,r) cdk_robo_reg_read(u,BCM53128_A0_WAN_PORT_SELr,(r._wan_port_sel),2)
#define BCM53128_A0_WRITE_WAN_PORT_SELr(u,r) cdk_robo_reg_write(u,BCM53128_A0_WAN_PORT_SELr,&(r._wan_port_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_PORT_SELr BCM53128_A0_WAN_PORT_SELr
#define WAN_PORT_SELr_SIZE BCM53128_A0_WAN_PORT_SELr_SIZE
typedef BCM53128_A0_WAN_PORT_SELr_t WAN_PORT_SELr_t;
#define WAN_PORT_SELr_CLR BCM53128_A0_WAN_PORT_SELr_CLR
#define WAN_PORT_SELr_SET BCM53128_A0_WAN_PORT_SELr_SET
#define WAN_PORT_SELr_GET BCM53128_A0_WAN_PORT_SELr_GET
#define WAN_PORT_SELr_WAN_SELECTf_GET BCM53128_A0_WAN_PORT_SELr_WAN_SELECTf_GET
#define WAN_PORT_SELr_WAN_SELECTf_SET BCM53128_A0_WAN_PORT_SELr_WAN_SELECTf_SET
#define WAN_PORT_SELr_RESERVED_0f_GET BCM53128_A0_WAN_PORT_SELr_RESERVED_0f_GET
#define WAN_PORT_SELr_RESERVED_0f_SET BCM53128_A0_WAN_PORT_SELr_RESERVED_0f_SET
#define WAN_PORT_SELr_EN_MAN2WANf_GET BCM53128_A0_WAN_PORT_SELr_EN_MAN2WANf_GET
#define WAN_PORT_SELr_EN_MAN2WANf_SET BCM53128_A0_WAN_PORT_SELr_EN_MAN2WANf_SET
#define WAN_PORT_SELr_RESERVED_1f_GET BCM53128_A0_WAN_PORT_SELr_RESERVED_1f_GET
#define WAN_PORT_SELr_RESERVED_1f_SET BCM53128_A0_WAN_PORT_SELr_RESERVED_1f_SET
#define READ_WAN_PORT_SELr BCM53128_A0_READ_WAN_PORT_SELr
#define WRITE_WAN_PORT_SELr BCM53128_A0_WRITE_WAN_PORT_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_WAN_PORT_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  WAN_SLEEP_TIMER
 * BLOCKS:   SYS
 * DESC:     Port7 Sleep Timer Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     WAN_SLEEP_TIMER  Port7 Sleep Timer.The configuration value of port 7 sleep timer to indicate the desired sleep recovery time(i.e. wake-up time). When the timer is set by the CPU to a non-zero value. it puts the corresponding port7 to sleep. The wake-up time is the set value decrease 1.The unit is 1 usec
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_WAN_SLEEP_TIMERr 0x00000314

#define BCM53128_A0_WAN_SLEEP_TIMERr_SIZE 2

/*
 * This structure should be used to declare and program WAN_SLEEP_TIMER.
 *
 */
typedef union BCM53128_A0_WAN_SLEEP_TIMERr_s {
	uint32_t v[1];
	uint32_t wan_sleep_timer[1];
	uint32_t _wan_sleep_timer;
} BCM53128_A0_WAN_SLEEP_TIMERr_t;

#define BCM53128_A0_WAN_SLEEP_TIMERr_CLR(r) (r).wan_sleep_timer[0] = 0
#define BCM53128_A0_WAN_SLEEP_TIMERr_SET(r,d) (r).wan_sleep_timer[0] = d
#define BCM53128_A0_WAN_SLEEP_TIMERr_GET(r) (r).wan_sleep_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_GET(r) (((r).wan_sleep_timer[0]) & 0x1fff)
#define BCM53128_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_SET(r,f) (r).wan_sleep_timer[0]=(((r).wan_sleep_timer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53128_A0_WAN_SLEEP_TIMERr_RESERVEDf_GET(r) ((((r).wan_sleep_timer[0]) >> 13) & 0x7)
#define BCM53128_A0_WAN_SLEEP_TIMERr_RESERVEDf_SET(r,f) (r).wan_sleep_timer[0]=(((r).wan_sleep_timer[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access WAN_SLEEP_TIMER.
 *
 */
#define BCM53128_A0_READ_WAN_SLEEP_TIMERr(u,r) cdk_robo_reg_read(u,BCM53128_A0_WAN_SLEEP_TIMERr,(r._wan_sleep_timer),2)
#define BCM53128_A0_WRITE_WAN_SLEEP_TIMERr(u,r) cdk_robo_reg_write(u,BCM53128_A0_WAN_SLEEP_TIMERr,&(r._wan_sleep_timer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_SLEEP_TIMERr BCM53128_A0_WAN_SLEEP_TIMERr
#define WAN_SLEEP_TIMERr_SIZE BCM53128_A0_WAN_SLEEP_TIMERr_SIZE
typedef BCM53128_A0_WAN_SLEEP_TIMERr_t WAN_SLEEP_TIMERr_t;
#define WAN_SLEEP_TIMERr_CLR BCM53128_A0_WAN_SLEEP_TIMERr_CLR
#define WAN_SLEEP_TIMERr_SET BCM53128_A0_WAN_SLEEP_TIMERr_SET
#define WAN_SLEEP_TIMERr_GET BCM53128_A0_WAN_SLEEP_TIMERr_GET
#define WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_GET BCM53128_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_GET
#define WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_SET BCM53128_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_SET
#define WAN_SLEEP_TIMERr_RESERVEDf_GET BCM53128_A0_WAN_SLEEP_TIMERr_RESERVEDf_GET
#define WAN_SLEEP_TIMERr_RESERVEDf_SET BCM53128_A0_WAN_SLEEP_TIMERr_RESERVEDf_SET
#define READ_WAN_SLEEP_TIMERr BCM53128_A0_READ_WAN_SLEEP_TIMERr
#define WRITE_WAN_SLEEP_TIMERr BCM53128_A0_WRITE_WAN_SLEEP_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_WAN_SLEEP_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  WATCH_DOG_CTRL
 * BLOCKS:   SYS
 * DESC:     Watch Dog Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_RST_SWITCH    Enable Reset Switch CodeDefault value by strap pin auto_reset_en.(Not2Release)
 *     EN_RST_REGFILE   Enable Reset RegisterDefault value by strap pin auto_reset_en.(Not2Release)
 *     EN_RELOAD_EEPROM Enable Reload EEPROM after software ResetDefault value by strap pin auto_reset_en.(Not2Release)
 *     EN_AUTO_RST      Enable watch dog Auto-Reset(in dumb system)Default value by strap pin auto_reset_en.(Not2Release)
 *     EN_SW_RESET      Enable Global Software Reset.
 *     RESERVED         Reserved
 *     SOFTWARE_RESET   Global Software Reset. (EN_SW_RST must be enabled as wellSet 1'b1 to trigger reset process.*** Reset Process except Strap value and PLL.Write software_reset bit 1, then write 0 to clear the reset state.
 *
 ******************************************************************************/
#define BCM53128_A0_WATCH_DOG_CTRLr 0x00000079

#define BCM53128_A0_WATCH_DOG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program WATCH_DOG_CTRL.
 *
 */
typedef union BCM53128_A0_WATCH_DOG_CTRLr_s {
	uint32_t v[1];
	uint32_t watch_dog_ctrl[1];
	uint32_t _watch_dog_ctrl;
} BCM53128_A0_WATCH_DOG_CTRLr_t;

#define BCM53128_A0_WATCH_DOG_CTRLr_CLR(r) (r).watch_dog_ctrl[0] = 0
#define BCM53128_A0_WATCH_DOG_CTRLr_SET(r,d) (r).watch_dog_ctrl[0] = d
#define BCM53128_A0_WATCH_DOG_CTRLr_GET(r) (r).watch_dog_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_GET(r) (((r).watch_dog_ctrl[0]) & 0x1)
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET(r) ((((r).watch_dog_ctrl[0]) >> 1) & 0x1)
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET(r) ((((r).watch_dog_ctrl[0]) >> 2) & 0x1)
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_GET(r) ((((r).watch_dog_ctrl[0]) >> 3) & 0x1)
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 4) & 0x1)
#define BCM53128_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53128_A0_WATCH_DOG_CTRLr_RESERVEDf_GET(r) ((((r).watch_dog_ctrl[0]) >> 5) & 0x3)
#define BCM53128_A0_WATCH_DOG_CTRLr_RESERVEDf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53128_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 7) & 0x1)
#define BCM53128_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access WATCH_DOG_CTRL.
 *
 */
#define BCM53128_A0_READ_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53128_A0_WATCH_DOG_CTRLr,(r._watch_dog_ctrl),1)
#define BCM53128_A0_WRITE_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53128_A0_WATCH_DOG_CTRLr,&(r._watch_dog_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_CTRLr BCM53128_A0_WATCH_DOG_CTRLr
#define WATCH_DOG_CTRLr_SIZE BCM53128_A0_WATCH_DOG_CTRLr_SIZE
typedef BCM53128_A0_WATCH_DOG_CTRLr_t WATCH_DOG_CTRLr_t;
#define WATCH_DOG_CTRLr_CLR BCM53128_A0_WATCH_DOG_CTRLr_CLR
#define WATCH_DOG_CTRLr_SET BCM53128_A0_WATCH_DOG_CTRLr_SET
#define WATCH_DOG_CTRLr_GET BCM53128_A0_WATCH_DOG_CTRLr_GET
#define WATCH_DOG_CTRLr_EN_RST_SWITCHf_GET BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_GET
#define WATCH_DOG_CTRLr_EN_RST_SWITCHf_SET BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_SET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET BCM53128_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET BCM53128_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET BCM53128_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET
#define WATCH_DOG_CTRLr_EN_AUTO_RSTf_GET BCM53128_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_GET
#define WATCH_DOG_CTRLr_EN_AUTO_RSTf_SET BCM53128_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_SET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_GET BCM53128_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_SET BCM53128_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET
#define WATCH_DOG_CTRLr_RESERVEDf_GET BCM53128_A0_WATCH_DOG_CTRLr_RESERVEDf_GET
#define WATCH_DOG_CTRLr_RESERVEDf_SET BCM53128_A0_WATCH_DOG_CTRLr_RESERVEDf_SET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET BCM53128_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET BCM53128_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET
#define READ_WATCH_DOG_CTRLr BCM53128_A0_READ_WATCH_DOG_CTRLr
#define WRITE_WATCH_DOG_CTRLr BCM53128_A0_WRITE_WATCH_DOG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_WATCH_DOG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  WATCH_DOG_RPT1
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 1 Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TX_PORT_HUNG_INDICATOR Tx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_WATCH_DOG_RPT1r 0x0000007a

#define BCM53128_A0_WATCH_DOG_RPT1r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT1.
 *
 */
typedef union BCM53128_A0_WATCH_DOG_RPT1r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt1[1];
	uint32_t _watch_dog_rpt1;
} BCM53128_A0_WATCH_DOG_RPT1r_t;

#define BCM53128_A0_WATCH_DOG_RPT1r_CLR(r) (r).watch_dog_rpt1[0] = 0
#define BCM53128_A0_WATCH_DOG_RPT1r_SET(r,d) (r).watch_dog_rpt1[0] = d
#define BCM53128_A0_WATCH_DOG_RPT1r_GET(r) (r).watch_dog_rpt1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt1[0]) & 0x1ff)
#define BCM53128_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_WATCH_DOG_RPT1r_RESERVEDf_GET(r) ((((r).watch_dog_rpt1[0]) >> 9) & 0x7f)
#define BCM53128_A0_WATCH_DOG_RPT1r_RESERVEDf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT1.
 *
 */
#define BCM53128_A0_READ_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_read(u,BCM53128_A0_WATCH_DOG_RPT1r,(r._watch_dog_rpt1),2)
#define BCM53128_A0_WRITE_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_write(u,BCM53128_A0_WATCH_DOG_RPT1r,&(r._watch_dog_rpt1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT1r BCM53128_A0_WATCH_DOG_RPT1r
#define WATCH_DOG_RPT1r_SIZE BCM53128_A0_WATCH_DOG_RPT1r_SIZE
typedef BCM53128_A0_WATCH_DOG_RPT1r_t WATCH_DOG_RPT1r_t;
#define WATCH_DOG_RPT1r_CLR BCM53128_A0_WATCH_DOG_RPT1r_CLR
#define WATCH_DOG_RPT1r_SET BCM53128_A0_WATCH_DOG_RPT1r_SET
#define WATCH_DOG_RPT1r_GET BCM53128_A0_WATCH_DOG_RPT1r_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET BCM53128_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET BCM53128_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT1r_RESERVEDf_GET BCM53128_A0_WATCH_DOG_RPT1r_RESERVEDf_GET
#define WATCH_DOG_RPT1r_RESERVEDf_SET BCM53128_A0_WATCH_DOG_RPT1r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT1r BCM53128_A0_READ_WATCH_DOG_RPT1r
#define WRITE_WATCH_DOG_RPT1r BCM53128_A0_WRITE_WATCH_DOG_RPT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_WATCH_DOG_RPT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  WATCH_DOG_RPT2
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 2 Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     RX_PORT_HUNG_INDICATOR Rx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_WATCH_DOG_RPT2r 0x0000007c

#define BCM53128_A0_WATCH_DOG_RPT2r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT2.
 *
 */
typedef union BCM53128_A0_WATCH_DOG_RPT2r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt2[1];
	uint32_t _watch_dog_rpt2;
} BCM53128_A0_WATCH_DOG_RPT2r_t;

#define BCM53128_A0_WATCH_DOG_RPT2r_CLR(r) (r).watch_dog_rpt2[0] = 0
#define BCM53128_A0_WATCH_DOG_RPT2r_SET(r,d) (r).watch_dog_rpt2[0] = d
#define BCM53128_A0_WATCH_DOG_RPT2r_GET(r) (r).watch_dog_rpt2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt2[0]) & 0x1ff)
#define BCM53128_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_WATCH_DOG_RPT2r_RESERVEDf_GET(r) ((((r).watch_dog_rpt2[0]) >> 9) & 0x7f)
#define BCM53128_A0_WATCH_DOG_RPT2r_RESERVEDf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT2.
 *
 */
#define BCM53128_A0_READ_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_read(u,BCM53128_A0_WATCH_DOG_RPT2r,(r._watch_dog_rpt2),2)
#define BCM53128_A0_WRITE_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_write(u,BCM53128_A0_WATCH_DOG_RPT2r,&(r._watch_dog_rpt2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT2r BCM53128_A0_WATCH_DOG_RPT2r
#define WATCH_DOG_RPT2r_SIZE BCM53128_A0_WATCH_DOG_RPT2r_SIZE
typedef BCM53128_A0_WATCH_DOG_RPT2r_t WATCH_DOG_RPT2r_t;
#define WATCH_DOG_RPT2r_CLR BCM53128_A0_WATCH_DOG_RPT2r_CLR
#define WATCH_DOG_RPT2r_SET BCM53128_A0_WATCH_DOG_RPT2r_SET
#define WATCH_DOG_RPT2r_GET BCM53128_A0_WATCH_DOG_RPT2r_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET BCM53128_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET BCM53128_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT2r_RESERVEDf_GET BCM53128_A0_WATCH_DOG_RPT2r_RESERVEDf_GET
#define WATCH_DOG_RPT2r_RESERVEDf_SET BCM53128_A0_WATCH_DOG_RPT2r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT2r BCM53128_A0_READ_WATCH_DOG_RPT2r
#define WRITE_WATCH_DOG_RPT2r BCM53128_A0_WRITE_WATCH_DOG_RPT2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_WATCH_DOG_RPT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53128_A0
 * REGISTER:  WATCH_DOG_RPT3
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 3 Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     ARL_HUNG_INDICATOR ARL Indicator.Bit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53128_A0_WATCH_DOG_RPT3r 0x0000007e

#define BCM53128_A0_WATCH_DOG_RPT3r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT3.
 *
 */
typedef union BCM53128_A0_WATCH_DOG_RPT3r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt3[1];
	uint32_t _watch_dog_rpt3;
} BCM53128_A0_WATCH_DOG_RPT3r_t;

#define BCM53128_A0_WATCH_DOG_RPT3r_CLR(r) (r).watch_dog_rpt3[0] = 0
#define BCM53128_A0_WATCH_DOG_RPT3r_SET(r,d) (r).watch_dog_rpt3[0] = d
#define BCM53128_A0_WATCH_DOG_RPT3r_GET(r) (r).watch_dog_rpt3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53128_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt3[0]) & 0x1ff)
#define BCM53128_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53128_A0_WATCH_DOG_RPT3r_RESERVEDf_GET(r) ((((r).watch_dog_rpt3[0]) >> 9) & 0x7f)
#define BCM53128_A0_WATCH_DOG_RPT3r_RESERVEDf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT3.
 *
 */
#define BCM53128_A0_READ_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_read(u,BCM53128_A0_WATCH_DOG_RPT3r,(r._watch_dog_rpt3),2)
#define BCM53128_A0_WRITE_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_write(u,BCM53128_A0_WATCH_DOG_RPT3r,&(r._watch_dog_rpt3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT3r BCM53128_A0_WATCH_DOG_RPT3r
#define WATCH_DOG_RPT3r_SIZE BCM53128_A0_WATCH_DOG_RPT3r_SIZE
typedef BCM53128_A0_WATCH_DOG_RPT3r_t WATCH_DOG_RPT3r_t;
#define WATCH_DOG_RPT3r_CLR BCM53128_A0_WATCH_DOG_RPT3r_CLR
#define WATCH_DOG_RPT3r_SET BCM53128_A0_WATCH_DOG_RPT3r_SET
#define WATCH_DOG_RPT3r_GET BCM53128_A0_WATCH_DOG_RPT3r_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET BCM53128_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET BCM53128_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT3r_RESERVEDf_GET BCM53128_A0_WATCH_DOG_RPT3r_RESERVEDf_GET
#define WATCH_DOG_RPT3r_RESERVEDf_SET BCM53128_A0_WATCH_DOG_RPT3r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT3r BCM53128_A0_READ_WATCH_DOG_RPT3r
#define WRITE_WATCH_DOG_RPT3r BCM53128_A0_WRITE_WATCH_DOG_RPT3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53128_A0_WATCH_DOG_RPT3r'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM53128_A0_DEFS_H__ */
