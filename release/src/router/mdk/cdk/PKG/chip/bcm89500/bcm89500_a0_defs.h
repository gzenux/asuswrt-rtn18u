#ifndef __BCM89500_A0_DEFS_H__
#define __BCM89500_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM89500_A0.
 * This file provides all basic definitions required to program the BCM89500_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CPIC/IMP port */
#define BCM89500_A0_CPIC_PORT           8

/* Additional block types */
#define BCM89500_A0_BLKTYPE_CPIC        0
#define BCM89500_A0_BLKTYPE_EXP         1
#define BCM89500_A0_BLKTYPE_GPIC        2
#define BCM89500_A0_BLKTYPE_SPI         3
#define BCM89500_A0_BLKTYPE_SYS         4


/* Dynamic configuration flags */
#define BCM89500_A0_DCFG_P4IEEE         0x80000000

#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM89500_A0_CPIC_PORT

#define BLKTYPE_CPIC                    BCM89500_A0_BLKTYPE_CPIC
#define BLKTYPE_EXP                     BCM89500_A0_BLKTYPE_EXP
#define BLKTYPE_GPIC                    BCM89500_A0_BLKTYPE_GPIC
#define BLKTYPE_SPI                     BCM89500_A0_BLKTYPE_SPI
#define BLKTYPE_SYS                     BCM89500_A0_BLKTYPE_SYS

#define DCFG_P4IEEE                     BCM89500_A0_DCFG_P4IEEE


#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ACT_POL_DATA0
 * BLOCKS:   SYS
 * DESC:     CFP Action/Policy Data 0 Registers
 * SIZE:     32
 * FIELDS:
 *     VLAN_BYP         It indicates whether the CFP generated forwarding decision is subject to the VLAN based filting.
 *     EAP_BYP          It indicates whether the CFP generated forwarding decision is subject to the 802.1x EAP port state based filting.
 *     STP_BYP          It indicates whether the CFP generated forwarding decision is subject to the STP port state based filting.
 *     REASON_CODE      It indicates the reasons why the packet is forwarded to CPU, when the corresponding Change_FWD action indicates packet forwarding to CPU.
 *     LOOP_BK_EN       It indicates whether the packet is allowed to be forwarded to the port it is originally received from.
 *     NEW_TC           It indicates whether the packet is allowed to be forwarded to the port it is originally received from.
 *     CHANGE_TC        It indicates whether to enforce new traffic class for the matched packet to be queue with the corresponding COS at its egress Ethernet port(s)(excluding IMP port) before being transmitted.(To be used together with TC2COS mapping at each egress port)
 *     DST_MAP_IB       It indicates the port(s) to which the packet is forwarded or removed (polar feature).Bits [23:22]: reserved,Bit [21]: port 8(IMP),Bit [20]: port 7 (polar feature),Bits [19:14]: port 5 - port 0.
 *     CHANGE_FWRD_MAP_IB It indicates whether to enforce new egress direction for the matched packet.00: No destination changes to the ARL derived destination.01: Removing ARL destiontions(port list) according to the DST_Map setting (polar feature).10: Replacing ARL derived destinations with the DST_Map derived dest.11: Adding the DST_Map derived destinations to the ARL derived destinations.
 *     NEW_DSCP_IB      New_DSCP value.(In IPv4 header, this field is called TOS field, and the IP checksum field needs to be updated accordingly. In IPv6 header, this field is called TrafficClass field, and there is no IP checksum to be updated)
 *
 ******************************************************************************/
#define BCM89500_A0_ACT_POL_DATA0r 0x0000a050

#define BCM89500_A0_ACT_POL_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program ACT_POL_DATA0.
 *
 */
typedef union BCM89500_A0_ACT_POL_DATA0r_s {
	uint32_t v[1];
	uint32_t act_pol_data0[1];
	uint32_t _act_pol_data0;
} BCM89500_A0_ACT_POL_DATA0r_t;

#define BCM89500_A0_ACT_POL_DATA0r_CLR(r) (r).act_pol_data0[0] = 0
#define BCM89500_A0_ACT_POL_DATA0r_SET(r,d) (r).act_pol_data0[0] = d
#define BCM89500_A0_ACT_POL_DATA0r_GET(r) (r).act_pol_data0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ACT_POL_DATA0r_VLAN_BYPf_GET(r) (((r).act_pol_data0[0]) & 0x1)
#define BCM89500_A0_ACT_POL_DATA0r_VLAN_BYPf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_ACT_POL_DATA0r_EAP_BYPf_GET(r) ((((r).act_pol_data0[0]) >> 1) & 0x1)
#define BCM89500_A0_ACT_POL_DATA0r_EAP_BYPf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_ACT_POL_DATA0r_STP_BYPf_GET(r) ((((r).act_pol_data0[0]) >> 2) & 0x1)
#define BCM89500_A0_ACT_POL_DATA0r_STP_BYPf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_ACT_POL_DATA0r_REASON_CODEf_GET(r) ((((r).act_pol_data0[0]) >> 3) & 0x3f)
#define BCM89500_A0_ACT_POL_DATA0r_REASON_CODEf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM89500_A0_ACT_POL_DATA0r_LOOP_BK_ENf_GET(r) ((((r).act_pol_data0[0]) >> 9) & 0x1)
#define BCM89500_A0_ACT_POL_DATA0r_LOOP_BK_ENf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_ACT_POL_DATA0r_NEW_TCf_GET(r) ((((r).act_pol_data0[0]) >> 10) & 0x7)
#define BCM89500_A0_ACT_POL_DATA0r_NEW_TCf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_ACT_POL_DATA0r_CHANGE_TCf_GET(r) ((((r).act_pol_data0[0]) >> 13) & 0x1)
#define BCM89500_A0_ACT_POL_DATA0r_CHANGE_TCf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_ACT_POL_DATA0r_DST_MAP_IBf_GET(r) ((((r).act_pol_data0[0]) >> 14) & 0x3ff)
#define BCM89500_A0_ACT_POL_DATA0r_DST_MAP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM89500_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_GET(r) ((((r).act_pol_data0[0]) >> 24) & 0x3)
#define BCM89500_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_GET(r) ((((r).act_pol_data0[0]) >> 26) & 0x3f)
#define BCM89500_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access ACT_POL_DATA0.
 *
 */
#define BCM89500_A0_READ_ACT_POL_DATA0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ACT_POL_DATA0r,(r._act_pol_data0),4)
#define BCM89500_A0_WRITE_ACT_POL_DATA0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ACT_POL_DATA0r,&(r._act_pol_data0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACT_POL_DATA0r BCM89500_A0_ACT_POL_DATA0r
#define ACT_POL_DATA0r_SIZE BCM89500_A0_ACT_POL_DATA0r_SIZE
typedef BCM89500_A0_ACT_POL_DATA0r_t ACT_POL_DATA0r_t;
#define ACT_POL_DATA0r_CLR BCM89500_A0_ACT_POL_DATA0r_CLR
#define ACT_POL_DATA0r_SET BCM89500_A0_ACT_POL_DATA0r_SET
#define ACT_POL_DATA0r_GET BCM89500_A0_ACT_POL_DATA0r_GET
#define ACT_POL_DATA0r_VLAN_BYPf_GET BCM89500_A0_ACT_POL_DATA0r_VLAN_BYPf_GET
#define ACT_POL_DATA0r_VLAN_BYPf_SET BCM89500_A0_ACT_POL_DATA0r_VLAN_BYPf_SET
#define ACT_POL_DATA0r_EAP_BYPf_GET BCM89500_A0_ACT_POL_DATA0r_EAP_BYPf_GET
#define ACT_POL_DATA0r_EAP_BYPf_SET BCM89500_A0_ACT_POL_DATA0r_EAP_BYPf_SET
#define ACT_POL_DATA0r_STP_BYPf_GET BCM89500_A0_ACT_POL_DATA0r_STP_BYPf_GET
#define ACT_POL_DATA0r_STP_BYPf_SET BCM89500_A0_ACT_POL_DATA0r_STP_BYPf_SET
#define ACT_POL_DATA0r_REASON_CODEf_GET BCM89500_A0_ACT_POL_DATA0r_REASON_CODEf_GET
#define ACT_POL_DATA0r_REASON_CODEf_SET BCM89500_A0_ACT_POL_DATA0r_REASON_CODEf_SET
#define ACT_POL_DATA0r_LOOP_BK_ENf_GET BCM89500_A0_ACT_POL_DATA0r_LOOP_BK_ENf_GET
#define ACT_POL_DATA0r_LOOP_BK_ENf_SET BCM89500_A0_ACT_POL_DATA0r_LOOP_BK_ENf_SET
#define ACT_POL_DATA0r_NEW_TCf_GET BCM89500_A0_ACT_POL_DATA0r_NEW_TCf_GET
#define ACT_POL_DATA0r_NEW_TCf_SET BCM89500_A0_ACT_POL_DATA0r_NEW_TCf_SET
#define ACT_POL_DATA0r_CHANGE_TCf_GET BCM89500_A0_ACT_POL_DATA0r_CHANGE_TCf_GET
#define ACT_POL_DATA0r_CHANGE_TCf_SET BCM89500_A0_ACT_POL_DATA0r_CHANGE_TCf_SET
#define ACT_POL_DATA0r_DST_MAP_IBf_GET BCM89500_A0_ACT_POL_DATA0r_DST_MAP_IBf_GET
#define ACT_POL_DATA0r_DST_MAP_IBf_SET BCM89500_A0_ACT_POL_DATA0r_DST_MAP_IBf_SET
#define ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_GET BCM89500_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_GET
#define ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_SET BCM89500_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_SET
#define ACT_POL_DATA0r_NEW_DSCP_IBf_GET BCM89500_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_GET
#define ACT_POL_DATA0r_NEW_DSCP_IBf_SET BCM89500_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_SET
#define READ_ACT_POL_DATA0r BCM89500_A0_READ_ACT_POL_DATA0r
#define WRITE_ACT_POL_DATA0r BCM89500_A0_WRITE_ACT_POL_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ACT_POL_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ACT_POL_DATA1
 * BLOCKS:   SYS
 * DESC:     CFP Action/Policy Data 1 Registers
 * SIZE:     32
 * FIELDS:
 *     CHANGE_DSCP_IB   packet based on the New_DSCP value.
 *     DST_MAP_OB       It indicates the port(s) to which the packet is forwarded or removed (polar feature).Bits [10:9]: reserved,Bit [8]: port 8(IMP),Bit [7]: port 7 (polar feature),Bits [6:1]: port 5 - port 0.
 *     CHANGE_FWRD_MAP_OB It indicates whether to enforce new egress direction for the matched packet.00: No destination changes to the ARL derived destination.01: Removing ARL destiontions(portmap) according to the DST_Map setting (polar feature).10: Replacing ARL derived destinations with the DST_Map derived dest.11: Adding the DST_Map derived destinations to the ARL derived destinations.
 *     NEW_DSCP_OB      New_DSCP value.(In IPv4 header, this field is called TOS field, and the IP checksum field needs to be updated accordingly. In IPv6 header, this field is called TrafficClass field, and there is no IP checksum to be updated)
 *     CHANGE_DSCP_OB   It indicates whether to modify the IP DSCP field of the matched packet based on the New_DSCP value.
 *     CHAIN_ID         If it is the result of Slice 0 chained search.it indicates the ChainID to be used as part of Chain slice key. 0x00 indicates no valid ChainID.Otherwise, it indicates the Classification ID if the packet needs to be forwarded to CPU. 0x00 indicates no valid Classification ID
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ACT_POL_DATA1r 0x0000a054

#define BCM89500_A0_ACT_POL_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program ACT_POL_DATA1.
 *
 */
typedef union BCM89500_A0_ACT_POL_DATA1r_s {
	uint32_t v[1];
	uint32_t act_pol_data1[1];
	uint32_t _act_pol_data1;
} BCM89500_A0_ACT_POL_DATA1r_t;

#define BCM89500_A0_ACT_POL_DATA1r_CLR(r) (r).act_pol_data1[0] = 0
#define BCM89500_A0_ACT_POL_DATA1r_SET(r,d) (r).act_pol_data1[0] = d
#define BCM89500_A0_ACT_POL_DATA1r_GET(r) (r).act_pol_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_IBf_GET(r) (((r).act_pol_data1[0]) & 0x1)
#define BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_IBf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_ACT_POL_DATA1r_DST_MAP_OBf_GET(r) ((((r).act_pol_data1[0]) >> 1) & 0x3ff)
#define BCM89500_A0_ACT_POL_DATA1r_DST_MAP_OBf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define BCM89500_A0_ACT_POL_DATA1r_CHANGE_FWRD_MAP_OBf_GET(r) ((((r).act_pol_data1[0]) >> 11) & 0x3)
#define BCM89500_A0_ACT_POL_DATA1r_CHANGE_FWRD_MAP_OBf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM89500_A0_ACT_POL_DATA1r_NEW_DSCP_OBf_GET(r) ((((r).act_pol_data1[0]) >> 13) & 0x3f)
#define BCM89500_A0_ACT_POL_DATA1r_NEW_DSCP_OBf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x3f << 13)) | ((((uint32_t)f) & 0x3f) << 13))
#define BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_OBf_GET(r) ((((r).act_pol_data1[0]) >> 19) & 0x1)
#define BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_OBf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_ACT_POL_DATA1r_CHAIN_IDf_GET(r) ((((r).act_pol_data1[0]) >> 20) & 0xff)
#define BCM89500_A0_ACT_POL_DATA1r_CHAIN_IDf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0xff << 20)) | ((((uint32_t)f) & 0xff) << 20))
#define BCM89500_A0_ACT_POL_DATA1r_RESERVEDf_GET(r) ((((r).act_pol_data1[0]) >> 28) & 0xf)
#define BCM89500_A0_ACT_POL_DATA1r_RESERVEDf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ACT_POL_DATA1.
 *
 */
#define BCM89500_A0_READ_ACT_POL_DATA1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ACT_POL_DATA1r,(r._act_pol_data1),4)
#define BCM89500_A0_WRITE_ACT_POL_DATA1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ACT_POL_DATA1r,&(r._act_pol_data1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACT_POL_DATA1r BCM89500_A0_ACT_POL_DATA1r
#define ACT_POL_DATA1r_SIZE BCM89500_A0_ACT_POL_DATA1r_SIZE
typedef BCM89500_A0_ACT_POL_DATA1r_t ACT_POL_DATA1r_t;
#define ACT_POL_DATA1r_CLR BCM89500_A0_ACT_POL_DATA1r_CLR
#define ACT_POL_DATA1r_SET BCM89500_A0_ACT_POL_DATA1r_SET
#define ACT_POL_DATA1r_GET BCM89500_A0_ACT_POL_DATA1r_GET
#define ACT_POL_DATA1r_CHANGE_DSCP_IBf_GET BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_IBf_GET
#define ACT_POL_DATA1r_CHANGE_DSCP_IBf_SET BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_IBf_SET
#define ACT_POL_DATA1r_DST_MAP_OBf_GET BCM89500_A0_ACT_POL_DATA1r_DST_MAP_OBf_GET
#define ACT_POL_DATA1r_DST_MAP_OBf_SET BCM89500_A0_ACT_POL_DATA1r_DST_MAP_OBf_SET
#define ACT_POL_DATA1r_CHANGE_FWRD_MAP_OBf_GET BCM89500_A0_ACT_POL_DATA1r_CHANGE_FWRD_MAP_OBf_GET
#define ACT_POL_DATA1r_CHANGE_FWRD_MAP_OBf_SET BCM89500_A0_ACT_POL_DATA1r_CHANGE_FWRD_MAP_OBf_SET
#define ACT_POL_DATA1r_NEW_DSCP_OBf_GET BCM89500_A0_ACT_POL_DATA1r_NEW_DSCP_OBf_GET
#define ACT_POL_DATA1r_NEW_DSCP_OBf_SET BCM89500_A0_ACT_POL_DATA1r_NEW_DSCP_OBf_SET
#define ACT_POL_DATA1r_CHANGE_DSCP_OBf_GET BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_OBf_GET
#define ACT_POL_DATA1r_CHANGE_DSCP_OBf_SET BCM89500_A0_ACT_POL_DATA1r_CHANGE_DSCP_OBf_SET
#define ACT_POL_DATA1r_CHAIN_IDf_GET BCM89500_A0_ACT_POL_DATA1r_CHAIN_IDf_GET
#define ACT_POL_DATA1r_CHAIN_IDf_SET BCM89500_A0_ACT_POL_DATA1r_CHAIN_IDf_SET
#define ACT_POL_DATA1r_RESERVEDf_GET BCM89500_A0_ACT_POL_DATA1r_RESERVEDf_GET
#define ACT_POL_DATA1r_RESERVEDf_SET BCM89500_A0_ACT_POL_DATA1r_RESERVEDf_SET
#define READ_ACT_POL_DATA1r BCM89500_A0_READ_ACT_POL_DATA1r
#define WRITE_ACT_POL_DATA1r BCM89500_A0_WRITE_ACT_POL_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ACT_POL_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_FWD_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR0 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_FWD_ENTRY0r 0x00000518

#define BCM89500_A0_ARLA_FWD_ENTRY0r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY0.
 *
 */
typedef union BCM89500_A0_ARLA_FWD_ENTRY0r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry0[1];
	uint32_t _arla_fwd_entry0;
} BCM89500_A0_ARLA_FWD_ENTRY0r_t;

#define BCM89500_A0_ARLA_FWD_ENTRY0r_CLR(r) (r).arla_fwd_entry0[0] = 0
#define BCM89500_A0_ARLA_FWD_ENTRY0r_SET(r,d) (r).arla_fwd_entry0[0] = d
#define BCM89500_A0_ARLA_FWD_ENTRY0r_GET(r) (r).arla_fwd_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_FWD_ENTRY0r_PORTIDf_GET(r) (((r).arla_fwd_entry0[0]) & 0x1ff)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_PORTIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET(r) ((((r).arla_fwd_entry0[0]) >> 9) & 0x3)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry0[0]) >> 11) & 0x7)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry0[0]) >> 14) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry0[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 16) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_ARLA_FWD_ENTRY0r_RESERVEDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 17) & 0x7fff)
#define BCM89500_A0_ARLA_FWD_ENTRY0r_RESERVEDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY0.
 *
 */
#define BCM89500_A0_READ_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_FWD_ENTRY0r,(r._arla_fwd_entry0),4)
#define BCM89500_A0_WRITE_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_FWD_ENTRY0r,&(r._arla_fwd_entry0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY0r BCM89500_A0_ARLA_FWD_ENTRY0r
#define ARLA_FWD_ENTRY0r_SIZE BCM89500_A0_ARLA_FWD_ENTRY0r_SIZE
typedef BCM89500_A0_ARLA_FWD_ENTRY0r_t ARLA_FWD_ENTRY0r_t;
#define ARLA_FWD_ENTRY0r_CLR BCM89500_A0_ARLA_FWD_ENTRY0r_CLR
#define ARLA_FWD_ENTRY0r_SET BCM89500_A0_ARLA_FWD_ENTRY0r_SET
#define ARLA_FWD_ENTRY0r_GET BCM89500_A0_ARLA_FWD_ENTRY0r_GET
#define ARLA_FWD_ENTRY0r_PORTIDf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_PORTIDf_GET
#define ARLA_FWD_ENTRY0r_PORTIDf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_PORTIDf_SET
#define ARLA_FWD_ENTRY0r_ARL_CONf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET
#define ARLA_FWD_ENTRY0r_ARL_CONf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY0r_RESERVEDf_GET BCM89500_A0_ARLA_FWD_ENTRY0r_RESERVEDf_GET
#define ARLA_FWD_ENTRY0r_RESERVEDf_SET BCM89500_A0_ARLA_FWD_ENTRY0r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY0r BCM89500_A0_READ_ARLA_FWD_ENTRY0r
#define WRITE_ARLA_FWD_ENTRY0r BCM89500_A0_WRITE_ARLA_FWD_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_FWD_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_FWD_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR1 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_FWD_ENTRY1r 0x00000528

#define BCM89500_A0_ARLA_FWD_ENTRY1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY1.
 *
 */
typedef union BCM89500_A0_ARLA_FWD_ENTRY1r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry1[1];
	uint32_t _arla_fwd_entry1;
} BCM89500_A0_ARLA_FWD_ENTRY1r_t;

#define BCM89500_A0_ARLA_FWD_ENTRY1r_CLR(r) (r).arla_fwd_entry1[0] = 0
#define BCM89500_A0_ARLA_FWD_ENTRY1r_SET(r,d) (r).arla_fwd_entry1[0] = d
#define BCM89500_A0_ARLA_FWD_ENTRY1r_GET(r) (r).arla_fwd_entry1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_FWD_ENTRY1r_PORTIDf_GET(r) (((r).arla_fwd_entry1[0]) & 0x1ff)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_PORTIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET(r) ((((r).arla_fwd_entry1[0]) >> 9) & 0x3)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry1[0]) >> 11) & 0x7)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry1[0]) >> 14) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry1[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 16) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_ARLA_FWD_ENTRY1r_RESERVEDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 17) & 0x7fff)
#define BCM89500_A0_ARLA_FWD_ENTRY1r_RESERVEDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY1.
 *
 */
#define BCM89500_A0_READ_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_FWD_ENTRY1r,(r._arla_fwd_entry1),4)
#define BCM89500_A0_WRITE_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_FWD_ENTRY1r,&(r._arla_fwd_entry1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY1r BCM89500_A0_ARLA_FWD_ENTRY1r
#define ARLA_FWD_ENTRY1r_SIZE BCM89500_A0_ARLA_FWD_ENTRY1r_SIZE
typedef BCM89500_A0_ARLA_FWD_ENTRY1r_t ARLA_FWD_ENTRY1r_t;
#define ARLA_FWD_ENTRY1r_CLR BCM89500_A0_ARLA_FWD_ENTRY1r_CLR
#define ARLA_FWD_ENTRY1r_SET BCM89500_A0_ARLA_FWD_ENTRY1r_SET
#define ARLA_FWD_ENTRY1r_GET BCM89500_A0_ARLA_FWD_ENTRY1r_GET
#define ARLA_FWD_ENTRY1r_PORTIDf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_PORTIDf_GET
#define ARLA_FWD_ENTRY1r_PORTIDf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_PORTIDf_SET
#define ARLA_FWD_ENTRY1r_ARL_CONf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET
#define ARLA_FWD_ENTRY1r_ARL_CONf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY1r_RESERVEDf_GET BCM89500_A0_ARLA_FWD_ENTRY1r_RESERVEDf_GET
#define ARLA_FWD_ENTRY1r_RESERVEDf_SET BCM89500_A0_ARLA_FWD_ENTRY1r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY1r BCM89500_A0_READ_ARLA_FWD_ENTRY1r
#define WRITE_ARLA_FWD_ENTRY1r BCM89500_A0_WRITE_ARLA_FWD_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_FWD_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_FWD_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR2 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_FWD_ENTRY2r 0x00000538

#define BCM89500_A0_ARLA_FWD_ENTRY2r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY2.
 *
 */
typedef union BCM89500_A0_ARLA_FWD_ENTRY2r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry2[1];
	uint32_t _arla_fwd_entry2;
} BCM89500_A0_ARLA_FWD_ENTRY2r_t;

#define BCM89500_A0_ARLA_FWD_ENTRY2r_CLR(r) (r).arla_fwd_entry2[0] = 0
#define BCM89500_A0_ARLA_FWD_ENTRY2r_SET(r,d) (r).arla_fwd_entry2[0] = d
#define BCM89500_A0_ARLA_FWD_ENTRY2r_GET(r) (r).arla_fwd_entry2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_FWD_ENTRY2r_PORTIDf_GET(r) (((r).arla_fwd_entry2[0]) & 0x1ff)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_PORTIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET(r) ((((r).arla_fwd_entry2[0]) >> 9) & 0x3)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry2[0]) >> 11) & 0x7)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry2[0]) >> 14) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry2[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 16) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_ARLA_FWD_ENTRY2r_RESERVEDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 17) & 0x7fff)
#define BCM89500_A0_ARLA_FWD_ENTRY2r_RESERVEDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY2.
 *
 */
#define BCM89500_A0_READ_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_FWD_ENTRY2r,(r._arla_fwd_entry2),4)
#define BCM89500_A0_WRITE_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_FWD_ENTRY2r,&(r._arla_fwd_entry2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY2r BCM89500_A0_ARLA_FWD_ENTRY2r
#define ARLA_FWD_ENTRY2r_SIZE BCM89500_A0_ARLA_FWD_ENTRY2r_SIZE
typedef BCM89500_A0_ARLA_FWD_ENTRY2r_t ARLA_FWD_ENTRY2r_t;
#define ARLA_FWD_ENTRY2r_CLR BCM89500_A0_ARLA_FWD_ENTRY2r_CLR
#define ARLA_FWD_ENTRY2r_SET BCM89500_A0_ARLA_FWD_ENTRY2r_SET
#define ARLA_FWD_ENTRY2r_GET BCM89500_A0_ARLA_FWD_ENTRY2r_GET
#define ARLA_FWD_ENTRY2r_PORTIDf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_PORTIDf_GET
#define ARLA_FWD_ENTRY2r_PORTIDf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_PORTIDf_SET
#define ARLA_FWD_ENTRY2r_ARL_CONf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET
#define ARLA_FWD_ENTRY2r_ARL_CONf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY2r_RESERVEDf_GET BCM89500_A0_ARLA_FWD_ENTRY2r_RESERVEDf_GET
#define ARLA_FWD_ENTRY2r_RESERVEDf_SET BCM89500_A0_ARLA_FWD_ENTRY2r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY2r BCM89500_A0_READ_ARLA_FWD_ENTRY2r
#define WRITE_ARLA_FWD_ENTRY2r BCM89500_A0_WRITE_ARLA_FWD_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_FWD_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_FWD_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR3 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_FWD_ENTRY3r 0x00000548

#define BCM89500_A0_ARLA_FWD_ENTRY3r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY3.
 *
 */
typedef union BCM89500_A0_ARLA_FWD_ENTRY3r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry3[1];
	uint32_t _arla_fwd_entry3;
} BCM89500_A0_ARLA_FWD_ENTRY3r_t;

#define BCM89500_A0_ARLA_FWD_ENTRY3r_CLR(r) (r).arla_fwd_entry3[0] = 0
#define BCM89500_A0_ARLA_FWD_ENTRY3r_SET(r,d) (r).arla_fwd_entry3[0] = d
#define BCM89500_A0_ARLA_FWD_ENTRY3r_GET(r) (r).arla_fwd_entry3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_FWD_ENTRY3r_PORTIDf_GET(r) (((r).arla_fwd_entry3[0]) & 0x1ff)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_PORTIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET(r) ((((r).arla_fwd_entry3[0]) >> 9) & 0x3)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry3[0]) >> 11) & 0x7)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry3[0]) >> 14) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry3[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 16) & 0x1)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_ARLA_FWD_ENTRY3r_RESERVEDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 17) & 0x7fff)
#define BCM89500_A0_ARLA_FWD_ENTRY3r_RESERVEDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY3.
 *
 */
#define BCM89500_A0_READ_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_FWD_ENTRY3r,(r._arla_fwd_entry3),4)
#define BCM89500_A0_WRITE_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_FWD_ENTRY3r,&(r._arla_fwd_entry3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY3r BCM89500_A0_ARLA_FWD_ENTRY3r
#define ARLA_FWD_ENTRY3r_SIZE BCM89500_A0_ARLA_FWD_ENTRY3r_SIZE
typedef BCM89500_A0_ARLA_FWD_ENTRY3r_t ARLA_FWD_ENTRY3r_t;
#define ARLA_FWD_ENTRY3r_CLR BCM89500_A0_ARLA_FWD_ENTRY3r_CLR
#define ARLA_FWD_ENTRY3r_SET BCM89500_A0_ARLA_FWD_ENTRY3r_SET
#define ARLA_FWD_ENTRY3r_GET BCM89500_A0_ARLA_FWD_ENTRY3r_GET
#define ARLA_FWD_ENTRY3r_PORTIDf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_PORTIDf_GET
#define ARLA_FWD_ENTRY3r_PORTIDf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_PORTIDf_SET
#define ARLA_FWD_ENTRY3r_ARL_CONf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET
#define ARLA_FWD_ENTRY3r_ARL_CONf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY3r_RESERVEDf_GET BCM89500_A0_ARLA_FWD_ENTRY3r_RESERVEDf_GET
#define ARLA_FWD_ENTRY3r_RESERVEDf_SET BCM89500_A0_ARLA_FWD_ENTRY3r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY3r BCM89500_A0_READ_ARLA_FWD_ENTRY3r
#define WRITE_ARLA_FWD_ENTRY3r BCM89500_A0_WRITE_ARLA_FWD_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_FWD_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_MAC
 * BLOCKS:   SYS
 * DESC:     MAC Address Index Register
 * SIZE:     48
 * FIELDS:
 *     MAC_ADDR_INDX    MAC Address Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0/1/2/3 locations. These entries are 64 bits wide. Initiating a write command will write the contents of ARL Entry 0/1/2/3 to the specified bin location (4 entries deep) and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_MACr 0x00000502

#define BCM89500_A0_ARLA_MACr_SIZE 6

/*
 * This structure should be used to declare and program ARLA_MAC.
 *
 */
typedef union BCM89500_A0_ARLA_MACr_s {
	uint32_t v[2];
	uint32_t arla_mac[2];
	uint32_t _arla_mac;
} BCM89500_A0_ARLA_MACr_t;

#define BCM89500_A0_ARLA_MACr_CLR(r) CDK_MEMSET(&((r)._arla_mac), 0, sizeof(BCM89500_A0_ARLA_MACr_t))
#define BCM89500_A0_ARLA_MACr_SET(r,i,d) (r).arla_mac[i] = d
#define BCM89500_A0_ARLA_MACr_GET(r,i) (r).arla_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_MACr_MAC_ADDR_INDXf_GET(r,a) cdk_field_get((r).arla_mac,0,47,a)
#define BCM89500_A0_ARLA_MACr_MAC_ADDR_INDXf_SET(r,a) cdk_field_set((r).arla_mac,0,47,a)

/*
 * These macros can be used to access ARLA_MAC.
 *
 */
#define BCM89500_A0_READ_ARLA_MACr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_MACr,(r._arla_mac),6)
#define BCM89500_A0_WRITE_ARLA_MACr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_MACr,&(r._arla_mac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACr BCM89500_A0_ARLA_MACr
#define ARLA_MACr_SIZE BCM89500_A0_ARLA_MACr_SIZE
typedef BCM89500_A0_ARLA_MACr_t ARLA_MACr_t;
#define ARLA_MACr_CLR BCM89500_A0_ARLA_MACr_CLR
#define ARLA_MACr_SET BCM89500_A0_ARLA_MACr_SET
#define ARLA_MACr_GET BCM89500_A0_ARLA_MACr_GET
#define ARLA_MACr_MAC_ADDR_INDXf_GET BCM89500_A0_ARLA_MACr_MAC_ADDR_INDXf_GET
#define ARLA_MACr_MAC_ADDR_INDXf_SET BCM89500_A0_ARLA_MACr_MAC_ADDR_INDXf_SET
#define READ_ARLA_MACr BCM89500_A0_READ_ARLA_MACr
#define WRITE_ARLA_MACr BCM89500_A0_WRITE_ARLA_MACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_MACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_MACVID_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 0.
 *     VID              VID0.The VID0 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 0 Register and MAC/VID Entry 0 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_MACVID_ENTRY0r 0x00000510

#define BCM89500_A0_ARLA_MACVID_ENTRY0r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY0.
 *
 */
typedef union BCM89500_A0_ARLA_MACVID_ENTRY0r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry0[2];
	uint32_t _arla_macvid_entry0;
} BCM89500_A0_ARLA_MACVID_ENTRY0r_t;

#define BCM89500_A0_ARLA_MACVID_ENTRY0r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry0), 0, sizeof(BCM89500_A0_ARLA_MACVID_ENTRY0r_t))
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_SET(r,i,d) (r).arla_macvid_entry0[i] = d
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_GET(r,i) (r).arla_macvid_entry0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry0,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry0,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_VIDf_GET(r) ((((r).arla_macvid_entry0[1]) >> 16) & 0xfff)
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_VIDf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_GET(r) ((((r).arla_macvid_entry0[1]) >> 28) & 0xf)
#define BCM89500_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY0.
 *
 */
#define BCM89500_A0_READ_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_MACVID_ENTRY0r,(r._arla_macvid_entry0),8)
#define BCM89500_A0_WRITE_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_MACVID_ENTRY0r,&(r._arla_macvid_entry0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY0r BCM89500_A0_ARLA_MACVID_ENTRY0r
#define ARLA_MACVID_ENTRY0r_SIZE BCM89500_A0_ARLA_MACVID_ENTRY0r_SIZE
typedef BCM89500_A0_ARLA_MACVID_ENTRY0r_t ARLA_MACVID_ENTRY0r_t;
#define ARLA_MACVID_ENTRY0r_CLR BCM89500_A0_ARLA_MACVID_ENTRY0r_CLR
#define ARLA_MACVID_ENTRY0r_SET BCM89500_A0_ARLA_MACVID_ENTRY0r_SET
#define ARLA_MACVID_ENTRY0r_GET BCM89500_A0_ARLA_MACVID_ENTRY0r_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET BCM89500_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET BCM89500_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY0r_VIDf_GET BCM89500_A0_ARLA_MACVID_ENTRY0r_VIDf_GET
#define ARLA_MACVID_ENTRY0r_VIDf_SET BCM89500_A0_ARLA_MACVID_ENTRY0r_VIDf_SET
#define ARLA_MACVID_ENTRY0r_RESERVEDf_GET BCM89500_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY0r_RESERVEDf_SET BCM89500_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY0r BCM89500_A0_READ_ARLA_MACVID_ENTRY0r
#define WRITE_ARLA_MACVID_ENTRY0r BCM89500_A0_WRITE_ARLA_MACVID_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_MACVID_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_MACVID_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 1.
 *     VID              VID1.The VID1 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 1 Register and MAC/VID Entry 1 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_MACVID_ENTRY1r 0x00000520

#define BCM89500_A0_ARLA_MACVID_ENTRY1r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY1.
 *
 */
typedef union BCM89500_A0_ARLA_MACVID_ENTRY1r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry1[2];
	uint32_t _arla_macvid_entry1;
} BCM89500_A0_ARLA_MACVID_ENTRY1r_t;

#define BCM89500_A0_ARLA_MACVID_ENTRY1r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry1), 0, sizeof(BCM89500_A0_ARLA_MACVID_ENTRY1r_t))
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_SET(r,i,d) (r).arla_macvid_entry1[i] = d
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_GET(r,i) (r).arla_macvid_entry1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry1,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry1,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_VIDf_GET(r) ((((r).arla_macvid_entry1[1]) >> 16) & 0xfff)
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_VIDf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_GET(r) ((((r).arla_macvid_entry1[1]) >> 28) & 0xf)
#define BCM89500_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY1.
 *
 */
#define BCM89500_A0_READ_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_MACVID_ENTRY1r,(r._arla_macvid_entry1),8)
#define BCM89500_A0_WRITE_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_MACVID_ENTRY1r,&(r._arla_macvid_entry1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY1r BCM89500_A0_ARLA_MACVID_ENTRY1r
#define ARLA_MACVID_ENTRY1r_SIZE BCM89500_A0_ARLA_MACVID_ENTRY1r_SIZE
typedef BCM89500_A0_ARLA_MACVID_ENTRY1r_t ARLA_MACVID_ENTRY1r_t;
#define ARLA_MACVID_ENTRY1r_CLR BCM89500_A0_ARLA_MACVID_ENTRY1r_CLR
#define ARLA_MACVID_ENTRY1r_SET BCM89500_A0_ARLA_MACVID_ENTRY1r_SET
#define ARLA_MACVID_ENTRY1r_GET BCM89500_A0_ARLA_MACVID_ENTRY1r_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET BCM89500_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET BCM89500_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY1r_VIDf_GET BCM89500_A0_ARLA_MACVID_ENTRY1r_VIDf_GET
#define ARLA_MACVID_ENTRY1r_VIDf_SET BCM89500_A0_ARLA_MACVID_ENTRY1r_VIDf_SET
#define ARLA_MACVID_ENTRY1r_RESERVEDf_GET BCM89500_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY1r_RESERVEDf_SET BCM89500_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY1r BCM89500_A0_READ_ARLA_MACVID_ENTRY1r
#define WRITE_ARLA_MACVID_ENTRY1r BCM89500_A0_WRITE_ARLA_MACVID_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_MACVID_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_MACVID_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 2 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 2.
 *     VID              VID2.The VID2 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 2 Register and MAC/VID Entry 2 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_MACVID_ENTRY2r 0x00000530

#define BCM89500_A0_ARLA_MACVID_ENTRY2r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY2.
 *
 */
typedef union BCM89500_A0_ARLA_MACVID_ENTRY2r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry2[2];
	uint32_t _arla_macvid_entry2;
} BCM89500_A0_ARLA_MACVID_ENTRY2r_t;

#define BCM89500_A0_ARLA_MACVID_ENTRY2r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry2), 0, sizeof(BCM89500_A0_ARLA_MACVID_ENTRY2r_t))
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_SET(r,i,d) (r).arla_macvid_entry2[i] = d
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_GET(r,i) (r).arla_macvid_entry2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry2,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry2,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_VIDf_GET(r) ((((r).arla_macvid_entry2[1]) >> 16) & 0xfff)
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_VIDf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_GET(r) ((((r).arla_macvid_entry2[1]) >> 28) & 0xf)
#define BCM89500_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY2.
 *
 */
#define BCM89500_A0_READ_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_MACVID_ENTRY2r,(r._arla_macvid_entry2),8)
#define BCM89500_A0_WRITE_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_MACVID_ENTRY2r,&(r._arla_macvid_entry2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY2r BCM89500_A0_ARLA_MACVID_ENTRY2r
#define ARLA_MACVID_ENTRY2r_SIZE BCM89500_A0_ARLA_MACVID_ENTRY2r_SIZE
typedef BCM89500_A0_ARLA_MACVID_ENTRY2r_t ARLA_MACVID_ENTRY2r_t;
#define ARLA_MACVID_ENTRY2r_CLR BCM89500_A0_ARLA_MACVID_ENTRY2r_CLR
#define ARLA_MACVID_ENTRY2r_SET BCM89500_A0_ARLA_MACVID_ENTRY2r_SET
#define ARLA_MACVID_ENTRY2r_GET BCM89500_A0_ARLA_MACVID_ENTRY2r_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET BCM89500_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET BCM89500_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY2r_VIDf_GET BCM89500_A0_ARLA_MACVID_ENTRY2r_VIDf_GET
#define ARLA_MACVID_ENTRY2r_VIDf_SET BCM89500_A0_ARLA_MACVID_ENTRY2r_VIDf_SET
#define ARLA_MACVID_ENTRY2r_RESERVEDf_GET BCM89500_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY2r_RESERVEDf_SET BCM89500_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY2r BCM89500_A0_READ_ARLA_MACVID_ENTRY2r
#define WRITE_ARLA_MACVID_ENTRY2r BCM89500_A0_WRITE_ARLA_MACVID_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_MACVID_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_MACVID_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 3 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 3.
 *     VID              VID3.The VID3 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 3 Register and MAC/VID Entry 3 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_MACVID_ENTRY3r 0x00000540

#define BCM89500_A0_ARLA_MACVID_ENTRY3r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY3.
 *
 */
typedef union BCM89500_A0_ARLA_MACVID_ENTRY3r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry3[2];
	uint32_t _arla_macvid_entry3;
} BCM89500_A0_ARLA_MACVID_ENTRY3r_t;

#define BCM89500_A0_ARLA_MACVID_ENTRY3r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry3), 0, sizeof(BCM89500_A0_ARLA_MACVID_ENTRY3r_t))
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_SET(r,i,d) (r).arla_macvid_entry3[i] = d
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_GET(r,i) (r).arla_macvid_entry3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry3,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry3,0,47,a)
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_VIDf_GET(r) ((((r).arla_macvid_entry3[1]) >> 16) & 0xfff)
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_VIDf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_GET(r) ((((r).arla_macvid_entry3[1]) >> 28) & 0xf)
#define BCM89500_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY3.
 *
 */
#define BCM89500_A0_READ_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_MACVID_ENTRY3r,(r._arla_macvid_entry3),8)
#define BCM89500_A0_WRITE_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_MACVID_ENTRY3r,&(r._arla_macvid_entry3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY3r BCM89500_A0_ARLA_MACVID_ENTRY3r
#define ARLA_MACVID_ENTRY3r_SIZE BCM89500_A0_ARLA_MACVID_ENTRY3r_SIZE
typedef BCM89500_A0_ARLA_MACVID_ENTRY3r_t ARLA_MACVID_ENTRY3r_t;
#define ARLA_MACVID_ENTRY3r_CLR BCM89500_A0_ARLA_MACVID_ENTRY3r_CLR
#define ARLA_MACVID_ENTRY3r_SET BCM89500_A0_ARLA_MACVID_ENTRY3r_SET
#define ARLA_MACVID_ENTRY3r_GET BCM89500_A0_ARLA_MACVID_ENTRY3r_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET BCM89500_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET BCM89500_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY3r_VIDf_GET BCM89500_A0_ARLA_MACVID_ENTRY3r_VIDf_GET
#define ARLA_MACVID_ENTRY3r_VIDf_SET BCM89500_A0_ARLA_MACVID_ENTRY3r_VIDf_SET
#define ARLA_MACVID_ENTRY3r_RESERVEDf_GET BCM89500_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY3r_RESERVEDf_SET BCM89500_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY3r BCM89500_A0_READ_ARLA_MACVID_ENTRY3r
#define WRITE_ARLA_MACVID_ENTRY3r BCM89500_A0_WRITE_ARLA_MACVID_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_MACVID_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_RWCTL
 * BLOCKS:   SYS
 * DESC:     ARL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     ARL_RW           ARL Read/Write.1 = Read,0 = Write.
 *     RESERVED         Reserved
 *     ARL_STRTDN       Start/Done Command.Write as 1 to initiate a read or write command, after first loading the MAC_ADDR_INDX register with the MAC address for which the ARL entry is to be read or written.The polar will reset the bit to indicate a write operation completed, or a read operation has completed and data from the bin entry is available in ARL Entry 0/1 Note that both ARL Entry 0 and 1 are both always read/written by the polar when accessing the address table locations in memory.
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_RWCTLr 0x00000500

#define BCM89500_A0_ARLA_RWCTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_RWCTL.
 *
 */
typedef union BCM89500_A0_ARLA_RWCTLr_s {
	uint32_t v[1];
	uint32_t arla_rwctl[1];
	uint32_t _arla_rwctl;
} BCM89500_A0_ARLA_RWCTLr_t;

#define BCM89500_A0_ARLA_RWCTLr_CLR(r) (r).arla_rwctl[0] = 0
#define BCM89500_A0_ARLA_RWCTLr_SET(r,d) (r).arla_rwctl[0] = d
#define BCM89500_A0_ARLA_RWCTLr_GET(r) (r).arla_rwctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_RWCTLr_ARL_RWf_GET(r) (((r).arla_rwctl[0]) & 0x1)
#define BCM89500_A0_ARLA_RWCTLr_ARL_RWf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_ARLA_RWCTLr_RESERVEDf_GET(r) ((((r).arla_rwctl[0]) >> 1) & 0x3f)
#define BCM89500_A0_ARLA_RWCTLr_RESERVEDf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM89500_A0_ARLA_RWCTLr_ARL_STRTDNf_GET(r) ((((r).arla_rwctl[0]) >> 7) & 0x1)
#define BCM89500_A0_ARLA_RWCTLr_ARL_STRTDNf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_RWCTL.
 *
 */
#define BCM89500_A0_READ_ARLA_RWCTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_RWCTLr,(r._arla_rwctl),1)
#define BCM89500_A0_WRITE_ARLA_RWCTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_RWCTLr,&(r._arla_rwctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_RWCTLr BCM89500_A0_ARLA_RWCTLr
#define ARLA_RWCTLr_SIZE BCM89500_A0_ARLA_RWCTLr_SIZE
typedef BCM89500_A0_ARLA_RWCTLr_t ARLA_RWCTLr_t;
#define ARLA_RWCTLr_CLR BCM89500_A0_ARLA_RWCTLr_CLR
#define ARLA_RWCTLr_SET BCM89500_A0_ARLA_RWCTLr_SET
#define ARLA_RWCTLr_GET BCM89500_A0_ARLA_RWCTLr_GET
#define ARLA_RWCTLr_ARL_RWf_GET BCM89500_A0_ARLA_RWCTLr_ARL_RWf_GET
#define ARLA_RWCTLr_ARL_RWf_SET BCM89500_A0_ARLA_RWCTLr_ARL_RWf_SET
#define ARLA_RWCTLr_RESERVEDf_GET BCM89500_A0_ARLA_RWCTLr_RESERVEDf_GET
#define ARLA_RWCTLr_RESERVEDf_SET BCM89500_A0_ARLA_RWCTLr_RESERVEDf_SET
#define ARLA_RWCTLr_ARL_STRTDNf_GET BCM89500_A0_ARLA_RWCTLr_ARL_STRTDNf_GET
#define ARLA_RWCTLr_ARL_STRTDNf_SET BCM89500_A0_ARLA_RWCTLr_ARL_STRTDNf_SET
#define READ_ARLA_RWCTLr BCM89500_A0_READ_ARLA_RWCTLr
#define WRITE_ARLA_RWCTLr BCM89500_A0_WRITE_ARLA_RWCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_RWCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_SRCH_ADR
 * BLOCKS:   SYS
 * DESC:     ARL Search Address Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_SRCH_ADR    ARL Address.15 bit internal representation of the address of the ARL entry currently being accessed by the ARL search routine.This is not a direct address of the ARL location, and is intended for factory test/diagnostic use only.
 *     ARLA_SRCH_ADR_VALID ARL Address Valid.Indicates the lower 15 bits of this register contain a valid internal representation of the ARL entry currently being accessed. Intended for factory test/diagnostic use only.
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_SRCH_ADRr 0x00000551

#define BCM89500_A0_ARLA_SRCH_ADRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_ADR.
 *
 */
typedef union BCM89500_A0_ARLA_SRCH_ADRr_s {
	uint32_t v[1];
	uint32_t arla_srch_adr[1];
	uint32_t _arla_srch_adr;
} BCM89500_A0_ARLA_SRCH_ADRr_t;

#define BCM89500_A0_ARLA_SRCH_ADRr_CLR(r) (r).arla_srch_adr[0] = 0
#define BCM89500_A0_ARLA_SRCH_ADRr_SET(r,d) (r).arla_srch_adr[0] = d
#define BCM89500_A0_ARLA_SRCH_ADRr_GET(r) (r).arla_srch_adr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET(r) (((r).arla_srch_adr[0]) & 0x7fff)
#define BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))
#define BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET(r) ((((r).arla_srch_adr[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_ADR.
 *
 */
#define BCM89500_A0_READ_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_SRCH_ADRr,(r._arla_srch_adr),2)
#define BCM89500_A0_WRITE_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_SRCH_ADRr,&(r._arla_srch_adr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_ADRr BCM89500_A0_ARLA_SRCH_ADRr
#define ARLA_SRCH_ADRr_SIZE BCM89500_A0_ARLA_SRCH_ADRr_SIZE
typedef BCM89500_A0_ARLA_SRCH_ADRr_t ARLA_SRCH_ADRr_t;
#define ARLA_SRCH_ADRr_CLR BCM89500_A0_ARLA_SRCH_ADRr_CLR
#define ARLA_SRCH_ADRr_SET BCM89500_A0_ARLA_SRCH_ADRr_SET
#define ARLA_SRCH_ADRr_GET BCM89500_A0_ARLA_SRCH_ADRr_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET BCM89500_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET
#define READ_ARLA_SRCH_ADRr BCM89500_A0_READ_ARLA_SRCH_ADRr
#define WRITE_ARLA_SRCH_ADRr BCM89500_A0_WRITE_ARLA_SRCH_ADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_SRCH_ADRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_SRCH_CTL
 * BLOCKS:   SYS
 * DESC:     ARL Search Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_SRCH_VLID   ARL Search Result ValidAvailable in the ARL Search Result register.Reset by a host read to the ARL Search Result register 1 , which will cause the ARL search process to continue through the ARL entries until the next entry is found with a Valid bit is set.(Note: should not reset by a host read to ARL Search VID Result Register. The correct process of reading a ARL Entry after having searched a valid one: Read ARL Search VID Result Register => Read ARL Search Result Register 1)
 *     RESERVED         Reserved
 *     ARLA_SRCH_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The polar will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_SRCH_CTLr 0x00000550

#define BCM89500_A0_ARLA_SRCH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_SRCH_CTL.
 *
 */
typedef union BCM89500_A0_ARLA_SRCH_CTLr_s {
	uint32_t v[1];
	uint32_t arla_srch_ctl[1];
	uint32_t _arla_srch_ctl;
} BCM89500_A0_ARLA_SRCH_CTLr_t;

#define BCM89500_A0_ARLA_SRCH_CTLr_CLR(r) (r).arla_srch_ctl[0] = 0
#define BCM89500_A0_ARLA_SRCH_CTLr_SET(r,d) (r).arla_srch_ctl[0] = d
#define BCM89500_A0_ARLA_SRCH_CTLr_GET(r) (r).arla_srch_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET(r) (((r).arla_srch_ctl[0]) & 0x1)
#define BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_ARLA_SRCH_CTLr_RESERVEDf_GET(r) ((((r).arla_srch_ctl[0]) >> 1) & 0x3f)
#define BCM89500_A0_ARLA_SRCH_CTLr_RESERVEDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET(r) ((((r).arla_srch_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_SRCH_CTL.
 *
 */
#define BCM89500_A0_READ_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_SRCH_CTLr,(r._arla_srch_ctl),1)
#define BCM89500_A0_WRITE_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_SRCH_CTLr,&(r._arla_srch_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_CTLr BCM89500_A0_ARLA_SRCH_CTLr
#define ARLA_SRCH_CTLr_SIZE BCM89500_A0_ARLA_SRCH_CTLr_SIZE
typedef BCM89500_A0_ARLA_SRCH_CTLr_t ARLA_SRCH_CTLr_t;
#define ARLA_SRCH_CTLr_CLR BCM89500_A0_ARLA_SRCH_CTLr_CLR
#define ARLA_SRCH_CTLr_SET BCM89500_A0_ARLA_SRCH_CTLr_SET
#define ARLA_SRCH_CTLr_GET BCM89500_A0_ARLA_SRCH_CTLr_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET
#define ARLA_SRCH_CTLr_RESERVEDf_GET BCM89500_A0_ARLA_SRCH_CTLr_RESERVEDf_GET
#define ARLA_SRCH_CTLr_RESERVEDf_SET BCM89500_A0_ARLA_SRCH_CTLr_RESERVEDf_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET BCM89500_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET
#define READ_ARLA_SRCH_CTLr BCM89500_A0_READ_ARLA_SRCH_CTLr
#define WRITE_ARLA_SRCH_CTLr BCM89500_A0_WRITE_ARLA_SRCH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_SRCH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL control bit for ARL control mode enhancement
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry.Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_SRCH_RSLTr 0x00000568

#define BCM89500_A0_ARLA_SRCH_RSLTr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT.
 *
 */
typedef union BCM89500_A0_ARLA_SRCH_RSLTr_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt[1];
	uint32_t _arla_srch_rslt;
} BCM89500_A0_ARLA_SRCH_RSLTr_t;

#define BCM89500_A0_ARLA_SRCH_RSLTr_CLR(r) (r).arla_srch_rslt[0] = 0
#define BCM89500_A0_ARLA_SRCH_RSLTr_SET(r,d) (r).arla_srch_rslt[0] = d
#define BCM89500_A0_ARLA_SRCH_RSLTr_GET(r) (r).arla_srch_rslt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_SRCH_RSLTr_PORTIDf_GET(r) (((r).arla_srch_rslt[0]) & 0x1ff)
#define BCM89500_A0_ARLA_SRCH_RSLTr_PORTIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET(r) ((((r).arla_srch_rslt[0]) >> 9) & 0x3)
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt[0]) >> 11) & 0x7)
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt[0]) >> 14) & 0x1)
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt[0]) >> 16) & 0x1)
#define BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_ARLA_SRCH_RSLTr_RESERVEDf_GET(r) ((((r).arla_srch_rslt[0]) >> 17) & 0x7fff)
#define BCM89500_A0_ARLA_SRCH_RSLTr_RESERVEDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT.
 *
 */
#define BCM89500_A0_READ_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_SRCH_RSLTr,(r._arla_srch_rslt),4)
#define BCM89500_A0_WRITE_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_SRCH_RSLTr,&(r._arla_srch_rslt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLTr BCM89500_A0_ARLA_SRCH_RSLTr
#define ARLA_SRCH_RSLTr_SIZE BCM89500_A0_ARLA_SRCH_RSLTr_SIZE
typedef BCM89500_A0_ARLA_SRCH_RSLTr_t ARLA_SRCH_RSLTr_t;
#define ARLA_SRCH_RSLTr_CLR BCM89500_A0_ARLA_SRCH_RSLTr_CLR
#define ARLA_SRCH_RSLTr_SET BCM89500_A0_ARLA_SRCH_RSLTr_SET
#define ARLA_SRCH_RSLTr_GET BCM89500_A0_ARLA_SRCH_RSLTr_GET
#define ARLA_SRCH_RSLTr_PORTIDf_GET BCM89500_A0_ARLA_SRCH_RSLTr_PORTIDf_GET
#define ARLA_SRCH_RSLTr_PORTIDf_SET BCM89500_A0_ARLA_SRCH_RSLTr_PORTIDf_SET
#define ARLA_SRCH_RSLTr_ARL_CONf_GET BCM89500_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET
#define ARLA_SRCH_RSLTr_ARL_CONf_SET BCM89500_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM89500_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLTr_RESERVEDf_GET BCM89500_A0_ARLA_SRCH_RSLTr_RESERVEDf_GET
#define ARLA_SRCH_RSLTr_RESERVEDf_SET BCM89500_A0_ARLA_SRCH_RSLTr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLTr BCM89500_A0_READ_ARLA_SRCH_RSLTr
#define WRITE_ARLA_SRCH_RSLTr BCM89500_A0_WRITE_ARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_SRCH_RSLTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_SRCH_RSLT_0_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr 0x00000560

#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_0_MACVID.
 *
 */
typedef union BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_0_macvid[2];
	uint32_t _arla_srch_rslt_0_macvid;
} BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_t;

#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_0_macvid), 0, sizeof(BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_t))
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_0_macvid[i] = d
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET(r,i) (r).arla_srch_rslt_0_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 16) & 0xfff)
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 28) & 0xf)
#define BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_0_MACVID.
 *
 */
#define BCM89500_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr,(r._arla_srch_rslt_0_macvid),8)
#define BCM89500_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr,&(r._arla_srch_rslt_0_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_0_MACVIDr BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr
#define ARLA_SRCH_RSLT_0_MACVIDr_SIZE BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE
typedef BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_t ARLA_SRCH_RSLT_0_MACVIDr_t;
#define ARLA_SRCH_RSLT_0_MACVIDr_CLR BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR
#define ARLA_SRCH_RSLT_0_MACVIDr_SET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_GET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_0_MACVIDr BCM89500_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_0_MACVIDr BCM89500_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_SRCH_RSLT_0_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_SRCH_RSLT_1
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[3:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL control bit for ARL control mode enhancement
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_SRCH_RSLT_1r 0x00000578

#define BCM89500_A0_ARLA_SRCH_RSLT_1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1.
 *
 */
typedef union BCM89500_A0_ARLA_SRCH_RSLT_1r_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt_1[1];
	uint32_t _arla_srch_rslt_1;
} BCM89500_A0_ARLA_SRCH_RSLT_1r_t;

#define BCM89500_A0_ARLA_SRCH_RSLT_1r_CLR(r) (r).arla_srch_rslt_1[0] = 0
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_SET(r,d) (r).arla_srch_rslt_1[0] = d
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_GET(r) (r).arla_srch_rslt_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_PORTIDf_GET(r) (((r).arla_srch_rslt_1[0]) & 0x1ff)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_PORTIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 9) & 0x3)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 11) & 0x7)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 14) & 0x1)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 15) & 0x1)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 16) & 0x1)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 17) & 0x7fff)
#define BCM89500_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1.
 *
 */
#define BCM89500_A0_READ_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_SRCH_RSLT_1r,(r._arla_srch_rslt_1),4)
#define BCM89500_A0_WRITE_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_SRCH_RSLT_1r,&(r._arla_srch_rslt_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1r BCM89500_A0_ARLA_SRCH_RSLT_1r
#define ARLA_SRCH_RSLT_1r_SIZE BCM89500_A0_ARLA_SRCH_RSLT_1r_SIZE
typedef BCM89500_A0_ARLA_SRCH_RSLT_1r_t ARLA_SRCH_RSLT_1r_t;
#define ARLA_SRCH_RSLT_1r_CLR BCM89500_A0_ARLA_SRCH_RSLT_1r_CLR
#define ARLA_SRCH_RSLT_1r_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_SET
#define ARLA_SRCH_RSLT_1r_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_GET
#define ARLA_SRCH_RSLT_1r_PORTIDf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_PORTIDf_GET
#define ARLA_SRCH_RSLT_1r_PORTIDf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_PORTIDf_SET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLT_1r_RESERVEDf_GET BCM89500_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_GET
#define ARLA_SRCH_RSLT_1r_RESERVEDf_SET BCM89500_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_1r BCM89500_A0_READ_ARLA_SRCH_RSLT_1r
#define WRITE_ARLA_SRCH_RSLT_1r BCM89500_A0_WRITE_ARLA_SRCH_RSLT_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_SRCH_RSLT_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_SRCH_RSLT_1_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr 0x00000570

#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1_MACVID.
 *
 */
typedef union BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_1_macvid[2];
	uint32_t _arla_srch_rslt_1_macvid;
} BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_t;

#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_1_macvid), 0, sizeof(BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_t))
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_1_macvid[i] = d
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET(r,i) (r).arla_srch_rslt_1_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 16) & 0xfff)
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 28) & 0xf)
#define BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1_MACVID.
 *
 */
#define BCM89500_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr,(r._arla_srch_rslt_1_macvid),8)
#define BCM89500_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr,&(r._arla_srch_rslt_1_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1_MACVIDr BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr
#define ARLA_SRCH_RSLT_1_MACVIDr_SIZE BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE
typedef BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_t ARLA_SRCH_RSLT_1_MACVIDr_t;
#define ARLA_SRCH_RSLT_1_MACVIDr_CLR BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR
#define ARLA_SRCH_RSLT_1_MACVIDr_SET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_GET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_1_MACVIDr BCM89500_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_1_MACVIDr BCM89500_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_SRCH_RSLT_1_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_VID
 * BLOCKS:   SYS
 * DESC:     VID Index Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VIDTAB_INDX VID Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address upon MAC Address Index, upon 12 bit VID Index Register if 802.1Q is enabled, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0 locations and VID Entry0. Both ARL entries are 64 bits wide. Both VID entries are 12 bits wide.Initiating a write command will write the contents of ARL Entry 0/1 and VID Entry 0/1 to the specified bin location and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *     ARLA_VIDTAB_RSRV0 Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_VIDr 0x00000508

#define BCM89500_A0_ARLA_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID.
 *
 */
typedef union BCM89500_A0_ARLA_VIDr_s {
	uint32_t v[1];
	uint32_t arla_vid[1];
	uint32_t _arla_vid;
} BCM89500_A0_ARLA_VIDr_t;

#define BCM89500_A0_ARLA_VIDr_CLR(r) (r).arla_vid[0] = 0
#define BCM89500_A0_ARLA_VIDr_SET(r,d) (r).arla_vid[0] = d
#define BCM89500_A0_ARLA_VIDr_GET(r) (r).arla_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET(r) (((r).arla_vid[0]) & 0xfff)
#define BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET(r) ((((r).arla_vid[0]) >> 12) & 0xf)
#define BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VID.
 *
 */
#define BCM89500_A0_READ_ARLA_VIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_VIDr,(r._arla_vid),2)
#define BCM89500_A0_WRITE_ARLA_VIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_VIDr,&(r._arla_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VIDr BCM89500_A0_ARLA_VIDr
#define ARLA_VIDr_SIZE BCM89500_A0_ARLA_VIDr_SIZE
typedef BCM89500_A0_ARLA_VIDr_t ARLA_VIDr_t;
#define ARLA_VIDr_CLR BCM89500_A0_ARLA_VIDr_CLR
#define ARLA_VIDr_SET BCM89500_A0_ARLA_VIDr_SET
#define ARLA_VIDr_GET BCM89500_A0_ARLA_VIDr_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_GET BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_SET BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET BCM89500_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET
#define READ_ARLA_VIDr BCM89500_A0_READ_ARLA_VIDr
#define WRITE_ARLA_VIDr BCM89500_A0_WRITE_ARLA_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_VTBL_ADDR
 * BLOCKS:   SYS
 * DESC:     VTBL Address Index Register
 * SIZE:     16
 * FIELDS:
 *     VTBL_ADDR_INDEX  VLAN Table Address Index.The VLAN Table Address Index Register is used to access VLAN Table Entry.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_VTBL_ADDRr 0x00000581

#define BCM89500_A0_ARLA_VTBL_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VTBL_ADDR.
 *
 */
typedef union BCM89500_A0_ARLA_VTBL_ADDRr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_addr[1];
	uint32_t _arla_vtbl_addr;
} BCM89500_A0_ARLA_VTBL_ADDRr_t;

#define BCM89500_A0_ARLA_VTBL_ADDRr_CLR(r) (r).arla_vtbl_addr[0] = 0
#define BCM89500_A0_ARLA_VTBL_ADDRr_SET(r,d) (r).arla_vtbl_addr[0] = d
#define BCM89500_A0_ARLA_VTBL_ADDRr_GET(r) (r).arla_vtbl_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET(r) (((r).arla_vtbl_addr[0]) & 0xfff)
#define BCM89500_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_ARLA_VTBL_ADDRr_RESERVEDf_GET(r) ((((r).arla_vtbl_addr[0]) >> 12) & 0xf)
#define BCM89500_A0_ARLA_VTBL_ADDRr_RESERVEDf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VTBL_ADDR.
 *
 */
#define BCM89500_A0_READ_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_VTBL_ADDRr,(r._arla_vtbl_addr),2)
#define BCM89500_A0_WRITE_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_VTBL_ADDRr,&(r._arla_vtbl_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ADDRr BCM89500_A0_ARLA_VTBL_ADDRr
#define ARLA_VTBL_ADDRr_SIZE BCM89500_A0_ARLA_VTBL_ADDRr_SIZE
typedef BCM89500_A0_ARLA_VTBL_ADDRr_t ARLA_VTBL_ADDRr_t;
#define ARLA_VTBL_ADDRr_CLR BCM89500_A0_ARLA_VTBL_ADDRr_CLR
#define ARLA_VTBL_ADDRr_SET BCM89500_A0_ARLA_VTBL_ADDRr_SET
#define ARLA_VTBL_ADDRr_GET BCM89500_A0_ARLA_VTBL_ADDRr_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET BCM89500_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET BCM89500_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET
#define ARLA_VTBL_ADDRr_RESERVEDf_GET BCM89500_A0_ARLA_VTBL_ADDRr_RESERVEDf_GET
#define ARLA_VTBL_ADDRr_RESERVEDf_SET BCM89500_A0_ARLA_VTBL_ADDRr_RESERVEDf_SET
#define READ_ARLA_VTBL_ADDRr BCM89500_A0_READ_ARLA_VTBL_ADDRr
#define WRITE_ARLA_VTBL_ADDRr BCM89500_A0_WRITE_ARLA_VTBL_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_VTBL_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_VTBL_ENTRY
 * BLOCKS:   SYS
 * DESC:     VTBL Entry Register
 * SIZE:     32
 * FIELDS:
 *     FWD_MAP          Forward PORT MAP.The VLAN-tagged Frame is allowed to be forwarded to the destination ports corresponding bits set in the Map.Bit [8]: Port 8(IMP),Bit [7]: Port 7,Bit [6]: Reserved,Bits [5:0]: Port 5-0.
 *     UNTAG_MAP        Untag Port Map.The VLAN-tagged Frame forward to the destination ports corresponding bits set in the Map will be untagged.Bit [17]: Port 8(IMP),Bit [16]: Port 7,Bit [15]: Reserved,Bits [14:9]: Port 5-0.
 *     MSPT_INDEX       Index for 8 spanning tree.
 *     FWD_MODE         It indicate whether the packet forwarding should be based on VLAN membership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used for certain ISP tagged packets received from ISP port when Falcon is operating in Double Tag mode.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_VTBL_ENTRYr 0x00000583

#define BCM89500_A0_ARLA_VTBL_ENTRYr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_VTBL_ENTRY.
 *
 */
typedef union BCM89500_A0_ARLA_VTBL_ENTRYr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_entry[1];
	uint32_t _arla_vtbl_entry;
} BCM89500_A0_ARLA_VTBL_ENTRYr_t;

#define BCM89500_A0_ARLA_VTBL_ENTRYr_CLR(r) (r).arla_vtbl_entry[0] = 0
#define BCM89500_A0_ARLA_VTBL_ENTRYr_SET(r,d) (r).arla_vtbl_entry[0] = d
#define BCM89500_A0_ARLA_VTBL_ENTRYr_GET(r) (r).arla_vtbl_entry[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET(r) (((r).arla_vtbl_entry[0]) & 0x1ff)
#define BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET(r) ((((r).arla_vtbl_entry[0]) >> 9) & 0x1ff)
#define BCM89500_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM89500_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET(r) ((((r).arla_vtbl_entry[0]) >> 18) & 0x7)
#define BCM89500_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET(r) ((((r).arla_vtbl_entry[0]) >> 21) & 0x1)
#define BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM89500_A0_ARLA_VTBL_ENTRYr_RESERVEDf_GET(r) ((((r).arla_vtbl_entry[0]) >> 22) & 0x3ff)
#define BCM89500_A0_ARLA_VTBL_ENTRYr_RESERVEDf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access ARLA_VTBL_ENTRY.
 *
 */
#define BCM89500_A0_READ_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_VTBL_ENTRYr,(r._arla_vtbl_entry),4)
#define BCM89500_A0_WRITE_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_VTBL_ENTRYr,&(r._arla_vtbl_entry),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ENTRYr BCM89500_A0_ARLA_VTBL_ENTRYr
#define ARLA_VTBL_ENTRYr_SIZE BCM89500_A0_ARLA_VTBL_ENTRYr_SIZE
typedef BCM89500_A0_ARLA_VTBL_ENTRYr_t ARLA_VTBL_ENTRYr_t;
#define ARLA_VTBL_ENTRYr_CLR BCM89500_A0_ARLA_VTBL_ENTRYr_CLR
#define ARLA_VTBL_ENTRYr_SET BCM89500_A0_ARLA_VTBL_ENTRYr_SET
#define ARLA_VTBL_ENTRYr_GET BCM89500_A0_ARLA_VTBL_ENTRYr_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_GET BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_SET BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET BCM89500_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET BCM89500_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET BCM89500_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET BCM89500_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_GET BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_SET BCM89500_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET
#define ARLA_VTBL_ENTRYr_RESERVEDf_GET BCM89500_A0_ARLA_VTBL_ENTRYr_RESERVEDf_GET
#define ARLA_VTBL_ENTRYr_RESERVEDf_SET BCM89500_A0_ARLA_VTBL_ENTRYr_RESERVEDf_SET
#define READ_ARLA_VTBL_ENTRYr BCM89500_A0_READ_ARLA_VTBL_ENTRYr
#define WRITE_ARLA_VTBL_ENTRYr BCM89500_A0_WRITE_ARLA_VTBL_ENTRYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_VTBL_ENTRYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ARLA_VTBL_RWCTRL
 * BLOCKS:   SYS
 * DESC:     VTBL Read/Write/Clear Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_VTBL_RW_CLR VTBL Read/Write/Clear-table11 = Reserved10 = Clear-table01 = Read00 = Write
 *     RESERVED         Reserved
 *     ARLA_VTBL_STDN   Start/Done.Write as 1 to initiate a read or write or clear-table command.For Read or Write Command, the VTBL Address Index register should be loaded with the VLAN ID for which the VTBL entry is to be read or written.polar will reset the bit to indicate a write operation completed or a read operation has completed and data from the bin entry is available in VTBL Entry, or a clear-table operation has completed.
 *
 ******************************************************************************/
#define BCM89500_A0_ARLA_VTBL_RWCTRLr 0x00000580

#define BCM89500_A0_ARLA_VTBL_RWCTRLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_VTBL_RWCTRL.
 *
 */
typedef union BCM89500_A0_ARLA_VTBL_RWCTRLr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_rwctrl[1];
	uint32_t _arla_vtbl_rwctrl;
} BCM89500_A0_ARLA_VTBL_RWCTRLr_t;

#define BCM89500_A0_ARLA_VTBL_RWCTRLr_CLR(r) (r).arla_vtbl_rwctrl[0] = 0
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_SET(r,d) (r).arla_vtbl_rwctrl[0] = d
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_GET(r) (r).arla_vtbl_rwctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET(r) (((r).arla_vtbl_rwctrl[0]) & 0x3)
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 2) & 0x1f)
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_VTBL_RWCTRL.
 *
 */
#define BCM89500_A0_READ_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ARLA_VTBL_RWCTRLr,(r._arla_vtbl_rwctrl),1)
#define BCM89500_A0_WRITE_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ARLA_VTBL_RWCTRLr,&(r._arla_vtbl_rwctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_RWCTRLr BCM89500_A0_ARLA_VTBL_RWCTRLr
#define ARLA_VTBL_RWCTRLr_SIZE BCM89500_A0_ARLA_VTBL_RWCTRLr_SIZE
typedef BCM89500_A0_ARLA_VTBL_RWCTRLr_t ARLA_VTBL_RWCTRLr_t;
#define ARLA_VTBL_RWCTRLr_CLR BCM89500_A0_ARLA_VTBL_RWCTRLr_CLR
#define ARLA_VTBL_RWCTRLr_SET BCM89500_A0_ARLA_VTBL_RWCTRLr_SET
#define ARLA_VTBL_RWCTRLr_GET BCM89500_A0_ARLA_VTBL_RWCTRLr_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET
#define ARLA_VTBL_RWCTRLr_RESERVEDf_GET BCM89500_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_GET
#define ARLA_VTBL_RWCTRLr_RESERVEDf_SET BCM89500_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_SET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET BCM89500_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET
#define READ_ARLA_VTBL_RWCTRLr BCM89500_A0_READ_ARLA_VTBL_RWCTRLr
#define WRITE_ARLA_VTBL_RWCTRLr BCM89500_A0_WRITE_ARLA_VTBL_RWCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ARLA_VTBL_RWCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr 0x00004170

#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_IMP.
 *
 */
typedef union BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_imp[1];
	uint32_t _bc_sup_pktdrop_cnt_imp;
} BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_t;

#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR(r) (r).bc_sup_pktdrop_cnt_imp[0] = 0
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_SET(r,d) (r).bc_sup_pktdrop_cnt_imp[0] = d
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_GET(r) (r).bc_sup_pktdrop_cnt_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_imp[0])
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_IMP.
 *
 */
#define BCM89500_A0_READ_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr,(r._bc_sup_pktdrop_cnt_imp),4)
#define BCM89500_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr,&(r._bc_sup_pktdrop_cnt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_IMPr BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr
#define BC_SUP_PKTDROP_CNT_IMPr_SIZE BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE
typedef BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_t BC_SUP_PKTDROP_CNT_IMPr_t;
#define BC_SUP_PKTDROP_CNT_IMPr_CLR BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR
#define BC_SUP_PKTDROP_CNT_IMPr_SET BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_SET
#define BC_SUP_PKTDROP_CNT_IMPr_GET BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_IMPr BCM89500_A0_READ_BC_SUP_PKTDROP_CNT_IMPr
#define WRITE_BC_SUP_PKTDROP_CNT_IMPr BCM89500_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BC_SUP_PKTDROP_CNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_P
 * BLOCKS:   GPIC0
 * DESC:     Port N Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr 0x00004150

#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_P.
 *
 */
typedef union BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_p[1];
	uint32_t _bc_sup_pktdrop_cnt_p;
} BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_t;

#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_CLR(r) (r).bc_sup_pktdrop_cnt_p[0] = 0
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_SET(r,d) (r).bc_sup_pktdrop_cnt_p[0] = d
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_GET(r) (r).bc_sup_pktdrop_cnt_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_p[0])
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_p[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_P.
 *
 */
#define BCM89500_A0_READ_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr,(r._bc_sup_pktdrop_cnt_p),4)
#define BCM89500_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr,&(r._bc_sup_pktdrop_cnt_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_Pr BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr
#define BC_SUP_PKTDROP_CNT_Pr_SIZE BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE
typedef BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_t BC_SUP_PKTDROP_CNT_Pr_t;
#define BC_SUP_PKTDROP_CNT_Pr_CLR BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_CLR
#define BC_SUP_PKTDROP_CNT_Pr_SET BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_SET
#define BC_SUP_PKTDROP_CNT_Pr_GET BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_Pr BCM89500_A0_READ_BC_SUP_PKTDROP_CNT_Pr
#define WRITE_BC_SUP_PKTDROP_CNT_Pr BCM89500_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BC_SUP_PKTDROP_CNT_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 Suppressed Packet Drop Counter Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r 0x0000416c

#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_P7.
 *
 */
typedef union BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_p7[1];
	uint32_t _bc_sup_pktdrop_cnt_p7;
} BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_t;

#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_CLR(r) (r).bc_sup_pktdrop_cnt_p7[0] = 0
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_SET(r,d) (r).bc_sup_pktdrop_cnt_p7[0] = d
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_GET(r) (r).bc_sup_pktdrop_cnt_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_p7[0])
#define BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_p7[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_P7.
 *
 */
#define BCM89500_A0_READ_BC_SUP_PKTDROP_CNT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r,(r._bc_sup_pktdrop_cnt_p7),4)
#define BCM89500_A0_WRITE_BC_SUP_PKTDROP_CNT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r,&(r._bc_sup_pktdrop_cnt_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_P7r BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r
#define BC_SUP_PKTDROP_CNT_P7r_SIZE BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_SIZE
typedef BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_t BC_SUP_PKTDROP_CNT_P7r_t;
#define BC_SUP_PKTDROP_CNT_P7r_CLR BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_CLR
#define BC_SUP_PKTDROP_CNT_P7r_SET BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_SET
#define BC_SUP_PKTDROP_CNT_P7r_GET BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_GET
#define BC_SUP_PKTDROP_CNT_P7r_PK_DROP_CNTf_GET BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_P7r_PK_DROP_CNTf_SET BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_P7r BCM89500_A0_READ_BC_SUP_PKTDROP_CNT_P7r
#define WRITE_BC_SUP_PKTDROP_CNT_P7r BCM89500_A0_WRITE_BC_SUP_PKTDROP_CNT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BC_SUP_PKTDROP_CNT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BC_SUP_RATECTRL_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 488K bytes
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 488K bytes
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr 0x00004130

#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_IMP.
 *
 */
typedef union BCM89500_A0_BC_SUP_RATECTRL_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_imp[1];
	uint32_t _bc_sup_ratectrl_imp;
} BCM89500_A0_BC_SUP_RATECTRL_IMPr_t;

#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_CLR(r) (r).bc_sup_ratectrl_imp[0] = 0
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_SET(r,d) (r).bc_sup_ratectrl_imp[0] = d
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_GET(r) (r).bc_sup_ratectrl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_imp[0]) & 0xff)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 8) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 11) & 0xff)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 19) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 22) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 23) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 24) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 25) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 26) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 27) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 28) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 29) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_IMP.
 *
 */
#define BCM89500_A0_READ_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_BC_SUP_RATECTRL_IMPr,(r._bc_sup_ratectrl_imp),4)
#define BCM89500_A0_WRITE_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_BC_SUP_RATECTRL_IMPr,&(r._bc_sup_ratectrl_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_IMPr BCM89500_A0_BC_SUP_RATECTRL_IMPr
#define BC_SUP_RATECTRL_IMPr_SIZE BCM89500_A0_BC_SUP_RATECTRL_IMPr_SIZE
typedef BCM89500_A0_BC_SUP_RATECTRL_IMPr_t BC_SUP_RATECTRL_IMPr_t;
#define BC_SUP_RATECTRL_IMPr_CLR BCM89500_A0_BC_SUP_RATECTRL_IMPr_CLR
#define BC_SUP_RATECTRL_IMPr_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_SET
#define BC_SUP_RATECTRL_IMPr_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_RESERVEDf_GET BCM89500_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_GET
#define BC_SUP_RATECTRL_IMPr_RESERVEDf_SET BCM89500_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_IMPr BCM89500_A0_READ_BC_SUP_RATECTRL_IMPr
#define WRITE_BC_SUP_RATECTRL_IMPr BCM89500_A0_WRITE_BC_SUP_RATECTRL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BC_SUP_RATECTRL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BC_SUP_RATECTRL_P
 * BLOCKS:   GPIC0
 * DESC:     Port N Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 488K bytes
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 488K bytes
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.1:Enable,0:Disable.
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_BC_SUP_RATECTRL_Pr 0x00004110

#define BCM89500_A0_BC_SUP_RATECTRL_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_P.
 *
 */
typedef union BCM89500_A0_BC_SUP_RATECTRL_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_p[1];
	uint32_t _bc_sup_ratectrl_p;
} BCM89500_A0_BC_SUP_RATECTRL_Pr_t;

#define BCM89500_A0_BC_SUP_RATECTRL_Pr_CLR(r) (r).bc_sup_ratectrl_p[0] = 0
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_SET(r,d) (r).bc_sup_ratectrl_p[0] = d
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_GET(r) (r).bc_sup_ratectrl_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_p[0]) & 0xff)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 8) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 11) & 0xff)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 19) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 22) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 23) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 24) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 25) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 26) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 27) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 28) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 29) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_P.
 *
 */
#define BCM89500_A0_READ_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BC_SUP_RATECTRL_Pr,(r._bc_sup_ratectrl_p),4)
#define BCM89500_A0_WRITE_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BC_SUP_RATECTRL_Pr,&(r._bc_sup_ratectrl_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_Pr BCM89500_A0_BC_SUP_RATECTRL_Pr
#define BC_SUP_RATECTRL_Pr_SIZE BCM89500_A0_BC_SUP_RATECTRL_Pr_SIZE
typedef BCM89500_A0_BC_SUP_RATECTRL_Pr_t BC_SUP_RATECTRL_Pr_t;
#define BC_SUP_RATECTRL_Pr_CLR BCM89500_A0_BC_SUP_RATECTRL_Pr_CLR
#define BC_SUP_RATECTRL_Pr_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_SET
#define BC_SUP_RATECTRL_Pr_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_Pr_RESERVEDf_GET BCM89500_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_GET
#define BC_SUP_RATECTRL_Pr_RESERVEDf_SET BCM89500_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_Pr BCM89500_A0_READ_BC_SUP_RATECTRL_Pr
#define WRITE_BC_SUP_RATECTRL_Pr BCM89500_A0_WRITE_BC_SUP_RATECTRL_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BC_SUP_RATECTRL_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BC_SUP_RATECTRL_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 Recive Rate Control Registers (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 488K bytes
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 4K bytes3'b001: 8K bytes3'b010: 16K bytes3'b011: 32K bytes3'b100: 64K bytesothers: 488K bytes
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_BC_SUP_RATECTRL_P7r 0x0000412c

#define BCM89500_A0_BC_SUP_RATECTRL_P7r_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_P7.
 *
 */
typedef union BCM89500_A0_BC_SUP_RATECTRL_P7r_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_p7[1];
	uint32_t _bc_sup_ratectrl_p7;
} BCM89500_A0_BC_SUP_RATECTRL_P7r_t;

#define BCM89500_A0_BC_SUP_RATECTRL_P7r_CLR(r) (r).bc_sup_ratectrl_p7[0] = 0
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_SET(r,d) (r).bc_sup_ratectrl_p7[0] = d
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_GET(r) (r).bc_sup_ratectrl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_p7[0]) & 0xff)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 8) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 11) & 0xff)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 19) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 22) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 23) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 24) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 25) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 26) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 27) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 28) & 0x1)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_p7[0]) >> 29) & 0x7)
#define BCM89500_A0_BC_SUP_RATECTRL_P7r_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_p7[0]=(((r).bc_sup_ratectrl_p7[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_P7.
 *
 */
#define BCM89500_A0_READ_BC_SUP_RATECTRL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_BC_SUP_RATECTRL_P7r,(r._bc_sup_ratectrl_p7),4)
#define BCM89500_A0_WRITE_BC_SUP_RATECTRL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_BC_SUP_RATECTRL_P7r,&(r._bc_sup_ratectrl_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_P7r BCM89500_A0_BC_SUP_RATECTRL_P7r
#define BC_SUP_RATECTRL_P7r_SIZE BCM89500_A0_BC_SUP_RATECTRL_P7r_SIZE
typedef BCM89500_A0_BC_SUP_RATECTRL_P7r_t BC_SUP_RATECTRL_P7r_t;
#define BC_SUP_RATECTRL_P7r_CLR BCM89500_A0_BC_SUP_RATECTRL_P7r_CLR
#define BC_SUP_RATECTRL_P7r_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_SET
#define BC_SUP_RATECTRL_P7r_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_GET
#define BC_SUP_RATECTRL_P7r_BUCKET0_REF_CNTf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_P7r_BUCKET0_REF_CNTf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_P7r_BUCKET0_SIZEf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_P7r_BUCKET0_SIZEf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_P7r_BUCKET1_REF_CNTf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_P7r_BUCKET1_REF_CNTf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_P7r_BUCKET1_SIZEf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_P7r_BUCKET1_SIZEf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_P7r_EN_BUCKET0f_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_P7r_EN_BUCKET0f_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_P7r_EN_BUCKET1f_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_P7r_EN_BUCKET1f_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_P7r_EN_DLF_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_P7r_EN_DLF_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_P7r_EN_MCAST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_P7r_EN_MCAST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_P7r_EN_BCAST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_P7r_EN_BCAST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_P7r_EN_RSV_MLTCST_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_P7r_EN_RSV_MLTCST_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_P7r_EN_STORM_SUPf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_P7r_EN_STORM_SUPf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_P7r_RESERVEDf_GET BCM89500_A0_BC_SUP_RATECTRL_P7r_RESERVEDf_GET
#define BC_SUP_RATECTRL_P7r_RESERVEDf_SET BCM89500_A0_BC_SUP_RATECTRL_P7r_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_P7r BCM89500_A0_READ_BC_SUP_RATECTRL_P7r
#define WRITE_BC_SUP_RATECTRL_P7r BCM89500_A0_WRITE_BC_SUP_RATECTRL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BC_SUP_RATECTRL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BIST_STS
 * BLOCKS:   SYS
 * DESC:     BIST Status Register
 * SIZE:     48
 * FIELDS:
 *     LV_MBIST_STATUS  LV MBIST StatusOnce LV MBIST is enabled, this field is 6'h3f, when the MBIST is done(around 4ms), this field contains the status of MBIST, when it is 6'h0, it means the MBIST is all pass.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_BIST_STSr 0x00000146

#define BCM89500_A0_BIST_STSr_SIZE 6

/*
 * This structure should be used to declare and program BIST_STS.
 *
 */
typedef union BCM89500_A0_BIST_STSr_s {
	uint32_t v[2];
	uint32_t bist_sts[2];
	uint32_t _bist_sts;
} BCM89500_A0_BIST_STSr_t;

#define BCM89500_A0_BIST_STSr_CLR(r) CDK_MEMSET(&((r)._bist_sts), 0, sizeof(BCM89500_A0_BIST_STSr_t))
#define BCM89500_A0_BIST_STSr_SET(r,i,d) (r).bist_sts[i] = d
#define BCM89500_A0_BIST_STSr_GET(r,i) (r).bist_sts[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BIST_STSr_LV_MBIST_STATUSf_GET(r) (((r).bist_sts[0]) & 0x3f)
#define BCM89500_A0_BIST_STSr_LV_MBIST_STATUSf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_BIST_STSr_RESERVEDf_GET(r,a) cdk_field_get((r).bist_sts,6,47,a)
#define BCM89500_A0_BIST_STSr_RESERVEDf_SET(r,a) cdk_field_set((r).bist_sts,6,47,a)

/*
 * These macros can be used to access BIST_STS.
 *
 */
#define BCM89500_A0_READ_BIST_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_BIST_STSr,(r._bist_sts),6)
#define BCM89500_A0_WRITE_BIST_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_BIST_STSr,&(r._bist_sts),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STSr BCM89500_A0_BIST_STSr
#define BIST_STSr_SIZE BCM89500_A0_BIST_STSr_SIZE
typedef BCM89500_A0_BIST_STSr_t BIST_STSr_t;
#define BIST_STSr_CLR BCM89500_A0_BIST_STSr_CLR
#define BIST_STSr_SET BCM89500_A0_BIST_STSr_SET
#define BIST_STSr_GET BCM89500_A0_BIST_STSr_GET
#define BIST_STSr_LV_MBIST_STATUSf_GET BCM89500_A0_BIST_STSr_LV_MBIST_STATUSf_GET
#define BIST_STSr_LV_MBIST_STATUSf_SET BCM89500_A0_BIST_STSr_LV_MBIST_STATUSf_SET
#define BIST_STSr_RESERVEDf_GET BCM89500_A0_BIST_STSr_RESERVEDf_GET
#define BIST_STSr_RESERVEDf_SET BCM89500_A0_BIST_STSr_RESERVEDf_SET
#define READ_BIST_STSr BCM89500_A0_READ_BIST_STSr
#define WRITE_BIST_STSr BCM89500_A0_WRITE_BIST_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BIST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BONDING_PAD_STATUS
 * BLOCKS:   SYS
 * DESC:     Bonding PAD status Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     BOND_PAD         2'b00: BCM89500, select RGMIIMII/RvMII through mii3_mode (4 BR-PHY + 3 MII)2'b01: BCM89501, select BR/TX100 PHY. (5 BR-PHY + 2 MII)2'b11: BCM89200, select BR/TX100 PHY and one BR-PHY (2 BR-PHY + 2 MII)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_BONDING_PAD_STATUSr 0x000000ee

#define BCM89500_A0_BONDING_PAD_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program BONDING_PAD_STATUS.
 *
 */
typedef union BCM89500_A0_BONDING_PAD_STATUSr_s {
	uint32_t v[1];
	uint32_t bonding_pad_status[1];
	uint32_t _bonding_pad_status;
} BCM89500_A0_BONDING_PAD_STATUSr_t;

#define BCM89500_A0_BONDING_PAD_STATUSr_CLR(r) (r).bonding_pad_status[0] = 0
#define BCM89500_A0_BONDING_PAD_STATUSr_SET(r,d) (r).bonding_pad_status[0] = d
#define BCM89500_A0_BONDING_PAD_STATUSr_GET(r) (r).bonding_pad_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BONDING_PAD_STATUSr_BOND_PADf_GET(r) (((r).bonding_pad_status[0]) & 0x3)
#define BCM89500_A0_BONDING_PAD_STATUSr_BOND_PADf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_BONDING_PAD_STATUSr_RESERVEDf_GET(r) ((((r).bonding_pad_status[0]) >> 2) & 0x3f)
#define BCM89500_A0_BONDING_PAD_STATUSr_RESERVEDf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access BONDING_PAD_STATUS.
 *
 */
#define BCM89500_A0_READ_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_BONDING_PAD_STATUSr,(r._bonding_pad_status),1)
#define BCM89500_A0_WRITE_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_BONDING_PAD_STATUSr,&(r._bonding_pad_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BONDING_PAD_STATUSr BCM89500_A0_BONDING_PAD_STATUSr
#define BONDING_PAD_STATUSr_SIZE BCM89500_A0_BONDING_PAD_STATUSr_SIZE
typedef BCM89500_A0_BONDING_PAD_STATUSr_t BONDING_PAD_STATUSr_t;
#define BONDING_PAD_STATUSr_CLR BCM89500_A0_BONDING_PAD_STATUSr_CLR
#define BONDING_PAD_STATUSr_SET BCM89500_A0_BONDING_PAD_STATUSr_SET
#define BONDING_PAD_STATUSr_GET BCM89500_A0_BONDING_PAD_STATUSr_GET
#define BONDING_PAD_STATUSr_BOND_PADf_GET BCM89500_A0_BONDING_PAD_STATUSr_BOND_PADf_GET
#define BONDING_PAD_STATUSr_BOND_PADf_SET BCM89500_A0_BONDING_PAD_STATUSr_BOND_PADf_SET
#define BONDING_PAD_STATUSr_RESERVEDf_GET BCM89500_A0_BONDING_PAD_STATUSr_RESERVEDf_GET
#define BONDING_PAD_STATUSr_RESERVEDf_SET BCM89500_A0_BONDING_PAD_STATUSr_RESERVEDf_SET
#define READ_BONDING_PAD_STATUSr BCM89500_A0_READ_BONDING_PAD_STATUSr
#define WRITE_BONDING_PAD_STATUSr BCM89500_A0_WRITE_BONDING_PAD_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BONDING_PAD_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     BPDU Multicast Address 1.(not release to customer).Defaults to the 802.1 defined reserved multicast address for the Bridge Group #Address. Programming to an alternate value allows support of proprietary #protocols in place of the normal Spanning Tree Protocol. Frames with a matching #DA to this address will be forwarded only to the designated management port #(IMP).
 *
 ******************************************************************************/
#define BCM89500_A0_BPDU_MCADDRr 0x00000404

#define BCM89500_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 *
 */
typedef union BCM89500_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM89500_A0_BPDU_MCADDRr_t;

#define BCM89500_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM89500_A0_BPDU_MCADDRr_t))
#define BCM89500_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM89500_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM89500_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 *
 */
#define BCM89500_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM89500_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM89500_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM89500_A0_BPDU_MCADDRr_SIZE
typedef BCM89500_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM89500_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM89500_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM89500_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM89500_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM89500_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM89500_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM89500_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BPDU_MCADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BRCM_HDR_CTRL
 * BLOCKS:   SYS
 * DESC:     BRCM Header Control Register
 * SIZE:     8
 * FIELDS:
 *     BRCM_HDR_EN      Broadcom Header enablebit 2: enable BRCM header for Port7 (polar feature)bit 1: enable BRCM header for Port5bit 0: enable BRCM header for Port81: Additional header information is inserted into the Original frame, between SA field and Type/Length field. The tag includes the BRCM header field.0: Without additional header information.Default value is determined by hw_fwdg_en strap pin.When hw_fwdg_en = 1, default 3'b000When hw_fwdg_en = 0, default 3'b001 (only port-8 is enabled)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_BRCM_HDR_CTRLr 0x00000203

#define BCM89500_A0_BRCM_HDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program BRCM_HDR_CTRL.
 *
 */
typedef union BCM89500_A0_BRCM_HDR_CTRLr_s {
	uint32_t v[1];
	uint32_t brcm_hdr_ctrl[1];
	uint32_t _brcm_hdr_ctrl;
} BCM89500_A0_BRCM_HDR_CTRLr_t;

#define BCM89500_A0_BRCM_HDR_CTRLr_CLR(r) (r).brcm_hdr_ctrl[0] = 0
#define BCM89500_A0_BRCM_HDR_CTRLr_SET(r,d) (r).brcm_hdr_ctrl[0] = d
#define BCM89500_A0_BRCM_HDR_CTRLr_GET(r) (r).brcm_hdr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET(r) (((r).brcm_hdr_ctrl[0]) & 0x7)
#define BCM89500_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_BRCM_HDR_CTRLr_RESERVEDf_GET(r) ((((r).brcm_hdr_ctrl[0]) >> 3) & 0x1f)
#define BCM89500_A0_BRCM_HDR_CTRLr_RESERVEDf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access BRCM_HDR_CTRL.
 *
 */
#define BCM89500_A0_READ_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_BRCM_HDR_CTRLr,(r._brcm_hdr_ctrl),1)
#define BCM89500_A0_WRITE_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_BRCM_HDR_CTRLr,&(r._brcm_hdr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BRCM_HDR_CTRLr BCM89500_A0_BRCM_HDR_CTRLr
#define BRCM_HDR_CTRLr_SIZE BCM89500_A0_BRCM_HDR_CTRLr_SIZE
typedef BCM89500_A0_BRCM_HDR_CTRLr_t BRCM_HDR_CTRLr_t;
#define BRCM_HDR_CTRLr_CLR BCM89500_A0_BRCM_HDR_CTRLr_CLR
#define BRCM_HDR_CTRLr_SET BCM89500_A0_BRCM_HDR_CTRLr_SET
#define BRCM_HDR_CTRLr_GET BCM89500_A0_BRCM_HDR_CTRLr_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET BCM89500_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET BCM89500_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET
#define BRCM_HDR_CTRLr_RESERVEDf_GET BCM89500_A0_BRCM_HDR_CTRLr_RESERVEDf_GET
#define BRCM_HDR_CTRLr_RESERVEDf_SET BCM89500_A0_BRCM_HDR_CTRLr_RESERVEDf_SET
#define READ_BRCM_HDR_CTRLr BCM89500_A0_READ_BRCM_HDR_CTRLr
#define WRITE_BRCM_HDR_CTRLr BCM89500_A0_WRITE_BRCM_HDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BRCM_HDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_AUX_CTL
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG_SEL   000 = Normal operation010 = Power/MII Control100 = Misc Test 1111 = Misc Control
 *     SHADOW_REG_CTRL  Power/MII Control:bit 15-6 : reservedbit 5 : super isolate, isolate mode with no link pulses transmitted.bit 4-3 : reservedMisc Test 1:bit 15 : remote loopback enablebit 14-4 : reservedbit 3 : transmit half amplitude, all speeds.Misc Control:bit 15 : write enablebit 14-12 : shadow register read selectorbit 11 : packet counter mode (1=count packets recieved, 0=count packets transmitted)bit 10 : bypass wirespeed timerbit 9 : force auto mdix modebit 8-3 : reservde
 *
 ******************************************************************************/
#define BCM89500_A0_BR_AUX_CTLr 0x00001030

#define BCM89500_A0_BR_AUX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program BR_AUX_CTL.
 *
 */
typedef union BCM89500_A0_BR_AUX_CTLr_s {
	uint32_t v[1];
	uint32_t br_aux_ctl[1];
	uint32_t _br_aux_ctl;
} BCM89500_A0_BR_AUX_CTLr_t;

#define BCM89500_A0_BR_AUX_CTLr_CLR(r) (r).br_aux_ctl[0] = 0
#define BCM89500_A0_BR_AUX_CTLr_SET(r,d) (r).br_aux_ctl[0] = d
#define BCM89500_A0_BR_AUX_CTLr_GET(r) (r).br_aux_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_SELf_GET(r) (((r).br_aux_ctl[0]) & 0x7)
#define BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_SELf_SET(r,f) (r).br_aux_ctl[0]=(((r).br_aux_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_CTRLf_GET(r) ((((r).br_aux_ctl[0]) >> 3) & 0x1fff)
#define BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_CTRLf_SET(r,f) (r).br_aux_ctl[0]=(((r).br_aux_ctl[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access BR_AUX_CTL.
 *
 */
#define BCM89500_A0_READ_BR_AUX_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_AUX_CTLr,(r._br_aux_ctl),2)
#define BCM89500_A0_WRITE_BR_AUX_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_AUX_CTLr,&(r._br_aux_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_AUX_CTLr BCM89500_A0_BR_AUX_CTLr
#define BR_AUX_CTLr_SIZE BCM89500_A0_BR_AUX_CTLr_SIZE
typedef BCM89500_A0_BR_AUX_CTLr_t BR_AUX_CTLr_t;
#define BR_AUX_CTLr_CLR BCM89500_A0_BR_AUX_CTLr_CLR
#define BR_AUX_CTLr_SET BCM89500_A0_BR_AUX_CTLr_SET
#define BR_AUX_CTLr_GET BCM89500_A0_BR_AUX_CTLr_GET
#define BR_AUX_CTLr_SHADOW_REG_SELf_GET BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_SELf_GET
#define BR_AUX_CTLr_SHADOW_REG_SELf_SET BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_SELf_SET
#define BR_AUX_CTLr_SHADOW_REG_CTRLf_GET BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_CTRLf_GET
#define BR_AUX_CTLr_SHADOW_REG_CTRLf_SET BCM89500_A0_BR_AUX_CTLr_SHADOW_REG_CTRLf_SET
#define READ_BR_AUX_CTLr BCM89500_A0_READ_BR_AUX_CTLr
#define WRITE_BR_AUX_CTLr BCM89500_A0_WRITE_BR_AUX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_AUX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_EXP_ACCESS
 * BLOCKS:   GPIC0
 * DESC:     Expansion Access Register
 * SIZE:     16
 * FIELDS:
 *     EXP_ADDR         Sets the Expansion register number accessed when read/write register 0x2a.8'h00 : to access transmit packet counter8'h70 : to access soft-reset8'h90-92 : to access BroadReach LRE misc control8'h9a : to access BroadReach LRE Register control (Not2Release)8'hf5 : to access time sync control and status
 *     EXP_SEL          Write 0xf to access Expansion registers.
 *     RESERVED         Write as 0, ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_EXP_ACCESSr 0x0000102e

#define BCM89500_A0_BR_EXP_ACCESSr_SIZE 2

/*
 * This structure should be used to declare and program BR_EXP_ACCESS.
 *
 */
typedef union BCM89500_A0_BR_EXP_ACCESSr_s {
	uint32_t v[1];
	uint32_t br_exp_access[1];
	uint32_t _br_exp_access;
} BCM89500_A0_BR_EXP_ACCESSr_t;

#define BCM89500_A0_BR_EXP_ACCESSr_CLR(r) (r).br_exp_access[0] = 0
#define BCM89500_A0_BR_EXP_ACCESSr_SET(r,d) (r).br_exp_access[0] = d
#define BCM89500_A0_BR_EXP_ACCESSr_GET(r) (r).br_exp_access[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_EXP_ACCESSr_EXP_ADDRf_GET(r) (((r).br_exp_access[0]) & 0xff)
#define BCM89500_A0_BR_EXP_ACCESSr_EXP_ADDRf_SET(r,f) (r).br_exp_access[0]=(((r).br_exp_access[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BR_EXP_ACCESSr_EXP_SELf_GET(r) ((((r).br_exp_access[0]) >> 8) & 0xf)
#define BCM89500_A0_BR_EXP_ACCESSr_EXP_SELf_SET(r,f) (r).br_exp_access[0]=(((r).br_exp_access[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_BR_EXP_ACCESSr_RESERVEDf_GET(r) ((((r).br_exp_access[0]) >> 12) & 0xf)
#define BCM89500_A0_BR_EXP_ACCESSr_RESERVEDf_SET(r,f) (r).br_exp_access[0]=(((r).br_exp_access[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access BR_EXP_ACCESS.
 *
 */
#define BCM89500_A0_READ_BR_EXP_ACCESSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_EXP_ACCESSr,(r._br_exp_access),2)
#define BCM89500_A0_WRITE_BR_EXP_ACCESSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_EXP_ACCESSr,&(r._br_exp_access),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_EXP_ACCESSr BCM89500_A0_BR_EXP_ACCESSr
#define BR_EXP_ACCESSr_SIZE BCM89500_A0_BR_EXP_ACCESSr_SIZE
typedef BCM89500_A0_BR_EXP_ACCESSr_t BR_EXP_ACCESSr_t;
#define BR_EXP_ACCESSr_CLR BCM89500_A0_BR_EXP_ACCESSr_CLR
#define BR_EXP_ACCESSr_SET BCM89500_A0_BR_EXP_ACCESSr_SET
#define BR_EXP_ACCESSr_GET BCM89500_A0_BR_EXP_ACCESSr_GET
#define BR_EXP_ACCESSr_EXP_ADDRf_GET BCM89500_A0_BR_EXP_ACCESSr_EXP_ADDRf_GET
#define BR_EXP_ACCESSr_EXP_ADDRf_SET BCM89500_A0_BR_EXP_ACCESSr_EXP_ADDRf_SET
#define BR_EXP_ACCESSr_EXP_SELf_GET BCM89500_A0_BR_EXP_ACCESSr_EXP_SELf_GET
#define BR_EXP_ACCESSr_EXP_SELf_SET BCM89500_A0_BR_EXP_ACCESSr_EXP_SELf_SET
#define BR_EXP_ACCESSr_RESERVEDf_GET BCM89500_A0_BR_EXP_ACCESSr_RESERVEDf_GET
#define BR_EXP_ACCESSr_RESERVEDf_SET BCM89500_A0_BR_EXP_ACCESSr_RESERVEDf_SET
#define READ_BR_EXP_ACCESSr BCM89500_A0_READ_BR_EXP_ACCESSr
#define WRITE_BR_EXP_ACCESSr BCM89500_A0_WRITE_BR_EXP_ACCESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_EXP_ACCESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_EXP_DATA
 * BLOCKS:   GPIC0
 * DESC:     Expansion Read/Write Register
 * SIZE:     16
 * FIELDS:
 *     EXP_DATA         Expansion register read/write data selected by 0x2e, bit7-0.transmit packet counter (0x2e, bit7-0=8'h00):bit 15- 0 : Returns the number of packets transmitted/received depending on the value of reg 0x30-7.11.  Freezes at FFFFh. Cleared by read.soft-reset (0x2e, bit7-0=8'h70):bit 15-1 : reservedbit 0 : soft-resetBroadReach LRE Misc Control (0x2e, bit7-0=8'h90):bit 15 : Enable digital high pass filter. (valid when Exp_Reg91[15] is enabled)bit 14-2 : reservedbit 1 : force BroadReach transceiver link up.bit 0 : capable of BroadReach functionBroadReach LRE Misc Control (0x2e, bit7-0=8'h91):bit 15 : Overwrite the decision of enabling of digital HPF through Exp_Reg90[15]bit 14-12 : reservedbit 11-9 : BroadReach PGA gain controlbit 8-4 : reserved (must write value 5'b00010).bit 3-0 : reserved (must write value 4'b1000).BroadReach LRE Misc Control (0x2e, bit7-0=8'h92):bit 15-13 : reservedbit 12-11 : Shape BR transmitter's waveform.bit 10-6 : reservedbit 5 : reserved (must write value 1).bit 4-0 : reservedBroadReach LRE Register Control (0x2e, bit7-0=8'h9a):(Not2Release)bit 15 : enable LRE register access overridebit 14 : LRE register override value (1=force access to IEEE register, 0=force access to BR LRE registers)bit 13 : LRE register status (1=BR LRE registers are accessable, 0=IEEE registers are accessable)bit 12-0 : reservedTime Sync (0x2e, bit7-0=8'hf5):bit 15-7 : reservedbit 6 : tx sop error statusbit 5 : Use txen as tx sop (1=use txen as tx sop, 0=use SFD as tx sop)bit 4 : rx sop error statusbit 3 : rx sop assertion option (1=assert rx sop is SFD is not detected but 16 bytes data have been received, 0=no rx sop if SFD in nit detected within the first 16 bytes)bit 2 : use rxdv as rx sop. (1=use rxdv as rx sop, 0=use SFD as rx sop)bit 1 : recovery clock selectbit 0 : time sync enable
 *
 ******************************************************************************/
#define BCM89500_A0_BR_EXP_DATAr 0x0000102a

#define BCM89500_A0_BR_EXP_DATAr_SIZE 2

/*
 * This structure should be used to declare and program BR_EXP_DATA.
 *
 */
typedef union BCM89500_A0_BR_EXP_DATAr_s {
	uint32_t v[1];
	uint32_t br_exp_data[1];
	uint32_t _br_exp_data;
} BCM89500_A0_BR_EXP_DATAr_t;

#define BCM89500_A0_BR_EXP_DATAr_CLR(r) (r).br_exp_data[0] = 0
#define BCM89500_A0_BR_EXP_DATAr_SET(r,d) (r).br_exp_data[0] = d
#define BCM89500_A0_BR_EXP_DATAr_GET(r) (r).br_exp_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_EXP_DATAr_EXP_DATAf_GET(r) (((r).br_exp_data[0]) & 0xffff)
#define BCM89500_A0_BR_EXP_DATAr_EXP_DATAf_SET(r,f) (r).br_exp_data[0]=(((r).br_exp_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BR_EXP_DATA.
 *
 */
#define BCM89500_A0_READ_BR_EXP_DATAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_EXP_DATAr,(r._br_exp_data),2)
#define BCM89500_A0_WRITE_BR_EXP_DATAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_EXP_DATAr,&(r._br_exp_data),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_EXP_DATAr BCM89500_A0_BR_EXP_DATAr
#define BR_EXP_DATAr_SIZE BCM89500_A0_BR_EXP_DATAr_SIZE
typedef BCM89500_A0_BR_EXP_DATAr_t BR_EXP_DATAr_t;
#define BR_EXP_DATAr_CLR BCM89500_A0_BR_EXP_DATAr_CLR
#define BR_EXP_DATAr_SET BCM89500_A0_BR_EXP_DATAr_SET
#define BR_EXP_DATAr_GET BCM89500_A0_BR_EXP_DATAr_GET
#define BR_EXP_DATAr_EXP_DATAf_GET BCM89500_A0_BR_EXP_DATAr_EXP_DATAf_GET
#define BR_EXP_DATAr_EXP_DATAf_SET BCM89500_A0_BR_EXP_DATAr_EXP_DATAf_SET
#define READ_BR_EXP_DATAr BCM89500_A0_READ_BR_EXP_DATAr
#define WRITE_BR_EXP_DATAr BCM89500_A0_WRITE_BR_EXP_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_EXP_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERROR_COUNT Number of idle errors since last read
 *     REMOTE_RECEIVER_STATUS 1 = remote receiver status OK 0 = remote receiver status not OK
 *     LOCAL_RECEIVER_STATUS 1 = local receiver status OK 0 = local receiver status not OK
 *     RESERVED         Write as 0, ignore on Read
 *
 ******************************************************************************/
#define BCM89500_A0_BR_EXT_STSr 0x0000101e

#define BCM89500_A0_BR_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program BR_EXT_STS.
 *
 */
typedef union BCM89500_A0_BR_EXT_STSr_s {
	uint32_t v[1];
	uint32_t br_ext_sts[1];
	uint32_t _br_ext_sts;
} BCM89500_A0_BR_EXT_STSr_t;

#define BCM89500_A0_BR_EXT_STSr_CLR(r) (r).br_ext_sts[0] = 0
#define BCM89500_A0_BR_EXT_STSr_SET(r,d) (r).br_ext_sts[0] = d
#define BCM89500_A0_BR_EXT_STSr_GET(r) (r).br_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_EXT_STSr_IDLE_ERROR_COUNTf_GET(r) (((r).br_ext_sts[0]) & 0xff)
#define BCM89500_A0_BR_EXT_STSr_IDLE_ERROR_COUNTf_SET(r,f) (r).br_ext_sts[0]=(((r).br_ext_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BR_EXT_STSr_REMOTE_RECEIVER_STATUSf_GET(r) ((((r).br_ext_sts[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_EXT_STSr_REMOTE_RECEIVER_STATUSf_SET(r,f) (r).br_ext_sts[0]=(((r).br_ext_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_EXT_STSr_LOCAL_RECEIVER_STATUSf_GET(r) ((((r).br_ext_sts[0]) >> 9) & 0x1)
#define BCM89500_A0_BR_EXT_STSr_LOCAL_RECEIVER_STATUSf_SET(r,f) (r).br_ext_sts[0]=(((r).br_ext_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_BR_EXT_STSr_RESERVEDf_GET(r) ((((r).br_ext_sts[0]) >> 10) & 0x3f)
#define BCM89500_A0_BR_EXT_STSr_RESERVEDf_SET(r,f) (r).br_ext_sts[0]=(((r).br_ext_sts[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access BR_EXT_STS.
 *
 */
#define BCM89500_A0_READ_BR_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_EXT_STSr,(r._br_ext_sts),2)
#define BCM89500_A0_WRITE_BR_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_EXT_STSr,&(r._br_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_EXT_STSr BCM89500_A0_BR_EXT_STSr
#define BR_EXT_STSr_SIZE BCM89500_A0_BR_EXT_STSr_SIZE
typedef BCM89500_A0_BR_EXT_STSr_t BR_EXT_STSr_t;
#define BR_EXT_STSr_CLR BCM89500_A0_BR_EXT_STSr_CLR
#define BR_EXT_STSr_SET BCM89500_A0_BR_EXT_STSr_SET
#define BR_EXT_STSr_GET BCM89500_A0_BR_EXT_STSr_GET
#define BR_EXT_STSr_IDLE_ERROR_COUNTf_GET BCM89500_A0_BR_EXT_STSr_IDLE_ERROR_COUNTf_GET
#define BR_EXT_STSr_IDLE_ERROR_COUNTf_SET BCM89500_A0_BR_EXT_STSr_IDLE_ERROR_COUNTf_SET
#define BR_EXT_STSr_REMOTE_RECEIVER_STATUSf_GET BCM89500_A0_BR_EXT_STSr_REMOTE_RECEIVER_STATUSf_GET
#define BR_EXT_STSr_REMOTE_RECEIVER_STATUSf_SET BCM89500_A0_BR_EXT_STSr_REMOTE_RECEIVER_STATUSf_SET
#define BR_EXT_STSr_LOCAL_RECEIVER_STATUSf_GET BCM89500_A0_BR_EXT_STSr_LOCAL_RECEIVER_STATUSf_GET
#define BR_EXT_STSr_LOCAL_RECEIVER_STATUSf_SET BCM89500_A0_BR_EXT_STSr_LOCAL_RECEIVER_STATUSf_SET
#define BR_EXT_STSr_RESERVEDf_GET BCM89500_A0_BR_EXT_STSr_RESERVEDf_GET
#define BR_EXT_STSr_RESERVEDf_SET BCM89500_A0_BR_EXT_STSr_RESERVEDf_SET
#define READ_BR_EXT_STSr BCM89500_A0_READ_BR_EXT_STSr
#define WRITE_BR_EXT_STSr BCM89500_A0_WRITE_BR_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_FALSE_CARR_CNT
 * BLOCKS:   GPIC0
 * DESC:     False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.
 *     RESERVED         Ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_FALSE_CARR_CNTr 0x00001026

#define BCM89500_A0_BR_FALSE_CARR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program BR_FALSE_CARR_CNT.
 *
 */
typedef union BCM89500_A0_BR_FALSE_CARR_CNTr_s {
	uint32_t v[1];
	uint32_t br_false_carr_cnt[1];
	uint32_t _br_false_carr_cnt;
} BCM89500_A0_BR_FALSE_CARR_CNTr_t;

#define BCM89500_A0_BR_FALSE_CARR_CNTr_CLR(r) (r).br_false_carr_cnt[0] = 0
#define BCM89500_A0_BR_FALSE_CARR_CNTr_SET(r,d) (r).br_false_carr_cnt[0] = d
#define BCM89500_A0_BR_FALSE_CARR_CNTr_GET(r) (r).br_false_carr_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_FALSE_CARR_CNTr_REC_ERR_CNTf_GET(r) (((r).br_false_carr_cnt[0]) & 0xff)
#define BCM89500_A0_BR_FALSE_CARR_CNTr_REC_ERR_CNTf_SET(r,f) (r).br_false_carr_cnt[0]=(((r).br_false_carr_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BR_FALSE_CARR_CNTr_RESERVEDf_GET(r) ((((r).br_false_carr_cnt[0]) >> 8) & 0xff)
#define BCM89500_A0_BR_FALSE_CARR_CNTr_RESERVEDf_SET(r,f) (r).br_false_carr_cnt[0]=(((r).br_false_carr_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access BR_FALSE_CARR_CNT.
 *
 */
#define BCM89500_A0_READ_BR_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_FALSE_CARR_CNTr,(r._br_false_carr_cnt),2)
#define BCM89500_A0_WRITE_BR_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_FALSE_CARR_CNTr,&(r._br_false_carr_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_FALSE_CARR_CNTr BCM89500_A0_BR_FALSE_CARR_CNTr
#define BR_FALSE_CARR_CNTr_SIZE BCM89500_A0_BR_FALSE_CARR_CNTr_SIZE
typedef BCM89500_A0_BR_FALSE_CARR_CNTr_t BR_FALSE_CARR_CNTr_t;
#define BR_FALSE_CARR_CNTr_CLR BCM89500_A0_BR_FALSE_CARR_CNTr_CLR
#define BR_FALSE_CARR_CNTr_SET BCM89500_A0_BR_FALSE_CARR_CNTr_SET
#define BR_FALSE_CARR_CNTr_GET BCM89500_A0_BR_FALSE_CARR_CNTr_GET
#define BR_FALSE_CARR_CNTr_REC_ERR_CNTf_GET BCM89500_A0_BR_FALSE_CARR_CNTr_REC_ERR_CNTf_GET
#define BR_FALSE_CARR_CNTr_REC_ERR_CNTf_SET BCM89500_A0_BR_FALSE_CARR_CNTr_REC_ERR_CNTf_SET
#define BR_FALSE_CARR_CNTr_RESERVEDf_GET BCM89500_A0_BR_FALSE_CARR_CNTr_RESERVEDf_GET
#define BR_FALSE_CARR_CNTr_RESERVEDf_SET BCM89500_A0_BR_FALSE_CARR_CNTr_RESERVEDf_SET
#define READ_BR_FALSE_CARR_CNTr BCM89500_A0_READ_BR_FALSE_CARR_CNTr
#define WRITE_BR_FALSE_CARR_CNTr BCM89500_A0_WRITE_BR_FALSE_CARR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_FALSE_CARR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_INTERRUPT_MSK
 * BLOCKS:   GPIC0
 * DESC:     Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    1 = interrupt masked (status bits still operate normally but do not generate interrupt output)0 = interrupt enabled
 *
 ******************************************************************************/
#define BCM89500_A0_BR_INTERRUPT_MSKr 0x00001036

#define BCM89500_A0_BR_INTERRUPT_MSKr_SIZE 2

/*
 * This structure should be used to declare and program BR_INTERRUPT_MSK.
 *
 */
typedef union BCM89500_A0_BR_INTERRUPT_MSKr_s {
	uint32_t v[1];
	uint32_t br_interrupt_msk[1];
	uint32_t _br_interrupt_msk;
} BCM89500_A0_BR_INTERRUPT_MSKr_t;

#define BCM89500_A0_BR_INTERRUPT_MSKr_CLR(r) (r).br_interrupt_msk[0] = 0
#define BCM89500_A0_BR_INTERRUPT_MSKr_SET(r,d) (r).br_interrupt_msk[0] = d
#define BCM89500_A0_BR_INTERRUPT_MSKr_GET(r) (r).br_interrupt_msk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_INTERRUPT_MSKr_INTERRUPT_MSKf_GET(r) (((r).br_interrupt_msk[0]) & 0xffff)
#define BCM89500_A0_BR_INTERRUPT_MSKr_INTERRUPT_MSKf_SET(r,f) (r).br_interrupt_msk[0]=(((r).br_interrupt_msk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BR_INTERRUPT_MSK.
 *
 */
#define BCM89500_A0_READ_BR_INTERRUPT_MSKr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_INTERRUPT_MSKr,(r._br_interrupt_msk),2)
#define BCM89500_A0_WRITE_BR_INTERRUPT_MSKr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_INTERRUPT_MSKr,&(r._br_interrupt_msk),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_INTERRUPT_MSKr BCM89500_A0_BR_INTERRUPT_MSKr
#define BR_INTERRUPT_MSKr_SIZE BCM89500_A0_BR_INTERRUPT_MSKr_SIZE
typedef BCM89500_A0_BR_INTERRUPT_MSKr_t BR_INTERRUPT_MSKr_t;
#define BR_INTERRUPT_MSKr_CLR BCM89500_A0_BR_INTERRUPT_MSKr_CLR
#define BR_INTERRUPT_MSKr_SET BCM89500_A0_BR_INTERRUPT_MSKr_SET
#define BR_INTERRUPT_MSKr_GET BCM89500_A0_BR_INTERRUPT_MSKr_GET
#define BR_INTERRUPT_MSKr_INTERRUPT_MSKf_GET BCM89500_A0_BR_INTERRUPT_MSKr_INTERRUPT_MSKf_GET
#define BR_INTERRUPT_MSKr_INTERRUPT_MSKf_SET BCM89500_A0_BR_INTERRUPT_MSKr_INTERRUPT_MSKf_SET
#define READ_BR_INTERRUPT_MSKr BCM89500_A0_READ_BR_INTERRUPT_MSKr
#define WRITE_BR_INTERRUPT_MSKr BCM89500_A0_WRITE_BR_INTERRUPT_MSKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_INTERRUPT_MSKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_INTERRUPT_STS
 * BLOCKS:   GPIC0
 * DESC:     Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     CRC_ERROR        1 = CRC error occurred since last read0 = interrupt cleared
 *     LINK_STATUS_CHANGE 1 = link status changed since last read0 = interrupt cleared
 *     LINK_SPEED_CHANGE 1 = link speed changed since last read0 = interrupt cleared
 *     DUPLEX_MODE_CHANGE 1 = duplex mode changed since last read0 = interrupt cleared
 *     LOCAL_RECEIVER_STATUS_CHANGE 1 = local receiver status changed since last read0 = interrupt cleared
 *     REMOTE_RECEIVER_STATUS_CHANGE 1 = remote receiver status changed since last read0 = interrupt cleared
 *     SCRAMBLER_SYNC_ERROR 1 = scrambler synchronization error occurred  since last read0 = interrupt cleared
 *     NEGOTIATED_UNSUPPORTED_HCD 1 = auto-negotiation HCD is not supported by local PHY0 = interrupt cleared
 *     NO_HCD           1 = auto-negotiation returned HCD=none0 = interrupt cleared
 *     HCD_NO_LINK      1 = negotiated HCD did not establish link0 = interrupt cleared
 *     AN_PAGE          1 = page received since last read0 = interrupt cleared
 *     EXCEEDED_LOW_COUNTER_THRESH 1 = value in one or more counters is above 1280 = all counters below 128
 *     EXCEEDED_HIGH_COUNTER_THRESH 1 = value in one or more counters is above 32k0 = all counters below 32k
 *     MDIX_STATUS_CHANGE 1 = MDIX status changed since last read (means that linkpulse or carrier was detected on a different pair than previously detected)0 = interrupt cleared
 *     ILLEGAL_PAIR_SWAP 1 = Illegal pair swap detected0 = interrupt cleared
 *     ENERGY_DETECT_CHANGE 1 = energy detect change since last read0 = interrupt cleared
 *
 ******************************************************************************/
#define BCM89500_A0_BR_INTERRUPT_STSr 0x00001034

#define BCM89500_A0_BR_INTERRUPT_STSr_SIZE 2

/*
 * This structure should be used to declare and program BR_INTERRUPT_STS.
 *
 */
typedef union BCM89500_A0_BR_INTERRUPT_STSr_s {
	uint32_t v[1];
	uint32_t br_interrupt_sts[1];
	uint32_t _br_interrupt_sts;
} BCM89500_A0_BR_INTERRUPT_STSr_t;

#define BCM89500_A0_BR_INTERRUPT_STSr_CLR(r) (r).br_interrupt_sts[0] = 0
#define BCM89500_A0_BR_INTERRUPT_STSr_SET(r,d) (r).br_interrupt_sts[0] = d
#define BCM89500_A0_BR_INTERRUPT_STSr_GET(r) (r).br_interrupt_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_INTERRUPT_STSr_CRC_ERRORf_GET(r) (((r).br_interrupt_sts[0]) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_CRC_ERRORf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_BR_INTERRUPT_STSr_LINK_STATUS_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_LINK_STATUS_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BR_INTERRUPT_STSr_LINK_SPEED_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_LINK_SPEED_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_BR_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 4) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_BR_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 5) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BR_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_GET(r) ((((r).br_interrupt_sts[0]) >> 6) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_BR_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_GET(r) ((((r).br_interrupt_sts[0]) >> 7) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_BR_INTERRUPT_STSr_NO_HCDf_GET(r) ((((r).br_interrupt_sts[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_NO_HCDf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_INTERRUPT_STSr_HCD_NO_LINKf_GET(r) ((((r).br_interrupt_sts[0]) >> 9) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_HCD_NO_LINKf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_BR_INTERRUPT_STSr_AN_PAGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 10) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_AN_PAGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_GET(r) ((((r).br_interrupt_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_GET(r) ((((r).br_interrupt_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_BR_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_BR_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_GET(r) ((((r).br_interrupt_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_GET(r) ((((r).br_interrupt_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_SET(r,f) (r).br_interrupt_sts[0]=(((r).br_interrupt_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_INTERRUPT_STS.
 *
 */
#define BCM89500_A0_READ_BR_INTERRUPT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_INTERRUPT_STSr,(r._br_interrupt_sts),2)
#define BCM89500_A0_WRITE_BR_INTERRUPT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_INTERRUPT_STSr,&(r._br_interrupt_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_INTERRUPT_STSr BCM89500_A0_BR_INTERRUPT_STSr
#define BR_INTERRUPT_STSr_SIZE BCM89500_A0_BR_INTERRUPT_STSr_SIZE
typedef BCM89500_A0_BR_INTERRUPT_STSr_t BR_INTERRUPT_STSr_t;
#define BR_INTERRUPT_STSr_CLR BCM89500_A0_BR_INTERRUPT_STSr_CLR
#define BR_INTERRUPT_STSr_SET BCM89500_A0_BR_INTERRUPT_STSr_SET
#define BR_INTERRUPT_STSr_GET BCM89500_A0_BR_INTERRUPT_STSr_GET
#define BR_INTERRUPT_STSr_CRC_ERRORf_GET BCM89500_A0_BR_INTERRUPT_STSr_CRC_ERRORf_GET
#define BR_INTERRUPT_STSr_CRC_ERRORf_SET BCM89500_A0_BR_INTERRUPT_STSr_CRC_ERRORf_SET
#define BR_INTERRUPT_STSr_LINK_STATUS_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_LINK_STATUS_CHANGEf_GET
#define BR_INTERRUPT_STSr_LINK_STATUS_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_LINK_STATUS_CHANGEf_SET
#define BR_INTERRUPT_STSr_LINK_SPEED_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_LINK_SPEED_CHANGEf_GET
#define BR_INTERRUPT_STSr_LINK_SPEED_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_LINK_SPEED_CHANGEf_SET
#define BR_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_GET
#define BR_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_SET
#define BR_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_GET
#define BR_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_SET
#define BR_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_GET
#define BR_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_SET
#define BR_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_GET BCM89500_A0_BR_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_GET
#define BR_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_SET BCM89500_A0_BR_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_SET
#define BR_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_GET BCM89500_A0_BR_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_GET
#define BR_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_SET BCM89500_A0_BR_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_SET
#define BR_INTERRUPT_STSr_NO_HCDf_GET BCM89500_A0_BR_INTERRUPT_STSr_NO_HCDf_GET
#define BR_INTERRUPT_STSr_NO_HCDf_SET BCM89500_A0_BR_INTERRUPT_STSr_NO_HCDf_SET
#define BR_INTERRUPT_STSr_HCD_NO_LINKf_GET BCM89500_A0_BR_INTERRUPT_STSr_HCD_NO_LINKf_GET
#define BR_INTERRUPT_STSr_HCD_NO_LINKf_SET BCM89500_A0_BR_INTERRUPT_STSr_HCD_NO_LINKf_SET
#define BR_INTERRUPT_STSr_AN_PAGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_AN_PAGEf_GET
#define BR_INTERRUPT_STSr_AN_PAGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_AN_PAGEf_SET
#define BR_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_GET BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_GET
#define BR_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_SET BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_SET
#define BR_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_GET BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_GET
#define BR_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_SET BCM89500_A0_BR_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_SET
#define BR_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_GET
#define BR_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_SET
#define BR_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_GET BCM89500_A0_BR_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_GET
#define BR_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_SET BCM89500_A0_BR_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_SET
#define BR_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_GET BCM89500_A0_BR_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_GET
#define BR_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_SET BCM89500_A0_BR_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_SET
#define READ_BR_INTERRUPT_STSr BCM89500_A0_READ_BR_INTERRUPT_STSr
#define WRITE_BR_INTERRUPT_STSr BCM89500_A0_WRITE_BR_INTERRUPT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_INTERRUPT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_ABILITY
 * BLOCKS:   GPIC0
 * DESC:     LDS Ability Next Page Register
 * SIZE:     16
 * FIELDS:
 *     NEXT_PAGE_MESSAGE For field number is not equal to 0 message content.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_ABILITYr 0x0000100c

#define BCM89500_A0_BR_LDS_ABILITYr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_ABILITY.
 *
 */
typedef union BCM89500_A0_BR_LDS_ABILITYr_s {
	uint32_t v[1];
	uint32_t br_lds_ability[1];
	uint32_t _br_lds_ability;
} BCM89500_A0_BR_LDS_ABILITYr_t;

#define BCM89500_A0_BR_LDS_ABILITYr_CLR(r) (r).br_lds_ability[0] = 0
#define BCM89500_A0_BR_LDS_ABILITYr_SET(r,d) (r).br_lds_ability[0] = d
#define BCM89500_A0_BR_LDS_ABILITYr_GET(r) (r).br_lds_ability[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_ABILITYr_NEXT_PAGE_MESSAGEf_GET(r) (((r).br_lds_ability[0]) & 0xffff)
#define BCM89500_A0_BR_LDS_ABILITYr_NEXT_PAGE_MESSAGEf_SET(r,f) (r).br_lds_ability[0]=(((r).br_lds_ability[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BR_LDS_ABILITY.
 *
 */
#define BCM89500_A0_READ_BR_LDS_ABILITYr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_ABILITYr,(r._br_lds_ability),2)
#define BCM89500_A0_WRITE_BR_LDS_ABILITYr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_ABILITYr,&(r._br_lds_ability),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_ABILITYr BCM89500_A0_BR_LDS_ABILITYr
#define BR_LDS_ABILITYr_SIZE BCM89500_A0_BR_LDS_ABILITYr_SIZE
typedef BCM89500_A0_BR_LDS_ABILITYr_t BR_LDS_ABILITYr_t;
#define BR_LDS_ABILITYr_CLR BCM89500_A0_BR_LDS_ABILITYr_CLR
#define BR_LDS_ABILITYr_SET BCM89500_A0_BR_LDS_ABILITYr_SET
#define BR_LDS_ABILITYr_GET BCM89500_A0_BR_LDS_ABILITYr_GET
#define BR_LDS_ABILITYr_NEXT_PAGE_MESSAGEf_GET BCM89500_A0_BR_LDS_ABILITYr_NEXT_PAGE_MESSAGEf_GET
#define BR_LDS_ABILITYr_NEXT_PAGE_MESSAGEf_SET BCM89500_A0_BR_LDS_ABILITYr_NEXT_PAGE_MESSAGEf_SET
#define READ_BR_LDS_ABILITYr BCM89500_A0_READ_BR_LDS_ABILITYr
#define WRITE_BR_LDS_ABILITYr BCM89500_A0_WRITE_BR_LDS_ABILITYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_ABILITYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_ADVERTISED_ABILITY
 * BLOCKS:   GPIC0
 * DESC:     LDS Advertised Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       write as 0, ignore on read.
 *     PAIR_1_10MBPS    1: Supports 1 pair, 10Mbps
 *     PAIRS_2_10MBPS   1: Supports 2 pairs, 10Mbps
 *     PAIRS_2_100MBPS  1: Supports 2 pairs, 100Mbps
 *     PAIRS_4_100MBPS  1: Supports 4 pairs, 100Mbps
 *     PAIR_1_100MBPS   1: Supports 1 pair, 100Mbps
 *     RESERVED_1       write as 0, ignore on read.
 *     PAUSE_OPERATION  1: Supports PAUSE operation.
 *     ASY_PAUSE_OPERATION 1: Supports Asymmetric PAUSE operation
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr 0x00001008

#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_ADVERTISED_ABILITY.
 *
 */
typedef union BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_s {
	uint32_t v[1];
	uint32_t br_lds_advertised_ability[1];
	uint32_t _br_lds_advertised_ability;
} BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_t;

#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_CLR(r) (r).br_lds_advertised_ability[0] = 0
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_SET(r,d) (r).br_lds_advertised_ability[0] = d
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_GET(r) (r).br_lds_advertised_ability[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_0f_GET(r) (((r).br_lds_advertised_ability[0]) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_0f_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_10MBPSf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 1) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_10MBPSf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_10MBPSf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 2) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_10MBPSf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_100MBPSf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_100MBPSf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_4_100MBPSf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 4) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_4_100MBPSf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_100MBPSf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 5) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_100MBPSf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_1f_GET(r) ((((r).br_lds_advertised_ability[0]) >> 6) & 0xff)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_1f_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAUSE_OPERATIONf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAUSE_OPERATIONf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_ASY_PAUSE_OPERATIONf_GET(r) ((((r).br_lds_advertised_ability[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_ASY_PAUSE_OPERATIONf_SET(r,f) (r).br_lds_advertised_ability[0]=(((r).br_lds_advertised_ability[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_LDS_ADVERTISED_ABILITY.
 *
 */
#define BCM89500_A0_READ_BR_LDS_ADVERTISED_ABILITYr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr,(r._br_lds_advertised_ability),2)
#define BCM89500_A0_WRITE_BR_LDS_ADVERTISED_ABILITYr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr,&(r._br_lds_advertised_ability),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_ADVERTISED_ABILITYr BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr
#define BR_LDS_ADVERTISED_ABILITYr_SIZE BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_SIZE
typedef BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_t BR_LDS_ADVERTISED_ABILITYr_t;
#define BR_LDS_ADVERTISED_ABILITYr_CLR BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_CLR
#define BR_LDS_ADVERTISED_ABILITYr_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_SET
#define BR_LDS_ADVERTISED_ABILITYr_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_GET
#define BR_LDS_ADVERTISED_ABILITYr_RESERVED_0f_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_0f_GET
#define BR_LDS_ADVERTISED_ABILITYr_RESERVED_0f_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_0f_SET
#define BR_LDS_ADVERTISED_ABILITYr_PAIR_1_10MBPSf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_10MBPSf_GET
#define BR_LDS_ADVERTISED_ABILITYr_PAIR_1_10MBPSf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_10MBPSf_SET
#define BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_10MBPSf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_10MBPSf_GET
#define BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_10MBPSf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_10MBPSf_SET
#define BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_100MBPSf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_100MBPSf_GET
#define BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_100MBPSf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_2_100MBPSf_SET
#define BR_LDS_ADVERTISED_ABILITYr_PAIRS_4_100MBPSf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_4_100MBPSf_GET
#define BR_LDS_ADVERTISED_ABILITYr_PAIRS_4_100MBPSf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIRS_4_100MBPSf_SET
#define BR_LDS_ADVERTISED_ABILITYr_PAIR_1_100MBPSf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_100MBPSf_GET
#define BR_LDS_ADVERTISED_ABILITYr_PAIR_1_100MBPSf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAIR_1_100MBPSf_SET
#define BR_LDS_ADVERTISED_ABILITYr_RESERVED_1f_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_1f_GET
#define BR_LDS_ADVERTISED_ABILITYr_RESERVED_1f_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_RESERVED_1f_SET
#define BR_LDS_ADVERTISED_ABILITYr_PAUSE_OPERATIONf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAUSE_OPERATIONf_GET
#define BR_LDS_ADVERTISED_ABILITYr_PAUSE_OPERATIONf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_PAUSE_OPERATIONf_SET
#define BR_LDS_ADVERTISED_ABILITYr_ASY_PAUSE_OPERATIONf_GET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_ASY_PAUSE_OPERATIONf_GET
#define BR_LDS_ADVERTISED_ABILITYr_ASY_PAUSE_OPERATIONf_SET BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr_ASY_PAUSE_OPERATIONf_SET
#define READ_BR_LDS_ADVERTISED_ABILITYr BCM89500_A0_READ_BR_LDS_ADVERTISED_ABILITYr
#define WRITE_BR_LDS_ADVERTISED_ABILITYr BCM89500_A0_WRITE_BR_LDS_ADVERTISED_ABILITYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_ADVERTISED_ABILITYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_ADVERTISED_CONTROL
 * BLOCKS:   GPIC0
 * DESC:     LDS Advertised Control Register
 * SIZE:     16
 * FIELDS:
 *     LOCAL_FIELD_NUMBER The local field number of the next page messages will be sent.
 *     ABILITY_FIELD_UPDATE Register offset 0xc is updated.
 *     PORT_TYPE        This bit is to be used to indicate the preference to operate as MASTER (multiport device) or as SLAVE (single-port device) if the LDS Enable bit is set (0.12).1: Multiport device 0: single-port device
 *     RESERVED         Write as 0, ignore on Read
 *     TEST_MODE        4 pair connection: Transmitter test mode operations are defined in Table 40-7 of IEEE 802.3. spec.2 and 1 pair connection: Test mode operations are defined in LRE spec. section 8 PMA electrical spec.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr 0x0000100a

#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_ADVERTISED_CONTROL.
 *
 */
typedef union BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_s {
	uint32_t v[1];
	uint32_t br_lds_advertised_control[1];
	uint32_t _br_lds_advertised_control;
} BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_t;

#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_CLR(r) (r).br_lds_advertised_control[0] = 0
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_SET(r,d) (r).br_lds_advertised_control[0] = d
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_GET(r) (r).br_lds_advertised_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_LOCAL_FIELD_NUMBERf_GET(r) (((r).br_lds_advertised_control[0]) & 0xff)
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_LOCAL_FIELD_NUMBERf_SET(r,f) (r).br_lds_advertised_control[0]=(((r).br_lds_advertised_control[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_ABILITY_FIELD_UPDATEf_GET(r) ((((r).br_lds_advertised_control[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_ABILITY_FIELD_UPDATEf_SET(r,f) (r).br_lds_advertised_control[0]=(((r).br_lds_advertised_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_PORT_TYPEf_GET(r) ((((r).br_lds_advertised_control[0]) >> 9) & 0x1)
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_PORT_TYPEf_SET(r,f) (r).br_lds_advertised_control[0]=(((r).br_lds_advertised_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_RESERVEDf_GET(r) ((((r).br_lds_advertised_control[0]) >> 10) & 0x7)
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_RESERVEDf_SET(r,f) (r).br_lds_advertised_control[0]=(((r).br_lds_advertised_control[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_TEST_MODEf_GET(r) ((((r).br_lds_advertised_control[0]) >> 13) & 0x7)
#define BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_TEST_MODEf_SET(r,f) (r).br_lds_advertised_control[0]=(((r).br_lds_advertised_control[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access BR_LDS_ADVERTISED_CONTROL.
 *
 */
#define BCM89500_A0_READ_BR_LDS_ADVERTISED_CONTROLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr,(r._br_lds_advertised_control),2)
#define BCM89500_A0_WRITE_BR_LDS_ADVERTISED_CONTROLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr,&(r._br_lds_advertised_control),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_ADVERTISED_CONTROLr BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr
#define BR_LDS_ADVERTISED_CONTROLr_SIZE BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_SIZE
typedef BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_t BR_LDS_ADVERTISED_CONTROLr_t;
#define BR_LDS_ADVERTISED_CONTROLr_CLR BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_CLR
#define BR_LDS_ADVERTISED_CONTROLr_SET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_SET
#define BR_LDS_ADVERTISED_CONTROLr_GET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_GET
#define BR_LDS_ADVERTISED_CONTROLr_LOCAL_FIELD_NUMBERf_GET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_LOCAL_FIELD_NUMBERf_GET
#define BR_LDS_ADVERTISED_CONTROLr_LOCAL_FIELD_NUMBERf_SET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_LOCAL_FIELD_NUMBERf_SET
#define BR_LDS_ADVERTISED_CONTROLr_ABILITY_FIELD_UPDATEf_GET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_ABILITY_FIELD_UPDATEf_GET
#define BR_LDS_ADVERTISED_CONTROLr_ABILITY_FIELD_UPDATEf_SET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_ABILITY_FIELD_UPDATEf_SET
#define BR_LDS_ADVERTISED_CONTROLr_PORT_TYPEf_GET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_PORT_TYPEf_GET
#define BR_LDS_ADVERTISED_CONTROLr_PORT_TYPEf_SET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_PORT_TYPEf_SET
#define BR_LDS_ADVERTISED_CONTROLr_RESERVEDf_GET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_RESERVEDf_GET
#define BR_LDS_ADVERTISED_CONTROLr_RESERVEDf_SET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_RESERVEDf_SET
#define BR_LDS_ADVERTISED_CONTROLr_TEST_MODEf_GET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_TEST_MODEf_GET
#define BR_LDS_ADVERTISED_CONTROLr_TEST_MODEf_SET BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr_TEST_MODEf_SET
#define READ_BR_LDS_ADVERTISED_CONTROLr BCM89500_A0_READ_BR_LDS_ADVERTISED_CONTROLr
#define WRITE_BR_LDS_ADVERTISED_CONTROLr BCM89500_A0_WRITE_BR_LDS_ADVERTISED_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_ADVERTISED_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_EXP
 * BLOCKS:   GPIC0
 * DESC:     LDS Expansion Register
 * SIZE:     16
 * FIELDS:
 *     ESTIMATED_WIRE_LENGTH Estimated cable length by Master. Slave device shall get this info via LDS and post here.
 *     PAIR_NUMBER      The number of connections detected by LDS process2'b00 = 1 pair connection 2'b01 = 2 pair connections 2'b10 = 4 pair connections 2'b11 = Reserved
 *     MASTER_SLAVE     1: Local device is Master 0: Local device is Slave.
 *     DOWN_GRADE_ABILITY 1: LDS result can not establish link. Speed is downgraded. 0: LDS result can establish link.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_EXPr 0x00001014

#define BCM89500_A0_BR_LDS_EXPr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_EXP.
 *
 */
typedef union BCM89500_A0_BR_LDS_EXPr_s {
	uint32_t v[1];
	uint32_t br_lds_exp[1];
	uint32_t _br_lds_exp;
} BCM89500_A0_BR_LDS_EXPr_t;

#define BCM89500_A0_BR_LDS_EXPr_CLR(r) (r).br_lds_exp[0] = 0
#define BCM89500_A0_BR_LDS_EXPr_SET(r,d) (r).br_lds_exp[0] = d
#define BCM89500_A0_BR_LDS_EXPr_GET(r) (r).br_lds_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_EXPr_ESTIMATED_WIRE_LENGTHf_GET(r) (((r).br_lds_exp[0]) & 0xfff)
#define BCM89500_A0_BR_LDS_EXPr_ESTIMATED_WIRE_LENGTHf_SET(r,f) (r).br_lds_exp[0]=(((r).br_lds_exp[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_BR_LDS_EXPr_PAIR_NUMBERf_GET(r) ((((r).br_lds_exp[0]) >> 12) & 0x3)
#define BCM89500_A0_BR_LDS_EXPr_PAIR_NUMBERf_SET(r,f) (r).br_lds_exp[0]=(((r).br_lds_exp[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_BR_LDS_EXPr_MASTER_SLAVEf_GET(r) ((((r).br_lds_exp[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_LDS_EXPr_MASTER_SLAVEf_SET(r,f) (r).br_lds_exp[0]=(((r).br_lds_exp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_LDS_EXPr_DOWN_GRADE_ABILITYf_GET(r) ((((r).br_lds_exp[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_LDS_EXPr_DOWN_GRADE_ABILITYf_SET(r,f) (r).br_lds_exp[0]=(((r).br_lds_exp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_LDS_EXP.
 *
 */
#define BCM89500_A0_READ_BR_LDS_EXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_EXPr,(r._br_lds_exp),2)
#define BCM89500_A0_WRITE_BR_LDS_EXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_EXPr,&(r._br_lds_exp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_EXPr BCM89500_A0_BR_LDS_EXPr
#define BR_LDS_EXPr_SIZE BCM89500_A0_BR_LDS_EXPr_SIZE
typedef BCM89500_A0_BR_LDS_EXPr_t BR_LDS_EXPr_t;
#define BR_LDS_EXPr_CLR BCM89500_A0_BR_LDS_EXPr_CLR
#define BR_LDS_EXPr_SET BCM89500_A0_BR_LDS_EXPr_SET
#define BR_LDS_EXPr_GET BCM89500_A0_BR_LDS_EXPr_GET
#define BR_LDS_EXPr_ESTIMATED_WIRE_LENGTHf_GET BCM89500_A0_BR_LDS_EXPr_ESTIMATED_WIRE_LENGTHf_GET
#define BR_LDS_EXPr_ESTIMATED_WIRE_LENGTHf_SET BCM89500_A0_BR_LDS_EXPr_ESTIMATED_WIRE_LENGTHf_SET
#define BR_LDS_EXPr_PAIR_NUMBERf_GET BCM89500_A0_BR_LDS_EXPr_PAIR_NUMBERf_GET
#define BR_LDS_EXPr_PAIR_NUMBERf_SET BCM89500_A0_BR_LDS_EXPr_PAIR_NUMBERf_SET
#define BR_LDS_EXPr_MASTER_SLAVEf_GET BCM89500_A0_BR_LDS_EXPr_MASTER_SLAVEf_GET
#define BR_LDS_EXPr_MASTER_SLAVEf_SET BCM89500_A0_BR_LDS_EXPr_MASTER_SLAVEf_SET
#define BR_LDS_EXPr_DOWN_GRADE_ABILITYf_GET BCM89500_A0_BR_LDS_EXPr_DOWN_GRADE_ABILITYf_GET
#define BR_LDS_EXPr_DOWN_GRADE_ABILITYf_SET BCM89500_A0_BR_LDS_EXPr_DOWN_GRADE_ABILITYf_SET
#define READ_BR_LDS_EXPr BCM89500_A0_READ_BR_LDS_EXPr
#define WRITE_BR_LDS_EXPr BCM89500_A0_WRITE_BR_LDS_EXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_EXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_LP_ABI_BP
 * BLOCKS:   GPIC0
 * DESC:     LDS Link Partner Ability Base Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Write as 0, ignore on Read
 *     PAIR_1_10MBPS    1: Link partner supports 1 pair, 10Mbps
 *     PAIRS_2_10MBPS   1: Link partner supports 2 pairs, 10Mbps
 *     PAIRS_2_100MBPS  1: Link partner supports 2 pairs, 100Mbps
 *     PAIRS_4_100MBPS  1: Link partner supports 4 pairs, 100Mbps
 *     PAIR_1_100MBPS   1: Link partner supports 1 pair, 100Mbps
 *     RESERVED_1       Write as 0, ignore on Read
 *     PAUSE_OPERATION  Link partner support supports PAUSE operation
 *     ASY_PAUSE_OPERATION Link partner supports Aynmmetric PAUSE operation
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_LP_ABI_BPr 0x0000100e

#define BCM89500_A0_BR_LDS_LP_ABI_BPr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_LP_ABI_BP.
 *
 */
typedef union BCM89500_A0_BR_LDS_LP_ABI_BPr_s {
	uint32_t v[1];
	uint32_t br_lds_lp_abi_bp[1];
	uint32_t _br_lds_lp_abi_bp;
} BCM89500_A0_BR_LDS_LP_ABI_BPr_t;

#define BCM89500_A0_BR_LDS_LP_ABI_BPr_CLR(r) (r).br_lds_lp_abi_bp[0] = 0
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_SET(r,d) (r).br_lds_lp_abi_bp[0] = d
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_GET(r) (r).br_lds_lp_abi_bp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_0f_GET(r) (((r).br_lds_lp_abi_bp[0]) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_0f_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_10MBPSf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 1) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_10MBPSf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_10MBPSf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 2) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_10MBPSf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_100MBPSf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_100MBPSf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_4_100MBPSf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 4) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_4_100MBPSf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_100MBPSf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 5) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_100MBPSf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_1f_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 6) & 0xff)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_1f_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAUSE_OPERATIONf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_PAUSE_OPERATIONf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_ASY_PAUSE_OPERATIONf_GET(r) ((((r).br_lds_lp_abi_bp[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_BPr_ASY_PAUSE_OPERATIONf_SET(r,f) (r).br_lds_lp_abi_bp[0]=(((r).br_lds_lp_abi_bp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_LDS_LP_ABI_BP.
 *
 */
#define BCM89500_A0_READ_BR_LDS_LP_ABI_BPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_LP_ABI_BPr,(r._br_lds_lp_abi_bp),2)
#define BCM89500_A0_WRITE_BR_LDS_LP_ABI_BPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_LP_ABI_BPr,&(r._br_lds_lp_abi_bp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_LP_ABI_BPr BCM89500_A0_BR_LDS_LP_ABI_BPr
#define BR_LDS_LP_ABI_BPr_SIZE BCM89500_A0_BR_LDS_LP_ABI_BPr_SIZE
typedef BCM89500_A0_BR_LDS_LP_ABI_BPr_t BR_LDS_LP_ABI_BPr_t;
#define BR_LDS_LP_ABI_BPr_CLR BCM89500_A0_BR_LDS_LP_ABI_BPr_CLR
#define BR_LDS_LP_ABI_BPr_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_SET
#define BR_LDS_LP_ABI_BPr_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_GET
#define BR_LDS_LP_ABI_BPr_RESERVED_0f_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_0f_GET
#define BR_LDS_LP_ABI_BPr_RESERVED_0f_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_0f_SET
#define BR_LDS_LP_ABI_BPr_PAIR_1_10MBPSf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_10MBPSf_GET
#define BR_LDS_LP_ABI_BPr_PAIR_1_10MBPSf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_10MBPSf_SET
#define BR_LDS_LP_ABI_BPr_PAIRS_2_10MBPSf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_10MBPSf_GET
#define BR_LDS_LP_ABI_BPr_PAIRS_2_10MBPSf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_10MBPSf_SET
#define BR_LDS_LP_ABI_BPr_PAIRS_2_100MBPSf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_100MBPSf_GET
#define BR_LDS_LP_ABI_BPr_PAIRS_2_100MBPSf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_2_100MBPSf_SET
#define BR_LDS_LP_ABI_BPr_PAIRS_4_100MBPSf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_4_100MBPSf_GET
#define BR_LDS_LP_ABI_BPr_PAIRS_4_100MBPSf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIRS_4_100MBPSf_SET
#define BR_LDS_LP_ABI_BPr_PAIR_1_100MBPSf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_100MBPSf_GET
#define BR_LDS_LP_ABI_BPr_PAIR_1_100MBPSf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAIR_1_100MBPSf_SET
#define BR_LDS_LP_ABI_BPr_RESERVED_1f_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_1f_GET
#define BR_LDS_LP_ABI_BPr_RESERVED_1f_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_RESERVED_1f_SET
#define BR_LDS_LP_ABI_BPr_PAUSE_OPERATIONf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAUSE_OPERATIONf_GET
#define BR_LDS_LP_ABI_BPr_PAUSE_OPERATIONf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_PAUSE_OPERATIONf_SET
#define BR_LDS_LP_ABI_BPr_ASY_PAUSE_OPERATIONf_GET BCM89500_A0_BR_LDS_LP_ABI_BPr_ASY_PAUSE_OPERATIONf_GET
#define BR_LDS_LP_ABI_BPr_ASY_PAUSE_OPERATIONf_SET BCM89500_A0_BR_LDS_LP_ABI_BPr_ASY_PAUSE_OPERATIONf_SET
#define READ_BR_LDS_LP_ABI_BPr BCM89500_A0_READ_BR_LDS_LP_ABI_BPr
#define WRITE_BR_LDS_LP_ABI_BPr BCM89500_A0_WRITE_BR_LDS_LP_ABI_BPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_LP_ABI_BPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_LP_ABI_NP
 * BLOCKS:   GPIC0
 * DESC:     LDS Link Partner Ability Next Page Register
 * SIZE:     16
 * FIELDS:
 *     REMOTE_FIELD_NUMBER The remote field number associated with the exchanged abilities.
 *     REMOTE_ACQ       Acknowledge from link partner
 *     RESERVED         Write as 0, ignore on Read
 *     NEXT_PAGE_READ_FLAG To indicate Reg 0x10 Next Page Message has been read by host.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_LP_ABI_NPr 0x00001012

#define BCM89500_A0_BR_LDS_LP_ABI_NPr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_LP_ABI_NP.
 *
 */
typedef union BCM89500_A0_BR_LDS_LP_ABI_NPr_s {
	uint32_t v[1];
	uint32_t br_lds_lp_abi_np[1];
	uint32_t _br_lds_lp_abi_np;
} BCM89500_A0_BR_LDS_LP_ABI_NPr_t;

#define BCM89500_A0_BR_LDS_LP_ABI_NPr_CLR(r) (r).br_lds_lp_abi_np[0] = 0
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_SET(r,d) (r).br_lds_lp_abi_np[0] = d
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_GET(r) (r).br_lds_lp_abi_np[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_FIELD_NUMBERf_GET(r) (((r).br_lds_lp_abi_np[0]) & 0xff)
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_FIELD_NUMBERf_SET(r,f) (r).br_lds_lp_abi_np[0]=(((r).br_lds_lp_abi_np[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_ACQf_GET(r) ((((r).br_lds_lp_abi_np[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_ACQf_SET(r,f) (r).br_lds_lp_abi_np[0]=(((r).br_lds_lp_abi_np[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_RESERVEDf_GET(r) ((((r).br_lds_lp_abi_np[0]) >> 9) & 0x3f)
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_RESERVEDf_SET(r,f) (r).br_lds_lp_abi_np[0]=(((r).br_lds_lp_abi_np[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_NEXT_PAGE_READ_FLAGf_GET(r) ((((r).br_lds_lp_abi_np[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_LDS_LP_ABI_NPr_NEXT_PAGE_READ_FLAGf_SET(r,f) (r).br_lds_lp_abi_np[0]=(((r).br_lds_lp_abi_np[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_LDS_LP_ABI_NP.
 *
 */
#define BCM89500_A0_READ_BR_LDS_LP_ABI_NPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_LP_ABI_NPr,(r._br_lds_lp_abi_np),2)
#define BCM89500_A0_WRITE_BR_LDS_LP_ABI_NPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_LP_ABI_NPr,&(r._br_lds_lp_abi_np),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_LP_ABI_NPr BCM89500_A0_BR_LDS_LP_ABI_NPr
#define BR_LDS_LP_ABI_NPr_SIZE BCM89500_A0_BR_LDS_LP_ABI_NPr_SIZE
typedef BCM89500_A0_BR_LDS_LP_ABI_NPr_t BR_LDS_LP_ABI_NPr_t;
#define BR_LDS_LP_ABI_NPr_CLR BCM89500_A0_BR_LDS_LP_ABI_NPr_CLR
#define BR_LDS_LP_ABI_NPr_SET BCM89500_A0_BR_LDS_LP_ABI_NPr_SET
#define BR_LDS_LP_ABI_NPr_GET BCM89500_A0_BR_LDS_LP_ABI_NPr_GET
#define BR_LDS_LP_ABI_NPr_REMOTE_FIELD_NUMBERf_GET BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_FIELD_NUMBERf_GET
#define BR_LDS_LP_ABI_NPr_REMOTE_FIELD_NUMBERf_SET BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_FIELD_NUMBERf_SET
#define BR_LDS_LP_ABI_NPr_REMOTE_ACQf_GET BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_ACQf_GET
#define BR_LDS_LP_ABI_NPr_REMOTE_ACQf_SET BCM89500_A0_BR_LDS_LP_ABI_NPr_REMOTE_ACQf_SET
#define BR_LDS_LP_ABI_NPr_RESERVEDf_GET BCM89500_A0_BR_LDS_LP_ABI_NPr_RESERVEDf_GET
#define BR_LDS_LP_ABI_NPr_RESERVEDf_SET BCM89500_A0_BR_LDS_LP_ABI_NPr_RESERVEDf_SET
#define BR_LDS_LP_ABI_NPr_NEXT_PAGE_READ_FLAGf_GET BCM89500_A0_BR_LDS_LP_ABI_NPr_NEXT_PAGE_READ_FLAGf_GET
#define BR_LDS_LP_ABI_NPr_NEXT_PAGE_READ_FLAGf_SET BCM89500_A0_BR_LDS_LP_ABI_NPr_NEXT_PAGE_READ_FLAGf_SET
#define READ_BR_LDS_LP_ABI_NPr BCM89500_A0_READ_BR_LDS_LP_ABI_NPr
#define WRITE_BR_LDS_LP_ABI_NPr BCM89500_A0_WRITE_BR_LDS_LP_ABI_NPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_LP_ABI_NPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LDS_LP_NP_MSG
 * BLOCKS:   GPIC0
 * DESC:     LDS Link Partner Next Page Message Register
 * SIZE:     16
 * FIELDS:
 *     LINK_PARTNER_NEXT_PAGE_MSG For remote field number is not equal to 0 message content.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LDS_LP_NP_MSGr 0x00001010

#define BCM89500_A0_BR_LDS_LP_NP_MSGr_SIZE 2

/*
 * This structure should be used to declare and program BR_LDS_LP_NP_MSG.
 *
 */
typedef union BCM89500_A0_BR_LDS_LP_NP_MSGr_s {
	uint32_t v[1];
	uint32_t br_lds_lp_np_msg[1];
	uint32_t _br_lds_lp_np_msg;
} BCM89500_A0_BR_LDS_LP_NP_MSGr_t;

#define BCM89500_A0_BR_LDS_LP_NP_MSGr_CLR(r) (r).br_lds_lp_np_msg[0] = 0
#define BCM89500_A0_BR_LDS_LP_NP_MSGr_SET(r,d) (r).br_lds_lp_np_msg[0] = d
#define BCM89500_A0_BR_LDS_LP_NP_MSGr_GET(r) (r).br_lds_lp_np_msg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LDS_LP_NP_MSGr_LINK_PARTNER_NEXT_PAGE_MSGf_GET(r) (((r).br_lds_lp_np_msg[0]) & 0xffff)
#define BCM89500_A0_BR_LDS_LP_NP_MSGr_LINK_PARTNER_NEXT_PAGE_MSGf_SET(r,f) (r).br_lds_lp_np_msg[0]=(((r).br_lds_lp_np_msg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BR_LDS_LP_NP_MSG.
 *
 */
#define BCM89500_A0_READ_BR_LDS_LP_NP_MSGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LDS_LP_NP_MSGr,(r._br_lds_lp_np_msg),2)
#define BCM89500_A0_WRITE_BR_LDS_LP_NP_MSGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LDS_LP_NP_MSGr,&(r._br_lds_lp_np_msg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LDS_LP_NP_MSGr BCM89500_A0_BR_LDS_LP_NP_MSGr
#define BR_LDS_LP_NP_MSGr_SIZE BCM89500_A0_BR_LDS_LP_NP_MSGr_SIZE
typedef BCM89500_A0_BR_LDS_LP_NP_MSGr_t BR_LDS_LP_NP_MSGr_t;
#define BR_LDS_LP_NP_MSGr_CLR BCM89500_A0_BR_LDS_LP_NP_MSGr_CLR
#define BR_LDS_LP_NP_MSGr_SET BCM89500_A0_BR_LDS_LP_NP_MSGr_SET
#define BR_LDS_LP_NP_MSGr_GET BCM89500_A0_BR_LDS_LP_NP_MSGr_GET
#define BR_LDS_LP_NP_MSGr_LINK_PARTNER_NEXT_PAGE_MSGf_GET BCM89500_A0_BR_LDS_LP_NP_MSGr_LINK_PARTNER_NEXT_PAGE_MSGf_GET
#define BR_LDS_LP_NP_MSGr_LINK_PARTNER_NEXT_PAGE_MSGf_SET BCM89500_A0_BR_LDS_LP_NP_MSGr_LINK_PARTNER_NEXT_PAGE_MSGf_SET
#define READ_BR_LDS_LP_NP_MSGr BCM89500_A0_READ_BR_LDS_LP_NP_MSGr
#define WRITE_BR_LDS_LP_NP_MSGr BCM89500_A0_WRITE_BR_LDS_LP_NP_MSGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LDS_LP_NP_MSGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LRE_CTL
 * BLOCKS:   GPIC0
 * DESC:     LRE Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Write as 0, ignore on Read.
 *     MASTER_SLAVE_SEL 1: Manually force local device to master, when bit 12 = 0.0: Manually force local device to slave, when bit 12 = 0.
 *     PAIR_SEL         2'b00 = 1 pair connection Others = Reserved
 *     SPEED_SELECTION  4'h0 = 10 Mb/s 4'h8 = 100 Mb/s Others = Reserved
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:normal operation.
 *     LDS_ENABLE       1: enable LDS process 0: disable LDS process
 *     RESTART_LDS      1: Restart LDS process 0: normal operation
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LRE_CTLr 0x00001000

#define BCM89500_A0_BR_LRE_CTLr_SIZE 2

/*
 * This structure should be used to declare and program BR_LRE_CTL.
 *
 */
typedef union BCM89500_A0_BR_LRE_CTLr_s {
	uint32_t v[1];
	uint32_t br_lre_ctl[1];
	uint32_t _br_lre_ctl;
} BCM89500_A0_BR_LRE_CTLr_t;

#define BCM89500_A0_BR_LRE_CTLr_CLR(r) (r).br_lre_ctl[0] = 0
#define BCM89500_A0_BR_LRE_CTLr_SET(r,d) (r).br_lre_ctl[0] = d
#define BCM89500_A0_BR_LRE_CTLr_GET(r) (r).br_lre_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LRE_CTLr_RESERVEDf_GET(r) (((r).br_lre_ctl[0]) & 0x7)
#define BCM89500_A0_BR_LRE_CTLr_RESERVEDf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_BR_LRE_CTLr_MASTER_SLAVE_SELf_GET(r) ((((r).br_lre_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_MASTER_SLAVE_SELf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_LRE_CTLr_PAIR_SELf_GET(r) ((((r).br_lre_ctl[0]) >> 4) & 0x3)
#define BCM89500_A0_BR_LRE_CTLr_PAIR_SELf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_BR_LRE_CTLr_SPEED_SELECTIONf_GET(r) ((((r).br_lre_ctl[0]) >> 6) & 0xf)
#define BCM89500_A0_BR_LRE_CTLr_SPEED_SELECTIONf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM89500_A0_BR_LRE_CTLr_ISOLATEf_GET(r) ((((r).br_lre_ctl[0]) >> 10) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_ISOLATEf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_BR_LRE_CTLr_PWR_DOWNf_GET(r) ((((r).br_lre_ctl[0]) >> 11) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_PWR_DOWNf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_BR_LRE_CTLr_LDS_ENABLEf_GET(r) ((((r).br_lre_ctl[0]) >> 12) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_LDS_ENABLEf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_BR_LRE_CTLr_RESTART_LDSf_GET(r) ((((r).br_lre_ctl[0]) >> 13) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_RESTART_LDSf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_BR_LRE_CTLr_LOOPBACKf_GET(r) ((((r).br_lre_ctl[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_LOOPBACKf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_LRE_CTLr_RESETf_GET(r) ((((r).br_lre_ctl[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_LRE_CTLr_RESETf_SET(r,f) (r).br_lre_ctl[0]=(((r).br_lre_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_LRE_CTL.
 *
 */
#define BCM89500_A0_READ_BR_LRE_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LRE_CTLr,(r._br_lre_ctl),2)
#define BCM89500_A0_WRITE_BR_LRE_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LRE_CTLr,&(r._br_lre_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LRE_CTLr BCM89500_A0_BR_LRE_CTLr
#define BR_LRE_CTLr_SIZE BCM89500_A0_BR_LRE_CTLr_SIZE
typedef BCM89500_A0_BR_LRE_CTLr_t BR_LRE_CTLr_t;
#define BR_LRE_CTLr_CLR BCM89500_A0_BR_LRE_CTLr_CLR
#define BR_LRE_CTLr_SET BCM89500_A0_BR_LRE_CTLr_SET
#define BR_LRE_CTLr_GET BCM89500_A0_BR_LRE_CTLr_GET
#define BR_LRE_CTLr_RESERVEDf_GET BCM89500_A0_BR_LRE_CTLr_RESERVEDf_GET
#define BR_LRE_CTLr_RESERVEDf_SET BCM89500_A0_BR_LRE_CTLr_RESERVEDf_SET
#define BR_LRE_CTLr_MASTER_SLAVE_SELf_GET BCM89500_A0_BR_LRE_CTLr_MASTER_SLAVE_SELf_GET
#define BR_LRE_CTLr_MASTER_SLAVE_SELf_SET BCM89500_A0_BR_LRE_CTLr_MASTER_SLAVE_SELf_SET
#define BR_LRE_CTLr_PAIR_SELf_GET BCM89500_A0_BR_LRE_CTLr_PAIR_SELf_GET
#define BR_LRE_CTLr_PAIR_SELf_SET BCM89500_A0_BR_LRE_CTLr_PAIR_SELf_SET
#define BR_LRE_CTLr_SPEED_SELECTIONf_GET BCM89500_A0_BR_LRE_CTLr_SPEED_SELECTIONf_GET
#define BR_LRE_CTLr_SPEED_SELECTIONf_SET BCM89500_A0_BR_LRE_CTLr_SPEED_SELECTIONf_SET
#define BR_LRE_CTLr_ISOLATEf_GET BCM89500_A0_BR_LRE_CTLr_ISOLATEf_GET
#define BR_LRE_CTLr_ISOLATEf_SET BCM89500_A0_BR_LRE_CTLr_ISOLATEf_SET
#define BR_LRE_CTLr_PWR_DOWNf_GET BCM89500_A0_BR_LRE_CTLr_PWR_DOWNf_GET
#define BR_LRE_CTLr_PWR_DOWNf_SET BCM89500_A0_BR_LRE_CTLr_PWR_DOWNf_SET
#define BR_LRE_CTLr_LDS_ENABLEf_GET BCM89500_A0_BR_LRE_CTLr_LDS_ENABLEf_GET
#define BR_LRE_CTLr_LDS_ENABLEf_SET BCM89500_A0_BR_LRE_CTLr_LDS_ENABLEf_SET
#define BR_LRE_CTLr_RESTART_LDSf_GET BCM89500_A0_BR_LRE_CTLr_RESTART_LDSf_GET
#define BR_LRE_CTLr_RESTART_LDSf_SET BCM89500_A0_BR_LRE_CTLr_RESTART_LDSf_SET
#define BR_LRE_CTLr_LOOPBACKf_GET BCM89500_A0_BR_LRE_CTLr_LOOPBACKf_GET
#define BR_LRE_CTLr_LOOPBACKf_SET BCM89500_A0_BR_LRE_CTLr_LOOPBACKf_SET
#define BR_LRE_CTLr_RESETf_GET BCM89500_A0_BR_LRE_CTLr_RESETf_GET
#define BR_LRE_CTLr_RESETf_SET BCM89500_A0_BR_LRE_CTLr_RESETf_SET
#define READ_BR_LRE_CTLr BCM89500_A0_READ_BR_LRE_CTLr
#define WRITE_BR_LRE_CTLr BCM89500_A0_WRITE_BR_LRE_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LRE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_LRE_STS
 * BLOCKS:   GPIC0
 * DESC:     LRE Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STATUS      1: link is up 0: link is down
 *     LDS_ABILITY      1: LRE PHY is able to perform LDS 0: LRE PHY is not able to perform LDS
 *     SUPPORT_IEEE802_3_PHY 1: Support IEEE 802.3 PHY 0: Does not support IEEE 802.3 PHY
 *     LDS_COMPLETE     1: LDS process completed 0: LDS process not completed
 *     MF_PRE_SUP       1: LRE PHY will accept management frames with preamble suppressed0: LRE PHY will not accept management frames with preamble suppressed.
 *     UNIDIRECTIONAL_ABILITY 1 : capable of Unidirectional Transmit0 : Not capable of Unidirectional Transmit
 *     EXT_STS          1 = extended status information in register offset 0x1e0 = no extended status info in register offset 0x1e
 *     CAP_10MBPS_1PAIR 1: LRE PHY able to performance 10Mb/s over 1 pair wire 0: LRE PHY not able to performance 10Mb/s over 1 pair wire
 *     CAP_10MBPS_2PAIR 1: LRE PHY able to performance 10Mb/s over 2 pair wires 0: LRE PHY not able to performance 10Mb/s over 2 pair wires
 *     CAP_100MBPS_2PAIR 1: LRE PHY able to performance 100Mb/s over 2 pair wires 0: LRE PHY not able to performance 100Mb/s over 2 pair wires
 *     CAP_100MBPS_4PAIR 1: LRE PHY able to performance 100Mb/s over 4 pair wires 0: LRE PHY not able to performance 100Mb/s over 4 pair wires
 *     CAP_100MBPS_1PAIR 1: LRE PHY able to performance 100Mb/s over 1 pair wires 0: LRE PHY not able to performance 100Mb/s over 1 pair wires
 *     RESERVED         Ignore when read
 *
 ******************************************************************************/
#define BCM89500_A0_BR_LRE_STSr 0x00001002

#define BCM89500_A0_BR_LRE_STSr_SIZE 2

/*
 * This structure should be used to declare and program BR_LRE_STS.
 *
 */
typedef union BCM89500_A0_BR_LRE_STSr_s {
	uint32_t v[1];
	uint32_t br_lre_sts[1];
	uint32_t _br_lre_sts;
} BCM89500_A0_BR_LRE_STSr_t;

#define BCM89500_A0_BR_LRE_STSr_CLR(r) (r).br_lre_sts[0] = 0
#define BCM89500_A0_BR_LRE_STSr_SET(r,d) (r).br_lre_sts[0] = d
#define BCM89500_A0_BR_LRE_STSr_GET(r) (r).br_lre_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_LRE_STSr_EXT_CAPf_GET(r) (((r).br_lre_sts[0]) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_EXT_CAPf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_BR_LRE_STSr_JABBER_DETf_GET(r) ((((r).br_lre_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_JABBER_DETf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BR_LRE_STSr_LINK_STATUSf_GET(r) ((((r).br_lre_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_LINK_STATUSf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_BR_LRE_STSr_LDS_ABILITYf_GET(r) ((((r).br_lre_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_LDS_ABILITYf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_LRE_STSr_SUPPORT_IEEE802_3_PHYf_GET(r) ((((r).br_lre_sts[0]) >> 4) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_SUPPORT_IEEE802_3_PHYf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_BR_LRE_STSr_LDS_COMPLETEf_GET(r) ((((r).br_lre_sts[0]) >> 5) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_LDS_COMPLETEf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BR_LRE_STSr_MF_PRE_SUPf_GET(r) ((((r).br_lre_sts[0]) >> 6) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_MF_PRE_SUPf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_BR_LRE_STSr_UNIDIRECTIONAL_ABILITYf_GET(r) ((((r).br_lre_sts[0]) >> 7) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_UNIDIRECTIONAL_ABILITYf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_BR_LRE_STSr_EXT_STSf_GET(r) ((((r).br_lre_sts[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_EXT_STSf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_1PAIRf_GET(r) ((((r).br_lre_sts[0]) >> 9) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_1PAIRf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_2PAIRf_GET(r) ((((r).br_lre_sts[0]) >> 10) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_2PAIRf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_2PAIRf_GET(r) ((((r).br_lre_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_2PAIRf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_4PAIRf_GET(r) ((((r).br_lre_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_4PAIRf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_1PAIRf_GET(r) ((((r).br_lre_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_1PAIRf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_BR_LRE_STSr_RESERVEDf_GET(r) ((((r).br_lre_sts[0]) >> 14) & 0x3)
#define BCM89500_A0_BR_LRE_STSr_RESERVEDf_SET(r,f) (r).br_lre_sts[0]=(((r).br_lre_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access BR_LRE_STS.
 *
 */
#define BCM89500_A0_READ_BR_LRE_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_LRE_STSr,(r._br_lre_sts),2)
#define BCM89500_A0_WRITE_BR_LRE_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_LRE_STSr,&(r._br_lre_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_LRE_STSr BCM89500_A0_BR_LRE_STSr
#define BR_LRE_STSr_SIZE BCM89500_A0_BR_LRE_STSr_SIZE
typedef BCM89500_A0_BR_LRE_STSr_t BR_LRE_STSr_t;
#define BR_LRE_STSr_CLR BCM89500_A0_BR_LRE_STSr_CLR
#define BR_LRE_STSr_SET BCM89500_A0_BR_LRE_STSr_SET
#define BR_LRE_STSr_GET BCM89500_A0_BR_LRE_STSr_GET
#define BR_LRE_STSr_EXT_CAPf_GET BCM89500_A0_BR_LRE_STSr_EXT_CAPf_GET
#define BR_LRE_STSr_EXT_CAPf_SET BCM89500_A0_BR_LRE_STSr_EXT_CAPf_SET
#define BR_LRE_STSr_JABBER_DETf_GET BCM89500_A0_BR_LRE_STSr_JABBER_DETf_GET
#define BR_LRE_STSr_JABBER_DETf_SET BCM89500_A0_BR_LRE_STSr_JABBER_DETf_SET
#define BR_LRE_STSr_LINK_STATUSf_GET BCM89500_A0_BR_LRE_STSr_LINK_STATUSf_GET
#define BR_LRE_STSr_LINK_STATUSf_SET BCM89500_A0_BR_LRE_STSr_LINK_STATUSf_SET
#define BR_LRE_STSr_LDS_ABILITYf_GET BCM89500_A0_BR_LRE_STSr_LDS_ABILITYf_GET
#define BR_LRE_STSr_LDS_ABILITYf_SET BCM89500_A0_BR_LRE_STSr_LDS_ABILITYf_SET
#define BR_LRE_STSr_SUPPORT_IEEE802_3_PHYf_GET BCM89500_A0_BR_LRE_STSr_SUPPORT_IEEE802_3_PHYf_GET
#define BR_LRE_STSr_SUPPORT_IEEE802_3_PHYf_SET BCM89500_A0_BR_LRE_STSr_SUPPORT_IEEE802_3_PHYf_SET
#define BR_LRE_STSr_LDS_COMPLETEf_GET BCM89500_A0_BR_LRE_STSr_LDS_COMPLETEf_GET
#define BR_LRE_STSr_LDS_COMPLETEf_SET BCM89500_A0_BR_LRE_STSr_LDS_COMPLETEf_SET
#define BR_LRE_STSr_MF_PRE_SUPf_GET BCM89500_A0_BR_LRE_STSr_MF_PRE_SUPf_GET
#define BR_LRE_STSr_MF_PRE_SUPf_SET BCM89500_A0_BR_LRE_STSr_MF_PRE_SUPf_SET
#define BR_LRE_STSr_UNIDIRECTIONAL_ABILITYf_GET BCM89500_A0_BR_LRE_STSr_UNIDIRECTIONAL_ABILITYf_GET
#define BR_LRE_STSr_UNIDIRECTIONAL_ABILITYf_SET BCM89500_A0_BR_LRE_STSr_UNIDIRECTIONAL_ABILITYf_SET
#define BR_LRE_STSr_EXT_STSf_GET BCM89500_A0_BR_LRE_STSr_EXT_STSf_GET
#define BR_LRE_STSr_EXT_STSf_SET BCM89500_A0_BR_LRE_STSr_EXT_STSf_SET
#define BR_LRE_STSr_CAP_10MBPS_1PAIRf_GET BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_1PAIRf_GET
#define BR_LRE_STSr_CAP_10MBPS_1PAIRf_SET BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_1PAIRf_SET
#define BR_LRE_STSr_CAP_10MBPS_2PAIRf_GET BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_2PAIRf_GET
#define BR_LRE_STSr_CAP_10MBPS_2PAIRf_SET BCM89500_A0_BR_LRE_STSr_CAP_10MBPS_2PAIRf_SET
#define BR_LRE_STSr_CAP_100MBPS_2PAIRf_GET BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_2PAIRf_GET
#define BR_LRE_STSr_CAP_100MBPS_2PAIRf_SET BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_2PAIRf_SET
#define BR_LRE_STSr_CAP_100MBPS_4PAIRf_GET BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_4PAIRf_GET
#define BR_LRE_STSr_CAP_100MBPS_4PAIRf_SET BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_4PAIRf_SET
#define BR_LRE_STSr_CAP_100MBPS_1PAIRf_GET BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_1PAIRf_GET
#define BR_LRE_STSr_CAP_100MBPS_1PAIRf_SET BCM89500_A0_BR_LRE_STSr_CAP_100MBPS_1PAIRf_SET
#define BR_LRE_STSr_RESERVEDf_GET BCM89500_A0_BR_LRE_STSr_RESERVEDf_GET
#define BR_LRE_STSr_RESERVEDf_SET BCM89500_A0_BR_LRE_STSr_RESERVEDf_SET
#define READ_BR_LRE_STSr BCM89500_A0_READ_BR_LRE_STSr
#define WRITE_BR_LRE_STSr BCM89500_A0_WRITE_BR_LRE_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_LRE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_MISC_SHADOW
 * BLOCKS:   GPIC0
 * DESC:     Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     MISC_CTRL        spare control 3:bit 9 : DLL lock enable during auto-power downbit 8 : txc/rxc disable during auto-power downbit 7-6 : reservedbit 5 : sd/energy detect change mux selectbit 4 : low power enc disablebit 3 : reservedbit 2 : sigdet deassert timer lengthbit 1 : auto-power down dll off disabalebit 0 : reservedauto-power down:bit 9-6 : reservedbit 5 : auto-power down mode enablebit 4: sleep timer select (1=5.4 seconds, 0=2.7 seconds)bit 3-0 : wake-up timer in units of 84msspare control 4:bit 9-7 : reservedbit 6 : soft-reset enablebit 5-0 : reservedspare control 5:bit 9-1 : reservedbit 0 : software IDDQ (1=iddq, 0=normal)
 *     SHADOW_REG_SEL   Shadow register selector5'h05 : spare control 35'h0a : auto-power down5'h0b : spare control 45'h0c : spare control 5
 *     WRITE_ENABLE     1 = write bits [9:0]0 = read bits [9:0]
 *
 ******************************************************************************/
#define BCM89500_A0_BR_MISC_SHADOWr 0x00001038

#define BCM89500_A0_BR_MISC_SHADOWr_SIZE 2

/*
 * This structure should be used to declare and program BR_MISC_SHADOW.
 *
 */
typedef union BCM89500_A0_BR_MISC_SHADOWr_s {
	uint32_t v[1];
	uint32_t br_misc_shadow[1];
	uint32_t _br_misc_shadow;
} BCM89500_A0_BR_MISC_SHADOWr_t;

#define BCM89500_A0_BR_MISC_SHADOWr_CLR(r) (r).br_misc_shadow[0] = 0
#define BCM89500_A0_BR_MISC_SHADOWr_SET(r,d) (r).br_misc_shadow[0] = d
#define BCM89500_A0_BR_MISC_SHADOWr_GET(r) (r).br_misc_shadow[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_MISC_SHADOWr_MISC_CTRLf_GET(r) (((r).br_misc_shadow[0]) & 0x3ff)
#define BCM89500_A0_BR_MISC_SHADOWr_MISC_CTRLf_SET(r,f) (r).br_misc_shadow[0]=(((r).br_misc_shadow[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_BR_MISC_SHADOWr_SHADOW_REG_SELf_GET(r) ((((r).br_misc_shadow[0]) >> 10) & 0x1f)
#define BCM89500_A0_BR_MISC_SHADOWr_SHADOW_REG_SELf_SET(r,f) (r).br_misc_shadow[0]=(((r).br_misc_shadow[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM89500_A0_BR_MISC_SHADOWr_WRITE_ENABLEf_GET(r) ((((r).br_misc_shadow[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_MISC_SHADOWr_WRITE_ENABLEf_SET(r,f) (r).br_misc_shadow[0]=(((r).br_misc_shadow[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_MISC_SHADOW.
 *
 */
#define BCM89500_A0_READ_BR_MISC_SHADOWr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_MISC_SHADOWr,(r._br_misc_shadow),2)
#define BCM89500_A0_WRITE_BR_MISC_SHADOWr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_MISC_SHADOWr,&(r._br_misc_shadow),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_MISC_SHADOWr BCM89500_A0_BR_MISC_SHADOWr
#define BR_MISC_SHADOWr_SIZE BCM89500_A0_BR_MISC_SHADOWr_SIZE
typedef BCM89500_A0_BR_MISC_SHADOWr_t BR_MISC_SHADOWr_t;
#define BR_MISC_SHADOWr_CLR BCM89500_A0_BR_MISC_SHADOWr_CLR
#define BR_MISC_SHADOWr_SET BCM89500_A0_BR_MISC_SHADOWr_SET
#define BR_MISC_SHADOWr_GET BCM89500_A0_BR_MISC_SHADOWr_GET
#define BR_MISC_SHADOWr_MISC_CTRLf_GET BCM89500_A0_BR_MISC_SHADOWr_MISC_CTRLf_GET
#define BR_MISC_SHADOWr_MISC_CTRLf_SET BCM89500_A0_BR_MISC_SHADOWr_MISC_CTRLf_SET
#define BR_MISC_SHADOWr_SHADOW_REG_SELf_GET BCM89500_A0_BR_MISC_SHADOWr_SHADOW_REG_SELf_GET
#define BR_MISC_SHADOWr_SHADOW_REG_SELf_SET BCM89500_A0_BR_MISC_SHADOWr_SHADOW_REG_SELf_SET
#define BR_MISC_SHADOWr_WRITE_ENABLEf_GET BCM89500_A0_BR_MISC_SHADOWr_WRITE_ENABLEf_GET
#define BR_MISC_SHADOWr_WRITE_ENABLEf_SET BCM89500_A0_BR_MISC_SHADOWr_WRITE_ENABLEf_SET
#define READ_BR_MISC_SHADOWr BCM89500_A0_READ_BR_MISC_SHADOWr
#define WRITE_BR_MISC_SHADOWr BCM89500_A0_WRITE_BR_MISC_SHADOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_MISC_SHADOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_PHYIDH
 * BLOCKS:   GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_PHYIDHr 0x00001004

#define BCM89500_A0_BR_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program BR_PHYIDH.
 *
 */
typedef union BCM89500_A0_BR_PHYIDHr_s {
	uint32_t v[1];
	uint32_t br_phyidh[1];
	uint32_t _br_phyidh;
} BCM89500_A0_BR_PHYIDHr_t;

#define BCM89500_A0_BR_PHYIDHr_CLR(r) (r).br_phyidh[0] = 0
#define BCM89500_A0_BR_PHYIDHr_SET(r,d) (r).br_phyidh[0] = d
#define BCM89500_A0_BR_PHYIDHr_GET(r) (r).br_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_PHYIDHr_OUIf_GET(r) (((r).br_phyidh[0]) & 0xffff)
#define BCM89500_A0_BR_PHYIDHr_OUIf_SET(r,f) (r).br_phyidh[0]=(((r).br_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BR_PHYIDH.
 *
 */
#define BCM89500_A0_READ_BR_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_PHYIDHr,(r._br_phyidh),2)
#define BCM89500_A0_WRITE_BR_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_PHYIDHr,&(r._br_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_PHYIDHr BCM89500_A0_BR_PHYIDHr
#define BR_PHYIDHr_SIZE BCM89500_A0_BR_PHYIDHr_SIZE
typedef BCM89500_A0_BR_PHYIDHr_t BR_PHYIDHr_t;
#define BR_PHYIDHr_CLR BCM89500_A0_BR_PHYIDHr_CLR
#define BR_PHYIDHr_SET BCM89500_A0_BR_PHYIDHr_SET
#define BR_PHYIDHr_GET BCM89500_A0_BR_PHYIDHr_GET
#define BR_PHYIDHr_OUIf_GET BCM89500_A0_BR_PHYIDHr_OUIf_GET
#define BR_PHYIDHr_OUIf_SET BCM89500_A0_BR_PHYIDHr_OUIf_SET
#define READ_BR_PHYIDHr BCM89500_A0_READ_BR_PHYIDHr
#define WRITE_BR_PHYIDHr BCM89500_A0_WRITE_BR_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_PHYIDL
 * BLOCKS:   GPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Chip Version ID.Bit 3:2 - Revision ID-00 = A-01 = B-10 = C-11 = DBit 1:0 - Revision number
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_PHYIDLr 0x00001006

#define BCM89500_A0_BR_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program BR_PHYIDL.
 *
 */
typedef union BCM89500_A0_BR_PHYIDLr_s {
	uint32_t v[1];
	uint32_t br_phyidl[1];
	uint32_t _br_phyidl;
} BCM89500_A0_BR_PHYIDLr_t;

#define BCM89500_A0_BR_PHYIDLr_CLR(r) (r).br_phyidl[0] = 0
#define BCM89500_A0_BR_PHYIDLr_SET(r,d) (r).br_phyidl[0] = d
#define BCM89500_A0_BR_PHYIDLr_GET(r) (r).br_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_PHYIDLr_REVISIONf_GET(r) (((r).br_phyidl[0]) & 0xf)
#define BCM89500_A0_BR_PHYIDLr_REVISIONf_SET(r,f) (r).br_phyidl[0]=(((r).br_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_BR_PHYIDLr_MODELf_GET(r) ((((r).br_phyidl[0]) >> 4) & 0x3f)
#define BCM89500_A0_BR_PHYIDLr_MODELf_SET(r,f) (r).br_phyidl[0]=(((r).br_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_BR_PHYIDLr_OUIf_GET(r) ((((r).br_phyidl[0]) >> 10) & 0x3f)
#define BCM89500_A0_BR_PHYIDLr_OUIf_SET(r,f) (r).br_phyidl[0]=(((r).br_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access BR_PHYIDL.
 *
 */
#define BCM89500_A0_READ_BR_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_PHYIDLr,(r._br_phyidl),2)
#define BCM89500_A0_WRITE_BR_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_PHYIDLr,&(r._br_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_PHYIDLr BCM89500_A0_BR_PHYIDLr
#define BR_PHYIDLr_SIZE BCM89500_A0_BR_PHYIDLr_SIZE
typedef BCM89500_A0_BR_PHYIDLr_t BR_PHYIDLr_t;
#define BR_PHYIDLr_CLR BCM89500_A0_BR_PHYIDLr_CLR
#define BR_PHYIDLr_SET BCM89500_A0_BR_PHYIDLr_SET
#define BR_PHYIDLr_GET BCM89500_A0_BR_PHYIDLr_GET
#define BR_PHYIDLr_REVISIONf_GET BCM89500_A0_BR_PHYIDLr_REVISIONf_GET
#define BR_PHYIDLr_REVISIONf_SET BCM89500_A0_BR_PHYIDLr_REVISIONf_SET
#define BR_PHYIDLr_MODELf_GET BCM89500_A0_BR_PHYIDLr_MODELf_GET
#define BR_PHYIDLr_MODELf_SET BCM89500_A0_BR_PHYIDLr_MODELf_SET
#define BR_PHYIDLr_OUIf_GET BCM89500_A0_BR_PHYIDLr_OUIf_GET
#define BR_PHYIDLr_OUIf_SET BCM89500_A0_BR_PHYIDLr_OUIf_SET
#define READ_BR_PHYIDLr BCM89500_A0_READ_BR_PHYIDLr
#define WRITE_BR_PHYIDLr BCM89500_A0_WRITE_BR_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_PHY_EXT_CTL
 * BLOCKS:   GPIC0
 * DESC:     PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Write as 0, ignore on read.
 *     UNIDIRECTIONAL_ENABLE 1 = able to transmit packets when no link0 = requires link in order to transmit packets(similar to IEEE register 0, bit 5.
 *     BLK_TXEN_MOD     1 = extend transmit IPG to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into "OFF" state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into "ON" state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     RESERVED_1       Write as 0.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_PHY_EXT_CTLr 0x00001020

#define BCM89500_A0_BR_PHY_EXT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program BR_PHY_EXT_CTL.
 *
 */
typedef union BCM89500_A0_BR_PHY_EXT_CTLr_s {
	uint32_t v[1];
	uint32_t br_phy_ext_ctl[1];
	uint32_t _br_phy_ext_ctl;
} BCM89500_A0_BR_PHY_EXT_CTLr_t;

#define BCM89500_A0_BR_PHY_EXT_CTLr_CLR(r) (r).br_phy_ext_ctl[0] = 0
#define BCM89500_A0_BR_PHY_EXT_CTLr_SET(r,d) (r).br_phy_ext_ctl[0] = d
#define BCM89500_A0_BR_PHY_EXT_CTLr_GET(r) (r).br_phy_ext_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_0f_GET(r) (((r).br_phy_ext_ctl[0]) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_0f_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_BR_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BR_PHY_EXT_CTLr_BLK_TXEN_MODf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_BLK_TXEN_MODf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_OFFf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_OFFf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_ONf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_ONf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_BR_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BR_PHY_EXT_CTLr_RST_SCRAMBLERf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_RST_SCRAMBLERf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET(r) ((((r).br_phy_ext_ctl[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 9) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ENCODEf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 10) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ENCODEf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 11) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_BR_PHY_EXT_CTLr_INTERRUPT_DISf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 12) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_INTERRUPT_DISf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_BR_PHY_EXT_CTLr_TRANSMIT_DISf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 13) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_TRANSMIT_DISf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_BR_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).br_phy_ext_ctl[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_1f_GET(r) ((((r).br_phy_ext_ctl[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_1f_SET(r,f) (r).br_phy_ext_ctl[0]=(((r).br_phy_ext_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_PHY_EXT_CTL.
 *
 */
#define BCM89500_A0_READ_BR_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_PHY_EXT_CTLr,(r._br_phy_ext_ctl),2)
#define BCM89500_A0_WRITE_BR_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_PHY_EXT_CTLr,&(r._br_phy_ext_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_PHY_EXT_CTLr BCM89500_A0_BR_PHY_EXT_CTLr
#define BR_PHY_EXT_CTLr_SIZE BCM89500_A0_BR_PHY_EXT_CTLr_SIZE
typedef BCM89500_A0_BR_PHY_EXT_CTLr_t BR_PHY_EXT_CTLr_t;
#define BR_PHY_EXT_CTLr_CLR BCM89500_A0_BR_PHY_EXT_CTLr_CLR
#define BR_PHY_EXT_CTLr_SET BCM89500_A0_BR_PHY_EXT_CTLr_SET
#define BR_PHY_EXT_CTLr_GET BCM89500_A0_BR_PHY_EXT_CTLr_GET
#define BR_PHY_EXT_CTLr_RESERVED_0f_GET BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_0f_GET
#define BR_PHY_EXT_CTLr_RESERVED_0f_SET BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_0f_SET
#define BR_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_GET BCM89500_A0_BR_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_GET
#define BR_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_SET BCM89500_A0_BR_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_SET
#define BR_PHY_EXT_CTLr_BLK_TXEN_MODf_GET BCM89500_A0_BR_PHY_EXT_CTLr_BLK_TXEN_MODf_GET
#define BR_PHY_EXT_CTLr_BLK_TXEN_MODf_SET BCM89500_A0_BR_PHY_EXT_CTLr_BLK_TXEN_MODf_SET
#define BR_PHY_EXT_CTLr_FORCE_LED_OFFf_GET BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_OFFf_GET
#define BR_PHY_EXT_CTLr_FORCE_LED_OFFf_SET BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_OFFf_SET
#define BR_PHY_EXT_CTLr_FORCE_LED_ONf_GET BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_ONf_GET
#define BR_PHY_EXT_CTLr_FORCE_LED_ONf_SET BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_LED_ONf_SET
#define BR_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_BR_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET
#define BR_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_BR_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET
#define BR_PHY_EXT_CTLr_RST_SCRAMBLERf_GET BCM89500_A0_BR_PHY_EXT_CTLr_RST_SCRAMBLERf_GET
#define BR_PHY_EXT_CTLr_RST_SCRAMBLERf_SET BCM89500_A0_BR_PHY_EXT_CTLr_RST_SCRAMBLERf_SET
#define BR_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET
#define BR_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET
#define BR_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET
#define BR_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET
#define BR_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET
#define BR_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET
#define BR_PHY_EXT_CTLr_BYPASS_ENCODEf_GET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ENCODEf_GET
#define BR_PHY_EXT_CTLr_BYPASS_ENCODEf_SET BCM89500_A0_BR_PHY_EXT_CTLr_BYPASS_ENCODEf_SET
#define BR_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET
#define BR_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET BCM89500_A0_BR_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET
#define BR_PHY_EXT_CTLr_INTERRUPT_DISf_GET BCM89500_A0_BR_PHY_EXT_CTLr_INTERRUPT_DISf_GET
#define BR_PHY_EXT_CTLr_INTERRUPT_DISf_SET BCM89500_A0_BR_PHY_EXT_CTLr_INTERRUPT_DISf_SET
#define BR_PHY_EXT_CTLr_TRANSMIT_DISf_GET BCM89500_A0_BR_PHY_EXT_CTLr_TRANSMIT_DISf_GET
#define BR_PHY_EXT_CTLr_TRANSMIT_DISf_SET BCM89500_A0_BR_PHY_EXT_CTLr_TRANSMIT_DISf_SET
#define BR_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_BR_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET
#define BR_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_BR_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET
#define BR_PHY_EXT_CTLr_RESERVED_1f_GET BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_1f_GET
#define BR_PHY_EXT_CTLr_RESERVED_1f_SET BCM89500_A0_BR_PHY_EXT_CTLr_RESERVED_1f_SET
#define READ_BR_PHY_EXT_CTLr BCM89500_A0_READ_BR_PHY_EXT_CTLr
#define WRITE_BR_PHY_EXT_CTLr BCM89500_A0_WRITE_BR_PHY_EXT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_PHY_EXT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_PHY_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_PHY_EXT_STSr 0x00001022

#define BCM89500_A0_BR_PHY_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program BR_PHY_EXT_STS.
 *
 */
typedef union BCM89500_A0_BR_PHY_EXT_STSr_s {
	uint32_t v[1];
	uint32_t br_phy_ext_sts[1];
	uint32_t _br_phy_ext_sts;
} BCM89500_A0_BR_PHY_EXT_STSr_t;

#define BCM89500_A0_BR_PHY_EXT_STSr_CLR(r) (r).br_phy_ext_sts[0] = 0
#define BCM89500_A0_BR_PHY_EXT_STSr_SET(r,d) (r).br_phy_ext_sts[0] = d
#define BCM89500_A0_BR_PHY_EXT_STSr_GET(r) (r).br_phy_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_PHY_EXT_STSr_MLT3_ERR_DETf_GET(r) (((r).br_phy_ext_sts[0]) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_MLT3_ERR_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_BR_PHY_EXT_STSr_LCK_ERR_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_LCK_ERR_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BR_PHY_EXT_STSr_TRMIT_ERR_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_TRMIT_ERR_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_BR_PHY_EXT_STSr_REC_ERR_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_REC_ERR_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_BR_PHY_EXT_STSr_BAD_ESD_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 4) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_BAD_ESD_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_BR_PHY_EXT_STSr_BAD_SSD_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 5) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_BAD_SSD_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BR_PHY_EXT_STSr_CARR_ERR_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 6) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_CARR_ERR_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_BR_PHY_EXT_STSr_CRC_ERR_DETf_GET(r) ((((r).br_phy_ext_sts[0]) >> 7) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_CRC_ERR_DETf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_BR_PHY_EXT_STSr_LINK_STSf_GET(r) ((((r).br_phy_ext_sts[0]) >> 8) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_LINK_STSf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_BR_PHY_EXT_STSr_LOCKf_GET(r) ((((r).br_phy_ext_sts[0]) >> 9) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_LOCKf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_BR_PHY_EXT_STSr_LOCAL_REC_STSf_GET(r) ((((r).br_phy_ext_sts[0]) >> 10) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_LOCAL_REC_STSf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_BR_PHY_EXT_STSr_REMOTE_REC_STSf_GET(r) ((((r).br_phy_ext_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_REMOTE_REC_STSf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_BR_PHY_EXT_STSr_INTERRUPT_STSf_GET(r) ((((r).br_phy_ext_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_INTERRUPT_STSf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_BR_PHY_EXT_STSr_MDI_CROS_STATEf_GET(r) ((((r).br_phy_ext_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_MDI_CROS_STATEf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_BR_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).br_phy_ext_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).br_phy_ext_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).br_phy_ext_sts[0]=(((r).br_phy_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_PHY_EXT_STS.
 *
 */
#define BCM89500_A0_READ_BR_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_PHY_EXT_STSr,(r._br_phy_ext_sts),2)
#define BCM89500_A0_WRITE_BR_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_PHY_EXT_STSr,&(r._br_phy_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_PHY_EXT_STSr BCM89500_A0_BR_PHY_EXT_STSr
#define BR_PHY_EXT_STSr_SIZE BCM89500_A0_BR_PHY_EXT_STSr_SIZE
typedef BCM89500_A0_BR_PHY_EXT_STSr_t BR_PHY_EXT_STSr_t;
#define BR_PHY_EXT_STSr_CLR BCM89500_A0_BR_PHY_EXT_STSr_CLR
#define BR_PHY_EXT_STSr_SET BCM89500_A0_BR_PHY_EXT_STSr_SET
#define BR_PHY_EXT_STSr_GET BCM89500_A0_BR_PHY_EXT_STSr_GET
#define BR_PHY_EXT_STSr_MLT3_ERR_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_MLT3_ERR_DETf_GET
#define BR_PHY_EXT_STSr_MLT3_ERR_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_MLT3_ERR_DETf_SET
#define BR_PHY_EXT_STSr_LCK_ERR_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_LCK_ERR_DETf_GET
#define BR_PHY_EXT_STSr_LCK_ERR_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_LCK_ERR_DETf_SET
#define BR_PHY_EXT_STSr_TRMIT_ERR_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_TRMIT_ERR_DETf_GET
#define BR_PHY_EXT_STSr_TRMIT_ERR_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_TRMIT_ERR_DETf_SET
#define BR_PHY_EXT_STSr_REC_ERR_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_REC_ERR_DETf_GET
#define BR_PHY_EXT_STSr_REC_ERR_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_REC_ERR_DETf_SET
#define BR_PHY_EXT_STSr_BAD_ESD_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_BAD_ESD_DETf_GET
#define BR_PHY_EXT_STSr_BAD_ESD_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_BAD_ESD_DETf_SET
#define BR_PHY_EXT_STSr_BAD_SSD_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_BAD_SSD_DETf_GET
#define BR_PHY_EXT_STSr_BAD_SSD_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_BAD_SSD_DETf_SET
#define BR_PHY_EXT_STSr_CARR_ERR_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_CARR_ERR_DETf_GET
#define BR_PHY_EXT_STSr_CARR_ERR_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_CARR_ERR_DETf_SET
#define BR_PHY_EXT_STSr_CRC_ERR_DETf_GET BCM89500_A0_BR_PHY_EXT_STSr_CRC_ERR_DETf_GET
#define BR_PHY_EXT_STSr_CRC_ERR_DETf_SET BCM89500_A0_BR_PHY_EXT_STSr_CRC_ERR_DETf_SET
#define BR_PHY_EXT_STSr_LINK_STSf_GET BCM89500_A0_BR_PHY_EXT_STSr_LINK_STSf_GET
#define BR_PHY_EXT_STSr_LINK_STSf_SET BCM89500_A0_BR_PHY_EXT_STSr_LINK_STSf_SET
#define BR_PHY_EXT_STSr_LOCKf_GET BCM89500_A0_BR_PHY_EXT_STSr_LOCKf_GET
#define BR_PHY_EXT_STSr_LOCKf_SET BCM89500_A0_BR_PHY_EXT_STSr_LOCKf_SET
#define BR_PHY_EXT_STSr_LOCAL_REC_STSf_GET BCM89500_A0_BR_PHY_EXT_STSr_LOCAL_REC_STSf_GET
#define BR_PHY_EXT_STSr_LOCAL_REC_STSf_SET BCM89500_A0_BR_PHY_EXT_STSr_LOCAL_REC_STSf_SET
#define BR_PHY_EXT_STSr_REMOTE_REC_STSf_GET BCM89500_A0_BR_PHY_EXT_STSr_REMOTE_REC_STSf_GET
#define BR_PHY_EXT_STSr_REMOTE_REC_STSf_SET BCM89500_A0_BR_PHY_EXT_STSr_REMOTE_REC_STSf_SET
#define BR_PHY_EXT_STSr_INTERRUPT_STSf_GET BCM89500_A0_BR_PHY_EXT_STSr_INTERRUPT_STSf_GET
#define BR_PHY_EXT_STSr_INTERRUPT_STSf_SET BCM89500_A0_BR_PHY_EXT_STSr_INTERRUPT_STSf_SET
#define BR_PHY_EXT_STSr_MDI_CROS_STATEf_GET BCM89500_A0_BR_PHY_EXT_STSr_MDI_CROS_STATEf_GET
#define BR_PHY_EXT_STSr_MDI_CROS_STATEf_SET BCM89500_A0_BR_PHY_EXT_STSr_MDI_CROS_STATEf_SET
#define BR_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_BR_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET
#define BR_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_BR_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET
#define BR_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_BR_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET
#define BR_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_BR_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_BR_PHY_EXT_STSr BCM89500_A0_READ_BR_PHY_EXT_STSr
#define WRITE_BR_PHY_EXT_STSr BCM89500_A0_WRITE_BR_PHY_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_PHY_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_REC_ERR_CNT
 * BLOCKS:   GPIC0
 * DESC:     Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_BR_REC_ERR_CNTr 0x00001024

#define BCM89500_A0_BR_REC_ERR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program BR_REC_ERR_CNT.
 *
 */
typedef union BCM89500_A0_BR_REC_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t br_rec_err_cnt[1];
	uint32_t _br_rec_err_cnt;
} BCM89500_A0_BR_REC_ERR_CNTr_t;

#define BCM89500_A0_BR_REC_ERR_CNTr_CLR(r) (r).br_rec_err_cnt[0] = 0
#define BCM89500_A0_BR_REC_ERR_CNTr_SET(r,d) (r).br_rec_err_cnt[0] = d
#define BCM89500_A0_BR_REC_ERR_CNTr_GET(r) (r).br_rec_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_REC_ERR_CNTr_REC_ERR_CNTf_GET(r) (((r).br_rec_err_cnt[0]) & 0xffff)
#define BCM89500_A0_BR_REC_ERR_CNTr_REC_ERR_CNTf_SET(r,f) (r).br_rec_err_cnt[0]=(((r).br_rec_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BR_REC_ERR_CNT.
 *
 */
#define BCM89500_A0_READ_BR_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_REC_ERR_CNTr,(r._br_rec_err_cnt),2)
#define BCM89500_A0_WRITE_BR_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_REC_ERR_CNTr,&(r._br_rec_err_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_REC_ERR_CNTr BCM89500_A0_BR_REC_ERR_CNTr
#define BR_REC_ERR_CNTr_SIZE BCM89500_A0_BR_REC_ERR_CNTr_SIZE
typedef BCM89500_A0_BR_REC_ERR_CNTr_t BR_REC_ERR_CNTr_t;
#define BR_REC_ERR_CNTr_CLR BCM89500_A0_BR_REC_ERR_CNTr_CLR
#define BR_REC_ERR_CNTr_SET BCM89500_A0_BR_REC_ERR_CNTr_SET
#define BR_REC_ERR_CNTr_GET BCM89500_A0_BR_REC_ERR_CNTr_GET
#define BR_REC_ERR_CNTr_REC_ERR_CNTf_GET BCM89500_A0_BR_REC_ERR_CNTr_REC_ERR_CNTf_GET
#define BR_REC_ERR_CNTr_REC_ERR_CNTf_SET BCM89500_A0_BR_REC_ERR_CNTr_REC_ERR_CNTf_SET
#define READ_BR_REC_ERR_CNTr BCM89500_A0_READ_BR_REC_ERR_CNTr
#define WRITE_BR_REC_ERR_CNTr BCM89500_A0_WRITE_BR_REC_ERR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_REC_ERR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_REC_NOTOK_CNT
 * BLOCKS:   GPIC0
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_BR_REC_NOTOK_CNTr 0x00001028

#define BCM89500_A0_BR_REC_NOTOK_CNTr_SIZE 2

/*
 * This structure should be used to declare and program BR_REC_NOTOK_CNT.
 *
 */
typedef union BCM89500_A0_BR_REC_NOTOK_CNTr_s {
	uint32_t v[1];
	uint32_t br_rec_notok_cnt[1];
	uint32_t _br_rec_notok_cnt;
} BCM89500_A0_BR_REC_NOTOK_CNTr_t;

#define BCM89500_A0_BR_REC_NOTOK_CNTr_CLR(r) (r).br_rec_notok_cnt[0] = 0
#define BCM89500_A0_BR_REC_NOTOK_CNTr_SET(r,d) (r).br_rec_notok_cnt[0] = d
#define BCM89500_A0_BR_REC_NOTOK_CNTr_GET(r) (r).br_rec_notok_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).br_rec_notok_cnt[0]) & 0xff)
#define BCM89500_A0_BR_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).br_rec_notok_cnt[0]=(((r).br_rec_notok_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_BR_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).br_rec_notok_cnt[0]) >> 8) & 0xff)
#define BCM89500_A0_BR_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).br_rec_notok_cnt[0]=(((r).br_rec_notok_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access BR_REC_NOTOK_CNT.
 *
 */
#define BCM89500_A0_READ_BR_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_REC_NOTOK_CNTr,(r._br_rec_notok_cnt),2)
#define BCM89500_A0_WRITE_BR_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_REC_NOTOK_CNTr,&(r._br_rec_notok_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_REC_NOTOK_CNTr BCM89500_A0_BR_REC_NOTOK_CNTr
#define BR_REC_NOTOK_CNTr_SIZE BCM89500_A0_BR_REC_NOTOK_CNTr_SIZE
typedef BCM89500_A0_BR_REC_NOTOK_CNTr_t BR_REC_NOTOK_CNTr_t;
#define BR_REC_NOTOK_CNTr_CLR BCM89500_A0_BR_REC_NOTOK_CNTr_CLR
#define BR_REC_NOTOK_CNTr_SET BCM89500_A0_BR_REC_NOTOK_CNTr_SET
#define BR_REC_NOTOK_CNTr_GET BCM89500_A0_BR_REC_NOTOK_CNTr_GET
#define BR_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_BR_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET
#define BR_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_BR_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET
#define BR_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_BR_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET
#define BR_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_BR_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_BR_REC_NOTOK_CNTr BCM89500_A0_READ_BR_REC_NOTOK_CNTr
#define WRITE_BR_REC_NOTOK_CNTr BCM89500_A0_WRITE_BR_REC_NOTOK_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_REC_NOTOK_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  BR_TEST1
 * BLOCKS:   GPIC0
 * DESC:     Test Register 1
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Write as 0, ignore on read.
 *     MANUAL_SWAP_MDI_STATE 1 = Swap0 = off
 *     MAN_SWP_MDI_ST   
 *     RESERVED_1       Write as 0, ignore on read.
 *     FORCE_LINK       1 = force link state machine into pass state0 = normal operation
 *     RESERVED_2       Write as 00, ignore on read.
 *     TX_ERR_CODE_VIS  
 *     CRC_ERROR_COUNT  1 = receiver NOT_OK counters merged into one 16 bit counter to count CRC errors instead (crc errors will only be counted after this bit is set!)0 = normal operation
 *     CRC_ERR_CNT_SEL  
 *
 ******************************************************************************/
#define BCM89500_A0_BR_TEST1r 0x0000103c

#define BCM89500_A0_BR_TEST1r_SIZE 2

/*
 * This structure should be used to declare and program BR_TEST1.
 *
 */
typedef union BCM89500_A0_BR_TEST1r_s {
	uint32_t v[1];
	uint32_t br_test1[1];
	uint32_t _br_test1;
} BCM89500_A0_BR_TEST1r_t;

#define BCM89500_A0_BR_TEST1r_CLR(r) (r).br_test1[0] = 0
#define BCM89500_A0_BR_TEST1r_SET(r,d) (r).br_test1[0] = d
#define BCM89500_A0_BR_TEST1r_GET(r) (r).br_test1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BR_TEST1r_RESERVED_0f_GET(r) (((r).br_test1[0]) & 0x7f)
#define BCM89500_A0_BR_TEST1r_RESERVED_0f_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM89500_A0_BR_TEST1r_MANUAL_SWAP_MDI_STATEf_GET(r) ((((r).br_test1[0]) >> 7) & 0x1)
#define BCM89500_A0_BR_TEST1r_MANUAL_SWAP_MDI_STATEf_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_BR_TEST1r_MAN_SWP_MDI_STf_GET(r) ((((r).br_test1[0]) >> 7) & 0x1)
#define BCM89500_A0_BR_TEST1r_MAN_SWP_MDI_STf_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_BR_TEST1r_RESERVED_1f_GET(r) ((((r).br_test1[0]) >> 8) & 0xf)
#define BCM89500_A0_BR_TEST1r_RESERVED_1f_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_BR_TEST1r_FORCE_LINKf_GET(r) ((((r).br_test1[0]) >> 12) & 0x1)
#define BCM89500_A0_BR_TEST1r_FORCE_LINKf_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_BR_TEST1r_RESERVED_2f_GET(r) ((((r).br_test1[0]) >> 13) & 0x3)
#define BCM89500_A0_BR_TEST1r_RESERVED_2f_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_BR_TEST1r_TX_ERR_CODE_VISf_GET(r) ((((r).br_test1[0]) >> 14) & 0x1)
#define BCM89500_A0_BR_TEST1r_TX_ERR_CODE_VISf_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_BR_TEST1r_CRC_ERROR_COUNTf_GET(r) ((((r).br_test1[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_TEST1r_CRC_ERROR_COUNTf_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_BR_TEST1r_CRC_ERR_CNT_SELf_GET(r) ((((r).br_test1[0]) >> 15) & 0x1)
#define BCM89500_A0_BR_TEST1r_CRC_ERR_CNT_SELf_SET(r,f) (r).br_test1[0]=(((r).br_test1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access BR_TEST1.
 *
 */
#define BCM89500_A0_READ_BR_TEST1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_BR_TEST1r,(r._br_test1),2)
#define BCM89500_A0_WRITE_BR_TEST1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_BR_TEST1r,&(r._br_test1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BR_TEST1r BCM89500_A0_BR_TEST1r
#define BR_TEST1r_SIZE BCM89500_A0_BR_TEST1r_SIZE
typedef BCM89500_A0_BR_TEST1r_t BR_TEST1r_t;
#define BR_TEST1r_CLR BCM89500_A0_BR_TEST1r_CLR
#define BR_TEST1r_SET BCM89500_A0_BR_TEST1r_SET
#define BR_TEST1r_GET BCM89500_A0_BR_TEST1r_GET
#define BR_TEST1r_RESERVED_0f_GET BCM89500_A0_BR_TEST1r_RESERVED_0f_GET
#define BR_TEST1r_RESERVED_0f_SET BCM89500_A0_BR_TEST1r_RESERVED_0f_SET
#define BR_TEST1r_MANUAL_SWAP_MDI_STATEf_GET BCM89500_A0_BR_TEST1r_MANUAL_SWAP_MDI_STATEf_GET
#define BR_TEST1r_MANUAL_SWAP_MDI_STATEf_SET BCM89500_A0_BR_TEST1r_MANUAL_SWAP_MDI_STATEf_SET
#define BR_TEST1r_MAN_SWP_MDI_STf_GET BCM89500_A0_BR_TEST1r_MAN_SWP_MDI_STf_GET
#define BR_TEST1r_MAN_SWP_MDI_STf_SET BCM89500_A0_BR_TEST1r_MAN_SWP_MDI_STf_SET
#define BR_TEST1r_RESERVED_1f_GET BCM89500_A0_BR_TEST1r_RESERVED_1f_GET
#define BR_TEST1r_RESERVED_1f_SET BCM89500_A0_BR_TEST1r_RESERVED_1f_SET
#define BR_TEST1r_FORCE_LINKf_GET BCM89500_A0_BR_TEST1r_FORCE_LINKf_GET
#define BR_TEST1r_FORCE_LINKf_SET BCM89500_A0_BR_TEST1r_FORCE_LINKf_SET
#define BR_TEST1r_RESERVED_2f_GET BCM89500_A0_BR_TEST1r_RESERVED_2f_GET
#define BR_TEST1r_RESERVED_2f_SET BCM89500_A0_BR_TEST1r_RESERVED_2f_SET
#define BR_TEST1r_TX_ERR_CODE_VISf_GET BCM89500_A0_BR_TEST1r_TX_ERR_CODE_VISf_GET
#define BR_TEST1r_TX_ERR_CODE_VISf_SET BCM89500_A0_BR_TEST1r_TX_ERR_CODE_VISf_SET
#define BR_TEST1r_CRC_ERROR_COUNTf_GET BCM89500_A0_BR_TEST1r_CRC_ERROR_COUNTf_GET
#define BR_TEST1r_CRC_ERROR_COUNTf_SET BCM89500_A0_BR_TEST1r_CRC_ERROR_COUNTf_SET
#define BR_TEST1r_CRC_ERR_CNT_SELf_GET BCM89500_A0_BR_TEST1r_CRC_ERR_CNT_SELf_GET
#define BR_TEST1r_CRC_ERR_CNT_SELf_SET BCM89500_A0_BR_TEST1r_CRC_ERR_CNT_SELf_SET
#define READ_BR_TEST1r BCM89500_A0_READ_BR_TEST1r
#define WRITE_BR_TEST1r BCM89500_A0_WRITE_BR_TEST1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BR_TEST1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  BUFCON
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Control Table
 * SIZE:     72
 * FIELDS:
 *     NEXTBUFPTR       nextbufptr[8:0]
 *     UNTAGMAP         untagmap[6:0]
 *     PORTMAP          portmap[6:0]
 *     RXPORT           rxport[3:0]
 *     DSCP             dscp[5:0]
 *     PRESV_1P_TAG     presv_1p_tag
 *     FMLEN            fmlen[13:0]
 *     TC               tc[2:0]
 *     TS               ts
 *     RSN_CD           rsn_cd[5:0]
 *     TSRPT            tsrpt
 *     C_TAG            C_tag
 *     S_TAG            S_tag
 *     CLASS_ID         class_id[7:0]
 *     PRESV_PKT_FORMAT presv_pkt_format
 *     CVID0            cvid0
 *     SVID0            svid0
 *
 ******************************************************************************/
#define BCM89500_A0_BUFCONm 0x00000000

#define BCM89500_A0_BUFCONm_MIN 0
#define BCM89500_A0_BUFCONm_MAX 5119
#define BCM89500_A0_BUFCONm_CMAX(u) 5119
#define BCM89500_A0_BUFCONm_SIZE 9

/*
 * This structure should be used to declare and program BUFCON.
 *
 */
typedef union BCM89500_A0_BUFCONm_s {
	uint32_t v[3];
	uint32_t bufcon[3];
	uint32_t _bufcon;
} BCM89500_A0_BUFCONm_t;

#define BCM89500_A0_BUFCONm_CLR(r) CDK_MEMSET(&((r)._bufcon), 0, sizeof(BCM89500_A0_BUFCONm_t))
#define BCM89500_A0_BUFCONm_SET(r,i,d) (r).bufcon[i] = d
#define BCM89500_A0_BUFCONm_GET(r,i) (r).bufcon[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_BUFCONm_NEXTBUFPTRf_GET(r) (((r).bufcon[0]) & 0x1ff)
#define BCM89500_A0_BUFCONm_NEXTBUFPTRf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_BUFCONm_UNTAGMAPf_GET(r) ((((r).bufcon[0]) >> 9) & 0x7f)
#define BCM89500_A0_BUFCONm_UNTAGMAPf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM89500_A0_BUFCONm_PORTMAPf_GET(r) ((((r).bufcon[0]) >> 16) & 0x7f)
#define BCM89500_A0_BUFCONm_PORTMAPf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM89500_A0_BUFCONm_RXPORTf_GET(r) ((((r).bufcon[0]) >> 23) & 0xf)
#define BCM89500_A0_BUFCONm_RXPORTf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0xf << 23)) | ((((uint32_t)f) & 0xf) << 23))
#define BCM89500_A0_BUFCONm_DSCPf_GET(r) cdk_field32_get((r).bufcon,27,32)
#define BCM89500_A0_BUFCONm_DSCPf_SET(r,f) cdk_field32_set((r).bufcon,27,32,f)
#define BCM89500_A0_BUFCONm_PRESV_1P_TAGf_GET(r) ((((r).bufcon[1]) >> 1) & 0x1)
#define BCM89500_A0_BUFCONm_PRESV_1P_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_BUFCONm_FMLENf_GET(r) ((((r).bufcon[1]) >> 2) & 0x3fff)
#define BCM89500_A0_BUFCONm_FMLENf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCM89500_A0_BUFCONm_TCf_GET(r) ((((r).bufcon[1]) >> 16) & 0x7)
#define BCM89500_A0_BUFCONm_TCf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM89500_A0_BUFCONm_TSf_GET(r) ((((r).bufcon[1]) >> 19) & 0x1)
#define BCM89500_A0_BUFCONm_TSf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_BUFCONm_RSN_CDf_GET(r) ((((r).bufcon[1]) >> 20) & 0x3f)
#define BCM89500_A0_BUFCONm_RSN_CDf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM89500_A0_BUFCONm_TSRPTf_GET(r) ((((r).bufcon[1]) >> 26) & 0x1)
#define BCM89500_A0_BUFCONm_TSRPTf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_BUFCONm_C_TAGf_GET(r) ((((r).bufcon[1]) >> 27) & 0x1)
#define BCM89500_A0_BUFCONm_C_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_BUFCONm_S_TAGf_GET(r) ((((r).bufcon[1]) >> 28) & 0x1)
#define BCM89500_A0_BUFCONm_S_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_BUFCONm_CLASS_IDf_GET(r) cdk_field32_get((r).bufcon,61,68)
#define BCM89500_A0_BUFCONm_CLASS_IDf_SET(r,f) cdk_field32_set((r).bufcon,61,68,f)
#define BCM89500_A0_BUFCONm_PRESV_PKT_FORMATf_GET(r) ((((r).bufcon[2]) >> 5) & 0x1)
#define BCM89500_A0_BUFCONm_PRESV_PKT_FORMATf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_BUFCONm_CVID0f_GET(r) ((((r).bufcon[2]) >> 6) & 0x1)
#define BCM89500_A0_BUFCONm_CVID0f_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_BUFCONm_SVID0f_GET(r) ((((r).bufcon[2]) >> 7) & 0x1)
#define BCM89500_A0_BUFCONm_SVID0f_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access BUFCON.
 *
 */
#define BCM89500_A0_READ_BUFCONm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_BUFCONm,i,(m),9)
#define BCM89500_A0_WRITE_BUFCONm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_BUFCONm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCONm BCM89500_A0_BUFCONm
#define BUFCONm_MIN BCM89500_A0_BUFCONm_MIN
#define BUFCONm_MAX BCM89500_A0_BUFCONm_MAX
#define BUFCONm_CMAX(u) BCM89500_A0_BUFCONm_CMAX(u)
#define BUFCONm_SIZE BCM89500_A0_BUFCONm_SIZE
typedef BCM89500_A0_BUFCONm_t BUFCONm_t;
#define BUFCONm_CLR BCM89500_A0_BUFCONm_CLR
#define BUFCONm_SET BCM89500_A0_BUFCONm_SET
#define BUFCONm_GET BCM89500_A0_BUFCONm_GET
#define BUFCONm_NEXTBUFPTRf_GET BCM89500_A0_BUFCONm_NEXTBUFPTRf_GET
#define BUFCONm_NEXTBUFPTRf_SET BCM89500_A0_BUFCONm_NEXTBUFPTRf_SET
#define BUFCONm_UNTAGMAPf_GET BCM89500_A0_BUFCONm_UNTAGMAPf_GET
#define BUFCONm_UNTAGMAPf_SET BCM89500_A0_BUFCONm_UNTAGMAPf_SET
#define BUFCONm_PORTMAPf_GET BCM89500_A0_BUFCONm_PORTMAPf_GET
#define BUFCONm_PORTMAPf_SET BCM89500_A0_BUFCONm_PORTMAPf_SET
#define BUFCONm_RXPORTf_GET BCM89500_A0_BUFCONm_RXPORTf_GET
#define BUFCONm_RXPORTf_SET BCM89500_A0_BUFCONm_RXPORTf_SET
#define BUFCONm_DSCPf_GET BCM89500_A0_BUFCONm_DSCPf_GET
#define BUFCONm_DSCPf_SET BCM89500_A0_BUFCONm_DSCPf_SET
#define BUFCONm_PRESV_1P_TAGf_GET BCM89500_A0_BUFCONm_PRESV_1P_TAGf_GET
#define BUFCONm_PRESV_1P_TAGf_SET BCM89500_A0_BUFCONm_PRESV_1P_TAGf_SET
#define BUFCONm_FMLENf_GET BCM89500_A0_BUFCONm_FMLENf_GET
#define BUFCONm_FMLENf_SET BCM89500_A0_BUFCONm_FMLENf_SET
#define BUFCONm_TCf_GET BCM89500_A0_BUFCONm_TCf_GET
#define BUFCONm_TCf_SET BCM89500_A0_BUFCONm_TCf_SET
#define BUFCONm_TSf_GET BCM89500_A0_BUFCONm_TSf_GET
#define BUFCONm_TSf_SET BCM89500_A0_BUFCONm_TSf_SET
#define BUFCONm_RSN_CDf_GET BCM89500_A0_BUFCONm_RSN_CDf_GET
#define BUFCONm_RSN_CDf_SET BCM89500_A0_BUFCONm_RSN_CDf_SET
#define BUFCONm_TSRPTf_GET BCM89500_A0_BUFCONm_TSRPTf_GET
#define BUFCONm_TSRPTf_SET BCM89500_A0_BUFCONm_TSRPTf_SET
#define BUFCONm_C_TAGf_GET BCM89500_A0_BUFCONm_C_TAGf_GET
#define BUFCONm_C_TAGf_SET BCM89500_A0_BUFCONm_C_TAGf_SET
#define BUFCONm_S_TAGf_GET BCM89500_A0_BUFCONm_S_TAGf_GET
#define BUFCONm_S_TAGf_SET BCM89500_A0_BUFCONm_S_TAGf_SET
#define BUFCONm_CLASS_IDf_GET BCM89500_A0_BUFCONm_CLASS_IDf_GET
#define BUFCONm_CLASS_IDf_SET BCM89500_A0_BUFCONm_CLASS_IDf_SET
#define BUFCONm_PRESV_PKT_FORMATf_GET BCM89500_A0_BUFCONm_PRESV_PKT_FORMATf_GET
#define BUFCONm_PRESV_PKT_FORMATf_SET BCM89500_A0_BUFCONm_PRESV_PKT_FORMATf_SET
#define BUFCONm_CVID0f_GET BCM89500_A0_BUFCONm_CVID0f_GET
#define BUFCONm_CVID0f_SET BCM89500_A0_BUFCONm_CVID0f_SET
#define BUFCONm_SVID0f_GET BCM89500_A0_BUFCONm_SVID0f_GET
#define BUFCONm_SVID0f_SET BCM89500_A0_BUFCONm_SVID0f_SET
#define READ_BUFCONm BCM89500_A0_READ_BUFCONm
#define WRITE_BUFCONm BCM89500_A0_WRITE_BUFCONm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_BUFCONm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CFP_ACC
 * BLOCKS:   SYS
 * DESC:     CFP Access Registers
 * SIZE:     32
 * FIELDS:
 *     OP_STR_DONE      Operation Start.Software set this bit to start the operation after having configured all the necessary operation related information to the registers.Hardware automatically clear this bit when the operation is done. For read and write operation, this bit is clear when a single read or write operation is done. For search operation, this bit is clear only when all the searches are done. For TCAM reset, software needn't to set this bit to start the reset.
 *     OP_SEL           Operational Select.3'b000: No op3'b001: Read operation (for TCAM and RAM)3'b010: Write operation (for TCAM and RAM)3'b100: Search operation (for TCAM only)others: reserved
 *     CFP_RAM_CLEAR    CFP RAM ClearWhen this bit is set, the CFP Action RAM, Rate Meter, and Static counters will be clear. This bit will be auto-cleared by hardware when the clear is done.
 *     RESERVED_0       
 *     RAM_SEL          RAM Selection.This field selects the target of the operation.5'b1_0000: Out-band Statistic RAM5'b0_1000: In-band Statistic RAM5'b0_0100: Rate Meter RAM5'b0_0010: Action/policy RAM5'b0_0001: TCAM5'b0_0000: no operationothers: not allowed
 *     TCAM_RST         TCAM Reset.Software set this bit to reset all the valid bit of all entries of the TCAM. It is necessary that software to perform TCAM reset before start to programming the TCAM, if software is not going to program all the entries in the TCAM.Software can only reset the TCAM while CFP is in disable state, i.e., no any port is enabled to request CFP lookup. Software is not allowed to reset TCAM in the middle of CFP lookup.Hardware automatically clear this bit when the reset operation is done.
 *     XCESS_ADDR       Access Address.This field indicates the address offset of the RAM blocks for the operation.For read and write operation, this is the target address for the TCAM and RAM blocks.For search operation, this is the initial search address which set by the software.This field contains the address of a valid content when the search_status is set.Hardware finishes search operation whenever it reaches the last entry of the TCAM.
 *     RESERVED_1       Reserved
 *     RESERVED_2       Reserved
 *     SERCH_STS        Search Status.This field indicates the status of search operation.Hardware will set this bit whenever a valid search content has been updated at the TCAM data register 0-7, and the address has been updated at the address bits of this register.Hardware will auto clear this bit whenever software read this register.After software read this bit as '1', software need to read TCAM_DATA0_REG to TCAM_DATA7_REG, and TCAM_MASK0_REG to TCAM_MASK7_REG.Hardware uses the "read operation" of TCAM_DATA7_REG as the signal of starting search again, in this case, software need to be carefully arrange the order of reading the TCAM data and mask registers.The TCAM_DATA7_REG need to the last one to read, otherwise, the TCAM data or mask registers might be overwritten by the next valid entry.
 *     RD_STS           Read Status.This field indicates the status of read operation.  1  means read data valid,  0  means read data not yet valid. Hardware will auto clear this bit whenever software read this register.4'b1000: Statistic RAM4'b0100: Rate Meter RAM4'b0010: Action/policy RAM4'b0001: TCAM4'b0000: Not readyOthers: not allowed
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_ACCr 0x0000a000

#define BCM89500_A0_CFP_ACCr_SIZE 4

/*
 * This structure should be used to declare and program CFP_ACC.
 *
 */
typedef union BCM89500_A0_CFP_ACCr_s {
	uint32_t v[1];
	uint32_t cfp_acc[1];
	uint32_t _cfp_acc;
} BCM89500_A0_CFP_ACCr_t;

#define BCM89500_A0_CFP_ACCr_CLR(r) (r).cfp_acc[0] = 0
#define BCM89500_A0_CFP_ACCr_SET(r,d) (r).cfp_acc[0] = d
#define BCM89500_A0_CFP_ACCr_GET(r) (r).cfp_acc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_ACCr_OP_STR_DONEf_GET(r) (((r).cfp_acc[0]) & 0x1)
#define BCM89500_A0_CFP_ACCr_OP_STR_DONEf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_ACCr_OP_SELf_GET(r) ((((r).cfp_acc[0]) >> 1) & 0x7)
#define BCM89500_A0_CFP_ACCr_OP_SELf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_CFP_ACCr_CFP_RAM_CLEARf_GET(r) ((((r).cfp_acc[0]) >> 4) & 0x1)
#define BCM89500_A0_CFP_ACCr_CFP_RAM_CLEARf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_ACCr_RESERVED_0f_GET(r) ((((r).cfp_acc[0]) >> 5) & 0x1f)
#define BCM89500_A0_CFP_ACCr_RESERVED_0f_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM89500_A0_CFP_ACCr_RAM_SELf_GET(r) ((((r).cfp_acc[0]) >> 10) & 0x1f)
#define BCM89500_A0_CFP_ACCr_RAM_SELf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM89500_A0_CFP_ACCr_TCAM_RSTf_GET(r) ((((r).cfp_acc[0]) >> 15) & 0x1)
#define BCM89500_A0_CFP_ACCr_TCAM_RSTf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_CFP_ACCr_XCESS_ADDRf_GET(r) ((((r).cfp_acc[0]) >> 16) & 0x7f)
#define BCM89500_A0_CFP_ACCr_XCESS_ADDRf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM89500_A0_CFP_ACCr_RESERVED_1f_GET(r) ((((r).cfp_acc[0]) >> 23) & 0x1)
#define BCM89500_A0_CFP_ACCr_RESERVED_1f_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM89500_A0_CFP_ACCr_RESERVED_2f_GET(r) ((((r).cfp_acc[0]) >> 24) & 0x7)
#define BCM89500_A0_CFP_ACCr_RESERVED_2f_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM89500_A0_CFP_ACCr_SERCH_STSf_GET(r) ((((r).cfp_acc[0]) >> 27) & 0x1)
#define BCM89500_A0_CFP_ACCr_SERCH_STSf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_ACCr_RD_STSf_GET(r) ((((r).cfp_acc[0]) >> 28) & 0xf)
#define BCM89500_A0_CFP_ACCr_RD_STSf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_ACC.
 *
 */
#define BCM89500_A0_READ_CFP_ACCr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CFP_ACCr,(r._cfp_acc),4)
#define BCM89500_A0_WRITE_CFP_ACCr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CFP_ACCr,&(r._cfp_acc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACCr BCM89500_A0_CFP_ACCr
#define CFP_ACCr_SIZE BCM89500_A0_CFP_ACCr_SIZE
typedef BCM89500_A0_CFP_ACCr_t CFP_ACCr_t;
#define CFP_ACCr_CLR BCM89500_A0_CFP_ACCr_CLR
#define CFP_ACCr_SET BCM89500_A0_CFP_ACCr_SET
#define CFP_ACCr_GET BCM89500_A0_CFP_ACCr_GET
#define CFP_ACCr_OP_STR_DONEf_GET BCM89500_A0_CFP_ACCr_OP_STR_DONEf_GET
#define CFP_ACCr_OP_STR_DONEf_SET BCM89500_A0_CFP_ACCr_OP_STR_DONEf_SET
#define CFP_ACCr_OP_SELf_GET BCM89500_A0_CFP_ACCr_OP_SELf_GET
#define CFP_ACCr_OP_SELf_SET BCM89500_A0_CFP_ACCr_OP_SELf_SET
#define CFP_ACCr_CFP_RAM_CLEARf_GET BCM89500_A0_CFP_ACCr_CFP_RAM_CLEARf_GET
#define CFP_ACCr_CFP_RAM_CLEARf_SET BCM89500_A0_CFP_ACCr_CFP_RAM_CLEARf_SET
#define CFP_ACCr_RESERVED_0f_GET BCM89500_A0_CFP_ACCr_RESERVED_0f_GET
#define CFP_ACCr_RESERVED_0f_SET BCM89500_A0_CFP_ACCr_RESERVED_0f_SET
#define CFP_ACCr_RAM_SELf_GET BCM89500_A0_CFP_ACCr_RAM_SELf_GET
#define CFP_ACCr_RAM_SELf_SET BCM89500_A0_CFP_ACCr_RAM_SELf_SET
#define CFP_ACCr_TCAM_RSTf_GET BCM89500_A0_CFP_ACCr_TCAM_RSTf_GET
#define CFP_ACCr_TCAM_RSTf_SET BCM89500_A0_CFP_ACCr_TCAM_RSTf_SET
#define CFP_ACCr_XCESS_ADDRf_GET BCM89500_A0_CFP_ACCr_XCESS_ADDRf_GET
#define CFP_ACCr_XCESS_ADDRf_SET BCM89500_A0_CFP_ACCr_XCESS_ADDRf_SET
#define CFP_ACCr_RESERVED_1f_GET BCM89500_A0_CFP_ACCr_RESERVED_1f_GET
#define CFP_ACCr_RESERVED_1f_SET BCM89500_A0_CFP_ACCr_RESERVED_1f_SET
#define CFP_ACCr_RESERVED_2f_GET BCM89500_A0_CFP_ACCr_RESERVED_2f_GET
#define CFP_ACCr_RESERVED_2f_SET BCM89500_A0_CFP_ACCr_RESERVED_2f_SET
#define CFP_ACCr_SERCH_STSf_GET BCM89500_A0_CFP_ACCr_SERCH_STSf_GET
#define CFP_ACCr_SERCH_STSf_SET BCM89500_A0_CFP_ACCr_SERCH_STSf_SET
#define CFP_ACCr_RD_STSf_GET BCM89500_A0_CFP_ACCr_RD_STSf_GET
#define CFP_ACCr_RD_STSf_SET BCM89500_A0_CFP_ACCr_RD_STSf_SET
#define READ_CFP_ACCr BCM89500_A0_READ_CFP_ACCr
#define WRITE_CFP_ACCr BCM89500_A0_WRITE_CFP_ACCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_ACCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_ACT_POL
 * BLOCKS:   SYS
 * DESC:     CFP_ACT_POL Table
 * SIZE:     64
 * FIELDS:
 *     VLAN_BYP         
 *     EAP_BYP          
 *     STP_BYP          
 *     REASON_CODE      
 *     LOOP_BK_EN       
 *     NEW_TC           
 *     CHANGE_TC        
 *     DST_MAP_IB       
 *     CHANGE_FWRD_MAP_IB 
 *     NEW_DSCP_IB      
 *     CHANGE_DSCP_IB   
 *     DST_MAP_OB       
 *     CHANGE_FWRD_MAP_OB 
 *     NEW_DSCP_OB      
 *     CHANGE_DSCP_OB   
 *     CHAIN_ID         
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_ACT_POLm 0x00005000

#define BCM89500_A0_CFP_ACT_POLm_MIN 0
#define BCM89500_A0_CFP_ACT_POLm_MAX 127
#define BCM89500_A0_CFP_ACT_POLm_CMAX(u) 127
#define BCM89500_A0_CFP_ACT_POLm_SIZE 8

/*
 * This structure should be used to declare and program CFP_ACT_POL.
 *
 */
typedef union BCM89500_A0_CFP_ACT_POLm_s {
	uint32_t v[2];
	uint32_t cfp_act_pol[2];
	uint32_t _cfp_act_pol;
} BCM89500_A0_CFP_ACT_POLm_t;

#define BCM89500_A0_CFP_ACT_POLm_CLR(r) CDK_MEMSET(&((r)._cfp_act_pol), 0, sizeof(BCM89500_A0_CFP_ACT_POLm_t))
#define BCM89500_A0_CFP_ACT_POLm_SET(r,i,d) (r).cfp_act_pol[i] = d
#define BCM89500_A0_CFP_ACT_POLm_GET(r,i) (r).cfp_act_pol[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_ACT_POLm_VLAN_BYPf_GET(r) (((r).cfp_act_pol[0]) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_VLAN_BYPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_ACT_POLm_EAP_BYPf_GET(r) ((((r).cfp_act_pol[0]) >> 1) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_EAP_BYPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_CFP_ACT_POLm_STP_BYPf_GET(r) ((((r).cfp_act_pol[0]) >> 2) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_STP_BYPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_CFP_ACT_POLm_REASON_CODEf_GET(r) ((((r).cfp_act_pol[0]) >> 3) & 0x3f)
#define BCM89500_A0_CFP_ACT_POLm_REASON_CODEf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM89500_A0_CFP_ACT_POLm_LOOP_BK_ENf_GET(r) ((((r).cfp_act_pol[0]) >> 9) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_LOOP_BK_ENf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_CFP_ACT_POLm_NEW_TCf_GET(r) ((((r).cfp_act_pol[0]) >> 10) & 0x7)
#define BCM89500_A0_CFP_ACT_POLm_NEW_TCf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_TCf_GET(r) ((((r).cfp_act_pol[0]) >> 13) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_TCf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_CFP_ACT_POLm_DST_MAP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 14) & 0x3ff)
#define BCM89500_A0_CFP_ACT_POLm_DST_MAP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 24) & 0x3)
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 26) & 0x3f)
#define BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_GET(r) (((r).cfp_act_pol[1]) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_ACT_POLm_DST_MAP_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 1) & 0x3ff)
#define BCM89500_A0_CFP_ACT_POLm_DST_MAP_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 11) & 0x3)
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 13) & 0x3f)
#define BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3f << 13)) | ((((uint32_t)f) & 0x3f) << 13))
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 19) & 0x1)
#define BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_CFP_ACT_POLm_CHAIN_IDf_GET(r) ((((r).cfp_act_pol[1]) >> 20) & 0xff)
#define BCM89500_A0_CFP_ACT_POLm_CHAIN_IDf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0xff << 20)) | ((((uint32_t)f) & 0xff) << 20))
#define BCM89500_A0_CFP_ACT_POLm_RESERVED_1Rf_GET(r) ((((r).cfp_act_pol[1]) >> 28) & 0xf)
#define BCM89500_A0_CFP_ACT_POLm_RESERVED_1Rf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_ACT_POL.
 *
 */
#define BCM89500_A0_READ_CFP_ACT_POLm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_ACT_POLm,i,(m),8)
#define BCM89500_A0_WRITE_CFP_ACT_POLm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_ACT_POLm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACT_POLm BCM89500_A0_CFP_ACT_POLm
#define CFP_ACT_POLm_MIN BCM89500_A0_CFP_ACT_POLm_MIN
#define CFP_ACT_POLm_MAX BCM89500_A0_CFP_ACT_POLm_MAX
#define CFP_ACT_POLm_CMAX(u) BCM89500_A0_CFP_ACT_POLm_CMAX(u)
#define CFP_ACT_POLm_SIZE BCM89500_A0_CFP_ACT_POLm_SIZE
typedef BCM89500_A0_CFP_ACT_POLm_t CFP_ACT_POLm_t;
#define CFP_ACT_POLm_CLR BCM89500_A0_CFP_ACT_POLm_CLR
#define CFP_ACT_POLm_SET BCM89500_A0_CFP_ACT_POLm_SET
#define CFP_ACT_POLm_GET BCM89500_A0_CFP_ACT_POLm_GET
#define CFP_ACT_POLm_VLAN_BYPf_GET BCM89500_A0_CFP_ACT_POLm_VLAN_BYPf_GET
#define CFP_ACT_POLm_VLAN_BYPf_SET BCM89500_A0_CFP_ACT_POLm_VLAN_BYPf_SET
#define CFP_ACT_POLm_EAP_BYPf_GET BCM89500_A0_CFP_ACT_POLm_EAP_BYPf_GET
#define CFP_ACT_POLm_EAP_BYPf_SET BCM89500_A0_CFP_ACT_POLm_EAP_BYPf_SET
#define CFP_ACT_POLm_STP_BYPf_GET BCM89500_A0_CFP_ACT_POLm_STP_BYPf_GET
#define CFP_ACT_POLm_STP_BYPf_SET BCM89500_A0_CFP_ACT_POLm_STP_BYPf_SET
#define CFP_ACT_POLm_REASON_CODEf_GET BCM89500_A0_CFP_ACT_POLm_REASON_CODEf_GET
#define CFP_ACT_POLm_REASON_CODEf_SET BCM89500_A0_CFP_ACT_POLm_REASON_CODEf_SET
#define CFP_ACT_POLm_LOOP_BK_ENf_GET BCM89500_A0_CFP_ACT_POLm_LOOP_BK_ENf_GET
#define CFP_ACT_POLm_LOOP_BK_ENf_SET BCM89500_A0_CFP_ACT_POLm_LOOP_BK_ENf_SET
#define CFP_ACT_POLm_NEW_TCf_GET BCM89500_A0_CFP_ACT_POLm_NEW_TCf_GET
#define CFP_ACT_POLm_NEW_TCf_SET BCM89500_A0_CFP_ACT_POLm_NEW_TCf_SET
#define CFP_ACT_POLm_CHANGE_TCf_GET BCM89500_A0_CFP_ACT_POLm_CHANGE_TCf_GET
#define CFP_ACT_POLm_CHANGE_TCf_SET BCM89500_A0_CFP_ACT_POLm_CHANGE_TCf_SET
#define CFP_ACT_POLm_DST_MAP_IBf_GET BCM89500_A0_CFP_ACT_POLm_DST_MAP_IBf_GET
#define CFP_ACT_POLm_DST_MAP_IBf_SET BCM89500_A0_CFP_ACT_POLm_DST_MAP_IBf_SET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_GET BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_GET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_SET BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_SET
#define CFP_ACT_POLm_NEW_DSCP_IBf_GET BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_IBf_GET
#define CFP_ACT_POLm_NEW_DSCP_IBf_SET BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_IBf_SET
#define CFP_ACT_POLm_CHANGE_DSCP_IBf_GET BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_GET
#define CFP_ACT_POLm_CHANGE_DSCP_IBf_SET BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_SET
#define CFP_ACT_POLm_DST_MAP_OBf_GET BCM89500_A0_CFP_ACT_POLm_DST_MAP_OBf_GET
#define CFP_ACT_POLm_DST_MAP_OBf_SET BCM89500_A0_CFP_ACT_POLm_DST_MAP_OBf_SET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_GET BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_GET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_SET BCM89500_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_SET
#define CFP_ACT_POLm_NEW_DSCP_OBf_GET BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_OBf_GET
#define CFP_ACT_POLm_NEW_DSCP_OBf_SET BCM89500_A0_CFP_ACT_POLm_NEW_DSCP_OBf_SET
#define CFP_ACT_POLm_CHANGE_DSCP_OBf_GET BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_GET
#define CFP_ACT_POLm_CHANGE_DSCP_OBf_SET BCM89500_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_SET
#define CFP_ACT_POLm_CHAIN_IDf_GET BCM89500_A0_CFP_ACT_POLm_CHAIN_IDf_GET
#define CFP_ACT_POLm_CHAIN_IDf_SET BCM89500_A0_CFP_ACT_POLm_CHAIN_IDf_SET
#define CFP_ACT_POLm_RESERVED_1Rf_GET BCM89500_A0_CFP_ACT_POLm_RESERVED_1Rf_GET
#define CFP_ACT_POLm_RESERVED_1Rf_SET BCM89500_A0_CFP_ACT_POLm_RESERVED_1Rf_SET
#define READ_CFP_ACT_POLm BCM89500_A0_READ_CFP_ACT_POLm
#define WRITE_CFP_ACT_POLm BCM89500_A0_WRITE_CFP_ACT_POLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_ACT_POLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CFP_CTL_REG
 * BLOCKS:   SYS
 * DESC:     CFP Control Registers
 * SIZE:     16
 * FIELDS:
 *     CFP_EN_MAP       The bitmap to enable CFP function. When set to one, the corresponding port CFP feature is enabled.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_CTL_REGr 0x0000a100

#define BCM89500_A0_CFP_CTL_REGr_SIZE 2

/*
 * This structure should be used to declare and program CFP_CTL_REG.
 *
 */
typedef union BCM89500_A0_CFP_CTL_REGr_s {
	uint32_t v[1];
	uint32_t cfp_ctl_reg[1];
	uint32_t _cfp_ctl_reg;
} BCM89500_A0_CFP_CTL_REGr_t;

#define BCM89500_A0_CFP_CTL_REGr_CLR(r) (r).cfp_ctl_reg[0] = 0
#define BCM89500_A0_CFP_CTL_REGr_SET(r,d) (r).cfp_ctl_reg[0] = d
#define BCM89500_A0_CFP_CTL_REGr_GET(r) (r).cfp_ctl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_CTL_REGr_CFP_EN_MAPf_GET(r) (((r).cfp_ctl_reg[0]) & 0x1ff)
#define BCM89500_A0_CFP_CTL_REGr_CFP_EN_MAPf_SET(r,f) (r).cfp_ctl_reg[0]=(((r).cfp_ctl_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_CFP_CTL_REGr_RESERVEDf_GET(r) ((((r).cfp_ctl_reg[0]) >> 9) & 0x7f)
#define BCM89500_A0_CFP_CTL_REGr_RESERVEDf_SET(r,f) (r).cfp_ctl_reg[0]=(((r).cfp_ctl_reg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access CFP_CTL_REG.
 *
 */
#define BCM89500_A0_READ_CFP_CTL_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CFP_CTL_REGr,(r._cfp_ctl_reg),2)
#define BCM89500_A0_WRITE_CFP_CTL_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CFP_CTL_REGr,&(r._cfp_ctl_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_CTL_REGr BCM89500_A0_CFP_CTL_REGr
#define CFP_CTL_REGr_SIZE BCM89500_A0_CFP_CTL_REGr_SIZE
typedef BCM89500_A0_CFP_CTL_REGr_t CFP_CTL_REGr_t;
#define CFP_CTL_REGr_CLR BCM89500_A0_CFP_CTL_REGr_CLR
#define CFP_CTL_REGr_SET BCM89500_A0_CFP_CTL_REGr_SET
#define CFP_CTL_REGr_GET BCM89500_A0_CFP_CTL_REGr_GET
#define CFP_CTL_REGr_CFP_EN_MAPf_GET BCM89500_A0_CFP_CTL_REGr_CFP_EN_MAPf_GET
#define CFP_CTL_REGr_CFP_EN_MAPf_SET BCM89500_A0_CFP_CTL_REGr_CFP_EN_MAPf_SET
#define CFP_CTL_REGr_RESERVEDf_GET BCM89500_A0_CFP_CTL_REGr_RESERVEDf_GET
#define CFP_CTL_REGr_RESERVEDf_SET BCM89500_A0_CFP_CTL_REGr_RESERVEDf_SET
#define READ_CFP_CTL_REGr BCM89500_A0_READ_CFP_CTL_REGr
#define WRITE_CFP_CTL_REGr BCM89500_A0_WRITE_CFP_CTL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_CTL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CFP_DATA
 * BLOCKS:   SYS
 * DESC:     CFP TCAM Data X Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_DATA        TCAM Data.The rule data(please refer to slice format) to be read from or write to the TCAM data.Please note that the bit [1:0] of this register are the valid bits of the rule.These two bits should be b oth '1' to validate this entry.The rule's LSB is in this register bit[2].CFP_DATA0[31:0] for tcam_data[31:0]CFP_DATA1[31:0] for tcam_data[63:32]CFP_DATA2[31:0] for tcam_data[95:64]CFP_DATA3[31:0] for tcam_data[127:96]CFP_DATA4[31:0] for tcam_data[159:128]CFP_DATA5[31:0] for tcam_data[191:160]CFP_DATA6[31:0] for tcam_data[223:192]CFP_DATA7[31:0] for tcam_data[231:224]CFP_DATA7[31:8] for Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_DATAr 0x0000a010

#define BCM89500_A0_CFP_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CFP_DATA.
 *
 */
typedef union BCM89500_A0_CFP_DATAr_s {
	uint32_t v[1];
	uint32_t cfp_data[1];
	uint32_t _cfp_data;
} BCM89500_A0_CFP_DATAr_t;

#define BCM89500_A0_CFP_DATAr_CLR(r) (r).cfp_data[0] = 0
#define BCM89500_A0_CFP_DATAr_SET(r,d) (r).cfp_data[0] = d
#define BCM89500_A0_CFP_DATAr_GET(r) (r).cfp_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_DATAr_TCAM_DATAf_GET(r) ((r).cfp_data[0])
#define BCM89500_A0_CFP_DATAr_TCAM_DATAf_SET(r,f) (r).cfp_data[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_DATA.
 *
 */
#define BCM89500_A0_READ_CFP_DATAr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_CFP_DATAr+(4*(i)),(r._cfp_data),4)
#define BCM89500_A0_WRITE_CFP_DATAr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_CFP_DATAr+(4*(i)),&(r._cfp_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_DATAr BCM89500_A0_CFP_DATAr
#define CFP_DATAr_SIZE BCM89500_A0_CFP_DATAr_SIZE
typedef BCM89500_A0_CFP_DATAr_t CFP_DATAr_t;
#define CFP_DATAr_CLR BCM89500_A0_CFP_DATAr_CLR
#define CFP_DATAr_SET BCM89500_A0_CFP_DATAr_SET
#define CFP_DATAr_GET BCM89500_A0_CFP_DATAr_GET
#define CFP_DATAr_TCAM_DATAf_GET BCM89500_A0_CFP_DATAr_TCAM_DATAf_GET
#define CFP_DATAr_TCAM_DATAf_SET BCM89500_A0_CFP_DATAr_TCAM_DATAf_SET
#define READ_CFP_DATAr BCM89500_A0_READ_CFP_DATAr
#define WRITE_CFP_DATAr BCM89500_A0_WRITE_CFP_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CFP_MASK
 * BLOCKS:   SYS
 * DESC:     CFP TCAM Mask X Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_MASK        TCAM Data.The mask data to be read from or write to the TCAM mask.Please note that the bit [1:0] of this register are the valid bits of the rule.These two bits should be both '1' to validate this entry.The mask's LSB is in this register bit[2].CFP_MASK0[31:0] for tcam_mask[31:0]CFP_MASK1[31:0] for tcam_mask[63:32]CFP_MASK2[31:0] for tcam_mask[95:64]CFP_MASK3[31:0] for tcam_mask[127:96]CFP_MASK4[31:0] for tcam_mask[159:128]CFP_MASK5[24:0] for tcam_mask[185:160]CFP_MASK6[31:0] for tcam_mask[223:192]CFP_MASK7[31:0] for tcam_mask[231:224]CFP_MASK7[31:8] for Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_MASKr 0x0000a030

#define BCM89500_A0_CFP_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CFP_MASK.
 *
 */
typedef union BCM89500_A0_CFP_MASKr_s {
	uint32_t v[1];
	uint32_t cfp_mask[1];
	uint32_t _cfp_mask;
} BCM89500_A0_CFP_MASKr_t;

#define BCM89500_A0_CFP_MASKr_CLR(r) (r).cfp_mask[0] = 0
#define BCM89500_A0_CFP_MASKr_SET(r,d) (r).cfp_mask[0] = d
#define BCM89500_A0_CFP_MASKr_GET(r) (r).cfp_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_MASKr_TCAM_MASKf_GET(r) ((r).cfp_mask[0])
#define BCM89500_A0_CFP_MASKr_TCAM_MASKf_SET(r,f) (r).cfp_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_MASK.
 *
 */
#define BCM89500_A0_READ_CFP_MASKr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_CFP_MASKr+(4*(i)),(r._cfp_mask),4)
#define BCM89500_A0_WRITE_CFP_MASKr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_CFP_MASKr+(4*(i)),&(r._cfp_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_MASKr BCM89500_A0_CFP_MASKr
#define CFP_MASKr_SIZE BCM89500_A0_CFP_MASKr_SIZE
typedef BCM89500_A0_CFP_MASKr_t CFP_MASKr_t;
#define CFP_MASKr_CLR BCM89500_A0_CFP_MASKr_CLR
#define CFP_MASKr_SET BCM89500_A0_CFP_MASKr_SET
#define CFP_MASKr_GET BCM89500_A0_CFP_MASKr_GET
#define CFP_MASKr_TCAM_MASKf_GET BCM89500_A0_CFP_MASKr_TCAM_MASKf_GET
#define CFP_MASKr_TCAM_MASKf_SET BCM89500_A0_CFP_MASKr_TCAM_MASKf_SET
#define READ_CFP_MASKr BCM89500_A0_READ_CFP_MASKr
#define WRITE_CFP_MASKr BCM89500_A0_WRITE_CFP_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_METER
 * BLOCKS:   SYS
 * DESC:     CFP_METER Table
 * SIZE:     64
 * FIELDS:
 *     CURR_QUOTA       Current Quota.This field is initialized by software as the initial credit for each flow. And hardware will update the current quota according to the per flow rate meter scheme. The unit is in byte.
 *     RESERVED_1R      Reserved
 *     TOKEN_NUM        Token.This token to be added on each refresh cycle, theunit is 32 byte.
 *     REF_CAP          Reference CAP.This field indicates the max bucket size per flow need to keep track off. The unit is in byte.5'b0_0000: ref_cap = 24'b1111_1111_1111_1111_1111_1111;5'b0_0001: ref_cap = 24'b0111_1111_1111_1111_1111_1111;5'b0_0010: ref_cap = 24'b0011_1111_1111_1111_1111_1111;5'b0_0011: ref_cap = 24'b0001_1111_1111_1111_1111_1111;5'b0_0100: ref_cap = 24'b0000_1111_1111_1111_1111_1111;5'b0_0101: ref_cap = 24'b0000_0111_1111_1111_1111_1111;5'b0_0110: ref_cap = 24'b0000_0011_1111_1111_1111_1111;5'b0_0111: ref_cap = 24'b0000_0001_1111_1111_1111_1111;5'b0_1000: ref_cap = 24'b0000_0000_1111_1111_1111_1111;5'b0_1001: ref_cap = 24'b0000_0000_0111_1111_1111_1111;5'b0_1010: ref_cap = 24'b0000_0000_0011_1111_1111_1111;5'b0_1011: ref_cap = 24'b0000_0000_0001_1111_1111_1111;5'b0_1100: ref_cap = 24'b0000_0000_0000_1111_1111_1111;5'b0_1101: ref_cap = 24'b0000_0000_0000_0111_1111_1111;5'b0_1110: ref_cap = 24'b0000_0000_0000_0011_1111_1111;5'b0_1111: ref_cap = 24'b0000_0000_0000_0001_1111_1111;others: reserved
 *     RESERVED_2R      Reserved
 *     RATE_REFRESH_EN  Rate Meter Refresh Enable.This field enables hardware for rate meter refresh.Software should set this bit after the rate meter RAM has been initialized, and software would like to start rate meter refresh (Global control).
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_METERm 0x00005100

#define BCM89500_A0_CFP_METERm_MIN 0
#define BCM89500_A0_CFP_METERm_MAX 127
#define BCM89500_A0_CFP_METERm_CMAX(u) 127
#define BCM89500_A0_CFP_METERm_SIZE 8

/*
 * This structure should be used to declare and program CFP_METER.
 *
 */
typedef union BCM89500_A0_CFP_METERm_s {
	uint32_t v[2];
	uint32_t cfp_meter[2];
	uint32_t _cfp_meter;
} BCM89500_A0_CFP_METERm_t;

#define BCM89500_A0_CFP_METERm_CLR(r) CDK_MEMSET(&((r)._cfp_meter), 0, sizeof(BCM89500_A0_CFP_METERm_t))
#define BCM89500_A0_CFP_METERm_SET(r,i,d) (r).cfp_meter[i] = d
#define BCM89500_A0_CFP_METERm_GET(r,i) (r).cfp_meter[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_METERm_CURR_QUOTAf_GET(r) (((r).cfp_meter[0]) & 0xffffff)
#define BCM89500_A0_CFP_METERm_CURR_QUOTAf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM89500_A0_CFP_METERm_RESERVED_1Rf_GET(r) ((((r).cfp_meter[0]) >> 24) & 0xff)
#define BCM89500_A0_CFP_METERm_RESERVED_1Rf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM89500_A0_CFP_METERm_TOKEN_NUMf_GET(r) (((r).cfp_meter[1]) & 0xff)
#define BCM89500_A0_CFP_METERm_TOKEN_NUMf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_CFP_METERm_REF_CAPf_GET(r) ((((r).cfp_meter[1]) >> 8) & 0xf)
#define BCM89500_A0_CFP_METERm_REF_CAPf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_CFP_METERm_RESERVED_2Rf_GET(r) ((((r).cfp_meter[1]) >> 12) & 0x7ffff)
#define BCM89500_A0_CFP_METERm_RESERVED_2Rf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0x7ffff << 12)) | ((((uint32_t)f) & 0x7ffff) << 12))
#define BCM89500_A0_CFP_METERm_RATE_REFRESH_ENf_GET(r) ((((r).cfp_meter[1]) >> 31) & 0x1)
#define BCM89500_A0_CFP_METERm_RATE_REFRESH_ENf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CFP_METER.
 *
 */
#define BCM89500_A0_READ_CFP_METERm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_METERm,i,(m),8)
#define BCM89500_A0_WRITE_CFP_METERm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_METERm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_METERm BCM89500_A0_CFP_METERm
#define CFP_METERm_MIN BCM89500_A0_CFP_METERm_MIN
#define CFP_METERm_MAX BCM89500_A0_CFP_METERm_MAX
#define CFP_METERm_CMAX(u) BCM89500_A0_CFP_METERm_CMAX(u)
#define CFP_METERm_SIZE BCM89500_A0_CFP_METERm_SIZE
typedef BCM89500_A0_CFP_METERm_t CFP_METERm_t;
#define CFP_METERm_CLR BCM89500_A0_CFP_METERm_CLR
#define CFP_METERm_SET BCM89500_A0_CFP_METERm_SET
#define CFP_METERm_GET BCM89500_A0_CFP_METERm_GET
#define CFP_METERm_CURR_QUOTAf_GET BCM89500_A0_CFP_METERm_CURR_QUOTAf_GET
#define CFP_METERm_CURR_QUOTAf_SET BCM89500_A0_CFP_METERm_CURR_QUOTAf_SET
#define CFP_METERm_RESERVED_1Rf_GET BCM89500_A0_CFP_METERm_RESERVED_1Rf_GET
#define CFP_METERm_RESERVED_1Rf_SET BCM89500_A0_CFP_METERm_RESERVED_1Rf_SET
#define CFP_METERm_TOKEN_NUMf_GET BCM89500_A0_CFP_METERm_TOKEN_NUMf_GET
#define CFP_METERm_TOKEN_NUMf_SET BCM89500_A0_CFP_METERm_TOKEN_NUMf_SET
#define CFP_METERm_REF_CAPf_GET BCM89500_A0_CFP_METERm_REF_CAPf_GET
#define CFP_METERm_REF_CAPf_SET BCM89500_A0_CFP_METERm_REF_CAPf_SET
#define CFP_METERm_RESERVED_2Rf_GET BCM89500_A0_CFP_METERm_RESERVED_2Rf_GET
#define CFP_METERm_RESERVED_2Rf_SET BCM89500_A0_CFP_METERm_RESERVED_2Rf_SET
#define CFP_METERm_RATE_REFRESH_ENf_GET BCM89500_A0_CFP_METERm_RATE_REFRESH_ENf_GET
#define CFP_METERm_RATE_REFRESH_ENf_SET BCM89500_A0_CFP_METERm_RATE_REFRESH_ENf_SET
#define READ_CFP_METERm BCM89500_A0_READ_CFP_METERm
#define WRITE_CFP_METERm BCM89500_A0_WRITE_CFP_METERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_METERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_STAT_IB
 * BLOCKS:   SYS
 * DESC:     Statistic In-Band RAM
 * SIZE:     32
 * FIELDS:
 *     IN_BAND_CNT      In band counter
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_STAT_IBm 0x00005300

#define BCM89500_A0_CFP_STAT_IBm_MIN 0
#define BCM89500_A0_CFP_STAT_IBm_MAX 127
#define BCM89500_A0_CFP_STAT_IBm_CMAX(u) 127
#define BCM89500_A0_CFP_STAT_IBm_SIZE 4

/*
 * This structure should be used to declare and program CFP_STAT_IB.
 *
 */
typedef union BCM89500_A0_CFP_STAT_IBm_s {
	uint32_t v[1];
	uint32_t cfp_stat_ib[1];
	uint32_t _cfp_stat_ib;
} BCM89500_A0_CFP_STAT_IBm_t;

#define BCM89500_A0_CFP_STAT_IBm_CLR(r) (r).cfp_stat_ib[0] = 0
#define BCM89500_A0_CFP_STAT_IBm_SET(r,d) (r).cfp_stat_ib[0] = d
#define BCM89500_A0_CFP_STAT_IBm_GET(r) (r).cfp_stat_ib[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_STAT_IBm_IN_BAND_CNTf_GET(r) ((r).cfp_stat_ib[0])
#define BCM89500_A0_CFP_STAT_IBm_IN_BAND_CNTf_SET(r,f) (r).cfp_stat_ib[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT_IB.
 *
 */
#define BCM89500_A0_READ_CFP_STAT_IBm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_STAT_IBm,i,(m),4)
#define BCM89500_A0_WRITE_CFP_STAT_IBm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_STAT_IBm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STAT_IBm BCM89500_A0_CFP_STAT_IBm
#define CFP_STAT_IBm_MIN BCM89500_A0_CFP_STAT_IBm_MIN
#define CFP_STAT_IBm_MAX BCM89500_A0_CFP_STAT_IBm_MAX
#define CFP_STAT_IBm_CMAX(u) BCM89500_A0_CFP_STAT_IBm_CMAX(u)
#define CFP_STAT_IBm_SIZE BCM89500_A0_CFP_STAT_IBm_SIZE
typedef BCM89500_A0_CFP_STAT_IBm_t CFP_STAT_IBm_t;
#define CFP_STAT_IBm_CLR BCM89500_A0_CFP_STAT_IBm_CLR
#define CFP_STAT_IBm_SET BCM89500_A0_CFP_STAT_IBm_SET
#define CFP_STAT_IBm_GET BCM89500_A0_CFP_STAT_IBm_GET
#define CFP_STAT_IBm_IN_BAND_CNTf_GET BCM89500_A0_CFP_STAT_IBm_IN_BAND_CNTf_GET
#define CFP_STAT_IBm_IN_BAND_CNTf_SET BCM89500_A0_CFP_STAT_IBm_IN_BAND_CNTf_SET
#define READ_CFP_STAT_IBm BCM89500_A0_READ_CFP_STAT_IBm
#define WRITE_CFP_STAT_IBm BCM89500_A0_WRITE_CFP_STAT_IBm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_STAT_IBm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_STAT_OB
 * BLOCKS:   SYS
 * DESC:     Statistic Out-Band RAM
 * SIZE:     32
 * FIELDS:
 *     OUT_BAND_CNT     Out band counter
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_STAT_OBm 0x00005200

#define BCM89500_A0_CFP_STAT_OBm_MIN 0
#define BCM89500_A0_CFP_STAT_OBm_MAX 127
#define BCM89500_A0_CFP_STAT_OBm_CMAX(u) 127
#define BCM89500_A0_CFP_STAT_OBm_SIZE 4

/*
 * This structure should be used to declare and program CFP_STAT_OB.
 *
 */
typedef union BCM89500_A0_CFP_STAT_OBm_s {
	uint32_t v[1];
	uint32_t cfp_stat_ob[1];
	uint32_t _cfp_stat_ob;
} BCM89500_A0_CFP_STAT_OBm_t;

#define BCM89500_A0_CFP_STAT_OBm_CLR(r) (r).cfp_stat_ob[0] = 0
#define BCM89500_A0_CFP_STAT_OBm_SET(r,d) (r).cfp_stat_ob[0] = d
#define BCM89500_A0_CFP_STAT_OBm_GET(r) (r).cfp_stat_ob[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_STAT_OBm_OUT_BAND_CNTf_GET(r) ((r).cfp_stat_ob[0])
#define BCM89500_A0_CFP_STAT_OBm_OUT_BAND_CNTf_SET(r,f) (r).cfp_stat_ob[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT_OB.
 *
 */
#define BCM89500_A0_READ_CFP_STAT_OBm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_STAT_OBm,i,(m),4)
#define BCM89500_A0_WRITE_CFP_STAT_OBm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_STAT_OBm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STAT_OBm BCM89500_A0_CFP_STAT_OBm
#define CFP_STAT_OBm_MIN BCM89500_A0_CFP_STAT_OBm_MIN
#define CFP_STAT_OBm_MAX BCM89500_A0_CFP_STAT_OBm_MAX
#define CFP_STAT_OBm_CMAX(u) BCM89500_A0_CFP_STAT_OBm_CMAX(u)
#define CFP_STAT_OBm_SIZE BCM89500_A0_CFP_STAT_OBm_SIZE
typedef BCM89500_A0_CFP_STAT_OBm_t CFP_STAT_OBm_t;
#define CFP_STAT_OBm_CLR BCM89500_A0_CFP_STAT_OBm_CLR
#define CFP_STAT_OBm_SET BCM89500_A0_CFP_STAT_OBm_SET
#define CFP_STAT_OBm_GET BCM89500_A0_CFP_STAT_OBm_GET
#define CFP_STAT_OBm_OUT_BAND_CNTf_GET BCM89500_A0_CFP_STAT_OBm_OUT_BAND_CNTf_GET
#define CFP_STAT_OBm_OUT_BAND_CNTf_SET BCM89500_A0_CFP_STAT_OBm_OUT_BAND_CNTf_SET
#define READ_CFP_STAT_OBm BCM89500_A0_READ_CFP_STAT_OBm
#define WRITE_CFP_STAT_OBm BCM89500_A0_WRITE_CFP_STAT_OBm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_STAT_OBm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_CHAIN_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Reserved
 *     UDF_N_D0         Field Mask
 *     UDF_N_D1         Field Mask
 *     UDF_N_D2         Field Mask
 *     UDF_N_D3         Field Mask
 *     UDF_N_D4         Field Mask
 *     UDF_N_D5         Field Mask
 *     UDF_N_D6         Field Mask
 *     UDF_N_D7         Field Mask
 *     UDF_N_D8         Field Mask
 *     UDF_N_D9         Field Mask
 *     UDF_N_D10        Field Mask
 *     UDF_N_D11        Field Mask
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     UDF9_VLD         Field Mask
 *     UDF10_VLD        Field Mask
 *     UDF11_VLD        Field Mask
 *     RESERVED_1R      Reserved
 *     CHAIN_ID         Field Mask
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm 0x00004e00

#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_MIN 0
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_MAX 127
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_CHAIN_MASK.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_CHAIN_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_chain_mask[8];
	uint32_t _cfp_tcam_chain_mask;
} BCM89500_A0_CFP_TCAM_CHAIN_MASKm_t;

#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_chain_mask), 0, sizeof(BCM89500_A0_CFP_TCAM_CHAIN_MASKm_t))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SET(r,i,d) (r).cfp_tcam_chain_mask[i] = d
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_GET(r,i) (r).cfp_tcam_chain_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_chain_mask[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_chain_mask[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_chain_mask[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_GET(r) ((((r).cfp_tcam_chain_mask[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,24,39)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,24,39,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_GET(r) ((((r).cfp_tcam_chain_mask[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_SET(r,f) (r).cfp_tcam_chain_mask[1]=(((r).cfp_tcam_chain_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,56,71)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,56,71,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_GET(r) ((((r).cfp_tcam_chain_mask[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_SET(r,f) (r).cfp_tcam_chain_mask[2]=(((r).cfp_tcam_chain_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,88,103)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,88,103,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_GET(r) ((((r).cfp_tcam_chain_mask[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_SET(r,f) (r).cfp_tcam_chain_mask[3]=(((r).cfp_tcam_chain_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,120,135)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,120,135,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_GET(r) ((((r).cfp_tcam_chain_mask[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_SET(r,f) (r).cfp_tcam_chain_mask[4]=(((r).cfp_tcam_chain_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,152,167)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,152,167,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_GET(r) ((((r).cfp_tcam_chain_mask[5]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_SET(r,f) (r).cfp_tcam_chain_mask[5]=(((r).cfp_tcam_chain_mask[5] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,184,199)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,184,199,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 8) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 9) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 10) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 11) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 12) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 13) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 14) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 15) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 16) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 17) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 18) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 19) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 20) & 0xf)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 24) & 0xff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_GET(r) (((r).cfp_tcam_chain_mask[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_SET(r,f) (r).cfp_tcam_chain_mask[7]=(((r).cfp_tcam_chain_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_CHAIN_MASK.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_CHAIN_MASKm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_CHAIN_MASKm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_CHAIN_MASKm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_CHAIN_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_CHAIN_MASKm BCM89500_A0_CFP_TCAM_CHAIN_MASKm
#define CFP_TCAM_CHAIN_MASKm_MIN BCM89500_A0_CFP_TCAM_CHAIN_MASKm_MIN
#define CFP_TCAM_CHAIN_MASKm_MAX BCM89500_A0_CFP_TCAM_CHAIN_MASKm_MAX
#define CFP_TCAM_CHAIN_MASKm_CMAX(u) BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CMAX(u)
#define CFP_TCAM_CHAIN_MASKm_SIZE BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SIZE
typedef BCM89500_A0_CFP_TCAM_CHAIN_MASKm_t CFP_TCAM_CHAIN_MASKm_t;
#define CFP_TCAM_CHAIN_MASKm_CLR BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CLR
#define CFP_TCAM_CHAIN_MASKm_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SET
#define CFP_TCAM_CHAIN_MASKm_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_GET
#define CFP_TCAM_CHAIN_MASKm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_GET
#define CFP_TCAM_CHAIN_MASKm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_SET
#define CFP_TCAM_CHAIN_MASKm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_GET
#define CFP_TCAM_CHAIN_MASKm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET
#define CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_SET
#define READ_CFP_TCAM_CHAIN_MASKm BCM89500_A0_READ_CFP_TCAM_CHAIN_MASKm
#define WRITE_CFP_TCAM_CHAIN_MASKm BCM89500_A0_WRITE_CFP_TCAM_CHAIN_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_CHAIN_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_CHAIN_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_D0         User define field 0
 *     UDF_N_D1         User define field 1
 *     UDF_N_D2         User define field 2
 *     UDF_N_D3         User define field 3
 *     UDF_N_D4         User define field 4
 *     UDF_N_D5         User define field 5
 *     UDF_N_D6         User define field 6
 *     UDF_N_D7         User define field 7
 *     UDF_N_D8         User define field 8
 *     UDF_N_D9         User define field 9
 *     UDF_N_D10        User define field 10
 *     UDF_N_D11        User define field 11
 *     UDF0_VLD         Valid indication for UDF_n_D0
 *     UDF1_VLD         Valid indication for UDF_n_D1
 *     UDF2_VLD         Valid indication for UDF_n_D2
 *     UDF3_VLD         Valid indication for UDF_n_D3
 *     UDF4_VLD         Valid indication for UDF_n_D4
 *     UDF5_VLD         Valid indication for UDF_n_D5
 *     UDF6_VLD         Valid indication for UDF_n_D6
 *     UDF7_VLD         Valid indication for UDF_n_D7
 *     UDF8_VLD         Valid indication for UDF_n_D8
 *     UDF9_VLD         Valid indication for UDF_n_D9
 *     UDF10_VLD        Valid indication for UDF_n_D10
 *     UDF11_VLD        Valid indication for UDF_n_D11
 *     RESERVED_1R      Reserved
 *     CHAIN_ID         The abstract ID found from Slice 0 chained rule searching
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm 0x00004600

#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_MIN 0
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_MAX 127
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_CHAIN_SC.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_CHAIN_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_chain_sc[8];
	uint32_t _cfp_tcam_chain_sc;
} BCM89500_A0_CFP_TCAM_CHAIN_SCm_t;

#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_chain_sc), 0, sizeof(BCM89500_A0_CFP_TCAM_CHAIN_SCm_t))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_SET(r,i,d) (r).cfp_tcam_chain_sc[i] = d
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_GET(r,i) (r).cfp_tcam_chain_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_chain_sc[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_chain_sc[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_chain_sc[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_GET(r) ((((r).cfp_tcam_chain_sc[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,24,39)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,24,39,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_GET(r) ((((r).cfp_tcam_chain_sc[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_SET(r,f) (r).cfp_tcam_chain_sc[1]=(((r).cfp_tcam_chain_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,56,71)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,56,71,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_GET(r) ((((r).cfp_tcam_chain_sc[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_SET(r,f) (r).cfp_tcam_chain_sc[2]=(((r).cfp_tcam_chain_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,88,103)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,88,103,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_GET(r) ((((r).cfp_tcam_chain_sc[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_SET(r,f) (r).cfp_tcam_chain_sc[3]=(((r).cfp_tcam_chain_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,120,135)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,120,135,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_GET(r) ((((r).cfp_tcam_chain_sc[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_SET(r,f) (r).cfp_tcam_chain_sc[4]=(((r).cfp_tcam_chain_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,152,167)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,152,167,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_GET(r) ((((r).cfp_tcam_chain_sc[5]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_SET(r,f) (r).cfp_tcam_chain_sc[5]=(((r).cfp_tcam_chain_sc[5] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,184,199)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,184,199,f)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 8) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 9) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 10) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 11) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 12) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 13) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 14) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 15) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 16) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 17) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 18) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 19) & 0x1)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 20) & 0xf)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 24) & 0xff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_GET(r) (((r).cfp_tcam_chain_sc[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_SET(r,f) (r).cfp_tcam_chain_sc[7]=(((r).cfp_tcam_chain_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_CHAIN_SC.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_CHAIN_SCm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_CHAIN_SCm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_CHAIN_SCm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_CHAIN_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_CHAIN_SCm BCM89500_A0_CFP_TCAM_CHAIN_SCm
#define CFP_TCAM_CHAIN_SCm_MIN BCM89500_A0_CFP_TCAM_CHAIN_SCm_MIN
#define CFP_TCAM_CHAIN_SCm_MAX BCM89500_A0_CFP_TCAM_CHAIN_SCm_MAX
#define CFP_TCAM_CHAIN_SCm_CMAX(u) BCM89500_A0_CFP_TCAM_CHAIN_SCm_CMAX(u)
#define CFP_TCAM_CHAIN_SCm_SIZE BCM89500_A0_CFP_TCAM_CHAIN_SCm_SIZE
typedef BCM89500_A0_CFP_TCAM_CHAIN_SCm_t CFP_TCAM_CHAIN_SCm_t;
#define CFP_TCAM_CHAIN_SCm_CLR BCM89500_A0_CFP_TCAM_CHAIN_SCm_CLR
#define CFP_TCAM_CHAIN_SCm_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_SET
#define CFP_TCAM_CHAIN_SCm_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_GET
#define CFP_TCAM_CHAIN_SCm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_GET
#define CFP_TCAM_CHAIN_SCm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_SET
#define CFP_TCAM_CHAIN_SCm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_GET
#define CFP_TCAM_CHAIN_SCm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D0f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D0f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D1f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D1f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D2f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D2f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D3f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D3f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D4f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D4f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D5f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D5f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D6f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D6f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D7f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D7f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D8f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D8f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D9f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D9f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D10f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D10f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D11f_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D11f_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_SET
#define CFP_TCAM_CHAIN_SCm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF9_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF9_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF10_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF10_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF11_VLDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF11_VLDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET
#define CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_GET BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_SET BCM89500_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_SET
#define READ_CFP_TCAM_CHAIN_SCm BCM89500_A0_READ_CFP_TCAM_CHAIN_SCm
#define WRITE_CFP_TCAM_CHAIN_SCm BCM89500_A0_WRITE_CFP_TCAM_CHAIN_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_CHAIN_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_IPV4_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Field Mask
 *     UDF_N_A0         Field Mask
 *     UDF_N_A1         Field Mask
 *     UDF_N_A2         Field Mask
 *     UDF_N_A3         Field Mask
 *     UDF_N_A4         Field Mask
 *     UDF_N_A5         Field Mask
 *     UDF_N_A6         Field Mask
 *     UDF_N_A7         Field Mask
 *     UDF_N_A8         Field Mask
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     RESERVED_1R      Field Mask
 *     TTL_RANGE        Field Mask
 *     IP_AUTH          Field Mask
 *     NON_FIRST_FRAG   Field Mask
 *     IP_FRAG          Field Mask
 *     IP_PROTO         Field Mask
 *     IP_TOS           Field Mask
 *     L3_FRAMING       Field Mask
 *     L2_FRAMING       Field Mask
 *     C_TAGGED         Field Mask
 *     S_TAGGED         Field Mask
 *     SRC_PMAP         Field Mask
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm 0x00004800

#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_MIN 0
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_MAX 127
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV4_MASK.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_IPV4_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv4_mask[8];
	uint32_t _cfp_tcam_ipv4_mask;
} BCM89500_A0_CFP_TCAM_IPV4_MASKm_t;

#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv4_mask), 0, sizeof(BCM89500_A0_CFP_TCAM_IPV4_MASKm_t))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SET(r,i,d) (r).cfp_tcam_ipv4_mask[i] = d
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_GET(r,i) (r).cfp_tcam_ipv4_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv4_mask[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv4_mask[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv4_mask[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_GET(r) ((((r).cfp_tcam_ipv4_mask[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,24,39)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,24,39,f)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_GET(r) ((((r).cfp_tcam_ipv4_mask[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_SET(r,f) (r).cfp_tcam_ipv4_mask[1]=(((r).cfp_tcam_ipv4_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,56,71)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,56,71,f)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_GET(r) ((((r).cfp_tcam_ipv4_mask[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_SET(r,f) (r).cfp_tcam_ipv4_mask[2]=(((r).cfp_tcam_ipv4_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,88,103)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,88,103,f)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_GET(r) ((((r).cfp_tcam_ipv4_mask[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_SET(r,f) (r).cfp_tcam_ipv4_mask[3]=(((r).cfp_tcam_ipv4_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,120,135)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,120,135,f)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_GET(r) ((((r).cfp_tcam_ipv4_mask[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_SET(r,f) (r).cfp_tcam_ipv4_mask[4]=(((r).cfp_tcam_ipv4_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,152,163)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,152,163,f)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 4) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 5) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 8) & 0xfff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 20) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 21) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 24) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 25) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 26) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 27) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 28) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 29) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 30) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 31) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv4_mask[6]) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 1) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 3) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 5) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 6) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 7) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 8) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 16) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 24) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 26) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 28) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 30) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv4_mask[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv4_mask[7]=(((r).cfp_tcam_ipv4_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV4_MASK.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_IPV4_MASKm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_IPV4_MASKm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_IPV4_MASKm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_IPV4_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV4_MASKm BCM89500_A0_CFP_TCAM_IPV4_MASKm
#define CFP_TCAM_IPV4_MASKm_MIN BCM89500_A0_CFP_TCAM_IPV4_MASKm_MIN
#define CFP_TCAM_IPV4_MASKm_MAX BCM89500_A0_CFP_TCAM_IPV4_MASKm_MAX
#define CFP_TCAM_IPV4_MASKm_CMAX(u) BCM89500_A0_CFP_TCAM_IPV4_MASKm_CMAX(u)
#define CFP_TCAM_IPV4_MASKm_SIZE BCM89500_A0_CFP_TCAM_IPV4_MASKm_SIZE
typedef BCM89500_A0_CFP_TCAM_IPV4_MASKm_t CFP_TCAM_IPV4_MASKm_t;
#define CFP_TCAM_IPV4_MASKm_CLR BCM89500_A0_CFP_TCAM_IPV4_MASKm_CLR
#define CFP_TCAM_IPV4_MASKm_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SET
#define CFP_TCAM_IPV4_MASKm_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_GET
#define CFP_TCAM_IPV4_MASKm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_GET
#define CFP_TCAM_IPV4_MASKm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_SET
#define CFP_TCAM_IPV4_MASKm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_GET
#define CFP_TCAM_IPV4_MASKm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_SET
#define CFP_TCAM_IPV4_MASKm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_IPV4_MASKm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A0f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A0f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A1f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A1f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A2f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A2f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A3f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A3f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A4f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A4f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A5f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A5f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A6f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A6f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A7f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A7f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A8f_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A8f_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_SET
#define CFP_TCAM_IPV4_MASKm_USR_VIDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_GET
#define CFP_TCAM_IPV4_MASKm_USR_VIDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_SET
#define CFP_TCAM_IPV4_MASKm_USR_CFIf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_GET
#define CFP_TCAM_IPV4_MASKm_USR_CFIf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_SET
#define CFP_TCAM_IPV4_MASKm_USR_PRIf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_GET
#define CFP_TCAM_IPV4_MASKm_USR_PRIf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_SET
#define CFP_TCAM_IPV4_MASKm_SP_VIDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_GET
#define CFP_TCAM_IPV4_MASKm_SP_VIDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_SET
#define CFP_TCAM_IPV4_MASKm_SP_CFIf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_GET
#define CFP_TCAM_IPV4_MASKm_SP_CFIf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_SET
#define CFP_TCAM_IPV4_MASKm_SP_PRIf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_GET
#define CFP_TCAM_IPV4_MASKm_SP_PRIf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_SET
#define CFP_TCAM_IPV4_MASKm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV4_MASKm_TTL_RANGEf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_GET
#define CFP_TCAM_IPV4_MASKm_TTL_RANGEf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_SET
#define CFP_TCAM_IPV4_MASKm_IP_AUTHf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_GET
#define CFP_TCAM_IPV4_MASKm_IP_AUTHf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_SET
#define CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV4_MASKm_IP_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_GET
#define CFP_TCAM_IPV4_MASKm_IP_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_SET
#define CFP_TCAM_IPV4_MASKm_IP_PROTOf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_GET
#define CFP_TCAM_IPV4_MASKm_IP_PROTOf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_SET
#define CFP_TCAM_IPV4_MASKm_IP_TOSf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_GET
#define CFP_TCAM_IPV4_MASKm_IP_TOSf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_SET
#define CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV4_MASKm_C_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_IPV4_MASKm_C_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_IPV4_MASKm_S_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_IPV4_MASKm_S_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_IPV4_MASKm_SRC_PMAPf_GET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_GET
#define CFP_TCAM_IPV4_MASKm_SRC_PMAPf_SET BCM89500_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV4_MASKm BCM89500_A0_READ_CFP_TCAM_IPV4_MASKm
#define WRITE_CFP_TCAM_IPV4_MASKm BCM89500_A0_WRITE_CFP_TCAM_IPV4_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_IPV4_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_IPV4_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_A0         User define field 0
 *     UDF_N_A1         User define field 1
 *     UDF_N_A2         User define field 2
 *     UDF_N_A3         User define field 3
 *     UDF_N_A4         User define field 4
 *     UDF_N_A5         User define field 5
 *     UDF_N_A6         User define field 6
 *     UDF_N_A7         User define field 7
 *     UDF_N_A8         User define field 8
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Valid indication for UDF_n_A0
 *     UDF1_VLD         Valid indication for UDF_n_A1
 *     UDF2_VLD         Valid indication for UDF_n_A2
 *     UDF3_VLD         Valid indication for UDF_n_A3
 *     UDF4_VLD         Valid indication for UDF_n_A4
 *     UDF5_VLD         Valid indication for UDF_n_A5
 *     UDF6_VLD         Valid indication for UDF_n_A6
 *     UDF7_VLD         Valid indication for UDF_n_A7
 *     UDF8_VLD         Valid indication for UDF_n_A8
 *     RESERVED_1R      Reserved
 *     TTL_RANGE        b00: TTL=0b01: TTL=1b10: TTL=Othersb11: TTL=255
 *     IP_AUTH          0: Not Authenticated1: Authenticated
 *     NON_FIRST_FRAG   0: Not Fragmented or First Fragment1: NonFirst Fragment
 *     IP_FRAG          0: Not Fragmented1: Fragmented
 *     IP_PROTO         The Protocol field of IPv4 header
 *     IP_TOS           Type Of Service field in IPv4 header
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PMAP         Ingress port indication
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_IPV4_SCm 0x00004000

#define BCM89500_A0_CFP_TCAM_IPV4_SCm_MIN 0
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_MAX 127
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV4_SC.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_IPV4_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv4_sc[8];
	uint32_t _cfp_tcam_ipv4_sc;
} BCM89500_A0_CFP_TCAM_IPV4_SCm_t;

#define BCM89500_A0_CFP_TCAM_IPV4_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv4_sc), 0, sizeof(BCM89500_A0_CFP_TCAM_IPV4_SCm_t))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SET(r,i,d) (r).cfp_tcam_ipv4_sc[i] = d
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_GET(r,i) (r).cfp_tcam_ipv4_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv4_sc[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv4_sc[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv4_sc[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_GET(r) ((((r).cfp_tcam_ipv4_sc[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,24,39)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,24,39,f)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_GET(r) ((((r).cfp_tcam_ipv4_sc[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_SET(r,f) (r).cfp_tcam_ipv4_sc[1]=(((r).cfp_tcam_ipv4_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,56,71)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,56,71,f)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_GET(r) ((((r).cfp_tcam_ipv4_sc[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_SET(r,f) (r).cfp_tcam_ipv4_sc[2]=(((r).cfp_tcam_ipv4_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,88,103)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,88,103,f)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_GET(r) ((((r).cfp_tcam_ipv4_sc[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_SET(r,f) (r).cfp_tcam_ipv4_sc[3]=(((r).cfp_tcam_ipv4_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,120,135)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,120,135,f)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_GET(r) ((((r).cfp_tcam_ipv4_sc[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_SET(r,f) (r).cfp_tcam_ipv4_sc[4]=(((r).cfp_tcam_ipv4_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,152,163)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,152,163,f)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 4) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 5) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 8) & 0xfff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 20) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 21) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 24) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 25) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 26) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 27) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 28) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 29) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 30) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 31) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv4_sc[6]) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 1) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 3) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 5) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 6) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 7) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 8) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 16) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 24) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 26) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 28) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 30) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv4_sc[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv4_sc[7]=(((r).cfp_tcam_ipv4_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV4_SC.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_IPV4_SCm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_IPV4_SCm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_IPV4_SCm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_IPV4_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV4_SCm BCM89500_A0_CFP_TCAM_IPV4_SCm
#define CFP_TCAM_IPV4_SCm_MIN BCM89500_A0_CFP_TCAM_IPV4_SCm_MIN
#define CFP_TCAM_IPV4_SCm_MAX BCM89500_A0_CFP_TCAM_IPV4_SCm_MAX
#define CFP_TCAM_IPV4_SCm_CMAX(u) BCM89500_A0_CFP_TCAM_IPV4_SCm_CMAX(u)
#define CFP_TCAM_IPV4_SCm_SIZE BCM89500_A0_CFP_TCAM_IPV4_SCm_SIZE
typedef BCM89500_A0_CFP_TCAM_IPV4_SCm_t CFP_TCAM_IPV4_SCm_t;
#define CFP_TCAM_IPV4_SCm_CLR BCM89500_A0_CFP_TCAM_IPV4_SCm_CLR
#define CFP_TCAM_IPV4_SCm_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_SET
#define CFP_TCAM_IPV4_SCm_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_GET
#define CFP_TCAM_IPV4_SCm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_GET
#define CFP_TCAM_IPV4_SCm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_SET
#define CFP_TCAM_IPV4_SCm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_GET
#define CFP_TCAM_IPV4_SCm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_SET
#define CFP_TCAM_IPV4_SCm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_GET
#define CFP_TCAM_IPV4_SCm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A0f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A0f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A1f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A1f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A2f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A2f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A3f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A3f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A4f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A4f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A5f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A5f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A6f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A6f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A7f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A7f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A8f_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A8f_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_SET
#define CFP_TCAM_IPV4_SCm_USR_VIDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_GET
#define CFP_TCAM_IPV4_SCm_USR_VIDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_SET
#define CFP_TCAM_IPV4_SCm_USR_CFIf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_GET
#define CFP_TCAM_IPV4_SCm_USR_CFIf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_SET
#define CFP_TCAM_IPV4_SCm_USR_PRIf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_GET
#define CFP_TCAM_IPV4_SCm_USR_PRIf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_SET
#define CFP_TCAM_IPV4_SCm_SP_VIDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_GET
#define CFP_TCAM_IPV4_SCm_SP_VIDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_SET
#define CFP_TCAM_IPV4_SCm_SP_CFIf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_GET
#define CFP_TCAM_IPV4_SCm_SP_CFIf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_SET
#define CFP_TCAM_IPV4_SCm_SP_PRIf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_GET
#define CFP_TCAM_IPV4_SCm_SP_PRIf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_SET
#define CFP_TCAM_IPV4_SCm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_SET
#define CFP_TCAM_IPV4_SCm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV4_SCm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV4_SCm_TTL_RANGEf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_GET
#define CFP_TCAM_IPV4_SCm_TTL_RANGEf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_SET
#define CFP_TCAM_IPV4_SCm_IP_AUTHf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_GET
#define CFP_TCAM_IPV4_SCm_IP_AUTHf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_SET
#define CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV4_SCm_IP_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_GET
#define CFP_TCAM_IPV4_SCm_IP_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_SET
#define CFP_TCAM_IPV4_SCm_IP_PROTOf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_GET
#define CFP_TCAM_IPV4_SCm_IP_PROTOf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_SET
#define CFP_TCAM_IPV4_SCm_IP_TOSf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_GET
#define CFP_TCAM_IPV4_SCm_IP_TOSf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_SET
#define CFP_TCAM_IPV4_SCm_L3_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV4_SCm_L3_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV4_SCm_L2_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV4_SCm_L2_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV4_SCm_C_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_GET
#define CFP_TCAM_IPV4_SCm_C_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_SET
#define CFP_TCAM_IPV4_SCm_S_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_GET
#define CFP_TCAM_IPV4_SCm_S_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_SET
#define CFP_TCAM_IPV4_SCm_SRC_PMAPf_GET BCM89500_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_GET
#define CFP_TCAM_IPV4_SCm_SRC_PMAPf_SET BCM89500_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV4_SCm BCM89500_A0_READ_CFP_TCAM_IPV4_SCm
#define WRITE_CFP_TCAM_IPV4_SCm BCM89500_A0_WRITE_CFP_TCAM_IPV4_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_IPV4_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_IPV6_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Field Mask
 *     UDF_N_B0         Field Mask
 *     UDF_N_B1         Field Mask
 *     UDF_N_B2         Field Mask
 *     UDF_N_B3         Field Mask
 *     UDF_N_B4         Field Mask
 *     UDF_N_B5         Field Mask
 *     UDF_N_B6         Field Mask
 *     UDF_N_B7         Field Mask
 *     UDF_N_B8         Field Mask
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     RESERVED_1R      Reserved
 *     TTL_RANGE        Field Mask
 *     IP_AUTH          Field Mask
 *     NON_FIRST_FRAG   Field Mask
 *     IP_FRAG          Field Mask
 *     IP_PROTO         Field Mask
 *     IP_TOS           Field Mask
 *     L3_FRAMING       Field Mask
 *     L2_FRAMING       Field Mask
 *     C_TAGGED         Field Mask
 *     S_TAGGED         Field Mask
 *     SRC_PMAP         Field Mask
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm 0x00004a00

#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_MIN 0
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_MAX 127
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV6_MASK.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_IPV6_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv6_mask[8];
	uint32_t _cfp_tcam_ipv6_mask;
} BCM89500_A0_CFP_TCAM_IPV6_MASKm_t;

#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv6_mask), 0, sizeof(BCM89500_A0_CFP_TCAM_IPV6_MASKm_t))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SET(r,i,d) (r).cfp_tcam_ipv6_mask[i] = d
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_GET(r,i) (r).cfp_tcam_ipv6_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv6_mask[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv6_mask[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv6_mask[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_GET(r) ((((r).cfp_tcam_ipv6_mask[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,24,39)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,24,39,f)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_GET(r) ((((r).cfp_tcam_ipv6_mask[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_SET(r,f) (r).cfp_tcam_ipv6_mask[1]=(((r).cfp_tcam_ipv6_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,56,71)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,56,71,f)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_GET(r) ((((r).cfp_tcam_ipv6_mask[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_SET(r,f) (r).cfp_tcam_ipv6_mask[2]=(((r).cfp_tcam_ipv6_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,88,103)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,88,103,f)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_GET(r) ((((r).cfp_tcam_ipv6_mask[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_SET(r,f) (r).cfp_tcam_ipv6_mask[3]=(((r).cfp_tcam_ipv6_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,120,135)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,120,135,f)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_GET(r) ((((r).cfp_tcam_ipv6_mask[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_SET(r,f) (r).cfp_tcam_ipv6_mask[4]=(((r).cfp_tcam_ipv6_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,152,163)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,152,163,f)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 4) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 5) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 8) & 0xfff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 20) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 21) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 24) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 25) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 26) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 27) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 28) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 29) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 30) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 31) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv6_mask[6]) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 1) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 3) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 5) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 6) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 7) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 8) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 16) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 24) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 26) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 28) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 30) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv6_mask[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv6_mask[7]=(((r).cfp_tcam_ipv6_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV6_MASK.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_IPV6_MASKm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_IPV6_MASKm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_IPV6_MASKm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_IPV6_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV6_MASKm BCM89500_A0_CFP_TCAM_IPV6_MASKm
#define CFP_TCAM_IPV6_MASKm_MIN BCM89500_A0_CFP_TCAM_IPV6_MASKm_MIN
#define CFP_TCAM_IPV6_MASKm_MAX BCM89500_A0_CFP_TCAM_IPV6_MASKm_MAX
#define CFP_TCAM_IPV6_MASKm_CMAX(u) BCM89500_A0_CFP_TCAM_IPV6_MASKm_CMAX(u)
#define CFP_TCAM_IPV6_MASKm_SIZE BCM89500_A0_CFP_TCAM_IPV6_MASKm_SIZE
typedef BCM89500_A0_CFP_TCAM_IPV6_MASKm_t CFP_TCAM_IPV6_MASKm_t;
#define CFP_TCAM_IPV6_MASKm_CLR BCM89500_A0_CFP_TCAM_IPV6_MASKm_CLR
#define CFP_TCAM_IPV6_MASKm_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SET
#define CFP_TCAM_IPV6_MASKm_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_GET
#define CFP_TCAM_IPV6_MASKm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_GET
#define CFP_TCAM_IPV6_MASKm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_SET
#define CFP_TCAM_IPV6_MASKm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_GET
#define CFP_TCAM_IPV6_MASKm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_SET
#define CFP_TCAM_IPV6_MASKm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_IPV6_MASKm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B0f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B0f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B1f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B1f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B2f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B2f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B3f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B3f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B4f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B4f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B5f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B5f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B6f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B6f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B7f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B7f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B8f_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B8f_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_SET
#define CFP_TCAM_IPV6_MASKm_USR_VIDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_GET
#define CFP_TCAM_IPV6_MASKm_USR_VIDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_SET
#define CFP_TCAM_IPV6_MASKm_USR_CFIf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_GET
#define CFP_TCAM_IPV6_MASKm_USR_CFIf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_SET
#define CFP_TCAM_IPV6_MASKm_USR_PRIf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_GET
#define CFP_TCAM_IPV6_MASKm_USR_PRIf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_SET
#define CFP_TCAM_IPV6_MASKm_SP_VIDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_GET
#define CFP_TCAM_IPV6_MASKm_SP_VIDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_SET
#define CFP_TCAM_IPV6_MASKm_SP_CFIf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_GET
#define CFP_TCAM_IPV6_MASKm_SP_CFIf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_SET
#define CFP_TCAM_IPV6_MASKm_SP_PRIf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_GET
#define CFP_TCAM_IPV6_MASKm_SP_PRIf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_SET
#define CFP_TCAM_IPV6_MASKm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV6_MASKm_TTL_RANGEf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_GET
#define CFP_TCAM_IPV6_MASKm_TTL_RANGEf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_SET
#define CFP_TCAM_IPV6_MASKm_IP_AUTHf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_GET
#define CFP_TCAM_IPV6_MASKm_IP_AUTHf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_SET
#define CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV6_MASKm_IP_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_GET
#define CFP_TCAM_IPV6_MASKm_IP_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_SET
#define CFP_TCAM_IPV6_MASKm_IP_PROTOf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_GET
#define CFP_TCAM_IPV6_MASKm_IP_PROTOf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_SET
#define CFP_TCAM_IPV6_MASKm_IP_TOSf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_GET
#define CFP_TCAM_IPV6_MASKm_IP_TOSf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_SET
#define CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV6_MASKm_C_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_IPV6_MASKm_C_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_IPV6_MASKm_S_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_IPV6_MASKm_S_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_IPV6_MASKm_SRC_PMAPf_GET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_GET
#define CFP_TCAM_IPV6_MASKm_SRC_PMAPf_SET BCM89500_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV6_MASKm BCM89500_A0_READ_CFP_TCAM_IPV6_MASKm
#define WRITE_CFP_TCAM_IPV6_MASKm BCM89500_A0_WRITE_CFP_TCAM_IPV6_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_IPV6_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_IPV6_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_B0         User define field 0
 *     UDF_N_B1         User define field 1
 *     UDF_N_B2         User define field 2
 *     UDF_N_B3         User define field 3
 *     UDF_N_B4         User define field 4
 *     UDF_N_B5         User define field 5
 *     UDF_N_B6         User define field 6
 *     UDF_N_B7         User define field 7
 *     UDF_N_B8         User define field 8
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Valid indication for UDF_n_B0
 *     UDF1_VLD         Valid indication for UDF_n_B1
 *     UDF2_VLD         Valid indication for UDF_n_B2
 *     UDF3_VLD         Valid indication for UDF_n_B3
 *     UDF4_VLD         Valid indication for UDF_n_B4
 *     UDF5_VLD         Valid indication for UDF_n_B5
 *     UDF6_VLD         Valid indication for UDF_n_B6
 *     UDF7_VLD         Valid indication for UDF_n_B7
 *     UDF8_VLD         Valid indication for UDF_n_B8
 *     RESERVED_1R      Reserved
 *     TTL_RANGE        HopLimit Range:b00: HopLimit=0b01: HopLimit TTL=1b10: HopLimit =Othersb11: HopLimit =255.
 *     IP_AUTH          0: Not Authenticated1: Authenticated
 *     NON_FIRST_FRAG   0: Not Fragmented or First Fragment1: NonFirst Fragment
 *     IP_FRAG          0: Not Fragmented1: Fragmented
 *     IP_PROTO         The Next Header  field of IPv6 header
 *     IP_TOS           TrafficClass field in IPv4 header
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PMAP         Ingress port indication
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_IPV6_SCm 0x00004200

#define BCM89500_A0_CFP_TCAM_IPV6_SCm_MIN 0
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_MAX 127
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV6_SC.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_IPV6_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv6_sc[8];
	uint32_t _cfp_tcam_ipv6_sc;
} BCM89500_A0_CFP_TCAM_IPV6_SCm_t;

#define BCM89500_A0_CFP_TCAM_IPV6_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv6_sc), 0, sizeof(BCM89500_A0_CFP_TCAM_IPV6_SCm_t))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SET(r,i,d) (r).cfp_tcam_ipv6_sc[i] = d
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_GET(r,i) (r).cfp_tcam_ipv6_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv6_sc[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv6_sc[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv6_sc[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_GET(r) ((((r).cfp_tcam_ipv6_sc[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,24,39)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,24,39,f)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_GET(r) ((((r).cfp_tcam_ipv6_sc[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_SET(r,f) (r).cfp_tcam_ipv6_sc[1]=(((r).cfp_tcam_ipv6_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,56,71)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,56,71,f)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_GET(r) ((((r).cfp_tcam_ipv6_sc[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_SET(r,f) (r).cfp_tcam_ipv6_sc[2]=(((r).cfp_tcam_ipv6_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,88,103)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,88,103,f)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_GET(r) ((((r).cfp_tcam_ipv6_sc[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_SET(r,f) (r).cfp_tcam_ipv6_sc[3]=(((r).cfp_tcam_ipv6_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,120,135)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,120,135,f)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_GET(r) ((((r).cfp_tcam_ipv6_sc[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_SET(r,f) (r).cfp_tcam_ipv6_sc[4]=(((r).cfp_tcam_ipv6_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,152,163)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,152,163,f)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 4) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 5) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 8) & 0xfff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 20) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 21) & 0x7)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 24) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 25) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 26) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 27) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 28) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 29) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 30) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 31) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv6_sc[6]) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 1) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 3) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 5) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 6) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 7) & 0x1)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 8) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 16) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 24) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 26) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 28) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 30) & 0x3)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv6_sc[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv6_sc[7]=(((r).cfp_tcam_ipv6_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV6_SC.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_IPV6_SCm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_IPV6_SCm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_IPV6_SCm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_IPV6_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV6_SCm BCM89500_A0_CFP_TCAM_IPV6_SCm
#define CFP_TCAM_IPV6_SCm_MIN BCM89500_A0_CFP_TCAM_IPV6_SCm_MIN
#define CFP_TCAM_IPV6_SCm_MAX BCM89500_A0_CFP_TCAM_IPV6_SCm_MAX
#define CFP_TCAM_IPV6_SCm_CMAX(u) BCM89500_A0_CFP_TCAM_IPV6_SCm_CMAX(u)
#define CFP_TCAM_IPV6_SCm_SIZE BCM89500_A0_CFP_TCAM_IPV6_SCm_SIZE
typedef BCM89500_A0_CFP_TCAM_IPV6_SCm_t CFP_TCAM_IPV6_SCm_t;
#define CFP_TCAM_IPV6_SCm_CLR BCM89500_A0_CFP_TCAM_IPV6_SCm_CLR
#define CFP_TCAM_IPV6_SCm_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_SET
#define CFP_TCAM_IPV6_SCm_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_GET
#define CFP_TCAM_IPV6_SCm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_GET
#define CFP_TCAM_IPV6_SCm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_SET
#define CFP_TCAM_IPV6_SCm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_GET
#define CFP_TCAM_IPV6_SCm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_SET
#define CFP_TCAM_IPV6_SCm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_GET
#define CFP_TCAM_IPV6_SCm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B0f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B0f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B1f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B1f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B2f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B2f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B3f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B3f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B4f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B4f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B5f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B5f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B6f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B6f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B7f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B7f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B8f_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B8f_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_SET
#define CFP_TCAM_IPV6_SCm_USR_VIDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_GET
#define CFP_TCAM_IPV6_SCm_USR_VIDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_SET
#define CFP_TCAM_IPV6_SCm_USR_CFIf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_GET
#define CFP_TCAM_IPV6_SCm_USR_CFIf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_SET
#define CFP_TCAM_IPV6_SCm_USR_PRIf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_GET
#define CFP_TCAM_IPV6_SCm_USR_PRIf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_SET
#define CFP_TCAM_IPV6_SCm_SP_VIDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_GET
#define CFP_TCAM_IPV6_SCm_SP_VIDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_SET
#define CFP_TCAM_IPV6_SCm_SP_CFIf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_GET
#define CFP_TCAM_IPV6_SCm_SP_CFIf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_SET
#define CFP_TCAM_IPV6_SCm_SP_PRIf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_GET
#define CFP_TCAM_IPV6_SCm_SP_PRIf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_SET
#define CFP_TCAM_IPV6_SCm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_SET
#define CFP_TCAM_IPV6_SCm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV6_SCm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV6_SCm_TTL_RANGEf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_GET
#define CFP_TCAM_IPV6_SCm_TTL_RANGEf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_SET
#define CFP_TCAM_IPV6_SCm_IP_AUTHf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_GET
#define CFP_TCAM_IPV6_SCm_IP_AUTHf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_SET
#define CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV6_SCm_IP_FRAGf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_GET
#define CFP_TCAM_IPV6_SCm_IP_FRAGf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_SET
#define CFP_TCAM_IPV6_SCm_IP_PROTOf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_GET
#define CFP_TCAM_IPV6_SCm_IP_PROTOf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_SET
#define CFP_TCAM_IPV6_SCm_IP_TOSf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_GET
#define CFP_TCAM_IPV6_SCm_IP_TOSf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_SET
#define CFP_TCAM_IPV6_SCm_L3_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV6_SCm_L3_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV6_SCm_L2_FRAMINGf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV6_SCm_L2_FRAMINGf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV6_SCm_C_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_GET
#define CFP_TCAM_IPV6_SCm_C_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_SET
#define CFP_TCAM_IPV6_SCm_S_TAGGEDf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_GET
#define CFP_TCAM_IPV6_SCm_S_TAGGEDf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_SET
#define CFP_TCAM_IPV6_SCm_SRC_PMAPf_GET BCM89500_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_GET
#define CFP_TCAM_IPV6_SCm_SRC_PMAPf_SET BCM89500_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV6_SCm BCM89500_A0_READ_CFP_TCAM_IPV6_SCm
#define WRITE_CFP_TCAM_IPV6_SCm BCM89500_A0_WRITE_CFP_TCAM_IPV6_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_IPV6_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_NONIP_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Reserved
 *     UDF_N_C0         Field Mask
 *     UDF_N_C1         Field Mask
 *     UDF_N_C2         Field Mask
 *     UDF_N_C3         Field Mask
 *     UDF_N_C4         Field Mask
 *     UDF_N_C5         Field Mask
 *     UDF_N_C6         Field Mask
 *     UDF_N_C7         Field Mask
 *     UDF_N_C8         Field Mask
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     RESERVED_1R      Reserved
 *     ETHERTYPE_SAP    Field Mask
 *     L3_FRAMING       Field Mask
 *     L2_FRAMING       Field Mask
 *     C_TAGGED         Field Mask
 *     S_TAGGED         Field Mask
 *     SRC_PMAP         Field Mask
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm 0x00004c00

#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_MIN 0
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_MAX 127
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_NONIP_MASK.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_NONIP_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_nonip_mask[8];
	uint32_t _cfp_tcam_nonip_mask;
} BCM89500_A0_CFP_TCAM_NONIP_MASKm_t;

#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_nonip_mask), 0, sizeof(BCM89500_A0_CFP_TCAM_NONIP_MASKm_t))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SET(r,i,d) (r).cfp_tcam_nonip_mask[i] = d
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_GET(r,i) (r).cfp_tcam_nonip_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_nonip_mask[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_nonip_mask[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_nonip_mask[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_GET(r) ((((r).cfp_tcam_nonip_mask[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,24,39)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,24,39,f)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_GET(r) ((((r).cfp_tcam_nonip_mask[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_SET(r,f) (r).cfp_tcam_nonip_mask[1]=(((r).cfp_tcam_nonip_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,56,71)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,56,71,f)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_GET(r) ((((r).cfp_tcam_nonip_mask[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_SET(r,f) (r).cfp_tcam_nonip_mask[2]=(((r).cfp_tcam_nonip_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,88,103)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,88,103,f)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_GET(r) ((((r).cfp_tcam_nonip_mask[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_SET(r,f) (r).cfp_tcam_nonip_mask[3]=(((r).cfp_tcam_nonip_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,120,135)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,120,135,f)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_GET(r) ((((r).cfp_tcam_nonip_mask[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_SET(r,f) (r).cfp_tcam_nonip_mask[4]=(((r).cfp_tcam_nonip_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,152,163)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,152,163,f)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 4) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 5) & 0x7)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 8) & 0xfff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 20) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 21) & 0x7)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 24) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 25) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 26) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 27) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 28) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 29) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 30) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 31) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_GET(r) (((r).cfp_tcam_nonip_mask[6]) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 1) & 0x7f)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 24) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 26) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 28) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 30) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_GET(r) (((r).cfp_tcam_nonip_mask[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_nonip_mask[7]=(((r).cfp_tcam_nonip_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_NONIP_MASK.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_NONIP_MASKm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_NONIP_MASKm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_NONIP_MASKm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_NONIP_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_NONIP_MASKm BCM89500_A0_CFP_TCAM_NONIP_MASKm
#define CFP_TCAM_NONIP_MASKm_MIN BCM89500_A0_CFP_TCAM_NONIP_MASKm_MIN
#define CFP_TCAM_NONIP_MASKm_MAX BCM89500_A0_CFP_TCAM_NONIP_MASKm_MAX
#define CFP_TCAM_NONIP_MASKm_CMAX(u) BCM89500_A0_CFP_TCAM_NONIP_MASKm_CMAX(u)
#define CFP_TCAM_NONIP_MASKm_SIZE BCM89500_A0_CFP_TCAM_NONIP_MASKm_SIZE
typedef BCM89500_A0_CFP_TCAM_NONIP_MASKm_t CFP_TCAM_NONIP_MASKm_t;
#define CFP_TCAM_NONIP_MASKm_CLR BCM89500_A0_CFP_TCAM_NONIP_MASKm_CLR
#define CFP_TCAM_NONIP_MASKm_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SET
#define CFP_TCAM_NONIP_MASKm_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_GET
#define CFP_TCAM_NONIP_MASKm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_GET
#define CFP_TCAM_NONIP_MASKm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_SET
#define CFP_TCAM_NONIP_MASKm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_GET
#define CFP_TCAM_NONIP_MASKm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_SET
#define CFP_TCAM_NONIP_MASKm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_NONIP_MASKm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C0f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C0f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C1f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C1f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C2f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C2f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C3f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C3f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C4f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C4f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C5f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C5f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C6f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C6f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C7f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C7f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C8f_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C8f_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_SET
#define CFP_TCAM_NONIP_MASKm_USR_VIDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_GET
#define CFP_TCAM_NONIP_MASKm_USR_VIDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_SET
#define CFP_TCAM_NONIP_MASKm_USR_CFIf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_GET
#define CFP_TCAM_NONIP_MASKm_USR_CFIf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_SET
#define CFP_TCAM_NONIP_MASKm_USR_PRIf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_GET
#define CFP_TCAM_NONIP_MASKm_USR_PRIf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_SET
#define CFP_TCAM_NONIP_MASKm_SP_VIDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_GET
#define CFP_TCAM_NONIP_MASKm_SP_VIDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_SET
#define CFP_TCAM_NONIP_MASKm_SP_CFIf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_GET
#define CFP_TCAM_NONIP_MASKm_SP_CFIf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_SET
#define CFP_TCAM_NONIP_MASKm_SP_PRIf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_GET
#define CFP_TCAM_NONIP_MASKm_SP_PRIf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_SET
#define CFP_TCAM_NONIP_MASKm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_GET
#define CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_SET
#define CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_NONIP_MASKm_C_TAGGEDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_NONIP_MASKm_C_TAGGEDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_NONIP_MASKm_S_TAGGEDf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_NONIP_MASKm_S_TAGGEDf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_NONIP_MASKm_SRC_PMAPf_GET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_GET
#define CFP_TCAM_NONIP_MASKm_SRC_PMAPf_SET BCM89500_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_SET
#define READ_CFP_TCAM_NONIP_MASKm BCM89500_A0_READ_CFP_TCAM_NONIP_MASKm
#define WRITE_CFP_TCAM_NONIP_MASKm BCM89500_A0_WRITE_CFP_TCAM_NONIP_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_NONIP_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  CFP_TCAM_NONIP_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_C0         User define field 0
 *     UDF_N_C1         User define field 1
 *     UDF_N_C2         User define field 2
 *     UDF_N_C3         User define field 3
 *     UDF_N_C4         User define field 4
 *     UDF_N_C5         User define field 5
 *     UDF_N_C6         User define field 6
 *     UDF_N_C7         User define field 7
 *     UDF_N_C8         User define field 8
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Valid indication for UDF_n_C0
 *     UDF1_VLD         Valid indication for UDF_n_C1
 *     UDF2_VLD         Valid indication for UDF_n_C2
 *     UDF3_VLD         Valid indication for UDF_n_C3
 *     UDF4_VLD         Valid indication for UDF_n_C4
 *     UDF5_VLD         Valid indication for UDF_n_C5
 *     UDF6_VLD         Valid indication for UDF_n_C6
 *     UDF7_VLD         Valid indication for UDF_n_C7
 *     UDF8_VLD         Valid indication for UDF_n_C8
 *     RESERVED_1R      Reserved
 *     ETHERTYPE_SAP    EtherType :when L2 Framing = DIXv2 or SNAP_PublicDSAP,SSAP : when L2 Framing = LLC or SNAP_Private.
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PMAP         Ingress port indication
 *
 ******************************************************************************/
#define BCM89500_A0_CFP_TCAM_NONIP_SCm 0x00004400

#define BCM89500_A0_CFP_TCAM_NONIP_SCm_MIN 0
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_MAX 127
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_CMAX(u) 127
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_NONIP_SC.
 *
 */
typedef union BCM89500_A0_CFP_TCAM_NONIP_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_nonip_sc[8];
	uint32_t _cfp_tcam_nonip_sc;
} BCM89500_A0_CFP_TCAM_NONIP_SCm_t;

#define BCM89500_A0_CFP_TCAM_NONIP_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_nonip_sc), 0, sizeof(BCM89500_A0_CFP_TCAM_NONIP_SCm_t))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SET(r,i,d) (r).cfp_tcam_nonip_sc[i] = d
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_GET(r,i) (r).cfp_tcam_nonip_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_nonip_sc[0]) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_nonip_sc[0]) >> 2) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_nonip_sc[0]) >> 4) & 0xf)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_GET(r) ((((r).cfp_tcam_nonip_sc[0]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,24,39)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,24,39,f)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_GET(r) ((((r).cfp_tcam_nonip_sc[1]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_SET(r,f) (r).cfp_tcam_nonip_sc[1]=(((r).cfp_tcam_nonip_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,56,71)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,56,71,f)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_GET(r) ((((r).cfp_tcam_nonip_sc[2]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_SET(r,f) (r).cfp_tcam_nonip_sc[2]=(((r).cfp_tcam_nonip_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,88,103)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,88,103,f)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_GET(r) ((((r).cfp_tcam_nonip_sc[3]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_SET(r,f) (r).cfp_tcam_nonip_sc[3]=(((r).cfp_tcam_nonip_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,120,135)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,120,135,f)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_GET(r) ((((r).cfp_tcam_nonip_sc[4]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_SET(r,f) (r).cfp_tcam_nonip_sc[4]=(((r).cfp_tcam_nonip_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,152,163)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,152,163,f)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 4) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 5) & 0x7)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 8) & 0xfff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 20) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 21) & 0x7)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 24) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 25) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 26) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 27) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 28) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 29) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 30) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 31) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_GET(r) (((r).cfp_tcam_nonip_sc[6]) & 0x1)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 1) & 0x7f)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 8) & 0xffff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 24) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 26) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 28) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 30) & 0x3)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_GET(r) (((r).cfp_tcam_nonip_sc[7]) & 0xff)
#define BCM89500_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_nonip_sc[7]=(((r).cfp_tcam_nonip_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_NONIP_SC.
 *
 */
#define BCM89500_A0_READ_CFP_TCAM_NONIP_SCm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_CFP_TCAM_NONIP_SCm,i,(m),29)
#define BCM89500_A0_WRITE_CFP_TCAM_NONIP_SCm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_CFP_TCAM_NONIP_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_NONIP_SCm BCM89500_A0_CFP_TCAM_NONIP_SCm
#define CFP_TCAM_NONIP_SCm_MIN BCM89500_A0_CFP_TCAM_NONIP_SCm_MIN
#define CFP_TCAM_NONIP_SCm_MAX BCM89500_A0_CFP_TCAM_NONIP_SCm_MAX
#define CFP_TCAM_NONIP_SCm_CMAX(u) BCM89500_A0_CFP_TCAM_NONIP_SCm_CMAX(u)
#define CFP_TCAM_NONIP_SCm_SIZE BCM89500_A0_CFP_TCAM_NONIP_SCm_SIZE
typedef BCM89500_A0_CFP_TCAM_NONIP_SCm_t CFP_TCAM_NONIP_SCm_t;
#define CFP_TCAM_NONIP_SCm_CLR BCM89500_A0_CFP_TCAM_NONIP_SCm_CLR
#define CFP_TCAM_NONIP_SCm_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_SET
#define CFP_TCAM_NONIP_SCm_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_GET
#define CFP_TCAM_NONIP_SCm_VALID_Rf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_GET
#define CFP_TCAM_NONIP_SCm_VALID_Rf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_SET
#define CFP_TCAM_NONIP_SCm_SC_N_IDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_GET
#define CFP_TCAM_NONIP_SCm_SC_N_IDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_SET
#define CFP_TCAM_NONIP_SCm_RESERVED_Rf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_GET
#define CFP_TCAM_NONIP_SCm_RESERVED_Rf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C0f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C0f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C1f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C1f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C2f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C2f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C3f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C3f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C4f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C4f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C5f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C5f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C6f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C6f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C7f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C7f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C8f_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C8f_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_SET
#define CFP_TCAM_NONIP_SCm_USR_VIDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_GET
#define CFP_TCAM_NONIP_SCm_USR_VIDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_SET
#define CFP_TCAM_NONIP_SCm_USR_CFIf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_GET
#define CFP_TCAM_NONIP_SCm_USR_CFIf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_SET
#define CFP_TCAM_NONIP_SCm_USR_PRIf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_GET
#define CFP_TCAM_NONIP_SCm_USR_PRIf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_SET
#define CFP_TCAM_NONIP_SCm_SP_VIDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_GET
#define CFP_TCAM_NONIP_SCm_SP_VIDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_SET
#define CFP_TCAM_NONIP_SCm_SP_CFIf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_GET
#define CFP_TCAM_NONIP_SCm_SP_CFIf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_SET
#define CFP_TCAM_NONIP_SCm_SP_PRIf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_GET
#define CFP_TCAM_NONIP_SCm_SP_PRIf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_SET
#define CFP_TCAM_NONIP_SCm_UDF0_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF0_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF1_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF1_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF2_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF2_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF3_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF3_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF4_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF4_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF5_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF5_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF6_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF6_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF7_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF7_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF8_VLDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF8_VLDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_SET
#define CFP_TCAM_NONIP_SCm_RESERVED_1Rf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_NONIP_SCm_RESERVED_1Rf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_GET
#define CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_SET
#define CFP_TCAM_NONIP_SCm_L3_FRAMINGf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_NONIP_SCm_L3_FRAMINGf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_NONIP_SCm_L2_FRAMINGf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_NONIP_SCm_L2_FRAMINGf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_NONIP_SCm_C_TAGGEDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_GET
#define CFP_TCAM_NONIP_SCm_C_TAGGEDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_SET
#define CFP_TCAM_NONIP_SCm_S_TAGGEDf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_GET
#define CFP_TCAM_NONIP_SCm_S_TAGGEDf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_SET
#define CFP_TCAM_NONIP_SCm_SRC_PMAPf_GET BCM89500_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_GET
#define CFP_TCAM_NONIP_SCm_SRC_PMAPf_SET BCM89500_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_SET
#define READ_CFP_TCAM_NONIP_SCm BCM89500_A0_READ_CFP_TCAM_NONIP_SCm
#define WRITE_CFP_TCAM_NONIP_SCm BCM89500_A0_WRITE_CFP_TCAM_NONIP_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CFP_TCAM_NONIP_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CHIP_REVID
 * BLOCKS:   SYS
 * DESC:     Chip Version ID Register
 * SIZE:     8
 * FIELDS:
 *     REVID            Chip Version ID.Bit 3:2 - Revision ID-00 = A-01 = B-10 = C-11 = DBit 1:0 - Revision number
 *
 ******************************************************************************/
#define BCM89500_A0_CHIP_REVIDr 0x00000240

#define BCM89500_A0_CHIP_REVIDr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_REVID.
 *
 */
typedef union BCM89500_A0_CHIP_REVIDr_s {
	uint32_t v[1];
	uint32_t chip_revid[1];
	uint32_t _chip_revid;
} BCM89500_A0_CHIP_REVIDr_t;

#define BCM89500_A0_CHIP_REVIDr_CLR(r) (r).chip_revid[0] = 0
#define BCM89500_A0_CHIP_REVIDr_SET(r,d) (r).chip_revid[0] = d
#define BCM89500_A0_CHIP_REVIDr_GET(r) (r).chip_revid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CHIP_REVIDr_REVIDf_GET(r) (((r).chip_revid[0]) & 0xff)
#define BCM89500_A0_CHIP_REVIDr_REVIDf_SET(r,f) (r).chip_revid[0]=(((r).chip_revid[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CHIP_REVID.
 *
 */
#define BCM89500_A0_READ_CHIP_REVIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CHIP_REVIDr,(r._chip_revid),1)
#define BCM89500_A0_WRITE_CHIP_REVIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CHIP_REVIDr,&(r._chip_revid),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_REVIDr BCM89500_A0_CHIP_REVIDr
#define CHIP_REVIDr_SIZE BCM89500_A0_CHIP_REVIDr_SIZE
typedef BCM89500_A0_CHIP_REVIDr_t CHIP_REVIDr_t;
#define CHIP_REVIDr_CLR BCM89500_A0_CHIP_REVIDr_CLR
#define CHIP_REVIDr_SET BCM89500_A0_CHIP_REVIDr_SET
#define CHIP_REVIDr_GET BCM89500_A0_CHIP_REVIDr_GET
#define CHIP_REVIDr_REVIDf_GET BCM89500_A0_CHIP_REVIDr_REVIDf_GET
#define CHIP_REVIDr_REVIDf_SET BCM89500_A0_CHIP_REVIDr_REVIDf_SET
#define READ_CHIP_REVIDr BCM89500_A0_READ_CHIP_REVIDr
#define WRITE_CHIP_REVIDr BCM89500_A0_WRITE_CHIP_REVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CHIP_REVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CLKSET
 * BLOCKS:   SPI
 * DESC:     Clock Period Setting Registers
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Clock Control Register
 *
 ******************************************************************************/
#define BCM89500_A0_CLKSETr 0x0000fffa

#define BCM89500_A0_CLKSETr_SIZE 4

/*
 * This structure should be used to declare and program CLKSET.
 *
 */
typedef union BCM89500_A0_CLKSETr_s {
	uint32_t v[1];
	uint32_t clkset[1];
	uint32_t _clkset;
} BCM89500_A0_CLKSETr_t;

#define BCM89500_A0_CLKSETr_CLR(r) (r).clkset[0] = 0
#define BCM89500_A0_CLKSETr_SET(r,d) (r).clkset[0] = d
#define BCM89500_A0_CLKSETr_GET(r) (r).clkset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CLKSETr_RESERVEDf_GET(r) ((r).clkset[0])
#define BCM89500_A0_CLKSETr_RESERVEDf_SET(r,f) (r).clkset[0]=((uint32_t)f)

/*
 * These macros can be used to access CLKSET.
 *
 */
#define BCM89500_A0_READ_CLKSETr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CLKSETr,(r._clkset),4)
#define BCM89500_A0_WRITE_CLKSETr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CLKSETr,&(r._clkset),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CLKSETr BCM89500_A0_CLKSETr
#define CLKSETr_SIZE BCM89500_A0_CLKSETr_SIZE
typedef BCM89500_A0_CLKSETr_t CLKSETr_t;
#define CLKSETr_CLR BCM89500_A0_CLKSETr_CLR
#define CLKSETr_SET BCM89500_A0_CLKSETr_SET
#define CLKSETr_GET BCM89500_A0_CLKSETr_GET
#define CLKSETr_RESERVEDf_GET BCM89500_A0_CLKSETr_RESERVEDf_GET
#define CLKSETr_RESERVEDf_SET BCM89500_A0_CLKSETr_RESERVEDf_SET
#define READ_CLKSETr BCM89500_A0_READ_CLKSETr
#define WRITE_CLKSETr BCM89500_A0_WRITE_CLKSETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CLKSETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CNTR_DBG
 * BLOCKS:   SYS
 * DESC:     Control and Debug Registers
 * SIZE:     16
 * FIELDS:
 *     RST_TX_CNTR      RST_TX_CNTR
 *     RST_RX_CNTR      RST_RX_CNTR
 *     CNTR_SLICE_SEL   CNTR_SLICE_SEL
 *     TC_80_LEAP       80 bits time code counter controlbit[6] - A command set by the CPU. Equivalent to Increment by 2 on the next time. Afterwards revert to default behavior.bit[5] - A command set by the CPU. Equivalent to Increment by 0 on the next time. Afterwards revert to default behavior.
 *     TS_SLICE_SEL     TS_SLICE_SEL
 *     HB_CNTL          heartbeat read start and end bitbit[11]: endbit[10]: start
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CNTR_DBGr 0x00009412

#define BCM89500_A0_CNTR_DBGr_SIZE 2

/*
 * This structure should be used to declare and program CNTR_DBG.
 *
 */
typedef union BCM89500_A0_CNTR_DBGr_s {
	uint32_t v[1];
	uint32_t cntr_dbg[1];
	uint32_t _cntr_dbg;
} BCM89500_A0_CNTR_DBGr_t;

#define BCM89500_A0_CNTR_DBGr_CLR(r) (r).cntr_dbg[0] = 0
#define BCM89500_A0_CNTR_DBGr_SET(r,d) (r).cntr_dbg[0] = d
#define BCM89500_A0_CNTR_DBGr_GET(r) (r).cntr_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CNTR_DBGr_RST_TX_CNTRf_GET(r) (((r).cntr_dbg[0]) & 0x1)
#define BCM89500_A0_CNTR_DBGr_RST_TX_CNTRf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CNTR_DBGr_RST_RX_CNTRf_GET(r) ((((r).cntr_dbg[0]) >> 1) & 0x1)
#define BCM89500_A0_CNTR_DBGr_RST_RX_CNTRf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_CNTR_DBGr_CNTR_SLICE_SELf_GET(r) ((((r).cntr_dbg[0]) >> 2) & 0x7)
#define BCM89500_A0_CNTR_DBGr_CNTR_SLICE_SELf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM89500_A0_CNTR_DBGr_TC_80_LEAPf_GET(r) ((((r).cntr_dbg[0]) >> 5) & 0x3)
#define BCM89500_A0_CNTR_DBGr_TC_80_LEAPf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM89500_A0_CNTR_DBGr_TS_SLICE_SELf_GET(r) ((((r).cntr_dbg[0]) >> 7) & 0x7)
#define BCM89500_A0_CNTR_DBGr_TS_SLICE_SELf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM89500_A0_CNTR_DBGr_HB_CNTLf_GET(r) ((((r).cntr_dbg[0]) >> 10) & 0x3)
#define BCM89500_A0_CNTR_DBGr_HB_CNTLf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM89500_A0_CNTR_DBGr_RESERVEDf_GET(r) ((((r).cntr_dbg[0]) >> 12) & 0xf)
#define BCM89500_A0_CNTR_DBGr_RESERVEDf_SET(r,f) (r).cntr_dbg[0]=(((r).cntr_dbg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access CNTR_DBG.
 *
 */
#define BCM89500_A0_READ_CNTR_DBGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CNTR_DBGr,(r._cntr_dbg),2)
#define BCM89500_A0_WRITE_CNTR_DBGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CNTR_DBGr,&(r._cntr_dbg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNTR_DBGr BCM89500_A0_CNTR_DBGr
#define CNTR_DBGr_SIZE BCM89500_A0_CNTR_DBGr_SIZE
typedef BCM89500_A0_CNTR_DBGr_t CNTR_DBGr_t;
#define CNTR_DBGr_CLR BCM89500_A0_CNTR_DBGr_CLR
#define CNTR_DBGr_SET BCM89500_A0_CNTR_DBGr_SET
#define CNTR_DBGr_GET BCM89500_A0_CNTR_DBGr_GET
#define CNTR_DBGr_RST_TX_CNTRf_GET BCM89500_A0_CNTR_DBGr_RST_TX_CNTRf_GET
#define CNTR_DBGr_RST_TX_CNTRf_SET BCM89500_A0_CNTR_DBGr_RST_TX_CNTRf_SET
#define CNTR_DBGr_RST_RX_CNTRf_GET BCM89500_A0_CNTR_DBGr_RST_RX_CNTRf_GET
#define CNTR_DBGr_RST_RX_CNTRf_SET BCM89500_A0_CNTR_DBGr_RST_RX_CNTRf_SET
#define CNTR_DBGr_CNTR_SLICE_SELf_GET BCM89500_A0_CNTR_DBGr_CNTR_SLICE_SELf_GET
#define CNTR_DBGr_CNTR_SLICE_SELf_SET BCM89500_A0_CNTR_DBGr_CNTR_SLICE_SELf_SET
#define CNTR_DBGr_TC_80_LEAPf_GET BCM89500_A0_CNTR_DBGr_TC_80_LEAPf_GET
#define CNTR_DBGr_TC_80_LEAPf_SET BCM89500_A0_CNTR_DBGr_TC_80_LEAPf_SET
#define CNTR_DBGr_TS_SLICE_SELf_GET BCM89500_A0_CNTR_DBGr_TS_SLICE_SELf_GET
#define CNTR_DBGr_TS_SLICE_SELf_SET BCM89500_A0_CNTR_DBGr_TS_SLICE_SELf_SET
#define CNTR_DBGr_HB_CNTLf_GET BCM89500_A0_CNTR_DBGr_HB_CNTLf_GET
#define CNTR_DBGr_HB_CNTLf_SET BCM89500_A0_CNTR_DBGr_HB_CNTLf_SET
#define CNTR_DBGr_RESERVEDf_GET BCM89500_A0_CNTR_DBGr_RESERVEDf_GET
#define CNTR_DBGr_RESERVEDf_SET BCM89500_A0_CNTR_DBGr_RESERVEDf_SET
#define READ_CNTR_DBGr BCM89500_A0_READ_CNTR_DBGr
#define WRITE_CNTR_DBGr BCM89500_A0_WRITE_CNTR_DBGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CNTR_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  COMM_IRC_CON
 * BLOCKS:   SYS
 * DESC:     Common Ingress rate Control Configuration Registers
 * SIZE:     32
 * FIELDS:
 *     PKT_MSK0         Packet Mask for Bucket 0Bit 0: Unicast lookup hitBit 1: Multicast lookup hitBit 2: Reserved Mac Address Frame(01-80-C2-0-00-2F)Bit 3: BroadcastBit 4: Multicats lookup failBit 5: Unicast lookup fail
 *     XLENEN_EG        Bit Rate Mode Selection for Egress Control0 : TX Rate excluding IPG1 : TX Rate including IPG (and preamble + SFD)
 *     DROP_EN0         suppression Drop Mode Enabled. (Not2Release)1:The incoming packet will be dropped if the allowed bandwidth for those packets defined in Packet Type Mask is up.0:The Pause Frame/Jamming Frame will be transmitted depend on Full/HalfDuplex Mode if the allowed bandwidth for those packets defined in Packet Type Mask is up.
 *     RATE_TYPE0       Bit Rate Mode selection.0: E3556 ModeIncoming Bit Rate is Defined in Refresh Count in per Ingress Port Rate Control Register with Absolute amout and Nothing about Link Speed.1:Bit Rate Related to Link Speed ModeIncoming Bit Rate is Define in Refresh Count in Per Ingress Port Rate Control Register with Related Amount to Link Speed
 *     PKT_MSK1         Packet Mask for Bucket 1Suppressed Packet Type in Bucket 1Bit 0: Unicast lookup hitBit 1: Multicast lookup hitBit 2: Reserved Mac Address Frame(01-80-C2-0-00-2F)Bit 3: BroadcastBit 4: Multicats lookup failBit 5: Unicast lookup failBit 6: Reserved
 *     DROP_EN1         suppression Drop Mode Enabled. (Not2Release)1:The incoming packet will be dropped if the allowed bandwidth for those packets defined in Packet Type Mask is up.0:The Pause Frame/Jamming Frame will be transmitted depend on Full/HalfDuplex Mode if the allowed bandwidth for those packets defined in Packet Type Mask is up.
 *     RATE_TYPE1       Bit Rate Mode selection.0:Absolute Bit Rate ModeIncoming Bit Rate is Defined in Refresh Count in per Ingress Port Rate Control Register with Absolute amout and Nothing about Link Speed.1:Bit Rate Related to Link Speed ModeIncoming Bit Rate is Define in Refresh Count in Per Ingress Port Rate Control Register with Related Amount to Link Speed
 *     XLEN_EN          bit rate Mode  Selection.0 : Rx rate excluding Preamble and IPG (20B)1 : Rx rate including Preamble and IPG (20B)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_COMM_IRC_CONr 0x00004100

#define BCM89500_A0_COMM_IRC_CONr_SIZE 4

/*
 * This structure should be used to declare and program COMM_IRC_CON.
 *
 */
typedef union BCM89500_A0_COMM_IRC_CONr_s {
	uint32_t v[1];
	uint32_t comm_irc_con[1];
	uint32_t _comm_irc_con;
} BCM89500_A0_COMM_IRC_CONr_t;

#define BCM89500_A0_COMM_IRC_CONr_CLR(r) (r).comm_irc_con[0] = 0
#define BCM89500_A0_COMM_IRC_CONr_SET(r,d) (r).comm_irc_con[0] = d
#define BCM89500_A0_COMM_IRC_CONr_GET(r) (r).comm_irc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_COMM_IRC_CONr_PKT_MSK0f_GET(r) (((r).comm_irc_con[0]) & 0x3f)
#define BCM89500_A0_COMM_IRC_CONr_PKT_MSK0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_COMM_IRC_CONr_XLENEN_EGf_GET(r) ((((r).comm_irc_con[0]) >> 6) & 0x1)
#define BCM89500_A0_COMM_IRC_CONr_XLENEN_EGf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_COMM_IRC_CONr_DROP_EN0f_GET(r) ((((r).comm_irc_con[0]) >> 7) & 0x1)
#define BCM89500_A0_COMM_IRC_CONr_DROP_EN0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_COMM_IRC_CONr_RATE_TYPE0f_GET(r) ((((r).comm_irc_con[0]) >> 8) & 0x1)
#define BCM89500_A0_COMM_IRC_CONr_RATE_TYPE0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_COMM_IRC_CONr_PKT_MSK1f_GET(r) ((((r).comm_irc_con[0]) >> 9) & 0x7f)
#define BCM89500_A0_COMM_IRC_CONr_PKT_MSK1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM89500_A0_COMM_IRC_CONr_DROP_EN1f_GET(r) ((((r).comm_irc_con[0]) >> 16) & 0x1)
#define BCM89500_A0_COMM_IRC_CONr_DROP_EN1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_COMM_IRC_CONr_RATE_TYPE1f_GET(r) ((((r).comm_irc_con[0]) >> 17) & 0x1)
#define BCM89500_A0_COMM_IRC_CONr_RATE_TYPE1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM89500_A0_COMM_IRC_CONr_XLEN_ENf_GET(r) ((((r).comm_irc_con[0]) >> 18) & 0x1)
#define BCM89500_A0_COMM_IRC_CONr_XLEN_ENf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM89500_A0_COMM_IRC_CONr_RESERVEDf_GET(r) ((((r).comm_irc_con[0]) >> 19) & 0x1fff)
#define BCM89500_A0_COMM_IRC_CONr_RESERVEDf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access COMM_IRC_CON.
 *
 */
#define BCM89500_A0_READ_COMM_IRC_CONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_COMM_IRC_CONr,(r._comm_irc_con),4)
#define BCM89500_A0_WRITE_COMM_IRC_CONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_COMM_IRC_CONr,&(r._comm_irc_con),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COMM_IRC_CONr BCM89500_A0_COMM_IRC_CONr
#define COMM_IRC_CONr_SIZE BCM89500_A0_COMM_IRC_CONr_SIZE
typedef BCM89500_A0_COMM_IRC_CONr_t COMM_IRC_CONr_t;
#define COMM_IRC_CONr_CLR BCM89500_A0_COMM_IRC_CONr_CLR
#define COMM_IRC_CONr_SET BCM89500_A0_COMM_IRC_CONr_SET
#define COMM_IRC_CONr_GET BCM89500_A0_COMM_IRC_CONr_GET
#define COMM_IRC_CONr_PKT_MSK0f_GET BCM89500_A0_COMM_IRC_CONr_PKT_MSK0f_GET
#define COMM_IRC_CONr_PKT_MSK0f_SET BCM89500_A0_COMM_IRC_CONr_PKT_MSK0f_SET
#define COMM_IRC_CONr_XLENEN_EGf_GET BCM89500_A0_COMM_IRC_CONr_XLENEN_EGf_GET
#define COMM_IRC_CONr_XLENEN_EGf_SET BCM89500_A0_COMM_IRC_CONr_XLENEN_EGf_SET
#define COMM_IRC_CONr_DROP_EN0f_GET BCM89500_A0_COMM_IRC_CONr_DROP_EN0f_GET
#define COMM_IRC_CONr_DROP_EN0f_SET BCM89500_A0_COMM_IRC_CONr_DROP_EN0f_SET
#define COMM_IRC_CONr_RATE_TYPE0f_GET BCM89500_A0_COMM_IRC_CONr_RATE_TYPE0f_GET
#define COMM_IRC_CONr_RATE_TYPE0f_SET BCM89500_A0_COMM_IRC_CONr_RATE_TYPE0f_SET
#define COMM_IRC_CONr_PKT_MSK1f_GET BCM89500_A0_COMM_IRC_CONr_PKT_MSK1f_GET
#define COMM_IRC_CONr_PKT_MSK1f_SET BCM89500_A0_COMM_IRC_CONr_PKT_MSK1f_SET
#define COMM_IRC_CONr_DROP_EN1f_GET BCM89500_A0_COMM_IRC_CONr_DROP_EN1f_GET
#define COMM_IRC_CONr_DROP_EN1f_SET BCM89500_A0_COMM_IRC_CONr_DROP_EN1f_SET
#define COMM_IRC_CONr_RATE_TYPE1f_GET BCM89500_A0_COMM_IRC_CONr_RATE_TYPE1f_GET
#define COMM_IRC_CONr_RATE_TYPE1f_SET BCM89500_A0_COMM_IRC_CONr_RATE_TYPE1f_SET
#define COMM_IRC_CONr_XLEN_ENf_GET BCM89500_A0_COMM_IRC_CONr_XLEN_ENf_GET
#define COMM_IRC_CONr_XLEN_ENf_SET BCM89500_A0_COMM_IRC_CONr_XLEN_ENf_SET
#define COMM_IRC_CONr_RESERVEDf_GET BCM89500_A0_COMM_IRC_CONr_RESERVEDf_GET
#define COMM_IRC_CONr_RESERVEDf_SET BCM89500_A0_COMM_IRC_CONr_RESERVEDf_SET
#define READ_COMM_IRC_CONr BCM89500_A0_READ_COMM_IRC_CONr
#define WRITE_COMM_IRC_CONr BCM89500_A0_WRITE_COMM_IRC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_COMM_IRC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CPU2COS_MAP
 * BLOCKS:   SYS
 * DESC:     CPU to COS Mapping Register
 * SIZE:     32
 * FIELDS:
 *     MIRROR           The packet forwarded to the CPU for mirroring reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     SA_LRN           The packet forwarded to the CPU for SA Learning reason .The COS selection is based on the highest COS valuses among all the resons for the packet..
 *     SW_FLD           The packet forwarded to the CPU for Switching/Flooding reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_TRMNT       The packet forwarded to the CPU for Protocol Termination reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_SNOOP       The packet forwarded to the CPU for Protocol Snooping reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     EXCPT_PRCS       The packet forwarded to the CPU for Exception Processing reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CPU2COS_MAPr 0x00003064

#define BCM89500_A0_CPU2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CPU2COS_MAP.
 *
 */
typedef union BCM89500_A0_CPU2COS_MAPr_s {
	uint32_t v[1];
	uint32_t cpu2cos_map[1];
	uint32_t _cpu2cos_map;
} BCM89500_A0_CPU2COS_MAPr_t;

#define BCM89500_A0_CPU2COS_MAPr_CLR(r) (r).cpu2cos_map[0] = 0
#define BCM89500_A0_CPU2COS_MAPr_SET(r,d) (r).cpu2cos_map[0] = d
#define BCM89500_A0_CPU2COS_MAPr_GET(r) (r).cpu2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CPU2COS_MAPr_MIRRORf_GET(r) (((r).cpu2cos_map[0]) & 0x7)
#define BCM89500_A0_CPU2COS_MAPr_MIRRORf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_CPU2COS_MAPr_SA_LRNf_GET(r) ((((r).cpu2cos_map[0]) >> 3) & 0x7)
#define BCM89500_A0_CPU2COS_MAPr_SA_LRNf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_CPU2COS_MAPr_SW_FLDf_GET(r) ((((r).cpu2cos_map[0]) >> 6) & 0x7)
#define BCM89500_A0_CPU2COS_MAPr_SW_FLDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET(r) ((((r).cpu2cos_map[0]) >> 9) & 0x7)
#define BCM89500_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET(r) ((((r).cpu2cos_map[0]) >> 12) & 0x7)
#define BCM89500_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET(r) ((((r).cpu2cos_map[0]) >> 15) & 0x7)
#define BCM89500_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_CPU2COS_MAPr_RESERVEDf_GET(r) ((((r).cpu2cos_map[0]) >> 18) & 0x3fff)
#define BCM89500_A0_CPU2COS_MAPr_RESERVEDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access CPU2COS_MAP.
 *
 */
#define BCM89500_A0_READ_CPU2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CPU2COS_MAPr,(r._cpu2cos_map),4)
#define BCM89500_A0_WRITE_CPU2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CPU2COS_MAPr,&(r._cpu2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU2COS_MAPr BCM89500_A0_CPU2COS_MAPr
#define CPU2COS_MAPr_SIZE BCM89500_A0_CPU2COS_MAPr_SIZE
typedef BCM89500_A0_CPU2COS_MAPr_t CPU2COS_MAPr_t;
#define CPU2COS_MAPr_CLR BCM89500_A0_CPU2COS_MAPr_CLR
#define CPU2COS_MAPr_SET BCM89500_A0_CPU2COS_MAPr_SET
#define CPU2COS_MAPr_GET BCM89500_A0_CPU2COS_MAPr_GET
#define CPU2COS_MAPr_MIRRORf_GET BCM89500_A0_CPU2COS_MAPr_MIRRORf_GET
#define CPU2COS_MAPr_MIRRORf_SET BCM89500_A0_CPU2COS_MAPr_MIRRORf_SET
#define CPU2COS_MAPr_SA_LRNf_GET BCM89500_A0_CPU2COS_MAPr_SA_LRNf_GET
#define CPU2COS_MAPr_SA_LRNf_SET BCM89500_A0_CPU2COS_MAPr_SA_LRNf_SET
#define CPU2COS_MAPr_SW_FLDf_GET BCM89500_A0_CPU2COS_MAPr_SW_FLDf_GET
#define CPU2COS_MAPr_SW_FLDf_SET BCM89500_A0_CPU2COS_MAPr_SW_FLDf_SET
#define CPU2COS_MAPr_PRTC_TRMNTf_GET BCM89500_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET
#define CPU2COS_MAPr_PRTC_TRMNTf_SET BCM89500_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET
#define CPU2COS_MAPr_PRTC_SNOOPf_GET BCM89500_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET
#define CPU2COS_MAPr_PRTC_SNOOPf_SET BCM89500_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET
#define CPU2COS_MAPr_EXCPT_PRCSf_GET BCM89500_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET
#define CPU2COS_MAPr_EXCPT_PRCSf_SET BCM89500_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET
#define CPU2COS_MAPr_RESERVEDf_GET BCM89500_A0_CPU2COS_MAPr_RESERVEDf_GET
#define CPU2COS_MAPr_RESERVEDf_SET BCM89500_A0_CPU2COS_MAPr_RESERVEDf_SET
#define READ_CPU2COS_MAPr BCM89500_A0_READ_CPU2COS_MAPr
#define WRITE_CPU2COS_MAPr BCM89500_A0_WRITE_CPU2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CPU2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CPU_DATA_SHARE
 * BLOCKS:   SYS
 * DESC:     CPU Data Share Register
 * SIZE:     64
 * FIELDS:
 *     CPU_DATA_SHARE   Data to be shared by internal CPU and external CPU.
 *
 ******************************************************************************/
#define BCM89500_A0_CPU_DATA_SHAREr 0x00000350

#define BCM89500_A0_CPU_DATA_SHAREr_SIZE 8

/*
 * This structure should be used to declare and program CPU_DATA_SHARE.
 *
 */
typedef union BCM89500_A0_CPU_DATA_SHAREr_s {
	uint32_t v[2];
	uint32_t cpu_data_share[2];
	uint32_t _cpu_data_share;
} BCM89500_A0_CPU_DATA_SHAREr_t;

#define BCM89500_A0_CPU_DATA_SHAREr_CLR(r) CDK_MEMSET(&((r)._cpu_data_share), 0, sizeof(BCM89500_A0_CPU_DATA_SHAREr_t))
#define BCM89500_A0_CPU_DATA_SHAREr_SET(r,i,d) (r).cpu_data_share[i] = d
#define BCM89500_A0_CPU_DATA_SHAREr_GET(r,i) (r).cpu_data_share[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_GET(r,a) cdk_field_get((r).cpu_data_share,0,63,a)
#define BCM89500_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_SET(r,a) cdk_field_set((r).cpu_data_share,0,63,a)

/*
 * These macros can be used to access CPU_DATA_SHARE.
 *
 */
#define BCM89500_A0_READ_CPU_DATA_SHAREr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CPU_DATA_SHAREr,(r._cpu_data_share),8)
#define BCM89500_A0_WRITE_CPU_DATA_SHAREr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CPU_DATA_SHAREr,&(r._cpu_data_share),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_DATA_SHAREr BCM89500_A0_CPU_DATA_SHAREr
#define CPU_DATA_SHAREr_SIZE BCM89500_A0_CPU_DATA_SHAREr_SIZE
typedef BCM89500_A0_CPU_DATA_SHAREr_t CPU_DATA_SHAREr_t;
#define CPU_DATA_SHAREr_CLR BCM89500_A0_CPU_DATA_SHAREr_CLR
#define CPU_DATA_SHAREr_SET BCM89500_A0_CPU_DATA_SHAREr_SET
#define CPU_DATA_SHAREr_GET BCM89500_A0_CPU_DATA_SHAREr_GET
#define CPU_DATA_SHAREr_CPU_DATA_SHAREf_GET BCM89500_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_GET
#define CPU_DATA_SHAREr_CPU_DATA_SHAREf_SET BCM89500_A0_CPU_DATA_SHAREr_CPU_DATA_SHAREf_SET
#define READ_CPU_DATA_SHAREr BCM89500_A0_READ_CPU_DATA_SHAREr
#define WRITE_CPU_DATA_SHAREr BCM89500_A0_WRITE_CPU_DATA_SHAREr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CPU_DATA_SHAREr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CPU_DATA_SHARE_1
 * BLOCKS:   SYS
 * DESC:     CPU Data Share 1 Register (polar feature)
 * SIZE:     64
 * FIELDS:
 *     CPU_DATA_SHARE   Data to be shared by internal CPU and external CPU.
 *
 ******************************************************************************/
#define BCM89500_A0_CPU_DATA_SHARE_1r 0x00000358

#define BCM89500_A0_CPU_DATA_SHARE_1r_SIZE 8

/*
 * This structure should be used to declare and program CPU_DATA_SHARE_1.
 *
 */
typedef union BCM89500_A0_CPU_DATA_SHARE_1r_s {
	uint32_t v[2];
	uint32_t cpu_data_share_1[2];
	uint32_t _cpu_data_share_1;
} BCM89500_A0_CPU_DATA_SHARE_1r_t;

#define BCM89500_A0_CPU_DATA_SHARE_1r_CLR(r) CDK_MEMSET(&((r)._cpu_data_share_1), 0, sizeof(BCM89500_A0_CPU_DATA_SHARE_1r_t))
#define BCM89500_A0_CPU_DATA_SHARE_1r_SET(r,i,d) (r).cpu_data_share_1[i] = d
#define BCM89500_A0_CPU_DATA_SHARE_1r_GET(r,i) (r).cpu_data_share_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CPU_DATA_SHARE_1r_CPU_DATA_SHAREf_GET(r,a) cdk_field_get((r).cpu_data_share_1,0,63,a)
#define BCM89500_A0_CPU_DATA_SHARE_1r_CPU_DATA_SHAREf_SET(r,a) cdk_field_set((r).cpu_data_share_1,0,63,a)

/*
 * These macros can be used to access CPU_DATA_SHARE_1.
 *
 */
#define BCM89500_A0_READ_CPU_DATA_SHARE_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_CPU_DATA_SHARE_1r,(r._cpu_data_share_1),8)
#define BCM89500_A0_WRITE_CPU_DATA_SHARE_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_CPU_DATA_SHARE_1r,&(r._cpu_data_share_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_DATA_SHARE_1r BCM89500_A0_CPU_DATA_SHARE_1r
#define CPU_DATA_SHARE_1r_SIZE BCM89500_A0_CPU_DATA_SHARE_1r_SIZE
typedef BCM89500_A0_CPU_DATA_SHARE_1r_t CPU_DATA_SHARE_1r_t;
#define CPU_DATA_SHARE_1r_CLR BCM89500_A0_CPU_DATA_SHARE_1r_CLR
#define CPU_DATA_SHARE_1r_SET BCM89500_A0_CPU_DATA_SHARE_1r_SET
#define CPU_DATA_SHARE_1r_GET BCM89500_A0_CPU_DATA_SHARE_1r_GET
#define CPU_DATA_SHARE_1r_CPU_DATA_SHAREf_GET BCM89500_A0_CPU_DATA_SHARE_1r_CPU_DATA_SHAREf_GET
#define CPU_DATA_SHARE_1r_CPU_DATA_SHAREf_SET BCM89500_A0_CPU_DATA_SHARE_1r_CPU_DATA_SHAREf_SET
#define READ_CPU_DATA_SHARE_1r BCM89500_A0_READ_CPU_DATA_SHARE_1r
#define WRITE_CPU_DATA_SHARE_1r BCM89500_A0_WRITE_CPU_DATA_SHARE_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CPU_DATA_SHARE_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  CPU_RESOURCE_ARBITER
 * BLOCKS:   SYS
 * DESC:     CPU Resource Arbitor Register
 * SIZE:     8
 * FIELDS:
 *     EXT_CPU_GNT      GNT signal for external CPU.1 = Granted by arbitor.
 *     EXT_CPU_REQ      REQ signal for external CPU.When CPU need to access critical section, it asserts REQ signal for arbitration. When granted by arbiter, the GNT signal will be asserted to inform the requester. The requester keeps asserting the REQ signal to lock the arbiter. When done, the requester deasserts REQ to give chance to the other requester.1 = Assert0 = Deassert
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_CPU_RESOURCE_ARBITERr 0x00000340

#define BCM89500_A0_CPU_RESOURCE_ARBITERr_SIZE 1

/*
 * This structure should be used to declare and program CPU_RESOURCE_ARBITER.
 *
 */
typedef union BCM89500_A0_CPU_RESOURCE_ARBITERr_s {
	uint32_t v[1];
	uint32_t cpu_resource_arbiter[1];
	uint32_t _cpu_resource_arbiter;
} BCM89500_A0_CPU_RESOURCE_ARBITERr_t;

#define BCM89500_A0_CPU_RESOURCE_ARBITERr_CLR(r) (r).cpu_resource_arbiter[0] = 0
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_SET(r,d) (r).cpu_resource_arbiter[0] = d
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_GET(r) (r).cpu_resource_arbiter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_GET(r) (((r).cpu_resource_arbiter[0]) & 0x1)
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_SET(r,f) (r).cpu_resource_arbiter[0]=(((r).cpu_resource_arbiter[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_GET(r) ((((r).cpu_resource_arbiter[0]) >> 1) & 0x1)
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_SET(r,f) (r).cpu_resource_arbiter[0]=(((r).cpu_resource_arbiter[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_GET(r) ((((r).cpu_resource_arbiter[0]) >> 2) & 0x3f)
#define BCM89500_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_SET(r,f) (r).cpu_resource_arbiter[0]=(((r).cpu_resource_arbiter[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access CPU_RESOURCE_ARBITER.
 *
 */
#define BCM89500_A0_READ_CPU_RESOURCE_ARBITERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_CPU_RESOURCE_ARBITERr,(r._cpu_resource_arbiter),1)
#define BCM89500_A0_WRITE_CPU_RESOURCE_ARBITERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_CPU_RESOURCE_ARBITERr,&(r._cpu_resource_arbiter),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_RESOURCE_ARBITERr BCM89500_A0_CPU_RESOURCE_ARBITERr
#define CPU_RESOURCE_ARBITERr_SIZE BCM89500_A0_CPU_RESOURCE_ARBITERr_SIZE
typedef BCM89500_A0_CPU_RESOURCE_ARBITERr_t CPU_RESOURCE_ARBITERr_t;
#define CPU_RESOURCE_ARBITERr_CLR BCM89500_A0_CPU_RESOURCE_ARBITERr_CLR
#define CPU_RESOURCE_ARBITERr_SET BCM89500_A0_CPU_RESOURCE_ARBITERr_SET
#define CPU_RESOURCE_ARBITERr_GET BCM89500_A0_CPU_RESOURCE_ARBITERr_GET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_GET BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_GET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_SET BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_GNTf_SET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_GET BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_GET
#define CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_SET BCM89500_A0_CPU_RESOURCE_ARBITERr_EXT_CPU_REQf_SET
#define CPU_RESOURCE_ARBITERr_RESERVEDf_GET BCM89500_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_GET
#define CPU_RESOURCE_ARBITERr_RESERVEDf_SET BCM89500_A0_CPU_RESOURCE_ARBITERr_RESERVEDf_SET
#define READ_CPU_RESOURCE_ARBITERr BCM89500_A0_READ_CPU_RESOURCE_ARBITERr
#define WRITE_CPU_RESOURCE_ARBITERr BCM89500_A0_WRITE_CPU_RESOURCE_ARBITERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_CPU_RESOURCE_ARBITERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DEBUG_REG
 * BLOCKS:   SYS
 * DESC:     Debug Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_DEBUG         1 : Enable debugging bus
 *     DEBUG_SEL        Debug bus select.
 *     PROBE_SOC_DMU_CLK (polar feature)used to enable SOC dmu clock probe output mux to GPIO0 for probing.
 *
 ******************************************************************************/
#define BCM89500_A0_DEBUG_REGr 0x0000001e

#define BCM89500_A0_DEBUG_REGr_SIZE 1

/*
 * This structure should be used to declare and program DEBUG_REG.
 *
 */
typedef union BCM89500_A0_DEBUG_REGr_s {
	uint32_t v[1];
	uint32_t debug_reg[1];
	uint32_t _debug_reg;
} BCM89500_A0_DEBUG_REGr_t;

#define BCM89500_A0_DEBUG_REGr_CLR(r) (r).debug_reg[0] = 0
#define BCM89500_A0_DEBUG_REGr_SET(r,d) (r).debug_reg[0] = d
#define BCM89500_A0_DEBUG_REGr_GET(r) (r).debug_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DEBUG_REGr_EN_DEBUGf_GET(r) (((r).debug_reg[0]) & 0x1)
#define BCM89500_A0_DEBUG_REGr_EN_DEBUGf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_DEBUG_REGr_DEBUG_SELf_GET(r) ((((r).debug_reg[0]) >> 1) & 0x3f)
#define BCM89500_A0_DEBUG_REGr_DEBUG_SELf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM89500_A0_DEBUG_REGr_PROBE_SOC_DMU_CLKf_GET(r) ((((r).debug_reg[0]) >> 7) & 0x1)
#define BCM89500_A0_DEBUG_REGr_PROBE_SOC_DMU_CLKf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access DEBUG_REG.
 *
 */
#define BCM89500_A0_READ_DEBUG_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DEBUG_REGr,(r._debug_reg),1)
#define BCM89500_A0_WRITE_DEBUG_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DEBUG_REGr,&(r._debug_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_REGr BCM89500_A0_DEBUG_REGr
#define DEBUG_REGr_SIZE BCM89500_A0_DEBUG_REGr_SIZE
typedef BCM89500_A0_DEBUG_REGr_t DEBUG_REGr_t;
#define DEBUG_REGr_CLR BCM89500_A0_DEBUG_REGr_CLR
#define DEBUG_REGr_SET BCM89500_A0_DEBUG_REGr_SET
#define DEBUG_REGr_GET BCM89500_A0_DEBUG_REGr_GET
#define DEBUG_REGr_EN_DEBUGf_GET BCM89500_A0_DEBUG_REGr_EN_DEBUGf_GET
#define DEBUG_REGr_EN_DEBUGf_SET BCM89500_A0_DEBUG_REGr_EN_DEBUGf_SET
#define DEBUG_REGr_DEBUG_SELf_GET BCM89500_A0_DEBUG_REGr_DEBUG_SELf_GET
#define DEBUG_REGr_DEBUG_SELf_SET BCM89500_A0_DEBUG_REGr_DEBUG_SELf_SET
#define DEBUG_REGr_PROBE_SOC_DMU_CLKf_GET BCM89500_A0_DEBUG_REGr_PROBE_SOC_DMU_CLKf_GET
#define DEBUG_REGr_PROBE_SOC_DMU_CLKf_SET BCM89500_A0_DEBUG_REGr_PROBE_SOC_DMU_CLKf_SET
#define READ_DEBUG_REGr BCM89500_A0_READ_DEBUG_REGr
#define WRITE_DEBUG_REGr BCM89500_A0_WRITE_DEBUG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DEBUG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DEFAULT_1Q_TAG
 * BLOCKS:   GPIC0
 * DESC:     Port N 802.1Q Default Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID('h0 and 'hfff are illegal setting).When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (polar don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM89500_A0_DEFAULT_1Q_TAGr 0x00003410

#define BCM89500_A0_DEFAULT_1Q_TAGr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG.
 *
 */
typedef union BCM89500_A0_DEFAULT_1Q_TAGr_s {
	uint32_t v[1];
	uint32_t default_1q_tag[1];
	uint32_t _default_1q_tag;
} BCM89500_A0_DEFAULT_1Q_TAGr_t;

#define BCM89500_A0_DEFAULT_1Q_TAGr_CLR(r) (r).default_1q_tag[0] = 0
#define BCM89500_A0_DEFAULT_1Q_TAGr_SET(r,d) (r).default_1q_tag[0] = d
#define BCM89500_A0_DEFAULT_1Q_TAGr_GET(r) (r).default_1q_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DEFAULT_1Q_TAGr_VIDf_GET(r) (((r).default_1q_tag[0]) & 0xfff)
#define BCM89500_A0_DEFAULT_1Q_TAGr_VIDf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_DEFAULT_1Q_TAGr_CFIf_GET(r) ((((r).default_1q_tag[0]) >> 12) & 0x1)
#define BCM89500_A0_DEFAULT_1Q_TAGr_CFIf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_DEFAULT_1Q_TAGr_PRIf_GET(r) ((((r).default_1q_tag[0]) >> 13) & 0x7)
#define BCM89500_A0_DEFAULT_1Q_TAGr_PRIf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG.
 *
 */
#define BCM89500_A0_READ_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_DEFAULT_1Q_TAGr,(r._default_1q_tag),2)
#define BCM89500_A0_WRITE_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_DEFAULT_1Q_TAGr,&(r._default_1q_tag),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAGr BCM89500_A0_DEFAULT_1Q_TAGr
#define DEFAULT_1Q_TAGr_SIZE BCM89500_A0_DEFAULT_1Q_TAGr_SIZE
typedef BCM89500_A0_DEFAULT_1Q_TAGr_t DEFAULT_1Q_TAGr_t;
#define DEFAULT_1Q_TAGr_CLR BCM89500_A0_DEFAULT_1Q_TAGr_CLR
#define DEFAULT_1Q_TAGr_SET BCM89500_A0_DEFAULT_1Q_TAGr_SET
#define DEFAULT_1Q_TAGr_GET BCM89500_A0_DEFAULT_1Q_TAGr_GET
#define DEFAULT_1Q_TAGr_VIDf_GET BCM89500_A0_DEFAULT_1Q_TAGr_VIDf_GET
#define DEFAULT_1Q_TAGr_VIDf_SET BCM89500_A0_DEFAULT_1Q_TAGr_VIDf_SET
#define DEFAULT_1Q_TAGr_CFIf_GET BCM89500_A0_DEFAULT_1Q_TAGr_CFIf_GET
#define DEFAULT_1Q_TAGr_CFIf_SET BCM89500_A0_DEFAULT_1Q_TAGr_CFIf_SET
#define DEFAULT_1Q_TAGr_PRIf_GET BCM89500_A0_DEFAULT_1Q_TAGr_PRIf_GET
#define DEFAULT_1Q_TAGr_PRIf_SET BCM89500_A0_DEFAULT_1Q_TAGr_PRIf_SET
#define READ_DEFAULT_1Q_TAGr BCM89500_A0_READ_DEFAULT_1Q_TAGr
#define WRITE_DEFAULT_1Q_TAGr BCM89500_A0_WRITE_DEFAULT_1Q_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DEFAULT_1Q_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DEFAULT_1Q_TAG_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 802.1Q Default Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID.('h0 and 'hfff are illegal setting).When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (polar don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr 0x00003420

#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG_IMP.
 *
 */
typedef union BCM89500_A0_DEFAULT_1Q_TAG_IMPr_s {
	uint32_t v[1];
	uint32_t default_1q_tag_imp[1];
	uint32_t _default_1q_tag_imp;
} BCM89500_A0_DEFAULT_1Q_TAG_IMPr_t;

#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_CLR(r) (r).default_1q_tag_imp[0] = 0
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_SET(r,d) (r).default_1q_tag_imp[0] = d
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_GET(r) (r).default_1q_tag_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_VIDf_GET(r) (((r).default_1q_tag_imp[0]) & 0xfff)
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_VIDf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_CFIf_GET(r) ((((r).default_1q_tag_imp[0]) >> 12) & 0x1)
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_CFIf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_PRIf_GET(r) ((((r).default_1q_tag_imp[0]) >> 13) & 0x7)
#define BCM89500_A0_DEFAULT_1Q_TAG_IMPr_PRIf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG_IMP.
 *
 */
#define BCM89500_A0_READ_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DEFAULT_1Q_TAG_IMPr,(r._default_1q_tag_imp),2)
#define BCM89500_A0_WRITE_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DEFAULT_1Q_TAG_IMPr,&(r._default_1q_tag_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAG_IMPr BCM89500_A0_DEFAULT_1Q_TAG_IMPr
#define DEFAULT_1Q_TAG_IMPr_SIZE BCM89500_A0_DEFAULT_1Q_TAG_IMPr_SIZE
typedef BCM89500_A0_DEFAULT_1Q_TAG_IMPr_t DEFAULT_1Q_TAG_IMPr_t;
#define DEFAULT_1Q_TAG_IMPr_CLR BCM89500_A0_DEFAULT_1Q_TAG_IMPr_CLR
#define DEFAULT_1Q_TAG_IMPr_SET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_SET
#define DEFAULT_1Q_TAG_IMPr_GET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_GET
#define DEFAULT_1Q_TAG_IMPr_VIDf_GET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_VIDf_GET
#define DEFAULT_1Q_TAG_IMPr_VIDf_SET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_VIDf_SET
#define DEFAULT_1Q_TAG_IMPr_CFIf_GET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_CFIf_GET
#define DEFAULT_1Q_TAG_IMPr_CFIf_SET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_CFIf_SET
#define DEFAULT_1Q_TAG_IMPr_PRIf_GET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_PRIf_GET
#define DEFAULT_1Q_TAG_IMPr_PRIf_SET BCM89500_A0_DEFAULT_1Q_TAG_IMPr_PRIf_SET
#define READ_DEFAULT_1Q_TAG_IMPr BCM89500_A0_READ_DEFAULT_1Q_TAG_IMPr
#define WRITE_DEFAULT_1Q_TAG_IMPr BCM89500_A0_WRITE_DEFAULT_1Q_TAG_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DEFAULT_1Q_TAG_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DEFAULT_1Q_TAG_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 802.1Q Default Tag Registers (polar feature)
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID.('h0 and 'hfff are illegal setting).When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (polar don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r 0x0000341e

#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG_P7.
 *
 */
typedef union BCM89500_A0_DEFAULT_1Q_TAG_P7r_s {
	uint32_t v[1];
	uint32_t default_1q_tag_p7[1];
	uint32_t _default_1q_tag_p7;
} BCM89500_A0_DEFAULT_1Q_TAG_P7r_t;

#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_CLR(r) (r).default_1q_tag_p7[0] = 0
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_SET(r,d) (r).default_1q_tag_p7[0] = d
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_GET(r) (r).default_1q_tag_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_VIDf_GET(r) (((r).default_1q_tag_p7[0]) & 0xfff)
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_VIDf_SET(r,f) (r).default_1q_tag_p7[0]=(((r).default_1q_tag_p7[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_CFIf_GET(r) ((((r).default_1q_tag_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_CFIf_SET(r,f) (r).default_1q_tag_p7[0]=(((r).default_1q_tag_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_PRIf_GET(r) ((((r).default_1q_tag_p7[0]) >> 13) & 0x7)
#define BCM89500_A0_DEFAULT_1Q_TAG_P7r_PRIf_SET(r,f) (r).default_1q_tag_p7[0]=(((r).default_1q_tag_p7[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG_P7.
 *
 */
#define BCM89500_A0_READ_DEFAULT_1Q_TAG_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_DEFAULT_1Q_TAG_P7r,(r._default_1q_tag_p7),2)
#define BCM89500_A0_WRITE_DEFAULT_1Q_TAG_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_DEFAULT_1Q_TAG_P7r,&(r._default_1q_tag_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAG_P7r BCM89500_A0_DEFAULT_1Q_TAG_P7r
#define DEFAULT_1Q_TAG_P7r_SIZE BCM89500_A0_DEFAULT_1Q_TAG_P7r_SIZE
typedef BCM89500_A0_DEFAULT_1Q_TAG_P7r_t DEFAULT_1Q_TAG_P7r_t;
#define DEFAULT_1Q_TAG_P7r_CLR BCM89500_A0_DEFAULT_1Q_TAG_P7r_CLR
#define DEFAULT_1Q_TAG_P7r_SET BCM89500_A0_DEFAULT_1Q_TAG_P7r_SET
#define DEFAULT_1Q_TAG_P7r_GET BCM89500_A0_DEFAULT_1Q_TAG_P7r_GET
#define DEFAULT_1Q_TAG_P7r_VIDf_GET BCM89500_A0_DEFAULT_1Q_TAG_P7r_VIDf_GET
#define DEFAULT_1Q_TAG_P7r_VIDf_SET BCM89500_A0_DEFAULT_1Q_TAG_P7r_VIDf_SET
#define DEFAULT_1Q_TAG_P7r_CFIf_GET BCM89500_A0_DEFAULT_1Q_TAG_P7r_CFIf_GET
#define DEFAULT_1Q_TAG_P7r_CFIf_SET BCM89500_A0_DEFAULT_1Q_TAG_P7r_CFIf_SET
#define DEFAULT_1Q_TAG_P7r_PRIf_GET BCM89500_A0_DEFAULT_1Q_TAG_P7r_PRIf_GET
#define DEFAULT_1Q_TAG_P7r_PRIf_SET BCM89500_A0_DEFAULT_1Q_TAG_P7r_PRIf_SET
#define READ_DEFAULT_1Q_TAG_P7r BCM89500_A0_READ_DEFAULT_1Q_TAG_P7r
#define WRITE_DEFAULT_1Q_TAG_P7r BCM89500_A0_WRITE_DEFAULT_1Q_TAG_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DEFAULT_1Q_TAG_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DF_TIMER
 * BLOCKS:   SYS
 * DESC:     Discovery Frame Timer Registers
 * SIZE:     8
 * FIELDS:
 *     DF_TIME          From 1 sec to 15 sec,4'h0: 1 sec..4'hE: 15 secscale = 1 sec
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_DF_TIMERr 0x00007202

#define BCM89500_A0_DF_TIMERr_SIZE 1

/*
 * This structure should be used to declare and program DF_TIMER.
 *
 */
typedef union BCM89500_A0_DF_TIMERr_s {
	uint32_t v[1];
	uint32_t df_timer[1];
	uint32_t _df_timer;
} BCM89500_A0_DF_TIMERr_t;

#define BCM89500_A0_DF_TIMERr_CLR(r) (r).df_timer[0] = 0
#define BCM89500_A0_DF_TIMERr_SET(r,d) (r).df_timer[0] = d
#define BCM89500_A0_DF_TIMERr_GET(r) (r).df_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DF_TIMERr_DF_TIMEf_GET(r) (((r).df_timer[0]) & 0xf)
#define BCM89500_A0_DF_TIMERr_DF_TIMEf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_DF_TIMERr_RESERVEDf_GET(r) ((((r).df_timer[0]) >> 4) & 0xf)
#define BCM89500_A0_DF_TIMERr_RESERVEDf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access DF_TIMER.
 *
 */
#define BCM89500_A0_READ_DF_TIMERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DF_TIMERr,(r._df_timer),1)
#define BCM89500_A0_WRITE_DF_TIMERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DF_TIMERr,&(r._df_timer),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DF_TIMERr BCM89500_A0_DF_TIMERr
#define DF_TIMERr_SIZE BCM89500_A0_DF_TIMERr_SIZE
typedef BCM89500_A0_DF_TIMERr_t DF_TIMERr_t;
#define DF_TIMERr_CLR BCM89500_A0_DF_TIMERr_CLR
#define DF_TIMERr_SET BCM89500_A0_DF_TIMERr_SET
#define DF_TIMERr_GET BCM89500_A0_DF_TIMERr_GET
#define DF_TIMERr_DF_TIMEf_GET BCM89500_A0_DF_TIMERr_DF_TIMEf_GET
#define DF_TIMERr_DF_TIMEf_SET BCM89500_A0_DF_TIMERr_DF_TIMEf_SET
#define DF_TIMERr_RESERVEDf_GET BCM89500_A0_DF_TIMERr_RESERVEDf_GET
#define DF_TIMERr_RESERVEDf_SET BCM89500_A0_DF_TIMERr_RESERVEDf_SET
#define READ_DF_TIMERr BCM89500_A0_READ_DF_TIMERr
#define WRITE_DF_TIMERr BCM89500_A0_WRITE_DF_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DF_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DIRECT_INPUT_CTRL_VALUE
 * BLOCKS:   SYS
 * DESC:     Direct Input Control Value Register
 * SIZE:     32
 * FIELDS:
 *     DIRECT_INPUT_CTRL_VALUE Display Direct Input Control ValueBit 1 = test enableBit 0 = osc_xtal_sel
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr 0x00000180

#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program DIRECT_INPUT_CTRL_VALUE.
 *
 */
typedef union BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_s {
	uint32_t v[1];
	uint32_t direct_input_ctrl_value[1];
	uint32_t _direct_input_ctrl_value;
} BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_t;

#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_CLR(r) (r).direct_input_ctrl_value[0] = 0
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_SET(r,d) (r).direct_input_ctrl_value[0] = d
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_GET(r) (r).direct_input_ctrl_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_DIRECT_INPUT_CTRL_VALUEf_GET(r) (((r).direct_input_ctrl_value[0]) & 0x3)
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_DIRECT_INPUT_CTRL_VALUEf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_GET(r) ((((r).direct_input_ctrl_value[0]) >> 2) & 0x3fffffff)
#define BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_SET(r,f) (r).direct_input_ctrl_value[0]=(((r).direct_input_ctrl_value[0] & ~((uint32_t)0x3fffffff << 2)) | ((((uint32_t)f) & 0x3fffffff) << 2))

/*
 * These macros can be used to access DIRECT_INPUT_CTRL_VALUE.
 *
 */
#define BCM89500_A0_READ_DIRECT_INPUT_CTRL_VALUEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr,(r._direct_input_ctrl_value),4)
#define BCM89500_A0_WRITE_DIRECT_INPUT_CTRL_VALUEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr,&(r._direct_input_ctrl_value),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIRECT_INPUT_CTRL_VALUEr BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr
#define DIRECT_INPUT_CTRL_VALUEr_SIZE BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_SIZE
typedef BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_t DIRECT_INPUT_CTRL_VALUEr_t;
#define DIRECT_INPUT_CTRL_VALUEr_CLR BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_CLR
#define DIRECT_INPUT_CTRL_VALUEr_SET BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_SET
#define DIRECT_INPUT_CTRL_VALUEr_GET BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_GET
#define DIRECT_INPUT_CTRL_VALUEr_DIRECT_INPUT_CTRL_VALUEf_GET BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_DIRECT_INPUT_CTRL_VALUEf_GET
#define DIRECT_INPUT_CTRL_VALUEr_DIRECT_INPUT_CTRL_VALUEf_SET BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_DIRECT_INPUT_CTRL_VALUEf_SET
#define DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_GET BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_GET
#define DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_SET BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr_RESERVEDf_SET
#define READ_DIRECT_INPUT_CTRL_VALUEr BCM89500_A0_READ_DIRECT_INPUT_CTRL_VALUEr
#define WRITE_DIRECT_INPUT_CTRL_VALUEr BCM89500_A0_WRITE_DIRECT_INPUT_CTRL_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DIRECT_INPUT_CTRL_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DIS_LEARN
 * BLOCKS:   SYS
 * DESC:     Disable Learning Register
 * SIZE:     16
 * FIELDS:
 *     DIS_LEARN        bit[8] : Port 8.bit[7] : Port 7.bit[5:0] : Port 5-01 : Disable learning, when disable, the hardware won't do the following items:	a. learn entries to ARL.	b. refresh entries to ARL.	c. support software learning.0 : Enable Learning.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_DIS_LEARNr 0x0000003c

#define BCM89500_A0_DIS_LEARNr_SIZE 2

/*
 * This structure should be used to declare and program DIS_LEARN.
 *
 */
typedef union BCM89500_A0_DIS_LEARNr_s {
	uint32_t v[1];
	uint32_t dis_learn[1];
	uint32_t _dis_learn;
} BCM89500_A0_DIS_LEARNr_t;

#define BCM89500_A0_DIS_LEARNr_CLR(r) (r).dis_learn[0] = 0
#define BCM89500_A0_DIS_LEARNr_SET(r,d) (r).dis_learn[0] = d
#define BCM89500_A0_DIS_LEARNr_GET(r) (r).dis_learn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DIS_LEARNr_DIS_LEARNf_GET(r) (((r).dis_learn[0]) & 0x1ff)
#define BCM89500_A0_DIS_LEARNr_DIS_LEARNf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_DIS_LEARNr_RESERVEDf_GET(r) ((((r).dis_learn[0]) >> 9) & 0x7f)
#define BCM89500_A0_DIS_LEARNr_RESERVEDf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DIS_LEARN.
 *
 */
#define BCM89500_A0_READ_DIS_LEARNr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DIS_LEARNr,(r._dis_learn),2)
#define BCM89500_A0_WRITE_DIS_LEARNr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DIS_LEARNr,&(r._dis_learn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIS_LEARNr BCM89500_A0_DIS_LEARNr
#define DIS_LEARNr_SIZE BCM89500_A0_DIS_LEARNr_SIZE
typedef BCM89500_A0_DIS_LEARNr_t DIS_LEARNr_t;
#define DIS_LEARNr_CLR BCM89500_A0_DIS_LEARNr_CLR
#define DIS_LEARNr_SET BCM89500_A0_DIS_LEARNr_SET
#define DIS_LEARNr_GET BCM89500_A0_DIS_LEARNr_GET
#define DIS_LEARNr_DIS_LEARNf_GET BCM89500_A0_DIS_LEARNr_DIS_LEARNf_GET
#define DIS_LEARNr_DIS_LEARNf_SET BCM89500_A0_DIS_LEARNr_DIS_LEARNf_SET
#define DIS_LEARNr_RESERVEDf_GET BCM89500_A0_DIS_LEARNr_RESERVEDf_GET
#define DIS_LEARNr_RESERVEDf_SET BCM89500_A0_DIS_LEARNr_RESERVEDf_SET
#define READ_DIS_LEARNr BCM89500_A0_READ_DIS_LEARNr
#define WRITE_DIS_LEARNr BCM89500_A0_WRITE_DIS_LEARNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DIS_LEARNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DOS_CTRL
 * BLOCKS:   SYS
 * DESC:     DoS Control RegisterRegister
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Reserved
 *     IP_LAND_DROP_EN  IP_LAND:IPDA=IPSA in an IP(v4/v6) datagram.1= Drop the specified packet0= Do not drop
 *     TCP_BLAT_DROP_EN TCP_BLAT:DPort=SPort in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     UDP_BLAT_DROP_EN UDP_BLAT:DPport=SPort in a UDP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_NULL_SCAN_DROP_EN TCP_NULLScan:Seq_Num=0 & All TCP_FLAGs=0, in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_XMASS_SCAN_DROP_EN TCP_XMASScan:Seq_Num=0 & FIN=1 & URG=1 & PSH=1 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SYNFIN_SCAN_DROP_EN TCP_SYNFINScan:SYN=1 & FIN=1 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SYN_ERR_DROP_EN TCP_SYNError:SYN=1 & ACK=0 & SRC_Port<1024 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SHORT_HDR_DROP_EN TCP_ShortHDR:The length of a TCP header carried in an unfragmented IP datagram or the first fragment of a fragmented IP datagram is less than MIN_TCP_Header_Size.1= Drop the specified packet0= Do not drop
 *     TCP_FRAG_ERR_DROP_EN TCP_FragError:The Fragment_Offset=1 in any fragment of a fragmented IP datagram carring part of TCP data.1= Drop the specified packet0= Do not drop
 *     ICMPV4_FRAGMENT_DROP_EN ICMPv4_Fragment:The ICMPv4 protocol data unit carrier in a fragmented IPv4 datagram.1= Drop the specified packet0= Do not drop
 *     ICMPV6_FRAGMENT_DROP_EN ICMPv6_Fragment:The ICMPv6 protocol data unit carrier in a fragmented IPv6 datagram.1= Drop the specified packet0= Do not drop
 *     ICMPV4_LONG_PING_DROP_EN ICMPv4_LongPing:The ICMPv4 Ping(Echo Request) protocol data unit carried in an unfragmented IPv4 datagram with its Payload Length indicating a value greater than the MAX_ICMPv4_Size + size of IPv4 heater.1= Drop the specified packet0= Do not drop
 *     ICMPV6_LONG_PING_DROP_EN ICMPv6_LongPing:The ICMPv6 Ping(Echo Request) protocol data unit carried in an unfragmented IPv6 datagram with its Payload Length indicating a value greater than the MAX_ICMPv6_Size.1= Drop the specified packet0= Do not drop
 *
 ******************************************************************************/
#define BCM89500_A0_DOS_CTRLr 0x00003600

#define BCM89500_A0_DOS_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CTRL.
 *
 */
typedef union BCM89500_A0_DOS_CTRLr_s {
	uint32_t v[1];
	uint32_t dos_ctrl[1];
	uint32_t _dos_ctrl;
} BCM89500_A0_DOS_CTRLr_t;

#define BCM89500_A0_DOS_CTRLr_CLR(r) (r).dos_ctrl[0] = 0
#define BCM89500_A0_DOS_CTRLr_SET(r,d) (r).dos_ctrl[0] = d
#define BCM89500_A0_DOS_CTRLr_GET(r) (r).dos_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DOS_CTRLr_RESERVEDf_GET(r) (((r).dos_ctrl[0]) & 0x1)
#define BCM89500_A0_DOS_CTRLr_RESERVEDf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 8) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 9) & 0x1)
#define BCM89500_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 10) & 0x1)
#define BCM89500_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 11) & 0x1)
#define BCM89500_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 12) & 0x1)
#define BCM89500_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 13) & 0x1)
#define BCM89500_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access DOS_CTRL.
 *
 */
#define BCM89500_A0_READ_DOS_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DOS_CTRLr,(r._dos_ctrl),4)
#define BCM89500_A0_WRITE_DOS_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DOS_CTRLr,&(r._dos_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CTRLr BCM89500_A0_DOS_CTRLr
#define DOS_CTRLr_SIZE BCM89500_A0_DOS_CTRLr_SIZE
typedef BCM89500_A0_DOS_CTRLr_t DOS_CTRLr_t;
#define DOS_CTRLr_CLR BCM89500_A0_DOS_CTRLr_CLR
#define DOS_CTRLr_SET BCM89500_A0_DOS_CTRLr_SET
#define DOS_CTRLr_GET BCM89500_A0_DOS_CTRLr_GET
#define DOS_CTRLr_RESERVEDf_GET BCM89500_A0_DOS_CTRLr_RESERVEDf_GET
#define DOS_CTRLr_RESERVEDf_SET BCM89500_A0_DOS_CTRLr_RESERVEDf_SET
#define DOS_CTRLr_IP_LAND_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET
#define DOS_CTRLr_IP_LAND_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET BCM89500_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET BCM89500_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET
#define READ_DOS_CTRLr BCM89500_A0_READ_DOS_CTRLr
#define WRITE_DOS_CTRLr BCM89500_A0_WRITE_DOS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DOS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DOS_DIS_LRN_REG
 * BLOCKS:   SYS
 * DESC:     DoS Disable Learn Register
 * SIZE:     8
 * FIELDS:
 *     DOS_DIS_LRN      When this bit is enabled, all frames drop by dos prevent module will NOT be learned.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_DOS_DIS_LRN_REGr 0x00003610

#define BCM89500_A0_DOS_DIS_LRN_REGr_SIZE 1

/*
 * This structure should be used to declare and program DOS_DIS_LRN_REG.
 *
 */
typedef union BCM89500_A0_DOS_DIS_LRN_REGr_s {
	uint32_t v[1];
	uint32_t dos_dis_lrn_reg[1];
	uint32_t _dos_dis_lrn_reg;
} BCM89500_A0_DOS_DIS_LRN_REGr_t;

#define BCM89500_A0_DOS_DIS_LRN_REGr_CLR(r) (r).dos_dis_lrn_reg[0] = 0
#define BCM89500_A0_DOS_DIS_LRN_REGr_SET(r,d) (r).dos_dis_lrn_reg[0] = d
#define BCM89500_A0_DOS_DIS_LRN_REGr_GET(r) (r).dos_dis_lrn_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET(r) (((r).dos_dis_lrn_reg[0]) & 0x1)
#define BCM89500_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_DOS_DIS_LRN_REGr_RESERVEDf_GET(r) ((((r).dos_dis_lrn_reg[0]) >> 1) & 0x7f)
#define BCM89500_A0_DOS_DIS_LRN_REGr_RESERVEDf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access DOS_DIS_LRN_REG.
 *
 */
#define BCM89500_A0_READ_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DOS_DIS_LRN_REGr,(r._dos_dis_lrn_reg),1)
#define BCM89500_A0_WRITE_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DOS_DIS_LRN_REGr,&(r._dos_dis_lrn_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_DIS_LRN_REGr BCM89500_A0_DOS_DIS_LRN_REGr
#define DOS_DIS_LRN_REGr_SIZE BCM89500_A0_DOS_DIS_LRN_REGr_SIZE
typedef BCM89500_A0_DOS_DIS_LRN_REGr_t DOS_DIS_LRN_REGr_t;
#define DOS_DIS_LRN_REGr_CLR BCM89500_A0_DOS_DIS_LRN_REGr_CLR
#define DOS_DIS_LRN_REGr_SET BCM89500_A0_DOS_DIS_LRN_REGr_SET
#define DOS_DIS_LRN_REGr_GET BCM89500_A0_DOS_DIS_LRN_REGr_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET BCM89500_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET BCM89500_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET
#define DOS_DIS_LRN_REGr_RESERVEDf_GET BCM89500_A0_DOS_DIS_LRN_REGr_RESERVEDf_GET
#define DOS_DIS_LRN_REGr_RESERVEDf_SET BCM89500_A0_DOS_DIS_LRN_REGr_RESERVEDf_SET
#define READ_DOS_DIS_LRN_REGr BCM89500_A0_READ_DOS_DIS_LRN_REGr
#define WRITE_DOS_DIS_LRN_REGr BCM89500_A0_WRITE_DOS_DIS_LRN_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DOS_DIS_LRN_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DPLL_DB_LSB
 * BLOCKS:   SYS
 * DESC:     DPLL Debug LSB Registers (Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DPLL_DB_LSB      DPLL NCO or DELTA LSB 32 bits = {DPLL_DB_MSB, DPLL_DB_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_DPLL_DB_LSBr 0x00009392

#define BCM89500_A0_DPLL_DB_LSBr_SIZE 2

/*
 * This structure should be used to declare and program DPLL_DB_LSB.
 *
 */
typedef union BCM89500_A0_DPLL_DB_LSBr_s {
	uint32_t v[1];
	uint32_t dpll_db_lsb[1];
	uint32_t _dpll_db_lsb;
} BCM89500_A0_DPLL_DB_LSBr_t;

#define BCM89500_A0_DPLL_DB_LSBr_CLR(r) (r).dpll_db_lsb[0] = 0
#define BCM89500_A0_DPLL_DB_LSBr_SET(r,d) (r).dpll_db_lsb[0] = d
#define BCM89500_A0_DPLL_DB_LSBr_GET(r) (r).dpll_db_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DPLL_DB_LSBr_DPLL_DB_LSBf_GET(r) (((r).dpll_db_lsb[0]) & 0xffff)
#define BCM89500_A0_DPLL_DB_LSBr_DPLL_DB_LSBf_SET(r,f) (r).dpll_db_lsb[0]=(((r).dpll_db_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DPLL_DB_LSB.
 *
 */
#define BCM89500_A0_READ_DPLL_DB_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DPLL_DB_LSBr,(r._dpll_db_lsb),2)
#define BCM89500_A0_WRITE_DPLL_DB_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DPLL_DB_LSBr,&(r._dpll_db_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DPLL_DB_LSBr BCM89500_A0_DPLL_DB_LSBr
#define DPLL_DB_LSBr_SIZE BCM89500_A0_DPLL_DB_LSBr_SIZE
typedef BCM89500_A0_DPLL_DB_LSBr_t DPLL_DB_LSBr_t;
#define DPLL_DB_LSBr_CLR BCM89500_A0_DPLL_DB_LSBr_CLR
#define DPLL_DB_LSBr_SET BCM89500_A0_DPLL_DB_LSBr_SET
#define DPLL_DB_LSBr_GET BCM89500_A0_DPLL_DB_LSBr_GET
#define DPLL_DB_LSBr_DPLL_DB_LSBf_GET BCM89500_A0_DPLL_DB_LSBr_DPLL_DB_LSBf_GET
#define DPLL_DB_LSBr_DPLL_DB_LSBf_SET BCM89500_A0_DPLL_DB_LSBr_DPLL_DB_LSBf_SET
#define READ_DPLL_DB_LSBr BCM89500_A0_READ_DPLL_DB_LSBr
#define WRITE_DPLL_DB_LSBr BCM89500_A0_WRITE_DPLL_DB_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DPLL_DB_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DPLL_DB_MSB
 * BLOCKS:   SYS
 * DESC:     DPLL Debug MSB Registers (Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DPLL_DB_MSB      DPLL NCO or DELTA 32 bits = {DPLL_DB_MSB, DPLL_DB_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_DPLL_DB_MSBr 0x00009394

#define BCM89500_A0_DPLL_DB_MSBr_SIZE 2

/*
 * This structure should be used to declare and program DPLL_DB_MSB.
 *
 */
typedef union BCM89500_A0_DPLL_DB_MSBr_s {
	uint32_t v[1];
	uint32_t dpll_db_msb[1];
	uint32_t _dpll_db_msb;
} BCM89500_A0_DPLL_DB_MSBr_t;

#define BCM89500_A0_DPLL_DB_MSBr_CLR(r) (r).dpll_db_msb[0] = 0
#define BCM89500_A0_DPLL_DB_MSBr_SET(r,d) (r).dpll_db_msb[0] = d
#define BCM89500_A0_DPLL_DB_MSBr_GET(r) (r).dpll_db_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DPLL_DB_MSBr_DPLL_DB_MSBf_GET(r) (((r).dpll_db_msb[0]) & 0xffff)
#define BCM89500_A0_DPLL_DB_MSBr_DPLL_DB_MSBf_SET(r,f) (r).dpll_db_msb[0]=(((r).dpll_db_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DPLL_DB_MSB.
 *
 */
#define BCM89500_A0_READ_DPLL_DB_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DPLL_DB_MSBr,(r._dpll_db_msb),2)
#define BCM89500_A0_WRITE_DPLL_DB_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DPLL_DB_MSBr,&(r._dpll_db_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DPLL_DB_MSBr BCM89500_A0_DPLL_DB_MSBr
#define DPLL_DB_MSBr_SIZE BCM89500_A0_DPLL_DB_MSBr_SIZE
typedef BCM89500_A0_DPLL_DB_MSBr_t DPLL_DB_MSBr_t;
#define DPLL_DB_MSBr_CLR BCM89500_A0_DPLL_DB_MSBr_CLR
#define DPLL_DB_MSBr_SET BCM89500_A0_DPLL_DB_MSBr_SET
#define DPLL_DB_MSBr_GET BCM89500_A0_DPLL_DB_MSBr_GET
#define DPLL_DB_MSBr_DPLL_DB_MSBf_GET BCM89500_A0_DPLL_DB_MSBr_DPLL_DB_MSBf_GET
#define DPLL_DB_MSBr_DPLL_DB_MSBf_SET BCM89500_A0_DPLL_DB_MSBr_DPLL_DB_MSBf_SET
#define READ_DPLL_DB_MSBr BCM89500_A0_READ_DPLL_DB_MSBr
#define WRITE_DPLL_DB_MSBr BCM89500_A0_WRITE_DPLL_DB_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DPLL_DB_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DPLL_DB_SEL
 * BLOCKS:   SYS
 * DESC:     DPLL Debug Select Registers (Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DPLL_DB_SEL      Select the DPLL NCO 32 bits or DELTA LSB 32 bits0 - DELTA LSB1 - NCO
 *     SPARE_REG        Reserved
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_DPLL_DB_SELr 0x00009396

#define BCM89500_A0_DPLL_DB_SELr_SIZE 2

/*
 * This structure should be used to declare and program DPLL_DB_SEL.
 *
 */
typedef union BCM89500_A0_DPLL_DB_SELr_s {
	uint32_t v[1];
	uint32_t dpll_db_sel[1];
	uint32_t _dpll_db_sel;
} BCM89500_A0_DPLL_DB_SELr_t;

#define BCM89500_A0_DPLL_DB_SELr_CLR(r) (r).dpll_db_sel[0] = 0
#define BCM89500_A0_DPLL_DB_SELr_SET(r,d) (r).dpll_db_sel[0] = d
#define BCM89500_A0_DPLL_DB_SELr_GET(r) (r).dpll_db_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DPLL_DB_SELr_DPLL_DB_SELf_GET(r) (((r).dpll_db_sel[0]) & 0x1)
#define BCM89500_A0_DPLL_DB_SELr_DPLL_DB_SELf_SET(r,f) (r).dpll_db_sel[0]=(((r).dpll_db_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_DPLL_DB_SELr_SPARE_REGf_GET(r) ((((r).dpll_db_sel[0]) >> 1) & 0x7f)
#define BCM89500_A0_DPLL_DB_SELr_SPARE_REGf_SET(r,f) (r).dpll_db_sel[0]=(((r).dpll_db_sel[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM89500_A0_DPLL_DB_SELr_RESERVEDf_GET(r) ((((r).dpll_db_sel[0]) >> 8) & 0xff)
#define BCM89500_A0_DPLL_DB_SELr_RESERVEDf_SET(r,f) (r).dpll_db_sel[0]=(((r).dpll_db_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access DPLL_DB_SEL.
 *
 */
#define BCM89500_A0_READ_DPLL_DB_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DPLL_DB_SELr,(r._dpll_db_sel),2)
#define BCM89500_A0_WRITE_DPLL_DB_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DPLL_DB_SELr,&(r._dpll_db_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DPLL_DB_SELr BCM89500_A0_DPLL_DB_SELr
#define DPLL_DB_SELr_SIZE BCM89500_A0_DPLL_DB_SELr_SIZE
typedef BCM89500_A0_DPLL_DB_SELr_t DPLL_DB_SELr_t;
#define DPLL_DB_SELr_CLR BCM89500_A0_DPLL_DB_SELr_CLR
#define DPLL_DB_SELr_SET BCM89500_A0_DPLL_DB_SELr_SET
#define DPLL_DB_SELr_GET BCM89500_A0_DPLL_DB_SELr_GET
#define DPLL_DB_SELr_DPLL_DB_SELf_GET BCM89500_A0_DPLL_DB_SELr_DPLL_DB_SELf_GET
#define DPLL_DB_SELr_DPLL_DB_SELf_SET BCM89500_A0_DPLL_DB_SELr_DPLL_DB_SELf_SET
#define DPLL_DB_SELr_SPARE_REGf_GET BCM89500_A0_DPLL_DB_SELr_SPARE_REGf_GET
#define DPLL_DB_SELr_SPARE_REGf_SET BCM89500_A0_DPLL_DB_SELr_SPARE_REGf_SET
#define DPLL_DB_SELr_RESERVEDf_GET BCM89500_A0_DPLL_DB_SELr_RESERVEDf_GET
#define DPLL_DB_SELr_RESERVEDf_SET BCM89500_A0_DPLL_DB_SELr_RESERVEDf_SET
#define READ_DPLL_DB_SELr BCM89500_A0_READ_DPLL_DB_SELr
#define WRITE_DPLL_DB_SELr BCM89500_A0_WRITE_DPLL_DB_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DPLL_DB_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DTAG_TPID
 * BLOCKS:   SYS
 * DESC:     Double Tagging TPID Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_TPID         TPID used to identify double tagged frame or not.
 *
 ******************************************************************************/
#define BCM89500_A0_DTAG_TPIDr 0x00003430

#define BCM89500_A0_DTAG_TPIDr_SIZE 2

/*
 * This structure should be used to declare and program DTAG_TPID.
 *
 */
typedef union BCM89500_A0_DTAG_TPIDr_s {
	uint32_t v[1];
	uint32_t dtag_tpid[1];
	uint32_t _dtag_tpid;
} BCM89500_A0_DTAG_TPIDr_t;

#define BCM89500_A0_DTAG_TPIDr_CLR(r) (r).dtag_tpid[0] = 0
#define BCM89500_A0_DTAG_TPIDr_SET(r,d) (r).dtag_tpid[0] = d
#define BCM89500_A0_DTAG_TPIDr_GET(r) (r).dtag_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DTAG_TPIDr_ISP_TPIDf_GET(r) (((r).dtag_tpid[0]) & 0xffff)
#define BCM89500_A0_DTAG_TPIDr_ISP_TPIDf_SET(r,f) (r).dtag_tpid[0]=(((r).dtag_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DTAG_TPID.
 *
 */
#define BCM89500_A0_READ_DTAG_TPIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DTAG_TPIDr,(r._dtag_tpid),2)
#define BCM89500_A0_WRITE_DTAG_TPIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DTAG_TPIDr,&(r._dtag_tpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DTAG_TPIDr BCM89500_A0_DTAG_TPIDr
#define DTAG_TPIDr_SIZE BCM89500_A0_DTAG_TPIDr_SIZE
typedef BCM89500_A0_DTAG_TPIDr_t DTAG_TPIDr_t;
#define DTAG_TPIDr_CLR BCM89500_A0_DTAG_TPIDr_CLR
#define DTAG_TPIDr_SET BCM89500_A0_DTAG_TPIDr_SET
#define DTAG_TPIDr_GET BCM89500_A0_DTAG_TPIDr_GET
#define DTAG_TPIDr_ISP_TPIDf_GET BCM89500_A0_DTAG_TPIDr_ISP_TPIDf_GET
#define DTAG_TPIDr_ISP_TPIDf_SET BCM89500_A0_DTAG_TPIDr_ISP_TPIDf_SET
#define READ_DTAG_TPIDr BCM89500_A0_READ_DTAG_TPIDr
#define WRITE_DTAG_TPIDr BCM89500_A0_WRITE_DTAG_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DTAG_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Duplex status Summary Register
 * SIZE:     16
 * FIELDS:
 *     DUP_STS          Duplex State.9 bit field indicating the half/full duplex state for each 10/100/1000BASE-T port.(bits 0-5 = 10/100/1000BASE-T ports, bit 7 = port 7, bit 8 = imp port).0 = Half Duplex.1 = Full Duplex.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_DUPSTSr 0x00000108

#define BCM89500_A0_DUPSTSr_SIZE 2

/*
 * This structure should be used to declare and program DUPSTS.
 *
 */
typedef union BCM89500_A0_DUPSTSr_s {
	uint32_t v[1];
	uint32_t dupsts[1];
	uint32_t _dupsts;
} BCM89500_A0_DUPSTSr_t;

#define BCM89500_A0_DUPSTSr_CLR(r) (r).dupsts[0] = 0
#define BCM89500_A0_DUPSTSr_SET(r,d) (r).dupsts[0] = d
#define BCM89500_A0_DUPSTSr_GET(r) (r).dupsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_DUPSTSr_DUP_STSf_GET(r) (((r).dupsts[0]) & 0x1ff)
#define BCM89500_A0_DUPSTSr_DUP_STSf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_DUPSTSr_RESERVEDf_GET(r) ((((r).dupsts[0]) >> 9) & 0x7f)
#define BCM89500_A0_DUPSTSr_RESERVEDf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DUPSTS.
 *
 */
#define BCM89500_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_DUPSTSr,(r._dupsts),2)
#define BCM89500_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_DUPSTSr,&(r._dupsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM89500_A0_DUPSTSr
#define DUPSTSr_SIZE BCM89500_A0_DUPSTSr_SIZE
typedef BCM89500_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM89500_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM89500_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM89500_A0_DUPSTSr_GET
#define DUPSTSr_DUP_STSf_GET BCM89500_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM89500_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVEDf_GET BCM89500_A0_DUPSTSr_RESERVEDf_GET
#define DUPSTSr_RESERVEDf_SET BCM89500_A0_DUPSTSr_RESERVEDf_SET
#define READ_DUPSTSr BCM89500_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM89500_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_DUPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EAP_DIP
 * BLOCKS:   SYS
 * DESC:     EAP Destination IP Registers
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG     EAP destination IP mask register N
 *     DIP_SUB_REG      EAP destination IP subnet register N
 *
 ******************************************************************************/
#define BCM89500_A0_EAP_DIPr 0x00004202

#define BCM89500_A0_EAP_DIPr_SIZE 8

/*
 * This structure should be used to declare and program EAP_DIP.
 *
 */
typedef union BCM89500_A0_EAP_DIPr_s {
	uint32_t v[2];
	uint32_t eap_dip[2];
	uint32_t _eap_dip;
} BCM89500_A0_EAP_DIPr_t;

#define BCM89500_A0_EAP_DIPr_CLR(r) CDK_MEMSET(&((r)._eap_dip), 0, sizeof(BCM89500_A0_EAP_DIPr_t))
#define BCM89500_A0_EAP_DIPr_SET(r,i,d) (r).eap_dip[i] = d
#define BCM89500_A0_EAP_DIPr_GET(r,i) (r).eap_dip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EAP_DIPr_DIP_MASK_REGf_GET(r) ((r).eap_dip[0])
#define BCM89500_A0_EAP_DIPr_DIP_MASK_REGf_SET(r,f) (r).eap_dip[0]=((uint32_t)f)
#define BCM89500_A0_EAP_DIPr_DIP_SUB_REGf_GET(r) ((r).eap_dip[1])
#define BCM89500_A0_EAP_DIPr_DIP_SUB_REGf_SET(r,f) (r).eap_dip[1]=((uint32_t)f)

/*
 * These macros can be used to access EAP_DIP.
 *
 */
#define BCM89500_A0_READ_EAP_DIPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_EAP_DIPr+(8*(i)),(r._eap_dip),8)
#define BCM89500_A0_WRITE_EAP_DIPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_EAP_DIPr+(8*(i)),&(r._eap_dip),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_DIPr BCM89500_A0_EAP_DIPr
#define EAP_DIPr_SIZE BCM89500_A0_EAP_DIPr_SIZE
typedef BCM89500_A0_EAP_DIPr_t EAP_DIPr_t;
#define EAP_DIPr_CLR BCM89500_A0_EAP_DIPr_CLR
#define EAP_DIPr_SET BCM89500_A0_EAP_DIPr_SET
#define EAP_DIPr_GET BCM89500_A0_EAP_DIPr_GET
#define EAP_DIPr_DIP_MASK_REGf_GET BCM89500_A0_EAP_DIPr_DIP_MASK_REGf_GET
#define EAP_DIPr_DIP_MASK_REGf_SET BCM89500_A0_EAP_DIPr_DIP_MASK_REGf_SET
#define EAP_DIPr_DIP_SUB_REGf_GET BCM89500_A0_EAP_DIPr_DIP_SUB_REGf_GET
#define EAP_DIPr_DIP_SUB_REGf_SET BCM89500_A0_EAP_DIPr_DIP_SUB_REGf_SET
#define READ_EAP_DIPr BCM89500_A0_READ_EAP_DIPr
#define WRITE_EAP_DIPr BCM89500_A0_WRITE_EAP_DIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EAP_DIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EAP_GLO_CON
 * BLOCKS:   SYS
 * DESC:     EAP Global Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *     EN_2_DIP         1'b1 : 2 subnet destination IP defined in EAP_DIP0_MASK & EAP_DIP1_MASK are allowed to pass1'b0 : drop
 *     EN_ARP           1'b1 : allow ARP to pass1'b0 : drop ARP
 *     EN_DHCP          1'b1 : allow DHCP to pass1'b0 : drop DHCP
 *     EN_RMC           When EAP_BLK_MODE is set,1'b1 : allow DA = 01-80-C2-00-00-02, 04-0F to pass1'b0 : drop DA = 01-80-C2-00-00-02, 04-0F
 *     EN_BPDU          When EAP_BLK_MODE is set,1'b1 : allow BPDU to pass1'b0 : drop BPDU
 *     EN_RARP          1'b1: allow RARP to pass1'b0: drop RARP
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EAP_GLO_CONr 0x00004200

#define BCM89500_A0_EAP_GLO_CONr_SIZE 1

/*
 * This structure should be used to declare and program EAP_GLO_CON.
 *
 */
typedef union BCM89500_A0_EAP_GLO_CONr_s {
	uint32_t v[1];
	uint32_t eap_glo_con[1];
	uint32_t _eap_glo_con;
} BCM89500_A0_EAP_GLO_CONr_t;

#define BCM89500_A0_EAP_GLO_CONr_CLR(r) (r).eap_glo_con[0] = 0
#define BCM89500_A0_EAP_GLO_CONr_SET(r,d) (r).eap_glo_con[0] = d
#define BCM89500_A0_EAP_GLO_CONr_GET(r) (r).eap_glo_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EAP_GLO_CONr_RESERVEDf_GET(r) (((r).eap_glo_con[0]) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_RESERVEDf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_EAP_GLO_CONr_EN_2_DIPf_GET(r) ((((r).eap_glo_con[0]) >> 1) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_EN_2_DIPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_EAP_GLO_CONr_EN_ARPf_GET(r) ((((r).eap_glo_con[0]) >> 2) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_EN_ARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_EAP_GLO_CONr_EN_DHCPf_GET(r) ((((r).eap_glo_con[0]) >> 3) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_EN_DHCPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_EAP_GLO_CONr_EN_RMCf_GET(r) ((((r).eap_glo_con[0]) >> 4) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_EN_RMCf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_EAP_GLO_CONr_EN_BPDUf_GET(r) ((((r).eap_glo_con[0]) >> 5) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_EN_BPDUf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_EAP_GLO_CONr_EN_RARPf_GET(r) ((((r).eap_glo_con[0]) >> 6) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_EN_RARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_EAP_GLO_CONr_RESERVED_0f_GET(r) ((((r).eap_glo_con[0]) >> 7) & 0x1)
#define BCM89500_A0_EAP_GLO_CONr_RESERVED_0f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access EAP_GLO_CON.
 *
 */
#define BCM89500_A0_READ_EAP_GLO_CONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EAP_GLO_CONr,(r._eap_glo_con),1)
#define BCM89500_A0_WRITE_EAP_GLO_CONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EAP_GLO_CONr,&(r._eap_glo_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_GLO_CONr BCM89500_A0_EAP_GLO_CONr
#define EAP_GLO_CONr_SIZE BCM89500_A0_EAP_GLO_CONr_SIZE
typedef BCM89500_A0_EAP_GLO_CONr_t EAP_GLO_CONr_t;
#define EAP_GLO_CONr_CLR BCM89500_A0_EAP_GLO_CONr_CLR
#define EAP_GLO_CONr_SET BCM89500_A0_EAP_GLO_CONr_SET
#define EAP_GLO_CONr_GET BCM89500_A0_EAP_GLO_CONr_GET
#define EAP_GLO_CONr_RESERVEDf_GET BCM89500_A0_EAP_GLO_CONr_RESERVEDf_GET
#define EAP_GLO_CONr_RESERVEDf_SET BCM89500_A0_EAP_GLO_CONr_RESERVEDf_SET
#define EAP_GLO_CONr_EN_2_DIPf_GET BCM89500_A0_EAP_GLO_CONr_EN_2_DIPf_GET
#define EAP_GLO_CONr_EN_2_DIPf_SET BCM89500_A0_EAP_GLO_CONr_EN_2_DIPf_SET
#define EAP_GLO_CONr_EN_ARPf_GET BCM89500_A0_EAP_GLO_CONr_EN_ARPf_GET
#define EAP_GLO_CONr_EN_ARPf_SET BCM89500_A0_EAP_GLO_CONr_EN_ARPf_SET
#define EAP_GLO_CONr_EN_DHCPf_GET BCM89500_A0_EAP_GLO_CONr_EN_DHCPf_GET
#define EAP_GLO_CONr_EN_DHCPf_SET BCM89500_A0_EAP_GLO_CONr_EN_DHCPf_SET
#define EAP_GLO_CONr_EN_RMCf_GET BCM89500_A0_EAP_GLO_CONr_EN_RMCf_GET
#define EAP_GLO_CONr_EN_RMCf_SET BCM89500_A0_EAP_GLO_CONr_EN_RMCf_SET
#define EAP_GLO_CONr_EN_BPDUf_GET BCM89500_A0_EAP_GLO_CONr_EN_BPDUf_GET
#define EAP_GLO_CONr_EN_BPDUf_SET BCM89500_A0_EAP_GLO_CONr_EN_BPDUf_SET
#define EAP_GLO_CONr_EN_RARPf_GET BCM89500_A0_EAP_GLO_CONr_EN_RARPf_GET
#define EAP_GLO_CONr_EN_RARPf_SET BCM89500_A0_EAP_GLO_CONr_EN_RARPf_SET
#define EAP_GLO_CONr_RESERVED_0f_GET BCM89500_A0_EAP_GLO_CONr_RESERVED_0f_GET
#define EAP_GLO_CONr_RESERVED_0f_SET BCM89500_A0_EAP_GLO_CONr_RESERVED_0f_SET
#define READ_EAP_GLO_CONr BCM89500_A0_READ_EAP_GLO_CONr
#define WRITE_EAP_GLO_CONr BCM89500_A0_WRITE_EAP_GLO_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EAP_GLO_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EAP_MULTI_ADDR_CTRL
 * BLOCKS:   SYS
 * DESC:     EAP Multiport Address Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_MPORT0        1'b1: allow multiport address define at Page/Offset=04/10h  to pass1'b0: drop
 *     EN_MPORT1        1'b1: allow multiport address define at Page/Offset=04/20h  to pass1'b0: drop
 *     EN_MPORT2        1'b1: allow multiport address define at Page/Offset=04/30h  to pass1'b0: drop
 *     EN_MPORT3        1'b1: allow multiport address define at Page/Offset=04/40h  to pass1'b0: drop
 *     EN_MPORT4        1'b1: allow multiport address define at Page/Offset=04/50h  to pass1'b0: drop
 *     EN_MPORT5        1'b1: allow multiport address define at Page/Offset=04/60h  to pass1'b0: drop
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr 0x00004201

#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program EAP_MULTI_ADDR_CTRL.
 *
 */
typedef union BCM89500_A0_EAP_MULTI_ADDR_CTRLr_s {
	uint32_t v[1];
	uint32_t eap_multi_addr_ctrl[1];
	uint32_t _eap_multi_addr_ctrl;
} BCM89500_A0_EAP_MULTI_ADDR_CTRLr_t;

#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_CLR(r) (r).eap_multi_addr_ctrl[0] = 0
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_SET(r,d) (r).eap_multi_addr_ctrl[0] = d
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_GET(r) (r).eap_multi_addr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET(r) (((r).eap_multi_addr_ctrl[0]) & 0x1)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 6) & 0x3)
#define BCM89500_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EAP_MULTI_ADDR_CTRL.
 *
 */
#define BCM89500_A0_READ_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EAP_MULTI_ADDR_CTRLr,(r._eap_multi_addr_ctrl),1)
#define BCM89500_A0_WRITE_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EAP_MULTI_ADDR_CTRLr,&(r._eap_multi_addr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_MULTI_ADDR_CTRLr BCM89500_A0_EAP_MULTI_ADDR_CTRLr
#define EAP_MULTI_ADDR_CTRLr_SIZE BCM89500_A0_EAP_MULTI_ADDR_CTRLr_SIZE
typedef BCM89500_A0_EAP_MULTI_ADDR_CTRLr_t EAP_MULTI_ADDR_CTRLr_t;
#define EAP_MULTI_ADDR_CTRLr_CLR BCM89500_A0_EAP_MULTI_ADDR_CTRLr_CLR
#define EAP_MULTI_ADDR_CTRLr_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_SET
#define EAP_MULTI_ADDR_CTRLr_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET
#define EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET
#define EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET BCM89500_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET
#define READ_EAP_MULTI_ADDR_CTRLr BCM89500_A0_READ_EAP_MULTI_ADDR_CTRLr
#define WRITE_EAP_MULTI_ADDR_CTRLr BCM89500_A0_WRITE_EAP_MULTI_ADDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EAP_MULTI_ADDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EAV_LNK_STATUS
 * BLOCKS:   SYS
 * DESC:     AVB Port AVB Link Status Register
 * SIZE:     16
 * FIELDS:
 *     PT_EAV_LNK_STATUS When software write the port AVB link status and select bit 14 in LED function.The AVB link status is shown on the LED.**Note port 5 status can be output on serial LED but not Parallel LED.bits[5:0] : for port5~port0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EAV_LNK_STATUSr 0x000090b0

#define BCM89500_A0_EAV_LNK_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program EAV_LNK_STATUS.
 *
 */
typedef union BCM89500_A0_EAV_LNK_STATUSr_s {
	uint32_t v[1];
	uint32_t eav_lnk_status[1];
	uint32_t _eav_lnk_status;
} BCM89500_A0_EAV_LNK_STATUSr_t;

#define BCM89500_A0_EAV_LNK_STATUSr_CLR(r) (r).eav_lnk_status[0] = 0
#define BCM89500_A0_EAV_LNK_STATUSr_SET(r,d) (r).eav_lnk_status[0] = d
#define BCM89500_A0_EAV_LNK_STATUSr_GET(r) (r).eav_lnk_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET(r) (((r).eav_lnk_status[0]) & 0x3f)
#define BCM89500_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_EAV_LNK_STATUSr_RESERVEDf_GET(r) ((((r).eav_lnk_status[0]) >> 6) & 0x3ff)
#define BCM89500_A0_EAV_LNK_STATUSr_RESERVEDf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access EAV_LNK_STATUS.
 *
 */
#define BCM89500_A0_READ_EAV_LNK_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EAV_LNK_STATUSr,(r._eav_lnk_status),2)
#define BCM89500_A0_WRITE_EAV_LNK_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EAV_LNK_STATUSr,&(r._eav_lnk_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAV_LNK_STATUSr BCM89500_A0_EAV_LNK_STATUSr
#define EAV_LNK_STATUSr_SIZE BCM89500_A0_EAV_LNK_STATUSr_SIZE
typedef BCM89500_A0_EAV_LNK_STATUSr_t EAV_LNK_STATUSr_t;
#define EAV_LNK_STATUSr_CLR BCM89500_A0_EAV_LNK_STATUSr_CLR
#define EAV_LNK_STATUSr_SET BCM89500_A0_EAV_LNK_STATUSr_SET
#define EAV_LNK_STATUSr_GET BCM89500_A0_EAV_LNK_STATUSr_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET BCM89500_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET BCM89500_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET
#define EAV_LNK_STATUSr_RESERVEDf_GET BCM89500_A0_EAV_LNK_STATUSr_RESERVEDf_GET
#define EAV_LNK_STATUSr_RESERVEDf_SET BCM89500_A0_EAV_LNK_STATUSr_RESERVEDf_SET
#define READ_EAV_LNK_STATUSr BCM89500_A0_READ_EAV_LNK_STATUSr
#define WRITE_EAV_LNK_STATUSr BCM89500_A0_WRITE_EAV_LNK_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EAV_LNK_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_DEBUG
 * BLOCKS:   SYS
 * DESC:     EEE Debug Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DIS_EMPTY_FLOW_CON Disable flow control checking in TXQ empty condition.0 = transmitQueueEmpty condition is included flow control checking(i.e. TXQ is not empty if "need_flow_con" = high). 1 = transmitQueueEmpty condition is not included flow control checking. 
 *     DIS_EXIT_LPI_FLOW_CON_TX Disable TX flow control checking in Low Power state checking.0 = Checking TX flow control condition when the state will be changed from EXIT_LOW_POWER state to LOW_POWER state(i.e. Exit Low Power State if "need_flow_con" = high) 1 = Disable the checking TX flow control condition when the state will be changed from EXIT_LOW_POWER state to LOW_POWER state.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_DEBUGr 0x000092e7

#define BCM89500_A0_EEE_DEBUGr_SIZE 1

/*
 * This structure should be used to declare and program EEE_DEBUG.
 *
 */
typedef union BCM89500_A0_EEE_DEBUGr_s {
	uint32_t v[1];
	uint32_t eee_debug[1];
	uint32_t _eee_debug;
} BCM89500_A0_EEE_DEBUGr_t;

#define BCM89500_A0_EEE_DEBUGr_CLR(r) (r).eee_debug[0] = 0
#define BCM89500_A0_EEE_DEBUGr_SET(r,d) (r).eee_debug[0] = d
#define BCM89500_A0_EEE_DEBUGr_GET(r) (r).eee_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_GET(r) (((r).eee_debug[0]) & 0x1)
#define BCM89500_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_SET(r,f) (r).eee_debug[0]=(((r).eee_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_EEE_DEBUGr_DIS_EXIT_LPI_FLOW_CON_TXf_GET(r) ((((r).eee_debug[0]) >> 1) & 0x1)
#define BCM89500_A0_EEE_DEBUGr_DIS_EXIT_LPI_FLOW_CON_TXf_SET(r,f) (r).eee_debug[0]=(((r).eee_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_EEE_DEBUGr_RESERVEDf_GET(r) ((((r).eee_debug[0]) >> 2) & 0x3f)
#define BCM89500_A0_EEE_DEBUGr_RESERVEDf_SET(r,f) (r).eee_debug[0]=(((r).eee_debug[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access EEE_DEBUG.
 *
 */
#define BCM89500_A0_READ_EEE_DEBUGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_DEBUGr,(r._eee_debug),1)
#define BCM89500_A0_WRITE_EEE_DEBUGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_DEBUGr,&(r._eee_debug),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_DEBUGr BCM89500_A0_EEE_DEBUGr
#define EEE_DEBUGr_SIZE BCM89500_A0_EEE_DEBUGr_SIZE
typedef BCM89500_A0_EEE_DEBUGr_t EEE_DEBUGr_t;
#define EEE_DEBUGr_CLR BCM89500_A0_EEE_DEBUGr_CLR
#define EEE_DEBUGr_SET BCM89500_A0_EEE_DEBUGr_SET
#define EEE_DEBUGr_GET BCM89500_A0_EEE_DEBUGr_GET
#define EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_GET BCM89500_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_GET
#define EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_SET BCM89500_A0_EEE_DEBUGr_DIS_EMPTY_FLOW_CONf_SET
#define EEE_DEBUGr_DIS_EXIT_LPI_FLOW_CON_TXf_GET BCM89500_A0_EEE_DEBUGr_DIS_EXIT_LPI_FLOW_CON_TXf_GET
#define EEE_DEBUGr_DIS_EXIT_LPI_FLOW_CON_TXf_SET BCM89500_A0_EEE_DEBUGr_DIS_EXIT_LPI_FLOW_CON_TXf_SET
#define EEE_DEBUGr_RESERVEDf_GET BCM89500_A0_EEE_DEBUGr_RESERVEDf_GET
#define EEE_DEBUGr_RESERVEDf_SET BCM89500_A0_EEE_DEBUGr_RESERVEDf_SET
#define READ_EEE_DEBUGr BCM89500_A0_READ_EEE_DEBUGr
#define WRITE_EEE_DEBUGr BCM89500_A0_WRITE_EEE_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     EEE Enable Control Registers
 * SIZE:     16
 * FIELDS:
 *     EN_EEE           Enable/Disable EEE9 bit field to enable/disable EEE.(bit 0-5 = port 0- port 5, bit 7 = port 7, bit 8 = IMP port)1 = Enable EEE0 = Disable EEEThe port 0 ~ port 4(internal PHY) default value read from en_eee pin on power-on. Can be overwritten subsequently.For unmanaged switch, the default value is suggested to enable EEE on power-on(i.e. en_eee_pin = 1).For managed switch, the default value is suggested to disable EEE on power-on(i.e. en_eee_pin = 0). to allow the processor to initial application and configuration, before EEE is enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_EN_CTRLr 0x00009200

#define BCM89500_A0_EEE_EN_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program EEE_EN_CTRL.
 *
 */
typedef union BCM89500_A0_EEE_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t eee_en_ctrl[1];
	uint32_t _eee_en_ctrl;
} BCM89500_A0_EEE_EN_CTRLr_t;

#define BCM89500_A0_EEE_EN_CTRLr_CLR(r) (r).eee_en_ctrl[0] = 0
#define BCM89500_A0_EEE_EN_CTRLr_SET(r,d) (r).eee_en_ctrl[0] = d
#define BCM89500_A0_EEE_EN_CTRLr_GET(r) (r).eee_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_EN_CTRLr_EN_EEEf_GET(r) (((r).eee_en_ctrl[0]) & 0x1ff)
#define BCM89500_A0_EEE_EN_CTRLr_EN_EEEf_SET(r,f) (r).eee_en_ctrl[0]=(((r).eee_en_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_EEE_EN_CTRLr_RESERVEDf_GET(r) ((((r).eee_en_ctrl[0]) >> 9) & 0x7f)
#define BCM89500_A0_EEE_EN_CTRLr_RESERVEDf_SET(r,f) (r).eee_en_ctrl[0]=(((r).eee_en_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_EN_CTRL.
 *
 */
#define BCM89500_A0_READ_EEE_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_EN_CTRLr,(r._eee_en_ctrl),2)
#define BCM89500_A0_WRITE_EEE_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_EN_CTRLr,&(r._eee_en_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_EN_CTRLr BCM89500_A0_EEE_EN_CTRLr
#define EEE_EN_CTRLr_SIZE BCM89500_A0_EEE_EN_CTRLr_SIZE
typedef BCM89500_A0_EEE_EN_CTRLr_t EEE_EN_CTRLr_t;
#define EEE_EN_CTRLr_CLR BCM89500_A0_EEE_EN_CTRLr_CLR
#define EEE_EN_CTRLr_SET BCM89500_A0_EEE_EN_CTRLr_SET
#define EEE_EN_CTRLr_GET BCM89500_A0_EEE_EN_CTRLr_GET
#define EEE_EN_CTRLr_EN_EEEf_GET BCM89500_A0_EEE_EN_CTRLr_EN_EEEf_GET
#define EEE_EN_CTRLr_EN_EEEf_SET BCM89500_A0_EEE_EN_CTRLr_EN_EEEf_SET
#define EEE_EN_CTRLr_RESERVEDf_GET BCM89500_A0_EEE_EN_CTRLr_RESERVEDf_GET
#define EEE_EN_CTRLr_RESERVEDf_SET BCM89500_A0_EEE_EN_CTRLr_RESERVEDf_SET
#define READ_EEE_EN_CTRLr BCM89500_A0_READ_EEE_EN_CTRLr
#define WRITE_EEE_EN_CTRLr BCM89500_A0_WRITE_EEE_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_GLB_CONG_TH
 * BLOCKS:   SYS
 * DESC:     EEE Global Congestion Threshold Registers
 * SIZE:     16
 * FIELDS:
 *     GLB_CONG_TH      EEE Global packet buffer congestion threshold.If this threshold is set to zero, then EEE is effectively disabled, if this threshold is set equal to or greater than 512(the number of cells implemented in the packet buffer), then protections against packet loss are disabled.The unit is "Buffer Cell Size": 256-byte cell.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_GLB_CONG_THr 0x000092c4

#define BCM89500_A0_EEE_GLB_CONG_THr_SIZE 2

/*
 * This structure should be used to declare and program EEE_GLB_CONG_TH.
 *
 */
typedef union BCM89500_A0_EEE_GLB_CONG_THr_s {
	uint32_t v[1];
	uint32_t eee_glb_cong_th[1];
	uint32_t _eee_glb_cong_th;
} BCM89500_A0_EEE_GLB_CONG_THr_t;

#define BCM89500_A0_EEE_GLB_CONG_THr_CLR(r) (r).eee_glb_cong_th[0] = 0
#define BCM89500_A0_EEE_GLB_CONG_THr_SET(r,d) (r).eee_glb_cong_th[0] = d
#define BCM89500_A0_EEE_GLB_CONG_THr_GET(r) (r).eee_glb_cong_th[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_GET(r) (((r).eee_glb_cong_th[0]) & 0x3ff)
#define BCM89500_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_SET(r,f) (r).eee_glb_cong_th[0]=(((r).eee_glb_cong_th[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_EEE_GLB_CONG_THr_RESERVEDf_GET(r) ((((r).eee_glb_cong_th[0]) >> 10) & 0x3f)
#define BCM89500_A0_EEE_GLB_CONG_THr_RESERVEDf_SET(r,f) (r).eee_glb_cong_th[0]=(((r).eee_glb_cong_th[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EEE_GLB_CONG_TH.
 *
 */
#define BCM89500_A0_READ_EEE_GLB_CONG_THr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_GLB_CONG_THr,(r._eee_glb_cong_th),2)
#define BCM89500_A0_WRITE_EEE_GLB_CONG_THr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_GLB_CONG_THr,&(r._eee_glb_cong_th),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_GLB_CONG_THr BCM89500_A0_EEE_GLB_CONG_THr
#define EEE_GLB_CONG_THr_SIZE BCM89500_A0_EEE_GLB_CONG_THr_SIZE
typedef BCM89500_A0_EEE_GLB_CONG_THr_t EEE_GLB_CONG_THr_t;
#define EEE_GLB_CONG_THr_CLR BCM89500_A0_EEE_GLB_CONG_THr_CLR
#define EEE_GLB_CONG_THr_SET BCM89500_A0_EEE_GLB_CONG_THr_SET
#define EEE_GLB_CONG_THr_GET BCM89500_A0_EEE_GLB_CONG_THr_GET
#define EEE_GLB_CONG_THr_GLB_CONG_THf_GET BCM89500_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_GET
#define EEE_GLB_CONG_THr_GLB_CONG_THf_SET BCM89500_A0_EEE_GLB_CONG_THr_GLB_CONG_THf_SET
#define EEE_GLB_CONG_THr_RESERVEDf_GET BCM89500_A0_EEE_GLB_CONG_THr_RESERVEDf_GET
#define EEE_GLB_CONG_THr_RESERVEDf_SET BCM89500_A0_EEE_GLB_CONG_THr_RESERVEDf_SET
#define READ_EEE_GLB_CONG_THr BCM89500_A0_READ_EEE_GLB_CONG_THr
#define WRITE_EEE_GLB_CONG_THr BCM89500_A0_WRITE_EEE_GLB_CONG_THr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_GLB_CONG_THr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LINK_DLY_TIMER
 * BLOCKS:   CPIC
 * DESC:     EEE Link Delay Timer Registers(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     LINK_DLY_TIMER   EEE link delay timer.When chip is reset or link status change, the link delay timer is started after port link up. When the link delay timer expires, EEE state machine is transite from INIT state to WAIT state.The unit is 1 usec.Note: The purpose of this timer is to prevent the first packet be hold in the TXQ when chip is reset or link status change. For example, the packet may be not completely received and EEE is entering low-power idle state, the packet is queued until EEE time out.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LINK_DLY_TIMERr 0x000092e8

#define BCM89500_A0_EEE_LINK_DLY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LINK_DLY_TIMER.
 *
 */
typedef union BCM89500_A0_EEE_LINK_DLY_TIMERr_s {
	uint32_t v[1];
	uint32_t eee_link_dly_timer[1];
	uint32_t _eee_link_dly_timer;
} BCM89500_A0_EEE_LINK_DLY_TIMERr_t;

#define BCM89500_A0_EEE_LINK_DLY_TIMERr_CLR(r) (r).eee_link_dly_timer[0] = 0
#define BCM89500_A0_EEE_LINK_DLY_TIMERr_SET(r,d) (r).eee_link_dly_timer[0] = d
#define BCM89500_A0_EEE_LINK_DLY_TIMERr_GET(r) (r).eee_link_dly_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_GET(r) ((r).eee_link_dly_timer[0])
#define BCM89500_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_SET(r,f) (r).eee_link_dly_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_LINK_DLY_TIMER.
 *
 */
#define BCM89500_A0_READ_EEE_LINK_DLY_TIMERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LINK_DLY_TIMERr,(r._eee_link_dly_timer),4)
#define BCM89500_A0_WRITE_EEE_LINK_DLY_TIMERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LINK_DLY_TIMERr,&(r._eee_link_dly_timer),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LINK_DLY_TIMERr BCM89500_A0_EEE_LINK_DLY_TIMERr
#define EEE_LINK_DLY_TIMERr_SIZE BCM89500_A0_EEE_LINK_DLY_TIMERr_SIZE
typedef BCM89500_A0_EEE_LINK_DLY_TIMERr_t EEE_LINK_DLY_TIMERr_t;
#define EEE_LINK_DLY_TIMERr_CLR BCM89500_A0_EEE_LINK_DLY_TIMERr_CLR
#define EEE_LINK_DLY_TIMERr_SET BCM89500_A0_EEE_LINK_DLY_TIMERr_SET
#define EEE_LINK_DLY_TIMERr_GET BCM89500_A0_EEE_LINK_DLY_TIMERr_GET
#define EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_GET BCM89500_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_GET
#define EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_SET BCM89500_A0_EEE_LINK_DLY_TIMERr_LINK_DLY_TIMERf_SET
#define READ_EEE_LINK_DLY_TIMERr BCM89500_A0_READ_EEE_LINK_DLY_TIMERr
#define WRITE_EEE_LINK_DLY_TIMERr BCM89500_A0_WRITE_EEE_LINK_DLY_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LINK_DLY_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_ASSERT
 * BLOCKS:   SYS
 * DESC:     EEE Low Power Assert Status Registers
 * SIZE:     16
 * FIELDS:
 *     LPI_ASSERT       Low Power Assert input signal status.9 bit indicating that a lowPowerAssert input signal that commands the transmit MAC to generate low-power idle symbols to the PHY once the transmit MAC is done transmitting any in-process packet.(bit 0-5 = port 0- port 5, bit 7 = port 7, bit 8 = IMP port)1 = asserted0 = deasserted
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_ASSERTr 0x00009202

#define BCM89500_A0_EEE_LPI_ASSERTr_SIZE 2

/*
 * This structure should be used to declare and program EEE_LPI_ASSERT.
 *
 */
typedef union BCM89500_A0_EEE_LPI_ASSERTr_s {
	uint32_t v[1];
	uint32_t eee_lpi_assert[1];
	uint32_t _eee_lpi_assert;
} BCM89500_A0_EEE_LPI_ASSERTr_t;

#define BCM89500_A0_EEE_LPI_ASSERTr_CLR(r) (r).eee_lpi_assert[0] = 0
#define BCM89500_A0_EEE_LPI_ASSERTr_SET(r,d) (r).eee_lpi_assert[0] = d
#define BCM89500_A0_EEE_LPI_ASSERTr_GET(r) (r).eee_lpi_assert[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_GET(r) (((r).eee_lpi_assert[0]) & 0x1ff)
#define BCM89500_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_SET(r,f) (r).eee_lpi_assert[0]=(((r).eee_lpi_assert[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_EEE_LPI_ASSERTr_RESERVEDf_GET(r) ((((r).eee_lpi_assert[0]) >> 9) & 0x7f)
#define BCM89500_A0_EEE_LPI_ASSERTr_RESERVEDf_SET(r,f) (r).eee_lpi_assert[0]=(((r).eee_lpi_assert[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_LPI_ASSERT.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_ASSERTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_ASSERTr,(r._eee_lpi_assert),2)
#define BCM89500_A0_WRITE_EEE_LPI_ASSERTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_ASSERTr,&(r._eee_lpi_assert),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_ASSERTr BCM89500_A0_EEE_LPI_ASSERTr
#define EEE_LPI_ASSERTr_SIZE BCM89500_A0_EEE_LPI_ASSERTr_SIZE
typedef BCM89500_A0_EEE_LPI_ASSERTr_t EEE_LPI_ASSERTr_t;
#define EEE_LPI_ASSERTr_CLR BCM89500_A0_EEE_LPI_ASSERTr_CLR
#define EEE_LPI_ASSERTr_SET BCM89500_A0_EEE_LPI_ASSERTr_SET
#define EEE_LPI_ASSERTr_GET BCM89500_A0_EEE_LPI_ASSERTr_GET
#define EEE_LPI_ASSERTr_LPI_ASSERTf_GET BCM89500_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_GET
#define EEE_LPI_ASSERTr_LPI_ASSERTf_SET BCM89500_A0_EEE_LPI_ASSERTr_LPI_ASSERTf_SET
#define EEE_LPI_ASSERTr_RESERVEDf_GET BCM89500_A0_EEE_LPI_ASSERTr_RESERVEDf_GET
#define EEE_LPI_ASSERTr_RESERVEDf_SET BCM89500_A0_EEE_LPI_ASSERTr_RESERVEDf_SET
#define READ_EEE_LPI_ASSERTr BCM89500_A0_READ_EEE_LPI_ASSERTr
#define WRITE_EEE_LPI_ASSERTr BCM89500_A0_WRITE_EEE_LPI_ASSERTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_ASSERTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_DURATION
 * BLOCKS:   GPIC0 CPIC
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_DURATIONr 0x000020bc

#define BCM89500_A0_EEE_LPI_DURATIONr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_DURATION.
 *
 */
typedef union BCM89500_A0_EEE_LPI_DURATIONr_s {
	uint32_t v[1];
	uint32_t eee_lpi_duration[1];
	uint32_t _eee_lpi_duration;
} BCM89500_A0_EEE_LPI_DURATIONr_t;

#define BCM89500_A0_EEE_LPI_DURATIONr_CLR(r) (r).eee_lpi_duration[0] = 0
#define BCM89500_A0_EEE_LPI_DURATIONr_SET(r,d) (r).eee_lpi_duration[0] = d
#define BCM89500_A0_EEE_LPI_DURATIONr_GET(r) (r).eee_lpi_duration[0]


/*
 * These macros can be used to access EEE_LPI_DURATION.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_DURATIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_LPI_DURATIONr,(r._eee_lpi_duration),4)
#define BCM89500_A0_WRITE_EEE_LPI_DURATIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_LPI_DURATIONr,&(r._eee_lpi_duration),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_DURATIONr BCM89500_A0_EEE_LPI_DURATIONr
#define EEE_LPI_DURATIONr_SIZE BCM89500_A0_EEE_LPI_DURATIONr_SIZE
typedef BCM89500_A0_EEE_LPI_DURATIONr_t EEE_LPI_DURATIONr_t;
#define EEE_LPI_DURATIONr_CLR BCM89500_A0_EEE_LPI_DURATIONr_CLR
#define EEE_LPI_DURATIONr_SET BCM89500_A0_EEE_LPI_DURATIONr_SET
#define EEE_LPI_DURATIONr_GET BCM89500_A0_EEE_LPI_DURATIONr_GET
#define READ_EEE_LPI_DURATIONr BCM89500_A0_READ_EEE_LPI_DURATIONr
#define WRITE_EEE_LPI_DURATIONr BCM89500_A0_WRITE_EEE_LPI_DURATIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_DURATIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_DURATION_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_DURATION_IMPr 0x000028bc

#define BCM89500_A0_EEE_LPI_DURATION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_DURATION_IMP.
 *
 */
typedef union BCM89500_A0_EEE_LPI_DURATION_IMPr_s {
	uint32_t v[1];
	uint32_t eee_lpi_duration_imp[1];
	uint32_t _eee_lpi_duration_imp;
} BCM89500_A0_EEE_LPI_DURATION_IMPr_t;

#define BCM89500_A0_EEE_LPI_DURATION_IMPr_CLR(r) (r).eee_lpi_duration_imp[0] = 0
#define BCM89500_A0_EEE_LPI_DURATION_IMPr_SET(r,d) (r).eee_lpi_duration_imp[0] = d
#define BCM89500_A0_EEE_LPI_DURATION_IMPr_GET(r) (r).eee_lpi_duration_imp[0]


/*
 * These macros can be used to access EEE_LPI_DURATION_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_DURATION_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_DURATION_IMPr,(r._eee_lpi_duration_imp),4)
#define BCM89500_A0_WRITE_EEE_LPI_DURATION_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_DURATION_IMPr,&(r._eee_lpi_duration_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_DURATION_IMPr BCM89500_A0_EEE_LPI_DURATION_IMPr
#define EEE_LPI_DURATION_IMPr_SIZE BCM89500_A0_EEE_LPI_DURATION_IMPr_SIZE
typedef BCM89500_A0_EEE_LPI_DURATION_IMPr_t EEE_LPI_DURATION_IMPr_t;
#define EEE_LPI_DURATION_IMPr_CLR BCM89500_A0_EEE_LPI_DURATION_IMPr_CLR
#define EEE_LPI_DURATION_IMPr_SET BCM89500_A0_EEE_LPI_DURATION_IMPr_SET
#define EEE_LPI_DURATION_IMPr_GET BCM89500_A0_EEE_LPI_DURATION_IMPr_GET
#define READ_EEE_LPI_DURATION_IMPr BCM89500_A0_READ_EEE_LPI_DURATION_IMPr
#define WRITE_EEE_LPI_DURATION_IMPr BCM89500_A0_WRITE_EEE_LPI_DURATION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_DURATION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_DURATION_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_DURATION_P7r 0x000027bc

#define BCM89500_A0_EEE_LPI_DURATION_P7r_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_DURATION_P7.
 *
 */
typedef union BCM89500_A0_EEE_LPI_DURATION_P7r_s {
	uint32_t v[1];
	uint32_t eee_lpi_duration_p7[1];
	uint32_t _eee_lpi_duration_p7;
} BCM89500_A0_EEE_LPI_DURATION_P7r_t;

#define BCM89500_A0_EEE_LPI_DURATION_P7r_CLR(r) (r).eee_lpi_duration_p7[0] = 0
#define BCM89500_A0_EEE_LPI_DURATION_P7r_SET(r,d) (r).eee_lpi_duration_p7[0] = d
#define BCM89500_A0_EEE_LPI_DURATION_P7r_GET(r) (r).eee_lpi_duration_p7[0]


/*
 * These macros can be used to access EEE_LPI_DURATION_P7.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_DURATION_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_DURATION_P7r,(r._eee_lpi_duration_p7),4)
#define BCM89500_A0_WRITE_EEE_LPI_DURATION_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_DURATION_P7r,&(r._eee_lpi_duration_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_DURATION_P7r BCM89500_A0_EEE_LPI_DURATION_P7r
#define EEE_LPI_DURATION_P7r_SIZE BCM89500_A0_EEE_LPI_DURATION_P7r_SIZE
typedef BCM89500_A0_EEE_LPI_DURATION_P7r_t EEE_LPI_DURATION_P7r_t;
#define EEE_LPI_DURATION_P7r_CLR BCM89500_A0_EEE_LPI_DURATION_P7r_CLR
#define EEE_LPI_DURATION_P7r_SET BCM89500_A0_EEE_LPI_DURATION_P7r_SET
#define EEE_LPI_DURATION_P7r_GET BCM89500_A0_EEE_LPI_DURATION_P7r_GET
#define READ_EEE_LPI_DURATION_P7r BCM89500_A0_READ_EEE_LPI_DURATION_P7r
#define WRITE_EEE_LPI_DURATION_P7r BCM89500_A0_WRITE_EEE_LPI_DURATION_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_DURATION_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_EVENT
 * BLOCKS:   GPIC0 CPIC
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_EVENTr 0x000020b8

#define BCM89500_A0_EEE_LPI_EVENTr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_EVENT.
 *
 */
typedef union BCM89500_A0_EEE_LPI_EVENTr_s {
	uint32_t v[1];
	uint32_t eee_lpi_event[1];
	uint32_t _eee_lpi_event;
} BCM89500_A0_EEE_LPI_EVENTr_t;

#define BCM89500_A0_EEE_LPI_EVENTr_CLR(r) (r).eee_lpi_event[0] = 0
#define BCM89500_A0_EEE_LPI_EVENTr_SET(r,d) (r).eee_lpi_event[0] = d
#define BCM89500_A0_EEE_LPI_EVENTr_GET(r) (r).eee_lpi_event[0]


/*
 * These macros can be used to access EEE_LPI_EVENT.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_EVENTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_LPI_EVENTr,(r._eee_lpi_event),4)
#define BCM89500_A0_WRITE_EEE_LPI_EVENTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_LPI_EVENTr,&(r._eee_lpi_event),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_EVENTr BCM89500_A0_EEE_LPI_EVENTr
#define EEE_LPI_EVENTr_SIZE BCM89500_A0_EEE_LPI_EVENTr_SIZE
typedef BCM89500_A0_EEE_LPI_EVENTr_t EEE_LPI_EVENTr_t;
#define EEE_LPI_EVENTr_CLR BCM89500_A0_EEE_LPI_EVENTr_CLR
#define EEE_LPI_EVENTr_SET BCM89500_A0_EEE_LPI_EVENTr_SET
#define EEE_LPI_EVENTr_GET BCM89500_A0_EEE_LPI_EVENTr_GET
#define READ_EEE_LPI_EVENTr BCM89500_A0_READ_EEE_LPI_EVENTr
#define WRITE_EEE_LPI_EVENTr BCM89500_A0_WRITE_EEE_LPI_EVENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_EVENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_EVENT_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_EVENT_IMPr 0x000028b8

#define BCM89500_A0_EEE_LPI_EVENT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_EVENT_IMP.
 *
 */
typedef union BCM89500_A0_EEE_LPI_EVENT_IMPr_s {
	uint32_t v[1];
	uint32_t eee_lpi_event_imp[1];
	uint32_t _eee_lpi_event_imp;
} BCM89500_A0_EEE_LPI_EVENT_IMPr_t;

#define BCM89500_A0_EEE_LPI_EVENT_IMPr_CLR(r) (r).eee_lpi_event_imp[0] = 0
#define BCM89500_A0_EEE_LPI_EVENT_IMPr_SET(r,d) (r).eee_lpi_event_imp[0] = d
#define BCM89500_A0_EEE_LPI_EVENT_IMPr_GET(r) (r).eee_lpi_event_imp[0]


/*
 * These macros can be used to access EEE_LPI_EVENT_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_EVENT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_EVENT_IMPr,(r._eee_lpi_event_imp),4)
#define BCM89500_A0_WRITE_EEE_LPI_EVENT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_EVENT_IMPr,&(r._eee_lpi_event_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_EVENT_IMPr BCM89500_A0_EEE_LPI_EVENT_IMPr
#define EEE_LPI_EVENT_IMPr_SIZE BCM89500_A0_EEE_LPI_EVENT_IMPr_SIZE
typedef BCM89500_A0_EEE_LPI_EVENT_IMPr_t EEE_LPI_EVENT_IMPr_t;
#define EEE_LPI_EVENT_IMPr_CLR BCM89500_A0_EEE_LPI_EVENT_IMPr_CLR
#define EEE_LPI_EVENT_IMPr_SET BCM89500_A0_EEE_LPI_EVENT_IMPr_SET
#define EEE_LPI_EVENT_IMPr_GET BCM89500_A0_EEE_LPI_EVENT_IMPr_GET
#define READ_EEE_LPI_EVENT_IMPr BCM89500_A0_READ_EEE_LPI_EVENT_IMPr
#define WRITE_EEE_LPI_EVENT_IMPr BCM89500_A0_WRITE_EEE_LPI_EVENT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_EVENT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_EVENT_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_EVENT_P7r 0x000027b8

#define BCM89500_A0_EEE_LPI_EVENT_P7r_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPI_EVENT_P7.
 *
 */
typedef union BCM89500_A0_EEE_LPI_EVENT_P7r_s {
	uint32_t v[1];
	uint32_t eee_lpi_event_p7[1];
	uint32_t _eee_lpi_event_p7;
} BCM89500_A0_EEE_LPI_EVENT_P7r_t;

#define BCM89500_A0_EEE_LPI_EVENT_P7r_CLR(r) (r).eee_lpi_event_p7[0] = 0
#define BCM89500_A0_EEE_LPI_EVENT_P7r_SET(r,d) (r).eee_lpi_event_p7[0] = d
#define BCM89500_A0_EEE_LPI_EVENT_P7r_GET(r) (r).eee_lpi_event_p7[0]


/*
 * These macros can be used to access EEE_LPI_EVENT_P7.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_EVENT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_EVENT_P7r,(r._eee_lpi_event_p7),4)
#define BCM89500_A0_WRITE_EEE_LPI_EVENT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_EVENT_P7r,&(r._eee_lpi_event_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_EVENT_P7r BCM89500_A0_EEE_LPI_EVENT_P7r
#define EEE_LPI_EVENT_P7r_SIZE BCM89500_A0_EEE_LPI_EVENT_P7r_SIZE
typedef BCM89500_A0_EEE_LPI_EVENT_P7r_t EEE_LPI_EVENT_P7r_t;
#define EEE_LPI_EVENT_P7r_CLR BCM89500_A0_EEE_LPI_EVENT_P7r_CLR
#define EEE_LPI_EVENT_P7r_SET BCM89500_A0_EEE_LPI_EVENT_P7r_SET
#define EEE_LPI_EVENT_P7r_GET BCM89500_A0_EEE_LPI_EVENT_P7r_GET
#define READ_EEE_LPI_EVENT_P7r BCM89500_A0_READ_EEE_LPI_EVENT_P7r
#define WRITE_EEE_LPI_EVENT_P7r BCM89500_A0_WRITE_EEE_LPI_EVENT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_EVENT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_INDICATE
 * BLOCKS:   SYS
 * DESC:     EEE Low Power Indicate Status Registers
 * SIZE:     16
 * FIELDS:
 *     LPI_INDICATE     lowPowerIndicate output signal status.9 bit indicating that a lowPowerIndicate output that is asserted whenever the receive PHY is sending low-power idle symbols to the receive MAC.(bit 0-5 = port 0- port 5, bit 7 = port 7, bit 8 = IMP port)1 = asserted0 = deasserted
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_INDICATEr 0x00009204

#define BCM89500_A0_EEE_LPI_INDICATEr_SIZE 2

/*
 * This structure should be used to declare and program EEE_LPI_INDICATE.
 *
 */
typedef union BCM89500_A0_EEE_LPI_INDICATEr_s {
	uint32_t v[1];
	uint32_t eee_lpi_indicate[1];
	uint32_t _eee_lpi_indicate;
} BCM89500_A0_EEE_LPI_INDICATEr_t;

#define BCM89500_A0_EEE_LPI_INDICATEr_CLR(r) (r).eee_lpi_indicate[0] = 0
#define BCM89500_A0_EEE_LPI_INDICATEr_SET(r,d) (r).eee_lpi_indicate[0] = d
#define BCM89500_A0_EEE_LPI_INDICATEr_GET(r) (r).eee_lpi_indicate[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_GET(r) (((r).eee_lpi_indicate[0]) & 0x1ff)
#define BCM89500_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_SET(r,f) (r).eee_lpi_indicate[0]=(((r).eee_lpi_indicate[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_EEE_LPI_INDICATEr_RESERVEDf_GET(r) ((((r).eee_lpi_indicate[0]) >> 9) & 0x7f)
#define BCM89500_A0_EEE_LPI_INDICATEr_RESERVEDf_SET(r,f) (r).eee_lpi_indicate[0]=(((r).eee_lpi_indicate[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_LPI_INDICATE.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_INDICATEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_INDICATEr,(r._eee_lpi_indicate),2)
#define BCM89500_A0_WRITE_EEE_LPI_INDICATEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_INDICATEr,&(r._eee_lpi_indicate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_INDICATEr BCM89500_A0_EEE_LPI_INDICATEr
#define EEE_LPI_INDICATEr_SIZE BCM89500_A0_EEE_LPI_INDICATEr_SIZE
typedef BCM89500_A0_EEE_LPI_INDICATEr_t EEE_LPI_INDICATEr_t;
#define EEE_LPI_INDICATEr_CLR BCM89500_A0_EEE_LPI_INDICATEr_CLR
#define EEE_LPI_INDICATEr_SET BCM89500_A0_EEE_LPI_INDICATEr_SET
#define EEE_LPI_INDICATEr_GET BCM89500_A0_EEE_LPI_INDICATEr_GET
#define EEE_LPI_INDICATEr_LPI_INDICATEf_GET BCM89500_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_GET
#define EEE_LPI_INDICATEr_LPI_INDICATEf_SET BCM89500_A0_EEE_LPI_INDICATEr_LPI_INDICATEf_SET
#define EEE_LPI_INDICATEr_RESERVEDf_GET BCM89500_A0_EEE_LPI_INDICATEr_RESERVEDf_GET
#define EEE_LPI_INDICATEr_RESERVEDf_SET BCM89500_A0_EEE_LPI_INDICATEr_RESERVEDf_SET
#define READ_EEE_LPI_INDICATEr BCM89500_A0_READ_EEE_LPI_INDICATEr
#define WRITE_EEE_LPI_INDICATEr BCM89500_A0_WRITE_EEE_LPI_INDICATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_INDICATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_LPI_SYMBOL_TX_DISABLE
 * BLOCKS:   SYS
 * DESC:     EEE LPI Symbol Transmit Disable Registers(Not2Release)(polar feature)
 * SIZE:     16
 * FIELDS:
 *     EEE_LPI_SYMBOL_TX_DISABLE LPI Symbol Transmit Disable9 bit field to disable per-port MAC to send LPI symbol to PHY when entering LPI state in EEE mode. (bits 0-5 = port 0 - port 5, bit 7 = port7, bit 8 = IMP port.)0 = Enable the MAC to send LPI symbol to PHY. (default)1 = Disable the MAC to send LPI symbol to PHY.Note: The register can be used in the IPM to mask possible LPI symbol to a non-EEE link partner to prevent interoperability issue
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr 0x00009208

#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_SIZE 2

/*
 * This structure should be used to declare and program EEE_LPI_SYMBOL_TX_DISABLE.
 *
 */
typedef union BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_s {
	uint32_t v[1];
	uint32_t eee_lpi_symbol_tx_disable[1];
	uint32_t _eee_lpi_symbol_tx_disable;
} BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_t;

#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_CLR(r) (r).eee_lpi_symbol_tx_disable[0] = 0
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_SET(r,d) (r).eee_lpi_symbol_tx_disable[0] = d
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_GET(r) (r).eee_lpi_symbol_tx_disable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_EEE_LPI_SYMBOL_TX_DISABLEf_GET(r) (((r).eee_lpi_symbol_tx_disable[0]) & 0x1ff)
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_EEE_LPI_SYMBOL_TX_DISABLEf_SET(r,f) (r).eee_lpi_symbol_tx_disable[0]=(((r).eee_lpi_symbol_tx_disable[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_RESERVEDf_GET(r) ((((r).eee_lpi_symbol_tx_disable[0]) >> 9) & 0x7f)
#define BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_RESERVEDf_SET(r,f) (r).eee_lpi_symbol_tx_disable[0]=(((r).eee_lpi_symbol_tx_disable[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_LPI_SYMBOL_TX_DISABLE.
 *
 */
#define BCM89500_A0_READ_EEE_LPI_SYMBOL_TX_DISABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr,(r._eee_lpi_symbol_tx_disable),2)
#define BCM89500_A0_WRITE_EEE_LPI_SYMBOL_TX_DISABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr,&(r._eee_lpi_symbol_tx_disable),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPI_SYMBOL_TX_DISABLEr BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr
#define EEE_LPI_SYMBOL_TX_DISABLEr_SIZE BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_SIZE
typedef BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_t EEE_LPI_SYMBOL_TX_DISABLEr_t;
#define EEE_LPI_SYMBOL_TX_DISABLEr_CLR BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_CLR
#define EEE_LPI_SYMBOL_TX_DISABLEr_SET BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_SET
#define EEE_LPI_SYMBOL_TX_DISABLEr_GET BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_GET
#define EEE_LPI_SYMBOL_TX_DISABLEr_EEE_LPI_SYMBOL_TX_DISABLEf_GET BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_EEE_LPI_SYMBOL_TX_DISABLEf_GET
#define EEE_LPI_SYMBOL_TX_DISABLEr_EEE_LPI_SYMBOL_TX_DISABLEf_SET BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_EEE_LPI_SYMBOL_TX_DISABLEf_SET
#define EEE_LPI_SYMBOL_TX_DISABLEr_RESERVEDf_GET BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_RESERVEDf_GET
#define EEE_LPI_SYMBOL_TX_DISABLEr_RESERVEDf_SET BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr_RESERVEDf_SET
#define READ_EEE_LPI_SYMBOL_TX_DISABLEr BCM89500_A0_READ_EEE_LPI_SYMBOL_TX_DISABLEr
#define WRITE_EEE_LPI_SYMBOL_TX_DISABLEr BCM89500_A0_WRITE_EEE_LPI_SYMBOL_TX_DISABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_LPI_SYMBOL_TX_DISABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_MIN_LP_TIMER_G
 * BLOCKS:   GPIC0
 * DESC:     EEE Port Minimum Low-Power Duration Timer - 1G Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_G   EEE minimum low-power duration delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr 0x00009258

#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_G.
 *
 */
typedef union BCM89500_A0_EEE_MIN_LP_TIMER_Gr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_g[1];
	uint32_t _eee_min_lp_timer_g;
} BCM89500_A0_EEE_MIN_LP_TIMER_Gr_t;

#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr_CLR(r) (r).eee_min_lp_timer_g[0] = 0
#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr_SET(r,d) (r).eee_min_lp_timer_g[0] = d
#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr_GET(r) (r).eee_min_lp_timer_g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_GET(r) ((r).eee_min_lp_timer_g[0])
#define BCM89500_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_SET(r,f) (r).eee_min_lp_timer_g[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_G.
 *
 */
#define BCM89500_A0_READ_EEE_MIN_LP_TIMER_Gr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_MIN_LP_TIMER_Gr,(r._eee_min_lp_timer_g),4)
#define BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_Gr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_MIN_LP_TIMER_Gr,&(r._eee_min_lp_timer_g),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_Gr BCM89500_A0_EEE_MIN_LP_TIMER_Gr
#define EEE_MIN_LP_TIMER_Gr_SIZE BCM89500_A0_EEE_MIN_LP_TIMER_Gr_SIZE
typedef BCM89500_A0_EEE_MIN_LP_TIMER_Gr_t EEE_MIN_LP_TIMER_Gr_t;
#define EEE_MIN_LP_TIMER_Gr_CLR BCM89500_A0_EEE_MIN_LP_TIMER_Gr_CLR
#define EEE_MIN_LP_TIMER_Gr_SET BCM89500_A0_EEE_MIN_LP_TIMER_Gr_SET
#define EEE_MIN_LP_TIMER_Gr_GET BCM89500_A0_EEE_MIN_LP_TIMER_Gr_GET
#define EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_GET BCM89500_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_GET
#define EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_SET BCM89500_A0_EEE_MIN_LP_TIMER_Gr_MIN_LP_TIMER_Gf_SET
#define READ_EEE_MIN_LP_TIMER_Gr BCM89500_A0_READ_EEE_MIN_LP_TIMER_Gr
#define WRITE_EEE_MIN_LP_TIMER_Gr BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_Gr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_MIN_LP_TIMER_Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_MIN_LP_TIMER_G_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Minimum Low-Power Duration Timer Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_G_IMP EEE minimum low-power duration delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr 0x00009278

#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_G_IMP.
 *
 */
typedef union BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_g_imp[1];
	uint32_t _eee_min_lp_timer_g_imp;
} BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_t;

#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_CLR(r) (r).eee_min_lp_timer_g_imp[0] = 0
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_SET(r,d) (r).eee_min_lp_timer_g_imp[0] = d
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_GET(r) (r).eee_min_lp_timer_g_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_GET(r) ((r).eee_min_lp_timer_g_imp[0])
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_SET(r,f) (r).eee_min_lp_timer_g_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_G_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_MIN_LP_TIMER_G_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr,(r._eee_min_lp_timer_g_imp),4)
#define BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_G_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr,&(r._eee_min_lp_timer_g_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_G_IMPr BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr
#define EEE_MIN_LP_TIMER_G_IMPr_SIZE BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_SIZE
typedef BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_t EEE_MIN_LP_TIMER_G_IMPr_t;
#define EEE_MIN_LP_TIMER_G_IMPr_CLR BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_CLR
#define EEE_MIN_LP_TIMER_G_IMPr_SET BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_SET
#define EEE_MIN_LP_TIMER_G_IMPr_GET BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_GET
#define EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_GET BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_GET
#define EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_SET BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr_MIN_LP_TIMER_G_IMPf_SET
#define READ_EEE_MIN_LP_TIMER_G_IMPr BCM89500_A0_READ_EEE_MIN_LP_TIMER_G_IMPr
#define WRITE_EEE_MIN_LP_TIMER_G_IMPr BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_G_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_MIN_LP_TIMER_G_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_MIN_LP_TIMER_G_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Port 7 Minimum Low-Power Duration Timer Registers (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_G   EEE minimum low-power duration delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r 0x00009274

#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_G_P7.
 *
 */
typedef union BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_g_p7[1];
	uint32_t _eee_min_lp_timer_g_p7;
} BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_t;

#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_CLR(r) (r).eee_min_lp_timer_g_p7[0] = 0
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_SET(r,d) (r).eee_min_lp_timer_g_p7[0] = d
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_GET(r) (r).eee_min_lp_timer_g_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_MIN_LP_TIMER_Gf_GET(r) ((r).eee_min_lp_timer_g_p7[0])
#define BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_MIN_LP_TIMER_Gf_SET(r,f) (r).eee_min_lp_timer_g_p7[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_G_P7.
 *
 */
#define BCM89500_A0_READ_EEE_MIN_LP_TIMER_G_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r,(r._eee_min_lp_timer_g_p7),4)
#define BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_G_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r,&(r._eee_min_lp_timer_g_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_G_P7r BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r
#define EEE_MIN_LP_TIMER_G_P7r_SIZE BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_SIZE
typedef BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_t EEE_MIN_LP_TIMER_G_P7r_t;
#define EEE_MIN_LP_TIMER_G_P7r_CLR BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_CLR
#define EEE_MIN_LP_TIMER_G_P7r_SET BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_SET
#define EEE_MIN_LP_TIMER_G_P7r_GET BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_GET
#define EEE_MIN_LP_TIMER_G_P7r_MIN_LP_TIMER_Gf_GET BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_MIN_LP_TIMER_Gf_GET
#define EEE_MIN_LP_TIMER_G_P7r_MIN_LP_TIMER_Gf_SET BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r_MIN_LP_TIMER_Gf_SET
#define READ_EEE_MIN_LP_TIMER_G_P7r BCM89500_A0_READ_EEE_MIN_LP_TIMER_G_P7r
#define WRITE_EEE_MIN_LP_TIMER_G_P7r BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_G_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_MIN_LP_TIMER_G_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_MIN_LP_TIMER_H
 * BLOCKS:   GPIC0
 * DESC:     EEE Port Minimum Low-Power Duration Timer - 100M Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_H   EEE minimum low-power duration delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr 0x0000927c

#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_H.
 *
 */
typedef union BCM89500_A0_EEE_MIN_LP_TIMER_Hr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_h[1];
	uint32_t _eee_min_lp_timer_h;
} BCM89500_A0_EEE_MIN_LP_TIMER_Hr_t;

#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr_CLR(r) (r).eee_min_lp_timer_h[0] = 0
#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr_SET(r,d) (r).eee_min_lp_timer_h[0] = d
#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr_GET(r) (r).eee_min_lp_timer_h[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_GET(r) ((r).eee_min_lp_timer_h[0])
#define BCM89500_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_SET(r,f) (r).eee_min_lp_timer_h[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_H.
 *
 */
#define BCM89500_A0_READ_EEE_MIN_LP_TIMER_Hr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_MIN_LP_TIMER_Hr,(r._eee_min_lp_timer_h),4)
#define BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_Hr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_MIN_LP_TIMER_Hr,&(r._eee_min_lp_timer_h),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_Hr BCM89500_A0_EEE_MIN_LP_TIMER_Hr
#define EEE_MIN_LP_TIMER_Hr_SIZE BCM89500_A0_EEE_MIN_LP_TIMER_Hr_SIZE
typedef BCM89500_A0_EEE_MIN_LP_TIMER_Hr_t EEE_MIN_LP_TIMER_Hr_t;
#define EEE_MIN_LP_TIMER_Hr_CLR BCM89500_A0_EEE_MIN_LP_TIMER_Hr_CLR
#define EEE_MIN_LP_TIMER_Hr_SET BCM89500_A0_EEE_MIN_LP_TIMER_Hr_SET
#define EEE_MIN_LP_TIMER_Hr_GET BCM89500_A0_EEE_MIN_LP_TIMER_Hr_GET
#define EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_GET BCM89500_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_GET
#define EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_SET BCM89500_A0_EEE_MIN_LP_TIMER_Hr_MIN_LP_TIMER_Hf_SET
#define READ_EEE_MIN_LP_TIMER_Hr BCM89500_A0_READ_EEE_MIN_LP_TIMER_Hr
#define WRITE_EEE_MIN_LP_TIMER_Hr BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_MIN_LP_TIMER_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_MIN_LP_TIMER_H_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Minimum Low-Power Duration Timer - 100M Registers
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_H_IMP EEE minimum low-power duration delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr 0x0000929c

#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_H_IMP.
 *
 */
typedef union BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_h_imp[1];
	uint32_t _eee_min_lp_timer_h_imp;
} BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_t;

#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_CLR(r) (r).eee_min_lp_timer_h_imp[0] = 0
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_SET(r,d) (r).eee_min_lp_timer_h_imp[0] = d
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_GET(r) (r).eee_min_lp_timer_h_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_GET(r) ((r).eee_min_lp_timer_h_imp[0])
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_SET(r,f) (r).eee_min_lp_timer_h_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_H_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_MIN_LP_TIMER_H_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr,(r._eee_min_lp_timer_h_imp),4)
#define BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_H_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr,&(r._eee_min_lp_timer_h_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_H_IMPr BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr
#define EEE_MIN_LP_TIMER_H_IMPr_SIZE BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_SIZE
typedef BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_t EEE_MIN_LP_TIMER_H_IMPr_t;
#define EEE_MIN_LP_TIMER_H_IMPr_CLR BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_CLR
#define EEE_MIN_LP_TIMER_H_IMPr_SET BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_SET
#define EEE_MIN_LP_TIMER_H_IMPr_GET BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_GET
#define EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_GET BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_GET
#define EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_SET BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr_MIN_LP_TIMER_H_IMPf_SET
#define READ_EEE_MIN_LP_TIMER_H_IMPr BCM89500_A0_READ_EEE_MIN_LP_TIMER_H_IMPr
#define WRITE_EEE_MIN_LP_TIMER_H_IMPr BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_H_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_MIN_LP_TIMER_H_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_MIN_LP_TIMER_H_P7
 * BLOCKS:   SYS
 * DESC:     EEE Port 7 Minimum Low-Power Duration Timer - 100M Registers (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MIN_LP_TIMER_H   EEE minimum low-power duration delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r 0x00009298

#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_SIZE 4

/*
 * This structure should be used to declare and program EEE_MIN_LP_TIMER_H_P7.
 *
 */
typedef union BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_s {
	uint32_t v[1];
	uint32_t eee_min_lp_timer_h_p7[1];
	uint32_t _eee_min_lp_timer_h_p7;
} BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_t;

#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_CLR(r) (r).eee_min_lp_timer_h_p7[0] = 0
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_SET(r,d) (r).eee_min_lp_timer_h_p7[0] = d
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_GET(r) (r).eee_min_lp_timer_h_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_MIN_LP_TIMER_Hf_GET(r) ((r).eee_min_lp_timer_h_p7[0])
#define BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_MIN_LP_TIMER_Hf_SET(r,f) (r).eee_min_lp_timer_h_p7[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_MIN_LP_TIMER_H_P7.
 *
 */
#define BCM89500_A0_READ_EEE_MIN_LP_TIMER_H_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r,(r._eee_min_lp_timer_h_p7),4)
#define BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_H_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r,&(r._eee_min_lp_timer_h_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_MIN_LP_TIMER_H_P7r BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r
#define EEE_MIN_LP_TIMER_H_P7r_SIZE BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_SIZE
typedef BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_t EEE_MIN_LP_TIMER_H_P7r_t;
#define EEE_MIN_LP_TIMER_H_P7r_CLR BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_CLR
#define EEE_MIN_LP_TIMER_H_P7r_SET BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_SET
#define EEE_MIN_LP_TIMER_H_P7r_GET BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_GET
#define EEE_MIN_LP_TIMER_H_P7r_MIN_LP_TIMER_Hf_GET BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_MIN_LP_TIMER_Hf_GET
#define EEE_MIN_LP_TIMER_H_P7r_MIN_LP_TIMER_Hf_SET BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r_MIN_LP_TIMER_Hf_SET
#define READ_EEE_MIN_LP_TIMER_H_P7r BCM89500_A0_READ_EEE_MIN_LP_TIMER_H_P7r
#define WRITE_EEE_MIN_LP_TIMER_H_P7r BCM89500_A0_WRITE_EEE_MIN_LP_TIMER_H_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_MIN_LP_TIMER_H_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_PHY_CTRL
 * BLOCKS:   SYS
 * DESC:     EEE PHY Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_BIAS_10BTE    Enable BIAS for 10 Base-TThe register indicate enable 10 Base-T BIAS or not.1 = Enable0 = DisableNOTE:the register is the value of enable_bias_10bte
 *     EN_PHY_LPI       Enable PHY LPI featurePHY LPI enable/disable control.1 = Enable PHY LPI0 = Disable PHY LPINOTE:1. The definition of lpi_feature_en_def[1:0]:00 - permanently disable01 - permanently enable10 - controlled by the register with default disable11 - controlled by the register with default disable2. lpi_feature_en_def[1:0]=1x in the polar implementation. The register is the low bit value of lpi_feature_en_def[1:0].
 *     EEE_1000BASE_TX  EEE support on 1000 Base-TThe register indicate 1000 Base-T support EEE or not.1 = EEE support0 = EEE do not supportNOTE: the register is the value of eee_1000base_tx_def and leee_pcs_1000base_tx_def.
 *     EEE_100BASE_TX   EEE support on 100 Base-TXThe register indicate 100 Base-TX support EEE or not.1 = EEE support0 = EEE do not supportNOTE: the register is the value of eee_100base_tx_def and leee_pcs_100base_tx_def.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_PHY_CTRLr 0x000092d2

#define BCM89500_A0_EEE_PHY_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program EEE_PHY_CTRL.
 *
 */
typedef union BCM89500_A0_EEE_PHY_CTRLr_s {
	uint32_t v[1];
	uint32_t eee_phy_ctrl[1];
	uint32_t _eee_phy_ctrl;
} BCM89500_A0_EEE_PHY_CTRLr_t;

#define BCM89500_A0_EEE_PHY_CTRLr_CLR(r) (r).eee_phy_ctrl[0] = 0
#define BCM89500_A0_EEE_PHY_CTRLr_SET(r,d) (r).eee_phy_ctrl[0] = d
#define BCM89500_A0_EEE_PHY_CTRLr_GET(r) (r).eee_phy_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_GET(r) (((r).eee_phy_ctrl[0]) & 0x1)
#define BCM89500_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_GET(r) ((((r).eee_phy_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_GET(r) ((((r).eee_phy_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_GET(r) ((((r).eee_phy_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_EEE_PHY_CTRLr_RESERVEDf_GET(r) ((((r).eee_phy_ctrl[0]) >> 4) & 0xf)
#define BCM89500_A0_EEE_PHY_CTRLr_RESERVEDf_SET(r,f) (r).eee_phy_ctrl[0]=(((r).eee_phy_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access EEE_PHY_CTRL.
 *
 */
#define BCM89500_A0_READ_EEE_PHY_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_PHY_CTRLr,(r._eee_phy_ctrl),1)
#define BCM89500_A0_WRITE_EEE_PHY_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_PHY_CTRLr,&(r._eee_phy_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_PHY_CTRLr BCM89500_A0_EEE_PHY_CTRLr
#define EEE_PHY_CTRLr_SIZE BCM89500_A0_EEE_PHY_CTRLr_SIZE
typedef BCM89500_A0_EEE_PHY_CTRLr_t EEE_PHY_CTRLr_t;
#define EEE_PHY_CTRLr_CLR BCM89500_A0_EEE_PHY_CTRLr_CLR
#define EEE_PHY_CTRLr_SET BCM89500_A0_EEE_PHY_CTRLr_SET
#define EEE_PHY_CTRLr_GET BCM89500_A0_EEE_PHY_CTRLr_GET
#define EEE_PHY_CTRLr_EN_BIAS_10BTEf_GET BCM89500_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_GET
#define EEE_PHY_CTRLr_EN_BIAS_10BTEf_SET BCM89500_A0_EEE_PHY_CTRLr_EN_BIAS_10BTEf_SET
#define EEE_PHY_CTRLr_EN_PHY_LPIf_GET BCM89500_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_GET
#define EEE_PHY_CTRLr_EN_PHY_LPIf_SET BCM89500_A0_EEE_PHY_CTRLr_EN_PHY_LPIf_SET
#define EEE_PHY_CTRLr_EEE_1000BASE_TXf_GET BCM89500_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_GET
#define EEE_PHY_CTRLr_EEE_1000BASE_TXf_SET BCM89500_A0_EEE_PHY_CTRLr_EEE_1000BASE_TXf_SET
#define EEE_PHY_CTRLr_EEE_100BASE_TXf_GET BCM89500_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_GET
#define EEE_PHY_CTRLr_EEE_100BASE_TXf_SET BCM89500_A0_EEE_PHY_CTRLr_EEE_100BASE_TXf_SET
#define EEE_PHY_CTRLr_RESERVEDf_GET BCM89500_A0_EEE_PHY_CTRLr_RESERVEDf_GET
#define EEE_PHY_CTRLr_RESERVEDf_SET BCM89500_A0_EEE_PHY_CTRLr_RESERVEDf_SET
#define READ_EEE_PHY_CTRLr BCM89500_A0_READ_EEE_PHY_CTRLr
#define WRITE_EEE_PHY_CTRLr BCM89500_A0_WRITE_EEE_PHY_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_PHY_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_PIPELINE_TIMER
 * BLOCKS:   SYS
 * DESC:     EEE Pipeline Delay Timer Registers
 * SIZE:     32
 * FIELDS:
 *     PIPELINE_TIMER   EEE pipeline delay timer load value.The unit is system clock rate(ex. If system clock=100Mhz, unit=10nsec).
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_PIPELINE_TIMERr 0x0000920c

#define BCM89500_A0_EEE_PIPELINE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program EEE_PIPELINE_TIMER.
 *
 */
typedef union BCM89500_A0_EEE_PIPELINE_TIMERr_s {
	uint32_t v[1];
	uint32_t eee_pipeline_timer[1];
	uint32_t _eee_pipeline_timer;
} BCM89500_A0_EEE_PIPELINE_TIMERr_t;

#define BCM89500_A0_EEE_PIPELINE_TIMERr_CLR(r) (r).eee_pipeline_timer[0] = 0
#define BCM89500_A0_EEE_PIPELINE_TIMERr_SET(r,d) (r).eee_pipeline_timer[0] = d
#define BCM89500_A0_EEE_PIPELINE_TIMERr_GET(r) (r).eee_pipeline_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_GET(r) ((r).eee_pipeline_timer[0])
#define BCM89500_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_SET(r,f) (r).eee_pipeline_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_PIPELINE_TIMER.
 *
 */
#define BCM89500_A0_READ_EEE_PIPELINE_TIMERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_PIPELINE_TIMERr,(r._eee_pipeline_timer),4)
#define BCM89500_A0_WRITE_EEE_PIPELINE_TIMERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_PIPELINE_TIMERr,&(r._eee_pipeline_timer),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_PIPELINE_TIMERr BCM89500_A0_EEE_PIPELINE_TIMERr
#define EEE_PIPELINE_TIMERr_SIZE BCM89500_A0_EEE_PIPELINE_TIMERr_SIZE
typedef BCM89500_A0_EEE_PIPELINE_TIMERr_t EEE_PIPELINE_TIMERr_t;
#define EEE_PIPELINE_TIMERr_CLR BCM89500_A0_EEE_PIPELINE_TIMERr_CLR
#define EEE_PIPELINE_TIMERr_SET BCM89500_A0_EEE_PIPELINE_TIMERr_SET
#define EEE_PIPELINE_TIMERr_GET BCM89500_A0_EEE_PIPELINE_TIMERr_GET
#define EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_GET BCM89500_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_GET
#define EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_SET BCM89500_A0_EEE_PIPELINE_TIMERr_PIPELINE_TIMERf_SET
#define READ_EEE_PIPELINE_TIMERr BCM89500_A0_READ_EEE_PIPELINE_TIMERr
#define WRITE_EEE_PIPELINE_TIMERr BCM89500_A0_WRITE_EEE_PIPELINE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_PIPELINE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_RX_IDLE_SYMBOL
 * BLOCKS:   SYS
 * DESC:     EEE Receiving Idle Symbols Status Registers
 * SIZE:     16
 * FIELDS:
 *     RX_IDLE_SYMBOL   receivingIdleSymbols output signal status.9 bit indicating that a receivingIdleSymbols output that is asserted whenever the receive PHY is sending normal idle symbols to the receive MAC.(bit 0-5 = port 0- port 5, bit 7 = port 7, bit 8 = IMP port)1 = asserted0 = deasserted
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr 0x00009206

#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_SIZE 2

/*
 * This structure should be used to declare and program EEE_RX_IDLE_SYMBOL.
 *
 */
typedef union BCM89500_A0_EEE_RX_IDLE_SYMBOLr_s {
	uint32_t v[1];
	uint32_t eee_rx_idle_symbol[1];
	uint32_t _eee_rx_idle_symbol;
} BCM89500_A0_EEE_RX_IDLE_SYMBOLr_t;

#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_CLR(r) (r).eee_rx_idle_symbol[0] = 0
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_SET(r,d) (r).eee_rx_idle_symbol[0] = d
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_GET(r) (r).eee_rx_idle_symbol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_GET(r) (((r).eee_rx_idle_symbol[0]) & 0x1ff)
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_SET(r,f) (r).eee_rx_idle_symbol[0]=(((r).eee_rx_idle_symbol[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_GET(r) ((((r).eee_rx_idle_symbol[0]) >> 9) & 0x7f)
#define BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_SET(r,f) (r).eee_rx_idle_symbol[0]=(((r).eee_rx_idle_symbol[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access EEE_RX_IDLE_SYMBOL.
 *
 */
#define BCM89500_A0_READ_EEE_RX_IDLE_SYMBOLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_RX_IDLE_SYMBOLr,(r._eee_rx_idle_symbol),2)
#define BCM89500_A0_WRITE_EEE_RX_IDLE_SYMBOLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_RX_IDLE_SYMBOLr,&(r._eee_rx_idle_symbol),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_RX_IDLE_SYMBOLr BCM89500_A0_EEE_RX_IDLE_SYMBOLr
#define EEE_RX_IDLE_SYMBOLr_SIZE BCM89500_A0_EEE_RX_IDLE_SYMBOLr_SIZE
typedef BCM89500_A0_EEE_RX_IDLE_SYMBOLr_t EEE_RX_IDLE_SYMBOLr_t;
#define EEE_RX_IDLE_SYMBOLr_CLR BCM89500_A0_EEE_RX_IDLE_SYMBOLr_CLR
#define EEE_RX_IDLE_SYMBOLr_SET BCM89500_A0_EEE_RX_IDLE_SYMBOLr_SET
#define EEE_RX_IDLE_SYMBOLr_GET BCM89500_A0_EEE_RX_IDLE_SYMBOLr_GET
#define EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_GET BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_GET
#define EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_SET BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RX_IDLE_SYMBOLf_SET
#define EEE_RX_IDLE_SYMBOLr_RESERVEDf_GET BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_GET
#define EEE_RX_IDLE_SYMBOLr_RESERVEDf_SET BCM89500_A0_EEE_RX_IDLE_SYMBOLr_RESERVEDf_SET
#define READ_EEE_RX_IDLE_SYMBOLr BCM89500_A0_READ_EEE_RX_IDLE_SYMBOLr
#define WRITE_EEE_RX_IDLE_SYMBOLr BCM89500_A0_WRITE_EEE_RX_IDLE_SYMBOLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_RX_IDLE_SYMBOLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_SLEEP_TIMER_G
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Sleep Delay Timer - 1G Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_G    EEE sleep delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_SLEEP_TIMER_Gr 0x00009210

#define BCM89500_A0_EEE_SLEEP_TIMER_Gr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_G.
 *
 */
typedef union BCM89500_A0_EEE_SLEEP_TIMER_Gr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_g[1];
	uint32_t _eee_sleep_timer_g;
} BCM89500_A0_EEE_SLEEP_TIMER_Gr_t;

#define BCM89500_A0_EEE_SLEEP_TIMER_Gr_CLR(r) (r).eee_sleep_timer_g[0] = 0
#define BCM89500_A0_EEE_SLEEP_TIMER_Gr_SET(r,d) (r).eee_sleep_timer_g[0] = d
#define BCM89500_A0_EEE_SLEEP_TIMER_Gr_GET(r) (r).eee_sleep_timer_g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_GET(r) ((r).eee_sleep_timer_g[0])
#define BCM89500_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_SET(r,f) (r).eee_sleep_timer_g[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_G.
 *
 */
#define BCM89500_A0_READ_EEE_SLEEP_TIMER_Gr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_SLEEP_TIMER_Gr,(r._eee_sleep_timer_g),4)
#define BCM89500_A0_WRITE_EEE_SLEEP_TIMER_Gr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_SLEEP_TIMER_Gr,&(r._eee_sleep_timer_g),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_Gr BCM89500_A0_EEE_SLEEP_TIMER_Gr
#define EEE_SLEEP_TIMER_Gr_SIZE BCM89500_A0_EEE_SLEEP_TIMER_Gr_SIZE
typedef BCM89500_A0_EEE_SLEEP_TIMER_Gr_t EEE_SLEEP_TIMER_Gr_t;
#define EEE_SLEEP_TIMER_Gr_CLR BCM89500_A0_EEE_SLEEP_TIMER_Gr_CLR
#define EEE_SLEEP_TIMER_Gr_SET BCM89500_A0_EEE_SLEEP_TIMER_Gr_SET
#define EEE_SLEEP_TIMER_Gr_GET BCM89500_A0_EEE_SLEEP_TIMER_Gr_GET
#define EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_GET BCM89500_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_GET
#define EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_SET BCM89500_A0_EEE_SLEEP_TIMER_Gr_SLEEP_TIMER_Gf_SET
#define READ_EEE_SLEEP_TIMER_Gr BCM89500_A0_READ_EEE_SLEEP_TIMER_Gr
#define WRITE_EEE_SLEEP_TIMER_Gr BCM89500_A0_WRITE_EEE_SLEEP_TIMER_Gr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_SLEEP_TIMER_Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_SLEEP_TIMER_G_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Sleep Delay Timer Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_G_IMP EEE sleep delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr 0x00009230

#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_G_IMP.
 *
 */
typedef union BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_g_imp[1];
	uint32_t _eee_sleep_timer_g_imp;
} BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_t;

#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_CLR(r) (r).eee_sleep_timer_g_imp[0] = 0
#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SET(r,d) (r).eee_sleep_timer_g_imp[0] = d
#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_GET(r) (r).eee_sleep_timer_g_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_GET(r) ((r).eee_sleep_timer_g_imp[0])
#define BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_SET(r,f) (r).eee_sleep_timer_g_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_G_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_SLEEP_TIMER_G_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr,(r._eee_sleep_timer_g_imp),4)
#define BCM89500_A0_WRITE_EEE_SLEEP_TIMER_G_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr,&(r._eee_sleep_timer_g_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_G_IMPr BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr
#define EEE_SLEEP_TIMER_G_IMPr_SIZE BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SIZE
typedef BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_t EEE_SLEEP_TIMER_G_IMPr_t;
#define EEE_SLEEP_TIMER_G_IMPr_CLR BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_CLR
#define EEE_SLEEP_TIMER_G_IMPr_SET BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SET
#define EEE_SLEEP_TIMER_G_IMPr_GET BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_GET
#define EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_GET BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_GET
#define EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_SET BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr_SLEEP_TIMER_G_IMPf_SET
#define READ_EEE_SLEEP_TIMER_G_IMPr BCM89500_A0_READ_EEE_SLEEP_TIMER_G_IMPr
#define WRITE_EEE_SLEEP_TIMER_G_IMPr BCM89500_A0_WRITE_EEE_SLEEP_TIMER_G_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_SLEEP_TIMER_G_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_SLEEP_TIMER_G_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Port 7 Sleep Delay Timer Registers (polar feature)
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_G    EEE sleep delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r 0x0000922c

#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_G_P7.
 *
 */
typedef union BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_g_p7[1];
	uint32_t _eee_sleep_timer_g_p7;
} BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_t;

#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_CLR(r) (r).eee_sleep_timer_g_p7[0] = 0
#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SET(r,d) (r).eee_sleep_timer_g_p7[0] = d
#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_GET(r) (r).eee_sleep_timer_g_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SLEEP_TIMER_Gf_GET(r) ((r).eee_sleep_timer_g_p7[0])
#define BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SLEEP_TIMER_Gf_SET(r,f) (r).eee_sleep_timer_g_p7[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_G_P7.
 *
 */
#define BCM89500_A0_READ_EEE_SLEEP_TIMER_G_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_SLEEP_TIMER_G_P7r,(r._eee_sleep_timer_g_p7),4)
#define BCM89500_A0_WRITE_EEE_SLEEP_TIMER_G_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_SLEEP_TIMER_G_P7r,&(r._eee_sleep_timer_g_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_G_P7r BCM89500_A0_EEE_SLEEP_TIMER_G_P7r
#define EEE_SLEEP_TIMER_G_P7r_SIZE BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SIZE
typedef BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_t EEE_SLEEP_TIMER_G_P7r_t;
#define EEE_SLEEP_TIMER_G_P7r_CLR BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_CLR
#define EEE_SLEEP_TIMER_G_P7r_SET BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SET
#define EEE_SLEEP_TIMER_G_P7r_GET BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_GET
#define EEE_SLEEP_TIMER_G_P7r_SLEEP_TIMER_Gf_GET BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SLEEP_TIMER_Gf_GET
#define EEE_SLEEP_TIMER_G_P7r_SLEEP_TIMER_Gf_SET BCM89500_A0_EEE_SLEEP_TIMER_G_P7r_SLEEP_TIMER_Gf_SET
#define READ_EEE_SLEEP_TIMER_G_P7r BCM89500_A0_READ_EEE_SLEEP_TIMER_G_P7r
#define WRITE_EEE_SLEEP_TIMER_G_P7r BCM89500_A0_WRITE_EEE_SLEEP_TIMER_G_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_SLEEP_TIMER_G_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_SLEEP_TIMER_H
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Sleep Delay Timer - 100M Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_H    EEE sleep delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_SLEEP_TIMER_Hr 0x00009234

#define BCM89500_A0_EEE_SLEEP_TIMER_Hr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_H.
 *
 */
typedef union BCM89500_A0_EEE_SLEEP_TIMER_Hr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_h[1];
	uint32_t _eee_sleep_timer_h;
} BCM89500_A0_EEE_SLEEP_TIMER_Hr_t;

#define BCM89500_A0_EEE_SLEEP_TIMER_Hr_CLR(r) (r).eee_sleep_timer_h[0] = 0
#define BCM89500_A0_EEE_SLEEP_TIMER_Hr_SET(r,d) (r).eee_sleep_timer_h[0] = d
#define BCM89500_A0_EEE_SLEEP_TIMER_Hr_GET(r) (r).eee_sleep_timer_h[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_GET(r) ((r).eee_sleep_timer_h[0])
#define BCM89500_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_SET(r,f) (r).eee_sleep_timer_h[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_H.
 *
 */
#define BCM89500_A0_READ_EEE_SLEEP_TIMER_Hr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_SLEEP_TIMER_Hr,(r._eee_sleep_timer_h),4)
#define BCM89500_A0_WRITE_EEE_SLEEP_TIMER_Hr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_SLEEP_TIMER_Hr,&(r._eee_sleep_timer_h),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_Hr BCM89500_A0_EEE_SLEEP_TIMER_Hr
#define EEE_SLEEP_TIMER_Hr_SIZE BCM89500_A0_EEE_SLEEP_TIMER_Hr_SIZE
typedef BCM89500_A0_EEE_SLEEP_TIMER_Hr_t EEE_SLEEP_TIMER_Hr_t;
#define EEE_SLEEP_TIMER_Hr_CLR BCM89500_A0_EEE_SLEEP_TIMER_Hr_CLR
#define EEE_SLEEP_TIMER_Hr_SET BCM89500_A0_EEE_SLEEP_TIMER_Hr_SET
#define EEE_SLEEP_TIMER_Hr_GET BCM89500_A0_EEE_SLEEP_TIMER_Hr_GET
#define EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_GET BCM89500_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_GET
#define EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_SET BCM89500_A0_EEE_SLEEP_TIMER_Hr_SLEEP_TIMER_Hf_SET
#define READ_EEE_SLEEP_TIMER_Hr BCM89500_A0_READ_EEE_SLEEP_TIMER_Hr
#define WRITE_EEE_SLEEP_TIMER_Hr BCM89500_A0_WRITE_EEE_SLEEP_TIMER_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_SLEEP_TIMER_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_SLEEP_TIMER_H_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Sleep Delay Timer Registers
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_H_IMP EEE sleep delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr 0x00009254

#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_H_IMP.
 *
 */
typedef union BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_h_imp[1];
	uint32_t _eee_sleep_timer_h_imp;
} BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_t;

#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_CLR(r) (r).eee_sleep_timer_h_imp[0] = 0
#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SET(r,d) (r).eee_sleep_timer_h_imp[0] = d
#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_GET(r) (r).eee_sleep_timer_h_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_GET(r) ((r).eee_sleep_timer_h_imp[0])
#define BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_SET(r,f) (r).eee_sleep_timer_h_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_H_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_SLEEP_TIMER_H_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr,(r._eee_sleep_timer_h_imp),4)
#define BCM89500_A0_WRITE_EEE_SLEEP_TIMER_H_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr,&(r._eee_sleep_timer_h_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_H_IMPr BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr
#define EEE_SLEEP_TIMER_H_IMPr_SIZE BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SIZE
typedef BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_t EEE_SLEEP_TIMER_H_IMPr_t;
#define EEE_SLEEP_TIMER_H_IMPr_CLR BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_CLR
#define EEE_SLEEP_TIMER_H_IMPr_SET BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SET
#define EEE_SLEEP_TIMER_H_IMPr_GET BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_GET
#define EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_GET BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_GET
#define EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_SET BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr_SLEEP_TIMER_H_IMPf_SET
#define READ_EEE_SLEEP_TIMER_H_IMPr BCM89500_A0_READ_EEE_SLEEP_TIMER_H_IMPr
#define WRITE_EEE_SLEEP_TIMER_H_IMPr BCM89500_A0_WRITE_EEE_SLEEP_TIMER_H_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_SLEEP_TIMER_H_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_SLEEP_TIMER_H_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Port 7 Sleep Delay Timer Registers (polar feature)
 * SIZE:     32
 * FIELDS:
 *     SLEEP_TIMER_H    EEE sleep delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r 0x00009250

#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SIZE 4

/*
 * This structure should be used to declare and program EEE_SLEEP_TIMER_H_P7.
 *
 */
typedef union BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_s {
	uint32_t v[1];
	uint32_t eee_sleep_timer_h_p7[1];
	uint32_t _eee_sleep_timer_h_p7;
} BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_t;

#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_CLR(r) (r).eee_sleep_timer_h_p7[0] = 0
#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SET(r,d) (r).eee_sleep_timer_h_p7[0] = d
#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_GET(r) (r).eee_sleep_timer_h_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SLEEP_TIMER_Hf_GET(r) ((r).eee_sleep_timer_h_p7[0])
#define BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SLEEP_TIMER_Hf_SET(r,f) (r).eee_sleep_timer_h_p7[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_SLEEP_TIMER_H_P7.
 *
 */
#define BCM89500_A0_READ_EEE_SLEEP_TIMER_H_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_SLEEP_TIMER_H_P7r,(r._eee_sleep_timer_h_p7),4)
#define BCM89500_A0_WRITE_EEE_SLEEP_TIMER_H_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_SLEEP_TIMER_H_P7r,&(r._eee_sleep_timer_h_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_SLEEP_TIMER_H_P7r BCM89500_A0_EEE_SLEEP_TIMER_H_P7r
#define EEE_SLEEP_TIMER_H_P7r_SIZE BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SIZE
typedef BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_t EEE_SLEEP_TIMER_H_P7r_t;
#define EEE_SLEEP_TIMER_H_P7r_CLR BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_CLR
#define EEE_SLEEP_TIMER_H_P7r_SET BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SET
#define EEE_SLEEP_TIMER_H_P7r_GET BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_GET
#define EEE_SLEEP_TIMER_H_P7r_SLEEP_TIMER_Hf_GET BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SLEEP_TIMER_Hf_GET
#define EEE_SLEEP_TIMER_H_P7r_SLEEP_TIMER_Hf_SET BCM89500_A0_EEE_SLEEP_TIMER_H_P7r_SLEEP_TIMER_Hf_SET
#define READ_EEE_SLEEP_TIMER_H_P7r BCM89500_A0_READ_EEE_SLEEP_TIMER_H_P7r
#define WRITE_EEE_SLEEP_TIMER_H_P7r BCM89500_A0_WRITE_EEE_SLEEP_TIMER_H_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_SLEEP_TIMER_H_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_STATE
 * BLOCKS:   SYS
 * DESC:     EEE Control Policy State Registers(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     EEE_STATE        EEE Control Policy State.A 27-bit field to indicate the EEE control policy state for each port. Three bits for each port. Bits 17-0 = port 5- port 0 respectatively, bit 26-24 = IMP port.000 = ACTIVE state(INIT, WAIT)001 = SLEEP state(SLEEP_DELAY, SLEEP_WAIT)010 = PIPELINE state(PIPELINE_DELAY, PIPELINE_WAIT)011 = LOW_POWER state(ENTER_LOW_POWER, LOW_POWER)100 = WAKE state(EXIT_LOW_POWER, WAKE_DELAY)(Not2Release)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_STATEr 0x000092ec

#define BCM89500_A0_EEE_STATEr_SIZE 4

/*
 * This structure should be used to declare and program EEE_STATE.
 *
 */
typedef union BCM89500_A0_EEE_STATEr_s {
	uint32_t v[1];
	uint32_t eee_state[1];
	uint32_t _eee_state;
} BCM89500_A0_EEE_STATEr_t;

#define BCM89500_A0_EEE_STATEr_CLR(r) (r).eee_state[0] = 0
#define BCM89500_A0_EEE_STATEr_SET(r,d) (r).eee_state[0] = d
#define BCM89500_A0_EEE_STATEr_GET(r) (r).eee_state[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_STATEr_EEE_STATEf_GET(r) (((r).eee_state[0]) & 0x7ffffff)
#define BCM89500_A0_EEE_STATEr_EEE_STATEf_SET(r,f) (r).eee_state[0]=(((r).eee_state[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))
#define BCM89500_A0_EEE_STATEr_RESERVEDf_GET(r) ((((r).eee_state[0]) >> 27) & 0x1f)
#define BCM89500_A0_EEE_STATEr_RESERVEDf_SET(r,f) (r).eee_state[0]=(((r).eee_state[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access EEE_STATE.
 *
 */
#define BCM89500_A0_READ_EEE_STATEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_STATEr,(r._eee_state),4)
#define BCM89500_A0_WRITE_EEE_STATEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_STATEr,&(r._eee_state),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_STATEr BCM89500_A0_EEE_STATEr
#define EEE_STATEr_SIZE BCM89500_A0_EEE_STATEr_SIZE
typedef BCM89500_A0_EEE_STATEr_t EEE_STATEr_t;
#define EEE_STATEr_CLR BCM89500_A0_EEE_STATEr_CLR
#define EEE_STATEr_SET BCM89500_A0_EEE_STATEr_SET
#define EEE_STATEr_GET BCM89500_A0_EEE_STATEr_GET
#define EEE_STATEr_EEE_STATEf_GET BCM89500_A0_EEE_STATEr_EEE_STATEf_GET
#define EEE_STATEr_EEE_STATEf_SET BCM89500_A0_EEE_STATEr_EEE_STATEf_SET
#define EEE_STATEr_RESERVEDf_GET BCM89500_A0_EEE_STATEr_RESERVEDf_GET
#define EEE_STATEr_RESERVEDf_SET BCM89500_A0_EEE_STATEr_RESERVEDf_SET
#define READ_EEE_STATEr BCM89500_A0_READ_EEE_STATEr
#define WRITE_EEE_STATEr BCM89500_A0_WRITE_EEE_STATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_STATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_TXQ_CONG_TH
 * BLOCKS:   SYS
 * DESC:     EEE TXQ N Congestion Threshold Registers
 * SIZE:     16
 * FIELDS:
 *     TXQ_CONG_TH      EEE TXQ packet buffer congestion threshold.If this threshold is set to zero, then EEE for queue N is effectively disabled, if this threshold is set equal to or greater than 512(the number of cells implemented in the packet buffer), then protections against packet loss are disabled.The unit is "Buffer Cell Size": 256-byte cell.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_TXQ_CONG_THr 0x000092c6

#define BCM89500_A0_EEE_TXQ_CONG_THr_SIZE 2

/*
 * This structure should be used to declare and program EEE_TXQ_CONG_TH.
 *
 */
typedef union BCM89500_A0_EEE_TXQ_CONG_THr_s {
	uint32_t v[1];
	uint32_t eee_txq_cong_th[1];
	uint32_t _eee_txq_cong_th;
} BCM89500_A0_EEE_TXQ_CONG_THr_t;

#define BCM89500_A0_EEE_TXQ_CONG_THr_CLR(r) (r).eee_txq_cong_th[0] = 0
#define BCM89500_A0_EEE_TXQ_CONG_THr_SET(r,d) (r).eee_txq_cong_th[0] = d
#define BCM89500_A0_EEE_TXQ_CONG_THr_GET(r) (r).eee_txq_cong_th[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_GET(r) (((r).eee_txq_cong_th[0]) & 0x3ff)
#define BCM89500_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_SET(r,f) (r).eee_txq_cong_th[0]=(((r).eee_txq_cong_th[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_EEE_TXQ_CONG_THr_RESERVEDf_GET(r) ((((r).eee_txq_cong_th[0]) >> 10) & 0x3f)
#define BCM89500_A0_EEE_TXQ_CONG_THr_RESERVEDf_SET(r,f) (r).eee_txq_cong_th[0]=(((r).eee_txq_cong_th[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EEE_TXQ_CONG_TH.
 *
 */
#define BCM89500_A0_READ_EEE_TXQ_CONG_THr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_TXQ_CONG_THr+(2*(i)),(r._eee_txq_cong_th),2)
#define BCM89500_A0_WRITE_EEE_TXQ_CONG_THr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_TXQ_CONG_THr+(2*(i)),&(r._eee_txq_cong_th),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_TXQ_CONG_THr BCM89500_A0_EEE_TXQ_CONG_THr
#define EEE_TXQ_CONG_THr_SIZE BCM89500_A0_EEE_TXQ_CONG_THr_SIZE
typedef BCM89500_A0_EEE_TXQ_CONG_THr_t EEE_TXQ_CONG_THr_t;
#define EEE_TXQ_CONG_THr_CLR BCM89500_A0_EEE_TXQ_CONG_THr_CLR
#define EEE_TXQ_CONG_THr_SET BCM89500_A0_EEE_TXQ_CONG_THr_SET
#define EEE_TXQ_CONG_THr_GET BCM89500_A0_EEE_TXQ_CONG_THr_GET
#define EEE_TXQ_CONG_THr_TXQ_CONG_THf_GET BCM89500_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_GET
#define EEE_TXQ_CONG_THr_TXQ_CONG_THf_SET BCM89500_A0_EEE_TXQ_CONG_THr_TXQ_CONG_THf_SET
#define EEE_TXQ_CONG_THr_RESERVEDf_GET BCM89500_A0_EEE_TXQ_CONG_THr_RESERVEDf_GET
#define EEE_TXQ_CONG_THr_RESERVEDf_SET BCM89500_A0_EEE_TXQ_CONG_THr_RESERVEDf_SET
#define READ_EEE_TXQ_CONG_THr BCM89500_A0_READ_EEE_TXQ_CONG_THr
#define WRITE_EEE_TXQ_CONG_THr BCM89500_A0_WRITE_EEE_TXQ_CONG_THr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_TXQ_CONG_THr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_WAKE_TIMER_G
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Wake Transition Timer - 1G Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_G     EEE wake transition delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_WAKE_TIMER_Gr 0x000092a0

#define BCM89500_A0_EEE_WAKE_TIMER_Gr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_G.
 *
 */
typedef union BCM89500_A0_EEE_WAKE_TIMER_Gr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_g[1];
	uint32_t _eee_wake_timer_g;
} BCM89500_A0_EEE_WAKE_TIMER_Gr_t;

#define BCM89500_A0_EEE_WAKE_TIMER_Gr_CLR(r) (r).eee_wake_timer_g[0] = 0
#define BCM89500_A0_EEE_WAKE_TIMER_Gr_SET(r,d) (r).eee_wake_timer_g[0] = d
#define BCM89500_A0_EEE_WAKE_TIMER_Gr_GET(r) (r).eee_wake_timer_g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_GET(r) (((r).eee_wake_timer_g[0]) & 0xffff)
#define BCM89500_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_SET(r,f) (r).eee_wake_timer_g[0]=(((r).eee_wake_timer_g[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_G.
 *
 */
#define BCM89500_A0_READ_EEE_WAKE_TIMER_Gr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_WAKE_TIMER_Gr,(r._eee_wake_timer_g),2)
#define BCM89500_A0_WRITE_EEE_WAKE_TIMER_Gr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_WAKE_TIMER_Gr,&(r._eee_wake_timer_g),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_Gr BCM89500_A0_EEE_WAKE_TIMER_Gr
#define EEE_WAKE_TIMER_Gr_SIZE BCM89500_A0_EEE_WAKE_TIMER_Gr_SIZE
typedef BCM89500_A0_EEE_WAKE_TIMER_Gr_t EEE_WAKE_TIMER_Gr_t;
#define EEE_WAKE_TIMER_Gr_CLR BCM89500_A0_EEE_WAKE_TIMER_Gr_CLR
#define EEE_WAKE_TIMER_Gr_SET BCM89500_A0_EEE_WAKE_TIMER_Gr_SET
#define EEE_WAKE_TIMER_Gr_GET BCM89500_A0_EEE_WAKE_TIMER_Gr_GET
#define EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_GET BCM89500_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_GET
#define EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_SET BCM89500_A0_EEE_WAKE_TIMER_Gr_WAKE_TIMER_Gf_SET
#define READ_EEE_WAKE_TIMER_Gr BCM89500_A0_READ_EEE_WAKE_TIMER_Gr
#define WRITE_EEE_WAKE_TIMER_Gr BCM89500_A0_WRITE_EEE_WAKE_TIMER_Gr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_WAKE_TIMER_Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_WAKE_TIMER_G_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Wake Transition Timer - 1G Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_G_IMP EEE wake transition delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr 0x000092b0

#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_G_IMP.
 *
 */
typedef union BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_g_imp[1];
	uint32_t _eee_wake_timer_g_imp;
} BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_t;

#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_CLR(r) (r).eee_wake_timer_g_imp[0] = 0
#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_SET(r,d) (r).eee_wake_timer_g_imp[0] = d
#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_GET(r) (r).eee_wake_timer_g_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_GET(r) (((r).eee_wake_timer_g_imp[0]) & 0xffff)
#define BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_SET(r,f) (r).eee_wake_timer_g_imp[0]=(((r).eee_wake_timer_g_imp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_G_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_WAKE_TIMER_G_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_WAKE_TIMER_G_IMPr,(r._eee_wake_timer_g_imp),2)
#define BCM89500_A0_WRITE_EEE_WAKE_TIMER_G_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_WAKE_TIMER_G_IMPr,&(r._eee_wake_timer_g_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_G_IMPr BCM89500_A0_EEE_WAKE_TIMER_G_IMPr
#define EEE_WAKE_TIMER_G_IMPr_SIZE BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_SIZE
typedef BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_t EEE_WAKE_TIMER_G_IMPr_t;
#define EEE_WAKE_TIMER_G_IMPr_CLR BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_CLR
#define EEE_WAKE_TIMER_G_IMPr_SET BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_SET
#define EEE_WAKE_TIMER_G_IMPr_GET BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_GET
#define EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_GET BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_GET
#define EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_SET BCM89500_A0_EEE_WAKE_TIMER_G_IMPr_WAKE_TIMER_G_IMPf_SET
#define READ_EEE_WAKE_TIMER_G_IMPr BCM89500_A0_READ_EEE_WAKE_TIMER_G_IMPr
#define WRITE_EEE_WAKE_TIMER_G_IMPr BCM89500_A0_WRITE_EEE_WAKE_TIMER_G_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_WAKE_TIMER_G_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_WAKE_TIMER_G_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Port 7 Wake Transition Timer - 1G Registers (polar feature)
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_G     EEE wake transition delay timer load value for 1G operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r 0x000092ae

#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_G_P7.
 *
 */
typedef union BCM89500_A0_EEE_WAKE_TIMER_G_P7r_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_g_p7[1];
	uint32_t _eee_wake_timer_g_p7;
} BCM89500_A0_EEE_WAKE_TIMER_G_P7r_t;

#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r_CLR(r) (r).eee_wake_timer_g_p7[0] = 0
#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r_SET(r,d) (r).eee_wake_timer_g_p7[0] = d
#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r_GET(r) (r).eee_wake_timer_g_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r_WAKE_TIMER_Gf_GET(r) (((r).eee_wake_timer_g_p7[0]) & 0xffff)
#define BCM89500_A0_EEE_WAKE_TIMER_G_P7r_WAKE_TIMER_Gf_SET(r,f) (r).eee_wake_timer_g_p7[0]=(((r).eee_wake_timer_g_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_G_P7.
 *
 */
#define BCM89500_A0_READ_EEE_WAKE_TIMER_G_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_WAKE_TIMER_G_P7r,(r._eee_wake_timer_g_p7),2)
#define BCM89500_A0_WRITE_EEE_WAKE_TIMER_G_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_WAKE_TIMER_G_P7r,&(r._eee_wake_timer_g_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_G_P7r BCM89500_A0_EEE_WAKE_TIMER_G_P7r
#define EEE_WAKE_TIMER_G_P7r_SIZE BCM89500_A0_EEE_WAKE_TIMER_G_P7r_SIZE
typedef BCM89500_A0_EEE_WAKE_TIMER_G_P7r_t EEE_WAKE_TIMER_G_P7r_t;
#define EEE_WAKE_TIMER_G_P7r_CLR BCM89500_A0_EEE_WAKE_TIMER_G_P7r_CLR
#define EEE_WAKE_TIMER_G_P7r_SET BCM89500_A0_EEE_WAKE_TIMER_G_P7r_SET
#define EEE_WAKE_TIMER_G_P7r_GET BCM89500_A0_EEE_WAKE_TIMER_G_P7r_GET
#define EEE_WAKE_TIMER_G_P7r_WAKE_TIMER_Gf_GET BCM89500_A0_EEE_WAKE_TIMER_G_P7r_WAKE_TIMER_Gf_GET
#define EEE_WAKE_TIMER_G_P7r_WAKE_TIMER_Gf_SET BCM89500_A0_EEE_WAKE_TIMER_G_P7r_WAKE_TIMER_Gf_SET
#define READ_EEE_WAKE_TIMER_G_P7r BCM89500_A0_READ_EEE_WAKE_TIMER_G_P7r
#define WRITE_EEE_WAKE_TIMER_G_P7r BCM89500_A0_WRITE_EEE_WAKE_TIMER_G_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_WAKE_TIMER_G_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_WAKE_TIMER_H
 * BLOCKS:   GPIC0
 * DESC:     EEE Port N Wake Transition Timer - 100M Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_H     EEE wake transition delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_WAKE_TIMER_Hr 0x000092b2

#define BCM89500_A0_EEE_WAKE_TIMER_Hr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_H.
 *
 */
typedef union BCM89500_A0_EEE_WAKE_TIMER_Hr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_h[1];
	uint32_t _eee_wake_timer_h;
} BCM89500_A0_EEE_WAKE_TIMER_Hr_t;

#define BCM89500_A0_EEE_WAKE_TIMER_Hr_CLR(r) (r).eee_wake_timer_h[0] = 0
#define BCM89500_A0_EEE_WAKE_TIMER_Hr_SET(r,d) (r).eee_wake_timer_h[0] = d
#define BCM89500_A0_EEE_WAKE_TIMER_Hr_GET(r) (r).eee_wake_timer_h[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_GET(r) (((r).eee_wake_timer_h[0]) & 0xffff)
#define BCM89500_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_SET(r,f) (r).eee_wake_timer_h[0]=(((r).eee_wake_timer_h[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_H.
 *
 */
#define BCM89500_A0_READ_EEE_WAKE_TIMER_Hr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EEE_WAKE_TIMER_Hr,(r._eee_wake_timer_h),2)
#define BCM89500_A0_WRITE_EEE_WAKE_TIMER_Hr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EEE_WAKE_TIMER_Hr,&(r._eee_wake_timer_h),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_Hr BCM89500_A0_EEE_WAKE_TIMER_Hr
#define EEE_WAKE_TIMER_Hr_SIZE BCM89500_A0_EEE_WAKE_TIMER_Hr_SIZE
typedef BCM89500_A0_EEE_WAKE_TIMER_Hr_t EEE_WAKE_TIMER_Hr_t;
#define EEE_WAKE_TIMER_Hr_CLR BCM89500_A0_EEE_WAKE_TIMER_Hr_CLR
#define EEE_WAKE_TIMER_Hr_SET BCM89500_A0_EEE_WAKE_TIMER_Hr_SET
#define EEE_WAKE_TIMER_Hr_GET BCM89500_A0_EEE_WAKE_TIMER_Hr_GET
#define EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_GET BCM89500_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_GET
#define EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_SET BCM89500_A0_EEE_WAKE_TIMER_Hr_WAKE_TIMER_Hf_SET
#define READ_EEE_WAKE_TIMER_Hr BCM89500_A0_READ_EEE_WAKE_TIMER_Hr
#define WRITE_EEE_WAKE_TIMER_Hr BCM89500_A0_WRITE_EEE_WAKE_TIMER_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_WAKE_TIMER_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_WAKE_TIMER_H_IMP
 * BLOCKS:   CPIC
 * DESC:     EEE Port 8(IMP) Wake Transition Timer - 100M Registers
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_H_IMP EEE wake transition delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr 0x000092c2

#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_H_IMP.
 *
 */
typedef union BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_h_imp[1];
	uint32_t _eee_wake_timer_h_imp;
} BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_t;

#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_CLR(r) (r).eee_wake_timer_h_imp[0] = 0
#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_SET(r,d) (r).eee_wake_timer_h_imp[0] = d
#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_GET(r) (r).eee_wake_timer_h_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_GET(r) (((r).eee_wake_timer_h_imp[0]) & 0xffff)
#define BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_SET(r,f) (r).eee_wake_timer_h_imp[0]=(((r).eee_wake_timer_h_imp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_H_IMP.
 *
 */
#define BCM89500_A0_READ_EEE_WAKE_TIMER_H_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_WAKE_TIMER_H_IMPr,(r._eee_wake_timer_h_imp),2)
#define BCM89500_A0_WRITE_EEE_WAKE_TIMER_H_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_WAKE_TIMER_H_IMPr,&(r._eee_wake_timer_h_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_H_IMPr BCM89500_A0_EEE_WAKE_TIMER_H_IMPr
#define EEE_WAKE_TIMER_H_IMPr_SIZE BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_SIZE
typedef BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_t EEE_WAKE_TIMER_H_IMPr_t;
#define EEE_WAKE_TIMER_H_IMPr_CLR BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_CLR
#define EEE_WAKE_TIMER_H_IMPr_SET BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_SET
#define EEE_WAKE_TIMER_H_IMPr_GET BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_GET
#define EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_GET BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_GET
#define EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_SET BCM89500_A0_EEE_WAKE_TIMER_H_IMPr_WAKE_TIMER_H_IMPf_SET
#define READ_EEE_WAKE_TIMER_H_IMPr BCM89500_A0_READ_EEE_WAKE_TIMER_H_IMPr
#define WRITE_EEE_WAKE_TIMER_H_IMPr BCM89500_A0_WRITE_EEE_WAKE_TIMER_H_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_WAKE_TIMER_H_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EEE_WAKE_TIMER_H_P7
 * BLOCKS:   GPIC7
 * DESC:     EEE Port 7 Wake Transition Timer - 100M Registers (polar feature)
 * SIZE:     16
 * FIELDS:
 *     WAKE_TIMER_H     EEE wake transition delay timer load value for 100M operation.The unit is 1usec.
 *
 ******************************************************************************/
#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r 0x000092c0

#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r_SIZE 2

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER_H_P7.
 *
 */
typedef union BCM89500_A0_EEE_WAKE_TIMER_H_P7r_s {
	uint32_t v[1];
	uint32_t eee_wake_timer_h_p7[1];
	uint32_t _eee_wake_timer_h_p7;
} BCM89500_A0_EEE_WAKE_TIMER_H_P7r_t;

#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r_CLR(r) (r).eee_wake_timer_h_p7[0] = 0
#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r_SET(r,d) (r).eee_wake_timer_h_p7[0] = d
#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r_GET(r) (r).eee_wake_timer_h_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r_WAKE_TIMER_Hf_GET(r) (((r).eee_wake_timer_h_p7[0]) & 0xffff)
#define BCM89500_A0_EEE_WAKE_TIMER_H_P7r_WAKE_TIMER_Hf_SET(r,f) (r).eee_wake_timer_h_p7[0]=(((r).eee_wake_timer_h_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER_H_P7.
 *
 */
#define BCM89500_A0_READ_EEE_WAKE_TIMER_H_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EEE_WAKE_TIMER_H_P7r,(r._eee_wake_timer_h_p7),2)
#define BCM89500_A0_WRITE_EEE_WAKE_TIMER_H_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EEE_WAKE_TIMER_H_P7r,&(r._eee_wake_timer_h_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMER_H_P7r BCM89500_A0_EEE_WAKE_TIMER_H_P7r
#define EEE_WAKE_TIMER_H_P7r_SIZE BCM89500_A0_EEE_WAKE_TIMER_H_P7r_SIZE
typedef BCM89500_A0_EEE_WAKE_TIMER_H_P7r_t EEE_WAKE_TIMER_H_P7r_t;
#define EEE_WAKE_TIMER_H_P7r_CLR BCM89500_A0_EEE_WAKE_TIMER_H_P7r_CLR
#define EEE_WAKE_TIMER_H_P7r_SET BCM89500_A0_EEE_WAKE_TIMER_H_P7r_SET
#define EEE_WAKE_TIMER_H_P7r_GET BCM89500_A0_EEE_WAKE_TIMER_H_P7r_GET
#define EEE_WAKE_TIMER_H_P7r_WAKE_TIMER_Hf_GET BCM89500_A0_EEE_WAKE_TIMER_H_P7r_WAKE_TIMER_Hf_GET
#define EEE_WAKE_TIMER_H_P7r_WAKE_TIMER_Hf_SET BCM89500_A0_EEE_WAKE_TIMER_H_P7r_WAKE_TIMER_Hf_SET
#define READ_EEE_WAKE_TIMER_H_P7r BCM89500_A0_READ_EEE_WAKE_TIMER_H_P7r
#define WRITE_EEE_WAKE_TIMER_H_P7r BCM89500_A0_WRITE_EEE_WAKE_TIMER_H_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EEE_WAKE_TIMER_H_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_MSK      Egress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-5 = Port0-5Bit 7 = Port7Bit 8 = IMP Port.
 *     RESERVED         Reserved
 *     OUT_DIV_EN       Egress Divider Enable.Mirror every nth transmitted frame (n=OUT_MIRROR_DIV + 1) that has passed through the OUT_MIRROR_FILTER.
 *     OUT_MIR_FLTR     Egress Mirror Filter.Defines the conditions under which frames transmitted on a port that has been selected in the OUT_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all egress frames.01: Mirror all transmitted frames with DA = OUT_MIROR_MAC.10: Mirror all transmitted frames with SA = OUT_MIRROR_MAC.11: Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EGMIRCTLr 0x0000021c

#define BCM89500_A0_EGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRCTL.
 *
 */
typedef union BCM89500_A0_EGMIRCTLr_s {
	uint32_t v[1];
	uint32_t egmirctl[1];
	uint32_t _egmirctl;
} BCM89500_A0_EGMIRCTLr_t;

#define BCM89500_A0_EGMIRCTLr_CLR(r) (r).egmirctl[0] = 0
#define BCM89500_A0_EGMIRCTLr_SET(r,d) (r).egmirctl[0] = d
#define BCM89500_A0_EGMIRCTLr_GET(r) (r).egmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) (((r).egmirctl[0]) & 0x1ff)
#define BCM89500_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_EGMIRCTLr_RESERVEDf_GET(r) ((((r).egmirctl[0]) >> 9) & 0xf)
#define BCM89500_A0_EGMIRCTLr_RESERVEDf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM89500_A0_EGMIRCTLr_OUT_DIV_ENf_GET(r) ((((r).egmirctl[0]) >> 13) & 0x1)
#define BCM89500_A0_EGMIRCTLr_OUT_DIV_ENf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET(r) ((((r).egmirctl[0]) >> 14) & 0x3)
#define BCM89500_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access EGMIRCTL.
 *
 */
#define BCM89500_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGMIRCTLr,(r._egmirctl),2)
#define BCM89500_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGMIRCTLr,&(r._egmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM89500_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM89500_A0_EGMIRCTLr_SIZE
typedef BCM89500_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM89500_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM89500_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM89500_A0_EGMIRCTLr_GET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM89500_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM89500_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_RESERVEDf_GET BCM89500_A0_EGMIRCTLr_RESERVEDf_GET
#define EGMIRCTLr_RESERVEDf_SET BCM89500_A0_EGMIRCTLr_RESERVEDf_SET
#define EGMIRCTLr_OUT_DIV_ENf_GET BCM89500_A0_EGMIRCTLr_OUT_DIV_ENf_GET
#define EGMIRCTLr_OUT_DIV_ENf_SET BCM89500_A0_EGMIRCTLr_OUT_DIV_ENf_SET
#define EGMIRCTLr_OUT_MIR_FLTRf_GET BCM89500_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET
#define EGMIRCTLr_OUT_MIR_FLTRf_SET BCM89500_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET
#define READ_EGMIRCTLr BCM89500_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM89500_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_DIV      Egress Mirror Divider.Transmit frames that have passed the OUT_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the OUT_DIV_EN bit in the Egress Mirror Control register is set, frames that pass the OUT_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only cp reg_profile.dat reg_profile.dat.julia6one in n frames (where n = OUT_MIRROR_DIV + 1) will be mirrored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EGMIRDIVr 0x0000021e

#define BCM89500_A0_EGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRDIV.
 *
 */
typedef union BCM89500_A0_EGMIRDIVr_s {
	uint32_t v[1];
	uint32_t egmirdiv[1];
	uint32_t _egmirdiv;
} BCM89500_A0_EGMIRDIVr_t;

#define BCM89500_A0_EGMIRDIVr_CLR(r) (r).egmirdiv[0] = 0
#define BCM89500_A0_EGMIRDIVr_SET(r,d) (r).egmirdiv[0] = d
#define BCM89500_A0_EGMIRDIVr_GET(r) (r).egmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGMIRDIVr_OUT_MIR_DIVf_GET(r) (((r).egmirdiv[0]) & 0x3ff)
#define BCM89500_A0_EGMIRDIVr_OUT_MIR_DIVf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_EGMIRDIVr_RESERVEDf_GET(r) ((((r).egmirdiv[0]) >> 10) & 0x3f)
#define BCM89500_A0_EGMIRDIVr_RESERVEDf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EGMIRDIV.
 *
 */
#define BCM89500_A0_READ_EGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGMIRDIVr,(r._egmirdiv),2)
#define BCM89500_A0_WRITE_EGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGMIRDIVr,&(r._egmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRDIVr BCM89500_A0_EGMIRDIVr
#define EGMIRDIVr_SIZE BCM89500_A0_EGMIRDIVr_SIZE
typedef BCM89500_A0_EGMIRDIVr_t EGMIRDIVr_t;
#define EGMIRDIVr_CLR BCM89500_A0_EGMIRDIVr_CLR
#define EGMIRDIVr_SET BCM89500_A0_EGMIRDIVr_SET
#define EGMIRDIVr_GET BCM89500_A0_EGMIRDIVr_GET
#define EGMIRDIVr_OUT_MIR_DIVf_GET BCM89500_A0_EGMIRDIVr_OUT_MIR_DIVf_GET
#define EGMIRDIVr_OUT_MIR_DIVf_SET BCM89500_A0_EGMIRDIVr_OUT_MIR_DIVf_SET
#define EGMIRDIVr_RESERVEDf_GET BCM89500_A0_EGMIRDIVr_RESERVEDf_GET
#define EGMIRDIVr_RESERVEDf_SET BCM89500_A0_EGMIRDIVr_RESERVEDf_SET
#define READ_EGMIRDIVr BCM89500_A0_READ_EGMIRDIVr
#define WRITE_EGMIRDIVr BCM89500_A0_WRITE_EGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Egress Mirror MAC Address Register
 * SIZE:     48
 * FIELDS:
 *     OUT_MIR_MAC      Egress Mirror MAC Address.MAC address that will be compared against engress frames in accordance with the OUT_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM89500_A0_EGMIRMACr 0x00000220

#define BCM89500_A0_EGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program EGMIRMAC.
 *
 */
typedef union BCM89500_A0_EGMIRMACr_s {
	uint32_t v[2];
	uint32_t egmirmac[2];
	uint32_t _egmirmac;
} BCM89500_A0_EGMIRMACr_t;

#define BCM89500_A0_EGMIRMACr_CLR(r) CDK_MEMSET(&((r)._egmirmac), 0, sizeof(BCM89500_A0_EGMIRMACr_t))
#define BCM89500_A0_EGMIRMACr_SET(r,i,d) (r).egmirmac[i] = d
#define BCM89500_A0_EGMIRMACr_GET(r,i) (r).egmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGMIRMACr_OUT_MIR_MACf_GET(r,a) cdk_field_get((r).egmirmac,0,47,a)
#define BCM89500_A0_EGMIRMACr_OUT_MIR_MACf_SET(r,a) cdk_field_set((r).egmirmac,0,47,a)

/*
 * These macros can be used to access EGMIRMAC.
 *
 */
#define BCM89500_A0_READ_EGMIRMACr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGMIRMACr,(r._egmirmac),6)
#define BCM89500_A0_WRITE_EGMIRMACr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGMIRMACr,&(r._egmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRMACr BCM89500_A0_EGMIRMACr
#define EGMIRMACr_SIZE BCM89500_A0_EGMIRMACr_SIZE
typedef BCM89500_A0_EGMIRMACr_t EGMIRMACr_t;
#define EGMIRMACr_CLR BCM89500_A0_EGMIRMACr_CLR
#define EGMIRMACr_SET BCM89500_A0_EGMIRMACr_SET
#define EGMIRMACr_GET BCM89500_A0_EGMIRMACr_GET
#define EGMIRMACr_OUT_MIR_MACf_GET BCM89500_A0_EGMIRMACr_OUT_MIR_MACf_GET
#define EGMIRMACr_OUT_MIR_MACf_SET BCM89500_A0_EGMIRMACr_OUT_MIR_MACf_SET
#define READ_EGMIRMACr BCM89500_A0_READ_EGMIRMACr
#define WRITE_EGMIRMACr BCM89500_A0_WRITE_EGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGRESS_PKT_TC2PCP_MAP
 * BLOCKS:   GPIC0
 * DESC:     Port N, Egress Packet TC to PCP mapping Register
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  The {CFI,PCP} Field for {RV,TC} = {0,0}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC1  The {CFI,PCP} Field for {RV,TC} = {0,1}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC2  The {CFI,PCP} Field for {RV,TC} = {0,2}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC3  The {CFI,PCP} Field for {RV,TC} = {0,3}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC4  The {CFI,PCP} Field for {RV,TC} = {0,4}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC5  The {CFI,PCP} Field for {RV,TC} = {0,5}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC6  The {CFI,PCP} Field for {RV,TC} = {0,6}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC7  The {CFI,PCP} Field for {RV,TC} = {0,7}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC0  The {CFI,PCP} Field for {RV,TC} = {1,0}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC1  The {CFI,PCP} Field for {RV,TC} = {1,1}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC2  The {CFI,PCP} Field for {RV,TC} = {1,2}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC3  The {CFI,PCP} Field for {RV,TC} = {1,3}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC4  The {CFI,PCP} Field for {RV,TC} = {1,4}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC5  The {CFI,PCP} Field for {RV,TC} = {1,5}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC6  The {CFI,PCP} Field for {RV,TC} = {1,6}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC7  The {CFI,PCP} Field for {RV,TC} = {1,7}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *
 ******************************************************************************/
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr 0x00009110

#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_PKT_TC2PCP_MAP.
 *
 */
typedef union BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_s {
	uint32_t v[2];
	uint32_t egress_pkt_tc2pcp_map[2];
	uint32_t _egress_pkt_tc2pcp_map;
} BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_t;

#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_CLR(r) CDK_MEMSET(&((r)._egress_pkt_tc2pcp_map), 0, sizeof(BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_t))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_SET(r,i,d) (r).egress_pkt_tc2pcp_map[i] = d
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_GET(r,i) (r).egress_pkt_tc2pcp_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_pkt_tc2pcp_map[0]) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 8) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 12) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 16) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 20) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 24) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_pkt_tc2pcp_map[0]) >> 28) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_pkt_tc2pcp_map[0]=(((r).egress_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_GET(r) (((r).egress_pkt_tc2pcp_map[1]) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 8) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 12) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 16) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 20) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 24) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_GET(r) ((((r).egress_pkt_tc2pcp_map[1]) >> 28) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_SET(r,f) (r).egress_pkt_tc2pcp_map[1]=(((r).egress_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGRESS_PKT_TC2PCP_MAP.
 *
 */
#define BCM89500_A0_READ_EGRESS_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr,(r._egress_pkt_tc2pcp_map),8)
#define BCM89500_A0_WRITE_EGRESS_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr,&(r._egress_pkt_tc2pcp_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_PKT_TC2PCP_MAPr BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr
#define EGRESS_PKT_TC2PCP_MAPr_SIZE BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_SIZE
typedef BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_t EGRESS_PKT_TC2PCP_MAPr_t;
#define EGRESS_PKT_TC2PCP_MAPr_CLR BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_CLR
#define EGRESS_PKT_TC2PCP_MAPr_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_SET
#define EGRESS_PKT_TC2PCP_MAPr_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_SET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_GET
#define EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_SET
#define READ_EGRESS_PKT_TC2PCP_MAPr BCM89500_A0_READ_EGRESS_PKT_TC2PCP_MAPr
#define WRITE_EGRESS_PKT_TC2PCP_MAPr BCM89500_A0_WRITE_EGRESS_PKT_TC2PCP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGRESS_PKT_TC2PCP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGRESS_PKT_TC2PCP_MAP_IMP
 * BLOCKS:   SYS
 * DESC:     Port8, Egress Packet TC to PCP mapping Register
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  The {CFI,PCP} Field for {RV,TC} = {0,0}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC1  The {CFI,PCP} Field for {RV,TC} = {0,1}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC2  The {CFI,PCP} Field for {RV,TC} = {0,2}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC3  The {CFI,PCP} Field for {RV,TC} = {0,3}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC4  The {CFI,PCP} Field for {RV,TC} = {0,4}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC5  The {CFI,PCP} Field for {RV,TC} = {0,5}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC6  The {CFI,PCP} Field for {RV,TC} = {0,6}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC7  The {CFI,PCP} Field for {RV,TC} = {0,7}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC0  The {CFI,PCP} Field for {RV,TC} = {1,0}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC1  The {CFI,PCP} Field for {RV,TC} = {1,1}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC2  The {CFI,PCP} Field for {RV,TC} = {1,2}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC3  The {CFI,PCP} Field for {RV,TC} = {1,3}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC4  The {CFI,PCP} Field for {RV,TC} = {1,4}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC5  The {CFI,PCP} Field for {RV,TC} = {1,5}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC6  The {CFI,PCP} Field for {RV,TC} = {1,6}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC7  The {CFI,PCP} Field for {RV,TC} = {1,7}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *
 ******************************************************************************/
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr 0x00009150

#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_PKT_TC2PCP_MAP_IMP.
 *
 */
typedef union BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_s {
	uint32_t v[2];
	uint32_t egress_pkt_tc2pcp_map_imp[2];
	uint32_t _egress_pkt_tc2pcp_map_imp;
} BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_t;

#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_CLR(r) CDK_MEMSET(&((r)._egress_pkt_tc2pcp_map_imp), 0, sizeof(BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_t))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_SET(r,i,d) (r).egress_pkt_tc2pcp_map_imp[i] = d
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_GET(r,i) (r).egress_pkt_tc2pcp_map_imp[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_pkt_tc2pcp_map_imp[0]) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 8) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 12) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 16) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 20) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 24) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[0]) >> 28) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[0]=(((r).egress_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_GET(r) (((r).egress_pkt_tc2pcp_map_imp[1]) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 8) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 12) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 16) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 20) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 24) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_GET(r) ((((r).egress_pkt_tc2pcp_map_imp[1]) >> 28) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_SET(r,f) (r).egress_pkt_tc2pcp_map_imp[1]=(((r).egress_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGRESS_PKT_TC2PCP_MAP_IMP.
 *
 */
#define BCM89500_A0_READ_EGRESS_PKT_TC2PCP_MAP_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr,(r._egress_pkt_tc2pcp_map_imp),8)
#define BCM89500_A0_WRITE_EGRESS_PKT_TC2PCP_MAP_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr,&(r._egress_pkt_tc2pcp_map_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_PKT_TC2PCP_MAP_IMPr BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr
#define EGRESS_PKT_TC2PCP_MAP_IMPr_SIZE BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_SIZE
typedef BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_t EGRESS_PKT_TC2PCP_MAP_IMPr_t;
#define EGRESS_PKT_TC2PCP_MAP_IMPr_CLR BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_CLR
#define EGRESS_PKT_TC2PCP_MAP_IMPr_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_SET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_GET
#define EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_SET
#define READ_EGRESS_PKT_TC2PCP_MAP_IMPr BCM89500_A0_READ_EGRESS_PKT_TC2PCP_MAP_IMPr
#define WRITE_EGRESS_PKT_TC2PCP_MAP_IMPr BCM89500_A0_WRITE_EGRESS_PKT_TC2PCP_MAP_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGRESS_PKT_TC2PCP_MAP_P7
 * BLOCKS:   SYS
 * DESC:     Port7, Egress Packet TC to PCP mapping Register (polar feature)
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  The {CFI,PCP} Field for {RV,TC} = {0,0}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC1  The {CFI,PCP} Field for {RV,TC} = {0,1}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC2  The {CFI,PCP} Field for {RV,TC} = {0,2}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC3  The {CFI,PCP} Field for {RV,TC} = {0,3}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC4  The {CFI,PCP} Field for {RV,TC} = {0,4}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC5  The {CFI,PCP} Field for {RV,TC} = {0,5}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC6  The {CFI,PCP} Field for {RV,TC} = {0,6}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV0_TC7  The {CFI,PCP} Field for {RV,TC} = {0,7}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC0  The {CFI,PCP} Field for {RV,TC} = {1,0}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC1  The {CFI,PCP} Field for {RV,TC} = {1,1}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC2  The {CFI,PCP} Field for {RV,TC} = {1,2}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC3  The {CFI,PCP} Field for {RV,TC} = {1,3}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC4  The {CFI,PCP} Field for {RV,TC} = {1,4}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC5  The {CFI,PCP} Field for {RV,TC} = {1,5}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC6  The {CFI,PCP} Field for {RV,TC} = {1,6}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *     PCP_FOR_RV1_TC7  The {CFI,PCP} Field for {RV,TC} = {1,7}; where RV means the CFP rate violations. When the packet doesn't go through CFP lookup, the RV is zero.
 *
 ******************************************************************************/
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r 0x00009148

#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_PKT_TC2PCP_MAP_P7.
 *
 */
typedef union BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_s {
	uint32_t v[2];
	uint32_t egress_pkt_tc2pcp_map_p7[2];
	uint32_t _egress_pkt_tc2pcp_map_p7;
} BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_t;

#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_CLR(r) CDK_MEMSET(&((r)._egress_pkt_tc2pcp_map_p7), 0, sizeof(BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_t))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_SET(r,i,d) (r).egress_pkt_tc2pcp_map_p7[i] = d
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_GET(r,i) (r).egress_pkt_tc2pcp_map_p7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_pkt_tc2pcp_map_p7[0]) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 8) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 12) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 16) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 20) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 24) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[0]) >> 28) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[0]=(((r).egress_pkt_tc2pcp_map_p7[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC0f_GET(r) (((r).egress_pkt_tc2pcp_map_p7[1]) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC0f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC1f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC1f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC2f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 8) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC2f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC3f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 12) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC3f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC4f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 16) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC4f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC5f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 20) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC5f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC6f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 24) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC6f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC7f_GET(r) ((((r).egress_pkt_tc2pcp_map_p7[1]) >> 28) & 0xf)
#define BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC7f_SET(r,f) (r).egress_pkt_tc2pcp_map_p7[1]=(((r).egress_pkt_tc2pcp_map_p7[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGRESS_PKT_TC2PCP_MAP_P7.
 *
 */
#define BCM89500_A0_READ_EGRESS_PKT_TC2PCP_MAP_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r,(r._egress_pkt_tc2pcp_map_p7),8)
#define BCM89500_A0_WRITE_EGRESS_PKT_TC2PCP_MAP_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r,&(r._egress_pkt_tc2pcp_map_p7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_PKT_TC2PCP_MAP_P7r BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r
#define EGRESS_PKT_TC2PCP_MAP_P7r_SIZE BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_SIZE
typedef BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_t EGRESS_PKT_TC2PCP_MAP_P7r_t;
#define EGRESS_PKT_TC2PCP_MAP_P7r_CLR BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_CLR
#define EGRESS_PKT_TC2PCP_MAP_P7r_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC0f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC0f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC0f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC0f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC1f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC1f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC1f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC1f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC2f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC2f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC2f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC2f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC3f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC3f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC3f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC3f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC4f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC4f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC4f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC4f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC5f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC5f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC5f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC5f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC6f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC6f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC6f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC6f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC7f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC7f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC7f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV0_TC7f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC0f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC0f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC0f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC0f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC1f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC1f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC1f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC1f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC2f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC2f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC2f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC2f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC3f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC3f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC3f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC3f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC4f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC4f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC4f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC4f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC5f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC5f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC5f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC5f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC6f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC6f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC6f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC6f_SET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC7f_GET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC7f_GET
#define EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC7f_SET BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r_PCP_FOR_RV1_TC7f_SET
#define READ_EGRESS_PKT_TC2PCP_MAP_P7r BCM89500_A0_READ_EGRESS_PKT_TC2PCP_MAP_P7r
#define WRITE_EGRESS_PKT_TC2PCP_MAP_P7r BCM89500_A0_WRITE_EGRESS_PKT_TC2PCP_MAP_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGRESS_PKT_TC2PCP_MAP_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  EGRESS_VID_REMARK
 * BLOCKS:   SYS
 * DESC:     Egress VID Remark table(Per port(0,1,2,3,4,5,cpu) 255 entries)
 * SIZE:     32
 * FIELDS:
 *     INNER_VID        Inner VID for modification
 *     INNER_OP         Inner Tag Operation,b00: as isb01: as receivedb10: removedb11: VID remarking
 *     RESERVED_1R      Reserved
 *     OUTER_VID        Outer VID for modification
 *     OUTER_OP         Outer Tag Operation,b00: as isb01: as receivedb10: removedb11: VID remarking
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EGRESS_VID_REMARKm 0x00003200

#define BCM89500_A0_EGRESS_VID_REMARKm_MIN 0
#define BCM89500_A0_EGRESS_VID_REMARKm_MAX 1791
#define BCM89500_A0_EGRESS_VID_REMARKm_CMAX(u) 1791
#define BCM89500_A0_EGRESS_VID_REMARKm_SIZE 4

/*
 * This structure should be used to declare and program EGRESS_VID_REMARK.
 *
 */
typedef union BCM89500_A0_EGRESS_VID_REMARKm_s {
	uint32_t v[1];
	uint32_t egress_vid_remark[1];
	uint32_t _egress_vid_remark;
} BCM89500_A0_EGRESS_VID_REMARKm_t;

#define BCM89500_A0_EGRESS_VID_REMARKm_CLR(r) (r).egress_vid_remark[0] = 0
#define BCM89500_A0_EGRESS_VID_REMARKm_SET(r,d) (r).egress_vid_remark[0] = d
#define BCM89500_A0_EGRESS_VID_REMARKm_GET(r) (r).egress_vid_remark[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGRESS_VID_REMARKm_INNER_VIDf_GET(r) (((r).egress_vid_remark[0]) & 0xfff)
#define BCM89500_A0_EGRESS_VID_REMARKm_INNER_VIDf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_EGRESS_VID_REMARKm_INNER_OPf_GET(r) ((((r).egress_vid_remark[0]) >> 12) & 0x3)
#define BCM89500_A0_EGRESS_VID_REMARKm_INNER_OPf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_GET(r) ((((r).egress_vid_remark[0]) >> 14) & 0x3)
#define BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM89500_A0_EGRESS_VID_REMARKm_OUTER_VIDf_GET(r) ((((r).egress_vid_remark[0]) >> 16) & 0xfff)
#define BCM89500_A0_EGRESS_VID_REMARKm_OUTER_VIDf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_EGRESS_VID_REMARKm_OUTER_OPf_GET(r) ((((r).egress_vid_remark[0]) >> 28) & 0x3)
#define BCM89500_A0_EGRESS_VID_REMARKm_OUTER_OPf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_GET(r) ((((r).egress_vid_remark[0]) >> 30) & 0x3)
#define BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access EGRESS_VID_REMARK.
 *
 */
#define BCM89500_A0_READ_EGRESS_VID_REMARKm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_EGRESS_VID_REMARKm,i,(m),4)
#define BCM89500_A0_WRITE_EGRESS_VID_REMARKm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_EGRESS_VID_REMARKm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_VID_REMARKm BCM89500_A0_EGRESS_VID_REMARKm
#define EGRESS_VID_REMARKm_MIN BCM89500_A0_EGRESS_VID_REMARKm_MIN
#define EGRESS_VID_REMARKm_MAX BCM89500_A0_EGRESS_VID_REMARKm_MAX
#define EGRESS_VID_REMARKm_CMAX(u) BCM89500_A0_EGRESS_VID_REMARKm_CMAX(u)
#define EGRESS_VID_REMARKm_SIZE BCM89500_A0_EGRESS_VID_REMARKm_SIZE
typedef BCM89500_A0_EGRESS_VID_REMARKm_t EGRESS_VID_REMARKm_t;
#define EGRESS_VID_REMARKm_CLR BCM89500_A0_EGRESS_VID_REMARKm_CLR
#define EGRESS_VID_REMARKm_SET BCM89500_A0_EGRESS_VID_REMARKm_SET
#define EGRESS_VID_REMARKm_GET BCM89500_A0_EGRESS_VID_REMARKm_GET
#define EGRESS_VID_REMARKm_INNER_VIDf_GET BCM89500_A0_EGRESS_VID_REMARKm_INNER_VIDf_GET
#define EGRESS_VID_REMARKm_INNER_VIDf_SET BCM89500_A0_EGRESS_VID_REMARKm_INNER_VIDf_SET
#define EGRESS_VID_REMARKm_INNER_OPf_GET BCM89500_A0_EGRESS_VID_REMARKm_INNER_OPf_GET
#define EGRESS_VID_REMARKm_INNER_OPf_SET BCM89500_A0_EGRESS_VID_REMARKm_INNER_OPf_SET
#define EGRESS_VID_REMARKm_RESERVED_1Rf_GET BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_GET
#define EGRESS_VID_REMARKm_RESERVED_1Rf_SET BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_SET
#define EGRESS_VID_REMARKm_OUTER_VIDf_GET BCM89500_A0_EGRESS_VID_REMARKm_OUTER_VIDf_GET
#define EGRESS_VID_REMARKm_OUTER_VIDf_SET BCM89500_A0_EGRESS_VID_REMARKm_OUTER_VIDf_SET
#define EGRESS_VID_REMARKm_OUTER_OPf_GET BCM89500_A0_EGRESS_VID_REMARKm_OUTER_OPf_GET
#define EGRESS_VID_REMARKm_OUTER_OPf_SET BCM89500_A0_EGRESS_VID_REMARKm_OUTER_OPf_SET
#define EGRESS_VID_REMARKm_RESERVED_2Rf_GET BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_GET
#define EGRESS_VID_REMARKm_RESERVED_2Rf_SET BCM89500_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_SET
#define READ_EGRESS_VID_REMARKm BCM89500_A0_READ_EGRESS_VID_REMARKm
#define WRITE_EGRESS_VID_REMARKm BCM89500_A0_WRITE_EGRESS_VID_REMARKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGRESS_VID_REMARKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGRESS_VID_RMK_TBL_ACS
 * BLOCKS:   SYS
 * DESC:     Egress VID Remarking Table Access Register
 * SIZE:     32
 * FIELDS:
 *     START_DONE       Operation StartSoftware set this bit to start the operation after having configured all the nessary operation related information to the registers.Harware automatically clear this bit when the operation is done. For read and write operation, this bit is clear when a single read or write operation is done.
 *     OP               Operation1'b0: Read operation(the data read from the table is specified in the Egress VID remarking Table DATA Register)1'b1: Write operation(the data to be written to the table is specified in the Egress VID remarking Table Data Register)
 *     RESET_EVT        Clear All EVT TablesWhen this bit is set, it reset sll the EVT tables. This bit will be auto-cleared by hardware when the reset is done.
 *     RESERVED2        Reserved
 *     EGRESS_PORT      Egress Port SelectThis field selects which egress port of the VID remarking table is selected for the access.4'b0000: port 04'b0001: port 14'b0010: port 24'b0011: port 34'b0100: port 44'b0101: port 54'b0111: port 74'b1000: port 8(IMP port)Others: reserved
 *     TBL_ADDR         VID remarking table addressThis field define the address of the VID remarking table, from address 0 to addres 255.
 *     RESERVED1        Reserved
 *     GLOBAL_WR_EN     Global Write Enable(Not2Release)When this bit is set, all the egress VID table are write simultaneously.
 *
 ******************************************************************************/
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr 0x00003440

#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_SIZE 4

/*
 * This structure should be used to declare and program EGRESS_VID_RMK_TBL_ACS.
 *
 */
typedef union BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_s {
	uint32_t v[1];
	uint32_t egress_vid_rmk_tbl_acs[1];
	uint32_t _egress_vid_rmk_tbl_acs;
} BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_t;

#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_CLR(r) (r).egress_vid_rmk_tbl_acs[0] = 0
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_SET(r,d) (r).egress_vid_rmk_tbl_acs[0] = d
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_GET(r) (r).egress_vid_rmk_tbl_acs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_GET(r) (((r).egress_vid_rmk_tbl_acs[0]) & 0x1)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 1) & 0x1)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 2) & 0x1)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2f_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 3) & 0x1)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2f_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORTf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 4) & 0xf)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORTf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 8) & 0xff)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1f_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 16) & 0x7fff)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1f_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 31) & 0x1)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access EGRESS_VID_RMK_TBL_ACS.
 *
 */
#define BCM89500_A0_READ_EGRESS_VID_RMK_TBL_ACSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr,(r._egress_vid_rmk_tbl_acs),4)
#define BCM89500_A0_WRITE_EGRESS_VID_RMK_TBL_ACSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr,&(r._egress_vid_rmk_tbl_acs),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_VID_RMK_TBL_ACSr BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr
#define EGRESS_VID_RMK_TBL_ACSr_SIZE BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_SIZE
typedef BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_t EGRESS_VID_RMK_TBL_ACSr_t;
#define EGRESS_VID_RMK_TBL_ACSr_CLR BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_CLR
#define EGRESS_VID_RMK_TBL_ACSr_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_SET
#define EGRESS_VID_RMK_TBL_ACSr_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_GET
#define EGRESS_VID_RMK_TBL_ACSr_START_DONEf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_GET
#define EGRESS_VID_RMK_TBL_ACSr_START_DONEf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_SET
#define EGRESS_VID_RMK_TBL_ACSr_OPf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_GET
#define EGRESS_VID_RMK_TBL_ACSr_OPf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_SET
#define EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_GET
#define EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_SET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED2f_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2f_GET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED2f_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2f_SET
#define EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORTf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORTf_GET
#define EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORTf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORTf_SET
#define EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_GET
#define EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_SET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED1f_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1f_GET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED1f_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1f_SET
#define EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_GET
#define EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_SET
#define READ_EGRESS_VID_RMK_TBL_ACSr BCM89500_A0_READ_EGRESS_VID_RMK_TBL_ACSr
#define WRITE_EGRESS_VID_RMK_TBL_ACSr BCM89500_A0_WRITE_EGRESS_VID_RMK_TBL_ACSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGRESS_VID_RMK_TBL_ACSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  EGRESS_VID_RMK_TBL_DATA
 * BLOCKS:   SYS
 * DESC:     Egress VID Remarking Table Data Register
 * SIZE:     32
 * FIELDS:
 *     INNER_VID        Inner VID for modificationThis field specifies the VID of the inner tag remarking. This field is only valid when the operation is set to '11', other than that this field is don't care.
 *     INNER_OP         Inner Tag OperationThis field specifies how the inner tag is modified.00: as is01: as received10: removed11: VID remarking
 *     RESERVED2        Reserved
 *     OUTER_VID        Outer VID for modificationThis field specifies the VID of the outer tag remarking. This field is only valid when the operation is set to '11', other than that this field is don't care.
 *     OUTER_OP         Outer Tag OperationThis field specifies how the outer tag is modified.00: as is01: as received10: removed11: VID remarking
 *     RESERVED1        Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr 0x00003444

#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_SIZE 4

/*
 * This structure should be used to declare and program EGRESS_VID_RMK_TBL_DATA.
 *
 */
typedef union BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_s {
	uint32_t v[1];
	uint32_t egress_vid_rmk_tbl_data[1];
	uint32_t _egress_vid_rmk_tbl_data;
} BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_t;

#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_CLR(r) (r).egress_vid_rmk_tbl_data[0] = 0
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_SET(r,d) (r).egress_vid_rmk_tbl_data[0] = d
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_GET(r) (r).egress_vid_rmk_tbl_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_GET(r) (((r).egress_vid_rmk_tbl_data[0]) & 0xfff)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 12) & 0x3)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2f_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 14) & 0x3)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2f_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 16) & 0xfff)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 28) & 0x3)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1f_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 30) & 0x3)
#define BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1f_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access EGRESS_VID_RMK_TBL_DATA.
 *
 */
#define BCM89500_A0_READ_EGRESS_VID_RMK_TBL_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr,(r._egress_vid_rmk_tbl_data),4)
#define BCM89500_A0_WRITE_EGRESS_VID_RMK_TBL_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr,&(r._egress_vid_rmk_tbl_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_VID_RMK_TBL_DATAr BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr
#define EGRESS_VID_RMK_TBL_DATAr_SIZE BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_SIZE
typedef BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_t EGRESS_VID_RMK_TBL_DATAr_t;
#define EGRESS_VID_RMK_TBL_DATAr_CLR BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_CLR
#define EGRESS_VID_RMK_TBL_DATAr_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_SET
#define EGRESS_VID_RMK_TBL_DATAr_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_GET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_GET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_SET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_GET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_SET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED2f_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2f_GET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED2f_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2f_SET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_GET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_SET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_GET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_SET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED1f_GET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1f_GET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED1f_SET BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1f_SET
#define READ_EGRESS_VID_RMK_TBL_DATAr BCM89500_A0_READ_EGRESS_VID_RMK_TBL_DATAr
#define WRITE_EGRESS_VID_RMK_TBL_DATAr BCM89500_A0_WRITE_EGRESS_VID_RMK_TBL_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_EGRESS_VID_RMK_TBL_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ENG_DET_INT_EN
 * BLOCKS:   SYS
 * DESC:     Energy Detection Interrupt Enable Register
 * SIZE:     16
 * FIELDS:
 *     ENG_DET_INT_EN   It is used to gate energy detect status interruptset "1" to enable interruptBit 0 map to port 0 Energy detection.....Bit 4 map to port 4 Energy detection 
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ENG_DET_INT_ENr 0x00000328

#define BCM89500_A0_ENG_DET_INT_ENr_SIZE 2

/*
 * This structure should be used to declare and program ENG_DET_INT_EN.
 *
 */
typedef union BCM89500_A0_ENG_DET_INT_ENr_s {
	uint32_t v[1];
	uint32_t eng_det_int_en[1];
	uint32_t _eng_det_int_en;
} BCM89500_A0_ENG_DET_INT_ENr_t;

#define BCM89500_A0_ENG_DET_INT_ENr_CLR(r) (r).eng_det_int_en[0] = 0
#define BCM89500_A0_ENG_DET_INT_ENr_SET(r,d) (r).eng_det_int_en[0] = d
#define BCM89500_A0_ENG_DET_INT_ENr_GET(r) (r).eng_det_int_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ENG_DET_INT_ENr_ENG_DET_INT_ENf_GET(r) (((r).eng_det_int_en[0]) & 0x1f)
#define BCM89500_A0_ENG_DET_INT_ENr_ENG_DET_INT_ENf_SET(r,f) (r).eng_det_int_en[0]=(((r).eng_det_int_en[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_ENG_DET_INT_ENr_RESERVED_0f_GET(r) ((((r).eng_det_int_en[0]) >> 5) & 0xf)
#define BCM89500_A0_ENG_DET_INT_ENr_RESERVED_0f_SET(r,f) (r).eng_det_int_en[0]=(((r).eng_det_int_en[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCM89500_A0_ENG_DET_INT_ENr_RESERVED_1f_GET(r) ((((r).eng_det_int_en[0]) >> 9) & 0x7f)
#define BCM89500_A0_ENG_DET_INT_ENr_RESERVED_1f_SET(r,f) (r).eng_det_int_en[0]=(((r).eng_det_int_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ENG_DET_INT_EN.
 *
 */
#define BCM89500_A0_READ_ENG_DET_INT_ENr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ENG_DET_INT_ENr,(r._eng_det_int_en),2)
#define BCM89500_A0_WRITE_ENG_DET_INT_ENr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ENG_DET_INT_ENr,&(r._eng_det_int_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ENG_DET_INT_ENr BCM89500_A0_ENG_DET_INT_ENr
#define ENG_DET_INT_ENr_SIZE BCM89500_A0_ENG_DET_INT_ENr_SIZE
typedef BCM89500_A0_ENG_DET_INT_ENr_t ENG_DET_INT_ENr_t;
#define ENG_DET_INT_ENr_CLR BCM89500_A0_ENG_DET_INT_ENr_CLR
#define ENG_DET_INT_ENr_SET BCM89500_A0_ENG_DET_INT_ENr_SET
#define ENG_DET_INT_ENr_GET BCM89500_A0_ENG_DET_INT_ENr_GET
#define ENG_DET_INT_ENr_ENG_DET_INT_ENf_GET BCM89500_A0_ENG_DET_INT_ENr_ENG_DET_INT_ENf_GET
#define ENG_DET_INT_ENr_ENG_DET_INT_ENf_SET BCM89500_A0_ENG_DET_INT_ENr_ENG_DET_INT_ENf_SET
#define ENG_DET_INT_ENr_RESERVED_0f_GET BCM89500_A0_ENG_DET_INT_ENr_RESERVED_0f_GET
#define ENG_DET_INT_ENr_RESERVED_0f_SET BCM89500_A0_ENG_DET_INT_ENr_RESERVED_0f_SET
#define ENG_DET_INT_ENr_RESERVED_1f_GET BCM89500_A0_ENG_DET_INT_ENr_RESERVED_1f_GET
#define ENG_DET_INT_ENr_RESERVED_1f_SET BCM89500_A0_ENG_DET_INT_ENr_RESERVED_1f_SET
#define READ_ENG_DET_INT_ENr BCM89500_A0_READ_ENG_DET_INT_ENr
#define WRITE_ENG_DET_INT_ENr BCM89500_A0_WRITE_ENG_DET_INT_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ENG_DET_INT_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ENG_DET_STS
 * BLOCKS:   SYS
 * DESC:     PHY Energy Detect Status Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     ENG_DET_STS      Energy Detect StatusPer bit indicates the energy detect status for each P4~P0.1=energy detected0=no energy detectedNote: If any of the register bit in Bit[12:8] of PHY Power Dwon Mode Register (Page 0x00, Offset 0x4a) is enabled, the corresponding port status bit in this register should be ignored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ENG_DET_STSr 0x00000192

#define BCM89500_A0_ENG_DET_STSr_SIZE 1

/*
 * This structure should be used to declare and program ENG_DET_STS.
 *
 */
typedef union BCM89500_A0_ENG_DET_STSr_s {
	uint32_t v[1];
	uint32_t eng_det_sts[1];
	uint32_t _eng_det_sts;
} BCM89500_A0_ENG_DET_STSr_t;

#define BCM89500_A0_ENG_DET_STSr_CLR(r) (r).eng_det_sts[0] = 0
#define BCM89500_A0_ENG_DET_STSr_SET(r,d) (r).eng_det_sts[0] = d
#define BCM89500_A0_ENG_DET_STSr_GET(r) (r).eng_det_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ENG_DET_STSr_ENG_DET_STSf_GET(r) (((r).eng_det_sts[0]) & 0x1f)
#define BCM89500_A0_ENG_DET_STSr_ENG_DET_STSf_SET(r,f) (r).eng_det_sts[0]=(((r).eng_det_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_ENG_DET_STSr_RESERVEDf_GET(r) ((((r).eng_det_sts[0]) >> 5) & 0x7)
#define BCM89500_A0_ENG_DET_STSr_RESERVEDf_SET(r,f) (r).eng_det_sts[0]=(((r).eng_det_sts[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access ENG_DET_STS.
 *
 */
#define BCM89500_A0_READ_ENG_DET_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ENG_DET_STSr,(r._eng_det_sts),1)
#define BCM89500_A0_WRITE_ENG_DET_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ENG_DET_STSr,&(r._eng_det_sts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ENG_DET_STSr BCM89500_A0_ENG_DET_STSr
#define ENG_DET_STSr_SIZE BCM89500_A0_ENG_DET_STSr_SIZE
typedef BCM89500_A0_ENG_DET_STSr_t ENG_DET_STSr_t;
#define ENG_DET_STSr_CLR BCM89500_A0_ENG_DET_STSr_CLR
#define ENG_DET_STSr_SET BCM89500_A0_ENG_DET_STSr_SET
#define ENG_DET_STSr_GET BCM89500_A0_ENG_DET_STSr_GET
#define ENG_DET_STSr_ENG_DET_STSf_GET BCM89500_A0_ENG_DET_STSr_ENG_DET_STSf_GET
#define ENG_DET_STSr_ENG_DET_STSf_SET BCM89500_A0_ENG_DET_STSr_ENG_DET_STSf_SET
#define ENG_DET_STSr_RESERVEDf_GET BCM89500_A0_ENG_DET_STSr_RESERVEDf_GET
#define ENG_DET_STSr_RESERVEDf_SET BCM89500_A0_ENG_DET_STSr_RESERVEDf_SET
#define READ_ENG_DET_STSr BCM89500_A0_READ_ENG_DET_STSr
#define WRITE_ENG_DET_STSr BCM89500_A0_WRITE_ENG_DET_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ENG_DET_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ENG_DET_STS_CHG
 * BLOCKS:   SYS
 * DESC:     PHY Energy Detect Status Change Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     ENG_DET_STS_CHG  Energy Detect Status ChangePer bit indicates that the energy detect status for each P4~P0 had changed since last read operation. Upon change of energy detect status, a bit remains set until cleared by a read operation.1=energy detect status changed0=no energy detect status change
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ENG_DET_STS_CHGr 0x00000193

#define BCM89500_A0_ENG_DET_STS_CHGr_SIZE 1

/*
 * This structure should be used to declare and program ENG_DET_STS_CHG.
 *
 */
typedef union BCM89500_A0_ENG_DET_STS_CHGr_s {
	uint32_t v[1];
	uint32_t eng_det_sts_chg[1];
	uint32_t _eng_det_sts_chg;
} BCM89500_A0_ENG_DET_STS_CHGr_t;

#define BCM89500_A0_ENG_DET_STS_CHGr_CLR(r) (r).eng_det_sts_chg[0] = 0
#define BCM89500_A0_ENG_DET_STS_CHGr_SET(r,d) (r).eng_det_sts_chg[0] = d
#define BCM89500_A0_ENG_DET_STS_CHGr_GET(r) (r).eng_det_sts_chg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ENG_DET_STS_CHGr_ENG_DET_STS_CHGf_GET(r) (((r).eng_det_sts_chg[0]) & 0x1f)
#define BCM89500_A0_ENG_DET_STS_CHGr_ENG_DET_STS_CHGf_SET(r,f) (r).eng_det_sts_chg[0]=(((r).eng_det_sts_chg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_ENG_DET_STS_CHGr_RESERVEDf_GET(r) ((((r).eng_det_sts_chg[0]) >> 5) & 0x7)
#define BCM89500_A0_ENG_DET_STS_CHGr_RESERVEDf_SET(r,f) (r).eng_det_sts_chg[0]=(((r).eng_det_sts_chg[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access ENG_DET_STS_CHG.
 *
 */
#define BCM89500_A0_READ_ENG_DET_STS_CHGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ENG_DET_STS_CHGr,(r._eng_det_sts_chg),1)
#define BCM89500_A0_WRITE_ENG_DET_STS_CHGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ENG_DET_STS_CHGr,&(r._eng_det_sts_chg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ENG_DET_STS_CHGr BCM89500_A0_ENG_DET_STS_CHGr
#define ENG_DET_STS_CHGr_SIZE BCM89500_A0_ENG_DET_STS_CHGr_SIZE
typedef BCM89500_A0_ENG_DET_STS_CHGr_t ENG_DET_STS_CHGr_t;
#define ENG_DET_STS_CHGr_CLR BCM89500_A0_ENG_DET_STS_CHGr_CLR
#define ENG_DET_STS_CHGr_SET BCM89500_A0_ENG_DET_STS_CHGr_SET
#define ENG_DET_STS_CHGr_GET BCM89500_A0_ENG_DET_STS_CHGr_GET
#define ENG_DET_STS_CHGr_ENG_DET_STS_CHGf_GET BCM89500_A0_ENG_DET_STS_CHGr_ENG_DET_STS_CHGf_GET
#define ENG_DET_STS_CHGr_ENG_DET_STS_CHGf_SET BCM89500_A0_ENG_DET_STS_CHGr_ENG_DET_STS_CHGf_SET
#define ENG_DET_STS_CHGr_RESERVEDf_GET BCM89500_A0_ENG_DET_STS_CHGr_RESERVEDf_GET
#define ENG_DET_STS_CHGr_RESERVEDf_SET BCM89500_A0_ENG_DET_STS_CHGr_RESERVEDf_SET
#define READ_ENG_DET_STS_CHGr BCM89500_A0_READ_ENG_DET_STS_CHGr
#define WRITE_ENG_DET_STS_CHGr BCM89500_A0_WRITE_ENG_DET_STS_CHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ENG_DET_STS_CHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FAST_AGE_CTRL
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_FAST_AGE_STATIC Set 1'b1 to Age out Static Entry.
 *     EN_AGE_DYNAMIC   Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_PORT      Set 1'b1 to Check Port ID
 *     EN_AGE_VLAN      Set 1'b1 to Check Vlan ID.
 *     EN_AGE_SPT       Set 1'b1 to check spanning Tree ID(refer to EN_802_1S/MSPT_AGE_MAP at page/address=43h/00h,02-05h)
 *     EN_AGE_MCAST     Enable Aging Multicast entry1: Aging multicast entries in ARL table0: Disable aging multicast entries in ARL table*** Note that the EN_AGE_MCAST and the EN_AGE_PORT can't enable(set to 1'b1) at same time.
 *     RESERVED         Reserved
 *     FAST_AGE_STR_DONE Set 1'b1 to trigger fast ageing process.When Fast aging process is done, this bit is cleared to 1'b0.
 *
 ******************************************************************************/
#define BCM89500_A0_FAST_AGE_CTRLr 0x00000088

#define BCM89500_A0_FAST_AGE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_CTRL.
 *
 */
typedef union BCM89500_A0_FAST_AGE_CTRLr_s {
	uint32_t v[1];
	uint32_t fast_age_ctrl[1];
	uint32_t _fast_age_ctrl;
} BCM89500_A0_FAST_AGE_CTRLr_t;

#define BCM89500_A0_FAST_AGE_CTRLr_CLR(r) (r).fast_age_ctrl[0] = 0
#define BCM89500_A0_FAST_AGE_CTRLr_SET(r,d) (r).fast_age_ctrl[0] = d
#define BCM89500_A0_FAST_AGE_CTRLr_GET(r) (r).fast_age_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET(r) (((r).fast_age_ctrl[0]) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET(r) ((((r).fast_age_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET(r) ((((r).fast_age_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET(r) ((((r).fast_age_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET(r) ((((r).fast_age_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET(r) ((((r).fast_age_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_FAST_AGE_CTRLr_RESERVEDf_GET(r) ((((r).fast_age_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_RESERVEDf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET(r) ((((r).fast_age_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FAST_AGE_CTRL.
 *
 */
#define BCM89500_A0_READ_FAST_AGE_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FAST_AGE_CTRLr,(r._fast_age_ctrl),1)
#define BCM89500_A0_WRITE_FAST_AGE_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FAST_AGE_CTRLr,&(r._fast_age_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_CTRLr BCM89500_A0_FAST_AGE_CTRLr
#define FAST_AGE_CTRLr_SIZE BCM89500_A0_FAST_AGE_CTRLr_SIZE
typedef BCM89500_A0_FAST_AGE_CTRLr_t FAST_AGE_CTRLr_t;
#define FAST_AGE_CTRLr_CLR BCM89500_A0_FAST_AGE_CTRLr_CLR
#define FAST_AGE_CTRLr_SET BCM89500_A0_FAST_AGE_CTRLr_SET
#define FAST_AGE_CTRLr_GET BCM89500_A0_FAST_AGE_CTRLr_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET BCM89500_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET BCM89500_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_GET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_SET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_GET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_SET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_GET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_SET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_GET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_SET BCM89500_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET
#define FAST_AGE_CTRLr_RESERVEDf_GET BCM89500_A0_FAST_AGE_CTRLr_RESERVEDf_GET
#define FAST_AGE_CTRLr_RESERVEDf_SET BCM89500_A0_FAST_AGE_CTRLr_RESERVEDf_SET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET BCM89500_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET BCM89500_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET
#define READ_FAST_AGE_CTRLr BCM89500_A0_READ_FAST_AGE_CTRLr
#define WRITE_FAST_AGE_CTRLr BCM89500_A0_WRITE_FAST_AGE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FAST_AGE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FAST_AGE_PORT
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Port Control Register
 * SIZE:     8
 * FIELDS:
 *     AGE_PORT         Select Fast Ageing Source Port.Select a specified Port ID to be aged-out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FAST_AGE_PORTr 0x00000089

#define BCM89500_A0_FAST_AGE_PORTr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_PORT.
 *
 */
typedef union BCM89500_A0_FAST_AGE_PORTr_s {
	uint32_t v[1];
	uint32_t fast_age_port[1];
	uint32_t _fast_age_port;
} BCM89500_A0_FAST_AGE_PORTr_t;

#define BCM89500_A0_FAST_AGE_PORTr_CLR(r) (r).fast_age_port[0] = 0
#define BCM89500_A0_FAST_AGE_PORTr_SET(r,d) (r).fast_age_port[0] = d
#define BCM89500_A0_FAST_AGE_PORTr_GET(r) (r).fast_age_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FAST_AGE_PORTr_AGE_PORTf_GET(r) (((r).fast_age_port[0]) & 0xf)
#define BCM89500_A0_FAST_AGE_PORTr_AGE_PORTf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_FAST_AGE_PORTr_RESERVEDf_GET(r) ((((r).fast_age_port[0]) >> 4) & 0xf)
#define BCM89500_A0_FAST_AGE_PORTr_RESERVEDf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access FAST_AGE_PORT.
 *
 */
#define BCM89500_A0_READ_FAST_AGE_PORTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FAST_AGE_PORTr,(r._fast_age_port),1)
#define BCM89500_A0_WRITE_FAST_AGE_PORTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FAST_AGE_PORTr,&(r._fast_age_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_PORTr BCM89500_A0_FAST_AGE_PORTr
#define FAST_AGE_PORTr_SIZE BCM89500_A0_FAST_AGE_PORTr_SIZE
typedef BCM89500_A0_FAST_AGE_PORTr_t FAST_AGE_PORTr_t;
#define FAST_AGE_PORTr_CLR BCM89500_A0_FAST_AGE_PORTr_CLR
#define FAST_AGE_PORTr_SET BCM89500_A0_FAST_AGE_PORTr_SET
#define FAST_AGE_PORTr_GET BCM89500_A0_FAST_AGE_PORTr_GET
#define FAST_AGE_PORTr_AGE_PORTf_GET BCM89500_A0_FAST_AGE_PORTr_AGE_PORTf_GET
#define FAST_AGE_PORTr_AGE_PORTf_SET BCM89500_A0_FAST_AGE_PORTr_AGE_PORTf_SET
#define FAST_AGE_PORTr_RESERVEDf_GET BCM89500_A0_FAST_AGE_PORTr_RESERVEDf_GET
#define FAST_AGE_PORTr_RESERVEDf_SET BCM89500_A0_FAST_AGE_PORTr_RESERVEDf_SET
#define READ_FAST_AGE_PORTr BCM89500_A0_READ_FAST_AGE_PORTr
#define WRITE_FAST_AGE_PORTr BCM89500_A0_WRITE_FAST_AGE_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FAST_AGE_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FAST_AGE_VID
 * BLOCKS:   SYS
 * DESC:     Fast Ageing VID Control Register
 * SIZE:     16
 * FIELDS:
 *     AGE_VID          Select Fast Ageing VLAN IDSelect a specified VLAN ID to be aged-out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FAST_AGE_VIDr 0x0000008a

#define BCM89500_A0_FAST_AGE_VIDr_SIZE 2

/*
 * This structure should be used to declare and program FAST_AGE_VID.
 *
 */
typedef union BCM89500_A0_FAST_AGE_VIDr_s {
	uint32_t v[1];
	uint32_t fast_age_vid[1];
	uint32_t _fast_age_vid;
} BCM89500_A0_FAST_AGE_VIDr_t;

#define BCM89500_A0_FAST_AGE_VIDr_CLR(r) (r).fast_age_vid[0] = 0
#define BCM89500_A0_FAST_AGE_VIDr_SET(r,d) (r).fast_age_vid[0] = d
#define BCM89500_A0_FAST_AGE_VIDr_GET(r) (r).fast_age_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FAST_AGE_VIDr_AGE_VIDf_GET(r) (((r).fast_age_vid[0]) & 0xfff)
#define BCM89500_A0_FAST_AGE_VIDr_AGE_VIDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_FAST_AGE_VIDr_RESERVEDf_GET(r) ((((r).fast_age_vid[0]) >> 12) & 0xf)
#define BCM89500_A0_FAST_AGE_VIDr_RESERVEDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access FAST_AGE_VID.
 *
 */
#define BCM89500_A0_READ_FAST_AGE_VIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FAST_AGE_VIDr,(r._fast_age_vid),2)
#define BCM89500_A0_WRITE_FAST_AGE_VIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FAST_AGE_VIDr,&(r._fast_age_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_VIDr BCM89500_A0_FAST_AGE_VIDr
#define FAST_AGE_VIDr_SIZE BCM89500_A0_FAST_AGE_VIDr_SIZE
typedef BCM89500_A0_FAST_AGE_VIDr_t FAST_AGE_VIDr_t;
#define FAST_AGE_VIDr_CLR BCM89500_A0_FAST_AGE_VIDr_CLR
#define FAST_AGE_VIDr_SET BCM89500_A0_FAST_AGE_VIDr_SET
#define FAST_AGE_VIDr_GET BCM89500_A0_FAST_AGE_VIDr_GET
#define FAST_AGE_VIDr_AGE_VIDf_GET BCM89500_A0_FAST_AGE_VIDr_AGE_VIDf_GET
#define FAST_AGE_VIDr_AGE_VIDf_SET BCM89500_A0_FAST_AGE_VIDr_AGE_VIDf_SET
#define FAST_AGE_VIDr_RESERVEDf_GET BCM89500_A0_FAST_AGE_VIDr_RESERVEDf_GET
#define FAST_AGE_VIDr_RESERVEDf_SET BCM89500_A0_FAST_AGE_VIDr_RESERVEDf_SET
#define READ_FAST_AGE_VIDr BCM89500_A0_READ_FAST_AGE_VIDr
#define WRITE_FAST_AGE_VIDr BCM89500_A0_WRITE_FAST_AGE_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FAST_AGE_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CHIP_INFO
 * BLOCKS:   SYS
 * DESC:     Chip Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     PRT_LINK         
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CHIP_INFOr 0x00000a9a

#define BCM89500_A0_FC_CHIP_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_CHIP_INFO.
 *
 */
typedef union BCM89500_A0_FC_CHIP_INFOr_s {
	uint32_t v[1];
	uint32_t fc_chip_info[1];
	uint32_t _fc_chip_info;
} BCM89500_A0_FC_CHIP_INFOr_t;

#define BCM89500_A0_FC_CHIP_INFOr_CLR(r) (r).fc_chip_info[0] = 0
#define BCM89500_A0_FC_CHIP_INFOr_SET(r,d) (r).fc_chip_info[0] = d
#define BCM89500_A0_FC_CHIP_INFOr_GET(r) (r).fc_chip_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CHIP_INFOr_PRT_LINKf_GET(r) (((r).fc_chip_info[0]) & 0x1ff)
#define BCM89500_A0_FC_CHIP_INFOr_PRT_LINKf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_FC_CHIP_INFOr_RESERVEDf_GET(r) ((((r).fc_chip_info[0]) >> 9) & 0x7f)
#define BCM89500_A0_FC_CHIP_INFOr_RESERVEDf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_CHIP_INFO.
 *
 */
#define BCM89500_A0_READ_FC_CHIP_INFOr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CHIP_INFOr,(r._fc_chip_info),2)
#define BCM89500_A0_WRITE_FC_CHIP_INFOr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CHIP_INFOr,&(r._fc_chip_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CHIP_INFOr BCM89500_A0_FC_CHIP_INFOr
#define FC_CHIP_INFOr_SIZE BCM89500_A0_FC_CHIP_INFOr_SIZE
typedef BCM89500_A0_FC_CHIP_INFOr_t FC_CHIP_INFOr_t;
#define FC_CHIP_INFOr_CLR BCM89500_A0_FC_CHIP_INFOr_CLR
#define FC_CHIP_INFOr_SET BCM89500_A0_FC_CHIP_INFOr_SET
#define FC_CHIP_INFOr_GET BCM89500_A0_FC_CHIP_INFOr_GET
#define FC_CHIP_INFOr_PRT_LINKf_GET BCM89500_A0_FC_CHIP_INFOr_PRT_LINKf_GET
#define FC_CHIP_INFOr_PRT_LINKf_SET BCM89500_A0_FC_CHIP_INFOr_PRT_LINKf_SET
#define FC_CHIP_INFOr_RESERVEDf_GET BCM89500_A0_FC_CHIP_INFOr_RESERVEDf_GET
#define FC_CHIP_INFOr_RESERVEDf_SET BCM89500_A0_FC_CHIP_INFOr_RESERVEDf_SET
#define READ_FC_CHIP_INFOr BCM89500_A0_READ_FC_CHIP_INFOr
#define WRITE_FC_CHIP_INFOr BCM89500_A0_WRITE_FC_CHIP_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CHIP_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CONG_BUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Congested Bus Error Register
 * SIZE:     16
 * FIELDS:
 *     CONG_BUF_ERR_HIS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr 0x00000aaa

#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_BUF_ERR_HIS.
 *
 */
typedef union BCM89500_A0_FC_CONG_BUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_cong_buf_err_his[1];
	uint32_t _fc_cong_buf_err_his;
} BCM89500_A0_FC_CONG_BUF_ERR_HISr_t;

#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_CLR(r) (r).fc_cong_buf_err_his[0] = 0
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_SET(r,d) (r).fc_cong_buf_err_his[0] = d
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_GET(r) (r).fc_cong_buf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET(r) (((r).fc_cong_buf_err_his[0]) & 0x1)
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_GET(r) ((((r).fc_cong_buf_err_his[0]) >> 1) & 0x7fff)
#define BCM89500_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access FC_CONG_BUF_ERR_HIS.
 *
 */
#define BCM89500_A0_READ_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CONG_BUF_ERR_HISr,(r._fc_cong_buf_err_his),2)
#define BCM89500_A0_WRITE_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CONG_BUF_ERR_HISr,&(r._fc_cong_buf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_BUF_ERR_HISr BCM89500_A0_FC_CONG_BUF_ERR_HISr
#define FC_CONG_BUF_ERR_HISr_SIZE BCM89500_A0_FC_CONG_BUF_ERR_HISr_SIZE
typedef BCM89500_A0_FC_CONG_BUF_ERR_HISr_t FC_CONG_BUF_ERR_HISr_t;
#define FC_CONG_BUF_ERR_HISr_CLR BCM89500_A0_FC_CONG_BUF_ERR_HISr_CLR
#define FC_CONG_BUF_ERR_HISr_SET BCM89500_A0_FC_CONG_BUF_ERR_HISr_SET
#define FC_CONG_BUF_ERR_HISr_GET BCM89500_A0_FC_CONG_BUF_ERR_HISr_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET BCM89500_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET BCM89500_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET
#define FC_CONG_BUF_ERR_HISr_RESERVEDf_GET BCM89500_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_GET
#define FC_CONG_BUF_ERR_HISr_RESERVEDf_SET BCM89500_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_SET
#define READ_FC_CONG_BUF_ERR_HISr BCM89500_A0_READ_FC_CONG_BUF_ERR_HISr
#define WRITE_FC_CONG_BUF_ERR_HISr BCM89500_A0_WRITE_FC_CONG_BUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CONG_BUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CONG_PORTMAP01
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port01 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP0    Port 0 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP1    Port 1 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CONG_PORTMAP01r 0x00000a90

#define BCM89500_A0_FC_CONG_PORTMAP01r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP01.
 *
 */
typedef union BCM89500_A0_FC_CONG_PORTMAP01r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap01[1];
	uint32_t _fc_cong_portmap01;
} BCM89500_A0_FC_CONG_PORTMAP01r_t;

#define BCM89500_A0_FC_CONG_PORTMAP01r_CLR(r) (r).fc_cong_portmap01[0] = 0
#define BCM89500_A0_FC_CONG_PORTMAP01r_SET(r,d) (r).fc_cong_portmap01[0] = d
#define BCM89500_A0_FC_CONG_PORTMAP01r_GET(r) (r).fc_cong_portmap01[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET(r) (((r).fc_cong_portmap01[0]) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET(r) ((((r).fc_cong_portmap01[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP01.
 *
 */
#define BCM89500_A0_READ_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CONG_PORTMAP01r,(r._fc_cong_portmap01),2)
#define BCM89500_A0_WRITE_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CONG_PORTMAP01r,&(r._fc_cong_portmap01),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP01r BCM89500_A0_FC_CONG_PORTMAP01r
#define FC_CONG_PORTMAP01r_SIZE BCM89500_A0_FC_CONG_PORTMAP01r_SIZE
typedef BCM89500_A0_FC_CONG_PORTMAP01r_t FC_CONG_PORTMAP01r_t;
#define FC_CONG_PORTMAP01r_CLR BCM89500_A0_FC_CONG_PORTMAP01r_CLR
#define FC_CONG_PORTMAP01r_SET BCM89500_A0_FC_CONG_PORTMAP01r_SET
#define FC_CONG_PORTMAP01r_GET BCM89500_A0_FC_CONG_PORTMAP01r_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET BCM89500_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET
#define READ_FC_CONG_PORTMAP01r BCM89500_A0_READ_FC_CONG_PORTMAP01r
#define WRITE_FC_CONG_PORTMAP01r BCM89500_A0_WRITE_FC_CONG_PORTMAP01r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CONG_PORTMAP01r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CONG_PORTMAP23
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port23 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP2    Port 2 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP3    Port 3 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CONG_PORTMAP23r 0x00000a92

#define BCM89500_A0_FC_CONG_PORTMAP23r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP23.
 *
 */
typedef union BCM89500_A0_FC_CONG_PORTMAP23r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap23[1];
	uint32_t _fc_cong_portmap23;
} BCM89500_A0_FC_CONG_PORTMAP23r_t;

#define BCM89500_A0_FC_CONG_PORTMAP23r_CLR(r) (r).fc_cong_portmap23[0] = 0
#define BCM89500_A0_FC_CONG_PORTMAP23r_SET(r,d) (r).fc_cong_portmap23[0] = d
#define BCM89500_A0_FC_CONG_PORTMAP23r_GET(r) (r).fc_cong_portmap23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET(r) (((r).fc_cong_portmap23[0]) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET(r) ((((r).fc_cong_portmap23[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP23.
 *
 */
#define BCM89500_A0_READ_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CONG_PORTMAP23r,(r._fc_cong_portmap23),2)
#define BCM89500_A0_WRITE_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CONG_PORTMAP23r,&(r._fc_cong_portmap23),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP23r BCM89500_A0_FC_CONG_PORTMAP23r
#define FC_CONG_PORTMAP23r_SIZE BCM89500_A0_FC_CONG_PORTMAP23r_SIZE
typedef BCM89500_A0_FC_CONG_PORTMAP23r_t FC_CONG_PORTMAP23r_t;
#define FC_CONG_PORTMAP23r_CLR BCM89500_A0_FC_CONG_PORTMAP23r_CLR
#define FC_CONG_PORTMAP23r_SET BCM89500_A0_FC_CONG_PORTMAP23r_SET
#define FC_CONG_PORTMAP23r_GET BCM89500_A0_FC_CONG_PORTMAP23r_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET BCM89500_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET
#define READ_FC_CONG_PORTMAP23r BCM89500_A0_READ_FC_CONG_PORTMAP23r
#define WRITE_FC_CONG_PORTMAP23r BCM89500_A0_WRITE_FC_CONG_PORTMAP23r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CONG_PORTMAP23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CONG_PORTMAP45
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port45 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP4    Port 4 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP5    Port 5 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CONG_PORTMAP45r 0x00000a94

#define BCM89500_A0_FC_CONG_PORTMAP45r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP45.
 *
 */
typedef union BCM89500_A0_FC_CONG_PORTMAP45r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap45[1];
	uint32_t _fc_cong_portmap45;
} BCM89500_A0_FC_CONG_PORTMAP45r_t;

#define BCM89500_A0_FC_CONG_PORTMAP45r_CLR(r) (r).fc_cong_portmap45[0] = 0
#define BCM89500_A0_FC_CONG_PORTMAP45r_SET(r,d) (r).fc_cong_portmap45[0] = d
#define BCM89500_A0_FC_CONG_PORTMAP45r_GET(r) (r).fc_cong_portmap45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET(r) (((r).fc_cong_portmap45[0]) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET(r) ((((r).fc_cong_portmap45[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP45.
 *
 */
#define BCM89500_A0_READ_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CONG_PORTMAP45r,(r._fc_cong_portmap45),2)
#define BCM89500_A0_WRITE_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CONG_PORTMAP45r,&(r._fc_cong_portmap45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP45r BCM89500_A0_FC_CONG_PORTMAP45r
#define FC_CONG_PORTMAP45r_SIZE BCM89500_A0_FC_CONG_PORTMAP45r_SIZE
typedef BCM89500_A0_FC_CONG_PORTMAP45r_t FC_CONG_PORTMAP45r_t;
#define FC_CONG_PORTMAP45r_CLR BCM89500_A0_FC_CONG_PORTMAP45r_CLR
#define FC_CONG_PORTMAP45r_SET BCM89500_A0_FC_CONG_PORTMAP45r_SET
#define FC_CONG_PORTMAP45r_GET BCM89500_A0_FC_CONG_PORTMAP45r_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET BCM89500_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET
#define READ_FC_CONG_PORTMAP45r BCM89500_A0_READ_FC_CONG_PORTMAP45r
#define WRITE_FC_CONG_PORTMAP45r BCM89500_A0_WRITE_FC_CONG_PORTMAP45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CONG_PORTMAP45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CONG_PORTMAP67
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port67 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP6    Port 6 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP7    Port 7 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CONG_PORTMAP67r 0x00000a96

#define BCM89500_A0_FC_CONG_PORTMAP67r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP67.
 *
 */
typedef union BCM89500_A0_FC_CONG_PORTMAP67r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap67[1];
	uint32_t _fc_cong_portmap67;
} BCM89500_A0_FC_CONG_PORTMAP67r_t;

#define BCM89500_A0_FC_CONG_PORTMAP67r_CLR(r) (r).fc_cong_portmap67[0] = 0
#define BCM89500_A0_FC_CONG_PORTMAP67r_SET(r,d) (r).fc_cong_portmap67[0] = d
#define BCM89500_A0_FC_CONG_PORTMAP67r_GET(r) (r).fc_cong_portmap67[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET(r) (((r).fc_cong_portmap67[0]) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET(r) ((((r).fc_cong_portmap67[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP67.
 *
 */
#define BCM89500_A0_READ_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CONG_PORTMAP67r,(r._fc_cong_portmap67),2)
#define BCM89500_A0_WRITE_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CONG_PORTMAP67r,&(r._fc_cong_portmap67),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP67r BCM89500_A0_FC_CONG_PORTMAP67r
#define FC_CONG_PORTMAP67r_SIZE BCM89500_A0_FC_CONG_PORTMAP67r_SIZE
typedef BCM89500_A0_FC_CONG_PORTMAP67r_t FC_CONG_PORTMAP67r_t;
#define FC_CONG_PORTMAP67r_CLR BCM89500_A0_FC_CONG_PORTMAP67r_CLR
#define FC_CONG_PORTMAP67r_SET BCM89500_A0_FC_CONG_PORTMAP67r_SET
#define FC_CONG_PORTMAP67r_GET BCM89500_A0_FC_CONG_PORTMAP67r_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET BCM89500_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET
#define READ_FC_CONG_PORTMAP67r BCM89500_A0_READ_FC_CONG_PORTMAP67r
#define WRITE_FC_CONG_PORTMAP67r BCM89500_A0_WRITE_FC_CONG_PORTMAP67r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CONG_PORTMAP67r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_CONG_PORTMAP8
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    Port 8 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_CONG_PORTMAP8r 0x00000a98

#define BCM89500_A0_FC_CONG_PORTMAP8r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP8.
 *
 */
typedef union BCM89500_A0_FC_CONG_PORTMAP8r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap8[1];
	uint32_t _fc_cong_portmap8;
} BCM89500_A0_FC_CONG_PORTMAP8r_t;

#define BCM89500_A0_FC_CONG_PORTMAP8r_CLR(r) (r).fc_cong_portmap8[0] = 0
#define BCM89500_A0_FC_CONG_PORTMAP8r_SET(r,d) (r).fc_cong_portmap8[0] = d
#define BCM89500_A0_FC_CONG_PORTMAP8r_GET(r) (r).fc_cong_portmap8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET(r) (((r).fc_cong_portmap8[0]) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_CONG_PORTMAP8r_RESERVEDf_GET(r) ((((r).fc_cong_portmap8[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_CONG_PORTMAP8r_RESERVEDf_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP8.
 *
 */
#define BCM89500_A0_READ_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_CONG_PORTMAP8r,(r._fc_cong_portmap8),2)
#define BCM89500_A0_WRITE_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_CONG_PORTMAP8r,&(r._fc_cong_portmap8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP8r BCM89500_A0_FC_CONG_PORTMAP8r
#define FC_CONG_PORTMAP8r_SIZE BCM89500_A0_FC_CONG_PORTMAP8r_SIZE
typedef BCM89500_A0_FC_CONG_PORTMAP8r_t FC_CONG_PORTMAP8r_t;
#define FC_CONG_PORTMAP8r_CLR BCM89500_A0_FC_CONG_PORTMAP8r_CLR
#define FC_CONG_PORTMAP8r_SET BCM89500_A0_FC_CONG_PORTMAP8r_SET
#define FC_CONG_PORTMAP8r_GET BCM89500_A0_FC_CONG_PORTMAP8r_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET BCM89500_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET BCM89500_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET
#define FC_CONG_PORTMAP8r_RESERVEDf_GET BCM89500_A0_FC_CONG_PORTMAP8r_RESERVEDf_GET
#define FC_CONG_PORTMAP8r_RESERVEDf_SET BCM89500_A0_FC_CONG_PORTMAP8r_RESERVEDf_SET
#define READ_FC_CONG_PORTMAP8r BCM89500_A0_READ_FC_CONG_PORTMAP8r
#define WRITE_FC_CONG_PORTMAP8r BCM89500_A0_WRITE_FC_CONG_PORTMAP8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_CONG_PORTMAP8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_DIAG_CTRL
 * BLOCKS:   SYS
 * DESC:     Flowcon Diagnosis Control Register
 * SIZE:     16
 * FIELDS:
 *     DIG_FLOWCON_PROT Diagnosis only: Select which port to be monitored.4'd0 : port 0; 4'd1: port1;  4'd 7: port 7
 *     RESERVED_1       Reserved
 *     RESERVED_2       Reserved
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_DIAG_CTRLr 0x00000a00

#define BCM89500_A0_FC_DIAG_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_DIAG_CTRL.
 *
 */
typedef union BCM89500_A0_FC_DIAG_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_diag_ctrl[1];
	uint32_t _fc_diag_ctrl;
} BCM89500_A0_FC_DIAG_CTRLr_t;

#define BCM89500_A0_FC_DIAG_CTRLr_CLR(r) (r).fc_diag_ctrl[0] = 0
#define BCM89500_A0_FC_DIAG_CTRLr_SET(r,d) (r).fc_diag_ctrl[0] = d
#define BCM89500_A0_FC_DIAG_CTRLr_GET(r) (r).fc_diag_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET(r) (((r).fc_diag_ctrl[0]) & 0xf)
#define BCM89500_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_FC_DIAG_CTRLr_RESERVED_1f_GET(r) ((((r).fc_diag_ctrl[0]) >> 4) & 0x3)
#define BCM89500_A0_FC_DIAG_CTRLr_RESERVED_1f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_FC_DIAG_CTRLr_RESERVED_2f_GET(r) ((((r).fc_diag_ctrl[0]) >> 6) & 0x3)
#define BCM89500_A0_FC_DIAG_CTRLr_RESERVED_2f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_FC_DIAG_CTRLr_RESERVED_3f_GET(r) ((((r).fc_diag_ctrl[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_DIAG_CTRLr_RESERVED_3f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_DIAG_CTRL.
 *
 */
#define BCM89500_A0_READ_FC_DIAG_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_DIAG_CTRLr,(r._fc_diag_ctrl),2)
#define BCM89500_A0_WRITE_FC_DIAG_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_DIAG_CTRLr,&(r._fc_diag_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_DIAG_CTRLr BCM89500_A0_FC_DIAG_CTRLr
#define FC_DIAG_CTRLr_SIZE BCM89500_A0_FC_DIAG_CTRLr_SIZE
typedef BCM89500_A0_FC_DIAG_CTRLr_t FC_DIAG_CTRLr_t;
#define FC_DIAG_CTRLr_CLR BCM89500_A0_FC_DIAG_CTRLr_CLR
#define FC_DIAG_CTRLr_SET BCM89500_A0_FC_DIAG_CTRLr_SET
#define FC_DIAG_CTRLr_GET BCM89500_A0_FC_DIAG_CTRLr_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET BCM89500_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET BCM89500_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET
#define FC_DIAG_CTRLr_RESERVED_1f_GET BCM89500_A0_FC_DIAG_CTRLr_RESERVED_1f_GET
#define FC_DIAG_CTRLr_RESERVED_1f_SET BCM89500_A0_FC_DIAG_CTRLr_RESERVED_1f_SET
#define FC_DIAG_CTRLr_RESERVED_2f_GET BCM89500_A0_FC_DIAG_CTRLr_RESERVED_2f_GET
#define FC_DIAG_CTRLr_RESERVED_2f_SET BCM89500_A0_FC_DIAG_CTRLr_RESERVED_2f_SET
#define FC_DIAG_CTRLr_RESERVED_3f_GET BCM89500_A0_FC_DIAG_CTRLr_RESERVED_3f_GET
#define FC_DIAG_CTRLr_RESERVED_3f_SET BCM89500_A0_FC_DIAG_CTRLr_RESERVED_3f_SET
#define READ_FC_DIAG_CTRLr BCM89500_A0_READ_FC_DIAG_CTRLr
#define WRITE_FC_DIAG_CTRLr BCM89500_A0_WRITE_FC_DIAG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_DIAG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_FRM_DROP_REG
 * BLOCKS:   SYS
 * DESC:     Force Frame Drop Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     FORCE_FRM_DROP   Force frame drop if the port in congestion.Bit 8 = IMP portBit 7:0 = Port 7 ~ Port 01:Frame drop when the congestions status of the queue = "01"0:Frame not drop when the congestions status of the queue = "01"(For fixing the strict priroity fairness issue)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_FRM_DROP_REGr 0x00000a5a

#define BCM89500_A0_FC_FRM_DROP_REGr_SIZE 2

/*
 * This structure should be used to declare and program FC_FRM_DROP_REG.
 *
 */
typedef union BCM89500_A0_FC_FRM_DROP_REGr_s {
	uint32_t v[1];
	uint32_t fc_frm_drop_reg[1];
	uint32_t _fc_frm_drop_reg;
} BCM89500_A0_FC_FRM_DROP_REGr_t;

#define BCM89500_A0_FC_FRM_DROP_REGr_CLR(r) (r).fc_frm_drop_reg[0] = 0
#define BCM89500_A0_FC_FRM_DROP_REGr_SET(r,d) (r).fc_frm_drop_reg[0] = d
#define BCM89500_A0_FC_FRM_DROP_REGr_GET(r) (r).fc_frm_drop_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_FRM_DROP_REGr_FORCE_FRM_DROPf_GET(r) (((r).fc_frm_drop_reg[0]) & 0x1ff)
#define BCM89500_A0_FC_FRM_DROP_REGr_FORCE_FRM_DROPf_SET(r,f) (r).fc_frm_drop_reg[0]=(((r).fc_frm_drop_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_FC_FRM_DROP_REGr_RESERVEDf_GET(r) ((((r).fc_frm_drop_reg[0]) >> 9) & 0x7f)
#define BCM89500_A0_FC_FRM_DROP_REGr_RESERVEDf_SET(r,f) (r).fc_frm_drop_reg[0]=(((r).fc_frm_drop_reg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_FRM_DROP_REG.
 *
 */
#define BCM89500_A0_READ_FC_FRM_DROP_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_FRM_DROP_REGr,(r._fc_frm_drop_reg),2)
#define BCM89500_A0_WRITE_FC_FRM_DROP_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_FRM_DROP_REGr,&(r._fc_frm_drop_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_FRM_DROP_REGr BCM89500_A0_FC_FRM_DROP_REGr
#define FC_FRM_DROP_REGr_SIZE BCM89500_A0_FC_FRM_DROP_REGr_SIZE
typedef BCM89500_A0_FC_FRM_DROP_REGr_t FC_FRM_DROP_REGr_t;
#define FC_FRM_DROP_REGr_CLR BCM89500_A0_FC_FRM_DROP_REGr_CLR
#define FC_FRM_DROP_REGr_SET BCM89500_A0_FC_FRM_DROP_REGr_SET
#define FC_FRM_DROP_REGr_GET BCM89500_A0_FC_FRM_DROP_REGr_GET
#define FC_FRM_DROP_REGr_FORCE_FRM_DROPf_GET BCM89500_A0_FC_FRM_DROP_REGr_FORCE_FRM_DROPf_GET
#define FC_FRM_DROP_REGr_FORCE_FRM_DROPf_SET BCM89500_A0_FC_FRM_DROP_REGr_FORCE_FRM_DROPf_SET
#define FC_FRM_DROP_REGr_RESERVEDf_GET BCM89500_A0_FC_FRM_DROP_REGr_RESERVEDf_GET
#define FC_FRM_DROP_REGr_RESERVEDf_SET BCM89500_A0_FC_FRM_DROP_REGr_RESERVEDf_SET
#define READ_FC_FRM_DROP_REGr BCM89500_A0_READ_FC_FRM_DROP_REGr
#define WRITE_FC_FRM_DROP_REGr BCM89500_A0_WRITE_FC_FRM_DROP_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_FRM_DROP_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_GIGA_INFO
 * BLOCKS:   SYS
 * DESC:     Giga Speed Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     GIGA_PORTMAP     
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_GIGA_INFOr 0x00000a9c

#define BCM89500_A0_FC_GIGA_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_GIGA_INFO.
 *
 */
typedef union BCM89500_A0_FC_GIGA_INFOr_s {
	uint32_t v[1];
	uint32_t fc_giga_info[1];
	uint32_t _fc_giga_info;
} BCM89500_A0_FC_GIGA_INFOr_t;

#define BCM89500_A0_FC_GIGA_INFOr_CLR(r) (r).fc_giga_info[0] = 0
#define BCM89500_A0_FC_GIGA_INFOr_SET(r,d) (r).fc_giga_info[0] = d
#define BCM89500_A0_FC_GIGA_INFOr_GET(r) (r).fc_giga_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET(r) (((r).fc_giga_info[0]) & 0x1ff)
#define BCM89500_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_FC_GIGA_INFOr_RESERVEDf_GET(r) ((((r).fc_giga_info[0]) >> 9) & 0x7f)
#define BCM89500_A0_FC_GIGA_INFOr_RESERVEDf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_GIGA_INFO.
 *
 */
#define BCM89500_A0_READ_FC_GIGA_INFOr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_GIGA_INFOr,(r._fc_giga_info),2)
#define BCM89500_A0_WRITE_FC_GIGA_INFOr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_GIGA_INFOr,&(r._fc_giga_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_GIGA_INFOr BCM89500_A0_FC_GIGA_INFOr
#define FC_GIGA_INFOr_SIZE BCM89500_A0_FC_GIGA_INFOr_SIZE
typedef BCM89500_A0_FC_GIGA_INFOr_t FC_GIGA_INFOr_t;
#define FC_GIGA_INFOr_CLR BCM89500_A0_FC_GIGA_INFOr_CLR
#define FC_GIGA_INFOr_SET BCM89500_A0_FC_GIGA_INFOr_SET
#define FC_GIGA_INFOr_GET BCM89500_A0_FC_GIGA_INFOr_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_GET BCM89500_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_SET BCM89500_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET
#define FC_GIGA_INFOr_RESERVEDf_GET BCM89500_A0_FC_GIGA_INFOr_RESERVEDf_GET
#define FC_GIGA_INFOr_RESERVEDf_SET BCM89500_A0_FC_GIGA_INFOr_RESERVEDf_SET
#define READ_FC_GIGA_INFOr BCM89500_A0_READ_FC_GIGA_INFOr
#define WRITE_FC_GIGA_INFOr BCM89500_A0_WRITE_FC_GIGA_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_GIGA_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_MCAST_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Multicast Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     PAR_DROP_EN      Multicast Partial Drop Enalbed.Bit 8 = IMP port,Bit 7 = Port 7,Bit 5:0 = Port 5 ~ Port 0,1: Multicast Frame can forward to uncongested Destination Port, and will not forward to congested Destination Port0: Multicast Frame can forward only if all destination ports are not congested.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_MCAST_DROP_CTRLr 0x00000a0c

#define BCM89500_A0_FC_MCAST_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_MCAST_DROP_CTRL.
 *
 */
typedef union BCM89500_A0_FC_MCAST_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_mcast_drop_ctrl[1];
	uint32_t _fc_mcast_drop_ctrl;
} BCM89500_A0_FC_MCAST_DROP_CTRLr_t;

#define BCM89500_A0_FC_MCAST_DROP_CTRLr_CLR(r) (r).fc_mcast_drop_ctrl[0] = 0
#define BCM89500_A0_FC_MCAST_DROP_CTRLr_SET(r,d) (r).fc_mcast_drop_ctrl[0] = d
#define BCM89500_A0_FC_MCAST_DROP_CTRLr_GET(r) (r).fc_mcast_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET(r) (((r).fc_mcast_drop_ctrl[0]) & 0x1ff)
#define BCM89500_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_GET(r) ((((r).fc_mcast_drop_ctrl[0]) >> 9) & 0x7f)
#define BCM89500_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_MCAST_DROP_CTRL.
 *
 */
#define BCM89500_A0_READ_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_MCAST_DROP_CTRLr,(r._fc_mcast_drop_ctrl),2)
#define BCM89500_A0_WRITE_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_MCAST_DROP_CTRLr,&(r._fc_mcast_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MCAST_DROP_CTRLr BCM89500_A0_FC_MCAST_DROP_CTRLr
#define FC_MCAST_DROP_CTRLr_SIZE BCM89500_A0_FC_MCAST_DROP_CTRLr_SIZE
typedef BCM89500_A0_FC_MCAST_DROP_CTRLr_t FC_MCAST_DROP_CTRLr_t;
#define FC_MCAST_DROP_CTRLr_CLR BCM89500_A0_FC_MCAST_DROP_CTRLr_CLR
#define FC_MCAST_DROP_CTRLr_SET BCM89500_A0_FC_MCAST_DROP_CTRLr_SET
#define FC_MCAST_DROP_CTRLr_GET BCM89500_A0_FC_MCAST_DROP_CTRLr_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET BCM89500_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET BCM89500_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET
#define FC_MCAST_DROP_CTRLr_RESERVEDf_GET BCM89500_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_GET
#define FC_MCAST_DROP_CTRLr_RESERVEDf_SET BCM89500_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_SET
#define READ_FC_MCAST_DROP_CTRLr BCM89500_A0_READ_FC_MCAST_DROP_CTRLr
#define WRITE_FC_MCAST_DROP_CTRLr BCM89500_A0_WRITE_FC_MCAST_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_MCAST_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_MON_TXQ
 * BLOCKS:   SYS
 * DESC:     Monitored TxQ N (0~5) Register
 * SIZE:     16
 * FIELDS:
 *     MONITORED_TXQ_CNT Monitor TxQ 0~5 countTxQ 4/5 indicate Class4/5 trafficThe diag_port setting in Diag register(Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_MON_TXQr 0x00000a60

#define BCM89500_A0_FC_MON_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_MON_TXQ.
 *
 */
typedef union BCM89500_A0_FC_MON_TXQr_s {
	uint32_t v[1];
	uint32_t fc_mon_txq[1];
	uint32_t _fc_mon_txq;
} BCM89500_A0_FC_MON_TXQr_t;

#define BCM89500_A0_FC_MON_TXQr_CLR(r) (r).fc_mon_txq[0] = 0
#define BCM89500_A0_FC_MON_TXQr_SET(r,d) (r).fc_mon_txq[0] = d
#define BCM89500_A0_FC_MON_TXQr_GET(r) (r).fc_mon_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET(r) (((r).fc_mon_txq[0]) & 0x7ff)
#define BCM89500_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_MON_TXQr_RESERVEDf_GET(r) ((((r).fc_mon_txq[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_MON_TXQr_RESERVEDf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_MON_TXQ.
 *
 */
#define BCM89500_A0_READ_FC_MON_TXQr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_MON_TXQr+(2*(i)),(r._fc_mon_txq),2)
#define BCM89500_A0_WRITE_FC_MON_TXQr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_MON_TXQr+(2*(i)),&(r._fc_mon_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_TXQr BCM89500_A0_FC_MON_TXQr
#define FC_MON_TXQr_SIZE BCM89500_A0_FC_MON_TXQr_SIZE
typedef BCM89500_A0_FC_MON_TXQr_t FC_MON_TXQr_t;
#define FC_MON_TXQr_CLR BCM89500_A0_FC_MON_TXQr_CLR
#define FC_MON_TXQr_SET BCM89500_A0_FC_MON_TXQr_SET
#define FC_MON_TXQr_GET BCM89500_A0_FC_MON_TXQr_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_GET BCM89500_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_SET BCM89500_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET
#define FC_MON_TXQr_RESERVEDf_GET BCM89500_A0_FC_MON_TXQr_RESERVEDf_GET
#define FC_MON_TXQr_RESERVEDf_SET BCM89500_A0_FC_MON_TXQr_RESERVEDf_SET
#define READ_FC_MON_TXQr BCM89500_A0_READ_FC_MON_TXQr
#define WRITE_FC_MON_TXQr BCM89500_A0_WRITE_FC_MON_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_MON_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_PAUSE_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause/Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TX_PAUSE      To enable txq pause machinism on Ethernet port
 *     EN_TX_DROP       
 *     EN_TOTAL_PAUSE   To enable total pause machinism on Ethernet port
 *     EN_TOTAL_DROP    
 *     EN_TX_LEGACY_PAUSE 
 *     RESERVED         Reserved
 *     EN_RX_PAUSE      
 *     EN_RX_DROP       
 *     RESERVED_0       Reserved
 *     EN_IMP1_TXQ_PAUSE To enable txq pause machinism on IMP1
 *     EN_IMP1_TOTAL_PAUSE To enable total pause machinism on IMP1
 *     EN_IMP_TXQ_PAUSE To enable txq pause machinism on IMP/IMP0
 *     EN_IMP_TOTAL_PAUSE To enable total pause machinism on IMP/IMP0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr 0x00000a0e

#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_DROP_CTRL.
 *
 */
typedef union BCM89500_A0_FC_PAUSE_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_pause_drop_ctrl[1];
	uint32_t _fc_pause_drop_ctrl;
} BCM89500_A0_FC_PAUSE_DROP_CTRLr_t;

#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_CLR(r) (r).fc_pause_drop_ctrl[0] = 0
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_SET(r,d) (r).fc_pause_drop_ctrl[0] = d
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_GET(r) (r).fc_pause_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET(r) (((r).fc_pause_drop_ctrl[0]) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 8) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 9) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 10) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 11) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 12) & 0x1)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 13) & 0x7)
#define BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access FC_PAUSE_DROP_CTRL.
 *
 */
#define BCM89500_A0_READ_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_PAUSE_DROP_CTRLr,(r._fc_pause_drop_ctrl),2)
#define BCM89500_A0_WRITE_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_PAUSE_DROP_CTRLr,&(r._fc_pause_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_DROP_CTRLr BCM89500_A0_FC_PAUSE_DROP_CTRLr
#define FC_PAUSE_DROP_CTRLr_SIZE BCM89500_A0_FC_PAUSE_DROP_CTRLr_SIZE
typedef BCM89500_A0_FC_PAUSE_DROP_CTRLr_t FC_PAUSE_DROP_CTRLr_t;
#define FC_PAUSE_DROP_CTRLr_CLR BCM89500_A0_FC_PAUSE_DROP_CTRLr_CLR
#define FC_PAUSE_DROP_CTRLr_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_SET
#define FC_PAUSE_DROP_CTRLr_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVEDf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVEDf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET BCM89500_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET
#define READ_FC_PAUSE_DROP_CTRLr BCM89500_A0_READ_FC_PAUSE_DROP_CTRLr
#define WRITE_FC_PAUSE_DROP_CTRLr BCM89500_A0_WRITE_FC_PAUSE_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_PAUSE_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_PAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     Pause History Register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_HIS        
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_PAUSE_HISr 0x00000aa0

#define BCM89500_A0_FC_PAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_HIS.
 *
 */
typedef union BCM89500_A0_FC_PAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_pause_his[1];
	uint32_t _fc_pause_his;
} BCM89500_A0_FC_PAUSE_HISr_t;

#define BCM89500_A0_FC_PAUSE_HISr_CLR(r) (r).fc_pause_his[0] = 0
#define BCM89500_A0_FC_PAUSE_HISr_SET(r,d) (r).fc_pause_his[0] = d
#define BCM89500_A0_FC_PAUSE_HISr_GET(r) (r).fc_pause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_PAUSE_HISr_PAUSE_HISf_GET(r) (((r).fc_pause_his[0]) & 0x7ff)
#define BCM89500_A0_FC_PAUSE_HISr_PAUSE_HISf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_PAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_pause_his[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_PAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PAUSE_HIS.
 *
 */
#define BCM89500_A0_READ_FC_PAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_PAUSE_HISr,(r._fc_pause_his),2)
#define BCM89500_A0_WRITE_FC_PAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_PAUSE_HISr,&(r._fc_pause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_HISr BCM89500_A0_FC_PAUSE_HISr
#define FC_PAUSE_HISr_SIZE BCM89500_A0_FC_PAUSE_HISr_SIZE
typedef BCM89500_A0_FC_PAUSE_HISr_t FC_PAUSE_HISr_t;
#define FC_PAUSE_HISr_CLR BCM89500_A0_FC_PAUSE_HISr_CLR
#define FC_PAUSE_HISr_SET BCM89500_A0_FC_PAUSE_HISr_SET
#define FC_PAUSE_HISr_GET BCM89500_A0_FC_PAUSE_HISr_GET
#define FC_PAUSE_HISr_PAUSE_HISf_GET BCM89500_A0_FC_PAUSE_HISr_PAUSE_HISf_GET
#define FC_PAUSE_HISr_PAUSE_HISf_SET BCM89500_A0_FC_PAUSE_HISr_PAUSE_HISf_SET
#define FC_PAUSE_HISr_RESERVEDf_GET BCM89500_A0_FC_PAUSE_HISr_RESERVEDf_GET
#define FC_PAUSE_HISr_RESERVEDf_SET BCM89500_A0_FC_PAUSE_HISr_RESERVEDf_SET
#define READ_FC_PAUSE_HISr BCM89500_A0_READ_FC_PAUSE_HISr
#define WRITE_FC_PAUSE_HISr BCM89500_A0_WRITE_FC_PAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_PAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_PEAK_RXBYTE
 * BLOCKS:   SYS
 * DESC:     Peak Rx Buffer Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_RXBUFFER_CNT Peak Rx Byte count.The diag_port setting in Diag register (Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_PEAK_RXBYTEr 0x00000a78

#define BCM89500_A0_FC_PEAK_RXBYTEr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_RXBYTE.
 *
 */
typedef union BCM89500_A0_FC_PEAK_RXBYTEr_s {
	uint32_t v[1];
	uint32_t fc_peak_rxbyte[1];
	uint32_t _fc_peak_rxbyte;
} BCM89500_A0_FC_PEAK_RXBYTEr_t;

#define BCM89500_A0_FC_PEAK_RXBYTEr_CLR(r) (r).fc_peak_rxbyte[0] = 0
#define BCM89500_A0_FC_PEAK_RXBYTEr_SET(r,d) (r).fc_peak_rxbyte[0] = d
#define BCM89500_A0_FC_PEAK_RXBYTEr_GET(r) (r).fc_peak_rxbyte[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET(r) (((r).fc_peak_rxbyte[0]) & 0x7ff)
#define BCM89500_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_PEAK_RXBYTEr_RESERVEDf_GET(r) ((((r).fc_peak_rxbyte[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_PEAK_RXBYTEr_RESERVEDf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_RXBYTE.
 *
 */
#define BCM89500_A0_READ_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_PEAK_RXBYTEr,(r._fc_peak_rxbyte),2)
#define BCM89500_A0_WRITE_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_PEAK_RXBYTEr,&(r._fc_peak_rxbyte),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_RXBYTEr BCM89500_A0_FC_PEAK_RXBYTEr
#define FC_PEAK_RXBYTEr_SIZE BCM89500_A0_FC_PEAK_RXBYTEr_SIZE
typedef BCM89500_A0_FC_PEAK_RXBYTEr_t FC_PEAK_RXBYTEr_t;
#define FC_PEAK_RXBYTEr_CLR BCM89500_A0_FC_PEAK_RXBYTEr_CLR
#define FC_PEAK_RXBYTEr_SET BCM89500_A0_FC_PEAK_RXBYTEr_SET
#define FC_PEAK_RXBYTEr_GET BCM89500_A0_FC_PEAK_RXBYTEr_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET BCM89500_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET BCM89500_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET
#define FC_PEAK_RXBYTEr_RESERVEDf_GET BCM89500_A0_FC_PEAK_RXBYTEr_RESERVEDf_GET
#define FC_PEAK_RXBYTEr_RESERVEDf_SET BCM89500_A0_FC_PEAK_RXBYTEr_RESERVEDf_SET
#define READ_FC_PEAK_RXBYTEr BCM89500_A0_READ_FC_PEAK_RXBYTEr
#define WRITE_FC_PEAK_RXBYTEr BCM89500_A0_WRITE_FC_PEAK_RXBYTEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_PEAK_RXBYTEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_PEAK_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Peak Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_USE   Peak Total Used count.This register lock the peak value of total used count.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr 0x00000a80

#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TOTAL_USED.
 *
 */
typedef union BCM89500_A0_FC_PEAK_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_peak_total_used[1];
	uint32_t _fc_peak_total_used;
} BCM89500_A0_FC_PEAK_TOTAL_USEDr_t;

#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_CLR(r) (r).fc_peak_total_used[0] = 0
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_SET(r,d) (r).fc_peak_total_used[0] = d
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_GET(r) (r).fc_peak_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET(r) (((r).fc_peak_total_used[0]) & 0x7ff)
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_GET(r) ((((r).fc_peak_total_used[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_TOTAL_USED.
 *
 */
#define BCM89500_A0_READ_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_PEAK_TOTAL_USEDr,(r._fc_peak_total_used),2)
#define BCM89500_A0_WRITE_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_PEAK_TOTAL_USEDr,&(r._fc_peak_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TOTAL_USEDr BCM89500_A0_FC_PEAK_TOTAL_USEDr
#define FC_PEAK_TOTAL_USEDr_SIZE BCM89500_A0_FC_PEAK_TOTAL_USEDr_SIZE
typedef BCM89500_A0_FC_PEAK_TOTAL_USEDr_t FC_PEAK_TOTAL_USEDr_t;
#define FC_PEAK_TOTAL_USEDr_CLR BCM89500_A0_FC_PEAK_TOTAL_USEDr_CLR
#define FC_PEAK_TOTAL_USEDr_SET BCM89500_A0_FC_PEAK_TOTAL_USEDr_SET
#define FC_PEAK_TOTAL_USEDr_GET BCM89500_A0_FC_PEAK_TOTAL_USEDr_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET BCM89500_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET BCM89500_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET
#define FC_PEAK_TOTAL_USEDr_RESERVEDf_GET BCM89500_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_GET
#define FC_PEAK_TOTAL_USEDr_RESERVEDf_SET BCM89500_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_SET
#define READ_FC_PEAK_TOTAL_USEDr BCM89500_A0_READ_FC_PEAK_TOTAL_USEDr
#define WRITE_FC_PEAK_TOTAL_USEDr BCM89500_A0_WRITE_FC_PEAK_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_PEAK_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_PEAK_TXQ
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (0~3) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 0~3 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_PEAK_TXQr 0x00000a70

#define BCM89500_A0_FC_PEAK_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ.
 *
 */
typedef union BCM89500_A0_FC_PEAK_TXQr_s {
	uint32_t v[1];
	uint32_t fc_peak_txq[1];
	uint32_t _fc_peak_txq;
} BCM89500_A0_FC_PEAK_TXQr_t;

#define BCM89500_A0_FC_PEAK_TXQr_CLR(r) (r).fc_peak_txq[0] = 0
#define BCM89500_A0_FC_PEAK_TXQr_SET(r,d) (r).fc_peak_txq[0] = d
#define BCM89500_A0_FC_PEAK_TXQr_GET(r) (r).fc_peak_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq[0]) & 0x7ff)
#define BCM89500_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_PEAK_TXQr_RESERVEDf_GET(r) ((((r).fc_peak_txq[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_PEAK_TXQr_RESERVEDf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ.
 *
 */
#define BCM89500_A0_READ_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_PEAK_TXQr+(2*(i)),(r._fc_peak_txq),2)
#define BCM89500_A0_WRITE_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_PEAK_TXQr+(2*(i)),&(r._fc_peak_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQr BCM89500_A0_FC_PEAK_TXQr
#define FC_PEAK_TXQr_SIZE BCM89500_A0_FC_PEAK_TXQr_SIZE
typedef BCM89500_A0_FC_PEAK_TXQr_t FC_PEAK_TXQr_t;
#define FC_PEAK_TXQr_CLR BCM89500_A0_FC_PEAK_TXQr_CLR
#define FC_PEAK_TXQr_SET BCM89500_A0_FC_PEAK_TXQr_SET
#define FC_PEAK_TXQr_GET BCM89500_A0_FC_PEAK_TXQr_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_GET BCM89500_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_SET BCM89500_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQr_RESERVEDf_GET BCM89500_A0_FC_PEAK_TXQr_RESERVEDf_GET
#define FC_PEAK_TXQr_RESERVEDf_SET BCM89500_A0_FC_PEAK_TXQr_RESERVEDf_SET
#define READ_FC_PEAK_TXQr BCM89500_A0_READ_FC_PEAK_TXQr
#define WRITE_FC_PEAK_TXQr BCM89500_A0_WRITE_FC_PEAK_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_PEAK_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_PEAK_TXQ_45
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (4~5) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 4~5 count.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_PEAK_TXQ_45r 0x00000a88

#define BCM89500_A0_FC_PEAK_TXQ_45r_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ_45.
 *
 */
typedef union BCM89500_A0_FC_PEAK_TXQ_45r_s {
	uint32_t v[1];
	uint32_t fc_peak_txq_45[1];
	uint32_t _fc_peak_txq_45;
} BCM89500_A0_FC_PEAK_TXQ_45r_t;

#define BCM89500_A0_FC_PEAK_TXQ_45r_CLR(r) (r).fc_peak_txq_45[0] = 0
#define BCM89500_A0_FC_PEAK_TXQ_45r_SET(r,d) (r).fc_peak_txq_45[0] = d
#define BCM89500_A0_FC_PEAK_TXQ_45r_GET(r) (r).fc_peak_txq_45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq_45[0]) & 0x7ff)
#define BCM89500_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_PEAK_TXQ_45r_RESERVEDf_GET(r) ((((r).fc_peak_txq_45[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_PEAK_TXQ_45r_RESERVEDf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ_45.
 *
 */
#define BCM89500_A0_READ_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_PEAK_TXQ_45r+(2*(i)),(r._fc_peak_txq_45),2)
#define BCM89500_A0_WRITE_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_PEAK_TXQ_45r+(2*(i)),&(r._fc_peak_txq_45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQ_45r BCM89500_A0_FC_PEAK_TXQ_45r
#define FC_PEAK_TXQ_45r_SIZE BCM89500_A0_FC_PEAK_TXQ_45r_SIZE
typedef BCM89500_A0_FC_PEAK_TXQ_45r_t FC_PEAK_TXQ_45r_t;
#define FC_PEAK_TXQ_45r_CLR BCM89500_A0_FC_PEAK_TXQ_45r_CLR
#define FC_PEAK_TXQ_45r_SET BCM89500_A0_FC_PEAK_TXQ_45r_SET
#define FC_PEAK_TXQ_45r_GET BCM89500_A0_FC_PEAK_TXQ_45r_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET BCM89500_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET BCM89500_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQ_45r_RESERVEDf_GET BCM89500_A0_FC_PEAK_TXQ_45r_RESERVEDf_GET
#define FC_PEAK_TXQ_45r_RESERVEDf_SET BCM89500_A0_FC_PEAK_TXQ_45r_RESERVEDf_SET
#define READ_FC_PEAK_TXQ_45r BCM89500_A0_READ_FC_PEAK_TXQ_45r
#define WRITE_FC_PEAK_TXQ_45r BCM89500_A0_WRITE_FC_PEAK_TXQ_45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_PEAK_TXQ_45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_0123
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 0,1,2,3 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP01   Port 1 congest status for Queue 4/5bit[7:6] = congest status for Q5bit[5:4] = congest status for Q4Port 1 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     CONG_PORTMAP23   Port 3 congest status for Queue 4/5bit[15:14] = congest status for Q5bit[13:12] = congest status for Q4Port 2 congest status for Queue 4/5bit[11:10] = congest status for Q5bit[9:8] = congest status for Q4
 *
 ******************************************************************************/
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r 0x00000ad0

#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_0123.
 *
 */
typedef union BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_0123[1];
	uint32_t _fc_q45_cong_portmap_0123;
} BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_t;

#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CLR(r) (r).fc_q45_cong_portmap_0123[0] = 0
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_SET(r,d) (r).fc_q45_cong_portmap_0123[0] = d
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_GET(r) (r).fc_q45_cong_portmap_0123[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET(r) (((r).fc_q45_cong_portmap_0123[0]) & 0xff)
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET(r) ((((r).fc_q45_cong_portmap_0123[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_0123.
 *
 */
#define BCM89500_A0_READ_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r,(r._fc_q45_cong_portmap_0123),2)
#define BCM89500_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r,&(r._fc_q45_cong_portmap_0123),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_0123r BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r
#define FC_Q45_CONG_PORTMAP_0123r_SIZE BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE
typedef BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_t FC_Q45_CONG_PORTMAP_0123r_t;
#define FC_Q45_CONG_PORTMAP_0123r_CLR BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CLR
#define FC_Q45_CONG_PORTMAP_0123r_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_SET
#define FC_Q45_CONG_PORTMAP_0123r_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET
#define READ_FC_Q45_CONG_PORTMAP_0123r BCM89500_A0_READ_FC_Q45_CONG_PORTMAP_0123r
#define WRITE_FC_Q45_CONG_PORTMAP_0123r BCM89500_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_Q45_CONG_PORTMAP_0123r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_4567
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 4,5,6,7 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP45   Port 5 congest status for Queue 4/5bit[7:6] = congest status for Q5bit[5:4] = congest status for Q4Port 4 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     CONG_PORTMAP67   Port 7 congest status for Queue 4/5bit[15:14] = congest status for Q5bit[13:12] = congest status for Q4Port 6 congest status for Queue 4/5bit[11:10] = congest status for Q5bit[9:8] = congest status for Q4
 *
 ******************************************************************************/
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r 0x00000ad2

#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_4567.
 *
 */
typedef union BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_4567[1];
	uint32_t _fc_q45_cong_portmap_4567;
} BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_t;

#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CLR(r) (r).fc_q45_cong_portmap_4567[0] = 0
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_SET(r,d) (r).fc_q45_cong_portmap_4567[0] = d
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_GET(r) (r).fc_q45_cong_portmap_4567[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET(r) (((r).fc_q45_cong_portmap_4567[0]) & 0xff)
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET(r) ((((r).fc_q45_cong_portmap_4567[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_4567.
 *
 */
#define BCM89500_A0_READ_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r,(r._fc_q45_cong_portmap_4567),2)
#define BCM89500_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r,&(r._fc_q45_cong_portmap_4567),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_4567r BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r
#define FC_Q45_CONG_PORTMAP_4567r_SIZE BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE
typedef BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_t FC_Q45_CONG_PORTMAP_4567r_t;
#define FC_Q45_CONG_PORTMAP_4567r_CLR BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CLR
#define FC_Q45_CONG_PORTMAP_4567r_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_SET
#define FC_Q45_CONG_PORTMAP_4567r_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET
#define READ_FC_Q45_CONG_PORTMAP_4567r BCM89500_A0_READ_FC_Q45_CONG_PORTMAP_4567r
#define WRITE_FC_Q45_CONG_PORTMAP_4567r BCM89500_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_Q45_CONG_PORTMAP_4567r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_8
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    Port 8 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r 0x00000ad4

#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_8.
 *
 */
typedef union BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_8[1];
	uint32_t _fc_q45_cong_portmap_8;
} BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_t;

#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_CLR(r) (r).fc_q45_cong_portmap_8[0] = 0
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_SET(r,d) (r).fc_q45_cong_portmap_8[0] = d
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_GET(r) (r).fc_q45_cong_portmap_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET(r) (((r).fc_q45_cong_portmap_8[0]) & 0xf)
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET(r) ((((r).fc_q45_cong_portmap_8[0]) >> 4) & 0xfff)
#define BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_8.
 *
 */
#define BCM89500_A0_READ_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_Q45_CONG_PORTMAP_8r,(r._fc_q45_cong_portmap_8),2)
#define BCM89500_A0_WRITE_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_Q45_CONG_PORTMAP_8r,&(r._fc_q45_cong_portmap_8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_8r BCM89500_A0_FC_Q45_CONG_PORTMAP_8r
#define FC_Q45_CONG_PORTMAP_8r_SIZE BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_SIZE
typedef BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_t FC_Q45_CONG_PORTMAP_8r_t;
#define FC_Q45_CONG_PORTMAP_8r_CLR BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_CLR
#define FC_Q45_CONG_PORTMAP_8r_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_SET
#define FC_Q45_CONG_PORTMAP_8r_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET
#define FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET
#define FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET BCM89500_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET
#define READ_FC_Q45_CONG_PORTMAP_8r BCM89500_A0_READ_FC_Q45_CONG_PORTMAP_8r
#define WRITE_FC_Q45_CONG_PORTMAP_8r BCM89500_A0_WRITE_FC_Q45_CONG_PORTMAP_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_Q45_CONG_PORTMAP_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_RXBUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Rx Buffer Error History Register
 * SIZE:     16
 * FIELDS:
 *     RXBUF_ERR_HIS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_RXBUF_ERR_HISr 0x00000aa8

#define BCM89500_A0_FC_RXBUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXBUF_ERR_HIS.
 *
 */
typedef union BCM89500_A0_FC_RXBUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxbuf_err_his[1];
	uint32_t _fc_rxbuf_err_his;
} BCM89500_A0_FC_RXBUF_ERR_HISr_t;

#define BCM89500_A0_FC_RXBUF_ERR_HISr_CLR(r) (r).fc_rxbuf_err_his[0] = 0
#define BCM89500_A0_FC_RXBUF_ERR_HISr_SET(r,d) (r).fc_rxbuf_err_his[0] = d
#define BCM89500_A0_FC_RXBUF_ERR_HISr_GET(r) (r).fc_rxbuf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET(r) (((r).fc_rxbuf_err_his[0]) & 0x7ff)
#define BCM89500_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_RXBUF_ERR_HISr_RESERVEDf_GET(r) ((((r).fc_rxbuf_err_his[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_RXBUF_ERR_HISr_RESERVEDf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXBUF_ERR_HIS.
 *
 */
#define BCM89500_A0_READ_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_RXBUF_ERR_HISr,(r._fc_rxbuf_err_his),2)
#define BCM89500_A0_WRITE_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_RXBUF_ERR_HISr,&(r._fc_rxbuf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXBUF_ERR_HISr BCM89500_A0_FC_RXBUF_ERR_HISr
#define FC_RXBUF_ERR_HISr_SIZE BCM89500_A0_FC_RXBUF_ERR_HISr_SIZE
typedef BCM89500_A0_FC_RXBUF_ERR_HISr_t FC_RXBUF_ERR_HISr_t;
#define FC_RXBUF_ERR_HISr_CLR BCM89500_A0_FC_RXBUF_ERR_HISr_CLR
#define FC_RXBUF_ERR_HISr_SET BCM89500_A0_FC_RXBUF_ERR_HISr_SET
#define FC_RXBUF_ERR_HISr_GET BCM89500_A0_FC_RXBUF_ERR_HISr_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET BCM89500_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET BCM89500_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET
#define FC_RXBUF_ERR_HISr_RESERVEDf_GET BCM89500_A0_FC_RXBUF_ERR_HISr_RESERVEDf_GET
#define FC_RXBUF_ERR_HISr_RESERVEDf_SET BCM89500_A0_FC_RXBUF_ERR_HISr_RESERVEDf_SET
#define READ_FC_RXBUF_ERR_HISr BCM89500_A0_READ_FC_RXBUF_ERR_HISr
#define WRITE_FC_RXBUF_ERR_HISr BCM89500_A0_WRITE_FC_RXBUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_RXBUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_RXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     RX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     RXPAUSE_HIS      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_RXPAUSE_HISr 0x00000aa4

#define BCM89500_A0_FC_RXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXPAUSE_HIS.
 *
 */
typedef union BCM89500_A0_FC_RXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxpause_his[1];
	uint32_t _fc_rxpause_his;
} BCM89500_A0_FC_RXPAUSE_HISr_t;

#define BCM89500_A0_FC_RXPAUSE_HISr_CLR(r) (r).fc_rxpause_his[0] = 0
#define BCM89500_A0_FC_RXPAUSE_HISr_SET(r,d) (r).fc_rxpause_his[0] = d
#define BCM89500_A0_FC_RXPAUSE_HISr_GET(r) (r).fc_rxpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET(r) (((r).fc_rxpause_his[0]) & 0x7ff)
#define BCM89500_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_RXPAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_rxpause_his[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_RXPAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXPAUSE_HIS.
 *
 */
#define BCM89500_A0_READ_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_RXPAUSE_HISr,(r._fc_rxpause_his),2)
#define BCM89500_A0_WRITE_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_RXPAUSE_HISr,&(r._fc_rxpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXPAUSE_HISr BCM89500_A0_FC_RXPAUSE_HISr
#define FC_RXPAUSE_HISr_SIZE BCM89500_A0_FC_RXPAUSE_HISr_SIZE
typedef BCM89500_A0_FC_RXPAUSE_HISr_t FC_RXPAUSE_HISr_t;
#define FC_RXPAUSE_HISr_CLR BCM89500_A0_FC_RXPAUSE_HISr_CLR
#define FC_RXPAUSE_HISr_SET BCM89500_A0_FC_RXPAUSE_HISr_SET
#define FC_RXPAUSE_HISr_GET BCM89500_A0_FC_RXPAUSE_HISr_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_GET BCM89500_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_SET BCM89500_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET
#define FC_RXPAUSE_HISr_RESERVEDf_GET BCM89500_A0_FC_RXPAUSE_HISr_RESERVEDf_GET
#define FC_RXPAUSE_HISr_RESERVEDf_SET BCM89500_A0_FC_RXPAUSE_HISr_RESERVEDf_SET
#define READ_FC_RXPAUSE_HISr BCM89500_A0_READ_FC_RXPAUSE_HISr
#define WRITE_FC_RXPAUSE_HISr BCM89500_A0_WRITE_FC_RXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_RXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_RX_HYST
 * BLOCKS:   SYS
 * DESC:     Rx-Base Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     RX_HYST_THRS     
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_RX_HYSTr 0x00000a54

#define BCM89500_A0_FC_RX_HYSTr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_HYST.
 *
 */
typedef union BCM89500_A0_FC_RX_HYSTr_s {
	uint32_t v[1];
	uint32_t fc_rx_hyst[1];
	uint32_t _fc_rx_hyst;
} BCM89500_A0_FC_RX_HYSTr_t;

#define BCM89500_A0_FC_RX_HYSTr_CLR(r) (r).fc_rx_hyst[0] = 0
#define BCM89500_A0_FC_RX_HYSTr_SET(r,d) (r).fc_rx_hyst[0] = d
#define BCM89500_A0_FC_RX_HYSTr_GET(r) (r).fc_rx_hyst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET(r) (((r).fc_rx_hyst[0]) & 0xff)
#define BCM89500_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_RX_HYSTr_RESERVEDf_GET(r) ((((r).fc_rx_hyst[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_RX_HYSTr_RESERVEDf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_HYST.
 *
 */
#define BCM89500_A0_READ_FC_RX_HYSTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_RX_HYSTr,(r._fc_rx_hyst),2)
#define BCM89500_A0_WRITE_FC_RX_HYSTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_RX_HYSTr,&(r._fc_rx_hyst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_HYSTr BCM89500_A0_FC_RX_HYSTr
#define FC_RX_HYSTr_SIZE BCM89500_A0_FC_RX_HYSTr_SIZE
typedef BCM89500_A0_FC_RX_HYSTr_t FC_RX_HYSTr_t;
#define FC_RX_HYSTr_CLR BCM89500_A0_FC_RX_HYSTr_CLR
#define FC_RX_HYSTr_SET BCM89500_A0_FC_RX_HYSTr_SET
#define FC_RX_HYSTr_GET BCM89500_A0_FC_RX_HYSTr_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_GET BCM89500_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_SET BCM89500_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET
#define FC_RX_HYSTr_RESERVEDf_GET BCM89500_A0_FC_RX_HYSTr_RESERVEDf_GET
#define FC_RX_HYSTr_RESERVEDf_SET BCM89500_A0_FC_RX_HYSTr_RESERVEDf_SET
#define READ_FC_RX_HYSTr BCM89500_A0_READ_FC_RX_HYSTr
#define WRITE_FC_RX_HYSTr BCM89500_A0_WRITE_FC_RX_HYSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_RX_HYSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_RX_MAX_PTR
 * BLOCKS:   SYS
 * DESC:     Rx-Base Max-Buffer Remap Register
 * SIZE:     16
 * FIELDS:
 *     MAXBUF_REMAP     Max_Buffer_ReMap Value.
 *     RESERVED         Reserved
 *     EN_REMAP         Enable remap.
 *
 ******************************************************************************/
#define BCM89500_A0_FC_RX_MAX_PTRr 0x00000a56

#define BCM89500_A0_FC_RX_MAX_PTRr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_MAX_PTR.
 *
 */
typedef union BCM89500_A0_FC_RX_MAX_PTRr_s {
	uint32_t v[1];
	uint32_t fc_rx_max_ptr[1];
	uint32_t _fc_rx_max_ptr;
} BCM89500_A0_FC_RX_MAX_PTRr_t;

#define BCM89500_A0_FC_RX_MAX_PTRr_CLR(r) (r).fc_rx_max_ptr[0] = 0
#define BCM89500_A0_FC_RX_MAX_PTRr_SET(r,d) (r).fc_rx_max_ptr[0] = d
#define BCM89500_A0_FC_RX_MAX_PTRr_GET(r) (r).fc_rx_max_ptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET(r) (((r).fc_rx_max_ptr[0]) & 0x7ff)
#define BCM89500_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_RX_MAX_PTRr_RESERVEDf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 11) & 0xf)
#define BCM89500_A0_FC_RX_MAX_PTRr_RESERVEDf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM89500_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 15) & 0x1)
#define BCM89500_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FC_RX_MAX_PTR.
 *
 */
#define BCM89500_A0_READ_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_RX_MAX_PTRr,(r._fc_rx_max_ptr),2)
#define BCM89500_A0_WRITE_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_RX_MAX_PTRr,&(r._fc_rx_max_ptr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_MAX_PTRr BCM89500_A0_FC_RX_MAX_PTRr
#define FC_RX_MAX_PTRr_SIZE BCM89500_A0_FC_RX_MAX_PTRr_SIZE
typedef BCM89500_A0_FC_RX_MAX_PTRr_t FC_RX_MAX_PTRr_t;
#define FC_RX_MAX_PTRr_CLR BCM89500_A0_FC_RX_MAX_PTRr_CLR
#define FC_RX_MAX_PTRr_SET BCM89500_A0_FC_RX_MAX_PTRr_SET
#define FC_RX_MAX_PTRr_GET BCM89500_A0_FC_RX_MAX_PTRr_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET BCM89500_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET BCM89500_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET
#define FC_RX_MAX_PTRr_RESERVEDf_GET BCM89500_A0_FC_RX_MAX_PTRr_RESERVEDf_GET
#define FC_RX_MAX_PTRr_RESERVEDf_SET BCM89500_A0_FC_RX_MAX_PTRr_RESERVEDf_SET
#define FC_RX_MAX_PTRr_EN_REMAPf_GET BCM89500_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET
#define FC_RX_MAX_PTRr_EN_REMAPf_SET BCM89500_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET
#define READ_FC_RX_MAX_PTRr BCM89500_A0_READ_FC_RX_MAX_PTRr
#define WRITE_FC_RX_MAX_PTRr BCM89500_A0_WRITE_FC_RX_MAX_PTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_RX_MAX_PTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_RX_RSRV
 * BLOCKS:   SYS
 * DESC:     Rx-Base Reserved Register
 * SIZE:     16
 * FIELDS:
 *     RESV_CTRL        
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_RX_RSRVr 0x00000a52

#define BCM89500_A0_FC_RX_RSRVr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RSRV.
 *
 */
typedef union BCM89500_A0_FC_RX_RSRVr_s {
	uint32_t v[1];
	uint32_t fc_rx_rsrv[1];
	uint32_t _fc_rx_rsrv;
} BCM89500_A0_FC_RX_RSRVr_t;

#define BCM89500_A0_FC_RX_RSRVr_CLR(r) (r).fc_rx_rsrv[0] = 0
#define BCM89500_A0_FC_RX_RSRVr_SET(r,d) (r).fc_rx_rsrv[0] = d
#define BCM89500_A0_FC_RX_RSRVr_GET(r) (r).fc_rx_rsrv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_RX_RSRVr_RESV_CTRLf_GET(r) (((r).fc_rx_rsrv[0]) & 0xff)
#define BCM89500_A0_FC_RX_RSRVr_RESV_CTRLf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_RX_RSRVr_RESERVEDf_GET(r) ((((r).fc_rx_rsrv[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_RX_RSRVr_RESERVEDf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RSRV.
 *
 */
#define BCM89500_A0_READ_FC_RX_RSRVr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_RX_RSRVr,(r._fc_rx_rsrv),2)
#define BCM89500_A0_WRITE_FC_RX_RSRVr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_RX_RSRVr,&(r._fc_rx_rsrv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RSRVr BCM89500_A0_FC_RX_RSRVr
#define FC_RX_RSRVr_SIZE BCM89500_A0_FC_RX_RSRVr_SIZE
typedef BCM89500_A0_FC_RX_RSRVr_t FC_RX_RSRVr_t;
#define FC_RX_RSRVr_CLR BCM89500_A0_FC_RX_RSRVr_CLR
#define FC_RX_RSRVr_SET BCM89500_A0_FC_RX_RSRVr_SET
#define FC_RX_RSRVr_GET BCM89500_A0_FC_RX_RSRVr_GET
#define FC_RX_RSRVr_RESV_CTRLf_GET BCM89500_A0_FC_RX_RSRVr_RESV_CTRLf_GET
#define FC_RX_RSRVr_RESV_CTRLf_SET BCM89500_A0_FC_RX_RSRVr_RESV_CTRLf_SET
#define FC_RX_RSRVr_RESERVEDf_GET BCM89500_A0_FC_RX_RSRVr_RESERVEDf_GET
#define FC_RX_RSRVr_RESERVEDf_SET BCM89500_A0_FC_RX_RSRVr_RESERVEDf_SET
#define READ_FC_RX_RSRVr BCM89500_A0_READ_FC_RX_RSRVr
#define WRITE_FC_RX_RSRVr BCM89500_A0_WRITE_FC_RX_RSRVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_RX_RSRVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_RX_RUNOFF
 * BLOCKS:   SYS
 * DESC:     Rx-Base Run-Off Register
 * SIZE:     16
 * FIELDS:
 *     RUN_OFF          
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_RX_RUNOFFr 0x00000a50

#define BCM89500_A0_FC_RX_RUNOFFr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RUNOFF.
 *
 */
typedef union BCM89500_A0_FC_RX_RUNOFFr_s {
	uint32_t v[1];
	uint32_t fc_rx_runoff[1];
	uint32_t _fc_rx_runoff;
} BCM89500_A0_FC_RX_RUNOFFr_t;

#define BCM89500_A0_FC_RX_RUNOFFr_CLR(r) (r).fc_rx_runoff[0] = 0
#define BCM89500_A0_FC_RX_RUNOFFr_SET(r,d) (r).fc_rx_runoff[0] = d
#define BCM89500_A0_FC_RX_RUNOFFr_GET(r) (r).fc_rx_runoff[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_RX_RUNOFFr_RUN_OFFf_GET(r) (((r).fc_rx_runoff[0]) & 0xff)
#define BCM89500_A0_FC_RX_RUNOFFr_RUN_OFFf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_FC_RX_RUNOFFr_RESERVEDf_GET(r) ((((r).fc_rx_runoff[0]) >> 8) & 0xff)
#define BCM89500_A0_FC_RX_RUNOFFr_RESERVEDf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RUNOFF.
 *
 */
#define BCM89500_A0_READ_FC_RX_RUNOFFr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_RX_RUNOFFr,(r._fc_rx_runoff),2)
#define BCM89500_A0_WRITE_FC_RX_RUNOFFr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_RX_RUNOFFr,&(r._fc_rx_runoff),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RUNOFFr BCM89500_A0_FC_RX_RUNOFFr
#define FC_RX_RUNOFFr_SIZE BCM89500_A0_FC_RX_RUNOFFr_SIZE
typedef BCM89500_A0_FC_RX_RUNOFFr_t FC_RX_RUNOFFr_t;
#define FC_RX_RUNOFFr_CLR BCM89500_A0_FC_RX_RUNOFFr_CLR
#define FC_RX_RUNOFFr_SET BCM89500_A0_FC_RX_RUNOFFr_SET
#define FC_RX_RUNOFFr_GET BCM89500_A0_FC_RX_RUNOFFr_GET
#define FC_RX_RUNOFFr_RUN_OFFf_GET BCM89500_A0_FC_RX_RUNOFFr_RUN_OFFf_GET
#define FC_RX_RUNOFFr_RUN_OFFf_SET BCM89500_A0_FC_RX_RUNOFFr_RUN_OFFf_SET
#define FC_RX_RUNOFFr_RESERVEDf_GET BCM89500_A0_FC_RX_RUNOFFr_RESERVEDf_GET
#define FC_RX_RUNOFFr_RESERVEDf_SET BCM89500_A0_FC_RX_RUNOFFr_RESERVEDf_SET
#define READ_FC_RX_RUNOFFr BCM89500_A0_READ_FC_RX_RUNOFFr
#define WRITE_FC_RX_RUNOFFr BCM89500_A0_WRITE_FC_RX_RUNOFFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_RX_RUNOFFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr 0x00000a38

#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q[1];
	uint32_t _fc_total_th_drop_q;
} BCM89500_A0_FC_TOTAL_TH_DROP_Qr_t;

#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_CLR(r) (r).fc_total_th_drop_q[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_SET(r,d) (r).fc_total_th_drop_q[0] = d
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_GET(r) (r).fc_total_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q[0]) & 0x7ff)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),(r._fc_total_th_drop_q),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),&(r._fc_total_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Qr BCM89500_A0_FC_TOTAL_TH_DROP_Qr
#define FC_TOTAL_TH_DROP_Qr_SIZE BCM89500_A0_FC_TOTAL_TH_DROP_Qr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_DROP_Qr_t FC_TOTAL_TH_DROP_Qr_t;
#define FC_TOTAL_TH_DROP_Qr_CLR BCM89500_A0_FC_TOTAL_TH_DROP_Qr_CLR
#define FC_TOTAL_TH_DROP_Qr_SET BCM89500_A0_FC_TOTAL_TH_DROP_Qr_SET
#define FC_TOTAL_TH_DROP_Qr_GET BCM89500_A0_FC_TOTAL_TH_DROP_Qr_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Qr BCM89500_A0_READ_FC_TOTAL_TH_DROP_Qr
#define WRITE_FC_TOTAL_TH_DROP_Qr BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r 0x00000ac4

#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q45.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q45[1];
	uint32_t _fc_total_th_drop_q45;
} BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_t;

#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_CLR(r) (r).fc_total_th_drop_q45[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_SET(r,d) (r).fc_total_th_drop_q45[0] = d
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_GET(r) (r).fc_total_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q45[0]) & 0x7ff)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q45[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q45.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),(r._fc_total_th_drop_q45),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),&(r._fc_total_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q45r BCM89500_A0_FC_TOTAL_TH_DROP_Q45r
#define FC_TOTAL_TH_DROP_Q45r_SIZE BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_t FC_TOTAL_TH_DROP_Q45r_t;
#define FC_TOTAL_TH_DROP_Q45r_CLR BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_CLR
#define FC_TOTAL_TH_DROP_Q45r_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_SET
#define FC_TOTAL_TH_DROP_Q45r_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q45r BCM89500_A0_READ_FC_TOTAL_TH_DROP_Q45r
#define WRITE_FC_TOTAL_TH_DROP_Q45r BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr 0x00000d38

#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_imp[1];
	uint32_t _fc_total_th_drop_q_imp;
} BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_t;

#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR(r) (r).fc_total_th_drop_q_imp[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET(r,d) (r).fc_total_th_drop_q_imp[0] = d
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET(r) (r).fc_total_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_imp[0]) & 0x7ff)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q_imp[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),(r._fc_total_th_drop_q_imp),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_total_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_IMPr BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr
#define FC_TOTAL_TH_DROP_Q_IMPr_SIZE BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_t FC_TOTAL_TH_DROP_Q_IMPr_t;
#define FC_TOTAL_TH_DROP_Q_IMPr_CLR BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR
#define FC_TOTAL_TH_DROP_Q_IMPr_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q_IMPr BCM89500_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr
#define WRITE_FC_TOTAL_TH_DROP_Q_IMPr BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr 0x00000e38

#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_wan[1];
	uint32_t _fc_total_th_drop_q_wan;
} BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_t;

#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR(r) (r).fc_total_th_drop_q_wan[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_SET(r,d) (r).fc_total_th_drop_q_wan[0] = d
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_GET(r) (r).fc_total_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_wan[0]) & 0x7ff)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q_wan[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),(r._fc_total_th_drop_q_wan),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),&(r._fc_total_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_WANr BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr
#define FC_TOTAL_TH_DROP_Q_WANr_SIZE BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_t FC_TOTAL_TH_DROP_Q_WANr_t;
#define FC_TOTAL_TH_DROP_Q_WANr_CLR BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR
#define FC_TOTAL_TH_DROP_Q_WANr_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_SET
#define FC_TOTAL_TH_DROP_Q_WANr_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q_WANr BCM89500_A0_READ_FC_TOTAL_TH_DROP_Q_WANr
#define WRITE_FC_TOTAL_TH_DROP_Q_WANr BCM89500_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr 0x00000a28

#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_HYST_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q[1];
	uint32_t _fc_total_th_hyst_q;
} BCM89500_A0_FC_TOTAL_TH_HYST_Qr_t;

#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_CLR(r) (r).fc_total_th_hyst_q[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_SET(r,d) (r).fc_total_th_hyst_q[0] = d
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_GET(r) (r).fc_total_th_hyst_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),(r._fc_total_th_hyst_q),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),&(r._fc_total_th_hyst_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Qr BCM89500_A0_FC_TOTAL_TH_HYST_Qr
#define FC_TOTAL_TH_HYST_Qr_SIZE BCM89500_A0_FC_TOTAL_TH_HYST_Qr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_HYST_Qr_t FC_TOTAL_TH_HYST_Qr_t;
#define FC_TOTAL_TH_HYST_Qr_CLR BCM89500_A0_FC_TOTAL_TH_HYST_Qr_CLR
#define FC_TOTAL_TH_HYST_Qr_SET BCM89500_A0_FC_TOTAL_TH_HYST_Qr_SET
#define FC_TOTAL_TH_HYST_Qr_GET BCM89500_A0_FC_TOTAL_TH_HYST_Qr_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Qr BCM89500_A0_READ_FC_TOTAL_TH_HYST_Qr
#define WRITE_FC_TOTAL_TH_HYST_Qr BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_HYST_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q45
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r 0x00000abc

#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q45.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q45[1];
	uint32_t _fc_total_th_hyst_q45;
} BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_t;

#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_CLR(r) (r).fc_total_th_hyst_q45[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_SET(r,d) (r).fc_total_th_hyst_q45[0] = d
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_GET(r) (r).fc_total_th_hyst_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q45[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q45[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q45.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),(r._fc_total_th_hyst_q45),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),&(r._fc_total_th_hyst_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q45r BCM89500_A0_FC_TOTAL_TH_HYST_Q45r
#define FC_TOTAL_TH_HYST_Q45r_SIZE BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_t FC_TOTAL_TH_HYST_Q45r_t;
#define FC_TOTAL_TH_HYST_Q45r_CLR BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_CLR
#define FC_TOTAL_TH_HYST_Q45r_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_SET
#define FC_TOTAL_TH_HYST_Q45r_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q45r BCM89500_A0_READ_FC_TOTAL_TH_HYST_Q45r
#define WRITE_FC_TOTAL_TH_HYST_Q45r BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_HYST_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr 0x00000d28

#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_imp[1];
	uint32_t _fc_total_th_hyst_q_imp;
} BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_t;

#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR(r) (r).fc_total_th_hyst_q_imp[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET(r,d) (r).fc_total_th_hyst_q_imp[0] = d
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET(r) (r).fc_total_th_hyst_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_imp[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q_imp[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),(r._fc_total_th_hyst_q_imp),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),&(r._fc_total_th_hyst_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_IMPr BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr
#define FC_TOTAL_TH_HYST_Q_IMPr_SIZE BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_t FC_TOTAL_TH_HYST_Q_IMPr_t;
#define FC_TOTAL_TH_HYST_Q_IMPr_CLR BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR
#define FC_TOTAL_TH_HYST_Q_IMPr_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q_IMPr BCM89500_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr
#define WRITE_FC_TOTAL_TH_HYST_Q_IMPr BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_HYST_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr 0x00000e28

#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_wan[1];
	uint32_t _fc_total_th_hyst_q_wan;
} BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_t;

#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR(r) (r).fc_total_th_hyst_q_wan[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_SET(r,d) (r).fc_total_th_hyst_q_wan[0] = d
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_GET(r) (r).fc_total_th_hyst_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_wan[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q_wan[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),(r._fc_total_th_hyst_q_wan),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),&(r._fc_total_th_hyst_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_WANr BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr
#define FC_TOTAL_TH_HYST_Q_WANr_SIZE BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_t FC_TOTAL_TH_HYST_Q_WANr_t;
#define FC_TOTAL_TH_HYST_Q_WANr_CLR BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR
#define FC_TOTAL_TH_HYST_Q_WANr_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_SET
#define FC_TOTAL_TH_HYST_Q_WANr_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q_WANr BCM89500_A0_READ_FC_TOTAL_TH_HYST_Q_WANr
#define WRITE_FC_TOTAL_TH_HYST_Q_WANr BCM89500_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_HYST_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr 0x00000a30

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q[1];
	uint32_t _fc_total_th_pause_q;
} BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_t;

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_CLR(r) (r).fc_total_th_pause_q[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_SET(r,d) (r).fc_total_th_pause_q[0] = d
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_GET(r) (r).fc_total_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),(r._fc_total_th_pause_q),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),&(r._fc_total_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Qr BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr
#define FC_TOTAL_TH_PAUSE_Qr_SIZE BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_t FC_TOTAL_TH_PAUSE_Qr_t;
#define FC_TOTAL_TH_PAUSE_Qr_CLR BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_CLR
#define FC_TOTAL_TH_PAUSE_Qr_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_SET
#define FC_TOTAL_TH_PAUSE_Qr_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Qr BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Qr
#define WRITE_FC_TOTAL_TH_PAUSE_Qr BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r 0x00000ac0

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q45.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q45[1];
	uint32_t _fc_total_th_pause_q45;
} BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_t;

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR(r) (r).fc_total_th_pause_q45[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_SET(r,d) (r).fc_total_th_pause_q45[0] = d
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_GET(r) (r).fc_total_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q45[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q45.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),(r._fc_total_th_pause_q45),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),&(r._fc_total_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q45r BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r
#define FC_TOTAL_TH_PAUSE_Q45r_SIZE BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_t FC_TOTAL_TH_PAUSE_Q45r_t;
#define FC_TOTAL_TH_PAUSE_Q45r_CLR BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR
#define FC_TOTAL_TH_PAUSE_Q45r_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_SET
#define FC_TOTAL_TH_PAUSE_Q45r_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q45r BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Q45r
#define WRITE_FC_TOTAL_TH_PAUSE_Q45r BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr 0x00000d30

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_imp[1];
	uint32_t _fc_total_th_pause_q_imp;
} BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t;

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_total_th_pause_q_imp[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_total_th_pause_q_imp[0] = d
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET(r) (r).fc_total_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_imp[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_total_th_pause_q_imp),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_total_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_IMPr BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t FC_TOTAL_TH_PAUSE_Q_IMPr_t;
#define FC_TOTAL_TH_PAUSE_Q_IMPr_CLR BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_IMPr BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr 0x00000e30

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_wan[1];
	uint32_t _fc_total_th_pause_q_wan;
} BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t;

#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR(r) (r).fc_total_th_pause_q_wan[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_total_th_pause_q_wan[0] = d
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET(r) (r).fc_total_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_wan[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_total_th_pause_q_wan),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_total_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_WANr BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr
#define FC_TOTAL_TH_PAUSE_Q_WANr_SIZE BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t FC_TOTAL_TH_PAUSE_Q_WANr_t;
#define FC_TOTAL_TH_PAUSE_Q_WANr_CLR BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR
#define FC_TOTAL_TH_PAUSE_Q_WANr_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_WANr BCM89500_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_WANr BCM89500_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Total Reserved Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_RSRV_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr 0x00000a40

#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_RSRV_Q.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_rsrv_q[1];
	uint32_t _fc_total_th_rsrv_q;
} BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_t;

#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_CLR(r) (r).fc_total_th_rsrv_q[0] = 0
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_SET(r,d) (r).fc_total_th_rsrv_q[0] = d
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_GET(r) (r).fc_total_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET(r) (((r).fc_total_th_rsrv_q[0]) & 0x3ff)
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_RSRV_Q.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),(r._fc_total_th_rsrv_q),2)
#define BCM89500_A0_WRITE_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),&(r._fc_total_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_RSRV_Qr BCM89500_A0_FC_TOTAL_TH_RSRV_Qr
#define FC_TOTAL_TH_RSRV_Qr_SIZE BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_SIZE
typedef BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_t FC_TOTAL_TH_RSRV_Qr_t;
#define FC_TOTAL_TH_RSRV_Qr_CLR BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_CLR
#define FC_TOTAL_TH_RSRV_Qr_SET BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_SET
#define FC_TOTAL_TH_RSRV_Qr_GET BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET
#define FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_RSRV_Qr BCM89500_A0_READ_FC_TOTAL_TH_RSRV_Qr
#define WRITE_FC_TOTAL_TH_RSRV_Qr BCM89500_A0_WRITE_FC_TOTAL_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_USE        Total Used count.This register records the current total used count.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TOTAL_USEDr 0x00000a82

#define BCM89500_A0_FC_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_USED.
 *
 */
typedef union BCM89500_A0_FC_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_total_used[1];
	uint32_t _fc_total_used;
} BCM89500_A0_FC_TOTAL_USEDr_t;

#define BCM89500_A0_FC_TOTAL_USEDr_CLR(r) (r).fc_total_used[0] = 0
#define BCM89500_A0_FC_TOTAL_USEDr_SET(r,d) (r).fc_total_used[0] = d
#define BCM89500_A0_FC_TOTAL_USEDr_GET(r) (r).fc_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET(r) (((r).fc_total_used[0]) & 0x7ff)
#define BCM89500_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_TOTAL_USEDr_RESERVEDf_GET(r) ((((r).fc_total_used[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_TOTAL_USEDr_RESERVEDf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_USED.
 *
 */
#define BCM89500_A0_READ_FC_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TOTAL_USEDr,(r._fc_total_used),2)
#define BCM89500_A0_WRITE_FC_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TOTAL_USEDr,&(r._fc_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_USEDr BCM89500_A0_FC_TOTAL_USEDr
#define FC_TOTAL_USEDr_SIZE BCM89500_A0_FC_TOTAL_USEDr_SIZE
typedef BCM89500_A0_FC_TOTAL_USEDr_t FC_TOTAL_USEDr_t;
#define FC_TOTAL_USEDr_CLR BCM89500_A0_FC_TOTAL_USEDr_CLR
#define FC_TOTAL_USEDr_SET BCM89500_A0_FC_TOTAL_USEDr_SET
#define FC_TOTAL_USEDr_GET BCM89500_A0_FC_TOTAL_USEDr_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_GET BCM89500_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_SET BCM89500_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET
#define FC_TOTAL_USEDr_RESERVEDf_GET BCM89500_A0_FC_TOTAL_USEDr_RESERVEDf_GET
#define FC_TOTAL_USEDr_RESERVEDf_SET BCM89500_A0_FC_TOTAL_USEDr_RESERVEDf_SET
#define READ_FC_TOTAL_USEDr BCM89500_A0_READ_FC_TOTAL_USEDr
#define WRITE_FC_TOTAL_USEDr BCM89500_A0_WRITE_FC_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     TX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     TXPAUSE_HIS      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXPAUSE_HISr 0x00000aa2

#define BCM89500_A0_FC_TXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXPAUSE_HIS.
 *
 */
typedef union BCM89500_A0_FC_TXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_txpause_his[1];
	uint32_t _fc_txpause_his;
} BCM89500_A0_FC_TXPAUSE_HISr_t;

#define BCM89500_A0_FC_TXPAUSE_HISr_CLR(r) (r).fc_txpause_his[0] = 0
#define BCM89500_A0_FC_TXPAUSE_HISr_SET(r,d) (r).fc_txpause_his[0] = d
#define BCM89500_A0_FC_TXPAUSE_HISr_GET(r) (r).fc_txpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET(r) (((r).fc_txpause_his[0]) & 0x7ff)
#define BCM89500_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_FC_TXPAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_txpause_his[0]) >> 11) & 0x1f)
#define BCM89500_A0_FC_TXPAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TXPAUSE_HIS.
 *
 */
#define BCM89500_A0_READ_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXPAUSE_HISr,(r._fc_txpause_his),2)
#define BCM89500_A0_WRITE_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXPAUSE_HISr,&(r._fc_txpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXPAUSE_HISr BCM89500_A0_FC_TXPAUSE_HISr
#define FC_TXPAUSE_HISr_SIZE BCM89500_A0_FC_TXPAUSE_HISr_SIZE
typedef BCM89500_A0_FC_TXPAUSE_HISr_t FC_TXPAUSE_HISr_t;
#define FC_TXPAUSE_HISr_CLR BCM89500_A0_FC_TXPAUSE_HISr_CLR
#define FC_TXPAUSE_HISr_SET BCM89500_A0_FC_TXPAUSE_HISr_SET
#define FC_TXPAUSE_HISr_GET BCM89500_A0_FC_TXPAUSE_HISr_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_GET BCM89500_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_SET BCM89500_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET
#define FC_TXPAUSE_HISr_RESERVEDf_GET BCM89500_A0_FC_TXPAUSE_HISr_RESERVEDf_GET
#define FC_TXPAUSE_HISr_RESERVEDf_SET BCM89500_A0_FC_TXPAUSE_HISr_RESERVEDf_SET
#define READ_FC_TXPAUSE_HISr BCM89500_A0_READ_FC_TXPAUSE_HISr
#define WRITE_FC_TXPAUSE_HISr BCM89500_A0_WRITE_FC_TXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr 0x00000a20

#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q[1];
	uint32_t _fc_txq_th_drop_q;
} BCM89500_A0_FC_TXQ_TH_DROP_Qr_t;

#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_CLR(r) (r).fc_txq_th_drop_q[0] = 0
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_SET(r,d) (r).fc_txq_th_drop_q[0] = d
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_GET(r) (r).fc_txq_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),(r._fc_txq_th_drop_q),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),&(r._fc_txq_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Qr BCM89500_A0_FC_TXQ_TH_DROP_Qr
#define FC_TXQ_TH_DROP_Qr_SIZE BCM89500_A0_FC_TXQ_TH_DROP_Qr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_DROP_Qr_t FC_TXQ_TH_DROP_Qr_t;
#define FC_TXQ_TH_DROP_Qr_CLR BCM89500_A0_FC_TXQ_TH_DROP_Qr_CLR
#define FC_TXQ_TH_DROP_Qr_SET BCM89500_A0_FC_TXQ_TH_DROP_Qr_SET
#define FC_TXQ_TH_DROP_Qr_GET BCM89500_A0_FC_TXQ_TH_DROP_Qr_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET BCM89500_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET BCM89500_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Qr_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Qr_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Qr BCM89500_A0_READ_FC_TXQ_TH_DROP_Qr
#define WRITE_FC_TXQ_TH_DROP_Qr BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r 0x00000ab8

#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q45.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q45[1];
	uint32_t _fc_txq_th_drop_q45;
} BCM89500_A0_FC_TXQ_TH_DROP_Q45r_t;

#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_CLR(r) (r).fc_txq_th_drop_q45[0] = 0
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_SET(r,d) (r).fc_txq_th_drop_q45[0] = d
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_GET(r) (r).fc_txq_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q45[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q45[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q45.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),(r._fc_txq_th_drop_q45),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),&(r._fc_txq_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q45r BCM89500_A0_FC_TXQ_TH_DROP_Q45r
#define FC_TXQ_TH_DROP_Q45r_SIZE BCM89500_A0_FC_TXQ_TH_DROP_Q45r_SIZE
typedef BCM89500_A0_FC_TXQ_TH_DROP_Q45r_t FC_TXQ_TH_DROP_Q45r_t;
#define FC_TXQ_TH_DROP_Q45r_CLR BCM89500_A0_FC_TXQ_TH_DROP_Q45r_CLR
#define FC_TXQ_TH_DROP_Q45r_SET BCM89500_A0_FC_TXQ_TH_DROP_Q45r_SET
#define FC_TXQ_TH_DROP_Q45r_GET BCM89500_A0_FC_TXQ_TH_DROP_Q45r_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET BCM89500_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET BCM89500_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q45r BCM89500_A0_READ_FC_TXQ_TH_DROP_Q45r
#define WRITE_FC_TXQ_TH_DROP_Q45r BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr 0x00000d20

#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_IMP.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_imp[1];
	uint32_t _fc_txq_th_drop_q_imp;
} BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_t;

#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR(r) (r).fc_txq_th_drop_q_imp[0] = 0
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_SET(r,d) (r).fc_txq_th_drop_q_imp[0] = d
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_GET(r) (r).fc_txq_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_imp[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q_imp[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_IMP.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),(r._fc_txq_th_drop_q_imp),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_txq_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_IMPr BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr
#define FC_TXQ_TH_DROP_Q_IMPr_SIZE BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_t FC_TXQ_TH_DROP_Q_IMPr_t;
#define FC_TXQ_TH_DROP_Q_IMPr_CLR BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR
#define FC_TXQ_TH_DROP_Q_IMPr_SET BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_SET
#define FC_TXQ_TH_DROP_Q_IMPr_GET BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q_IMPr BCM89500_A0_READ_FC_TXQ_TH_DROP_Q_IMPr
#define WRITE_FC_TXQ_TH_DROP_Q_IMPr BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr 0x00000e20

#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_WAN.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_wan[1];
	uint32_t _fc_txq_th_drop_q_wan;
} BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_t;

#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_CLR(r) (r).fc_txq_th_drop_q_wan[0] = 0
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_SET(r,d) (r).fc_txq_th_drop_q_wan[0] = d
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_GET(r) (r).fc_txq_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_wan[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q_wan[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_WAN.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),(r._fc_txq_th_drop_q_wan),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),&(r._fc_txq_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_WANr BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr
#define FC_TXQ_TH_DROP_Q_WANr_SIZE BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_t FC_TXQ_TH_DROP_Q_WANr_t;
#define FC_TXQ_TH_DROP_Q_WANr_CLR BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_CLR
#define FC_TXQ_TH_DROP_Q_WANr_SET BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_SET
#define FC_TXQ_TH_DROP_Q_WANr_GET BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q_WANr BCM89500_A0_READ_FC_TXQ_TH_DROP_Q_WANr
#define WRITE_FC_TXQ_TH_DROP_Q_WANr BCM89500_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr 0x00000a18

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q[1];
	uint32_t _fc_txq_th_pause_q;
} BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_t;

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_CLR(r) (r).fc_txq_th_pause_q[0] = 0
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_SET(r,d) (r).fc_txq_th_pause_q[0] = d
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_GET(r) (r).fc_txq_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),(r._fc_txq_th_pause_q),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),&(r._fc_txq_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Qr BCM89500_A0_FC_TXQ_TH_PAUSE_Qr
#define FC_TXQ_TH_PAUSE_Qr_SIZE BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_t FC_TXQ_TH_PAUSE_Qr_t;
#define FC_TXQ_TH_PAUSE_Qr_CLR BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_CLR
#define FC_TXQ_TH_PAUSE_Qr_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_SET
#define FC_TXQ_TH_PAUSE_Qr_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Qr BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Qr
#define WRITE_FC_TXQ_TH_PAUSE_Qr BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r 0x00000ab4

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q45.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q45[1];
	uint32_t _fc_txq_th_pause_q45;
} BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_t;

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_CLR(r) (r).fc_txq_th_pause_q45[0] = 0
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_SET(r,d) (r).fc_txq_th_pause_q45[0] = d
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_GET(r) (r).fc_txq_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q45[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q45.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),(r._fc_txq_th_pause_q45),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),&(r._fc_txq_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q45r BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r
#define FC_TXQ_TH_PAUSE_Q45r_SIZE BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE
typedef BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_t FC_TXQ_TH_PAUSE_Q45r_t;
#define FC_TXQ_TH_PAUSE_Q45r_CLR BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_CLR
#define FC_TXQ_TH_PAUSE_Q45r_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_SET
#define FC_TXQ_TH_PAUSE_Q45r_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q45r BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Q45r
#define WRITE_FC_TXQ_TH_PAUSE_Q45r BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr 0x00000d18

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_imp[1];
	uint32_t _fc_txq_th_pause_q_imp;
} BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t;

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_txq_th_pause_q_imp[0] = 0
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_txq_th_pause_q_imp[0] = d
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET(r) (r).fc_txq_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_imp[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_txq_th_pause_q_imp),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_txq_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_IMPr BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr
#define FC_TXQ_TH_PAUSE_Q_IMPr_SIZE BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t FC_TXQ_TH_PAUSE_Q_IMPr_t;
#define FC_TXQ_TH_PAUSE_Q_IMPr_CLR BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR
#define FC_TXQ_TH_PAUSE_Q_IMPr_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_IMPr BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr
#define WRITE_FC_TXQ_TH_PAUSE_Q_IMPr BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr 0x00000e18

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_wan[1];
	uint32_t _fc_txq_th_pause_q_wan;
} BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_t;

#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR(r) (r).fc_txq_th_pause_q_wan[0] = 0
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_txq_th_pause_q_wan[0] = d
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET(r) (r).fc_txq_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_wan[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_txq_th_pause_q_wan),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_txq_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_WANr BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr
#define FC_TXQ_TH_PAUSE_Q_WANr_SIZE BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_t FC_TXQ_TH_PAUSE_Q_WANr_t;
#define FC_TXQ_TH_PAUSE_Q_WANr_CLR BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR
#define FC_TXQ_TH_PAUSE_Q_WANr_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_WANr BCM89500_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr
#define WRITE_FC_TXQ_TH_PAUSE_Q_WANr BCM89500_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr 0x00000a10

#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q[1];
	uint32_t _fc_txq_th_rsrv_q;
} BCM89500_A0_FC_TXQ_TH_RSRV_Qr_t;

#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_CLR(r) (r).fc_txq_th_rsrv_q[0] = 0
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_SET(r,d) (r).fc_txq_th_rsrv_q[0] = d
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_GET(r) (r).fc_txq_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),(r._fc_txq_th_rsrv_q),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),&(r._fc_txq_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Qr BCM89500_A0_FC_TXQ_TH_RSRV_Qr
#define FC_TXQ_TH_RSRV_Qr_SIZE BCM89500_A0_FC_TXQ_TH_RSRV_Qr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_RSRV_Qr_t FC_TXQ_TH_RSRV_Qr_t;
#define FC_TXQ_TH_RSRV_Qr_CLR BCM89500_A0_FC_TXQ_TH_RSRV_Qr_CLR
#define FC_TXQ_TH_RSRV_Qr_SET BCM89500_A0_FC_TXQ_TH_RSRV_Qr_SET
#define FC_TXQ_TH_RSRV_Qr_GET BCM89500_A0_FC_TXQ_TH_RSRV_Qr_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET BCM89500_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET BCM89500_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET BCM89500_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET BCM89500_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Qr BCM89500_A0_READ_FC_TXQ_TH_RSRV_Qr
#define WRITE_FC_TXQ_TH_RSRV_Qr BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r 0x00000ab0

#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q45.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q45[1];
	uint32_t _fc_txq_th_rsrv_q45;
} BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_t;

#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_CLR(r) (r).fc_txq_th_rsrv_q45[0] = 0
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_SET(r,d) (r).fc_txq_th_rsrv_q45[0] = d
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_GET(r) (r).fc_txq_th_rsrv_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q45[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q45[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q45.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),(r._fc_txq_th_rsrv_q45),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),&(r._fc_txq_th_rsrv_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q45r BCM89500_A0_FC_TXQ_TH_RSRV_Q45r
#define FC_TXQ_TH_RSRV_Q45r_SIZE BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_SIZE
typedef BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_t FC_TXQ_TH_RSRV_Q45r_t;
#define FC_TXQ_TH_RSRV_Q45r_CLR BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_CLR
#define FC_TXQ_TH_RSRV_Q45r_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_SET
#define FC_TXQ_TH_RSRV_Q45r_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q45r BCM89500_A0_READ_FC_TXQ_TH_RSRV_Q45r
#define WRITE_FC_TXQ_TH_RSRV_Q45r BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_RSRV_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr 0x00000d10

#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_imp[1];
	uint32_t _fc_txq_th_rsrv_q_imp;
} BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_t;

#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR(r) (r).fc_txq_th_rsrv_q_imp[0] = 0
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET(r,d) (r).fc_txq_th_rsrv_q_imp[0] = d
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET(r) (r).fc_txq_th_rsrv_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_imp[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q_imp[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),(r._fc_txq_th_rsrv_q_imp),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),&(r._fc_txq_th_rsrv_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_IMPr BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr
#define FC_TXQ_TH_RSRV_Q_IMPr_SIZE BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_t FC_TXQ_TH_RSRV_Q_IMPr_t;
#define FC_TXQ_TH_RSRV_Q_IMPr_CLR BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR
#define FC_TXQ_TH_RSRV_Q_IMPr_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q_IMPr BCM89500_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr
#define WRITE_FC_TXQ_TH_RSRV_Q_IMPr BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_RSRV_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr 0x00000e10

#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
typedef union BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_wan[1];
	uint32_t _fc_txq_th_rsrv_q_wan;
} BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_t;

#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR(r) (r).fc_txq_th_rsrv_q_wan[0] = 0
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_SET(r,d) (r).fc_txq_th_rsrv_q_wan[0] = d
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_GET(r) (r).fc_txq_th_rsrv_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_wan[0]) & 0x3ff)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q_wan[0]) >> 10) & 0x3f)
#define BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
#define BCM89500_A0_READ_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),(r._fc_txq_th_rsrv_q_wan),2)
#define BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),&(r._fc_txq_th_rsrv_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_WANr BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr
#define FC_TXQ_TH_RSRV_Q_WANr_SIZE BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE
typedef BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_t FC_TXQ_TH_RSRV_Q_WANr_t;
#define FC_TXQ_TH_RSRV_Q_WANr_CLR BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR
#define FC_TXQ_TH_RSRV_Q_WANr_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_SET
#define FC_TXQ_TH_RSRV_Q_WANr_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q_WANr BCM89500_A0_READ_FC_TXQ_TH_RSRV_Q_WANr
#define WRITE_FC_TXQ_TH_RSRV_Q_WANr BCM89500_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FC_TXQ_TH_RSRV_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  FRAME_BUF
 * BLOCKS:   SYS
 * DESC:     Frame Buffer Memory
 * SIZE:     64
 * FIELDS:
 *     GENMEM_DATA      RAM data entry
 *
 ******************************************************************************/
#define BCM89500_A0_FRAME_BUFm 0x00000000

#define BCM89500_A0_FRAME_BUFm_MIN 0
#define BCM89500_A0_FRAME_BUFm_MAX 4095
#define BCM89500_A0_FRAME_BUFm_CMAX(u) 4095
#define BCM89500_A0_FRAME_BUFm_SIZE 8

/*
 * This structure should be used to declare and program FRAME_BUF.
 *
 */
typedef union BCM89500_A0_FRAME_BUFm_s {
	uint32_t v[2];
	uint32_t frame_buf[2];
	uint32_t _frame_buf;
} BCM89500_A0_FRAME_BUFm_t;

#define BCM89500_A0_FRAME_BUFm_CLR(r) CDK_MEMSET(&((r)._frame_buf), 0, sizeof(BCM89500_A0_FRAME_BUFm_t))
#define BCM89500_A0_FRAME_BUFm_SET(r,i,d) (r).frame_buf[i] = d
#define BCM89500_A0_FRAME_BUFm_GET(r,i) (r).frame_buf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_FRAME_BUFm_GENMEM_DATAf_GET(r,a) cdk_field_get((r).frame_buf,0,63,a)
#define BCM89500_A0_FRAME_BUFm_GENMEM_DATAf_SET(r,a) cdk_field_set((r).frame_buf,0,63,a)

/*
 * These macros can be used to access FRAME_BUF.
 *
 */
#define BCM89500_A0_READ_FRAME_BUFm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_FRAME_BUFm,i,(m),8)
#define BCM89500_A0_WRITE_FRAME_BUFm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_FRAME_BUFm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FRAME_BUFm BCM89500_A0_FRAME_BUFm
#define FRAME_BUFm_MIN BCM89500_A0_FRAME_BUFm_MIN
#define FRAME_BUFm_MAX BCM89500_A0_FRAME_BUFm_MAX
#define FRAME_BUFm_CMAX(u) BCM89500_A0_FRAME_BUFm_CMAX(u)
#define FRAME_BUFm_SIZE BCM89500_A0_FRAME_BUFm_SIZE
typedef BCM89500_A0_FRAME_BUFm_t FRAME_BUFm_t;
#define FRAME_BUFm_CLR BCM89500_A0_FRAME_BUFm_CLR
#define FRAME_BUFm_SET BCM89500_A0_FRAME_BUFm_SET
#define FRAME_BUFm_GET BCM89500_A0_FRAME_BUFm_GET
#define FRAME_BUFm_GENMEM_DATAf_GET BCM89500_A0_FRAME_BUFm_GENMEM_DATAf_GET
#define FRAME_BUFm_GENMEM_DATAf_SET BCM89500_A0_FRAME_BUFm_GENMEM_DATAf_SET
#define READ_FRAME_BUFm BCM89500_A0_READ_FRAME_BUFm
#define WRITE_FRAME_BUFm BCM89500_A0_WRITE_FRAME_BUFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_FRAME_BUFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable The hash function for the ARL such that entries are direct mapped to the table. The hash function is enabled as the default for the polar ARL,but can be disabled by setting this bit.
 *     RESERVED_0       Reserved
 *     AGE_ACC          Age Accele rate, test only.1: accelerate 128 times for age process.0: Keep original age process.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_GARLCFGr 0x00000400

#define BCM89500_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 *
 */
typedef union BCM89500_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM89500_A0_GARLCFGr_t;

#define BCM89500_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM89500_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM89500_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM89500_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_GARLCFGr_RESERVED_0f_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM89500_A0_GARLCFGr_RESERVED_0f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM89500_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_GARLCFGr_RESERVED_1f_GET(r) ((((r).garlcfg[0]) >> 3) & 0x1f)
#define BCM89500_A0_GARLCFGr_RESERVED_1f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access GARLCFG.
 *
 */
#define BCM89500_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_GARLCFGr,(r._garlcfg),1)
#define BCM89500_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM89500_A0_GARLCFGr
#define GARLCFGr_SIZE BCM89500_A0_GARLCFGr_SIZE
typedef BCM89500_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM89500_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM89500_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM89500_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM89500_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM89500_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_RESERVED_0f_GET BCM89500_A0_GARLCFGr_RESERVED_0f_GET
#define GARLCFGr_RESERVED_0f_SET BCM89500_A0_GARLCFGr_RESERVED_0f_SET
#define GARLCFGr_AGE_ACCf_GET BCM89500_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM89500_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_RESERVED_1f_GET BCM89500_A0_GARLCFGr_RESERVED_1f_GET
#define GARLCFGr_RESERVED_1f_SET BCM89500_A0_GARLCFGr_RESERVED_1f_SET
#define READ_GARLCFGr BCM89500_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM89500_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GARLCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GMII_IO_DS_SEL0
 * BLOCKS:   SYS
 * DESC:     GMII I/O Pad Drive Strength Select 0 Register (Engineering use only) (polar feature)
 * SIZE:     32
 * FIELDS:
 *     GMII_IO_DS_SEL0  (sel1, sel0)11: 7.5mA (original drive level)10: 6.6mA01: 5.25mA00: 3.9mABit 2: mii3Bit 1: mii2Bit 0: mii1(default 1 for 7.5mA)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_GMII_IO_DS_SEL0r 0x0000e034

#define BCM89500_A0_GMII_IO_DS_SEL0r_SIZE 4

/*
 * This structure should be used to declare and program GMII_IO_DS_SEL0.
 *
 */
typedef union BCM89500_A0_GMII_IO_DS_SEL0r_s {
	uint32_t v[1];
	uint32_t gmii_io_ds_sel0[1];
	uint32_t _gmii_io_ds_sel0;
} BCM89500_A0_GMII_IO_DS_SEL0r_t;

#define BCM89500_A0_GMII_IO_DS_SEL0r_CLR(r) (r).gmii_io_ds_sel0[0] = 0
#define BCM89500_A0_GMII_IO_DS_SEL0r_SET(r,d) (r).gmii_io_ds_sel0[0] = d
#define BCM89500_A0_GMII_IO_DS_SEL0r_GET(r) (r).gmii_io_ds_sel0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GMII_IO_DS_SEL0r_GMII_IO_DS_SEL0f_GET(r) (((r).gmii_io_ds_sel0[0]) & 0x7)
#define BCM89500_A0_GMII_IO_DS_SEL0r_GMII_IO_DS_SEL0f_SET(r,f) (r).gmii_io_ds_sel0[0]=(((r).gmii_io_ds_sel0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_GMII_IO_DS_SEL0r_RESERVEDf_GET(r) ((((r).gmii_io_ds_sel0[0]) >> 3) & 0x1fffffff)
#define BCM89500_A0_GMII_IO_DS_SEL0r_RESERVEDf_SET(r,f) (r).gmii_io_ds_sel0[0]=(((r).gmii_io_ds_sel0[0] & ~((uint32_t)0x1fffffff << 3)) | ((((uint32_t)f) & 0x1fffffff) << 3))

/*
 * These macros can be used to access GMII_IO_DS_SEL0.
 *
 */
#define BCM89500_A0_READ_GMII_IO_DS_SEL0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_GMII_IO_DS_SEL0r,(r._gmii_io_ds_sel0),4)
#define BCM89500_A0_WRITE_GMII_IO_DS_SEL0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_GMII_IO_DS_SEL0r,&(r._gmii_io_ds_sel0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMII_IO_DS_SEL0r BCM89500_A0_GMII_IO_DS_SEL0r
#define GMII_IO_DS_SEL0r_SIZE BCM89500_A0_GMII_IO_DS_SEL0r_SIZE
typedef BCM89500_A0_GMII_IO_DS_SEL0r_t GMII_IO_DS_SEL0r_t;
#define GMII_IO_DS_SEL0r_CLR BCM89500_A0_GMII_IO_DS_SEL0r_CLR
#define GMII_IO_DS_SEL0r_SET BCM89500_A0_GMII_IO_DS_SEL0r_SET
#define GMII_IO_DS_SEL0r_GET BCM89500_A0_GMII_IO_DS_SEL0r_GET
#define GMII_IO_DS_SEL0r_GMII_IO_DS_SEL0f_GET BCM89500_A0_GMII_IO_DS_SEL0r_GMII_IO_DS_SEL0f_GET
#define GMII_IO_DS_SEL0r_GMII_IO_DS_SEL0f_SET BCM89500_A0_GMII_IO_DS_SEL0r_GMII_IO_DS_SEL0f_SET
#define GMII_IO_DS_SEL0r_RESERVEDf_GET BCM89500_A0_GMII_IO_DS_SEL0r_RESERVEDf_GET
#define GMII_IO_DS_SEL0r_RESERVEDf_SET BCM89500_A0_GMII_IO_DS_SEL0r_RESERVEDf_SET
#define READ_GMII_IO_DS_SEL0r BCM89500_A0_READ_GMII_IO_DS_SEL0r
#define WRITE_GMII_IO_DS_SEL0r BCM89500_A0_WRITE_GMII_IO_DS_SEL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GMII_IO_DS_SEL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GMII_IO_DS_SEL1
 * BLOCKS:   SYS
 * DESC:     GMII I/O Pad Drive Strength Select 1 Register (Engineering use only) (polar feature)
 * SIZE:     32
 * FIELDS:
 *     GMII_IO_DS_SEL1  (sel1, sel0)11: 7.5mA (original drive level)10: 6.6mA01: 5.25mA00: 3.9mABit 2: mii3Bit 1: mii2Bit 0: mii1(default 1 for 7.5mA)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_GMII_IO_DS_SEL1r 0x0000e038

#define BCM89500_A0_GMII_IO_DS_SEL1r_SIZE 4

/*
 * This structure should be used to declare and program GMII_IO_DS_SEL1.
 *
 */
typedef union BCM89500_A0_GMII_IO_DS_SEL1r_s {
	uint32_t v[1];
	uint32_t gmii_io_ds_sel1[1];
	uint32_t _gmii_io_ds_sel1;
} BCM89500_A0_GMII_IO_DS_SEL1r_t;

#define BCM89500_A0_GMII_IO_DS_SEL1r_CLR(r) (r).gmii_io_ds_sel1[0] = 0
#define BCM89500_A0_GMII_IO_DS_SEL1r_SET(r,d) (r).gmii_io_ds_sel1[0] = d
#define BCM89500_A0_GMII_IO_DS_SEL1r_GET(r) (r).gmii_io_ds_sel1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GMII_IO_DS_SEL1r_GMII_IO_DS_SEL1f_GET(r) (((r).gmii_io_ds_sel1[0]) & 0x7)
#define BCM89500_A0_GMII_IO_DS_SEL1r_GMII_IO_DS_SEL1f_SET(r,f) (r).gmii_io_ds_sel1[0]=(((r).gmii_io_ds_sel1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_GMII_IO_DS_SEL1r_RESERVEDf_GET(r) ((((r).gmii_io_ds_sel1[0]) >> 3) & 0x1fffffff)
#define BCM89500_A0_GMII_IO_DS_SEL1r_RESERVEDf_SET(r,f) (r).gmii_io_ds_sel1[0]=(((r).gmii_io_ds_sel1[0] & ~((uint32_t)0x1fffffff << 3)) | ((((uint32_t)f) & 0x1fffffff) << 3))

/*
 * These macros can be used to access GMII_IO_DS_SEL1.
 *
 */
#define BCM89500_A0_READ_GMII_IO_DS_SEL1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_GMII_IO_DS_SEL1r,(r._gmii_io_ds_sel1),4)
#define BCM89500_A0_WRITE_GMII_IO_DS_SEL1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_GMII_IO_DS_SEL1r,&(r._gmii_io_ds_sel1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMII_IO_DS_SEL1r BCM89500_A0_GMII_IO_DS_SEL1r
#define GMII_IO_DS_SEL1r_SIZE BCM89500_A0_GMII_IO_DS_SEL1r_SIZE
typedef BCM89500_A0_GMII_IO_DS_SEL1r_t GMII_IO_DS_SEL1r_t;
#define GMII_IO_DS_SEL1r_CLR BCM89500_A0_GMII_IO_DS_SEL1r_CLR
#define GMII_IO_DS_SEL1r_SET BCM89500_A0_GMII_IO_DS_SEL1r_SET
#define GMII_IO_DS_SEL1r_GET BCM89500_A0_GMII_IO_DS_SEL1r_GET
#define GMII_IO_DS_SEL1r_GMII_IO_DS_SEL1f_GET BCM89500_A0_GMII_IO_DS_SEL1r_GMII_IO_DS_SEL1f_GET
#define GMII_IO_DS_SEL1r_GMII_IO_DS_SEL1f_SET BCM89500_A0_GMII_IO_DS_SEL1r_GMII_IO_DS_SEL1f_SET
#define GMII_IO_DS_SEL1r_RESERVEDf_GET BCM89500_A0_GMII_IO_DS_SEL1r_RESERVEDf_GET
#define GMII_IO_DS_SEL1r_RESERVEDf_SET BCM89500_A0_GMII_IO_DS_SEL1r_RESERVEDf_SET
#define READ_GMII_IO_DS_SEL1r BCM89500_A0_READ_GMII_IO_DS_SEL1r
#define WRITE_GMII_IO_DS_SEL1r BCM89500_A0_WRITE_GMII_IO_DS_SEL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GMII_IO_DS_SEL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GMII_IO_SR_CTL
 * BLOCKS:   SYS
 * DESC:     GMII I/O Pad Slew Rate Control Register (Engineering use only) (polar feature)
 * SIZE:     32
 * FIELDS:
 *     GMII_IO_SR_CTL   1'b1: Normal; 1'b0: High speedBit 2: mii3Bit 1: mii2Bit 0: mii1(default 0 for high speed)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_GMII_IO_SR_CTLr 0x0000e030

#define BCM89500_A0_GMII_IO_SR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GMII_IO_SR_CTL.
 *
 */
typedef union BCM89500_A0_GMII_IO_SR_CTLr_s {
	uint32_t v[1];
	uint32_t gmii_io_sr_ctl[1];
	uint32_t _gmii_io_sr_ctl;
} BCM89500_A0_GMII_IO_SR_CTLr_t;

#define BCM89500_A0_GMII_IO_SR_CTLr_CLR(r) (r).gmii_io_sr_ctl[0] = 0
#define BCM89500_A0_GMII_IO_SR_CTLr_SET(r,d) (r).gmii_io_sr_ctl[0] = d
#define BCM89500_A0_GMII_IO_SR_CTLr_GET(r) (r).gmii_io_sr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GMII_IO_SR_CTLr_GMII_IO_SR_CTLf_GET(r) (((r).gmii_io_sr_ctl[0]) & 0x7)
#define BCM89500_A0_GMII_IO_SR_CTLr_GMII_IO_SR_CTLf_SET(r,f) (r).gmii_io_sr_ctl[0]=(((r).gmii_io_sr_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_GMII_IO_SR_CTLr_RESERVEDf_GET(r) ((((r).gmii_io_sr_ctl[0]) >> 3) & 0x1fffffff)
#define BCM89500_A0_GMII_IO_SR_CTLr_RESERVEDf_SET(r,f) (r).gmii_io_sr_ctl[0]=(((r).gmii_io_sr_ctl[0] & ~((uint32_t)0x1fffffff << 3)) | ((((uint32_t)f) & 0x1fffffff) << 3))

/*
 * These macros can be used to access GMII_IO_SR_CTL.
 *
 */
#define BCM89500_A0_READ_GMII_IO_SR_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_GMII_IO_SR_CTLr,(r._gmii_io_sr_ctl),4)
#define BCM89500_A0_WRITE_GMII_IO_SR_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_GMII_IO_SR_CTLr,&(r._gmii_io_sr_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMII_IO_SR_CTLr BCM89500_A0_GMII_IO_SR_CTLr
#define GMII_IO_SR_CTLr_SIZE BCM89500_A0_GMII_IO_SR_CTLr_SIZE
typedef BCM89500_A0_GMII_IO_SR_CTLr_t GMII_IO_SR_CTLr_t;
#define GMII_IO_SR_CTLr_CLR BCM89500_A0_GMII_IO_SR_CTLr_CLR
#define GMII_IO_SR_CTLr_SET BCM89500_A0_GMII_IO_SR_CTLr_SET
#define GMII_IO_SR_CTLr_GET BCM89500_A0_GMII_IO_SR_CTLr_GET
#define GMII_IO_SR_CTLr_GMII_IO_SR_CTLf_GET BCM89500_A0_GMII_IO_SR_CTLr_GMII_IO_SR_CTLf_GET
#define GMII_IO_SR_CTLr_GMII_IO_SR_CTLf_SET BCM89500_A0_GMII_IO_SR_CTLr_GMII_IO_SR_CTLf_SET
#define GMII_IO_SR_CTLr_RESERVEDf_GET BCM89500_A0_GMII_IO_SR_CTLr_RESERVEDf_GET
#define GMII_IO_SR_CTLr_RESERVEDf_SET BCM89500_A0_GMII_IO_SR_CTLr_RESERVEDf_SET
#define READ_GMII_IO_SR_CTLr BCM89500_A0_READ_GMII_IO_SR_CTLr
#define WRITE_GMII_IO_SR_CTLr BCM89500_A0_WRITE_GMII_IO_SR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GMII_IO_SR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB CountersResets all MIB counters for all ports to zero (Pages 20h-28h). The host must set the bit and then clear the bit in successive write cycles to activate the reset operation.
 *     RXBPDU_EN        Receive BPDU Enable.Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.
 *     RESERVED         Reserved
 *     FRM_MNGP         IMP Port EnableThis field enables the IMP(In-band Management Port) function under manabement mode.00=No IMP Port01=Reserved10=Enable IMP Port(IMP0) only   All traffic to CPU from LAN ports and WAN ports will be forwarded to IMP0.11=Enable Dual-IMP ports(both IMP0 and IMP1)   All traffic to CPU from LAN ports will be forwarded to IMP0; and All traffic from WAN ports will be forwarded to IMP1.These bits are ignored when SW_FWD_MODE=Unmanaged in the Switch Mode Register, and the device will behave as if there is no defined management port.In polar, IMP0 is Port 8 and IMP1 is Port 5.When only IMP0 is enabled,(FRM_MNGT_PORT = 10), IMP0 is also called IMP port.
 *
 ******************************************************************************/
#define BCM89500_A0_GMNGCFGr 0x00000200

#define BCM89500_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 *
 */
typedef union BCM89500_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM89500_A0_GMNGCFGr_t;

#define BCM89500_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM89500_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM89500_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GMNGCFGr_RST_MIB_CNTf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM89500_A0_GMNGCFGr_RST_MIB_CNTf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_GMNGCFGr_RXBPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM89500_A0_GMNGCFGr_RXBPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_GMNGCFGr_RESERVEDf_GET(r) ((((r).gmngcfg[0]) >> 2) & 0xf)
#define BCM89500_A0_GMNGCFGr_RESERVEDf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM89500_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM89500_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 *
 */
#define BCM89500_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM89500_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM89500_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM89500_A0_GMNGCFGr_SIZE
typedef BCM89500_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM89500_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM89500_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM89500_A0_GMNGCFGr_GET
#define GMNGCFGr_RST_MIB_CNTf_GET BCM89500_A0_GMNGCFGr_RST_MIB_CNTf_GET
#define GMNGCFGr_RST_MIB_CNTf_SET BCM89500_A0_GMNGCFGr_RST_MIB_CNTf_SET
#define GMNGCFGr_RXBPDU_ENf_GET BCM89500_A0_GMNGCFGr_RXBPDU_ENf_GET
#define GMNGCFGr_RXBPDU_ENf_SET BCM89500_A0_GMNGCFGr_RXBPDU_ENf_SET
#define GMNGCFGr_RESERVEDf_GET BCM89500_A0_GMNGCFGr_RESERVEDf_GET
#define GMNGCFGr_RESERVEDf_SET BCM89500_A0_GMNGCFGr_RESERVEDf_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM89500_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM89500_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM89500_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM89500_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GMNGCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GREEN_MODE_DATA
 * BLOCKS:   SYS
 * DESC:     Green Mode Data Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     GREEN_MODE_DATA  Green mode parameters(GL_T_A, GL_T_B, EXP10, and THRESHOLD) loaded from OTP.
 *
 ******************************************************************************/
#define BCM89500_A0_GREEN_MODE_DATAr 0x000000c0

#define BCM89500_A0_GREEN_MODE_DATAr_SIZE 8

/*
 * This structure should be used to declare and program GREEN_MODE_DATA.
 *
 */
typedef union BCM89500_A0_GREEN_MODE_DATAr_s {
	uint32_t v[2];
	uint32_t green_mode_data[2];
	uint32_t _green_mode_data;
} BCM89500_A0_GREEN_MODE_DATAr_t;

#define BCM89500_A0_GREEN_MODE_DATAr_CLR(r) CDK_MEMSET(&((r)._green_mode_data), 0, sizeof(BCM89500_A0_GREEN_MODE_DATAr_t))
#define BCM89500_A0_GREEN_MODE_DATAr_SET(r,i,d) (r).green_mode_data[i] = d
#define BCM89500_A0_GREEN_MODE_DATAr_GET(r,i) (r).green_mode_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_GET(r,a) cdk_field_get((r).green_mode_data,0,63,a)
#define BCM89500_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_SET(r,a) cdk_field_set((r).green_mode_data,0,63,a)

/*
 * These macros can be used to access GREEN_MODE_DATA.
 *
 */
#define BCM89500_A0_READ_GREEN_MODE_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_GREEN_MODE_DATAr,(r._green_mode_data),8)
#define BCM89500_A0_WRITE_GREEN_MODE_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_GREEN_MODE_DATAr,&(r._green_mode_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GREEN_MODE_DATAr BCM89500_A0_GREEN_MODE_DATAr
#define GREEN_MODE_DATAr_SIZE BCM89500_A0_GREEN_MODE_DATAr_SIZE
typedef BCM89500_A0_GREEN_MODE_DATAr_t GREEN_MODE_DATAr_t;
#define GREEN_MODE_DATAr_CLR BCM89500_A0_GREEN_MODE_DATAr_CLR
#define GREEN_MODE_DATAr_SET BCM89500_A0_GREEN_MODE_DATAr_SET
#define GREEN_MODE_DATAr_GET BCM89500_A0_GREEN_MODE_DATAr_GET
#define GREEN_MODE_DATAr_GREEN_MODE_DATAf_GET BCM89500_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_GET
#define GREEN_MODE_DATAr_GREEN_MODE_DATAf_SET BCM89500_A0_GREEN_MODE_DATAr_GREEN_MODE_DATAf_SET
#define READ_GREEN_MODE_DATAr BCM89500_A0_READ_GREEN_MODE_DATAr
#define WRITE_GREEN_MODE_DATAr BCM89500_A0_WRITE_GREEN_MODE_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GREEN_MODE_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  GREEN_MODE_SELECT
 * BLOCKS:   SYS
 * DESC:     Green mode Select Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *     GREEN_MODE_SELECT Green mode select parameter loaded from OTP.
 *
 ******************************************************************************/
#define BCM89500_A0_GREEN_MODE_SELECTr 0x000000c9

#define BCM89500_A0_GREEN_MODE_SELECTr_SIZE 1

/*
 * This structure should be used to declare and program GREEN_MODE_SELECT.
 *
 */
typedef union BCM89500_A0_GREEN_MODE_SELECTr_s {
	uint32_t v[1];
	uint32_t green_mode_select[1];
	uint32_t _green_mode_select;
} BCM89500_A0_GREEN_MODE_SELECTr_t;

#define BCM89500_A0_GREEN_MODE_SELECTr_CLR(r) (r).green_mode_select[0] = 0
#define BCM89500_A0_GREEN_MODE_SELECTr_SET(r,d) (r).green_mode_select[0] = d
#define BCM89500_A0_GREEN_MODE_SELECTr_GET(r) (r).green_mode_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_GREEN_MODE_SELECTr_RESERVEDf_GET(r) (((r).green_mode_select[0]) & 0x1)
#define BCM89500_A0_GREEN_MODE_SELECTr_RESERVEDf_SET(r,f) (r).green_mode_select[0]=(((r).green_mode_select[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_GET(r) ((((r).green_mode_select[0]) >> 1) & 0x7f)
#define BCM89500_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_SET(r,f) (r).green_mode_select[0]=(((r).green_mode_select[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access GREEN_MODE_SELECT.
 *
 */
#define BCM89500_A0_READ_GREEN_MODE_SELECTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_GREEN_MODE_SELECTr,(r._green_mode_select),1)
#define BCM89500_A0_WRITE_GREEN_MODE_SELECTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_GREEN_MODE_SELECTr,&(r._green_mode_select),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GREEN_MODE_SELECTr BCM89500_A0_GREEN_MODE_SELECTr
#define GREEN_MODE_SELECTr_SIZE BCM89500_A0_GREEN_MODE_SELECTr_SIZE
typedef BCM89500_A0_GREEN_MODE_SELECTr_t GREEN_MODE_SELECTr_t;
#define GREEN_MODE_SELECTr_CLR BCM89500_A0_GREEN_MODE_SELECTr_CLR
#define GREEN_MODE_SELECTr_SET BCM89500_A0_GREEN_MODE_SELECTr_SET
#define GREEN_MODE_SELECTr_GET BCM89500_A0_GREEN_MODE_SELECTr_GET
#define GREEN_MODE_SELECTr_RESERVEDf_GET BCM89500_A0_GREEN_MODE_SELECTr_RESERVEDf_GET
#define GREEN_MODE_SELECTr_RESERVEDf_SET BCM89500_A0_GREEN_MODE_SELECTr_RESERVEDf_SET
#define GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_GET BCM89500_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_GET
#define GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_SET BCM89500_A0_GREEN_MODE_SELECTr_GREEN_MODE_SELECTf_SET
#define READ_GREEN_MODE_SELECTr BCM89500_A0_READ_GREEN_MODE_SELECTr
#define WRITE_GREEN_MODE_SELECTr BCM89500_A0_WRITE_GREEN_MODE_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_GREEN_MODE_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANADV
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANADVr 0x00001408

#define BCM89500_A0_G_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV.
 *
 */
typedef union BCM89500_A0_G_ANADVr_s {
	uint32_t v[1];
	uint32_t g_anadv[1];
	uint32_t _g_anadv;
} BCM89500_A0_G_ANADVr_t;

#define BCM89500_A0_G_ANADVr_CLR(r) (r).g_anadv[0] = 0
#define BCM89500_A0_G_ANADVr_SET(r,d) (r).g_anadv[0] = d
#define BCM89500_A0_G_ANADVr_GET(r) (r).g_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANADVr_PROTOCOL_SELf_GET(r) (((r).g_anadv[0]) & 0x1f)
#define BCM89500_A0_G_ANADVr_PROTOCOL_SELf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANADVr_ADV_B10Tf_GET(r) ((((r).g_anadv[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANADVr_ADV_B10Tf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANADVr_ADV_B100Xf_GET(r) ((((r).g_anadv[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANADVr_ADV_B100Xf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANADVr_ADV_B100_FDXf_GET(r) ((((r).g_anadv[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANADVr_ADV_B100_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANADVr_B100T4f_GET(r) ((((r).g_anadv[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANADVr_B100T4f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANADVr_ASY_PAUSEf_GET(r) ((((r).g_anadv[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANADVr_ASY_PAUSEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANADVr_RESERVED_1f_GET(r) ((((r).g_anadv[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANADVr_RESERVED_1f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANADVr_REMOTE_FAULTf_GET(r) ((((r).g_anadv[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANADVr_REMOTE_FAULTf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANADVr_RESERVED_2f_GET(r) ((((r).g_anadv[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANADVr_RESERVED_2f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANADVr_NEXT_PAGEf_GET(r) ((((r).g_anadv[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANADVr_NEXT_PAGEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV.
 *
 */
#define BCM89500_A0_READ_G_ANADVr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANADVr,(r._g_anadv),2)
#define BCM89500_A0_WRITE_G_ANADVr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANADVr,&(r._g_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADVr BCM89500_A0_G_ANADVr
#define G_ANADVr_SIZE BCM89500_A0_G_ANADVr_SIZE
typedef BCM89500_A0_G_ANADVr_t G_ANADVr_t;
#define G_ANADVr_CLR BCM89500_A0_G_ANADVr_CLR
#define G_ANADVr_SET BCM89500_A0_G_ANADVr_SET
#define G_ANADVr_GET BCM89500_A0_G_ANADVr_GET
#define G_ANADVr_PROTOCOL_SELf_GET BCM89500_A0_G_ANADVr_PROTOCOL_SELf_GET
#define G_ANADVr_PROTOCOL_SELf_SET BCM89500_A0_G_ANADVr_PROTOCOL_SELf_SET
#define G_ANADVr_ADV_B10Tf_GET BCM89500_A0_G_ANADVr_ADV_B10Tf_GET
#define G_ANADVr_ADV_B10Tf_SET BCM89500_A0_G_ANADVr_ADV_B10Tf_SET
#define G_ANADVr_ADV_B10T_FDXf_GET BCM89500_A0_G_ANADVr_ADV_B10T_FDXf_GET
#define G_ANADVr_ADV_B10T_FDXf_SET BCM89500_A0_G_ANADVr_ADV_B10T_FDXf_SET
#define G_ANADVr_ADV_B100Xf_GET BCM89500_A0_G_ANADVr_ADV_B100Xf_GET
#define G_ANADVr_ADV_B100Xf_SET BCM89500_A0_G_ANADVr_ADV_B100Xf_SET
#define G_ANADVr_ADV_B100_FDXf_GET BCM89500_A0_G_ANADVr_ADV_B100_FDXf_GET
#define G_ANADVr_ADV_B100_FDXf_SET BCM89500_A0_G_ANADVr_ADV_B100_FDXf_SET
#define G_ANADVr_B100T4f_GET BCM89500_A0_G_ANADVr_B100T4f_GET
#define G_ANADVr_B100T4f_SET BCM89500_A0_G_ANADVr_B100T4f_SET
#define G_ANADVr_ADV_PAUSE_CAPf_GET BCM89500_A0_G_ANADVr_ADV_PAUSE_CAPf_GET
#define G_ANADVr_ADV_PAUSE_CAPf_SET BCM89500_A0_G_ANADVr_ADV_PAUSE_CAPf_SET
#define G_ANADVr_ASY_PAUSEf_GET BCM89500_A0_G_ANADVr_ASY_PAUSEf_GET
#define G_ANADVr_ASY_PAUSEf_SET BCM89500_A0_G_ANADVr_ASY_PAUSEf_SET
#define G_ANADVr_RESERVED_1f_GET BCM89500_A0_G_ANADVr_RESERVED_1f_GET
#define G_ANADVr_RESERVED_1f_SET BCM89500_A0_G_ANADVr_RESERVED_1f_SET
#define G_ANADVr_REMOTE_FAULTf_GET BCM89500_A0_G_ANADVr_REMOTE_FAULTf_GET
#define G_ANADVr_REMOTE_FAULTf_SET BCM89500_A0_G_ANADVr_REMOTE_FAULTf_SET
#define G_ANADVr_RESERVED_2f_GET BCM89500_A0_G_ANADVr_RESERVED_2f_GET
#define G_ANADVr_RESERVED_2f_SET BCM89500_A0_G_ANADVr_RESERVED_2f_SET
#define G_ANADVr_NEXT_PAGEf_GET BCM89500_A0_G_ANADVr_NEXT_PAGEf_GET
#define G_ANADVr_NEXT_PAGEf_SET BCM89500_A0_G_ANADVr_NEXT_PAGEf_SET
#define READ_G_ANADVr BCM89500_A0_READ_G_ANADVr
#define WRITE_G_ANADVr BCM89500_A0_WRITE_G_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANADV_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANADV_EXTr 0x00008808

#define BCM89500_A0_G_ANADV_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT.
 *
 */
typedef union BCM89500_A0_G_ANADV_EXTr_s {
	uint32_t v[1];
	uint32_t g_anadv_ext[1];
	uint32_t _g_anadv_ext;
} BCM89500_A0_G_ANADV_EXTr_t;

#define BCM89500_A0_G_ANADV_EXTr_CLR(r) (r).g_anadv_ext[0] = 0
#define BCM89500_A0_G_ANADV_EXTr_SET(r,d) (r).g_anadv_ext[0] = d
#define BCM89500_A0_G_ANADV_EXTr_GET(r) (r).g_anadv_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext[0]) & 0x1f)
#define BCM89500_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANADV_EXTr_ADV_B10Tf_GET(r) ((((r).g_anadv_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_ADV_B10Tf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANADV_EXTr_ADV_B100Xf_GET(r) ((((r).g_anadv_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_ADV_B100Xf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANADV_EXTr_B100T4f_GET(r) ((((r).g_anadv_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_B100T4f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANADV_EXTr_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANADV_EXTr_RESERVED_1f_GET(r) ((((r).g_anadv_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_RESERVED_1f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANADV_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANADV_EXTr_RESERVED_2f_GET(r) ((((r).g_anadv_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_RESERVED_2f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANADV_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANADV_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT.
 *
 */
#define BCM89500_A0_READ_G_ANADV_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANADV_EXTr,(r._g_anadv_ext),2)
#define BCM89500_A0_WRITE_G_ANADV_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANADV_EXTr,&(r._g_anadv_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXTr BCM89500_A0_G_ANADV_EXTr
#define G_ANADV_EXTr_SIZE BCM89500_A0_G_ANADV_EXTr_SIZE
typedef BCM89500_A0_G_ANADV_EXTr_t G_ANADV_EXTr_t;
#define G_ANADV_EXTr_CLR BCM89500_A0_G_ANADV_EXTr_CLR
#define G_ANADV_EXTr_SET BCM89500_A0_G_ANADV_EXTr_SET
#define G_ANADV_EXTr_GET BCM89500_A0_G_ANADV_EXTr_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_GET BCM89500_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_SET BCM89500_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET
#define G_ANADV_EXTr_ADV_B10Tf_GET BCM89500_A0_G_ANADV_EXTr_ADV_B10Tf_GET
#define G_ANADV_EXTr_ADV_B10Tf_SET BCM89500_A0_G_ANADV_EXTr_ADV_B10Tf_SET
#define G_ANADV_EXTr_ADV_B10T_FDXf_GET BCM89500_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET
#define G_ANADV_EXTr_ADV_B10T_FDXf_SET BCM89500_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET
#define G_ANADV_EXTr_ADV_B100Xf_GET BCM89500_A0_G_ANADV_EXTr_ADV_B100Xf_GET
#define G_ANADV_EXTr_ADV_B100Xf_SET BCM89500_A0_G_ANADV_EXTr_ADV_B100Xf_SET
#define G_ANADV_EXTr_ADV_B100_FDXf_GET BCM89500_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET
#define G_ANADV_EXTr_ADV_B100_FDXf_SET BCM89500_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET
#define G_ANADV_EXTr_B100T4f_GET BCM89500_A0_G_ANADV_EXTr_B100T4f_GET
#define G_ANADV_EXTr_B100T4f_SET BCM89500_A0_G_ANADV_EXTr_B100T4f_SET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_GET BCM89500_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_SET BCM89500_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXTr_ASY_PAUSEf_GET BCM89500_A0_G_ANADV_EXTr_ASY_PAUSEf_GET
#define G_ANADV_EXTr_ASY_PAUSEf_SET BCM89500_A0_G_ANADV_EXTr_ASY_PAUSEf_SET
#define G_ANADV_EXTr_RESERVED_1f_GET BCM89500_A0_G_ANADV_EXTr_RESERVED_1f_GET
#define G_ANADV_EXTr_RESERVED_1f_SET BCM89500_A0_G_ANADV_EXTr_RESERVED_1f_SET
#define G_ANADV_EXTr_REMOTE_FAULTf_GET BCM89500_A0_G_ANADV_EXTr_REMOTE_FAULTf_GET
#define G_ANADV_EXTr_REMOTE_FAULTf_SET BCM89500_A0_G_ANADV_EXTr_REMOTE_FAULTf_SET
#define G_ANADV_EXTr_RESERVED_2f_GET BCM89500_A0_G_ANADV_EXTr_RESERVED_2f_GET
#define G_ANADV_EXTr_RESERVED_2f_SET BCM89500_A0_G_ANADV_EXTr_RESERVED_2f_SET
#define G_ANADV_EXTr_NEXT_PAGEf_GET BCM89500_A0_G_ANADV_EXTr_NEXT_PAGEf_GET
#define G_ANADV_EXTr_NEXT_PAGEf_SET BCM89500_A0_G_ANADV_EXTr_NEXT_PAGEf_SET
#define READ_G_ANADV_EXTr BCM89500_A0_READ_G_ANADV_EXTr
#define WRITE_G_ANADV_EXTr BCM89500_A0_WRITE_G_ANADV_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANADV_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANADV_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANADV_EXT_P4r 0x00008408

#define BCM89500_A0_G_ANADV_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_ANADV_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_anadv_ext_p4[1];
	uint32_t _g_anadv_ext_p4;
} BCM89500_A0_G_ANADV_EXT_P4r_t;

#define BCM89500_A0_G_ANADV_EXT_P4r_CLR(r) (r).g_anadv_ext_p4[0] = 0
#define BCM89500_A0_G_ANADV_EXT_P4r_SET(r,d) (r).g_anadv_ext_p4[0] = d
#define BCM89500_A0_G_ANADV_EXT_P4r_GET(r) (r).g_anadv_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANADV_EXT_P4r_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext_p4[0]) & 0x1f)
#define BCM89500_A0_G_ANADV_EXT_P4r_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10Tf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10Tf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100Xf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100Xf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANADV_EXT_P4r_B100T4f_GET(r) ((((r).g_anadv_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_B100T4f_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANADV_EXT_P4r_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_1f_GET(r) ((((r).g_anadv_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_1f_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANADV_EXT_P4r_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_2f_GET(r) ((((r).g_anadv_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_2f_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANADV_EXT_P4r_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P4r_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext_p4[0]=(((r).g_anadv_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_ANADV_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANADV_EXT_P4r,(r._g_anadv_ext_p4),2)
#define BCM89500_A0_WRITE_G_ANADV_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANADV_EXT_P4r,&(r._g_anadv_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXT_P4r BCM89500_A0_G_ANADV_EXT_P4r
#define G_ANADV_EXT_P4r_SIZE BCM89500_A0_G_ANADV_EXT_P4r_SIZE
typedef BCM89500_A0_G_ANADV_EXT_P4r_t G_ANADV_EXT_P4r_t;
#define G_ANADV_EXT_P4r_CLR BCM89500_A0_G_ANADV_EXT_P4r_CLR
#define G_ANADV_EXT_P4r_SET BCM89500_A0_G_ANADV_EXT_P4r_SET
#define G_ANADV_EXT_P4r_GET BCM89500_A0_G_ANADV_EXT_P4r_GET
#define G_ANADV_EXT_P4r_PROTOCOL_SELf_GET BCM89500_A0_G_ANADV_EXT_P4r_PROTOCOL_SELf_GET
#define G_ANADV_EXT_P4r_PROTOCOL_SELf_SET BCM89500_A0_G_ANADV_EXT_P4r_PROTOCOL_SELf_SET
#define G_ANADV_EXT_P4r_ADV_B10Tf_GET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10Tf_GET
#define G_ANADV_EXT_P4r_ADV_B10Tf_SET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10Tf_SET
#define G_ANADV_EXT_P4r_ADV_B10T_FDXf_GET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10T_FDXf_GET
#define G_ANADV_EXT_P4r_ADV_B10T_FDXf_SET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B10T_FDXf_SET
#define G_ANADV_EXT_P4r_ADV_B100Xf_GET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100Xf_GET
#define G_ANADV_EXT_P4r_ADV_B100Xf_SET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100Xf_SET
#define G_ANADV_EXT_P4r_ADV_B100_FDXf_GET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100_FDXf_GET
#define G_ANADV_EXT_P4r_ADV_B100_FDXf_SET BCM89500_A0_G_ANADV_EXT_P4r_ADV_B100_FDXf_SET
#define G_ANADV_EXT_P4r_B100T4f_GET BCM89500_A0_G_ANADV_EXT_P4r_B100T4f_GET
#define G_ANADV_EXT_P4r_B100T4f_SET BCM89500_A0_G_ANADV_EXT_P4r_B100T4f_SET
#define G_ANADV_EXT_P4r_ADV_PAUSE_CAPf_GET BCM89500_A0_G_ANADV_EXT_P4r_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXT_P4r_ADV_PAUSE_CAPf_SET BCM89500_A0_G_ANADV_EXT_P4r_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXT_P4r_ASY_PAUSEf_GET BCM89500_A0_G_ANADV_EXT_P4r_ASY_PAUSEf_GET
#define G_ANADV_EXT_P4r_ASY_PAUSEf_SET BCM89500_A0_G_ANADV_EXT_P4r_ASY_PAUSEf_SET
#define G_ANADV_EXT_P4r_RESERVED_1f_GET BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_1f_GET
#define G_ANADV_EXT_P4r_RESERVED_1f_SET BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_1f_SET
#define G_ANADV_EXT_P4r_REMOTE_FAULTf_GET BCM89500_A0_G_ANADV_EXT_P4r_REMOTE_FAULTf_GET
#define G_ANADV_EXT_P4r_REMOTE_FAULTf_SET BCM89500_A0_G_ANADV_EXT_P4r_REMOTE_FAULTf_SET
#define G_ANADV_EXT_P4r_RESERVED_2f_GET BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_2f_GET
#define G_ANADV_EXT_P4r_RESERVED_2f_SET BCM89500_A0_G_ANADV_EXT_P4r_RESERVED_2f_SET
#define G_ANADV_EXT_P4r_NEXT_PAGEf_GET BCM89500_A0_G_ANADV_EXT_P4r_NEXT_PAGEf_GET
#define G_ANADV_EXT_P4r_NEXT_PAGEf_SET BCM89500_A0_G_ANADV_EXT_P4r_NEXT_PAGEf_SET
#define READ_G_ANADV_EXT_P4r BCM89500_A0_READ_G_ANADV_EXT_P4r
#define WRITE_G_ANADV_EXT_P4r BCM89500_A0_WRITE_G_ANADV_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANADV_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANADV_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANADV_EXT_P5r 0x00008508

#define BCM89500_A0_G_ANADV_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_ANADV_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_anadv_ext_p5[1];
	uint32_t _g_anadv_ext_p5;
} BCM89500_A0_G_ANADV_EXT_P5r_t;

#define BCM89500_A0_G_ANADV_EXT_P5r_CLR(r) (r).g_anadv_ext_p5[0] = 0
#define BCM89500_A0_G_ANADV_EXT_P5r_SET(r,d) (r).g_anadv_ext_p5[0] = d
#define BCM89500_A0_G_ANADV_EXT_P5r_GET(r) (r).g_anadv_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext_p5[0]) & 0x1f)
#define BCM89500_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10Tf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10Tf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100Xf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100Xf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANADV_EXT_P5r_B100T4f_GET(r) ((((r).g_anadv_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_B100T4f_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_1f_GET(r) ((((r).g_anadv_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_1f_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANADV_EXT_P5r_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_2f_GET(r) ((((r).g_anadv_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_2f_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_ANADV_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANADV_EXT_P5r,(r._g_anadv_ext_p5),2)
#define BCM89500_A0_WRITE_G_ANADV_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANADV_EXT_P5r,&(r._g_anadv_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXT_P5r BCM89500_A0_G_ANADV_EXT_P5r
#define G_ANADV_EXT_P5r_SIZE BCM89500_A0_G_ANADV_EXT_P5r_SIZE
typedef BCM89500_A0_G_ANADV_EXT_P5r_t G_ANADV_EXT_P5r_t;
#define G_ANADV_EXT_P5r_CLR BCM89500_A0_G_ANADV_EXT_P5r_CLR
#define G_ANADV_EXT_P5r_SET BCM89500_A0_G_ANADV_EXT_P5r_SET
#define G_ANADV_EXT_P5r_GET BCM89500_A0_G_ANADV_EXT_P5r_GET
#define G_ANADV_EXT_P5r_PROTOCOL_SELf_GET BCM89500_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_GET
#define G_ANADV_EXT_P5r_PROTOCOL_SELf_SET BCM89500_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_SET
#define G_ANADV_EXT_P5r_ADV_B10Tf_GET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10Tf_GET
#define G_ANADV_EXT_P5r_ADV_B10Tf_SET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10Tf_SET
#define G_ANADV_EXT_P5r_ADV_B10T_FDXf_GET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_GET
#define G_ANADV_EXT_P5r_ADV_B10T_FDXf_SET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_SET
#define G_ANADV_EXT_P5r_ADV_B100Xf_GET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100Xf_GET
#define G_ANADV_EXT_P5r_ADV_B100Xf_SET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100Xf_SET
#define G_ANADV_EXT_P5r_ADV_B100_FDXf_GET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_GET
#define G_ANADV_EXT_P5r_ADV_B100_FDXf_SET BCM89500_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_SET
#define G_ANADV_EXT_P5r_B100T4f_GET BCM89500_A0_G_ANADV_EXT_P5r_B100T4f_GET
#define G_ANADV_EXT_P5r_B100T4f_SET BCM89500_A0_G_ANADV_EXT_P5r_B100T4f_SET
#define G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET BCM89500_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET BCM89500_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXT_P5r_ASY_PAUSEf_GET BCM89500_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_GET
#define G_ANADV_EXT_P5r_ASY_PAUSEf_SET BCM89500_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_SET
#define G_ANADV_EXT_P5r_RESERVED_1f_GET BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_1f_GET
#define G_ANADV_EXT_P5r_RESERVED_1f_SET BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_1f_SET
#define G_ANADV_EXT_P5r_REMOTE_FAULTf_GET BCM89500_A0_G_ANADV_EXT_P5r_REMOTE_FAULTf_GET
#define G_ANADV_EXT_P5r_REMOTE_FAULTf_SET BCM89500_A0_G_ANADV_EXT_P5r_REMOTE_FAULTf_SET
#define G_ANADV_EXT_P5r_RESERVED_2f_GET BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_2f_GET
#define G_ANADV_EXT_P5r_RESERVED_2f_SET BCM89500_A0_G_ANADV_EXT_P5r_RESERVED_2f_SET
#define G_ANADV_EXT_P5r_NEXT_PAGEf_GET BCM89500_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_GET
#define G_ANADV_EXT_P5r_NEXT_PAGEf_SET BCM89500_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_ANADV_EXT_P5r BCM89500_A0_READ_G_ANADV_EXT_P5r
#define WRITE_G_ANADV_EXT_P5r BCM89500_A0_WRITE_G_ANADV_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANADV_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANADV_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANADV_EXT_PNr 0x00008008

#define BCM89500_A0_G_ANADV_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_ANADV_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_anadv_ext_pn[1];
	uint32_t _g_anadv_ext_pn;
} BCM89500_A0_G_ANADV_EXT_PNr_t;

#define BCM89500_A0_G_ANADV_EXT_PNr_CLR(r) (r).g_anadv_ext_pn[0] = 0
#define BCM89500_A0_G_ANADV_EXT_PNr_SET(r,d) (r).g_anadv_ext_pn[0] = d
#define BCM89500_A0_G_ANADV_EXT_PNr_GET(r) (r).g_anadv_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANADV_EXT_PNr_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext_pn[0]) & 0x1f)
#define BCM89500_A0_G_ANADV_EXT_PNr_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10Tf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10Tf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100Xf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100Xf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANADV_EXT_PNr_B100T4f_GET(r) ((((r).g_anadv_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_B100T4f_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANADV_EXT_PNr_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_1f_GET(r) ((((r).g_anadv_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_1f_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANADV_EXT_PNr_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_2f_GET(r) ((((r).g_anadv_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_2f_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANADV_EXT_PNr_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANADV_EXT_PNr_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext_pn[0]=(((r).g_anadv_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_ANADV_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_ANADV_EXT_PNr,(r._g_anadv_ext_pn),2)
#define BCM89500_A0_WRITE_G_ANADV_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_ANADV_EXT_PNr,&(r._g_anadv_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXT_PNr BCM89500_A0_G_ANADV_EXT_PNr
#define G_ANADV_EXT_PNr_SIZE BCM89500_A0_G_ANADV_EXT_PNr_SIZE
typedef BCM89500_A0_G_ANADV_EXT_PNr_t G_ANADV_EXT_PNr_t;
#define G_ANADV_EXT_PNr_CLR BCM89500_A0_G_ANADV_EXT_PNr_CLR
#define G_ANADV_EXT_PNr_SET BCM89500_A0_G_ANADV_EXT_PNr_SET
#define G_ANADV_EXT_PNr_GET BCM89500_A0_G_ANADV_EXT_PNr_GET
#define G_ANADV_EXT_PNr_PROTOCOL_SELf_GET BCM89500_A0_G_ANADV_EXT_PNr_PROTOCOL_SELf_GET
#define G_ANADV_EXT_PNr_PROTOCOL_SELf_SET BCM89500_A0_G_ANADV_EXT_PNr_PROTOCOL_SELf_SET
#define G_ANADV_EXT_PNr_ADV_B10Tf_GET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10Tf_GET
#define G_ANADV_EXT_PNr_ADV_B10Tf_SET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10Tf_SET
#define G_ANADV_EXT_PNr_ADV_B10T_FDXf_GET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10T_FDXf_GET
#define G_ANADV_EXT_PNr_ADV_B10T_FDXf_SET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B10T_FDXf_SET
#define G_ANADV_EXT_PNr_ADV_B100Xf_GET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100Xf_GET
#define G_ANADV_EXT_PNr_ADV_B100Xf_SET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100Xf_SET
#define G_ANADV_EXT_PNr_ADV_B100_FDXf_GET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100_FDXf_GET
#define G_ANADV_EXT_PNr_ADV_B100_FDXf_SET BCM89500_A0_G_ANADV_EXT_PNr_ADV_B100_FDXf_SET
#define G_ANADV_EXT_PNr_B100T4f_GET BCM89500_A0_G_ANADV_EXT_PNr_B100T4f_GET
#define G_ANADV_EXT_PNr_B100T4f_SET BCM89500_A0_G_ANADV_EXT_PNr_B100T4f_SET
#define G_ANADV_EXT_PNr_ADV_PAUSE_CAPf_GET BCM89500_A0_G_ANADV_EXT_PNr_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXT_PNr_ADV_PAUSE_CAPf_SET BCM89500_A0_G_ANADV_EXT_PNr_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXT_PNr_ASY_PAUSEf_GET BCM89500_A0_G_ANADV_EXT_PNr_ASY_PAUSEf_GET
#define G_ANADV_EXT_PNr_ASY_PAUSEf_SET BCM89500_A0_G_ANADV_EXT_PNr_ASY_PAUSEf_SET
#define G_ANADV_EXT_PNr_RESERVED_1f_GET BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_1f_GET
#define G_ANADV_EXT_PNr_RESERVED_1f_SET BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_1f_SET
#define G_ANADV_EXT_PNr_REMOTE_FAULTf_GET BCM89500_A0_G_ANADV_EXT_PNr_REMOTE_FAULTf_GET
#define G_ANADV_EXT_PNr_REMOTE_FAULTf_SET BCM89500_A0_G_ANADV_EXT_PNr_REMOTE_FAULTf_SET
#define G_ANADV_EXT_PNr_RESERVED_2f_GET BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_2f_GET
#define G_ANADV_EXT_PNr_RESERVED_2f_SET BCM89500_A0_G_ANADV_EXT_PNr_RESERVED_2f_SET
#define G_ANADV_EXT_PNr_NEXT_PAGEf_GET BCM89500_A0_G_ANADV_EXT_PNr_NEXT_PAGEf_GET
#define G_ANADV_EXT_PNr_NEXT_PAGEf_SET BCM89500_A0_G_ANADV_EXT_PNr_NEXT_PAGEf_SET
#define READ_G_ANADV_EXT_PNr BCM89500_A0_READ_G_ANADV_EXT_PNr
#define WRITE_G_ANADV_EXT_PNr BCM89500_A0_WRITE_G_ANADV_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANADV_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANADV_P7
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANADV_P7r 0x00001708

#define BCM89500_A0_G_ANADV_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_P7.
 *
 */
typedef union BCM89500_A0_G_ANADV_P7r_s {
	uint32_t v[1];
	uint32_t g_anadv_p7[1];
	uint32_t _g_anadv_p7;
} BCM89500_A0_G_ANADV_P7r_t;

#define BCM89500_A0_G_ANADV_P7r_CLR(r) (r).g_anadv_p7[0] = 0
#define BCM89500_A0_G_ANADV_P7r_SET(r,d) (r).g_anadv_p7[0] = d
#define BCM89500_A0_G_ANADV_P7r_GET(r) (r).g_anadv_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANADV_P7r_PROTOCOL_SELf_GET(r) (((r).g_anadv_p7[0]) & 0x1f)
#define BCM89500_A0_G_ANADV_P7r_PROTOCOL_SELf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANADV_P7r_ADV_B10Tf_GET(r) ((((r).g_anadv_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_ADV_B10Tf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANADV_P7r_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANADV_P7r_ADV_B100Xf_GET(r) ((((r).g_anadv_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_ADV_B100Xf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANADV_P7r_ADV_B100_FDXf_GET(r) ((((r).g_anadv_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_ADV_B100_FDXf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANADV_P7r_B100T4f_GET(r) ((((r).g_anadv_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_B100T4f_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANADV_P7r_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANADV_P7r_ASY_PAUSEf_GET(r) ((((r).g_anadv_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_ASY_PAUSEf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANADV_P7r_RESERVED_1f_GET(r) ((((r).g_anadv_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_RESERVED_1f_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANADV_P7r_REMOTE_FAULTf_GET(r) ((((r).g_anadv_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_REMOTE_FAULTf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANADV_P7r_RESERVED_2f_GET(r) ((((r).g_anadv_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_RESERVED_2f_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANADV_P7r_NEXT_PAGEf_GET(r) ((((r).g_anadv_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANADV_P7r_NEXT_PAGEf_SET(r,f) (r).g_anadv_p7[0]=(((r).g_anadv_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_P7.
 *
 */
#define BCM89500_A0_READ_G_ANADV_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANADV_P7r,(r._g_anadv_p7),2)
#define BCM89500_A0_WRITE_G_ANADV_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANADV_P7r,&(r._g_anadv_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_P7r BCM89500_A0_G_ANADV_P7r
#define G_ANADV_P7r_SIZE BCM89500_A0_G_ANADV_P7r_SIZE
typedef BCM89500_A0_G_ANADV_P7r_t G_ANADV_P7r_t;
#define G_ANADV_P7r_CLR BCM89500_A0_G_ANADV_P7r_CLR
#define G_ANADV_P7r_SET BCM89500_A0_G_ANADV_P7r_SET
#define G_ANADV_P7r_GET BCM89500_A0_G_ANADV_P7r_GET
#define G_ANADV_P7r_PROTOCOL_SELf_GET BCM89500_A0_G_ANADV_P7r_PROTOCOL_SELf_GET
#define G_ANADV_P7r_PROTOCOL_SELf_SET BCM89500_A0_G_ANADV_P7r_PROTOCOL_SELf_SET
#define G_ANADV_P7r_ADV_B10Tf_GET BCM89500_A0_G_ANADV_P7r_ADV_B10Tf_GET
#define G_ANADV_P7r_ADV_B10Tf_SET BCM89500_A0_G_ANADV_P7r_ADV_B10Tf_SET
#define G_ANADV_P7r_ADV_B10T_FDXf_GET BCM89500_A0_G_ANADV_P7r_ADV_B10T_FDXf_GET
#define G_ANADV_P7r_ADV_B10T_FDXf_SET BCM89500_A0_G_ANADV_P7r_ADV_B10T_FDXf_SET
#define G_ANADV_P7r_ADV_B100Xf_GET BCM89500_A0_G_ANADV_P7r_ADV_B100Xf_GET
#define G_ANADV_P7r_ADV_B100Xf_SET BCM89500_A0_G_ANADV_P7r_ADV_B100Xf_SET
#define G_ANADV_P7r_ADV_B100_FDXf_GET BCM89500_A0_G_ANADV_P7r_ADV_B100_FDXf_GET
#define G_ANADV_P7r_ADV_B100_FDXf_SET BCM89500_A0_G_ANADV_P7r_ADV_B100_FDXf_SET
#define G_ANADV_P7r_B100T4f_GET BCM89500_A0_G_ANADV_P7r_B100T4f_GET
#define G_ANADV_P7r_B100T4f_SET BCM89500_A0_G_ANADV_P7r_B100T4f_SET
#define G_ANADV_P7r_ADV_PAUSE_CAPf_GET BCM89500_A0_G_ANADV_P7r_ADV_PAUSE_CAPf_GET
#define G_ANADV_P7r_ADV_PAUSE_CAPf_SET BCM89500_A0_G_ANADV_P7r_ADV_PAUSE_CAPf_SET
#define G_ANADV_P7r_ASY_PAUSEf_GET BCM89500_A0_G_ANADV_P7r_ASY_PAUSEf_GET
#define G_ANADV_P7r_ASY_PAUSEf_SET BCM89500_A0_G_ANADV_P7r_ASY_PAUSEf_SET
#define G_ANADV_P7r_RESERVED_1f_GET BCM89500_A0_G_ANADV_P7r_RESERVED_1f_GET
#define G_ANADV_P7r_RESERVED_1f_SET BCM89500_A0_G_ANADV_P7r_RESERVED_1f_SET
#define G_ANADV_P7r_REMOTE_FAULTf_GET BCM89500_A0_G_ANADV_P7r_REMOTE_FAULTf_GET
#define G_ANADV_P7r_REMOTE_FAULTf_SET BCM89500_A0_G_ANADV_P7r_REMOTE_FAULTf_SET
#define G_ANADV_P7r_RESERVED_2f_GET BCM89500_A0_G_ANADV_P7r_RESERVED_2f_GET
#define G_ANADV_P7r_RESERVED_2f_SET BCM89500_A0_G_ANADV_P7r_RESERVED_2f_SET
#define G_ANADV_P7r_NEXT_PAGEf_GET BCM89500_A0_G_ANADV_P7r_NEXT_PAGEf_GET
#define G_ANADV_P7r_NEXT_PAGEf_SET BCM89500_A0_G_ANADV_P7r_NEXT_PAGEf_SET
#define READ_G_ANADV_P7r BCM89500_A0_READ_G_ANADV_P7r
#define WRITE_G_ANADV_P7r BCM89500_A0_WRITE_G_ANADV_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANADV_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANEXP
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANEXPr 0x0000140c

#define BCM89500_A0_G_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP.
 *
 */
typedef union BCM89500_A0_G_ANEXPr_s {
	uint32_t v[1];
	uint32_t g_anexp[1];
	uint32_t _g_anexp;
} BCM89500_A0_G_ANEXPr_t;

#define BCM89500_A0_G_ANEXPr_CLR(r) (r).g_anexp[0] = 0
#define BCM89500_A0_G_ANEXPr_SET(r,d) (r).g_anexp[0] = d
#define BCM89500_A0_G_ANEXPr_GET(r) (r).g_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANEXPr_LP_AN_ABIf_GET(r) (((r).g_anexp[0]) & 0x1)
#define BCM89500_A0_G_ANEXPr_LP_AN_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_ANEXPr_PAGE_RECf_GET(r) ((((r).g_anexp[0]) >> 1) & 0x1)
#define BCM89500_A0_G_ANEXPr_PAGE_RECf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 2) & 0x1)
#define BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 3) & 0x1)
#define BCM89500_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_ANEXPr_PAR_DET_FAILf_GET(r) ((((r).g_anexp[0]) >> 4) & 0x1)
#define BCM89500_A0_G_ANEXPr_PAR_DET_FAILf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_ANEXPr_NEXT_PAGEf_GET(r) ((((r).g_anexp[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANEXPr_NEXT_PAGEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANEXPr_RESERVED_1f_GET(r) ((((r).g_anexp[0]) >> 7) & 0x1ff)
#define BCM89500_A0_G_ANEXPr_RESERVED_1f_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP.
 *
 */
#define BCM89500_A0_READ_G_ANEXPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANEXPr,(r._g_anexp),2)
#define BCM89500_A0_WRITE_G_ANEXPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANEXPr,&(r._g_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXPr BCM89500_A0_G_ANEXPr
#define G_ANEXPr_SIZE BCM89500_A0_G_ANEXPr_SIZE
typedef BCM89500_A0_G_ANEXPr_t G_ANEXPr_t;
#define G_ANEXPr_CLR BCM89500_A0_G_ANEXPr_CLR
#define G_ANEXPr_SET BCM89500_A0_G_ANEXPr_SET
#define G_ANEXPr_GET BCM89500_A0_G_ANEXPr_GET
#define G_ANEXPr_LP_AN_ABIf_GET BCM89500_A0_G_ANEXPr_LP_AN_ABIf_GET
#define G_ANEXPr_LP_AN_ABIf_SET BCM89500_A0_G_ANEXPr_LP_AN_ABIf_SET
#define G_ANEXPr_PAGE_RECf_GET BCM89500_A0_G_ANEXPr_PAGE_RECf_GET
#define G_ANEXPr_PAGE_RECf_SET BCM89500_A0_G_ANEXPr_PAGE_RECf_SET
#define G_ANEXPr_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_PAR_DET_FAILf_GET BCM89500_A0_G_ANEXPr_PAR_DET_FAILf_GET
#define G_ANEXPr_PAR_DET_FAILf_SET BCM89500_A0_G_ANEXPr_PAR_DET_FAILf_SET
#define G_ANEXPr_NEXT_PAGEf_GET BCM89500_A0_G_ANEXPr_NEXT_PAGEf_GET
#define G_ANEXPr_NEXT_PAGEf_SET BCM89500_A0_G_ANEXPr_NEXT_PAGEf_SET
#define G_ANEXPr_NEXT_PAGE_ABLEf_GET BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET
#define G_ANEXPr_NEXT_PAGE_ABLEf_SET BCM89500_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET
#define G_ANEXPr_RESERVED_1f_GET BCM89500_A0_G_ANEXPr_RESERVED_1f_GET
#define G_ANEXPr_RESERVED_1f_SET BCM89500_A0_G_ANEXPr_RESERVED_1f_SET
#define READ_G_ANEXPr BCM89500_A0_READ_G_ANEXPr
#define WRITE_G_ANEXPr BCM89500_A0_WRITE_G_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANEXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANEXP_EXTr 0x0000880c

#define BCM89500_A0_G_ANEXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT.
 *
 */
typedef union BCM89500_A0_G_ANEXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_anexp_ext[1];
	uint32_t _g_anexp_ext;
} BCM89500_A0_G_ANEXP_EXTr_t;

#define BCM89500_A0_G_ANEXP_EXTr_CLR(r) (r).g_anexp_ext[0] = 0
#define BCM89500_A0_G_ANEXP_EXTr_SET(r,d) (r).g_anexp_ext[0] = d
#define BCM89500_A0_G_ANEXP_EXTr_GET(r) (r).g_anexp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET(r) (((r).g_anexp_ext[0]) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_ANEXP_EXTr_PAGE_RECf_GET(r) ((((r).g_anexp_ext[0]) >> 1) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_PAGE_RECf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 2) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 3) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext[0]) >> 4) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANEXP_EXTr_RESERVED_1f_GET(r) ((((r).g_anexp_ext[0]) >> 7) & 0x1ff)
#define BCM89500_A0_G_ANEXP_EXTr_RESERVED_1f_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT.
 *
 */
#define BCM89500_A0_READ_G_ANEXP_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANEXP_EXTr,(r._g_anexp_ext),2)
#define BCM89500_A0_WRITE_G_ANEXP_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANEXP_EXTr,&(r._g_anexp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXTr BCM89500_A0_G_ANEXP_EXTr
#define G_ANEXP_EXTr_SIZE BCM89500_A0_G_ANEXP_EXTr_SIZE
typedef BCM89500_A0_G_ANEXP_EXTr_t G_ANEXP_EXTr_t;
#define G_ANEXP_EXTr_CLR BCM89500_A0_G_ANEXP_EXTr_CLR
#define G_ANEXP_EXTr_SET BCM89500_A0_G_ANEXP_EXTr_SET
#define G_ANEXP_EXTr_GET BCM89500_A0_G_ANEXP_EXTr_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_GET BCM89500_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_SET BCM89500_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET
#define G_ANEXP_EXTr_PAGE_RECf_GET BCM89500_A0_G_ANEXP_EXTr_PAGE_RECf_GET
#define G_ANEXP_EXTr_PAGE_RECf_SET BCM89500_A0_G_ANEXP_EXTr_PAGE_RECf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_PAR_DET_FAILf_GET BCM89500_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET
#define G_ANEXP_EXTr_PAR_DET_FAILf_SET BCM89500_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET
#define G_ANEXP_EXTr_NEXT_PAGEf_GET BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET
#define G_ANEXP_EXTr_NEXT_PAGEf_SET BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET BCM89500_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXTr_RESERVED_1f_GET BCM89500_A0_G_ANEXP_EXTr_RESERVED_1f_GET
#define G_ANEXP_EXTr_RESERVED_1f_SET BCM89500_A0_G_ANEXP_EXTr_RESERVED_1f_SET
#define READ_G_ANEXP_EXTr BCM89500_A0_READ_G_ANEXP_EXTr
#define WRITE_G_ANEXP_EXTr BCM89500_A0_WRITE_G_ANEXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANEXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANEXP_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANEXP_EXT_P4r 0x0000840c

#define BCM89500_A0_G_ANEXP_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_ANEXP_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_anexp_ext_p4[1];
	uint32_t _g_anexp_ext_p4;
} BCM89500_A0_G_ANEXP_EXT_P4r_t;

#define BCM89500_A0_G_ANEXP_EXT_P4r_CLR(r) (r).g_anexp_ext_p4[0] = 0
#define BCM89500_A0_G_ANEXP_EXT_P4r_SET(r,d) (r).g_anexp_ext_p4[0] = d
#define BCM89500_A0_G_ANEXP_EXT_P4r_GET(r) (r).g_anexp_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANEXP_EXT_P4r_LP_AN_ABIf_GET(r) (((r).g_anexp_ext_p4[0]) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_ANEXP_EXT_P4r_PAGE_RECf_GET(r) ((((r).g_anexp_ext_p4[0]) >> 1) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_PAGE_RECf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p4[0]) >> 2) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_ANEXP_EXT_P4r_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p4[0]) >> 3) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_ANEXP_EXT_P4r_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext_p4[0]) >> 4) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext_p4[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANEXP_EXT_P4r_RESERVED_1f_GET(r) ((((r).g_anexp_ext_p4[0]) >> 7) & 0x1ff)
#define BCM89500_A0_G_ANEXP_EXT_P4r_RESERVED_1f_SET(r,f) (r).g_anexp_ext_p4[0]=(((r).g_anexp_ext_p4[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_ANEXP_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANEXP_EXT_P4r,(r._g_anexp_ext_p4),2)
#define BCM89500_A0_WRITE_G_ANEXP_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANEXP_EXT_P4r,&(r._g_anexp_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXT_P4r BCM89500_A0_G_ANEXP_EXT_P4r
#define G_ANEXP_EXT_P4r_SIZE BCM89500_A0_G_ANEXP_EXT_P4r_SIZE
typedef BCM89500_A0_G_ANEXP_EXT_P4r_t G_ANEXP_EXT_P4r_t;
#define G_ANEXP_EXT_P4r_CLR BCM89500_A0_G_ANEXP_EXT_P4r_CLR
#define G_ANEXP_EXT_P4r_SET BCM89500_A0_G_ANEXP_EXT_P4r_SET
#define G_ANEXP_EXT_P4r_GET BCM89500_A0_G_ANEXP_EXT_P4r_GET
#define G_ANEXP_EXT_P4r_LP_AN_ABIf_GET BCM89500_A0_G_ANEXP_EXT_P4r_LP_AN_ABIf_GET
#define G_ANEXP_EXT_P4r_LP_AN_ABIf_SET BCM89500_A0_G_ANEXP_EXT_P4r_LP_AN_ABIf_SET
#define G_ANEXP_EXT_P4r_PAGE_RECf_GET BCM89500_A0_G_ANEXP_EXT_P4r_PAGE_RECf_GET
#define G_ANEXP_EXT_P4r_PAGE_RECf_SET BCM89500_A0_G_ANEXP_EXT_P4r_PAGE_RECf_SET
#define G_ANEXP_EXT_P4r_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P4r_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P4r_LP_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXT_P4r_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P4r_LP_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXT_P4r_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P4r_PAR_DET_FAILf_GET BCM89500_A0_G_ANEXP_EXT_P4r_PAR_DET_FAILf_GET
#define G_ANEXP_EXT_P4r_PAR_DET_FAILf_SET BCM89500_A0_G_ANEXP_EXT_P4r_PAR_DET_FAILf_SET
#define G_ANEXP_EXT_P4r_NEXT_PAGEf_GET BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGEf_GET
#define G_ANEXP_EXT_P4r_NEXT_PAGEf_SET BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGEf_SET
#define G_ANEXP_EXT_P4r_NEXT_PAGE_ABLEf_GET BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXT_P4r_NEXT_PAGE_ABLEf_SET BCM89500_A0_G_ANEXP_EXT_P4r_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXT_P4r_RESERVED_1f_GET BCM89500_A0_G_ANEXP_EXT_P4r_RESERVED_1f_GET
#define G_ANEXP_EXT_P4r_RESERVED_1f_SET BCM89500_A0_G_ANEXP_EXT_P4r_RESERVED_1f_SET
#define READ_G_ANEXP_EXT_P4r BCM89500_A0_READ_G_ANEXP_EXT_P4r
#define WRITE_G_ANEXP_EXT_P4r BCM89500_A0_WRITE_G_ANEXP_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANEXP_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANEXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANEXP_EXT_P5r 0x0000850c

#define BCM89500_A0_G_ANEXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_ANEXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_anexp_ext_p5[1];
	uint32_t _g_anexp_ext_p5;
} BCM89500_A0_G_ANEXP_EXT_P5r_t;

#define BCM89500_A0_G_ANEXP_EXT_P5r_CLR(r) (r).g_anexp_ext_p5[0] = 0
#define BCM89500_A0_G_ANEXP_EXT_P5r_SET(r,d) (r).g_anexp_ext_p5[0] = d
#define BCM89500_A0_G_ANEXP_EXT_P5r_GET(r) (r).g_anexp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_GET(r) (((r).g_anexp_ext_p5[0]) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_ANEXP_EXT_P5r_PAGE_RECf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 1) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_PAGE_RECf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 2) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 3) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 4) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANEXP_EXT_P5r_RESERVED_1f_GET(r) ((((r).g_anexp_ext_p5[0]) >> 7) & 0x1ff)
#define BCM89500_A0_G_ANEXP_EXT_P5r_RESERVED_1f_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_ANEXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANEXP_EXT_P5r,(r._g_anexp_ext_p5),2)
#define BCM89500_A0_WRITE_G_ANEXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANEXP_EXT_P5r,&(r._g_anexp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXT_P5r BCM89500_A0_G_ANEXP_EXT_P5r
#define G_ANEXP_EXT_P5r_SIZE BCM89500_A0_G_ANEXP_EXT_P5r_SIZE
typedef BCM89500_A0_G_ANEXP_EXT_P5r_t G_ANEXP_EXT_P5r_t;
#define G_ANEXP_EXT_P5r_CLR BCM89500_A0_G_ANEXP_EXT_P5r_CLR
#define G_ANEXP_EXT_P5r_SET BCM89500_A0_G_ANEXP_EXT_P5r_SET
#define G_ANEXP_EXT_P5r_GET BCM89500_A0_G_ANEXP_EXT_P5r_GET
#define G_ANEXP_EXT_P5r_LP_AN_ABIf_GET BCM89500_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_GET
#define G_ANEXP_EXT_P5r_LP_AN_ABIf_SET BCM89500_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_SET
#define G_ANEXP_EXT_P5r_PAGE_RECf_GET BCM89500_A0_G_ANEXP_EXT_P5r_PAGE_RECf_GET
#define G_ANEXP_EXT_P5r_PAGE_RECf_SET BCM89500_A0_G_ANEXP_EXT_P5r_PAGE_RECf_SET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P5r_PAR_DET_FAILf_GET BCM89500_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_GET
#define G_ANEXP_EXT_P5r_PAR_DET_FAILf_SET BCM89500_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_SET
#define G_ANEXP_EXT_P5r_NEXT_PAGEf_GET BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_GET
#define G_ANEXP_EXT_P5r_NEXT_PAGEf_SET BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_SET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET BCM89500_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXT_P5r_RESERVED_1f_GET BCM89500_A0_G_ANEXP_EXT_P5r_RESERVED_1f_GET
#define G_ANEXP_EXT_P5r_RESERVED_1f_SET BCM89500_A0_G_ANEXP_EXT_P5r_RESERVED_1f_SET
#define READ_G_ANEXP_EXT_P5r BCM89500_A0_READ_G_ANEXP_EXT_P5r
#define WRITE_G_ANEXP_EXT_P5r BCM89500_A0_WRITE_G_ANEXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANEXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANEXP_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANEXP_EXT_PNr 0x0000800c

#define BCM89500_A0_G_ANEXP_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_ANEXP_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_anexp_ext_pn[1];
	uint32_t _g_anexp_ext_pn;
} BCM89500_A0_G_ANEXP_EXT_PNr_t;

#define BCM89500_A0_G_ANEXP_EXT_PNr_CLR(r) (r).g_anexp_ext_pn[0] = 0
#define BCM89500_A0_G_ANEXP_EXT_PNr_SET(r,d) (r).g_anexp_ext_pn[0] = d
#define BCM89500_A0_G_ANEXP_EXT_PNr_GET(r) (r).g_anexp_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANEXP_EXT_PNr_LP_AN_ABIf_GET(r) (((r).g_anexp_ext_pn[0]) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_ANEXP_EXT_PNr_PAGE_RECf_GET(r) ((((r).g_anexp_ext_pn[0]) >> 1) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_PAGE_RECf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_pn[0]) >> 2) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_ANEXP_EXT_PNr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_pn[0]) >> 3) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_ANEXP_EXT_PNr_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext_pn[0]) >> 4) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext_pn[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANEXP_EXT_PNr_RESERVED_1f_GET(r) ((((r).g_anexp_ext_pn[0]) >> 7) & 0x1ff)
#define BCM89500_A0_G_ANEXP_EXT_PNr_RESERVED_1f_SET(r,f) (r).g_anexp_ext_pn[0]=(((r).g_anexp_ext_pn[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_ANEXP_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_ANEXP_EXT_PNr,(r._g_anexp_ext_pn),2)
#define BCM89500_A0_WRITE_G_ANEXP_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_ANEXP_EXT_PNr,&(r._g_anexp_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXT_PNr BCM89500_A0_G_ANEXP_EXT_PNr
#define G_ANEXP_EXT_PNr_SIZE BCM89500_A0_G_ANEXP_EXT_PNr_SIZE
typedef BCM89500_A0_G_ANEXP_EXT_PNr_t G_ANEXP_EXT_PNr_t;
#define G_ANEXP_EXT_PNr_CLR BCM89500_A0_G_ANEXP_EXT_PNr_CLR
#define G_ANEXP_EXT_PNr_SET BCM89500_A0_G_ANEXP_EXT_PNr_SET
#define G_ANEXP_EXT_PNr_GET BCM89500_A0_G_ANEXP_EXT_PNr_GET
#define G_ANEXP_EXT_PNr_LP_AN_ABIf_GET BCM89500_A0_G_ANEXP_EXT_PNr_LP_AN_ABIf_GET
#define G_ANEXP_EXT_PNr_LP_AN_ABIf_SET BCM89500_A0_G_ANEXP_EXT_PNr_LP_AN_ABIf_SET
#define G_ANEXP_EXT_PNr_PAGE_RECf_GET BCM89500_A0_G_ANEXP_EXT_PNr_PAGE_RECf_GET
#define G_ANEXP_EXT_PNr_PAGE_RECf_SET BCM89500_A0_G_ANEXP_EXT_PNr_PAGE_RECf_SET
#define G_ANEXP_EXT_PNr_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_PNr_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_PNr_LP_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_EXT_PNr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_PNr_LP_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_EXT_PNr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_PNr_PAR_DET_FAILf_GET BCM89500_A0_G_ANEXP_EXT_PNr_PAR_DET_FAILf_GET
#define G_ANEXP_EXT_PNr_PAR_DET_FAILf_SET BCM89500_A0_G_ANEXP_EXT_PNr_PAR_DET_FAILf_SET
#define G_ANEXP_EXT_PNr_NEXT_PAGEf_GET BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGEf_GET
#define G_ANEXP_EXT_PNr_NEXT_PAGEf_SET BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGEf_SET
#define G_ANEXP_EXT_PNr_NEXT_PAGE_ABLEf_GET BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXT_PNr_NEXT_PAGE_ABLEf_SET BCM89500_A0_G_ANEXP_EXT_PNr_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXT_PNr_RESERVED_1f_GET BCM89500_A0_G_ANEXP_EXT_PNr_RESERVED_1f_GET
#define G_ANEXP_EXT_PNr_RESERVED_1f_SET BCM89500_A0_G_ANEXP_EXT_PNr_RESERVED_1f_SET
#define READ_G_ANEXP_EXT_PNr BCM89500_A0_READ_G_ANEXP_EXT_PNr
#define WRITE_G_ANEXP_EXT_PNr BCM89500_A0_WRITE_G_ANEXP_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANEXP_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANEXP_P7
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANEXP_P7r 0x0000170c

#define BCM89500_A0_G_ANEXP_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_P7.
 *
 */
typedef union BCM89500_A0_G_ANEXP_P7r_s {
	uint32_t v[1];
	uint32_t g_anexp_p7[1];
	uint32_t _g_anexp_p7;
} BCM89500_A0_G_ANEXP_P7r_t;

#define BCM89500_A0_G_ANEXP_P7r_CLR(r) (r).g_anexp_p7[0] = 0
#define BCM89500_A0_G_ANEXP_P7r_SET(r,d) (r).g_anexp_p7[0] = d
#define BCM89500_A0_G_ANEXP_P7r_GET(r) (r).g_anexp_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANEXP_P7r_LP_AN_ABIf_GET(r) (((r).g_anexp_p7[0]) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_LP_AN_ABIf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_ANEXP_P7r_PAGE_RECf_GET(r) ((((r).g_anexp_p7[0]) >> 1) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_PAGE_RECf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_p7[0]) >> 2) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_ANEXP_P7r_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_p7[0]) >> 3) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_ANEXP_P7r_PAR_DET_FAILf_GET(r) ((((r).g_anexp_p7[0]) >> 4) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_PAR_DET_FAILf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_ANEXP_P7r_NEXT_PAGEf_GET(r) ((((r).g_anexp_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_NEXT_PAGEf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANEXP_P7r_RESERVED_1f_GET(r) ((((r).g_anexp_p7[0]) >> 7) & 0x1ff)
#define BCM89500_A0_G_ANEXP_P7r_RESERVED_1f_SET(r,f) (r).g_anexp_p7[0]=(((r).g_anexp_p7[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_P7.
 *
 */
#define BCM89500_A0_READ_G_ANEXP_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANEXP_P7r,(r._g_anexp_p7),2)
#define BCM89500_A0_WRITE_G_ANEXP_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANEXP_P7r,&(r._g_anexp_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_P7r BCM89500_A0_G_ANEXP_P7r
#define G_ANEXP_P7r_SIZE BCM89500_A0_G_ANEXP_P7r_SIZE
typedef BCM89500_A0_G_ANEXP_P7r_t G_ANEXP_P7r_t;
#define G_ANEXP_P7r_CLR BCM89500_A0_G_ANEXP_P7r_CLR
#define G_ANEXP_P7r_SET BCM89500_A0_G_ANEXP_P7r_SET
#define G_ANEXP_P7r_GET BCM89500_A0_G_ANEXP_P7r_GET
#define G_ANEXP_P7r_LP_AN_ABIf_GET BCM89500_A0_G_ANEXP_P7r_LP_AN_ABIf_GET
#define G_ANEXP_P7r_LP_AN_ABIf_SET BCM89500_A0_G_ANEXP_P7r_LP_AN_ABIf_SET
#define G_ANEXP_P7r_PAGE_RECf_GET BCM89500_A0_G_ANEXP_P7r_PAGE_RECf_GET
#define G_ANEXP_P7r_PAGE_RECf_SET BCM89500_A0_G_ANEXP_P7r_PAGE_RECf_SET
#define G_ANEXP_P7r_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABIf_GET
#define G_ANEXP_P7r_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABIf_SET
#define G_ANEXP_P7r_LP_NEXT_PAGE_ABIf_GET BCM89500_A0_G_ANEXP_P7r_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_P7r_LP_NEXT_PAGE_ABIf_SET BCM89500_A0_G_ANEXP_P7r_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_P7r_PAR_DET_FAILf_GET BCM89500_A0_G_ANEXP_P7r_PAR_DET_FAILf_GET
#define G_ANEXP_P7r_PAR_DET_FAILf_SET BCM89500_A0_G_ANEXP_P7r_PAR_DET_FAILf_SET
#define G_ANEXP_P7r_NEXT_PAGEf_GET BCM89500_A0_G_ANEXP_P7r_NEXT_PAGEf_GET
#define G_ANEXP_P7r_NEXT_PAGEf_SET BCM89500_A0_G_ANEXP_P7r_NEXT_PAGEf_SET
#define G_ANEXP_P7r_NEXT_PAGE_ABLEf_GET BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_P7r_NEXT_PAGE_ABLEf_SET BCM89500_A0_G_ANEXP_P7r_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_P7r_RESERVED_1f_GET BCM89500_A0_G_ANEXP_P7r_RESERVED_1f_GET
#define G_ANEXP_P7r_RESERVED_1f_SET BCM89500_A0_G_ANEXP_P7r_RESERVED_1f_SET
#define READ_G_ANEXP_P7r BCM89500_A0_READ_G_ANEXP_P7r
#define WRITE_G_ANEXP_P7r BCM89500_A0_WRITE_G_ANEXP_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANEXP_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANLPA
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_HD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B10T_FD_CAP      1 = link partner is 10Base-T full duplex capable0 = link partner is not 10Base-T full duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANLPAr 0x0000140a

#define BCM89500_A0_G_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA.
 *
 */
typedef union BCM89500_A0_G_ANLPAr_s {
	uint32_t v[1];
	uint32_t g_anlpa[1];
	uint32_t _g_anlpa;
} BCM89500_A0_G_ANLPAr_t;

#define BCM89500_A0_G_ANLPAr_CLR(r) (r).g_anlpa[0] = 0
#define BCM89500_A0_G_ANLPAr_SET(r,d) (r).g_anlpa[0] = d
#define BCM89500_A0_G_ANLPAr_GET(r) (r).g_anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANLPAr_PROTOCOL_SELf_GET(r) (((r).g_anlpa[0]) & 0x1f)
#define BCM89500_A0_G_ANLPAr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANLPAr_B10T_HD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANLPAr_B10T_HD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANLPAr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 6) & 0x1)
#define BCM89500_A0_G_ANLPAr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_ANLPAr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANLPAr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANLPAr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANLPAr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANLPAr_B100T4_CAPf_GET(r) ((((r).g_anlpa[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANLPAr_B100T4_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANLPAr_PAUSE_CAPf_GET(r) ((((r).g_anlpa[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANLPAr_PAUSE_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANLPAr_RESERVED_1f_GET(r) ((((r).g_anlpa[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANLPAr_RESERVED_1f_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANLPAr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANLPAr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANLPAr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANLPAr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANLPAr_NEXT_PAGEf_GET(r) ((((r).g_anlpa[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANLPAr_NEXT_PAGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA.
 *
 */
#define BCM89500_A0_READ_G_ANLPAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANLPAr,(r._g_anlpa),2)
#define BCM89500_A0_WRITE_G_ANLPAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANLPAr,&(r._g_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPAr BCM89500_A0_G_ANLPAr
#define G_ANLPAr_SIZE BCM89500_A0_G_ANLPAr_SIZE
typedef BCM89500_A0_G_ANLPAr_t G_ANLPAr_t;
#define G_ANLPAr_CLR BCM89500_A0_G_ANLPAr_CLR
#define G_ANLPAr_SET BCM89500_A0_G_ANLPAr_SET
#define G_ANLPAr_GET BCM89500_A0_G_ANLPAr_GET
#define G_ANLPAr_PROTOCOL_SELf_GET BCM89500_A0_G_ANLPAr_PROTOCOL_SELf_GET
#define G_ANLPAr_PROTOCOL_SELf_SET BCM89500_A0_G_ANLPAr_PROTOCOL_SELf_SET
#define G_ANLPAr_B10T_HD_CAPf_GET BCM89500_A0_G_ANLPAr_B10T_HD_CAPf_GET
#define G_ANLPAr_B10T_HD_CAPf_SET BCM89500_A0_G_ANLPAr_B10T_HD_CAPf_SET
#define G_ANLPAr_B10T_FD_CAPf_GET BCM89500_A0_G_ANLPAr_B10T_FD_CAPf_GET
#define G_ANLPAr_B10T_FD_CAPf_SET BCM89500_A0_G_ANLPAr_B10T_FD_CAPf_SET
#define G_ANLPAr_B100_TXHD_CAPf_GET BCM89500_A0_G_ANLPAr_B100_TXHD_CAPf_GET
#define G_ANLPAr_B100_TXHD_CAPf_SET BCM89500_A0_G_ANLPAr_B100_TXHD_CAPf_SET
#define G_ANLPAr_B100_TXFD_CAPf_GET BCM89500_A0_G_ANLPAr_B100_TXFD_CAPf_GET
#define G_ANLPAr_B100_TXFD_CAPf_SET BCM89500_A0_G_ANLPAr_B100_TXFD_CAPf_SET
#define G_ANLPAr_B100T4_CAPf_GET BCM89500_A0_G_ANLPAr_B100T4_CAPf_GET
#define G_ANLPAr_B100T4_CAPf_SET BCM89500_A0_G_ANLPAr_B100T4_CAPf_SET
#define G_ANLPAr_PAUSE_CAPf_GET BCM89500_A0_G_ANLPAr_PAUSE_CAPf_GET
#define G_ANLPAr_PAUSE_CAPf_SET BCM89500_A0_G_ANLPAr_PAUSE_CAPf_SET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_GET BCM89500_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_SET BCM89500_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPAr_RESERVED_1f_GET BCM89500_A0_G_ANLPAr_RESERVED_1f_GET
#define G_ANLPAr_RESERVED_1f_SET BCM89500_A0_G_ANLPAr_RESERVED_1f_SET
#define G_ANLPAr_REMOTE_FAULTf_GET BCM89500_A0_G_ANLPAr_REMOTE_FAULTf_GET
#define G_ANLPAr_REMOTE_FAULTf_SET BCM89500_A0_G_ANLPAr_REMOTE_FAULTf_SET
#define G_ANLPAr_ACKNOWLEDGEf_GET BCM89500_A0_G_ANLPAr_ACKNOWLEDGEf_GET
#define G_ANLPAr_ACKNOWLEDGEf_SET BCM89500_A0_G_ANLPAr_ACKNOWLEDGEf_SET
#define G_ANLPAr_NEXT_PAGEf_GET BCM89500_A0_G_ANLPAr_NEXT_PAGEf_GET
#define G_ANLPAr_NEXT_PAGEf_SET BCM89500_A0_G_ANLPAr_NEXT_PAGEf_SET
#define READ_G_ANLPAr BCM89500_A0_READ_G_ANLPAr
#define WRITE_G_ANLPAr BCM89500_A0_WRITE_G_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANLPA_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANLPA_EXTr 0x0000880a

#define BCM89500_A0_G_ANLPA_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT.
 *
 */
typedef union BCM89500_A0_G_ANLPA_EXTr_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext[1];
	uint32_t _g_anlpa_ext;
} BCM89500_A0_G_ANLPA_EXTr_t;

#define BCM89500_A0_G_ANLPA_EXTr_CLR(r) (r).g_anlpa_ext[0] = 0
#define BCM89500_A0_G_ANLPA_EXTr_SET(r,d) (r).g_anlpa_ext[0] = d
#define BCM89500_A0_G_ANLPA_EXTr_GET(r) (r).g_anlpa_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext[0]) & 0x1f)
#define BCM89500_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANLPA_EXTr_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANLPA_EXTr_RESERVED_1f_GET(r) ((((r).g_anlpa_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_RESERVED_1f_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANLPA_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT.
 *
 */
#define BCM89500_A0_READ_G_ANLPA_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANLPA_EXTr,(r._g_anlpa_ext),2)
#define BCM89500_A0_WRITE_G_ANLPA_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANLPA_EXTr,&(r._g_anlpa_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXTr BCM89500_A0_G_ANLPA_EXTr
#define G_ANLPA_EXTr_SIZE BCM89500_A0_G_ANLPA_EXTr_SIZE
typedef BCM89500_A0_G_ANLPA_EXTr_t G_ANLPA_EXTr_t;
#define G_ANLPA_EXTr_CLR BCM89500_A0_G_ANLPA_EXTr_CLR
#define G_ANLPA_EXTr_SET BCM89500_A0_G_ANLPA_EXTr_SET
#define G_ANLPA_EXTr_GET BCM89500_A0_G_ANLPA_EXTr_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_GET BCM89500_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_SET BCM89500_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET
#define G_ANLPA_EXTr_B10T_FD_CAPf_GET BCM89500_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET
#define G_ANLPA_EXTr_B10T_FD_CAPf_SET BCM89500_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_GET BCM89500_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_SET BCM89500_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_GET BCM89500_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_SET BCM89500_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET
#define G_ANLPA_EXTr_B100T4_CAPf_GET BCM89500_A0_G_ANLPA_EXTr_B100T4_CAPf_GET
#define G_ANLPA_EXTr_B100T4_CAPf_SET BCM89500_A0_G_ANLPA_EXTr_B100T4_CAPf_SET
#define G_ANLPA_EXTr_PAUSE_CAPf_GET BCM89500_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET
#define G_ANLPA_EXTr_PAUSE_CAPf_SET BCM89500_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET BCM89500_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET BCM89500_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXTr_RESERVED_1f_GET BCM89500_A0_G_ANLPA_EXTr_RESERVED_1f_GET
#define G_ANLPA_EXTr_RESERVED_1f_SET BCM89500_A0_G_ANLPA_EXTr_RESERVED_1f_SET
#define G_ANLPA_EXTr_REMOTE_FAULTf_GET BCM89500_A0_G_ANLPA_EXTr_REMOTE_FAULTf_GET
#define G_ANLPA_EXTr_REMOTE_FAULTf_SET BCM89500_A0_G_ANLPA_EXTr_REMOTE_FAULTf_SET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_GET BCM89500_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_SET BCM89500_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET
#define G_ANLPA_EXTr_NEXT_PAGEf_GET BCM89500_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET
#define G_ANLPA_EXTr_NEXT_PAGEf_SET BCM89500_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXTr BCM89500_A0_READ_G_ANLPA_EXTr
#define WRITE_G_ANLPA_EXTr BCM89500_A0_WRITE_G_ANLPA_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANLPA_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANLPA_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANLPA_EXT_P4r 0x0000840a

#define BCM89500_A0_G_ANLPA_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_ANLPA_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext_p4[1];
	uint32_t _g_anlpa_ext_p4;
} BCM89500_A0_G_ANLPA_EXT_P4r_t;

#define BCM89500_A0_G_ANLPA_EXT_P4r_CLR(r) (r).g_anlpa_ext_p4[0] = 0
#define BCM89500_A0_G_ANLPA_EXT_P4r_SET(r,d) (r).g_anlpa_ext_p4[0] = d
#define BCM89500_A0_G_ANLPA_EXT_P4r_GET(r) (r).g_anlpa_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANLPA_EXT_P4r_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext_p4[0]) & 0x1f)
#define BCM89500_A0_G_ANLPA_EXT_P4r_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANLPA_EXT_P4r_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANLPA_EXT_P4r_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANLPA_EXT_P4r_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANLPA_EXT_P4r_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANLPA_EXT_P4r_RESERVED_1f_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_RESERVED_1f_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANLPA_EXT_P4r_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANLPA_EXT_P4r_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANLPA_EXT_P4r_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P4r_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext_p4[0]=(((r).g_anlpa_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_ANLPA_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANLPA_EXT_P4r,(r._g_anlpa_ext_p4),2)
#define BCM89500_A0_WRITE_G_ANLPA_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANLPA_EXT_P4r,&(r._g_anlpa_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXT_P4r BCM89500_A0_G_ANLPA_EXT_P4r
#define G_ANLPA_EXT_P4r_SIZE BCM89500_A0_G_ANLPA_EXT_P4r_SIZE
typedef BCM89500_A0_G_ANLPA_EXT_P4r_t G_ANLPA_EXT_P4r_t;
#define G_ANLPA_EXT_P4r_CLR BCM89500_A0_G_ANLPA_EXT_P4r_CLR
#define G_ANLPA_EXT_P4r_SET BCM89500_A0_G_ANLPA_EXT_P4r_SET
#define G_ANLPA_EXT_P4r_GET BCM89500_A0_G_ANLPA_EXT_P4r_GET
#define G_ANLPA_EXT_P4r_PROTOCOL_SELf_GET BCM89500_A0_G_ANLPA_EXT_P4r_PROTOCOL_SELf_GET
#define G_ANLPA_EXT_P4r_PROTOCOL_SELf_SET BCM89500_A0_G_ANLPA_EXT_P4r_PROTOCOL_SELf_SET
#define G_ANLPA_EXT_P4r_B10T_FD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P4r_B10T_FD_CAPf_GET
#define G_ANLPA_EXT_P4r_B10T_FD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P4r_B10T_FD_CAPf_SET
#define G_ANLPA_EXT_P4r_B100_TXHD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXHD_CAPf_GET
#define G_ANLPA_EXT_P4r_B100_TXHD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXHD_CAPf_SET
#define G_ANLPA_EXT_P4r_B100_TXFD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXFD_CAPf_GET
#define G_ANLPA_EXT_P4r_B100_TXFD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P4r_B100_TXFD_CAPf_SET
#define G_ANLPA_EXT_P4r_B100T4_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P4r_B100T4_CAPf_GET
#define G_ANLPA_EXT_P4r_B100T4_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P4r_B100T4_CAPf_SET
#define G_ANLPA_EXT_P4r_PAUSE_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P4r_PAUSE_CAPf_GET
#define G_ANLPA_EXT_P4r_PAUSE_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P4r_PAUSE_CAPf_SET
#define G_ANLPA_EXT_P4r_LK_PAR_ASYM_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P4r_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXT_P4r_LK_PAR_ASYM_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P4r_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXT_P4r_RESERVED_1f_GET BCM89500_A0_G_ANLPA_EXT_P4r_RESERVED_1f_GET
#define G_ANLPA_EXT_P4r_RESERVED_1f_SET BCM89500_A0_G_ANLPA_EXT_P4r_RESERVED_1f_SET
#define G_ANLPA_EXT_P4r_REMOTE_FAULTf_GET BCM89500_A0_G_ANLPA_EXT_P4r_REMOTE_FAULTf_GET
#define G_ANLPA_EXT_P4r_REMOTE_FAULTf_SET BCM89500_A0_G_ANLPA_EXT_P4r_REMOTE_FAULTf_SET
#define G_ANLPA_EXT_P4r_ACKNOWLEDGEf_GET BCM89500_A0_G_ANLPA_EXT_P4r_ACKNOWLEDGEf_GET
#define G_ANLPA_EXT_P4r_ACKNOWLEDGEf_SET BCM89500_A0_G_ANLPA_EXT_P4r_ACKNOWLEDGEf_SET
#define G_ANLPA_EXT_P4r_NEXT_PAGEf_GET BCM89500_A0_G_ANLPA_EXT_P4r_NEXT_PAGEf_GET
#define G_ANLPA_EXT_P4r_NEXT_PAGEf_SET BCM89500_A0_G_ANLPA_EXT_P4r_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXT_P4r BCM89500_A0_READ_G_ANLPA_EXT_P4r
#define WRITE_G_ANLPA_EXT_P4r BCM89500_A0_WRITE_G_ANLPA_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANLPA_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANLPA_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANLPA_EXT_P5r 0x0000850a

#define BCM89500_A0_G_ANLPA_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_ANLPA_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext_p5[1];
	uint32_t _g_anlpa_ext_p5;
} BCM89500_A0_G_ANLPA_EXT_P5r_t;

#define BCM89500_A0_G_ANLPA_EXT_P5r_CLR(r) (r).g_anlpa_ext_p5[0] = 0
#define BCM89500_A0_G_ANLPA_EXT_P5r_SET(r,d) (r).g_anlpa_ext_p5[0] = d
#define BCM89500_A0_G_ANLPA_EXT_P5r_GET(r) (r).g_anlpa_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext_p5[0]) & 0x1f)
#define BCM89500_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANLPA_EXT_P5r_RESERVED_1f_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_RESERVED_1f_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANLPA_EXT_P5r_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_ANLPA_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANLPA_EXT_P5r,(r._g_anlpa_ext_p5),2)
#define BCM89500_A0_WRITE_G_ANLPA_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANLPA_EXT_P5r,&(r._g_anlpa_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXT_P5r BCM89500_A0_G_ANLPA_EXT_P5r
#define G_ANLPA_EXT_P5r_SIZE BCM89500_A0_G_ANLPA_EXT_P5r_SIZE
typedef BCM89500_A0_G_ANLPA_EXT_P5r_t G_ANLPA_EXT_P5r_t;
#define G_ANLPA_EXT_P5r_CLR BCM89500_A0_G_ANLPA_EXT_P5r_CLR
#define G_ANLPA_EXT_P5r_SET BCM89500_A0_G_ANLPA_EXT_P5r_SET
#define G_ANLPA_EXT_P5r_GET BCM89500_A0_G_ANLPA_EXT_P5r_GET
#define G_ANLPA_EXT_P5r_PROTOCOL_SELf_GET BCM89500_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_GET
#define G_ANLPA_EXT_P5r_PROTOCOL_SELf_SET BCM89500_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_SET
#define G_ANLPA_EXT_P5r_B10T_FD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_GET
#define G_ANLPA_EXT_P5r_B10T_FD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_SET
#define G_ANLPA_EXT_P5r_B100_TXHD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_GET
#define G_ANLPA_EXT_P5r_B100_TXHD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_SET
#define G_ANLPA_EXT_P5r_B100_TXFD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_GET
#define G_ANLPA_EXT_P5r_B100_TXFD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_SET
#define G_ANLPA_EXT_P5r_B100T4_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_GET
#define G_ANLPA_EXT_P5r_B100T4_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_SET
#define G_ANLPA_EXT_P5r_PAUSE_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_GET
#define G_ANLPA_EXT_P5r_PAUSE_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_SET
#define G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_GET BCM89500_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_SET BCM89500_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXT_P5r_RESERVED_1f_GET BCM89500_A0_G_ANLPA_EXT_P5r_RESERVED_1f_GET
#define G_ANLPA_EXT_P5r_RESERVED_1f_SET BCM89500_A0_G_ANLPA_EXT_P5r_RESERVED_1f_SET
#define G_ANLPA_EXT_P5r_REMOTE_FAULTf_GET BCM89500_A0_G_ANLPA_EXT_P5r_REMOTE_FAULTf_GET
#define G_ANLPA_EXT_P5r_REMOTE_FAULTf_SET BCM89500_A0_G_ANLPA_EXT_P5r_REMOTE_FAULTf_SET
#define G_ANLPA_EXT_P5r_ACKNOWLEDGEf_GET BCM89500_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_GET
#define G_ANLPA_EXT_P5r_ACKNOWLEDGEf_SET BCM89500_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_SET
#define G_ANLPA_EXT_P5r_NEXT_PAGEf_GET BCM89500_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_GET
#define G_ANLPA_EXT_P5r_NEXT_PAGEf_SET BCM89500_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXT_P5r BCM89500_A0_READ_G_ANLPA_EXT_P5r
#define WRITE_G_ANLPA_EXT_P5r BCM89500_A0_WRITE_G_ANLPA_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANLPA_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANLPA_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANLPA_EXT_PNr 0x0000800a

#define BCM89500_A0_G_ANLPA_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_ANLPA_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext_pn[1];
	uint32_t _g_anlpa_ext_pn;
} BCM89500_A0_G_ANLPA_EXT_PNr_t;

#define BCM89500_A0_G_ANLPA_EXT_PNr_CLR(r) (r).g_anlpa_ext_pn[0] = 0
#define BCM89500_A0_G_ANLPA_EXT_PNr_SET(r,d) (r).g_anlpa_ext_pn[0] = d
#define BCM89500_A0_G_ANLPA_EXT_PNr_GET(r) (r).g_anlpa_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANLPA_EXT_PNr_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext_pn[0]) & 0x1f)
#define BCM89500_A0_G_ANLPA_EXT_PNr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANLPA_EXT_PNr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANLPA_EXT_PNr_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANLPA_EXT_PNr_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANLPA_EXT_PNr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANLPA_EXT_PNr_RESERVED_1f_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_RESERVED_1f_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANLPA_EXT_PNr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANLPA_EXT_PNr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANLPA_EXT_PNr_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANLPA_EXT_PNr_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext_pn[0]=(((r).g_anlpa_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_ANLPA_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_ANLPA_EXT_PNr,(r._g_anlpa_ext_pn),2)
#define BCM89500_A0_WRITE_G_ANLPA_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_ANLPA_EXT_PNr,&(r._g_anlpa_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXT_PNr BCM89500_A0_G_ANLPA_EXT_PNr
#define G_ANLPA_EXT_PNr_SIZE BCM89500_A0_G_ANLPA_EXT_PNr_SIZE
typedef BCM89500_A0_G_ANLPA_EXT_PNr_t G_ANLPA_EXT_PNr_t;
#define G_ANLPA_EXT_PNr_CLR BCM89500_A0_G_ANLPA_EXT_PNr_CLR
#define G_ANLPA_EXT_PNr_SET BCM89500_A0_G_ANLPA_EXT_PNr_SET
#define G_ANLPA_EXT_PNr_GET BCM89500_A0_G_ANLPA_EXT_PNr_GET
#define G_ANLPA_EXT_PNr_PROTOCOL_SELf_GET BCM89500_A0_G_ANLPA_EXT_PNr_PROTOCOL_SELf_GET
#define G_ANLPA_EXT_PNr_PROTOCOL_SELf_SET BCM89500_A0_G_ANLPA_EXT_PNr_PROTOCOL_SELf_SET
#define G_ANLPA_EXT_PNr_B10T_FD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_PNr_B10T_FD_CAPf_GET
#define G_ANLPA_EXT_PNr_B10T_FD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_PNr_B10T_FD_CAPf_SET
#define G_ANLPA_EXT_PNr_B100_TXHD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXHD_CAPf_GET
#define G_ANLPA_EXT_PNr_B100_TXHD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXHD_CAPf_SET
#define G_ANLPA_EXT_PNr_B100_TXFD_CAPf_GET BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXFD_CAPf_GET
#define G_ANLPA_EXT_PNr_B100_TXFD_CAPf_SET BCM89500_A0_G_ANLPA_EXT_PNr_B100_TXFD_CAPf_SET
#define G_ANLPA_EXT_PNr_B100T4_CAPf_GET BCM89500_A0_G_ANLPA_EXT_PNr_B100T4_CAPf_GET
#define G_ANLPA_EXT_PNr_B100T4_CAPf_SET BCM89500_A0_G_ANLPA_EXT_PNr_B100T4_CAPf_SET
#define G_ANLPA_EXT_PNr_PAUSE_CAPf_GET BCM89500_A0_G_ANLPA_EXT_PNr_PAUSE_CAPf_GET
#define G_ANLPA_EXT_PNr_PAUSE_CAPf_SET BCM89500_A0_G_ANLPA_EXT_PNr_PAUSE_CAPf_SET
#define G_ANLPA_EXT_PNr_LK_PAR_ASYM_CAPf_GET BCM89500_A0_G_ANLPA_EXT_PNr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXT_PNr_LK_PAR_ASYM_CAPf_SET BCM89500_A0_G_ANLPA_EXT_PNr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXT_PNr_RESERVED_1f_GET BCM89500_A0_G_ANLPA_EXT_PNr_RESERVED_1f_GET
#define G_ANLPA_EXT_PNr_RESERVED_1f_SET BCM89500_A0_G_ANLPA_EXT_PNr_RESERVED_1f_SET
#define G_ANLPA_EXT_PNr_REMOTE_FAULTf_GET BCM89500_A0_G_ANLPA_EXT_PNr_REMOTE_FAULTf_GET
#define G_ANLPA_EXT_PNr_REMOTE_FAULTf_SET BCM89500_A0_G_ANLPA_EXT_PNr_REMOTE_FAULTf_SET
#define G_ANLPA_EXT_PNr_ACKNOWLEDGEf_GET BCM89500_A0_G_ANLPA_EXT_PNr_ACKNOWLEDGEf_GET
#define G_ANLPA_EXT_PNr_ACKNOWLEDGEf_SET BCM89500_A0_G_ANLPA_EXT_PNr_ACKNOWLEDGEf_SET
#define G_ANLPA_EXT_PNr_NEXT_PAGEf_GET BCM89500_A0_G_ANLPA_EXT_PNr_NEXT_PAGEf_GET
#define G_ANLPA_EXT_PNr_NEXT_PAGEf_SET BCM89500_A0_G_ANLPA_EXT_PNr_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXT_PNr BCM89500_A0_READ_G_ANLPA_EXT_PNr
#define WRITE_G_ANLPA_EXT_PNr BCM89500_A0_WRITE_G_ANLPA_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANLPA_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANLPA_P7
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANLPA_P7r 0x0000170a

#define BCM89500_A0_G_ANLPA_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_P7.
 *
 */
typedef union BCM89500_A0_G_ANLPA_P7r_s {
	uint32_t v[1];
	uint32_t g_anlpa_p7[1];
	uint32_t _g_anlpa_p7;
} BCM89500_A0_G_ANLPA_P7r_t;

#define BCM89500_A0_G_ANLPA_P7r_CLR(r) (r).g_anlpa_p7[0] = 0
#define BCM89500_A0_G_ANLPA_P7r_SET(r,d) (r).g_anlpa_p7[0] = d
#define BCM89500_A0_G_ANLPA_P7r_GET(r) (r).g_anlpa_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANLPA_P7r_PROTOCOL_SELf_GET(r) (((r).g_anlpa_p7[0]) & 0x1f)
#define BCM89500_A0_G_ANLPA_P7r_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_ANLPA_P7r_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANLPA_P7r_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_ANLPA_P7r_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_ANLPA_P7r_B100T4_CAPf_GET(r) ((((r).g_anlpa_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_B100T4_CAPf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_ANLPA_P7r_PAUSE_CAPf_GET(r) ((((r).g_anlpa_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_PAUSE_CAPf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_ANLPA_P7r_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANLPA_P7r_RESERVED_1f_GET(r) ((((r).g_anlpa_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_RESERVED_1f_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANLPA_P7r_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANLPA_P7r_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANLPA_P7r_NEXT_PAGEf_GET(r) ((((r).g_anlpa_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANLPA_P7r_NEXT_PAGEf_SET(r,f) (r).g_anlpa_p7[0]=(((r).g_anlpa_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_P7.
 *
 */
#define BCM89500_A0_READ_G_ANLPA_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANLPA_P7r,(r._g_anlpa_p7),2)
#define BCM89500_A0_WRITE_G_ANLPA_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANLPA_P7r,&(r._g_anlpa_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_P7r BCM89500_A0_G_ANLPA_P7r
#define G_ANLPA_P7r_SIZE BCM89500_A0_G_ANLPA_P7r_SIZE
typedef BCM89500_A0_G_ANLPA_P7r_t G_ANLPA_P7r_t;
#define G_ANLPA_P7r_CLR BCM89500_A0_G_ANLPA_P7r_CLR
#define G_ANLPA_P7r_SET BCM89500_A0_G_ANLPA_P7r_SET
#define G_ANLPA_P7r_GET BCM89500_A0_G_ANLPA_P7r_GET
#define G_ANLPA_P7r_PROTOCOL_SELf_GET BCM89500_A0_G_ANLPA_P7r_PROTOCOL_SELf_GET
#define G_ANLPA_P7r_PROTOCOL_SELf_SET BCM89500_A0_G_ANLPA_P7r_PROTOCOL_SELf_SET
#define G_ANLPA_P7r_B10T_FD_CAPf_GET BCM89500_A0_G_ANLPA_P7r_B10T_FD_CAPf_GET
#define G_ANLPA_P7r_B10T_FD_CAPf_SET BCM89500_A0_G_ANLPA_P7r_B10T_FD_CAPf_SET
#define G_ANLPA_P7r_B100_TXHD_CAPf_GET BCM89500_A0_G_ANLPA_P7r_B100_TXHD_CAPf_GET
#define G_ANLPA_P7r_B100_TXHD_CAPf_SET BCM89500_A0_G_ANLPA_P7r_B100_TXHD_CAPf_SET
#define G_ANLPA_P7r_B100_TXFD_CAPf_GET BCM89500_A0_G_ANLPA_P7r_B100_TXFD_CAPf_GET
#define G_ANLPA_P7r_B100_TXFD_CAPf_SET BCM89500_A0_G_ANLPA_P7r_B100_TXFD_CAPf_SET
#define G_ANLPA_P7r_B100T4_CAPf_GET BCM89500_A0_G_ANLPA_P7r_B100T4_CAPf_GET
#define G_ANLPA_P7r_B100T4_CAPf_SET BCM89500_A0_G_ANLPA_P7r_B100T4_CAPf_SET
#define G_ANLPA_P7r_PAUSE_CAPf_GET BCM89500_A0_G_ANLPA_P7r_PAUSE_CAPf_GET
#define G_ANLPA_P7r_PAUSE_CAPf_SET BCM89500_A0_G_ANLPA_P7r_PAUSE_CAPf_SET
#define G_ANLPA_P7r_LK_PAR_ASYM_CAPf_GET BCM89500_A0_G_ANLPA_P7r_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_P7r_LK_PAR_ASYM_CAPf_SET BCM89500_A0_G_ANLPA_P7r_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_P7r_RESERVED_1f_GET BCM89500_A0_G_ANLPA_P7r_RESERVED_1f_GET
#define G_ANLPA_P7r_RESERVED_1f_SET BCM89500_A0_G_ANLPA_P7r_RESERVED_1f_SET
#define G_ANLPA_P7r_REMOTE_FAULTf_GET BCM89500_A0_G_ANLPA_P7r_REMOTE_FAULTf_GET
#define G_ANLPA_P7r_REMOTE_FAULTf_SET BCM89500_A0_G_ANLPA_P7r_REMOTE_FAULTf_SET
#define G_ANLPA_P7r_ACKNOWLEDGEf_GET BCM89500_A0_G_ANLPA_P7r_ACKNOWLEDGEf_GET
#define G_ANLPA_P7r_ACKNOWLEDGEf_SET BCM89500_A0_G_ANLPA_P7r_ACKNOWLEDGEf_SET
#define G_ANLPA_P7r_NEXT_PAGEf_GET BCM89500_A0_G_ANLPA_P7r_NEXT_PAGEf_GET
#define G_ANLPA_P7r_NEXT_PAGEf_SET BCM89500_A0_G_ANLPA_P7r_NEXT_PAGEf_SET
#define READ_G_ANLPA_P7r BCM89500_A0_READ_G_ANLPA_P7r
#define WRITE_G_ANLPA_P7r BCM89500_A0_WRITE_G_ANLPA_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANLPA_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANNXP
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANNXPr 0x0000140e

#define BCM89500_A0_G_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP.
 *
 */
typedef union BCM89500_A0_G_ANNXPr_s {
	uint32_t v[1];
	uint32_t g_annxp[1];
	uint32_t _g_annxp;
} BCM89500_A0_G_ANNXPr_t;

#define BCM89500_A0_G_ANNXPr_CLR(r) (r).g_annxp[0] = 0
#define BCM89500_A0_G_ANNXPr_SET(r,d) (r).g_annxp[0] = d
#define BCM89500_A0_G_ANNXPr_GET(r) (r).g_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANNXPr_CODE_FIELDf_GET(r) (((r).g_annxp[0]) & 0x7ff)
#define BCM89500_A0_G_ANNXPr_CODE_FIELDf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_G_ANNXPr_TOGGLEf_GET(r) ((((r).g_annxp[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANNXPr_TOGGLEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANNXPr_MES_PAGEf_GET(r) ((((r).g_annxp[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANNXPr_MES_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANNXPr_RESERVED_1f_GET(r) ((((r).g_annxp[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANNXPr_RESERVED_1f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANNXPr_NEXT_PAGEf_GET(r) ((((r).g_annxp[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANNXPr_NEXT_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP.
 *
 */
#define BCM89500_A0_READ_G_ANNXPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANNXPr,(r._g_annxp),2)
#define BCM89500_A0_WRITE_G_ANNXPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANNXPr,&(r._g_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXPr BCM89500_A0_G_ANNXPr
#define G_ANNXPr_SIZE BCM89500_A0_G_ANNXPr_SIZE
typedef BCM89500_A0_G_ANNXPr_t G_ANNXPr_t;
#define G_ANNXPr_CLR BCM89500_A0_G_ANNXPr_CLR
#define G_ANNXPr_SET BCM89500_A0_G_ANNXPr_SET
#define G_ANNXPr_GET BCM89500_A0_G_ANNXPr_GET
#define G_ANNXPr_CODE_FIELDf_GET BCM89500_A0_G_ANNXPr_CODE_FIELDf_GET
#define G_ANNXPr_CODE_FIELDf_SET BCM89500_A0_G_ANNXPr_CODE_FIELDf_SET
#define G_ANNXPr_TOGGLEf_GET BCM89500_A0_G_ANNXPr_TOGGLEf_GET
#define G_ANNXPr_TOGGLEf_SET BCM89500_A0_G_ANNXPr_TOGGLEf_SET
#define G_ANNXPr_ACKNOWLEDGE_2f_GET BCM89500_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET
#define G_ANNXPr_ACKNOWLEDGE_2f_SET BCM89500_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET
#define G_ANNXPr_MES_PAGEf_GET BCM89500_A0_G_ANNXPr_MES_PAGEf_GET
#define G_ANNXPr_MES_PAGEf_SET BCM89500_A0_G_ANNXPr_MES_PAGEf_SET
#define G_ANNXPr_RESERVED_1f_GET BCM89500_A0_G_ANNXPr_RESERVED_1f_GET
#define G_ANNXPr_RESERVED_1f_SET BCM89500_A0_G_ANNXPr_RESERVED_1f_SET
#define G_ANNXPr_NEXT_PAGEf_GET BCM89500_A0_G_ANNXPr_NEXT_PAGEf_GET
#define G_ANNXPr_NEXT_PAGEf_SET BCM89500_A0_G_ANNXPr_NEXT_PAGEf_SET
#define READ_G_ANNXPr BCM89500_A0_READ_G_ANNXPr
#define WRITE_G_ANNXPr BCM89500_A0_WRITE_G_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANNXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANNXP_EXTr 0x0000880e

#define BCM89500_A0_G_ANNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT.
 *
 */
typedef union BCM89500_A0_G_ANNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_annxp_ext[1];
	uint32_t _g_annxp_ext;
} BCM89500_A0_G_ANNXP_EXTr_t;

#define BCM89500_A0_G_ANNXP_EXTr_CLR(r) (r).g_annxp_ext[0] = 0
#define BCM89500_A0_G_ANNXP_EXTr_SET(r,d) (r).g_annxp_ext[0] = d
#define BCM89500_A0_G_ANNXP_EXTr_GET(r) (r).g_annxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_annxp_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANNXP_EXTr_TOGGLEf_GET(r) ((((r).g_annxp_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANNXP_EXTr_TOGGLEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANNXP_EXTr_RESERVED_1f_GET(r) ((((r).g_annxp_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANNXP_EXTr_RESERVED_1f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT.
 *
 */
#define BCM89500_A0_READ_G_ANNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANNXP_EXTr,(r._g_annxp_ext),2)
#define BCM89500_A0_WRITE_G_ANNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANNXP_EXTr,&(r._g_annxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXTr BCM89500_A0_G_ANNXP_EXTr
#define G_ANNXP_EXTr_SIZE BCM89500_A0_G_ANNXP_EXTr_SIZE
typedef BCM89500_A0_G_ANNXP_EXTr_t G_ANNXP_EXTr_t;
#define G_ANNXP_EXTr_CLR BCM89500_A0_G_ANNXP_EXTr_CLR
#define G_ANNXP_EXTr_SET BCM89500_A0_G_ANNXP_EXTr_SET
#define G_ANNXP_EXTr_GET BCM89500_A0_G_ANNXP_EXTr_GET
#define G_ANNXP_EXTr_CODE_FIELDf_GET BCM89500_A0_G_ANNXP_EXTr_CODE_FIELDf_GET
#define G_ANNXP_EXTr_CODE_FIELDf_SET BCM89500_A0_G_ANNXP_EXTr_CODE_FIELDf_SET
#define G_ANNXP_EXTr_TOGGLEf_GET BCM89500_A0_G_ANNXP_EXTr_TOGGLEf_GET
#define G_ANNXP_EXTr_TOGGLEf_SET BCM89500_A0_G_ANNXP_EXTr_TOGGLEf_SET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET BCM89500_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET BCM89500_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXTr_MES_PAGEf_GET BCM89500_A0_G_ANNXP_EXTr_MES_PAGEf_GET
#define G_ANNXP_EXTr_MES_PAGEf_SET BCM89500_A0_G_ANNXP_EXTr_MES_PAGEf_SET
#define G_ANNXP_EXTr_RESERVED_1f_GET BCM89500_A0_G_ANNXP_EXTr_RESERVED_1f_GET
#define G_ANNXP_EXTr_RESERVED_1f_SET BCM89500_A0_G_ANNXP_EXTr_RESERVED_1f_SET
#define G_ANNXP_EXTr_NEXT_PAGEf_GET BCM89500_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET
#define G_ANNXP_EXTr_NEXT_PAGEf_SET BCM89500_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXTr BCM89500_A0_READ_G_ANNXP_EXTr
#define WRITE_G_ANNXP_EXTr BCM89500_A0_WRITE_G_ANNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANNXP_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANNXP_EXT_P4r 0x0000840e

#define BCM89500_A0_G_ANNXP_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_ANNXP_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_annxp_ext_p4[1];
	uint32_t _g_annxp_ext_p4;
} BCM89500_A0_G_ANNXP_EXT_P4r_t;

#define BCM89500_A0_G_ANNXP_EXT_P4r_CLR(r) (r).g_annxp_ext_p4[0] = 0
#define BCM89500_A0_G_ANNXP_EXT_P4r_SET(r,d) (r).g_annxp_ext_p4[0] = d
#define BCM89500_A0_G_ANNXP_EXT_P4r_GET(r) (r).g_annxp_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANNXP_EXT_P4r_CODE_FIELDf_GET(r) ((((r).g_annxp_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P4r_CODE_FIELDf_SET(r,f) (r).g_annxp_ext_p4[0]=(((r).g_annxp_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANNXP_EXT_P4r_TOGGLEf_GET(r) ((((r).g_annxp_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P4r_TOGGLEf_SET(r,f) (r).g_annxp_ext_p4[0]=(((r).g_annxp_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANNXP_EXT_P4r_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P4r_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext_p4[0]=(((r).g_annxp_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANNXP_EXT_P4r_MES_PAGEf_GET(r) ((((r).g_annxp_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P4r_MES_PAGEf_SET(r,f) (r).g_annxp_ext_p4[0]=(((r).g_annxp_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANNXP_EXT_P4r_RESERVED_1f_GET(r) ((((r).g_annxp_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P4r_RESERVED_1f_SET(r,f) (r).g_annxp_ext_p4[0]=(((r).g_annxp_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANNXP_EXT_P4r_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P4r_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext_p4[0]=(((r).g_annxp_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_ANNXP_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANNXP_EXT_P4r,(r._g_annxp_ext_p4),2)
#define BCM89500_A0_WRITE_G_ANNXP_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANNXP_EXT_P4r,&(r._g_annxp_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXT_P4r BCM89500_A0_G_ANNXP_EXT_P4r
#define G_ANNXP_EXT_P4r_SIZE BCM89500_A0_G_ANNXP_EXT_P4r_SIZE
typedef BCM89500_A0_G_ANNXP_EXT_P4r_t G_ANNXP_EXT_P4r_t;
#define G_ANNXP_EXT_P4r_CLR BCM89500_A0_G_ANNXP_EXT_P4r_CLR
#define G_ANNXP_EXT_P4r_SET BCM89500_A0_G_ANNXP_EXT_P4r_SET
#define G_ANNXP_EXT_P4r_GET BCM89500_A0_G_ANNXP_EXT_P4r_GET
#define G_ANNXP_EXT_P4r_CODE_FIELDf_GET BCM89500_A0_G_ANNXP_EXT_P4r_CODE_FIELDf_GET
#define G_ANNXP_EXT_P4r_CODE_FIELDf_SET BCM89500_A0_G_ANNXP_EXT_P4r_CODE_FIELDf_SET
#define G_ANNXP_EXT_P4r_TOGGLEf_GET BCM89500_A0_G_ANNXP_EXT_P4r_TOGGLEf_GET
#define G_ANNXP_EXT_P4r_TOGGLEf_SET BCM89500_A0_G_ANNXP_EXT_P4r_TOGGLEf_SET
#define G_ANNXP_EXT_P4r_ACKNOWLEDGE_2f_GET BCM89500_A0_G_ANNXP_EXT_P4r_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXT_P4r_ACKNOWLEDGE_2f_SET BCM89500_A0_G_ANNXP_EXT_P4r_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXT_P4r_MES_PAGEf_GET BCM89500_A0_G_ANNXP_EXT_P4r_MES_PAGEf_GET
#define G_ANNXP_EXT_P4r_MES_PAGEf_SET BCM89500_A0_G_ANNXP_EXT_P4r_MES_PAGEf_SET
#define G_ANNXP_EXT_P4r_RESERVED_1f_GET BCM89500_A0_G_ANNXP_EXT_P4r_RESERVED_1f_GET
#define G_ANNXP_EXT_P4r_RESERVED_1f_SET BCM89500_A0_G_ANNXP_EXT_P4r_RESERVED_1f_SET
#define G_ANNXP_EXT_P4r_NEXT_PAGEf_GET BCM89500_A0_G_ANNXP_EXT_P4r_NEXT_PAGEf_GET
#define G_ANNXP_EXT_P4r_NEXT_PAGEf_SET BCM89500_A0_G_ANNXP_EXT_P4r_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXT_P4r BCM89500_A0_READ_G_ANNXP_EXT_P4r
#define WRITE_G_ANNXP_EXT_P4r BCM89500_A0_WRITE_G_ANNXP_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANNXP_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANNXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANNXP_EXT_P5r 0x0000850e

#define BCM89500_A0_G_ANNXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_ANNXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_annxp_ext_p5[1];
	uint32_t _g_annxp_ext_p5;
} BCM89500_A0_G_ANNXP_EXT_P5r_t;

#define BCM89500_A0_G_ANNXP_EXT_P5r_CLR(r) (r).g_annxp_ext_p5[0] = 0
#define BCM89500_A0_G_ANNXP_EXT_P5r_SET(r,d) (r).g_annxp_ext_p5[0] = d
#define BCM89500_A0_G_ANNXP_EXT_P5r_GET(r) (r).g_annxp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANNXP_EXT_P5r_TOGGLEf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P5r_TOGGLEf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANNXP_EXT_P5r_MES_PAGEf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P5r_MES_PAGEf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANNXP_EXT_P5r_RESERVED_1f_GET(r) ((((r).g_annxp_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P5r_RESERVED_1f_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_ANNXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANNXP_EXT_P5r,(r._g_annxp_ext_p5),2)
#define BCM89500_A0_WRITE_G_ANNXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANNXP_EXT_P5r,&(r._g_annxp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXT_P5r BCM89500_A0_G_ANNXP_EXT_P5r
#define G_ANNXP_EXT_P5r_SIZE BCM89500_A0_G_ANNXP_EXT_P5r_SIZE
typedef BCM89500_A0_G_ANNXP_EXT_P5r_t G_ANNXP_EXT_P5r_t;
#define G_ANNXP_EXT_P5r_CLR BCM89500_A0_G_ANNXP_EXT_P5r_CLR
#define G_ANNXP_EXT_P5r_SET BCM89500_A0_G_ANNXP_EXT_P5r_SET
#define G_ANNXP_EXT_P5r_GET BCM89500_A0_G_ANNXP_EXT_P5r_GET
#define G_ANNXP_EXT_P5r_CODE_FIELDf_GET BCM89500_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_GET
#define G_ANNXP_EXT_P5r_CODE_FIELDf_SET BCM89500_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_SET
#define G_ANNXP_EXT_P5r_TOGGLEf_GET BCM89500_A0_G_ANNXP_EXT_P5r_TOGGLEf_GET
#define G_ANNXP_EXT_P5r_TOGGLEf_SET BCM89500_A0_G_ANNXP_EXT_P5r_TOGGLEf_SET
#define G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_GET BCM89500_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_SET BCM89500_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXT_P5r_MES_PAGEf_GET BCM89500_A0_G_ANNXP_EXT_P5r_MES_PAGEf_GET
#define G_ANNXP_EXT_P5r_MES_PAGEf_SET BCM89500_A0_G_ANNXP_EXT_P5r_MES_PAGEf_SET
#define G_ANNXP_EXT_P5r_RESERVED_1f_GET BCM89500_A0_G_ANNXP_EXT_P5r_RESERVED_1f_GET
#define G_ANNXP_EXT_P5r_RESERVED_1f_SET BCM89500_A0_G_ANNXP_EXT_P5r_RESERVED_1f_SET
#define G_ANNXP_EXT_P5r_NEXT_PAGEf_GET BCM89500_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_GET
#define G_ANNXP_EXT_P5r_NEXT_PAGEf_SET BCM89500_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXT_P5r BCM89500_A0_READ_G_ANNXP_EXT_P5r
#define WRITE_G_ANNXP_EXT_P5r BCM89500_A0_WRITE_G_ANNXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANNXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANNXP_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANNXP_EXT_PNr 0x0000800e

#define BCM89500_A0_G_ANNXP_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_ANNXP_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_annxp_ext_pn[1];
	uint32_t _g_annxp_ext_pn;
} BCM89500_A0_G_ANNXP_EXT_PNr_t;

#define BCM89500_A0_G_ANNXP_EXT_PNr_CLR(r) (r).g_annxp_ext_pn[0] = 0
#define BCM89500_A0_G_ANNXP_EXT_PNr_SET(r,d) (r).g_annxp_ext_pn[0] = d
#define BCM89500_A0_G_ANNXP_EXT_PNr_GET(r) (r).g_annxp_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANNXP_EXT_PNr_CODE_FIELDf_GET(r) ((((r).g_annxp_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_PNr_CODE_FIELDf_SET(r,f) (r).g_annxp_ext_pn[0]=(((r).g_annxp_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANNXP_EXT_PNr_TOGGLEf_GET(r) ((((r).g_annxp_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_PNr_TOGGLEf_SET(r,f) (r).g_annxp_ext_pn[0]=(((r).g_annxp_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANNXP_EXT_PNr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_PNr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext_pn[0]=(((r).g_annxp_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANNXP_EXT_PNr_MES_PAGEf_GET(r) ((((r).g_annxp_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_PNr_MES_PAGEf_SET(r,f) (r).g_annxp_ext_pn[0]=(((r).g_annxp_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANNXP_EXT_PNr_RESERVED_1f_GET(r) ((((r).g_annxp_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_PNr_RESERVED_1f_SET(r,f) (r).g_annxp_ext_pn[0]=(((r).g_annxp_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANNXP_EXT_PNr_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANNXP_EXT_PNr_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext_pn[0]=(((r).g_annxp_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_ANNXP_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_ANNXP_EXT_PNr,(r._g_annxp_ext_pn),2)
#define BCM89500_A0_WRITE_G_ANNXP_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_ANNXP_EXT_PNr,&(r._g_annxp_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXT_PNr BCM89500_A0_G_ANNXP_EXT_PNr
#define G_ANNXP_EXT_PNr_SIZE BCM89500_A0_G_ANNXP_EXT_PNr_SIZE
typedef BCM89500_A0_G_ANNXP_EXT_PNr_t G_ANNXP_EXT_PNr_t;
#define G_ANNXP_EXT_PNr_CLR BCM89500_A0_G_ANNXP_EXT_PNr_CLR
#define G_ANNXP_EXT_PNr_SET BCM89500_A0_G_ANNXP_EXT_PNr_SET
#define G_ANNXP_EXT_PNr_GET BCM89500_A0_G_ANNXP_EXT_PNr_GET
#define G_ANNXP_EXT_PNr_CODE_FIELDf_GET BCM89500_A0_G_ANNXP_EXT_PNr_CODE_FIELDf_GET
#define G_ANNXP_EXT_PNr_CODE_FIELDf_SET BCM89500_A0_G_ANNXP_EXT_PNr_CODE_FIELDf_SET
#define G_ANNXP_EXT_PNr_TOGGLEf_GET BCM89500_A0_G_ANNXP_EXT_PNr_TOGGLEf_GET
#define G_ANNXP_EXT_PNr_TOGGLEf_SET BCM89500_A0_G_ANNXP_EXT_PNr_TOGGLEf_SET
#define G_ANNXP_EXT_PNr_ACKNOWLEDGE_2f_GET BCM89500_A0_G_ANNXP_EXT_PNr_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXT_PNr_ACKNOWLEDGE_2f_SET BCM89500_A0_G_ANNXP_EXT_PNr_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXT_PNr_MES_PAGEf_GET BCM89500_A0_G_ANNXP_EXT_PNr_MES_PAGEf_GET
#define G_ANNXP_EXT_PNr_MES_PAGEf_SET BCM89500_A0_G_ANNXP_EXT_PNr_MES_PAGEf_SET
#define G_ANNXP_EXT_PNr_RESERVED_1f_GET BCM89500_A0_G_ANNXP_EXT_PNr_RESERVED_1f_GET
#define G_ANNXP_EXT_PNr_RESERVED_1f_SET BCM89500_A0_G_ANNXP_EXT_PNr_RESERVED_1f_SET
#define G_ANNXP_EXT_PNr_NEXT_PAGEf_GET BCM89500_A0_G_ANNXP_EXT_PNr_NEXT_PAGEf_GET
#define G_ANNXP_EXT_PNr_NEXT_PAGEf_SET BCM89500_A0_G_ANNXP_EXT_PNr_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXT_PNr BCM89500_A0_READ_G_ANNXP_EXT_PNr
#define WRITE_G_ANNXP_EXT_PNr BCM89500_A0_WRITE_G_ANNXP_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANNXP_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_ANNXP_P7
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_ANNXP_P7r 0x0000170e

#define BCM89500_A0_G_ANNXP_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_P7.
 *
 */
typedef union BCM89500_A0_G_ANNXP_P7r_s {
	uint32_t v[1];
	uint32_t g_annxp_p7[1];
	uint32_t _g_annxp_p7;
} BCM89500_A0_G_ANNXP_P7r_t;

#define BCM89500_A0_G_ANNXP_P7r_CLR(r) (r).g_annxp_p7[0] = 0
#define BCM89500_A0_G_ANNXP_P7r_SET(r,d) (r).g_annxp_p7[0] = d
#define BCM89500_A0_G_ANNXP_P7r_GET(r) (r).g_annxp_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_ANNXP_P7r_CODE_FIELDf_GET(r) ((((r).g_annxp_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_ANNXP_P7r_CODE_FIELDf_SET(r,f) (r).g_annxp_p7[0]=(((r).g_annxp_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_ANNXP_P7r_TOGGLEf_GET(r) ((((r).g_annxp_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_ANNXP_P7r_TOGGLEf_SET(r,f) (r).g_annxp_p7[0]=(((r).g_annxp_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_ANNXP_P7r_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_ANNXP_P7r_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_p7[0]=(((r).g_annxp_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_ANNXP_P7r_MES_PAGEf_GET(r) ((((r).g_annxp_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_ANNXP_P7r_MES_PAGEf_SET(r,f) (r).g_annxp_p7[0]=(((r).g_annxp_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_ANNXP_P7r_RESERVED_1f_GET(r) ((((r).g_annxp_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_ANNXP_P7r_RESERVED_1f_SET(r,f) (r).g_annxp_p7[0]=(((r).g_annxp_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_ANNXP_P7r_NEXT_PAGEf_GET(r) ((((r).g_annxp_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_ANNXP_P7r_NEXT_PAGEf_SET(r,f) (r).g_annxp_p7[0]=(((r).g_annxp_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_P7.
 *
 */
#define BCM89500_A0_READ_G_ANNXP_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_ANNXP_P7r,(r._g_annxp_p7),2)
#define BCM89500_A0_WRITE_G_ANNXP_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_ANNXP_P7r,&(r._g_annxp_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_P7r BCM89500_A0_G_ANNXP_P7r
#define G_ANNXP_P7r_SIZE BCM89500_A0_G_ANNXP_P7r_SIZE
typedef BCM89500_A0_G_ANNXP_P7r_t G_ANNXP_P7r_t;
#define G_ANNXP_P7r_CLR BCM89500_A0_G_ANNXP_P7r_CLR
#define G_ANNXP_P7r_SET BCM89500_A0_G_ANNXP_P7r_SET
#define G_ANNXP_P7r_GET BCM89500_A0_G_ANNXP_P7r_GET
#define G_ANNXP_P7r_CODE_FIELDf_GET BCM89500_A0_G_ANNXP_P7r_CODE_FIELDf_GET
#define G_ANNXP_P7r_CODE_FIELDf_SET BCM89500_A0_G_ANNXP_P7r_CODE_FIELDf_SET
#define G_ANNXP_P7r_TOGGLEf_GET BCM89500_A0_G_ANNXP_P7r_TOGGLEf_GET
#define G_ANNXP_P7r_TOGGLEf_SET BCM89500_A0_G_ANNXP_P7r_TOGGLEf_SET
#define G_ANNXP_P7r_ACKNOWLEDGE_2f_GET BCM89500_A0_G_ANNXP_P7r_ACKNOWLEDGE_2f_GET
#define G_ANNXP_P7r_ACKNOWLEDGE_2f_SET BCM89500_A0_G_ANNXP_P7r_ACKNOWLEDGE_2f_SET
#define G_ANNXP_P7r_MES_PAGEf_GET BCM89500_A0_G_ANNXP_P7r_MES_PAGEf_GET
#define G_ANNXP_P7r_MES_PAGEf_SET BCM89500_A0_G_ANNXP_P7r_MES_PAGEf_SET
#define G_ANNXP_P7r_RESERVED_1f_GET BCM89500_A0_G_ANNXP_P7r_RESERVED_1f_GET
#define G_ANNXP_P7r_RESERVED_1f_SET BCM89500_A0_G_ANNXP_P7r_RESERVED_1f_SET
#define G_ANNXP_P7r_NEXT_PAGEf_GET BCM89500_A0_G_ANNXP_P7r_NEXT_PAGEf_GET
#define G_ANNXP_P7r_NEXT_PAGEf_SET BCM89500_A0_G_ANNXP_P7r_NEXT_PAGEf_SET
#define READ_G_ANNXP_P7r BCM89500_A0_READ_G_ANNXP_P7r
#define WRITE_G_ANNXP_P7r BCM89500_A0_WRITE_G_ANNXP_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_ANNXP_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_CTL
 * BLOCKS:   SYS
 * DESC:     Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG_SEL   000 = Auxiliary Control001 = 10 Base T010 = Power/MII Control100 = Misc Test 1111 = Misc Control
 *     SHADOW_REG_CTRL  Power/MII Control:bit 15-6 : reservedbit 5 : super isolate, isolate mode with no link pulses transmitted.bit 4-3 : reservedMisc Test 1:bit 15 : remote loopback enablebit 14-5 : reservedbit 4 : swap rx mdix (1=rx and tx operate on same pair, 0=normal operation)bit 3 : transmit half amplitude, all speeds.Misc Control:bit 15 : write enablebit 14-12 : shadow register read selectorbit 11 : packet counter mode (1=count packets recieved, 0=count packets transmitted)bit 10 : bypass wirespeed timerbit 9 : force auto mdix modebit 8-3 : reservde
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_CTLr 0x00001430

#define BCM89500_A0_G_AUX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL.
 *
 */
typedef union BCM89500_A0_G_AUX_CTLr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl[1];
	uint32_t _g_aux_ctl;
} BCM89500_A0_G_AUX_CTLr_t;

#define BCM89500_A0_G_AUX_CTLr_CLR(r) (r).g_aux_ctl[0] = 0
#define BCM89500_A0_G_AUX_CTLr_SET(r,d) (r).g_aux_ctl[0] = d
#define BCM89500_A0_G_AUX_CTLr_GET(r) (r).g_aux_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_CTLr_SHADOW_REG_SELf_GET(r) (((r).g_aux_ctl[0]) & 0x7)
#define BCM89500_A0_G_AUX_CTLr_SHADOW_REG_SELf_SET(r,f) (r).g_aux_ctl[0]=(((r).g_aux_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_G_AUX_CTLr_SHADOW_REG_CTRLf_GET(r) ((((r).g_aux_ctl[0]) >> 3) & 0x1fff)
#define BCM89500_A0_G_AUX_CTLr_SHADOW_REG_CTRLf_SET(r,f) (r).g_aux_ctl[0]=(((r).g_aux_ctl[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access G_AUX_CTL.
 *
 */
#define BCM89500_A0_READ_G_AUX_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_CTLr,(r._g_aux_ctl),2)
#define BCM89500_A0_WRITE_G_AUX_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_CTLr,&(r._g_aux_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTLr BCM89500_A0_G_AUX_CTLr
#define G_AUX_CTLr_SIZE BCM89500_A0_G_AUX_CTLr_SIZE
typedef BCM89500_A0_G_AUX_CTLr_t G_AUX_CTLr_t;
#define G_AUX_CTLr_CLR BCM89500_A0_G_AUX_CTLr_CLR
#define G_AUX_CTLr_SET BCM89500_A0_G_AUX_CTLr_SET
#define G_AUX_CTLr_GET BCM89500_A0_G_AUX_CTLr_GET
#define G_AUX_CTLr_SHADOW_REG_SELf_GET BCM89500_A0_G_AUX_CTLr_SHADOW_REG_SELf_GET
#define G_AUX_CTLr_SHADOW_REG_SELf_SET BCM89500_A0_G_AUX_CTLr_SHADOW_REG_SELf_SET
#define G_AUX_CTLr_SHADOW_REG_CTRLf_GET BCM89500_A0_G_AUX_CTLr_SHADOW_REG_CTRLf_GET
#define G_AUX_CTLr_SHADOW_REG_CTRLf_SET BCM89500_A0_G_AUX_CTLr_SHADOW_REG_CTRLf_SET
#define READ_G_AUX_CTLr BCM89500_A0_READ_G_AUX_CTLr
#define WRITE_G_AUX_CTLr BCM89500_A0_WRITE_G_AUX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_CTL_EXTr 0x00008830

#define BCM89500_A0_G_AUX_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT.
 *
 */
typedef union BCM89500_A0_G_AUX_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext[1];
	uint32_t _g_aux_ctl_ext;
} BCM89500_A0_G_AUX_CTL_EXTr_t;

#define BCM89500_A0_G_AUX_CTL_EXTr_CLR(r) (r).g_aux_ctl_ext[0] = 0
#define BCM89500_A0_G_AUX_CTL_EXTr_SET(r,d) (r).g_aux_ctl_ext[0] = d
#define BCM89500_A0_G_AUX_CTL_EXTr_GET(r) (r).g_aux_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext[0]) & 0xffff)
#define BCM89500_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext[0]=(((r).g_aux_ctl_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT.
 *
 */
#define BCM89500_A0_READ_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_CTL_EXTr,(r._g_aux_ctl_ext),2)
#define BCM89500_A0_WRITE_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_CTL_EXTr,&(r._g_aux_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXTr BCM89500_A0_G_AUX_CTL_EXTr
#define G_AUX_CTL_EXTr_SIZE BCM89500_A0_G_AUX_CTL_EXTr_SIZE
typedef BCM89500_A0_G_AUX_CTL_EXTr_t G_AUX_CTL_EXTr_t;
#define G_AUX_CTL_EXTr_CLR BCM89500_A0_G_AUX_CTL_EXTr_CLR
#define G_AUX_CTL_EXTr_SET BCM89500_A0_G_AUX_CTL_EXTr_SET
#define G_AUX_CTL_EXTr_GET BCM89500_A0_G_AUX_CTL_EXTr_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_GET BCM89500_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_SET BCM89500_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXTr BCM89500_A0_READ_G_AUX_CTL_EXTr
#define WRITE_G_AUX_CTL_EXTr BCM89500_A0_WRITE_G_AUX_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_CTL_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_CTL_EXT_P4r 0x00008430

#define BCM89500_A0_G_AUX_CTL_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_AUX_CTL_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext_p4[1];
	uint32_t _g_aux_ctl_ext_p4;
} BCM89500_A0_G_AUX_CTL_EXT_P4r_t;

#define BCM89500_A0_G_AUX_CTL_EXT_P4r_CLR(r) (r).g_aux_ctl_ext_p4[0] = 0
#define BCM89500_A0_G_AUX_CTL_EXT_P4r_SET(r,d) (r).g_aux_ctl_ext_p4[0] = d
#define BCM89500_A0_G_AUX_CTL_EXT_P4r_GET(r) (r).g_aux_ctl_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_CTL_EXT_P4r_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_AUX_CTL_EXT_P4r_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext_p4[0]=(((r).g_aux_ctl_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_AUX_CTL_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_CTL_EXT_P4r,(r._g_aux_ctl_ext_p4),2)
#define BCM89500_A0_WRITE_G_AUX_CTL_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_CTL_EXT_P4r,&(r._g_aux_ctl_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXT_P4r BCM89500_A0_G_AUX_CTL_EXT_P4r
#define G_AUX_CTL_EXT_P4r_SIZE BCM89500_A0_G_AUX_CTL_EXT_P4r_SIZE
typedef BCM89500_A0_G_AUX_CTL_EXT_P4r_t G_AUX_CTL_EXT_P4r_t;
#define G_AUX_CTL_EXT_P4r_CLR BCM89500_A0_G_AUX_CTL_EXT_P4r_CLR
#define G_AUX_CTL_EXT_P4r_SET BCM89500_A0_G_AUX_CTL_EXT_P4r_SET
#define G_AUX_CTL_EXT_P4r_GET BCM89500_A0_G_AUX_CTL_EXT_P4r_GET
#define G_AUX_CTL_EXT_P4r_SHADOW_REGf_GET BCM89500_A0_G_AUX_CTL_EXT_P4r_SHADOW_REGf_GET
#define G_AUX_CTL_EXT_P4r_SHADOW_REGf_SET BCM89500_A0_G_AUX_CTL_EXT_P4r_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXT_P4r BCM89500_A0_READ_G_AUX_CTL_EXT_P4r
#define WRITE_G_AUX_CTL_EXT_P4r BCM89500_A0_WRITE_G_AUX_CTL_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_CTL_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_CTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_CTL_EXT_P5r 0x00008530

#define BCM89500_A0_G_AUX_CTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_AUX_CTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext_p5[1];
	uint32_t _g_aux_ctl_ext_p5;
} BCM89500_A0_G_AUX_CTL_EXT_P5r_t;

#define BCM89500_A0_G_AUX_CTL_EXT_P5r_CLR(r) (r).g_aux_ctl_ext_p5[0] = 0
#define BCM89500_A0_G_AUX_CTL_EXT_P5r_SET(r,d) (r).g_aux_ctl_ext_p5[0] = d
#define BCM89500_A0_G_AUX_CTL_EXT_P5r_GET(r) (r).g_aux_ctl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext_p5[0]=(((r).g_aux_ctl_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_AUX_CTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_CTL_EXT_P5r,(r._g_aux_ctl_ext_p5),2)
#define BCM89500_A0_WRITE_G_AUX_CTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_CTL_EXT_P5r,&(r._g_aux_ctl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXT_P5r BCM89500_A0_G_AUX_CTL_EXT_P5r
#define G_AUX_CTL_EXT_P5r_SIZE BCM89500_A0_G_AUX_CTL_EXT_P5r_SIZE
typedef BCM89500_A0_G_AUX_CTL_EXT_P5r_t G_AUX_CTL_EXT_P5r_t;
#define G_AUX_CTL_EXT_P5r_CLR BCM89500_A0_G_AUX_CTL_EXT_P5r_CLR
#define G_AUX_CTL_EXT_P5r_SET BCM89500_A0_G_AUX_CTL_EXT_P5r_SET
#define G_AUX_CTL_EXT_P5r_GET BCM89500_A0_G_AUX_CTL_EXT_P5r_GET
#define G_AUX_CTL_EXT_P5r_SHADOW_REGf_GET BCM89500_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_GET
#define G_AUX_CTL_EXT_P5r_SHADOW_REGf_SET BCM89500_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXT_P5r BCM89500_A0_READ_G_AUX_CTL_EXT_P5r
#define WRITE_G_AUX_CTL_EXT_P5r BCM89500_A0_WRITE_G_AUX_CTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_CTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_CTL_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_CTL_EXT_PNr 0x00008030

#define BCM89500_A0_G_AUX_CTL_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_AUX_CTL_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext_pn[1];
	uint32_t _g_aux_ctl_ext_pn;
} BCM89500_A0_G_AUX_CTL_EXT_PNr_t;

#define BCM89500_A0_G_AUX_CTL_EXT_PNr_CLR(r) (r).g_aux_ctl_ext_pn[0] = 0
#define BCM89500_A0_G_AUX_CTL_EXT_PNr_SET(r,d) (r).g_aux_ctl_ext_pn[0] = d
#define BCM89500_A0_G_AUX_CTL_EXT_PNr_GET(r) (r).g_aux_ctl_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_CTL_EXT_PNr_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_AUX_CTL_EXT_PNr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext_pn[0]=(((r).g_aux_ctl_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_AUX_CTL_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_AUX_CTL_EXT_PNr,(r._g_aux_ctl_ext_pn),2)
#define BCM89500_A0_WRITE_G_AUX_CTL_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_AUX_CTL_EXT_PNr,&(r._g_aux_ctl_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXT_PNr BCM89500_A0_G_AUX_CTL_EXT_PNr
#define G_AUX_CTL_EXT_PNr_SIZE BCM89500_A0_G_AUX_CTL_EXT_PNr_SIZE
typedef BCM89500_A0_G_AUX_CTL_EXT_PNr_t G_AUX_CTL_EXT_PNr_t;
#define G_AUX_CTL_EXT_PNr_CLR BCM89500_A0_G_AUX_CTL_EXT_PNr_CLR
#define G_AUX_CTL_EXT_PNr_SET BCM89500_A0_G_AUX_CTL_EXT_PNr_SET
#define G_AUX_CTL_EXT_PNr_GET BCM89500_A0_G_AUX_CTL_EXT_PNr_GET
#define G_AUX_CTL_EXT_PNr_SHADOW_REGf_GET BCM89500_A0_G_AUX_CTL_EXT_PNr_SHADOW_REGf_GET
#define G_AUX_CTL_EXT_PNr_SHADOW_REGf_SET BCM89500_A0_G_AUX_CTL_EXT_PNr_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXT_PNr BCM89500_A0_READ_G_AUX_CTL_EXT_PNr
#define WRITE_G_AUX_CTL_EXT_PNr BCM89500_A0_WRITE_G_AUX_CTL_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_CTL_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_CTL_P7
 * BLOCKS:   SYS
 * DESC:     Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_CTL_P7r 0x00001730

#define BCM89500_A0_G_AUX_CTL_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_P7.
 *
 */
typedef union BCM89500_A0_G_AUX_CTL_P7r_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_p7[1];
	uint32_t _g_aux_ctl_p7;
} BCM89500_A0_G_AUX_CTL_P7r_t;

#define BCM89500_A0_G_AUX_CTL_P7r_CLR(r) (r).g_aux_ctl_p7[0] = 0
#define BCM89500_A0_G_AUX_CTL_P7r_SET(r,d) (r).g_aux_ctl_p7[0] = d
#define BCM89500_A0_G_AUX_CTL_P7r_GET(r) (r).g_aux_ctl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_CTL_P7r_SHADOW_REGf_GET(r) (((r).g_aux_ctl_p7[0]) & 0xffff)
#define BCM89500_A0_G_AUX_CTL_P7r_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_p7[0]=(((r).g_aux_ctl_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_P7.
 *
 */
#define BCM89500_A0_READ_G_AUX_CTL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_CTL_P7r,(r._g_aux_ctl_p7),2)
#define BCM89500_A0_WRITE_G_AUX_CTL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_CTL_P7r,&(r._g_aux_ctl_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_P7r BCM89500_A0_G_AUX_CTL_P7r
#define G_AUX_CTL_P7r_SIZE BCM89500_A0_G_AUX_CTL_P7r_SIZE
typedef BCM89500_A0_G_AUX_CTL_P7r_t G_AUX_CTL_P7r_t;
#define G_AUX_CTL_P7r_CLR BCM89500_A0_G_AUX_CTL_P7r_CLR
#define G_AUX_CTL_P7r_SET BCM89500_A0_G_AUX_CTL_P7r_SET
#define G_AUX_CTL_P7r_GET BCM89500_A0_G_AUX_CTL_P7r_GET
#define G_AUX_CTL_P7r_SHADOW_REGf_GET BCM89500_A0_G_AUX_CTL_P7r_SHADOW_REGf_GET
#define G_AUX_CTL_P7r_SHADOW_REGf_SET BCM89500_A0_G_AUX_CTL_P7r_SHADOW_REGf_SET
#define READ_G_AUX_CTL_P7r BCM89500_A0_READ_G_AUX_CTL_P7r
#define WRITE_G_AUX_CTL_P7r BCM89500_A0_WRITE_G_AUX_CTL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_CTL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_STS
 * BLOCKS:   SYS
 * DESC:     Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_RESOLUTION_TX 1 = enable pause transmit 0 = disable pause transmit
 *     PAUSE_RESOLUTION_RX 1 = enable pause receive0 = disable pause receive
 *     LINK_STATUS      1 = link pass0 = link fail
 *     LP_NP_ABILITY    1 = link partner is next page able0 = link partner is not next page able
 *     LP_AN_ABILITY    1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able
 *     PAGE_RECEIVED    1 = new link code word has been received0 = new link code word has not been received
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault
 *     PARALLEL_DETECTION_FAULT 1 = parallel detection fault0 = no parallel detection fault
 *     AN_HCD           111 = 1000Base-T full duplex110 = 1000Base-T half duplex101 = 100Base-TX full duplex100 = 100Base-T4011 = 100Base-TX half duplex010 = 10Base-T full duplex001 = 10Base-T half duplex000 = no highest common denominator (when auto-neg complete = 1) or auto-negotiation not complete (when auto-neg complete = 0)
 *     AN_NEXT_PAGE_WAIT 1 = entered auto-neg "next page wait" state0 = state not entered since last read
 *     AN_ABILITY_DETECT 1 = entered auto-neg "ability detect" state0 = state not entered since last read
 *     AN_ACK_DETECT    1 = entered auto-neg "acknowledge detect" state0 = state not entered since last read
 *     AN_COMPLETE_ACK  1 = entered auto-neg "link good check" state0 = state not entered since last read
 *     AN_COMPLETE      1 = auto-negotiation complete0 = auto-negotiation in progress
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_STSr 0x00001432

#define BCM89500_A0_G_AUX_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS.
 *
 */
typedef union BCM89500_A0_G_AUX_STSr_s {
	uint32_t v[1];
	uint32_t g_aux_sts[1];
	uint32_t _g_aux_sts;
} BCM89500_A0_G_AUX_STSr_t;

#define BCM89500_A0_G_AUX_STSr_CLR(r) (r).g_aux_sts[0] = 0
#define BCM89500_A0_G_AUX_STSr_SET(r,d) (r).g_aux_sts[0] = d
#define BCM89500_A0_G_AUX_STSr_GET(r) (r).g_aux_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_TXf_GET(r) (((r).g_aux_sts[0]) & 0x1)
#define BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_TXf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_RXf_GET(r) ((((r).g_aux_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_RXf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_AUX_STSr_LINK_STATUSf_GET(r) ((((r).g_aux_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_G_AUX_STSr_LINK_STATUSf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_AUX_STSr_LP_NP_ABILITYf_GET(r) ((((r).g_aux_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_G_AUX_STSr_LP_NP_ABILITYf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_AUX_STSr_LP_AN_ABILITYf_GET(r) ((((r).g_aux_sts[0]) >> 4) & 0x1)
#define BCM89500_A0_G_AUX_STSr_LP_AN_ABILITYf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_AUX_STSr_PAGE_RECEIVEDf_GET(r) ((((r).g_aux_sts[0]) >> 5) & 0x1)
#define BCM89500_A0_G_AUX_STSr_PAGE_RECEIVEDf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_AUX_STSr_REMOTE_FAULTf_GET(r) ((((r).g_aux_sts[0]) >> 6) & 0x1)
#define BCM89500_A0_G_AUX_STSr_REMOTE_FAULTf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_AUX_STSr_PARALLEL_DETECTION_FAULTf_GET(r) ((((r).g_aux_sts[0]) >> 7) & 0x1)
#define BCM89500_A0_G_AUX_STSr_PARALLEL_DETECTION_FAULTf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_AUX_STSr_AN_HCDf_GET(r) ((((r).g_aux_sts[0]) >> 8) & 0x7)
#define BCM89500_A0_G_AUX_STSr_AN_HCDf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM89500_A0_G_AUX_STSr_AN_NEXT_PAGE_WAITf_GET(r) ((((r).g_aux_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_G_AUX_STSr_AN_NEXT_PAGE_WAITf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_AUX_STSr_AN_ABILITY_DETECTf_GET(r) ((((r).g_aux_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_G_AUX_STSr_AN_ABILITY_DETECTf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_AUX_STSr_AN_ACK_DETECTf_GET(r) ((((r).g_aux_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_G_AUX_STSr_AN_ACK_DETECTf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_AUX_STSr_AN_COMPLETE_ACKf_GET(r) ((((r).g_aux_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_G_AUX_STSr_AN_COMPLETE_ACKf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_AUX_STSr_AN_COMPLETEf_GET(r) ((((r).g_aux_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_G_AUX_STSr_AN_COMPLETEf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_AUX_STS.
 *
 */
#define BCM89500_A0_READ_G_AUX_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_STSr,(r._g_aux_sts),2)
#define BCM89500_A0_WRITE_G_AUX_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_STSr,&(r._g_aux_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STSr BCM89500_A0_G_AUX_STSr
#define G_AUX_STSr_SIZE BCM89500_A0_G_AUX_STSr_SIZE
typedef BCM89500_A0_G_AUX_STSr_t G_AUX_STSr_t;
#define G_AUX_STSr_CLR BCM89500_A0_G_AUX_STSr_CLR
#define G_AUX_STSr_SET BCM89500_A0_G_AUX_STSr_SET
#define G_AUX_STSr_GET BCM89500_A0_G_AUX_STSr_GET
#define G_AUX_STSr_PAUSE_RESOLUTION_TXf_GET BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_TXf_GET
#define G_AUX_STSr_PAUSE_RESOLUTION_TXf_SET BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_TXf_SET
#define G_AUX_STSr_PAUSE_RESOLUTION_RXf_GET BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_RXf_GET
#define G_AUX_STSr_PAUSE_RESOLUTION_RXf_SET BCM89500_A0_G_AUX_STSr_PAUSE_RESOLUTION_RXf_SET
#define G_AUX_STSr_LINK_STATUSf_GET BCM89500_A0_G_AUX_STSr_LINK_STATUSf_GET
#define G_AUX_STSr_LINK_STATUSf_SET BCM89500_A0_G_AUX_STSr_LINK_STATUSf_SET
#define G_AUX_STSr_LP_NP_ABILITYf_GET BCM89500_A0_G_AUX_STSr_LP_NP_ABILITYf_GET
#define G_AUX_STSr_LP_NP_ABILITYf_SET BCM89500_A0_G_AUX_STSr_LP_NP_ABILITYf_SET
#define G_AUX_STSr_LP_AN_ABILITYf_GET BCM89500_A0_G_AUX_STSr_LP_AN_ABILITYf_GET
#define G_AUX_STSr_LP_AN_ABILITYf_SET BCM89500_A0_G_AUX_STSr_LP_AN_ABILITYf_SET
#define G_AUX_STSr_PAGE_RECEIVEDf_GET BCM89500_A0_G_AUX_STSr_PAGE_RECEIVEDf_GET
#define G_AUX_STSr_PAGE_RECEIVEDf_SET BCM89500_A0_G_AUX_STSr_PAGE_RECEIVEDf_SET
#define G_AUX_STSr_REMOTE_FAULTf_GET BCM89500_A0_G_AUX_STSr_REMOTE_FAULTf_GET
#define G_AUX_STSr_REMOTE_FAULTf_SET BCM89500_A0_G_AUX_STSr_REMOTE_FAULTf_SET
#define G_AUX_STSr_PARALLEL_DETECTION_FAULTf_GET BCM89500_A0_G_AUX_STSr_PARALLEL_DETECTION_FAULTf_GET
#define G_AUX_STSr_PARALLEL_DETECTION_FAULTf_SET BCM89500_A0_G_AUX_STSr_PARALLEL_DETECTION_FAULTf_SET
#define G_AUX_STSr_AN_HCDf_GET BCM89500_A0_G_AUX_STSr_AN_HCDf_GET
#define G_AUX_STSr_AN_HCDf_SET BCM89500_A0_G_AUX_STSr_AN_HCDf_SET
#define G_AUX_STSr_AN_NEXT_PAGE_WAITf_GET BCM89500_A0_G_AUX_STSr_AN_NEXT_PAGE_WAITf_GET
#define G_AUX_STSr_AN_NEXT_PAGE_WAITf_SET BCM89500_A0_G_AUX_STSr_AN_NEXT_PAGE_WAITf_SET
#define G_AUX_STSr_AN_ABILITY_DETECTf_GET BCM89500_A0_G_AUX_STSr_AN_ABILITY_DETECTf_GET
#define G_AUX_STSr_AN_ABILITY_DETECTf_SET BCM89500_A0_G_AUX_STSr_AN_ABILITY_DETECTf_SET
#define G_AUX_STSr_AN_ACK_DETECTf_GET BCM89500_A0_G_AUX_STSr_AN_ACK_DETECTf_GET
#define G_AUX_STSr_AN_ACK_DETECTf_SET BCM89500_A0_G_AUX_STSr_AN_ACK_DETECTf_SET
#define G_AUX_STSr_AN_COMPLETE_ACKf_GET BCM89500_A0_G_AUX_STSr_AN_COMPLETE_ACKf_GET
#define G_AUX_STSr_AN_COMPLETE_ACKf_SET BCM89500_A0_G_AUX_STSr_AN_COMPLETE_ACKf_SET
#define G_AUX_STSr_AN_COMPLETEf_GET BCM89500_A0_G_AUX_STSr_AN_COMPLETEf_GET
#define G_AUX_STSr_AN_COMPLETEf_SET BCM89500_A0_G_AUX_STSr_AN_COMPLETEf_SET
#define READ_G_AUX_STSr BCM89500_A0_READ_G_AUX_STSr
#define WRITE_G_AUX_STSr BCM89500_A0_WRITE_G_AUX_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_STS_EXTr 0x00008832

#define BCM89500_A0_G_AUX_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT.
 *
 */
typedef union BCM89500_A0_G_AUX_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext[1];
	uint32_t _g_aux_sts_ext;
} BCM89500_A0_G_AUX_STS_EXTr_t;

#define BCM89500_A0_G_AUX_STS_EXTr_CLR(r) (r).g_aux_sts_ext[0] = 0
#define BCM89500_A0_G_AUX_STS_EXTr_SET(r,d) (r).g_aux_sts_ext[0] = d
#define BCM89500_A0_G_AUX_STS_EXTr_GET(r) (r).g_aux_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_STS_EXTr_AUX_STSf_GET(r) (((r).g_aux_sts_ext[0]) & 0xffff)
#define BCM89500_A0_G_AUX_STS_EXTr_AUX_STSf_SET(r,f) (r).g_aux_sts_ext[0]=(((r).g_aux_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT.
 *
 */
#define BCM89500_A0_READ_G_AUX_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_STS_EXTr,(r._g_aux_sts_ext),2)
#define BCM89500_A0_WRITE_G_AUX_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_STS_EXTr,&(r._g_aux_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXTr BCM89500_A0_G_AUX_STS_EXTr
#define G_AUX_STS_EXTr_SIZE BCM89500_A0_G_AUX_STS_EXTr_SIZE
typedef BCM89500_A0_G_AUX_STS_EXTr_t G_AUX_STS_EXTr_t;
#define G_AUX_STS_EXTr_CLR BCM89500_A0_G_AUX_STS_EXTr_CLR
#define G_AUX_STS_EXTr_SET BCM89500_A0_G_AUX_STS_EXTr_SET
#define G_AUX_STS_EXTr_GET BCM89500_A0_G_AUX_STS_EXTr_GET
#define G_AUX_STS_EXTr_AUX_STSf_GET BCM89500_A0_G_AUX_STS_EXTr_AUX_STSf_GET
#define G_AUX_STS_EXTr_AUX_STSf_SET BCM89500_A0_G_AUX_STS_EXTr_AUX_STSf_SET
#define READ_G_AUX_STS_EXTr BCM89500_A0_READ_G_AUX_STS_EXTr
#define WRITE_G_AUX_STS_EXTr BCM89500_A0_WRITE_G_AUX_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_STS_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_STS_EXT_P4r 0x00008432

#define BCM89500_A0_G_AUX_STS_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_AUX_STS_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext_p4[1];
	uint32_t _g_aux_sts_ext_p4;
} BCM89500_A0_G_AUX_STS_EXT_P4r_t;

#define BCM89500_A0_G_AUX_STS_EXT_P4r_CLR(r) (r).g_aux_sts_ext_p4[0] = 0
#define BCM89500_A0_G_AUX_STS_EXT_P4r_SET(r,d) (r).g_aux_sts_ext_p4[0] = d
#define BCM89500_A0_G_AUX_STS_EXT_P4r_GET(r) (r).g_aux_sts_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_STS_EXT_P4r_AUX_STSf_GET(r) (((r).g_aux_sts_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_AUX_STS_EXT_P4r_AUX_STSf_SET(r,f) (r).g_aux_sts_ext_p4[0]=(((r).g_aux_sts_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_AUX_STS_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_STS_EXT_P4r,(r._g_aux_sts_ext_p4),2)
#define BCM89500_A0_WRITE_G_AUX_STS_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_STS_EXT_P4r,&(r._g_aux_sts_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXT_P4r BCM89500_A0_G_AUX_STS_EXT_P4r
#define G_AUX_STS_EXT_P4r_SIZE BCM89500_A0_G_AUX_STS_EXT_P4r_SIZE
typedef BCM89500_A0_G_AUX_STS_EXT_P4r_t G_AUX_STS_EXT_P4r_t;
#define G_AUX_STS_EXT_P4r_CLR BCM89500_A0_G_AUX_STS_EXT_P4r_CLR
#define G_AUX_STS_EXT_P4r_SET BCM89500_A0_G_AUX_STS_EXT_P4r_SET
#define G_AUX_STS_EXT_P4r_GET BCM89500_A0_G_AUX_STS_EXT_P4r_GET
#define G_AUX_STS_EXT_P4r_AUX_STSf_GET BCM89500_A0_G_AUX_STS_EXT_P4r_AUX_STSf_GET
#define G_AUX_STS_EXT_P4r_AUX_STSf_SET BCM89500_A0_G_AUX_STS_EXT_P4r_AUX_STSf_SET
#define READ_G_AUX_STS_EXT_P4r BCM89500_A0_READ_G_AUX_STS_EXT_P4r
#define WRITE_G_AUX_STS_EXT_P4r BCM89500_A0_WRITE_G_AUX_STS_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_STS_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_STS_EXT_P5r 0x00008532

#define BCM89500_A0_G_AUX_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_AUX_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext_p5[1];
	uint32_t _g_aux_sts_ext_p5;
} BCM89500_A0_G_AUX_STS_EXT_P5r_t;

#define BCM89500_A0_G_AUX_STS_EXT_P5r_CLR(r) (r).g_aux_sts_ext_p5[0] = 0
#define BCM89500_A0_G_AUX_STS_EXT_P5r_SET(r,d) (r).g_aux_sts_ext_p5[0] = d
#define BCM89500_A0_G_AUX_STS_EXT_P5r_GET(r) (r).g_aux_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_STS_EXT_P5r_AUX_STSf_GET(r) (((r).g_aux_sts_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_AUX_STS_EXT_P5r_AUX_STSf_SET(r,f) (r).g_aux_sts_ext_p5[0]=(((r).g_aux_sts_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_AUX_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_STS_EXT_P5r,(r._g_aux_sts_ext_p5),2)
#define BCM89500_A0_WRITE_G_AUX_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_STS_EXT_P5r,&(r._g_aux_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXT_P5r BCM89500_A0_G_AUX_STS_EXT_P5r
#define G_AUX_STS_EXT_P5r_SIZE BCM89500_A0_G_AUX_STS_EXT_P5r_SIZE
typedef BCM89500_A0_G_AUX_STS_EXT_P5r_t G_AUX_STS_EXT_P5r_t;
#define G_AUX_STS_EXT_P5r_CLR BCM89500_A0_G_AUX_STS_EXT_P5r_CLR
#define G_AUX_STS_EXT_P5r_SET BCM89500_A0_G_AUX_STS_EXT_P5r_SET
#define G_AUX_STS_EXT_P5r_GET BCM89500_A0_G_AUX_STS_EXT_P5r_GET
#define G_AUX_STS_EXT_P5r_AUX_STSf_GET BCM89500_A0_G_AUX_STS_EXT_P5r_AUX_STSf_GET
#define G_AUX_STS_EXT_P5r_AUX_STSf_SET BCM89500_A0_G_AUX_STS_EXT_P5r_AUX_STSf_SET
#define READ_G_AUX_STS_EXT_P5r BCM89500_A0_READ_G_AUX_STS_EXT_P5r
#define WRITE_G_AUX_STS_EXT_P5r BCM89500_A0_WRITE_G_AUX_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_STS_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_STS_EXT_PNr 0x00008032

#define BCM89500_A0_G_AUX_STS_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_AUX_STS_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext_pn[1];
	uint32_t _g_aux_sts_ext_pn;
} BCM89500_A0_G_AUX_STS_EXT_PNr_t;

#define BCM89500_A0_G_AUX_STS_EXT_PNr_CLR(r) (r).g_aux_sts_ext_pn[0] = 0
#define BCM89500_A0_G_AUX_STS_EXT_PNr_SET(r,d) (r).g_aux_sts_ext_pn[0] = d
#define BCM89500_A0_G_AUX_STS_EXT_PNr_GET(r) (r).g_aux_sts_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_STS_EXT_PNr_AUX_STSf_GET(r) (((r).g_aux_sts_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_AUX_STS_EXT_PNr_AUX_STSf_SET(r,f) (r).g_aux_sts_ext_pn[0]=(((r).g_aux_sts_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_AUX_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_AUX_STS_EXT_PNr,(r._g_aux_sts_ext_pn),2)
#define BCM89500_A0_WRITE_G_AUX_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_AUX_STS_EXT_PNr,&(r._g_aux_sts_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXT_PNr BCM89500_A0_G_AUX_STS_EXT_PNr
#define G_AUX_STS_EXT_PNr_SIZE BCM89500_A0_G_AUX_STS_EXT_PNr_SIZE
typedef BCM89500_A0_G_AUX_STS_EXT_PNr_t G_AUX_STS_EXT_PNr_t;
#define G_AUX_STS_EXT_PNr_CLR BCM89500_A0_G_AUX_STS_EXT_PNr_CLR
#define G_AUX_STS_EXT_PNr_SET BCM89500_A0_G_AUX_STS_EXT_PNr_SET
#define G_AUX_STS_EXT_PNr_GET BCM89500_A0_G_AUX_STS_EXT_PNr_GET
#define G_AUX_STS_EXT_PNr_AUX_STSf_GET BCM89500_A0_G_AUX_STS_EXT_PNr_AUX_STSf_GET
#define G_AUX_STS_EXT_PNr_AUX_STSf_SET BCM89500_A0_G_AUX_STS_EXT_PNr_AUX_STSf_SET
#define READ_G_AUX_STS_EXT_PNr BCM89500_A0_READ_G_AUX_STS_EXT_PNr
#define WRITE_G_AUX_STS_EXT_PNr BCM89500_A0_WRITE_G_AUX_STS_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_STS_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_AUX_STS_P7
 * BLOCKS:   SYS
 * DESC:     Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM89500_A0_G_AUX_STS_P7r 0x00001732

#define BCM89500_A0_G_AUX_STS_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_P7.
 *
 */
typedef union BCM89500_A0_G_AUX_STS_P7r_s {
	uint32_t v[1];
	uint32_t g_aux_sts_p7[1];
	uint32_t _g_aux_sts_p7;
} BCM89500_A0_G_AUX_STS_P7r_t;

#define BCM89500_A0_G_AUX_STS_P7r_CLR(r) (r).g_aux_sts_p7[0] = 0
#define BCM89500_A0_G_AUX_STS_P7r_SET(r,d) (r).g_aux_sts_p7[0] = d
#define BCM89500_A0_G_AUX_STS_P7r_GET(r) (r).g_aux_sts_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_AUX_STS_P7r_AUX_STSf_GET(r) (((r).g_aux_sts_p7[0]) & 0xffff)
#define BCM89500_A0_G_AUX_STS_P7r_AUX_STSf_SET(r,f) (r).g_aux_sts_p7[0]=(((r).g_aux_sts_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_P7.
 *
 */
#define BCM89500_A0_READ_G_AUX_STS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_AUX_STS_P7r,(r._g_aux_sts_p7),2)
#define BCM89500_A0_WRITE_G_AUX_STS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_AUX_STS_P7r,&(r._g_aux_sts_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_P7r BCM89500_A0_G_AUX_STS_P7r
#define G_AUX_STS_P7r_SIZE BCM89500_A0_G_AUX_STS_P7r_SIZE
typedef BCM89500_A0_G_AUX_STS_P7r_t G_AUX_STS_P7r_t;
#define G_AUX_STS_P7r_CLR BCM89500_A0_G_AUX_STS_P7r_CLR
#define G_AUX_STS_P7r_SET BCM89500_A0_G_AUX_STS_P7r_SET
#define G_AUX_STS_P7r_GET BCM89500_A0_G_AUX_STS_P7r_GET
#define G_AUX_STS_P7r_AUX_STSf_GET BCM89500_A0_G_AUX_STS_P7r_AUX_STSf_GET
#define G_AUX_STS_P7r_AUX_STSf_SET BCM89500_A0_G_AUX_STS_P7r_AUX_STSf_SET
#define READ_G_AUX_STS_P7r BCM89500_A0_READ_G_AUX_STS_P7r
#define WRITE_G_AUX_STS_P7r BCM89500_A0_WRITE_G_AUX_STS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_AUX_STS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_CTL
 * BLOCKS:   SYS
 * DESC:     1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when bit 12 is set0 = configure PHY as Slave when bit 12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_CTLr 0x00001412

#define BCM89500_A0_G_B1000T_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL.
 *
 */
typedef union BCM89500_A0_G_B1000T_CTLr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl[1];
	uint32_t _g_b1000t_ctl;
} BCM89500_A0_G_B1000T_CTLr_t;

#define BCM89500_A0_G_B1000T_CTLr_CLR(r) (r).g_b1000t_ctl[0] = 0
#define BCM89500_A0_G_B1000T_CTLr_SET(r,d) (r).g_b1000t_ctl[0] = d
#define BCM89500_A0_G_B1000T_CTLr_GET(r) (r).g_b1000t_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_CTLr_RESERVEDf_GET(r) (((r).g_b1000t_ctl[0]) & 0xff)
#define BCM89500_A0_G_B1000T_CTLr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 8) & 0x1)
#define BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 9) & 0x1)
#define BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_B1000T_CTLr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_CTLr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_CTLr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 13) & 0x7)
#define BCM89500_A0_G_B1000T_CTLr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL.
 *
 */
#define BCM89500_A0_READ_G_B1000T_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_CTLr,(r._g_b1000t_ctl),2)
#define BCM89500_A0_WRITE_G_B1000T_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_CTLr,&(r._g_b1000t_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTLr BCM89500_A0_G_B1000T_CTLr
#define G_B1000T_CTLr_SIZE BCM89500_A0_G_B1000T_CTLr_SIZE
typedef BCM89500_A0_G_B1000T_CTLr_t G_B1000T_CTLr_t;
#define G_B1000T_CTLr_CLR BCM89500_A0_G_B1000T_CTLr_CLR
#define G_B1000T_CTLr_SET BCM89500_A0_G_B1000T_CTLr_SET
#define G_B1000T_CTLr_GET BCM89500_A0_G_B1000T_CTLr_GET
#define G_B1000T_CTLr_RESERVEDf_GET BCM89500_A0_G_B1000T_CTLr_RESERVEDf_GET
#define G_B1000T_CTLr_RESERVEDf_SET BCM89500_A0_G_B1000T_CTLr_RESERVEDf_SET
#define G_B1000T_CTLr_ADV_B1000T_HDf_GET BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET
#define G_B1000T_CTLr_ADV_B1000T_HDf_SET BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET
#define G_B1000T_CTLr_ADV_B1000T_FDf_GET BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET
#define G_B1000T_CTLr_ADV_B1000T_FDf_SET BCM89500_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET
#define G_B1000T_CTLr_REPEATER_DTEf_GET BCM89500_A0_G_B1000T_CTLr_REPEATER_DTEf_GET
#define G_B1000T_CTLr_REPEATER_DTEf_SET BCM89500_A0_G_B1000T_CTLr_REPEATER_DTEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET BCM89500_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTLr_TEST_MODEf_GET BCM89500_A0_G_B1000T_CTLr_TEST_MODEf_GET
#define G_B1000T_CTLr_TEST_MODEf_SET BCM89500_A0_G_B1000T_CTLr_TEST_MODEf_SET
#define READ_G_B1000T_CTLr BCM89500_A0_READ_G_B1000T_CTLr
#define WRITE_G_B1000T_CTLr BCM89500_A0_WRITE_G_B1000T_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_CTL_EXTr 0x00008812

#define BCM89500_A0_G_B1000T_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT.
 *
 */
typedef union BCM89500_A0_G_B1000T_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext[1];
	uint32_t _g_b1000t_ctl_ext;
} BCM89500_A0_G_B1000T_CTL_EXTr_t;

#define BCM89500_A0_G_B1000T_CTL_EXTr_CLR(r) (r).g_b1000t_ctl_ext[0] = 0
#define BCM89500_A0_G_B1000T_CTL_EXTr_SET(r,d) (r).g_b1000t_ctl_ext[0] = d
#define BCM89500_A0_G_B1000T_CTL_EXTr_GET(r) (r).g_b1000t_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_CTL_EXTr_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext[0]) & 0xff)
#define BCM89500_A0_G_B1000T_CTL_EXTr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_CTL_EXTr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 13) & 0x7)
#define BCM89500_A0_G_B1000T_CTL_EXTr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT.
 *
 */
#define BCM89500_A0_READ_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_CTL_EXTr,(r._g_b1000t_ctl_ext),2)
#define BCM89500_A0_WRITE_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_CTL_EXTr,&(r._g_b1000t_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXTr BCM89500_A0_G_B1000T_CTL_EXTr
#define G_B1000T_CTL_EXTr_SIZE BCM89500_A0_G_B1000T_CTL_EXTr_SIZE
typedef BCM89500_A0_G_B1000T_CTL_EXTr_t G_B1000T_CTL_EXTr_t;
#define G_B1000T_CTL_EXTr_CLR BCM89500_A0_G_B1000T_CTL_EXTr_CLR
#define G_B1000T_CTL_EXTr_SET BCM89500_A0_G_B1000T_CTL_EXTr_SET
#define G_B1000T_CTL_EXTr_GET BCM89500_A0_G_B1000T_CTL_EXTr_GET
#define G_B1000T_CTL_EXTr_RESERVEDf_GET BCM89500_A0_G_B1000T_CTL_EXTr_RESERVEDf_GET
#define G_B1000T_CTL_EXTr_RESERVEDf_SET BCM89500_A0_G_B1000T_CTL_EXTr_RESERVEDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET BCM89500_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_GET BCM89500_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_SET BCM89500_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET BCM89500_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXTr_TEST_MODEf_GET BCM89500_A0_G_B1000T_CTL_EXTr_TEST_MODEf_GET
#define G_B1000T_CTL_EXTr_TEST_MODEf_SET BCM89500_A0_G_B1000T_CTL_EXTr_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXTr BCM89500_A0_READ_G_B1000T_CTL_EXTr
#define WRITE_G_B1000T_CTL_EXTr BCM89500_A0_WRITE_G_B1000T_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_CTL_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r 0x00008412

#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_B1000T_CTL_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext_p4[1];
	uint32_t _g_b1000t_ctl_ext_p4;
} BCM89500_A0_G_B1000T_CTL_EXT_P4r_t;

#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_CLR(r) (r).g_b1000t_ctl_ext_p4[0] = 0
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_SET(r,d) (r).g_b1000t_ctl_ext_p4[0] = d
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_GET(r) (r).g_b1000t_ctl_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext_p4[0]) & 0xff)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext_p4[0]) >> 13) & 0x7)
#define BCM89500_A0_G_B1000T_CTL_EXT_P4r_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext_p4[0]=(((r).g_b1000t_ctl_ext_p4[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_B1000T_CTL_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_CTL_EXT_P4r,(r._g_b1000t_ctl_ext_p4),2)
#define BCM89500_A0_WRITE_G_B1000T_CTL_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_CTL_EXT_P4r,&(r._g_b1000t_ctl_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXT_P4r BCM89500_A0_G_B1000T_CTL_EXT_P4r
#define G_B1000T_CTL_EXT_P4r_SIZE BCM89500_A0_G_B1000T_CTL_EXT_P4r_SIZE
typedef BCM89500_A0_G_B1000T_CTL_EXT_P4r_t G_B1000T_CTL_EXT_P4r_t;
#define G_B1000T_CTL_EXT_P4r_CLR BCM89500_A0_G_B1000T_CTL_EXT_P4r_CLR
#define G_B1000T_CTL_EXT_P4r_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_SET
#define G_B1000T_CTL_EXT_P4r_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_GET
#define G_B1000T_CTL_EXT_P4r_RESERVEDf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_RESERVEDf_GET
#define G_B1000T_CTL_EXT_P4r_RESERVEDf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_RESERVEDf_SET
#define G_B1000T_CTL_EXT_P4r_ADV_B1000T_HDf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXT_P4r_ADV_B1000T_HDf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXT_P4r_ADV_B1000T_FDf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXT_P4r_ADV_B1000T_FDf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXT_P4r_REPEATER_DTEf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXT_P4r_REPEATER_DTEf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_VALUEf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_VALUEf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_ENf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_ENf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXT_P4r_TEST_MODEf_GET BCM89500_A0_G_B1000T_CTL_EXT_P4r_TEST_MODEf_GET
#define G_B1000T_CTL_EXT_P4r_TEST_MODEf_SET BCM89500_A0_G_B1000T_CTL_EXT_P4r_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXT_P4r BCM89500_A0_READ_G_B1000T_CTL_EXT_P4r
#define WRITE_G_B1000T_CTL_EXT_P4r BCM89500_A0_WRITE_G_B1000T_CTL_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_CTL_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_CTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r 0x00008512

#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_B1000T_CTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext_p5[1];
	uint32_t _g_b1000t_ctl_ext_p5;
} BCM89500_A0_G_B1000T_CTL_EXT_P5r_t;

#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_CLR(r) (r).g_b1000t_ctl_ext_p5[0] = 0
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_SET(r,d) (r).g_b1000t_ctl_ext_p5[0] = d
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_GET(r) (r).g_b1000t_ctl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext_p5[0]) & 0xff)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 13) & 0x7)
#define BCM89500_A0_G_B1000T_CTL_EXT_P5r_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_B1000T_CTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_CTL_EXT_P5r,(r._g_b1000t_ctl_ext_p5),2)
#define BCM89500_A0_WRITE_G_B1000T_CTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_CTL_EXT_P5r,&(r._g_b1000t_ctl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXT_P5r BCM89500_A0_G_B1000T_CTL_EXT_P5r
#define G_B1000T_CTL_EXT_P5r_SIZE BCM89500_A0_G_B1000T_CTL_EXT_P5r_SIZE
typedef BCM89500_A0_G_B1000T_CTL_EXT_P5r_t G_B1000T_CTL_EXT_P5r_t;
#define G_B1000T_CTL_EXT_P5r_CLR BCM89500_A0_G_B1000T_CTL_EXT_P5r_CLR
#define G_B1000T_CTL_EXT_P5r_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_SET
#define G_B1000T_CTL_EXT_P5r_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_GET
#define G_B1000T_CTL_EXT_P5r_RESERVEDf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_RESERVEDf_GET
#define G_B1000T_CTL_EXT_P5r_RESERVEDf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_RESERVEDf_SET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXT_P5r_TEST_MODEf_GET BCM89500_A0_G_B1000T_CTL_EXT_P5r_TEST_MODEf_GET
#define G_B1000T_CTL_EXT_P5r_TEST_MODEf_SET BCM89500_A0_G_B1000T_CTL_EXT_P5r_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXT_P5r BCM89500_A0_READ_G_B1000T_CTL_EXT_P5r
#define WRITE_G_B1000T_CTL_EXT_P5r BCM89500_A0_WRITE_G_B1000T_CTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_CTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_CTL_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr 0x00008012

#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_B1000T_CTL_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext_pn[1];
	uint32_t _g_b1000t_ctl_ext_pn;
} BCM89500_A0_G_B1000T_CTL_EXT_PNr_t;

#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_CLR(r) (r).g_b1000t_ctl_ext_pn[0] = 0
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_SET(r,d) (r).g_b1000t_ctl_ext_pn[0] = d
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_GET(r) (r).g_b1000t_ctl_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext_pn[0]) & 0xff)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext_pn[0]) >> 13) & 0x7)
#define BCM89500_A0_G_B1000T_CTL_EXT_PNr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext_pn[0]=(((r).g_b1000t_ctl_ext_pn[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_B1000T_CTL_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_B1000T_CTL_EXT_PNr,(r._g_b1000t_ctl_ext_pn),2)
#define BCM89500_A0_WRITE_G_B1000T_CTL_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_B1000T_CTL_EXT_PNr,&(r._g_b1000t_ctl_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXT_PNr BCM89500_A0_G_B1000T_CTL_EXT_PNr
#define G_B1000T_CTL_EXT_PNr_SIZE BCM89500_A0_G_B1000T_CTL_EXT_PNr_SIZE
typedef BCM89500_A0_G_B1000T_CTL_EXT_PNr_t G_B1000T_CTL_EXT_PNr_t;
#define G_B1000T_CTL_EXT_PNr_CLR BCM89500_A0_G_B1000T_CTL_EXT_PNr_CLR
#define G_B1000T_CTL_EXT_PNr_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_SET
#define G_B1000T_CTL_EXT_PNr_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_GET
#define G_B1000T_CTL_EXT_PNr_RESERVEDf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_RESERVEDf_GET
#define G_B1000T_CTL_EXT_PNr_RESERVEDf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_RESERVEDf_SET
#define G_B1000T_CTL_EXT_PNr_ADV_B1000T_HDf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXT_PNr_ADV_B1000T_HDf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXT_PNr_ADV_B1000T_FDf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXT_PNr_ADV_B1000T_FDf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXT_PNr_REPEATER_DTEf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXT_PNr_REPEATER_DTEf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_VALUEf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_VALUEf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_ENf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_ENf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXT_PNr_TEST_MODEf_GET BCM89500_A0_G_B1000T_CTL_EXT_PNr_TEST_MODEf_GET
#define G_B1000T_CTL_EXT_PNr_TEST_MODEf_SET BCM89500_A0_G_B1000T_CTL_EXT_PNr_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXT_PNr BCM89500_A0_READ_G_B1000T_CTL_EXT_PNr
#define WRITE_G_B1000T_CTL_EXT_PNr BCM89500_A0_WRITE_G_B1000T_CTL_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_CTL_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_CTL_P7
 * BLOCKS:   SYS
 * DESC:     1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_CTL_P7r 0x00001712

#define BCM89500_A0_G_B1000T_CTL_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_P7.
 *
 */
typedef union BCM89500_A0_G_B1000T_CTL_P7r_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_p7[1];
	uint32_t _g_b1000t_ctl_p7;
} BCM89500_A0_G_B1000T_CTL_P7r_t;

#define BCM89500_A0_G_B1000T_CTL_P7r_CLR(r) (r).g_b1000t_ctl_p7[0] = 0
#define BCM89500_A0_G_B1000T_CTL_P7r_SET(r,d) (r).g_b1000t_ctl_p7[0] = d
#define BCM89500_A0_G_B1000T_CTL_P7r_GET(r) (r).g_b1000t_ctl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_CTL_P7r_RESERVEDf_GET(r) (((r).g_b1000t_ctl_p7[0]) & 0xff)
#define BCM89500_A0_G_B1000T_CTL_P7r_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_B1000T_CTL_P7r_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_P7r_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_CTL_P7r_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_p7[0]) >> 13) & 0x7)
#define BCM89500_A0_G_B1000T_CTL_P7r_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_p7[0]=(((r).g_b1000t_ctl_p7[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_P7.
 *
 */
#define BCM89500_A0_READ_G_B1000T_CTL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_CTL_P7r,(r._g_b1000t_ctl_p7),2)
#define BCM89500_A0_WRITE_G_B1000T_CTL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_CTL_P7r,&(r._g_b1000t_ctl_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_P7r BCM89500_A0_G_B1000T_CTL_P7r
#define G_B1000T_CTL_P7r_SIZE BCM89500_A0_G_B1000T_CTL_P7r_SIZE
typedef BCM89500_A0_G_B1000T_CTL_P7r_t G_B1000T_CTL_P7r_t;
#define G_B1000T_CTL_P7r_CLR BCM89500_A0_G_B1000T_CTL_P7r_CLR
#define G_B1000T_CTL_P7r_SET BCM89500_A0_G_B1000T_CTL_P7r_SET
#define G_B1000T_CTL_P7r_GET BCM89500_A0_G_B1000T_CTL_P7r_GET
#define G_B1000T_CTL_P7r_RESERVEDf_GET BCM89500_A0_G_B1000T_CTL_P7r_RESERVEDf_GET
#define G_B1000T_CTL_P7r_RESERVEDf_SET BCM89500_A0_G_B1000T_CTL_P7r_RESERVEDf_SET
#define G_B1000T_CTL_P7r_ADV_B1000T_HDf_GET BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_P7r_ADV_B1000T_HDf_SET BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_P7r_ADV_B1000T_FDf_GET BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_P7r_ADV_B1000T_FDf_SET BCM89500_A0_G_B1000T_CTL_P7r_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_P7r_REPEATER_DTEf_GET BCM89500_A0_G_B1000T_CTL_P7r_REPEATER_DTEf_GET
#define G_B1000T_CTL_P7r_REPEATER_DTEf_SET BCM89500_A0_G_B1000T_CTL_P7r_REPEATER_DTEf_SET
#define G_B1000T_CTL_P7r_MAST_SLV_CONG_VALUEf_GET BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_P7r_MAST_SLV_CONG_VALUEf_SET BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_P7r_MAST_SLV_CONG_ENf_GET BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_P7r_MAST_SLV_CONG_ENf_SET BCM89500_A0_G_B1000T_CTL_P7r_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_P7r_TEST_MODEf_GET BCM89500_A0_G_B1000T_CTL_P7r_TEST_MODEf_GET
#define G_B1000T_CTL_P7r_TEST_MODEf_SET BCM89500_A0_G_B1000T_CTL_P7r_TEST_MODEf_SET
#define READ_G_B1000T_CTL_P7r BCM89500_A0_READ_G_B1000T_CTL_P7r
#define WRITE_G_B1000T_CTL_P7r BCM89500_A0_WRITE_G_B1000T_CTL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_CTL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_STS
 * BLOCKS:   SYS
 * DESC:     1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_STSr 0x00001414

#define BCM89500_A0_G_B1000T_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS.
 *
 */
typedef union BCM89500_A0_G_B1000T_STSr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts[1];
	uint32_t _g_b1000t_sts;
} BCM89500_A0_G_B1000T_STSr_t;

#define BCM89500_A0_G_B1000T_STSr_CLR(r) (r).g_b1000t_sts[0] = 0
#define BCM89500_A0_G_B1000T_STSr_SET(r,d) (r).g_b1000t_sts[0] = d
#define BCM89500_A0_G_B1000T_STSr_GET(r) (r).g_b1000t_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts[0]) & 0xff)
#define BCM89500_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_STSr_RESERVEDf_GET(r) ((((r).g_b1000t_sts[0]) >> 8) & 0x3)
#define BCM89500_A0_G_B1000T_STSr_RESERVEDf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS.
 *
 */
#define BCM89500_A0_READ_G_B1000T_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_STSr,(r._g_b1000t_sts),2)
#define BCM89500_A0_WRITE_G_B1000T_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_STSr,&(r._g_b1000t_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STSr BCM89500_A0_G_B1000T_STSr
#define G_B1000T_STSr_SIZE BCM89500_A0_G_B1000T_STSr_SIZE
typedef BCM89500_A0_G_B1000T_STSr_t G_B1000T_STSr_t;
#define G_B1000T_STSr_CLR BCM89500_A0_G_B1000T_STSr_CLR
#define G_B1000T_STSr_SET BCM89500_A0_G_B1000T_STSr_SET
#define G_B1000T_STSr_GET BCM89500_A0_G_B1000T_STSr_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_GET BCM89500_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_SET BCM89500_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET
#define G_B1000T_STSr_RESERVEDf_GET BCM89500_A0_G_B1000T_STSr_RESERVEDf_GET
#define G_B1000T_STSr_RESERVEDf_SET BCM89500_A0_G_B1000T_STSr_RESERVEDf_SET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_GET BCM89500_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_SET BCM89500_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_GET BCM89500_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_SET BCM89500_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STSr_REMOTE_REC_STSf_GET BCM89500_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET
#define G_B1000T_STSr_REMOTE_REC_STSf_SET BCM89500_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET
#define G_B1000T_STSr_LOCAL_REC_STSf_GET BCM89500_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET
#define G_B1000T_STSr_LOCAL_REC_STSf_SET BCM89500_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_GET BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_SET BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET BCM89500_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STSr BCM89500_A0_READ_G_B1000T_STSr
#define WRITE_G_B1000T_STSr BCM89500_A0_WRITE_G_B1000T_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_STS_EXTr 0x00008814

#define BCM89500_A0_G_B1000T_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT.
 *
 */
typedef union BCM89500_A0_G_B1000T_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext[1];
	uint32_t _g_b1000t_sts_ext;
} BCM89500_A0_G_B1000T_STS_EXTr_t;

#define BCM89500_A0_G_B1000T_STS_EXTr_CLR(r) (r).g_b1000t_sts_ext[0] = 0
#define BCM89500_A0_G_B1000T_STS_EXTr_SET(r,d) (r).g_b1000t_sts_ext[0] = d
#define BCM89500_A0_G_B1000T_STS_EXTr_GET(r) (r).g_b1000t_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext[0]) & 0xff)
#define BCM89500_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_STS_EXTr_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 8) & 0x3)
#define BCM89500_A0_G_B1000T_STS_EXTr_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT.
 *
 */
#define BCM89500_A0_READ_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_STS_EXTr,(r._g_b1000t_sts_ext),2)
#define BCM89500_A0_WRITE_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_STS_EXTr,&(r._g_b1000t_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXTr BCM89500_A0_G_B1000T_STS_EXTr
#define G_B1000T_STS_EXTr_SIZE BCM89500_A0_G_B1000T_STS_EXTr_SIZE
typedef BCM89500_A0_G_B1000T_STS_EXTr_t G_B1000T_STS_EXTr_t;
#define G_B1000T_STS_EXTr_CLR BCM89500_A0_G_B1000T_STS_EXTr_CLR
#define G_B1000T_STS_EXTr_SET BCM89500_A0_G_B1000T_STS_EXTr_SET
#define G_B1000T_STS_EXTr_GET BCM89500_A0_G_B1000T_STS_EXTr_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET BCM89500_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET BCM89500_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXTr_RESERVEDf_GET BCM89500_A0_G_B1000T_STS_EXTr_RESERVEDf_GET
#define G_B1000T_STS_EXTr_RESERVEDf_SET BCM89500_A0_G_B1000T_STS_EXTr_RESERVEDf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET BCM89500_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXTr BCM89500_A0_READ_G_B1000T_STS_EXTr
#define WRITE_G_B1000T_STS_EXTr BCM89500_A0_WRITE_G_B1000T_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_STS_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_STS_EXT_P4r 0x00008414

#define BCM89500_A0_G_B1000T_STS_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_B1000T_STS_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext_p4[1];
	uint32_t _g_b1000t_sts_ext_p4;
} BCM89500_A0_G_B1000T_STS_EXT_P4r_t;

#define BCM89500_A0_G_B1000T_STS_EXT_P4r_CLR(r) (r).g_b1000t_sts_ext_p4[0] = 0
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_SET(r,d) (r).g_b1000t_sts_ext_p4[0] = d
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_GET(r) (r).g_b1000t_sts_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext_p4[0]) & 0xff)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 8) & 0x3)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext_p4[0]=(((r).g_b1000t_sts_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_B1000T_STS_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_STS_EXT_P4r,(r._g_b1000t_sts_ext_p4),2)
#define BCM89500_A0_WRITE_G_B1000T_STS_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_STS_EXT_P4r,&(r._g_b1000t_sts_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXT_P4r BCM89500_A0_G_B1000T_STS_EXT_P4r
#define G_B1000T_STS_EXT_P4r_SIZE BCM89500_A0_G_B1000T_STS_EXT_P4r_SIZE
typedef BCM89500_A0_G_B1000T_STS_EXT_P4r_t G_B1000T_STS_EXT_P4r_t;
#define G_B1000T_STS_EXT_P4r_CLR BCM89500_A0_G_B1000T_STS_EXT_P4r_CLR
#define G_B1000T_STS_EXT_P4r_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_SET
#define G_B1000T_STS_EXT_P4r_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_GET
#define G_B1000T_STS_EXT_P4r_IDLE_ERR_CNTf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXT_P4r_IDLE_ERR_CNTf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXT_P4r_RESERVEDf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_RESERVEDf_GET
#define G_B1000T_STS_EXT_P4r_RESERVEDf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_RESERVEDf_SET
#define G_B1000T_STS_EXT_P4r_LP_B1000T_HD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXT_P4r_LP_B1000T_HD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXT_P4r_LP_B1000T_FD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXT_P4r_LP_B1000T_FD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXT_P4r_REMOTE_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXT_P4r_REMOTE_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXT_P4r_LOCAL_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXT_P4r_LOCAL_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_FAULTf_GET BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_FAULTf_SET BCM89500_A0_G_B1000T_STS_EXT_P4r_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXT_P4r BCM89500_A0_READ_G_B1000T_STS_EXT_P4r
#define WRITE_G_B1000T_STS_EXT_P4r BCM89500_A0_WRITE_G_B1000T_STS_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_STS_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_STS_EXT_P5r 0x00008514

#define BCM89500_A0_G_B1000T_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_B1000T_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext_p5[1];
	uint32_t _g_b1000t_sts_ext_p5;
} BCM89500_A0_G_B1000T_STS_EXT_P5r_t;

#define BCM89500_A0_G_B1000T_STS_EXT_P5r_CLR(r) (r).g_b1000t_sts_ext_p5[0] = 0
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_SET(r,d) (r).g_b1000t_sts_ext_p5[0] = d
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_GET(r) (r).g_b1000t_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext_p5[0]) & 0xff)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 8) & 0x3)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_B1000T_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_STS_EXT_P5r,(r._g_b1000t_sts_ext_p5),2)
#define BCM89500_A0_WRITE_G_B1000T_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_STS_EXT_P5r,&(r._g_b1000t_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXT_P5r BCM89500_A0_G_B1000T_STS_EXT_P5r
#define G_B1000T_STS_EXT_P5r_SIZE BCM89500_A0_G_B1000T_STS_EXT_P5r_SIZE
typedef BCM89500_A0_G_B1000T_STS_EXT_P5r_t G_B1000T_STS_EXT_P5r_t;
#define G_B1000T_STS_EXT_P5r_CLR BCM89500_A0_G_B1000T_STS_EXT_P5r_CLR
#define G_B1000T_STS_EXT_P5r_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_SET
#define G_B1000T_STS_EXT_P5r_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_GET
#define G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXT_P5r_RESERVEDf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_RESERVEDf_GET
#define G_B1000T_STS_EXT_P5r_RESERVEDf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_RESERVEDf_SET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_GET BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_SET BCM89500_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXT_P5r BCM89500_A0_READ_G_B1000T_STS_EXT_P5r
#define WRITE_G_B1000T_STS_EXT_P5r BCM89500_A0_WRITE_G_B1000T_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_STS_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_STS_EXT_PNr 0x00008014

#define BCM89500_A0_G_B1000T_STS_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_B1000T_STS_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext_pn[1];
	uint32_t _g_b1000t_sts_ext_pn;
} BCM89500_A0_G_B1000T_STS_EXT_PNr_t;

#define BCM89500_A0_G_B1000T_STS_EXT_PNr_CLR(r) (r).g_b1000t_sts_ext_pn[0] = 0
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_SET(r,d) (r).g_b1000t_sts_ext_pn[0] = d
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_GET(r) (r).g_b1000t_sts_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext_pn[0]) & 0xff)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 8) & 0x3)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext_pn[0]=(((r).g_b1000t_sts_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_B1000T_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_B1000T_STS_EXT_PNr,(r._g_b1000t_sts_ext_pn),2)
#define BCM89500_A0_WRITE_G_B1000T_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_B1000T_STS_EXT_PNr,&(r._g_b1000t_sts_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXT_PNr BCM89500_A0_G_B1000T_STS_EXT_PNr
#define G_B1000T_STS_EXT_PNr_SIZE BCM89500_A0_G_B1000T_STS_EXT_PNr_SIZE
typedef BCM89500_A0_G_B1000T_STS_EXT_PNr_t G_B1000T_STS_EXT_PNr_t;
#define G_B1000T_STS_EXT_PNr_CLR BCM89500_A0_G_B1000T_STS_EXT_PNr_CLR
#define G_B1000T_STS_EXT_PNr_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_SET
#define G_B1000T_STS_EXT_PNr_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_GET
#define G_B1000T_STS_EXT_PNr_IDLE_ERR_CNTf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXT_PNr_IDLE_ERR_CNTf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXT_PNr_RESERVEDf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_RESERVEDf_GET
#define G_B1000T_STS_EXT_PNr_RESERVEDf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_RESERVEDf_SET
#define G_B1000T_STS_EXT_PNr_LP_B1000T_HD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXT_PNr_LP_B1000T_HD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXT_PNr_LP_B1000T_FD_CAPf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXT_PNr_LP_B1000T_FD_CAPf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXT_PNr_REMOTE_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXT_PNr_REMOTE_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXT_PNr_LOCAL_REC_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXT_PNr_LOCAL_REC_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_STSf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_STSf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_FAULTf_GET BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_FAULTf_SET BCM89500_A0_G_B1000T_STS_EXT_PNr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXT_PNr BCM89500_A0_READ_G_B1000T_STS_EXT_PNr
#define WRITE_G_B1000T_STS_EXT_PNr BCM89500_A0_WRITE_G_B1000T_STS_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_STS_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_B1000T_STS_P7
 * BLOCKS:   SYS
 * DESC:     1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM89500_A0_G_B1000T_STS_P7r 0x00001714

#define BCM89500_A0_G_B1000T_STS_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_P7.
 *
 */
typedef union BCM89500_A0_G_B1000T_STS_P7r_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_p7[1];
	uint32_t _g_b1000t_sts_p7;
} BCM89500_A0_G_B1000T_STS_P7r_t;

#define BCM89500_A0_G_B1000T_STS_P7r_CLR(r) (r).g_b1000t_sts_p7[0] = 0
#define BCM89500_A0_G_B1000T_STS_P7r_SET(r,d) (r).g_b1000t_sts_p7[0] = d
#define BCM89500_A0_G_B1000T_STS_P7r_GET(r) (r).g_b1000t_sts_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_B1000T_STS_P7r_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_p7[0]) & 0xff)
#define BCM89500_A0_G_B1000T_STS_P7r_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_B1000T_STS_P7r_RESERVEDf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 8) & 0x3)
#define BCM89500_A0_G_B1000T_STS_P7r_RESERVEDf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_B1000T_STS_P7r_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_B1000T_STS_P7r_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_B1000T_STS_P7r_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_B1000T_STS_P7r_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_p7[0]=(((r).g_b1000t_sts_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_P7.
 *
 */
#define BCM89500_A0_READ_G_B1000T_STS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_B1000T_STS_P7r,(r._g_b1000t_sts_p7),2)
#define BCM89500_A0_WRITE_G_B1000T_STS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_B1000T_STS_P7r,&(r._g_b1000t_sts_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_P7r BCM89500_A0_G_B1000T_STS_P7r
#define G_B1000T_STS_P7r_SIZE BCM89500_A0_G_B1000T_STS_P7r_SIZE
typedef BCM89500_A0_G_B1000T_STS_P7r_t G_B1000T_STS_P7r_t;
#define G_B1000T_STS_P7r_CLR BCM89500_A0_G_B1000T_STS_P7r_CLR
#define G_B1000T_STS_P7r_SET BCM89500_A0_G_B1000T_STS_P7r_SET
#define G_B1000T_STS_P7r_GET BCM89500_A0_G_B1000T_STS_P7r_GET
#define G_B1000T_STS_P7r_IDLE_ERR_CNTf_GET BCM89500_A0_G_B1000T_STS_P7r_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_P7r_IDLE_ERR_CNTf_SET BCM89500_A0_G_B1000T_STS_P7r_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_P7r_RESERVEDf_GET BCM89500_A0_G_B1000T_STS_P7r_RESERVEDf_GET
#define G_B1000T_STS_P7r_RESERVEDf_SET BCM89500_A0_G_B1000T_STS_P7r_RESERVEDf_SET
#define G_B1000T_STS_P7r_LP_B1000T_HD_CAPf_GET BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_P7r_LP_B1000T_HD_CAPf_SET BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_P7r_LP_B1000T_FD_CAPf_GET BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_P7r_LP_B1000T_FD_CAPf_SET BCM89500_A0_G_B1000T_STS_P7r_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_P7r_REMOTE_REC_STSf_GET BCM89500_A0_G_B1000T_STS_P7r_REMOTE_REC_STSf_GET
#define G_B1000T_STS_P7r_REMOTE_REC_STSf_SET BCM89500_A0_G_B1000T_STS_P7r_REMOTE_REC_STSf_SET
#define G_B1000T_STS_P7r_LOCAL_REC_STSf_GET BCM89500_A0_G_B1000T_STS_P7r_LOCAL_REC_STSf_GET
#define G_B1000T_STS_P7r_LOCAL_REC_STSf_SET BCM89500_A0_G_B1000T_STS_P7r_LOCAL_REC_STSf_SET
#define G_B1000T_STS_P7r_MAST_SLV_CONG_STSf_GET BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_P7r_MAST_SLV_CONG_STSf_SET BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_P7r_MAST_SLV_CONG_FAULTf_GET BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_P7r_MAST_SLV_CONG_FAULTf_SET BCM89500_A0_G_B1000T_STS_P7r_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_P7r BCM89500_A0_READ_G_B1000T_STS_P7r
#define WRITE_G_B1000T_STS_P7r BCM89500_A0_WRITE_G_B1000T_STS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_B1000T_STS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr 0x0000882e

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext[1];
	uint32_t _g_dsp_coefficient_addr_ext;
} BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR(r) (r).g_dsp_coefficient_addr_ext[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET(r,d) (r).g_dsp_coefficient_addr_ext[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET(r) (r).g_dsp_coefficient_addr_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext[0]) & 0xff)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 8) & 0xf)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 13) & 0x3)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr,(r._g_dsp_coefficient_addr_ext),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr,&(r._g_dsp_coefficient_addr_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXTr BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr
#define G_DSP_COEFFICIENT_ADDR_EXTr_SIZE BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t G_DSP_COEFFICIENT_ADDR_EXTr_t;
#define G_DSP_COEFFICIENT_ADDR_EXTr_CLR BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR
#define G_DSP_COEFFICIENT_ADDR_EXTr_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXTr BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXTr BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r 0x0000842e

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext_p4[1];
	uint32_t _g_dsp_coefficient_addr_ext_p4;
} BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_CLR(r) (r).g_dsp_coefficient_addr_ext_p4[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_SET(r,d) (r).g_dsp_coefficient_addr_ext_p4[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_GET(r) (r).g_dsp_coefficient_addr_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext_p4[0]) & 0xff)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p4[0]=(((r).g_dsp_coefficient_addr_ext_p4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p4[0]) >> 8) & 0xf)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p4[0]=(((r).g_dsp_coefficient_addr_ext_p4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p4[0]=(((r).g_dsp_coefficient_addr_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p4[0]) >> 13) & 0x3)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p4[0]=(((r).g_dsp_coefficient_addr_ext_p4[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p4[0]=(((r).g_dsp_coefficient_addr_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r,(r._g_dsp_coefficient_addr_ext_p4),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r,&(r._g_dsp_coefficient_addr_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXT_P4r BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_SIZE BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_t G_DSP_COEFFICIENT_ADDR_EXT_P4r_t;
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_CLR BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_CLR
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_TAP_NUMf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_TAP_NUMf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_FILTER_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_FILTER_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_FILTER_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_FILTER_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_CHANNEL_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_CHANNEL_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_CHANNEL_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_CHANNEL_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXT_P4r BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P4r
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P4r BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r 0x0000852e

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext_p5[1];
	uint32_t _g_dsp_coefficient_addr_ext_p5;
} BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CLR(r) (r).g_dsp_coefficient_addr_ext_p5[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SET(r,d) (r).g_dsp_coefficient_addr_ext_p5[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_GET(r) (r).g_dsp_coefficient_addr_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext_p5[0]) & 0xff)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 8) & 0xf)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 13) & 0x3)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r,(r._g_dsp_coefficient_addr_ext_p5),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r,&(r._g_dsp_coefficient_addr_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXT_P5r BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_SIZE BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_t G_DSP_COEFFICIENT_ADDR_EXT_P5r_t;
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_CLR BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CLR
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXT_P5r BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P5r
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P5r BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr 0x0000802e

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext_pn[1];
	uint32_t _g_dsp_coefficient_addr_ext_pn;
} BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_CLR(r) (r).g_dsp_coefficient_addr_ext_pn[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_SET(r,d) (r).g_dsp_coefficient_addr_ext_pn[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_GET(r) (r).g_dsp_coefficient_addr_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext_pn[0]) & 0xff)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext_pn[0]=(((r).g_dsp_coefficient_addr_ext_pn[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_pn[0]) >> 8) & 0xf)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_pn[0]=(((r).g_dsp_coefficient_addr_ext_pn[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_pn[0]=(((r).g_dsp_coefficient_addr_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_pn[0]) >> 13) & 0x3)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_pn[0]=(((r).g_dsp_coefficient_addr_ext_pn[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_pn[0]=(((r).g_dsp_coefficient_addr_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr,(r._g_dsp_coefficient_addr_ext_pn),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr,&(r._g_dsp_coefficient_addr_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXT_PNr BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_SIZE BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_t G_DSP_COEFFICIENT_ADDR_EXT_PNr_t;
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_CLR BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_CLR
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_TAP_NUMf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_TAP_NUMf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_FILTER_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_FILTER_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_FILTER_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_FILTER_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_CHANNEL_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_CHANNEL_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_CHANNEL_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_CHANNEL_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXT_PNr BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_PNr
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXT_PNr BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_ADDR_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_P7
 * BLOCKS:   SYS
 * DESC:     DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r 0x0000172e

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_P7.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_p7[1];
	uint32_t _g_dsp_coefficient_addr_p7;
} BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_CLR(r) (r).g_dsp_coefficient_addr_p7[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_SET(r,d) (r).g_dsp_coefficient_addr_p7[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_GET(r) (r).g_dsp_coefficient_addr_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_p7[0]) & 0xff)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_p7[0]=(((r).g_dsp_coefficient_addr_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_p7[0]) >> 8) & 0xf)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_p7[0]=(((r).g_dsp_coefficient_addr_p7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_p7[0]=(((r).g_dsp_coefficient_addr_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_p7[0]) >> 13) & 0x3)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_p7[0]=(((r).g_dsp_coefficient_addr_p7[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_p7[0]=(((r).g_dsp_coefficient_addr_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_P7.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r,(r._g_dsp_coefficient_addr_p7),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r,&(r._g_dsp_coefficient_addr_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_P7r BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r
#define G_DSP_COEFFICIENT_ADDR_P7r_SIZE BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_t G_DSP_COEFFICIENT_ADDR_P7r_t;
#define G_DSP_COEFFICIENT_ADDR_P7r_CLR BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_CLR
#define G_DSP_COEFFICIENT_ADDR_P7r_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_SET
#define G_DSP_COEFFICIENT_ADDR_P7r_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_GET
#define G_DSP_COEFFICIENT_ADDR_P7r_TAP_NUMf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_P7r_TAP_NUMf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_P7r_FILTER_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_P7r_FILTER_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_P7r_ALL_FILTER_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_P7r_ALL_FILTER_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_P7r_CHANNEL_SELf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_P7r_CHANNEL_SELf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_P7r_ALL_CHANNEL_CTLf_GET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_P7r_ALL_CHANNEL_CTLf_SET BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_P7r BCM89500_A0_READ_G_DSP_COEFFICIENT_ADDR_P7r
#define WRITE_G_DSP_COEFFICIENT_ADDR_P7r BCM89500_A0_WRITE_G_DSP_COEFFICIENT_ADDR_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_ADDR_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr 0x0000882a

#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext[1];
	uint32_t _g_dsp_coefficient_ext;
} BCM89500_A0_G_DSP_COEFFICIENT_EXTr_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr_CLR(r) (r).g_dsp_coefficient_ext[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr_SET(r,d) (r).g_dsp_coefficient_ext[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr_GET(r) (r).g_dsp_coefficient_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext[0]) & 0xffff)
#define BCM89500_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext[0]=(((r).g_dsp_coefficient_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_EXTr,(r._g_dsp_coefficient_ext),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_EXTr,&(r._g_dsp_coefficient_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXTr BCM89500_A0_G_DSP_COEFFICIENT_EXTr
#define G_DSP_COEFFICIENT_EXTr_SIZE BCM89500_A0_G_DSP_COEFFICIENT_EXTr_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_EXTr_t G_DSP_COEFFICIENT_EXTr_t;
#define G_DSP_COEFFICIENT_EXTr_CLR BCM89500_A0_G_DSP_COEFFICIENT_EXTr_CLR
#define G_DSP_COEFFICIENT_EXTr_SET BCM89500_A0_G_DSP_COEFFICIENT_EXTr_SET
#define G_DSP_COEFFICIENT_EXTr_GET BCM89500_A0_G_DSP_COEFFICIENT_EXTr_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET BCM89500_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET BCM89500_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXTr BCM89500_A0_READ_G_DSP_COEFFICIENT_EXTr
#define WRITE_G_DSP_COEFFICIENT_EXTr BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r 0x0000842a

#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext_p4[1];
	uint32_t _g_dsp_coefficient_ext_p4;
} BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_CLR(r) (r).g_dsp_coefficient_ext_p4[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_SET(r,d) (r).g_dsp_coefficient_ext_p4[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_GET(r) (r).g_dsp_coefficient_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext_p4[0]=(((r).g_dsp_coefficient_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r,(r._g_dsp_coefficient_ext_p4),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r,&(r._g_dsp_coefficient_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXT_P4r BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r
#define G_DSP_COEFFICIENT_EXT_P4r_SIZE BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_t G_DSP_COEFFICIENT_EXT_P4r_t;
#define G_DSP_COEFFICIENT_EXT_P4r_CLR BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_CLR
#define G_DSP_COEFFICIENT_EXT_P4r_SET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_SET
#define G_DSP_COEFFICIENT_EXT_P4r_GET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_GET
#define G_DSP_COEFFICIENT_EXT_P4r_DSP_COEFFICIENTf_GET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXT_P4r_DSP_COEFFICIENTf_SET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXT_P4r BCM89500_A0_READ_G_DSP_COEFFICIENT_EXT_P4r
#define WRITE_G_DSP_COEFFICIENT_EXT_P4r BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r 0x0000852a

#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext_p5[1];
	uint32_t _g_dsp_coefficient_ext_p5;
} BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_CLR(r) (r).g_dsp_coefficient_ext_p5[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_SET(r,d) (r).g_dsp_coefficient_ext_p5[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_GET(r) (r).g_dsp_coefficient_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext_p5[0]=(((r).g_dsp_coefficient_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r,(r._g_dsp_coefficient_ext_p5),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r,&(r._g_dsp_coefficient_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXT_P5r BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r
#define G_DSP_COEFFICIENT_EXT_P5r_SIZE BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_t G_DSP_COEFFICIENT_EXT_P5r_t;
#define G_DSP_COEFFICIENT_EXT_P5r_CLR BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_CLR
#define G_DSP_COEFFICIENT_EXT_P5r_SET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_SET
#define G_DSP_COEFFICIENT_EXT_P5r_GET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_GET
#define G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_GET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_SET BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXT_P5r BCM89500_A0_READ_G_DSP_COEFFICIENT_EXT_P5r
#define WRITE_G_DSP_COEFFICIENT_EXT_P5r BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr 0x0000802a

#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext_pn[1];
	uint32_t _g_dsp_coefficient_ext_pn;
} BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_CLR(r) (r).g_dsp_coefficient_ext_pn[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_SET(r,d) (r).g_dsp_coefficient_ext_pn[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_GET(r) (r).g_dsp_coefficient_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext_pn[0]=(((r).g_dsp_coefficient_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr,(r._g_dsp_coefficient_ext_pn),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr,&(r._g_dsp_coefficient_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXT_PNr BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr
#define G_DSP_COEFFICIENT_EXT_PNr_SIZE BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_t G_DSP_COEFFICIENT_EXT_PNr_t;
#define G_DSP_COEFFICIENT_EXT_PNr_CLR BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_CLR
#define G_DSP_COEFFICIENT_EXT_PNr_SET BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_SET
#define G_DSP_COEFFICIENT_EXT_PNr_GET BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_GET
#define G_DSP_COEFFICIENT_EXT_PNr_DSP_COEFFICIENTf_GET BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXT_PNr_DSP_COEFFICIENTf_SET BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXT_PNr BCM89500_A0_READ_G_DSP_COEFFICIENT_EXT_PNr
#define WRITE_G_DSP_COEFFICIENT_EXT_PNr BCM89500_A0_WRITE_G_DSP_COEFFICIENT_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_DSP_COEFFICIENT_P7
 * BLOCKS:   SYS
 * DESC:     DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM89500_A0_G_DSP_COEFFICIENT_P7r 0x0000172a

#define BCM89500_A0_G_DSP_COEFFICIENT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_P7.
 *
 */
typedef union BCM89500_A0_G_DSP_COEFFICIENT_P7r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_p7[1];
	uint32_t _g_dsp_coefficient_p7;
} BCM89500_A0_G_DSP_COEFFICIENT_P7r_t;

#define BCM89500_A0_G_DSP_COEFFICIENT_P7r_CLR(r) (r).g_dsp_coefficient_p7[0] = 0
#define BCM89500_A0_G_DSP_COEFFICIENT_P7r_SET(r,d) (r).g_dsp_coefficient_p7[0] = d
#define BCM89500_A0_G_DSP_COEFFICIENT_P7r_GET(r) (r).g_dsp_coefficient_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_DSP_COEFFICIENT_P7r_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_p7[0]) & 0xffff)
#define BCM89500_A0_G_DSP_COEFFICIENT_P7r_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_p7[0]=(((r).g_dsp_coefficient_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_P7.
 *
 */
#define BCM89500_A0_READ_G_DSP_COEFFICIENT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_DSP_COEFFICIENT_P7r,(r._g_dsp_coefficient_p7),2)
#define BCM89500_A0_WRITE_G_DSP_COEFFICIENT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_DSP_COEFFICIENT_P7r,&(r._g_dsp_coefficient_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_P7r BCM89500_A0_G_DSP_COEFFICIENT_P7r
#define G_DSP_COEFFICIENT_P7r_SIZE BCM89500_A0_G_DSP_COEFFICIENT_P7r_SIZE
typedef BCM89500_A0_G_DSP_COEFFICIENT_P7r_t G_DSP_COEFFICIENT_P7r_t;
#define G_DSP_COEFFICIENT_P7r_CLR BCM89500_A0_G_DSP_COEFFICIENT_P7r_CLR
#define G_DSP_COEFFICIENT_P7r_SET BCM89500_A0_G_DSP_COEFFICIENT_P7r_SET
#define G_DSP_COEFFICIENT_P7r_GET BCM89500_A0_G_DSP_COEFFICIENT_P7r_GET
#define G_DSP_COEFFICIENT_P7r_DSP_COEFFICIENTf_GET BCM89500_A0_G_DSP_COEFFICIENT_P7r_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_P7r_DSP_COEFFICIENTf_SET BCM89500_A0_G_DSP_COEFFICIENT_P7r_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_P7r BCM89500_A0_READ_G_DSP_COEFFICIENT_P7r
#define WRITE_G_DSP_COEFFICIENT_P7r BCM89500_A0_WRITE_G_DSP_COEFFICIENT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_DSP_COEFFICIENT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXP_ACCESS
 * BLOCKS:   SYS
 * DESC:     Expansion Access Register
 * SIZE:     16
 * FIELDS:
 *     EXP_ADDR         Sets the Expansion register number accessed when read/write register 0x2a.8'h00 : to access transmit packet counter8'h08 : to access 10BT control8'h70 : to access soft-reset8'h90-92 : to access BroadReach LRE misc control8'h9a : to access BroadReach LRE Register control (Not2Release)8'hf5 : to access time sync control and status
 *     EXP_SEL          Write 0xf to access Expansion registers.
 *     RESERVED         Write as 0, ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXP_ACCESSr 0x0000142e

#define BCM89500_A0_G_EXP_ACCESSr_SIZE 2

/*
 * This structure should be used to declare and program G_EXP_ACCESS.
 *
 */
typedef union BCM89500_A0_G_EXP_ACCESSr_s {
	uint32_t v[1];
	uint32_t g_exp_access[1];
	uint32_t _g_exp_access;
} BCM89500_A0_G_EXP_ACCESSr_t;

#define BCM89500_A0_G_EXP_ACCESSr_CLR(r) (r).g_exp_access[0] = 0
#define BCM89500_A0_G_EXP_ACCESSr_SET(r,d) (r).g_exp_access[0] = d
#define BCM89500_A0_G_EXP_ACCESSr_GET(r) (r).g_exp_access[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXP_ACCESSr_EXP_ADDRf_GET(r) (((r).g_exp_access[0]) & 0xff)
#define BCM89500_A0_G_EXP_ACCESSr_EXP_ADDRf_SET(r,f) (r).g_exp_access[0]=(((r).g_exp_access[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_EXP_ACCESSr_EXP_SELf_GET(r) ((((r).g_exp_access[0]) >> 8) & 0xf)
#define BCM89500_A0_G_EXP_ACCESSr_EXP_SELf_SET(r,f) (r).g_exp_access[0]=(((r).g_exp_access[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_EXP_ACCESSr_RESERVEDf_GET(r) ((((r).g_exp_access[0]) >> 12) & 0xf)
#define BCM89500_A0_G_EXP_ACCESSr_RESERVEDf_SET(r,f) (r).g_exp_access[0]=(((r).g_exp_access[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access G_EXP_ACCESS.
 *
 */
#define BCM89500_A0_READ_G_EXP_ACCESSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXP_ACCESSr,(r._g_exp_access),2)
#define BCM89500_A0_WRITE_G_EXP_ACCESSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXP_ACCESSr,&(r._g_exp_access),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXP_ACCESSr BCM89500_A0_G_EXP_ACCESSr
#define G_EXP_ACCESSr_SIZE BCM89500_A0_G_EXP_ACCESSr_SIZE
typedef BCM89500_A0_G_EXP_ACCESSr_t G_EXP_ACCESSr_t;
#define G_EXP_ACCESSr_CLR BCM89500_A0_G_EXP_ACCESSr_CLR
#define G_EXP_ACCESSr_SET BCM89500_A0_G_EXP_ACCESSr_SET
#define G_EXP_ACCESSr_GET BCM89500_A0_G_EXP_ACCESSr_GET
#define G_EXP_ACCESSr_EXP_ADDRf_GET BCM89500_A0_G_EXP_ACCESSr_EXP_ADDRf_GET
#define G_EXP_ACCESSr_EXP_ADDRf_SET BCM89500_A0_G_EXP_ACCESSr_EXP_ADDRf_SET
#define G_EXP_ACCESSr_EXP_SELf_GET BCM89500_A0_G_EXP_ACCESSr_EXP_SELf_GET
#define G_EXP_ACCESSr_EXP_SELf_SET BCM89500_A0_G_EXP_ACCESSr_EXP_SELf_SET
#define G_EXP_ACCESSr_RESERVEDf_GET BCM89500_A0_G_EXP_ACCESSr_RESERVEDf_GET
#define G_EXP_ACCESSr_RESERVEDf_SET BCM89500_A0_G_EXP_ACCESSr_RESERVEDf_SET
#define READ_G_EXP_ACCESSr BCM89500_A0_READ_G_EXP_ACCESSr
#define WRITE_G_EXP_ACCESSr BCM89500_A0_WRITE_G_EXP_ACCESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXP_ACCESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXP_DATA
 * BLOCKS:   SYS
 * DESC:     Expansion Read/Write Register
 * SIZE:     16
 * FIELDS:
 *     EXP_DATA         Expansion register read/write data selected by 0x2e, bit7-0.transmit packet counter (0x2e, bit7-0=8'h00):bit 15- 0 : Returns the number of packets transmitted/received depending on the value of reg 0x30-7.11.  Freezes at FFFFh. Cleared by read.soft-reset (0x2e, bit7-0=8'h70):bit 15-1 : reservedbit 0 : soft-resetBroadReach LRE Misc Control (0x2e, bit7-0=8'h90):bit 15 : Enable digital high pass filter. (valid when Exp_Reg91[15] is enabled)bit 14-2 : reservedbit 1 : force BroadReach transceiver link up.bit 0 : capable of BroadReach functionBroadReach LRE Misc Control (0x2e, bit7-0=8'h91):bit 15 : Overwrite the decision of enabling of digital HPF through Exp_Reg90[15]bit 14-12 : reservedbit 11-9 : BroadReach PGA gain controlbit 8-4 : reserved (must write value 5'b00010).bit 3-0 : reserved (must write value 4'b1000).BroadReach LRE Misc Control (0x2e, bit7-0=8'h92):bit 15-13 : reservedbit 12-11 : Shape BR transmitter's waveform.bit 10-6 : reservedbit 5 : reserved (must write value 1).bit 4-0 : reservedBroadReach LRE Register Control (0x2e, bit7-0=8'h9a):(Not2Release)bit 15 : enable LRE register access overridebit 14 : LRE register override value (1=force access to IEEE register, 0=force access to BR LRE registers)bit 13 : LRE register status (1=BR LRE registers are accessable, 0=IEEE registers are accessable)bit 12-0 : reservedTime Sync (0x2e, bit7-0=8'hf5):bit 15-7 : reservedbit 6 : tx sop error statusbit 5 : Use txen as tx sop (1=use txen as tx sop, 0=use SFD as tx sop)bit 4 : rx sop error statusbit 3 : rx sop assertion option (1=assert rx sop is SFD is not detected but 16 bytes data have been received, 0=no rx sop if SFD in nit detected within the first 16 bytes)bit 2 : use rxdv as rx sop. (1=use rxdv as rx sop, 0=use SFD as rx sop)bit 1 : recovery clock selectbit 0 : time sync enable
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXP_DATAr 0x0000142a

#define BCM89500_A0_G_EXP_DATAr_SIZE 2

/*
 * This structure should be used to declare and program G_EXP_DATA.
 *
 */
typedef union BCM89500_A0_G_EXP_DATAr_s {
	uint32_t v[1];
	uint32_t g_exp_data[1];
	uint32_t _g_exp_data;
} BCM89500_A0_G_EXP_DATAr_t;

#define BCM89500_A0_G_EXP_DATAr_CLR(r) (r).g_exp_data[0] = 0
#define BCM89500_A0_G_EXP_DATAr_SET(r,d) (r).g_exp_data[0] = d
#define BCM89500_A0_G_EXP_DATAr_GET(r) (r).g_exp_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXP_DATAr_EXP_DATAf_GET(r) (((r).g_exp_data[0]) & 0xffff)
#define BCM89500_A0_G_EXP_DATAr_EXP_DATAf_SET(r,f) (r).g_exp_data[0]=(((r).g_exp_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_EXP_DATA.
 *
 */
#define BCM89500_A0_READ_G_EXP_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXP_DATAr,(r._g_exp_data),2)
#define BCM89500_A0_WRITE_G_EXP_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXP_DATAr,&(r._g_exp_data),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXP_DATAr BCM89500_A0_G_EXP_DATAr
#define G_EXP_DATAr_SIZE BCM89500_A0_G_EXP_DATAr_SIZE
typedef BCM89500_A0_G_EXP_DATAr_t G_EXP_DATAr_t;
#define G_EXP_DATAr_CLR BCM89500_A0_G_EXP_DATAr_CLR
#define G_EXP_DATAr_SET BCM89500_A0_G_EXP_DATAr_SET
#define G_EXP_DATAr_GET BCM89500_A0_G_EXP_DATAr_GET
#define G_EXP_DATAr_EXP_DATAf_GET BCM89500_A0_G_EXP_DATAr_EXP_DATAf_GET
#define G_EXP_DATAr_EXP_DATAf_SET BCM89500_A0_G_EXP_DATAr_EXP_DATAf_SET
#define READ_G_EXP_DATAr BCM89500_A0_READ_G_EXP_DATAr
#define WRITE_G_EXP_DATAr BCM89500_A0_WRITE_G_EXP_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXP_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXT_STS
 * BLOCKS:   SYS
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXT_STSr 0x0000141e

#define BCM89500_A0_G_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS.
 *
 */
typedef union BCM89500_A0_G_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_ext_sts[1];
	uint32_t _g_ext_sts;
} BCM89500_A0_G_EXT_STSr_t;

#define BCM89500_A0_G_EXT_STSr_CLR(r) (r).g_ext_sts[0] = 0
#define BCM89500_A0_G_EXT_STSr_SET(r,d) (r).g_ext_sts[0] = d
#define BCM89500_A0_G_EXT_STSr_GET(r) (r).g_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXT_STSr_RESERVEDf_GET(r) (((r).g_ext_sts[0]) & 0xfff)
#define BCM89500_A0_G_EXT_STSr_RESERVEDf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_G_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_G_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_G_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_G_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_G_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS.
 *
 */
#define BCM89500_A0_READ_G_EXT_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXT_STSr,(r._g_ext_sts),2)
#define BCM89500_A0_WRITE_G_EXT_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXT_STSr,&(r._g_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STSr BCM89500_A0_G_EXT_STSr
#define G_EXT_STSr_SIZE BCM89500_A0_G_EXT_STSr_SIZE
typedef BCM89500_A0_G_EXT_STSr_t G_EXT_STSr_t;
#define G_EXT_STSr_CLR BCM89500_A0_G_EXT_STSr_CLR
#define G_EXT_STSr_SET BCM89500_A0_G_EXT_STSr_SET
#define G_EXT_STSr_GET BCM89500_A0_G_EXT_STSr_GET
#define G_EXT_STSr_RESERVEDf_GET BCM89500_A0_G_EXT_STSr_RESERVEDf_GET
#define G_EXT_STSr_RESERVEDf_SET BCM89500_A0_G_EXT_STSr_RESERVEDf_SET
#define G_EXT_STSr_B1000T_HD_CAPf_GET BCM89500_A0_G_EXT_STSr_B1000T_HD_CAPf_GET
#define G_EXT_STSr_B1000T_HD_CAPf_SET BCM89500_A0_G_EXT_STSr_B1000T_HD_CAPf_SET
#define G_EXT_STSr_B1000T_FD_CAPf_GET BCM89500_A0_G_EXT_STSr_B1000T_FD_CAPf_GET
#define G_EXT_STSr_B1000T_FD_CAPf_SET BCM89500_A0_G_EXT_STSr_B1000T_FD_CAPf_SET
#define G_EXT_STSr_B1000X_HD_CAPf_GET BCM89500_A0_G_EXT_STSr_B1000X_HD_CAPf_GET
#define G_EXT_STSr_B1000X_HD_CAPf_SET BCM89500_A0_G_EXT_STSr_B1000X_HD_CAPf_SET
#define G_EXT_STSr_B1000X_FD_CAPf_GET BCM89500_A0_G_EXT_STSr_B1000X_FD_CAPf_GET
#define G_EXT_STSr_B1000X_FD_CAPf_SET BCM89500_A0_G_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STSr BCM89500_A0_READ_G_EXT_STSr
#define WRITE_G_EXT_STSr BCM89500_A0_WRITE_G_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXT_STS_EXTr 0x0000881e

#define BCM89500_A0_G_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT.
 *
 */
typedef union BCM89500_A0_G_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext[1];
	uint32_t _g_ext_sts_ext;
} BCM89500_A0_G_EXT_STS_EXTr_t;

#define BCM89500_A0_G_EXT_STS_EXTr_CLR(r) (r).g_ext_sts_ext[0] = 0
#define BCM89500_A0_G_EXT_STS_EXTr_SET(r,d) (r).g_ext_sts_ext[0] = d
#define BCM89500_A0_G_EXT_STS_EXTr_GET(r) (r).g_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXT_STS_EXTr_RESERVEDf_GET(r) (((r).g_ext_sts_ext[0]) & 0xfff)
#define BCM89500_A0_G_EXT_STS_EXTr_RESERVEDf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT.
 *
 */
#define BCM89500_A0_READ_G_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXT_STS_EXTr,(r._g_ext_sts_ext),2)
#define BCM89500_A0_WRITE_G_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXT_STS_EXTr,&(r._g_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXTr BCM89500_A0_G_EXT_STS_EXTr
#define G_EXT_STS_EXTr_SIZE BCM89500_A0_G_EXT_STS_EXTr_SIZE
typedef BCM89500_A0_G_EXT_STS_EXTr_t G_EXT_STS_EXTr_t;
#define G_EXT_STS_EXTr_CLR BCM89500_A0_G_EXT_STS_EXTr_CLR
#define G_EXT_STS_EXTr_SET BCM89500_A0_G_EXT_STS_EXTr_SET
#define G_EXT_STS_EXTr_GET BCM89500_A0_G_EXT_STS_EXTr_GET
#define G_EXT_STS_EXTr_RESERVEDf_GET BCM89500_A0_G_EXT_STS_EXTr_RESERVEDf_GET
#define G_EXT_STS_EXTr_RESERVEDf_SET BCM89500_A0_G_EXT_STS_EXTr_RESERVEDf_SET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXTr BCM89500_A0_READ_G_EXT_STS_EXTr
#define WRITE_G_EXT_STS_EXTr BCM89500_A0_WRITE_G_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXT_STS_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXT_STS_EXT_P4r 0x0000841e

#define BCM89500_A0_G_EXT_STS_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_EXT_STS_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext_p4[1];
	uint32_t _g_ext_sts_ext_p4;
} BCM89500_A0_G_EXT_STS_EXT_P4r_t;

#define BCM89500_A0_G_EXT_STS_EXT_P4r_CLR(r) (r).g_ext_sts_ext_p4[0] = 0
#define BCM89500_A0_G_EXT_STS_EXT_P4r_SET(r,d) (r).g_ext_sts_ext_p4[0] = d
#define BCM89500_A0_G_EXT_STS_EXT_P4r_GET(r) (r).g_ext_sts_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXT_STS_EXT_P4r_RESERVEDf_GET(r) (((r).g_ext_sts_ext_p4[0]) & 0xfff)
#define BCM89500_A0_G_EXT_STS_EXT_P4r_RESERVEDf_SET(r,f) (r).g_ext_sts_ext_p4[0]=(((r).g_ext_sts_ext_p4[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p4[0]=(((r).g_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p4[0]=(((r).g_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p4[0]=(((r).g_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p4[0]=(((r).g_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_EXT_STS_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXT_STS_EXT_P4r,(r._g_ext_sts_ext_p4),2)
#define BCM89500_A0_WRITE_G_EXT_STS_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXT_STS_EXT_P4r,&(r._g_ext_sts_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXT_P4r BCM89500_A0_G_EXT_STS_EXT_P4r
#define G_EXT_STS_EXT_P4r_SIZE BCM89500_A0_G_EXT_STS_EXT_P4r_SIZE
typedef BCM89500_A0_G_EXT_STS_EXT_P4r_t G_EXT_STS_EXT_P4r_t;
#define G_EXT_STS_EXT_P4r_CLR BCM89500_A0_G_EXT_STS_EXT_P4r_CLR
#define G_EXT_STS_EXT_P4r_SET BCM89500_A0_G_EXT_STS_EXT_P4r_SET
#define G_EXT_STS_EXT_P4r_GET BCM89500_A0_G_EXT_STS_EXT_P4r_GET
#define G_EXT_STS_EXT_P4r_RESERVEDf_GET BCM89500_A0_G_EXT_STS_EXT_P4r_RESERVEDf_GET
#define G_EXT_STS_EXT_P4r_RESERVEDf_SET BCM89500_A0_G_EXT_STS_EXT_P4r_RESERVEDf_SET
#define G_EXT_STS_EXT_P4r_B1000T_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXT_P4r_B1000T_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXT_P4r_B1000T_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXT_P4r_B1000T_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXT_P4r_B1000X_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXT_P4r_B1000X_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXT_P4r_B1000X_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXT_P4r_B1000X_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P4r_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXT_P4r BCM89500_A0_READ_G_EXT_STS_EXT_P4r
#define WRITE_G_EXT_STS_EXT_P4r BCM89500_A0_WRITE_G_EXT_STS_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXT_STS_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXT_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXT_STS_EXT_P5r 0x0000851e

#define BCM89500_A0_G_EXT_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_EXT_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext_p5[1];
	uint32_t _g_ext_sts_ext_p5;
} BCM89500_A0_G_EXT_STS_EXT_P5r_t;

#define BCM89500_A0_G_EXT_STS_EXT_P5r_CLR(r) (r).g_ext_sts_ext_p5[0] = 0
#define BCM89500_A0_G_EXT_STS_EXT_P5r_SET(r,d) (r).g_ext_sts_ext_p5[0] = d
#define BCM89500_A0_G_EXT_STS_EXT_P5r_GET(r) (r).g_ext_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXT_STS_EXT_P5r_RESERVEDf_GET(r) (((r).g_ext_sts_ext_p5[0]) & 0xfff)
#define BCM89500_A0_G_EXT_STS_EXT_P5r_RESERVEDf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXT_STS_EXT_P5r,(r._g_ext_sts_ext_p5),2)
#define BCM89500_A0_WRITE_G_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXT_STS_EXT_P5r,&(r._g_ext_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXT_P5r BCM89500_A0_G_EXT_STS_EXT_P5r
#define G_EXT_STS_EXT_P5r_SIZE BCM89500_A0_G_EXT_STS_EXT_P5r_SIZE
typedef BCM89500_A0_G_EXT_STS_EXT_P5r_t G_EXT_STS_EXT_P5r_t;
#define G_EXT_STS_EXT_P5r_CLR BCM89500_A0_G_EXT_STS_EXT_P5r_CLR
#define G_EXT_STS_EXT_P5r_SET BCM89500_A0_G_EXT_STS_EXT_P5r_SET
#define G_EXT_STS_EXT_P5r_GET BCM89500_A0_G_EXT_STS_EXT_P5r_GET
#define G_EXT_STS_EXT_P5r_RESERVEDf_GET BCM89500_A0_G_EXT_STS_EXT_P5r_RESERVEDf_GET
#define G_EXT_STS_EXT_P5r_RESERVEDf_SET BCM89500_A0_G_EXT_STS_EXT_P5r_RESERVEDf_SET
#define G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXT_P5r BCM89500_A0_READ_G_EXT_STS_EXT_P5r
#define WRITE_G_EXT_STS_EXT_P5r BCM89500_A0_WRITE_G_EXT_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXT_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXT_STS_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXT_STS_EXT_PNr 0x0000801e

#define BCM89500_A0_G_EXT_STS_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_EXT_STS_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext_pn[1];
	uint32_t _g_ext_sts_ext_pn;
} BCM89500_A0_G_EXT_STS_EXT_PNr_t;

#define BCM89500_A0_G_EXT_STS_EXT_PNr_CLR(r) (r).g_ext_sts_ext_pn[0] = 0
#define BCM89500_A0_G_EXT_STS_EXT_PNr_SET(r,d) (r).g_ext_sts_ext_pn[0] = d
#define BCM89500_A0_G_EXT_STS_EXT_PNr_GET(r) (r).g_ext_sts_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXT_STS_EXT_PNr_RESERVEDf_GET(r) (((r).g_ext_sts_ext_pn[0]) & 0xfff)
#define BCM89500_A0_G_EXT_STS_EXT_PNr_RESERVEDf_SET(r,f) (r).g_ext_sts_ext_pn[0]=(((r).g_ext_sts_ext_pn[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_pn[0]=(((r).g_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_pn[0]=(((r).g_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_pn[0]=(((r).g_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_pn[0]=(((r).g_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_EXT_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_EXT_STS_EXT_PNr,(r._g_ext_sts_ext_pn),2)
#define BCM89500_A0_WRITE_G_EXT_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_EXT_STS_EXT_PNr,&(r._g_ext_sts_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXT_PNr BCM89500_A0_G_EXT_STS_EXT_PNr
#define G_EXT_STS_EXT_PNr_SIZE BCM89500_A0_G_EXT_STS_EXT_PNr_SIZE
typedef BCM89500_A0_G_EXT_STS_EXT_PNr_t G_EXT_STS_EXT_PNr_t;
#define G_EXT_STS_EXT_PNr_CLR BCM89500_A0_G_EXT_STS_EXT_PNr_CLR
#define G_EXT_STS_EXT_PNr_SET BCM89500_A0_G_EXT_STS_EXT_PNr_SET
#define G_EXT_STS_EXT_PNr_GET BCM89500_A0_G_EXT_STS_EXT_PNr_GET
#define G_EXT_STS_EXT_PNr_RESERVEDf_GET BCM89500_A0_G_EXT_STS_EXT_PNr_RESERVEDf_GET
#define G_EXT_STS_EXT_PNr_RESERVEDf_SET BCM89500_A0_G_EXT_STS_EXT_PNr_RESERVEDf_SET
#define G_EXT_STS_EXT_PNr_B1000T_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXT_PNr_B1000T_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXT_PNr_B1000T_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXT_PNr_B1000T_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXT_PNr_B1000X_HD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXT_PNr_B1000X_HD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXT_PNr_B1000X_FD_CAPf_GET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXT_PNr_B1000X_FD_CAPf_SET BCM89500_A0_G_EXT_STS_EXT_PNr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXT_PNr BCM89500_A0_READ_G_EXT_STS_EXT_PNr
#define WRITE_G_EXT_STS_EXT_PNr BCM89500_A0_WRITE_G_EXT_STS_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXT_STS_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_EXT_STS_P7
 * BLOCKS:   SYS
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_G_EXT_STS_P7r 0x0000171e

#define BCM89500_A0_G_EXT_STS_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_P7.
 *
 */
typedef union BCM89500_A0_G_EXT_STS_P7r_s {
	uint32_t v[1];
	uint32_t g_ext_sts_p7[1];
	uint32_t _g_ext_sts_p7;
} BCM89500_A0_G_EXT_STS_P7r_t;

#define BCM89500_A0_G_EXT_STS_P7r_CLR(r) (r).g_ext_sts_p7[0] = 0
#define BCM89500_A0_G_EXT_STS_P7r_SET(r,d) (r).g_ext_sts_p7[0] = d
#define BCM89500_A0_G_EXT_STS_P7r_GET(r) (r).g_ext_sts_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_EXT_STS_P7r_RESERVEDf_GET(r) (((r).g_ext_sts_p7[0]) & 0xfff)
#define BCM89500_A0_G_EXT_STS_P7r_RESERVEDf_SET(r,f) (r).g_ext_sts_p7[0]=(((r).g_ext_sts_p7[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_G_EXT_STS_P7r_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_EXT_STS_P7r_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_p7[0]=(((r).g_ext_sts_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_EXT_STS_P7r_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_EXT_STS_P7r_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_p7[0]=(((r).g_ext_sts_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_EXT_STS_P7r_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_EXT_STS_P7r_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_p7[0]=(((r).g_ext_sts_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_EXT_STS_P7r_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_EXT_STS_P7r_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_p7[0]=(((r).g_ext_sts_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_P7.
 *
 */
#define BCM89500_A0_READ_G_EXT_STS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_EXT_STS_P7r,(r._g_ext_sts_p7),2)
#define BCM89500_A0_WRITE_G_EXT_STS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_EXT_STS_P7r,&(r._g_ext_sts_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_P7r BCM89500_A0_G_EXT_STS_P7r
#define G_EXT_STS_P7r_SIZE BCM89500_A0_G_EXT_STS_P7r_SIZE
typedef BCM89500_A0_G_EXT_STS_P7r_t G_EXT_STS_P7r_t;
#define G_EXT_STS_P7r_CLR BCM89500_A0_G_EXT_STS_P7r_CLR
#define G_EXT_STS_P7r_SET BCM89500_A0_G_EXT_STS_P7r_SET
#define G_EXT_STS_P7r_GET BCM89500_A0_G_EXT_STS_P7r_GET
#define G_EXT_STS_P7r_RESERVEDf_GET BCM89500_A0_G_EXT_STS_P7r_RESERVEDf_GET
#define G_EXT_STS_P7r_RESERVEDf_SET BCM89500_A0_G_EXT_STS_P7r_RESERVEDf_SET
#define G_EXT_STS_P7r_B1000T_HD_CAPf_GET BCM89500_A0_G_EXT_STS_P7r_B1000T_HD_CAPf_GET
#define G_EXT_STS_P7r_B1000T_HD_CAPf_SET BCM89500_A0_G_EXT_STS_P7r_B1000T_HD_CAPf_SET
#define G_EXT_STS_P7r_B1000T_FD_CAPf_GET BCM89500_A0_G_EXT_STS_P7r_B1000T_FD_CAPf_GET
#define G_EXT_STS_P7r_B1000T_FD_CAPf_SET BCM89500_A0_G_EXT_STS_P7r_B1000T_FD_CAPf_SET
#define G_EXT_STS_P7r_B1000X_HD_CAPf_GET BCM89500_A0_G_EXT_STS_P7r_B1000X_HD_CAPf_GET
#define G_EXT_STS_P7r_B1000X_HD_CAPf_SET BCM89500_A0_G_EXT_STS_P7r_B1000X_HD_CAPf_SET
#define G_EXT_STS_P7r_B1000X_FD_CAPf_GET BCM89500_A0_G_EXT_STS_P7r_B1000X_FD_CAPf_GET
#define G_EXT_STS_P7r_B1000X_FD_CAPf_SET BCM89500_A0_G_EXT_STS_P7r_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_P7r BCM89500_A0_READ_G_EXT_STS_P7r
#define WRITE_G_EXT_STS_P7r BCM89500_A0_WRITE_G_EXT_STS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_EXT_STS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_FALSE_CARR_CNT
 * BLOCKS:   SYS
 * DESC:     False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.
 *     RESERVED         Ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_FALSE_CARR_CNTr 0x00001426

#define BCM89500_A0_G_FALSE_CARR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT.
 *
 */
typedef union BCM89500_A0_G_FALSE_CARR_CNTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt[1];
	uint32_t _g_false_carr_cnt;
} BCM89500_A0_G_FALSE_CARR_CNTr_t;

#define BCM89500_A0_G_FALSE_CARR_CNTr_CLR(r) (r).g_false_carr_cnt[0] = 0
#define BCM89500_A0_G_FALSE_CARR_CNTr_SET(r,d) (r).g_false_carr_cnt[0] = d
#define BCM89500_A0_G_FALSE_CARR_CNTr_GET(r) (r).g_false_carr_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt[0]) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_FALSE_CARR_CNTr_RESERVEDf_GET(r) ((((r).g_false_carr_cnt[0]) >> 8) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNTr_RESERVEDf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT.
 *
 */
#define BCM89500_A0_READ_G_FALSE_CARR_CNTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_FALSE_CARR_CNTr,(r._g_false_carr_cnt),2)
#define BCM89500_A0_WRITE_G_FALSE_CARR_CNTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_FALSE_CARR_CNTr,&(r._g_false_carr_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNTr BCM89500_A0_G_FALSE_CARR_CNTr
#define G_FALSE_CARR_CNTr_SIZE BCM89500_A0_G_FALSE_CARR_CNTr_SIZE
typedef BCM89500_A0_G_FALSE_CARR_CNTr_t G_FALSE_CARR_CNTr_t;
#define G_FALSE_CARR_CNTr_CLR BCM89500_A0_G_FALSE_CARR_CNTr_CLR
#define G_FALSE_CARR_CNTr_SET BCM89500_A0_G_FALSE_CARR_CNTr_SET
#define G_FALSE_CARR_CNTr_GET BCM89500_A0_G_FALSE_CARR_CNTr_GET
#define G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNTr_RESERVEDf_GET BCM89500_A0_G_FALSE_CARR_CNTr_RESERVEDf_GET
#define G_FALSE_CARR_CNTr_RESERVEDf_SET BCM89500_A0_G_FALSE_CARR_CNTr_RESERVEDf_SET
#define READ_G_FALSE_CARR_CNTr BCM89500_A0_READ_G_FALSE_CARR_CNTr
#define WRITE_G_FALSE_CARR_CNTr BCM89500_A0_WRITE_G_FALSE_CARR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_FALSE_CARR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr 0x00008826

#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT.
 *
 */
typedef union BCM89500_A0_G_FALSE_CARR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext[1];
	uint32_t _g_false_carr_cnt_ext;
} BCM89500_A0_G_FALSE_CARR_CNT_EXTr_t;

#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_CLR(r) (r).g_false_carr_cnt_ext[0] = 0
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SET(r,d) (r).g_false_carr_cnt_ext[0] = d
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_GET(r) (r).g_false_carr_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext[0]) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext[0]) >> 8) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT.
 *
 */
#define BCM89500_A0_READ_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_FALSE_CARR_CNT_EXTr,(r._g_false_carr_cnt_ext),2)
#define BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_FALSE_CARR_CNT_EXTr,&(r._g_false_carr_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXTr BCM89500_A0_G_FALSE_CARR_CNT_EXTr
#define G_FALSE_CARR_CNT_EXTr_SIZE BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SIZE
typedef BCM89500_A0_G_FALSE_CARR_CNT_EXTr_t G_FALSE_CARR_CNT_EXTr_t;
#define G_FALSE_CARR_CNT_EXTr_CLR BCM89500_A0_G_FALSE_CARR_CNT_EXTr_CLR
#define G_FALSE_CARR_CNT_EXTr_SET BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SET
#define G_FALSE_CARR_CNT_EXTr_GET BCM89500_A0_G_FALSE_CARR_CNT_EXTr_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXTr BCM89500_A0_READ_G_FALSE_CARR_CNT_EXTr
#define WRITE_G_FALSE_CARR_CNT_EXTr BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_FALSE_CARR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r 0x00008426

#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext_p4[1];
	uint32_t _g_false_carr_cnt_ext_p4;
} BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_t;

#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_CLR(r) (r).g_false_carr_cnt_ext_p4[0] = 0
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SET(r,d) (r).g_false_carr_cnt_ext_p4[0] = d
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_GET(r) (r).g_false_carr_cnt_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext_p4[0]) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p4[0]=(((r).g_false_carr_cnt_ext_p4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext_p4[0]) >> 8) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p4[0]=(((r).g_false_carr_cnt_ext_p4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_FALSE_CARR_CNT_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r,(r._g_false_carr_cnt_ext_p4),2)
#define BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r,&(r._g_false_carr_cnt_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXT_P4r BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r
#define G_FALSE_CARR_CNT_EXT_P4r_SIZE BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SIZE
typedef BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_t G_FALSE_CARR_CNT_EXT_P4r_t;
#define G_FALSE_CARR_CNT_EXT_P4r_CLR BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_CLR
#define G_FALSE_CARR_CNT_EXT_P4r_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SET
#define G_FALSE_CARR_CNT_EXT_P4r_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_GET
#define G_FALSE_CARR_CNT_EXT_P4r_REC_ERR_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P4r_REC_ERR_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXT_P4r_SERDES_BER_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P4r_SERDES_BER_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXT_P4r BCM89500_A0_READ_G_FALSE_CARR_CNT_EXT_P4r
#define WRITE_G_FALSE_CARR_CNT_EXT_P4r BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_FALSE_CARR_CNT_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r 0x00008526

#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext_p5[1];
	uint32_t _g_false_carr_cnt_ext_p5;
} BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_t;

#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_CLR(r) (r).g_false_carr_cnt_ext_p5[0] = 0
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SET(r,d) (r).g_false_carr_cnt_ext_p5[0] = d
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_GET(r) (r).g_false_carr_cnt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext_p5[0]) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p5[0]=(((r).g_false_carr_cnt_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext_p5[0]) >> 8) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p5[0]=(((r).g_false_carr_cnt_ext_p5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_FALSE_CARR_CNT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r,(r._g_false_carr_cnt_ext_p5),2)
#define BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r,&(r._g_false_carr_cnt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXT_P5r BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r
#define G_FALSE_CARR_CNT_EXT_P5r_SIZE BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SIZE
typedef BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_t G_FALSE_CARR_CNT_EXT_P5r_t;
#define G_FALSE_CARR_CNT_EXT_P5r_CLR BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_CLR
#define G_FALSE_CARR_CNT_EXT_P5r_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SET
#define G_FALSE_CARR_CNT_EXT_P5r_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_GET
#define G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXT_P5r BCM89500_A0_READ_G_FALSE_CARR_CNT_EXT_P5r
#define WRITE_G_FALSE_CARR_CNT_EXT_P5r BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_FALSE_CARR_CNT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr 0x00008026

#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext_pn[1];
	uint32_t _g_false_carr_cnt_ext_pn;
} BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_t;

#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_CLR(r) (r).g_false_carr_cnt_ext_pn[0] = 0
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SET(r,d) (r).g_false_carr_cnt_ext_pn[0] = d
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_GET(r) (r).g_false_carr_cnt_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext_pn[0]) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_pn[0]=(((r).g_false_carr_cnt_ext_pn[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext_pn[0]) >> 8) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_pn[0]=(((r).g_false_carr_cnt_ext_pn[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_FALSE_CARR_CNT_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr,(r._g_false_carr_cnt_ext_pn),2)
#define BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr,&(r._g_false_carr_cnt_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXT_PNr BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr
#define G_FALSE_CARR_CNT_EXT_PNr_SIZE BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SIZE
typedef BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_t G_FALSE_CARR_CNT_EXT_PNr_t;
#define G_FALSE_CARR_CNT_EXT_PNr_CLR BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_CLR
#define G_FALSE_CARR_CNT_EXT_PNr_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SET
#define G_FALSE_CARR_CNT_EXT_PNr_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_GET
#define G_FALSE_CARR_CNT_EXT_PNr_REC_ERR_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_PNr_REC_ERR_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXT_PNr_SERDES_BER_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_PNr_SERDES_BER_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXT_PNr BCM89500_A0_READ_G_FALSE_CARR_CNT_EXT_PNr
#define WRITE_G_FALSE_CARR_CNT_EXT_PNr BCM89500_A0_WRITE_G_FALSE_CARR_CNT_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_FALSE_CARR_CNT_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_FALSE_CARR_CNT_P7
 * BLOCKS:   SYS
 * DESC:     False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r 0x00001726

#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_P7.
 *
 */
typedef union BCM89500_A0_G_FALSE_CARR_CNT_P7r_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_p7[1];
	uint32_t _g_false_carr_cnt_p7;
} BCM89500_A0_G_FALSE_CARR_CNT_P7r_t;

#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_CLR(r) (r).g_false_carr_cnt_p7[0] = 0
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_SET(r,d) (r).g_false_carr_cnt_p7[0] = d
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_GET(r) (r).g_false_carr_cnt_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_p7[0]) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_p7[0]=(((r).g_false_carr_cnt_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_p7[0]) >> 8) & 0xff)
#define BCM89500_A0_G_FALSE_CARR_CNT_P7r_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_p7[0]=(((r).g_false_carr_cnt_p7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_P7.
 *
 */
#define BCM89500_A0_READ_G_FALSE_CARR_CNT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_FALSE_CARR_CNT_P7r,(r._g_false_carr_cnt_p7),2)
#define BCM89500_A0_WRITE_G_FALSE_CARR_CNT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_FALSE_CARR_CNT_P7r,&(r._g_false_carr_cnt_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_P7r BCM89500_A0_G_FALSE_CARR_CNT_P7r
#define G_FALSE_CARR_CNT_P7r_SIZE BCM89500_A0_G_FALSE_CARR_CNT_P7r_SIZE
typedef BCM89500_A0_G_FALSE_CARR_CNT_P7r_t G_FALSE_CARR_CNT_P7r_t;
#define G_FALSE_CARR_CNT_P7r_CLR BCM89500_A0_G_FALSE_CARR_CNT_P7r_CLR
#define G_FALSE_CARR_CNT_P7r_SET BCM89500_A0_G_FALSE_CARR_CNT_P7r_SET
#define G_FALSE_CARR_CNT_P7r_GET BCM89500_A0_G_FALSE_CARR_CNT_P7r_GET
#define G_FALSE_CARR_CNT_P7r_REC_ERR_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_P7r_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_P7r_REC_ERR_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_P7r_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_P7r_SERDES_BER_CNTf_GET BCM89500_A0_G_FALSE_CARR_CNT_P7r_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_P7r_SERDES_BER_CNTf_SET BCM89500_A0_G_FALSE_CARR_CNT_P7r_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_P7r BCM89500_A0_READ_G_FALSE_CARR_CNT_P7r
#define WRITE_G_FALSE_CARR_CNT_P7r BCM89500_A0_WRITE_G_FALSE_CARR_CNT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_FALSE_CARR_CNT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_MSK
 * BLOCKS:   SYS
 * DESC:     Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    1 = interrupt masked (status bits still operate normally but do not generate interrupt output)0 = interrupt enabled
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_MSKr 0x00001436

#define BCM89500_A0_G_INTERRUPT_MSKr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_MSKr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk[1];
	uint32_t _g_interrupt_msk;
} BCM89500_A0_G_INTERRUPT_MSKr_t;

#define BCM89500_A0_G_INTERRUPT_MSKr_CLR(r) (r).g_interrupt_msk[0] = 0
#define BCM89500_A0_G_INTERRUPT_MSKr_SET(r,d) (r).g_interrupt_msk[0] = d
#define BCM89500_A0_G_INTERRUPT_MSKr_GET(r) (r).g_interrupt_msk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk[0]=(((r).g_interrupt_msk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_MSKr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_MSKr,(r._g_interrupt_msk),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_MSKr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_MSKr,&(r._g_interrupt_msk),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSKr BCM89500_A0_G_INTERRUPT_MSKr
#define G_INTERRUPT_MSKr_SIZE BCM89500_A0_G_INTERRUPT_MSKr_SIZE
typedef BCM89500_A0_G_INTERRUPT_MSKr_t G_INTERRUPT_MSKr_t;
#define G_INTERRUPT_MSKr_CLR BCM89500_A0_G_INTERRUPT_MSKr_CLR
#define G_INTERRUPT_MSKr_SET BCM89500_A0_G_INTERRUPT_MSKr_SET
#define G_INTERRUPT_MSKr_GET BCM89500_A0_G_INTERRUPT_MSKr_GET
#define G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET BCM89500_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET BCM89500_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSKr BCM89500_A0_READ_G_INTERRUPT_MSKr
#define WRITE_G_INTERRUPT_MSKr BCM89500_A0_WRITE_G_INTERRUPT_MSKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_MSKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_MSK_EXTr 0x00008836

#define BCM89500_A0_G_INTERRUPT_MSK_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_MSK_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext[1];
	uint32_t _g_interrupt_msk_ext;
} BCM89500_A0_G_INTERRUPT_MSK_EXTr_t;

#define BCM89500_A0_G_INTERRUPT_MSK_EXTr_CLR(r) (r).g_interrupt_msk_ext[0] = 0
#define BCM89500_A0_G_INTERRUPT_MSK_EXTr_SET(r,d) (r).g_interrupt_msk_ext[0] = d
#define BCM89500_A0_G_INTERRUPT_MSK_EXTr_GET(r) (r).g_interrupt_msk_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext[0]=(((r).g_interrupt_msk_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_MSK_EXTr,(r._g_interrupt_msk_ext),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_MSK_EXTr,&(r._g_interrupt_msk_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXTr BCM89500_A0_G_INTERRUPT_MSK_EXTr
#define G_INTERRUPT_MSK_EXTr_SIZE BCM89500_A0_G_INTERRUPT_MSK_EXTr_SIZE
typedef BCM89500_A0_G_INTERRUPT_MSK_EXTr_t G_INTERRUPT_MSK_EXTr_t;
#define G_INTERRUPT_MSK_EXTr_CLR BCM89500_A0_G_INTERRUPT_MSK_EXTr_CLR
#define G_INTERRUPT_MSK_EXTr_SET BCM89500_A0_G_INTERRUPT_MSK_EXTr_SET
#define G_INTERRUPT_MSK_EXTr_GET BCM89500_A0_G_INTERRUPT_MSK_EXTr_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET BCM89500_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET BCM89500_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXTr BCM89500_A0_READ_G_INTERRUPT_MSK_EXTr
#define WRITE_G_INTERRUPT_MSK_EXTr BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_MSK_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r 0x00008436

#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext_p4[1];
	uint32_t _g_interrupt_msk_ext_p4;
} BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_t;

#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_CLR(r) (r).g_interrupt_msk_ext_p4[0] = 0
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_SET(r,d) (r).g_interrupt_msk_ext_p4[0] = d
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_GET(r) (r).g_interrupt_msk_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext_p4[0]=(((r).g_interrupt_msk_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_MSK_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r,(r._g_interrupt_msk_ext_p4),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r,&(r._g_interrupt_msk_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXT_P4r BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r
#define G_INTERRUPT_MSK_EXT_P4r_SIZE BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_SIZE
typedef BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_t G_INTERRUPT_MSK_EXT_P4r_t;
#define G_INTERRUPT_MSK_EXT_P4r_CLR BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_CLR
#define G_INTERRUPT_MSK_EXT_P4r_SET BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_SET
#define G_INTERRUPT_MSK_EXT_P4r_GET BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_GET
#define G_INTERRUPT_MSK_EXT_P4r_INTERRUPT_MSKf_GET BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXT_P4r_INTERRUPT_MSKf_SET BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXT_P4r BCM89500_A0_READ_G_INTERRUPT_MSK_EXT_P4r
#define WRITE_G_INTERRUPT_MSK_EXT_P4r BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_MSK_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r 0x00008536

#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext_p5[1];
	uint32_t _g_interrupt_msk_ext_p5;
} BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_t;

#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_CLR(r) (r).g_interrupt_msk_ext_p5[0] = 0
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_SET(r,d) (r).g_interrupt_msk_ext_p5[0] = d
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_GET(r) (r).g_interrupt_msk_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext_p5[0]=(((r).g_interrupt_msk_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_MSK_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r,(r._g_interrupt_msk_ext_p5),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r,&(r._g_interrupt_msk_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXT_P5r BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r
#define G_INTERRUPT_MSK_EXT_P5r_SIZE BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_SIZE
typedef BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_t G_INTERRUPT_MSK_EXT_P5r_t;
#define G_INTERRUPT_MSK_EXT_P5r_CLR BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_CLR
#define G_INTERRUPT_MSK_EXT_P5r_SET BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_SET
#define G_INTERRUPT_MSK_EXT_P5r_GET BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_GET
#define G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_GET BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_SET BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXT_P5r BCM89500_A0_READ_G_INTERRUPT_MSK_EXT_P5r
#define WRITE_G_INTERRUPT_MSK_EXT_P5r BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_MSK_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr 0x00008036

#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext_pn[1];
	uint32_t _g_interrupt_msk_ext_pn;
} BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_t;

#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_CLR(r) (r).g_interrupt_msk_ext_pn[0] = 0
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_SET(r,d) (r).g_interrupt_msk_ext_pn[0] = d
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_GET(r) (r).g_interrupt_msk_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext_pn[0]=(((r).g_interrupt_msk_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_MSK_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr,(r._g_interrupt_msk_ext_pn),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr,&(r._g_interrupt_msk_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXT_PNr BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr
#define G_INTERRUPT_MSK_EXT_PNr_SIZE BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_SIZE
typedef BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_t G_INTERRUPT_MSK_EXT_PNr_t;
#define G_INTERRUPT_MSK_EXT_PNr_CLR BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_CLR
#define G_INTERRUPT_MSK_EXT_PNr_SET BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_SET
#define G_INTERRUPT_MSK_EXT_PNr_GET BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_GET
#define G_INTERRUPT_MSK_EXT_PNr_INTERRUPT_MSKf_GET BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXT_PNr_INTERRUPT_MSKf_SET BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXT_PNr BCM89500_A0_READ_G_INTERRUPT_MSK_EXT_PNr
#define WRITE_G_INTERRUPT_MSK_EXT_PNr BCM89500_A0_WRITE_G_INTERRUPT_MSK_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_MSK_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_MSK_P7
 * BLOCKS:   SYS
 * DESC:     Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_MSK_P7r 0x00001736

#define BCM89500_A0_G_INTERRUPT_MSK_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_P7.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_MSK_P7r_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_p7[1];
	uint32_t _g_interrupt_msk_p7;
} BCM89500_A0_G_INTERRUPT_MSK_P7r_t;

#define BCM89500_A0_G_INTERRUPT_MSK_P7r_CLR(r) (r).g_interrupt_msk_p7[0] = 0
#define BCM89500_A0_G_INTERRUPT_MSK_P7r_SET(r,d) (r).g_interrupt_msk_p7[0] = d
#define BCM89500_A0_G_INTERRUPT_MSK_P7r_GET(r) (r).g_interrupt_msk_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_MSK_P7r_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_p7[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_MSK_P7r_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_p7[0]=(((r).g_interrupt_msk_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_P7.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_MSK_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_MSK_P7r,(r._g_interrupt_msk_p7),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_MSK_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_MSK_P7r,&(r._g_interrupt_msk_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_P7r BCM89500_A0_G_INTERRUPT_MSK_P7r
#define G_INTERRUPT_MSK_P7r_SIZE BCM89500_A0_G_INTERRUPT_MSK_P7r_SIZE
typedef BCM89500_A0_G_INTERRUPT_MSK_P7r_t G_INTERRUPT_MSK_P7r_t;
#define G_INTERRUPT_MSK_P7r_CLR BCM89500_A0_G_INTERRUPT_MSK_P7r_CLR
#define G_INTERRUPT_MSK_P7r_SET BCM89500_A0_G_INTERRUPT_MSK_P7r_SET
#define G_INTERRUPT_MSK_P7r_GET BCM89500_A0_G_INTERRUPT_MSK_P7r_GET
#define G_INTERRUPT_MSK_P7r_INTERRUPT_MSKf_GET BCM89500_A0_G_INTERRUPT_MSK_P7r_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_P7r_INTERRUPT_MSKf_SET BCM89500_A0_G_INTERRUPT_MSK_P7r_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_P7r BCM89500_A0_READ_G_INTERRUPT_MSK_P7r
#define WRITE_G_INTERRUPT_MSK_P7r BCM89500_A0_WRITE_G_INTERRUPT_MSK_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_MSK_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_STS
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     CRC_ERROR        1 = CRC error occurred since last read0 = interrupt cleared
 *     LINK_STATUS_CHANGE 1 = link status changed since last read0 = interrupt cleared
 *     LINK_SPEED_CHANGE 1 = link speed changed since last read0 = interrupt cleared
 *     DUPLEX_MODE_CHANGE 1 = duplex mode changed since last read0 = interrupt cleared
 *     LOCAL_RECEIVER_STATUS_CHANGE 1 = local receiver status changed since last read0 = interrupt cleared
 *     REMOTE_RECEIVER_STATUS_CHANGE 1 = remote receiver status changed since last read0 = interrupt cleared
 *     SCRAMBLER_SYNC_ERROR 1 = scrambler synchronization error occurred  since last read0 = interrupt cleared
 *     NEGOTIATED_UNSUPPORTED_HCD 1 = auto-negotiation HCD is not supported by local PHY0 = interrupt cleared
 *     NO_HCD           1 = auto-negotiation returned HCD=none0 = interrupt cleared
 *     HCD_NO_LINK      1 = negotiated HCD did not establish link0 = interrupt cleared
 *     AN_PAGE          1 = page received since last read0 = interrupt cleared
 *     EXCEEDED_LOW_COUNTER_THRESH 1 = value in one or more counters is above 1280 = all counters below 128
 *     EXCEEDED_HIGH_COUNTER_THRESH 1 = value in one or more counters is above 32k0 = all counters below 32k
 *     MDIX_STATUS_CHANGE 1 = MDIX status changed since last read (means that linkpulse or carrier was detected on a different pair than previously detected)0 = interrupt cleared
 *     ILLEGAL_PAIR_SWAP 1 = Illegal pair swap detected0 = interrupt cleared
 *     ENERGY_DETECT_CHANGE 1 = energy detect change since last read0 = interrupt cleared
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_STSr 0x00001434

#define BCM89500_A0_G_INTERRUPT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_STSr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts[1];
	uint32_t _g_interrupt_sts;
} BCM89500_A0_G_INTERRUPT_STSr_t;

#define BCM89500_A0_G_INTERRUPT_STSr_CLR(r) (r).g_interrupt_sts[0] = 0
#define BCM89500_A0_G_INTERRUPT_STSr_SET(r,d) (r).g_interrupt_sts[0] = d
#define BCM89500_A0_G_INTERRUPT_STSr_GET(r) (r).g_interrupt_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_STSr_CRC_ERRORf_GET(r) (((r).g_interrupt_sts[0]) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_CRC_ERRORf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_INTERRUPT_STSr_LINK_STATUS_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_LINK_STATUS_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_INTERRUPT_STSr_LINK_SPEED_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_LINK_SPEED_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 4) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 5) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_GET(r) ((((r).g_interrupt_sts[0]) >> 6) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_GET(r) ((((r).g_interrupt_sts[0]) >> 7) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_INTERRUPT_STSr_NO_HCDf_GET(r) ((((r).g_interrupt_sts[0]) >> 8) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_NO_HCDf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_INTERRUPT_STSr_HCD_NO_LINKf_GET(r) ((((r).g_interrupt_sts[0]) >> 9) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_HCD_NO_LINKf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_INTERRUPT_STSr_AN_PAGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 10) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_AN_PAGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_GET(r) ((((r).g_interrupt_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_GET(r) ((((r).g_interrupt_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_GET(r) ((((r).g_interrupt_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_GET(r) ((((r).g_interrupt_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_G_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_INTERRUPT_STS.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_STSr,(r._g_interrupt_sts),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_STSr,&(r._g_interrupt_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STSr BCM89500_A0_G_INTERRUPT_STSr
#define G_INTERRUPT_STSr_SIZE BCM89500_A0_G_INTERRUPT_STSr_SIZE
typedef BCM89500_A0_G_INTERRUPT_STSr_t G_INTERRUPT_STSr_t;
#define G_INTERRUPT_STSr_CLR BCM89500_A0_G_INTERRUPT_STSr_CLR
#define G_INTERRUPT_STSr_SET BCM89500_A0_G_INTERRUPT_STSr_SET
#define G_INTERRUPT_STSr_GET BCM89500_A0_G_INTERRUPT_STSr_GET
#define G_INTERRUPT_STSr_CRC_ERRORf_GET BCM89500_A0_G_INTERRUPT_STSr_CRC_ERRORf_GET
#define G_INTERRUPT_STSr_CRC_ERRORf_SET BCM89500_A0_G_INTERRUPT_STSr_CRC_ERRORf_SET
#define G_INTERRUPT_STSr_LINK_STATUS_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_LINK_STATUS_CHANGEf_GET
#define G_INTERRUPT_STSr_LINK_STATUS_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_LINK_STATUS_CHANGEf_SET
#define G_INTERRUPT_STSr_LINK_SPEED_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_LINK_SPEED_CHANGEf_GET
#define G_INTERRUPT_STSr_LINK_SPEED_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_LINK_SPEED_CHANGEf_SET
#define G_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_GET
#define G_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_DUPLEX_MODE_CHANGEf_SET
#define G_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_GET
#define G_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_LOCAL_RECEIVER_STATUS_CHANGEf_SET
#define G_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_GET
#define G_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_REMOTE_RECEIVER_STATUS_CHANGEf_SET
#define G_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_GET BCM89500_A0_G_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_GET
#define G_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_SET BCM89500_A0_G_INTERRUPT_STSr_SCRAMBLER_SYNC_ERRORf_SET
#define G_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_GET BCM89500_A0_G_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_GET
#define G_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_SET BCM89500_A0_G_INTERRUPT_STSr_NEGOTIATED_UNSUPPORTED_HCDf_SET
#define G_INTERRUPT_STSr_NO_HCDf_GET BCM89500_A0_G_INTERRUPT_STSr_NO_HCDf_GET
#define G_INTERRUPT_STSr_NO_HCDf_SET BCM89500_A0_G_INTERRUPT_STSr_NO_HCDf_SET
#define G_INTERRUPT_STSr_HCD_NO_LINKf_GET BCM89500_A0_G_INTERRUPT_STSr_HCD_NO_LINKf_GET
#define G_INTERRUPT_STSr_HCD_NO_LINKf_SET BCM89500_A0_G_INTERRUPT_STSr_HCD_NO_LINKf_SET
#define G_INTERRUPT_STSr_AN_PAGEf_GET BCM89500_A0_G_INTERRUPT_STSr_AN_PAGEf_GET
#define G_INTERRUPT_STSr_AN_PAGEf_SET BCM89500_A0_G_INTERRUPT_STSr_AN_PAGEf_SET
#define G_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_GET BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_GET
#define G_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_SET BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_LOW_COUNTER_THRESHf_SET
#define G_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_GET BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_GET
#define G_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_SET BCM89500_A0_G_INTERRUPT_STSr_EXCEEDED_HIGH_COUNTER_THRESHf_SET
#define G_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_GET
#define G_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_MDIX_STATUS_CHANGEf_SET
#define G_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_GET BCM89500_A0_G_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_GET
#define G_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_SET BCM89500_A0_G_INTERRUPT_STSr_ILLEGAL_PAIR_SWAPf_SET
#define G_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_GET BCM89500_A0_G_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_GET
#define G_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_SET BCM89500_A0_G_INTERRUPT_STSr_ENERGY_DETECT_CHANGEf_SET
#define READ_G_INTERRUPT_STSr BCM89500_A0_READ_G_INTERRUPT_STSr
#define WRITE_G_INTERRUPT_STSr BCM89500_A0_WRITE_G_INTERRUPT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_STS_EXTr 0x00008834

#define BCM89500_A0_G_INTERRUPT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext[1];
	uint32_t _g_interrupt_sts_ext;
} BCM89500_A0_G_INTERRUPT_STS_EXTr_t;

#define BCM89500_A0_G_INTERRUPT_STS_EXTr_CLR(r) (r).g_interrupt_sts_ext[0] = 0
#define BCM89500_A0_G_INTERRUPT_STS_EXTr_SET(r,d) (r).g_interrupt_sts_ext[0] = d
#define BCM89500_A0_G_INTERRUPT_STS_EXTr_GET(r) (r).g_interrupt_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext[0]=(((r).g_interrupt_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_STS_EXTr,(r._g_interrupt_sts_ext),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_STS_EXTr,&(r._g_interrupt_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXTr BCM89500_A0_G_INTERRUPT_STS_EXTr
#define G_INTERRUPT_STS_EXTr_SIZE BCM89500_A0_G_INTERRUPT_STS_EXTr_SIZE
typedef BCM89500_A0_G_INTERRUPT_STS_EXTr_t G_INTERRUPT_STS_EXTr_t;
#define G_INTERRUPT_STS_EXTr_CLR BCM89500_A0_G_INTERRUPT_STS_EXTr_CLR
#define G_INTERRUPT_STS_EXTr_SET BCM89500_A0_G_INTERRUPT_STS_EXTr_SET
#define G_INTERRUPT_STS_EXTr_GET BCM89500_A0_G_INTERRUPT_STS_EXTr_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET BCM89500_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET BCM89500_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXTr BCM89500_A0_READ_G_INTERRUPT_STS_EXTr
#define WRITE_G_INTERRUPT_STS_EXTr BCM89500_A0_WRITE_G_INTERRUPT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_STS_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r 0x00008434

#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext_p4[1];
	uint32_t _g_interrupt_sts_ext_p4;
} BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_t;

#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_CLR(r) (r).g_interrupt_sts_ext_p4[0] = 0
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_SET(r,d) (r).g_interrupt_sts_ext_p4[0] = d
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_GET(r) (r).g_interrupt_sts_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext_p4[0]=(((r).g_interrupt_sts_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_STS_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_STS_EXT_P4r,(r._g_interrupt_sts_ext_p4),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_STS_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_STS_EXT_P4r,&(r._g_interrupt_sts_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXT_P4r BCM89500_A0_G_INTERRUPT_STS_EXT_P4r
#define G_INTERRUPT_STS_EXT_P4r_SIZE BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_SIZE
typedef BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_t G_INTERRUPT_STS_EXT_P4r_t;
#define G_INTERRUPT_STS_EXT_P4r_CLR BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_CLR
#define G_INTERRUPT_STS_EXT_P4r_SET BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_SET
#define G_INTERRUPT_STS_EXT_P4r_GET BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_GET
#define G_INTERRUPT_STS_EXT_P4r_INTERRUPT_STSf_GET BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXT_P4r_INTERRUPT_STSf_SET BCM89500_A0_G_INTERRUPT_STS_EXT_P4r_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXT_P4r BCM89500_A0_READ_G_INTERRUPT_STS_EXT_P4r
#define WRITE_G_INTERRUPT_STS_EXT_P4r BCM89500_A0_WRITE_G_INTERRUPT_STS_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_STS_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r 0x00008534

#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext_p5[1];
	uint32_t _g_interrupt_sts_ext_p5;
} BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_t;

#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_CLR(r) (r).g_interrupt_sts_ext_p5[0] = 0
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_SET(r,d) (r).g_interrupt_sts_ext_p5[0] = d
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_GET(r) (r).g_interrupt_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext_p5[0]=(((r).g_interrupt_sts_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_STS_EXT_P5r,(r._g_interrupt_sts_ext_p5),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_STS_EXT_P5r,&(r._g_interrupt_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXT_P5r BCM89500_A0_G_INTERRUPT_STS_EXT_P5r
#define G_INTERRUPT_STS_EXT_P5r_SIZE BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_SIZE
typedef BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_t G_INTERRUPT_STS_EXT_P5r_t;
#define G_INTERRUPT_STS_EXT_P5r_CLR BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_CLR
#define G_INTERRUPT_STS_EXT_P5r_SET BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_SET
#define G_INTERRUPT_STS_EXT_P5r_GET BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_GET
#define G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_GET BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_SET BCM89500_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXT_P5r BCM89500_A0_READ_G_INTERRUPT_STS_EXT_P5r
#define WRITE_G_INTERRUPT_STS_EXT_P5r BCM89500_A0_WRITE_G_INTERRUPT_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_STS_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr 0x00008034

#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext_pn[1];
	uint32_t _g_interrupt_sts_ext_pn;
} BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_t;

#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_CLR(r) (r).g_interrupt_sts_ext_pn[0] = 0
#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_SET(r,d) (r).g_interrupt_sts_ext_pn[0] = d
#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_GET(r) (r).g_interrupt_sts_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext_pn[0]=(((r).g_interrupt_sts_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_INTERRUPT_STS_EXT_PNr,(r._g_interrupt_sts_ext_pn),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_INTERRUPT_STS_EXT_PNr,&(r._g_interrupt_sts_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXT_PNr BCM89500_A0_G_INTERRUPT_STS_EXT_PNr
#define G_INTERRUPT_STS_EXT_PNr_SIZE BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_SIZE
typedef BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_t G_INTERRUPT_STS_EXT_PNr_t;
#define G_INTERRUPT_STS_EXT_PNr_CLR BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_CLR
#define G_INTERRUPT_STS_EXT_PNr_SET BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_SET
#define G_INTERRUPT_STS_EXT_PNr_GET BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_GET
#define G_INTERRUPT_STS_EXT_PNr_INTERRUPT_STSf_GET BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXT_PNr_INTERRUPT_STSf_SET BCM89500_A0_G_INTERRUPT_STS_EXT_PNr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXT_PNr BCM89500_A0_READ_G_INTERRUPT_STS_EXT_PNr
#define WRITE_G_INTERRUPT_STS_EXT_PNr BCM89500_A0_WRITE_G_INTERRUPT_STS_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_STS_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_INTERRUPT_STS_P7
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM89500_A0_G_INTERRUPT_STS_P7r 0x00001734

#define BCM89500_A0_G_INTERRUPT_STS_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_P7.
 *
 */
typedef union BCM89500_A0_G_INTERRUPT_STS_P7r_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_p7[1];
	uint32_t _g_interrupt_sts_p7;
} BCM89500_A0_G_INTERRUPT_STS_P7r_t;

#define BCM89500_A0_G_INTERRUPT_STS_P7r_CLR(r) (r).g_interrupt_sts_p7[0] = 0
#define BCM89500_A0_G_INTERRUPT_STS_P7r_SET(r,d) (r).g_interrupt_sts_p7[0] = d
#define BCM89500_A0_G_INTERRUPT_STS_P7r_GET(r) (r).g_interrupt_sts_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_INTERRUPT_STS_P7r_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_p7[0]) & 0xffff)
#define BCM89500_A0_G_INTERRUPT_STS_P7r_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_p7[0]=(((r).g_interrupt_sts_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_P7.
 *
 */
#define BCM89500_A0_READ_G_INTERRUPT_STS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_INTERRUPT_STS_P7r,(r._g_interrupt_sts_p7),2)
#define BCM89500_A0_WRITE_G_INTERRUPT_STS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_INTERRUPT_STS_P7r,&(r._g_interrupt_sts_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_P7r BCM89500_A0_G_INTERRUPT_STS_P7r
#define G_INTERRUPT_STS_P7r_SIZE BCM89500_A0_G_INTERRUPT_STS_P7r_SIZE
typedef BCM89500_A0_G_INTERRUPT_STS_P7r_t G_INTERRUPT_STS_P7r_t;
#define G_INTERRUPT_STS_P7r_CLR BCM89500_A0_G_INTERRUPT_STS_P7r_CLR
#define G_INTERRUPT_STS_P7r_SET BCM89500_A0_G_INTERRUPT_STS_P7r_SET
#define G_INTERRUPT_STS_P7r_GET BCM89500_A0_G_INTERRUPT_STS_P7r_GET
#define G_INTERRUPT_STS_P7r_INTERRUPT_STSf_GET BCM89500_A0_G_INTERRUPT_STS_P7r_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_P7r_INTERRUPT_STSf_SET BCM89500_A0_G_INTERRUPT_STS_P7r_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_P7r BCM89500_A0_READ_G_INTERRUPT_STS_P7r
#define WRITE_G_INTERRUPT_STS_P7r BCM89500_A0_WRITE_G_INTERRUPT_STS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_INTERRUPT_STS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_LPNXP
 * BLOCKS:   SYS
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACKNOWLEDGE_3    1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_LPNXPr 0x00001410

#define BCM89500_A0_G_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP.
 *
 */
typedef union BCM89500_A0_G_LPNXPr_s {
	uint32_t v[1];
	uint32_t g_lpnxp[1];
	uint32_t _g_lpnxp;
} BCM89500_A0_G_LPNXPr_t;

#define BCM89500_A0_G_LPNXPr_CLR(r) (r).g_lpnxp[0] = 0
#define BCM89500_A0_G_LPNXPr_SET(r,d) (r).g_lpnxp[0] = d
#define BCM89500_A0_G_LPNXPr_GET(r) (r).g_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_LPNXPr_CODE_FIELDf_GET(r) (((r).g_lpnxp[0]) & 0x7ff)
#define BCM89500_A0_G_LPNXPr_CODE_FIELDf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_G_LPNXPr_TOGGLEf_GET(r) ((((r).g_lpnxp[0]) >> 11) & 0x1)
#define BCM89500_A0_G_LPNXPr_TOGGLEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp[0]) >> 12) & 0x1)
#define BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_LPNXPr_MES_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 13) & 0x1)
#define BCM89500_A0_G_LPNXPr_MES_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_3f_GET(r) ((((r).g_lpnxp[0]) >> 14) & 0x1)
#define BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_3f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_LPNXPr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 15) & 0x1)
#define BCM89500_A0_G_LPNXPr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP.
 *
 */
#define BCM89500_A0_READ_G_LPNXPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_LPNXPr,(r._g_lpnxp),2)
#define BCM89500_A0_WRITE_G_LPNXPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_LPNXPr,&(r._g_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXPr BCM89500_A0_G_LPNXPr
#define G_LPNXPr_SIZE BCM89500_A0_G_LPNXPr_SIZE
typedef BCM89500_A0_G_LPNXPr_t G_LPNXPr_t;
#define G_LPNXPr_CLR BCM89500_A0_G_LPNXPr_CLR
#define G_LPNXPr_SET BCM89500_A0_G_LPNXPr_SET
#define G_LPNXPr_GET BCM89500_A0_G_LPNXPr_GET
#define G_LPNXPr_CODE_FIELDf_GET BCM89500_A0_G_LPNXPr_CODE_FIELDf_GET
#define G_LPNXPr_CODE_FIELDf_SET BCM89500_A0_G_LPNXPr_CODE_FIELDf_SET
#define G_LPNXPr_TOGGLEf_GET BCM89500_A0_G_LPNXPr_TOGGLEf_GET
#define G_LPNXPr_TOGGLEf_SET BCM89500_A0_G_LPNXPr_TOGGLEf_SET
#define G_LPNXPr_ACKNOWLEDGE_2f_GET BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET
#define G_LPNXPr_ACKNOWLEDGE_2f_SET BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET
#define G_LPNXPr_MES_PAGEf_GET BCM89500_A0_G_LPNXPr_MES_PAGEf_GET
#define G_LPNXPr_MES_PAGEf_SET BCM89500_A0_G_LPNXPr_MES_PAGEf_SET
#define G_LPNXPr_ACKNOWLEDGE_3f_GET BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_3f_GET
#define G_LPNXPr_ACKNOWLEDGE_3f_SET BCM89500_A0_G_LPNXPr_ACKNOWLEDGE_3f_SET
#define G_LPNXPr_NEXT_PAGEf_GET BCM89500_A0_G_LPNXPr_NEXT_PAGEf_GET
#define G_LPNXPr_NEXT_PAGEf_SET BCM89500_A0_G_LPNXPr_NEXT_PAGEf_SET
#define READ_G_LPNXPr BCM89500_A0_READ_G_LPNXPr
#define WRITE_G_LPNXPr BCM89500_A0_WRITE_G_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_LPNXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_LPNXP_EXTr 0x00008810

#define BCM89500_A0_G_LPNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT.
 *
 */
typedef union BCM89500_A0_G_LPNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext[1];
	uint32_t _g_lpnxp_ext;
} BCM89500_A0_G_LPNXP_EXTr_t;

#define BCM89500_A0_G_LPNXP_EXTr_CLR(r) (r).g_lpnxp_ext[0] = 0
#define BCM89500_A0_G_LPNXP_EXTr_SET(r,d) (r).g_lpnxp_ext[0] = d
#define BCM89500_A0_G_LPNXP_EXTr_GET(r) (r).g_lpnxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_LPNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_LPNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_LPNXP_EXTr_TOGGLEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_LPNXP_EXTr_TOGGLEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_LPNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_LPNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_LPNXP_EXTr_ACKf_GET(r) ((((r).g_lpnxp_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_LPNXP_EXTr_ACKf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT.
 *
 */
#define BCM89500_A0_READ_G_LPNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_LPNXP_EXTr,(r._g_lpnxp_ext),2)
#define BCM89500_A0_WRITE_G_LPNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_LPNXP_EXTr,&(r._g_lpnxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXTr BCM89500_A0_G_LPNXP_EXTr
#define G_LPNXP_EXTr_SIZE BCM89500_A0_G_LPNXP_EXTr_SIZE
typedef BCM89500_A0_G_LPNXP_EXTr_t G_LPNXP_EXTr_t;
#define G_LPNXP_EXTr_CLR BCM89500_A0_G_LPNXP_EXTr_CLR
#define G_LPNXP_EXTr_SET BCM89500_A0_G_LPNXP_EXTr_SET
#define G_LPNXP_EXTr_GET BCM89500_A0_G_LPNXP_EXTr_GET
#define G_LPNXP_EXTr_CODE_FIELDf_GET BCM89500_A0_G_LPNXP_EXTr_CODE_FIELDf_GET
#define G_LPNXP_EXTr_CODE_FIELDf_SET BCM89500_A0_G_LPNXP_EXTr_CODE_FIELDf_SET
#define G_LPNXP_EXTr_TOGGLEf_GET BCM89500_A0_G_LPNXP_EXTr_TOGGLEf_GET
#define G_LPNXP_EXTr_TOGGLEf_SET BCM89500_A0_G_LPNXP_EXTr_TOGGLEf_SET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET BCM89500_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET BCM89500_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXTr_MES_PAGEf_GET BCM89500_A0_G_LPNXP_EXTr_MES_PAGEf_GET
#define G_LPNXP_EXTr_MES_PAGEf_SET BCM89500_A0_G_LPNXP_EXTr_MES_PAGEf_SET
#define G_LPNXP_EXTr_ACKf_GET BCM89500_A0_G_LPNXP_EXTr_ACKf_GET
#define G_LPNXP_EXTr_ACKf_SET BCM89500_A0_G_LPNXP_EXTr_ACKf_SET
#define G_LPNXP_EXTr_NEXT_PAGEf_GET BCM89500_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET
#define G_LPNXP_EXTr_NEXT_PAGEf_SET BCM89500_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXTr BCM89500_A0_READ_G_LPNXP_EXTr
#define WRITE_G_LPNXP_EXTr BCM89500_A0_WRITE_G_LPNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_LPNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_LPNXP_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_LPNXP_EXT_P4r 0x00008410

#define BCM89500_A0_G_LPNXP_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_LPNXP_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext_p4[1];
	uint32_t _g_lpnxp_ext_p4;
} BCM89500_A0_G_LPNXP_EXT_P4r_t;

#define BCM89500_A0_G_LPNXP_EXT_P4r_CLR(r) (r).g_lpnxp_ext_p4[0] = 0
#define BCM89500_A0_G_LPNXP_EXT_P4r_SET(r,d) (r).g_lpnxp_ext_p4[0] = d
#define BCM89500_A0_G_LPNXP_EXT_P4r_GET(r) (r).g_lpnxp_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_LPNXP_EXT_P4r_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P4r_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext_p4[0]=(((r).g_lpnxp_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_LPNXP_EXT_P4r_TOGGLEf_GET(r) ((((r).g_lpnxp_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P4r_TOGGLEf_SET(r,f) (r).g_lpnxp_ext_p4[0]=(((r).g_lpnxp_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_LPNXP_EXT_P4r_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P4r_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext_p4[0]=(((r).g_lpnxp_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_LPNXP_EXT_P4r_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P4r_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext_p4[0]=(((r).g_lpnxp_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_LPNXP_EXT_P4r_ACKf_GET(r) ((((r).g_lpnxp_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P4r_ACKf_SET(r,f) (r).g_lpnxp_ext_p4[0]=(((r).g_lpnxp_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_LPNXP_EXT_P4r_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P4r_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext_p4[0]=(((r).g_lpnxp_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_LPNXP_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_LPNXP_EXT_P4r,(r._g_lpnxp_ext_p4),2)
#define BCM89500_A0_WRITE_G_LPNXP_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_LPNXP_EXT_P4r,&(r._g_lpnxp_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXT_P4r BCM89500_A0_G_LPNXP_EXT_P4r
#define G_LPNXP_EXT_P4r_SIZE BCM89500_A0_G_LPNXP_EXT_P4r_SIZE
typedef BCM89500_A0_G_LPNXP_EXT_P4r_t G_LPNXP_EXT_P4r_t;
#define G_LPNXP_EXT_P4r_CLR BCM89500_A0_G_LPNXP_EXT_P4r_CLR
#define G_LPNXP_EXT_P4r_SET BCM89500_A0_G_LPNXP_EXT_P4r_SET
#define G_LPNXP_EXT_P4r_GET BCM89500_A0_G_LPNXP_EXT_P4r_GET
#define G_LPNXP_EXT_P4r_CODE_FIELDf_GET BCM89500_A0_G_LPNXP_EXT_P4r_CODE_FIELDf_GET
#define G_LPNXP_EXT_P4r_CODE_FIELDf_SET BCM89500_A0_G_LPNXP_EXT_P4r_CODE_FIELDf_SET
#define G_LPNXP_EXT_P4r_TOGGLEf_GET BCM89500_A0_G_LPNXP_EXT_P4r_TOGGLEf_GET
#define G_LPNXP_EXT_P4r_TOGGLEf_SET BCM89500_A0_G_LPNXP_EXT_P4r_TOGGLEf_SET
#define G_LPNXP_EXT_P4r_ACKNOWLEDGE_2f_GET BCM89500_A0_G_LPNXP_EXT_P4r_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXT_P4r_ACKNOWLEDGE_2f_SET BCM89500_A0_G_LPNXP_EXT_P4r_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXT_P4r_MES_PAGEf_GET BCM89500_A0_G_LPNXP_EXT_P4r_MES_PAGEf_GET
#define G_LPNXP_EXT_P4r_MES_PAGEf_SET BCM89500_A0_G_LPNXP_EXT_P4r_MES_PAGEf_SET
#define G_LPNXP_EXT_P4r_ACKf_GET BCM89500_A0_G_LPNXP_EXT_P4r_ACKf_GET
#define G_LPNXP_EXT_P4r_ACKf_SET BCM89500_A0_G_LPNXP_EXT_P4r_ACKf_SET
#define G_LPNXP_EXT_P4r_NEXT_PAGEf_GET BCM89500_A0_G_LPNXP_EXT_P4r_NEXT_PAGEf_GET
#define G_LPNXP_EXT_P4r_NEXT_PAGEf_SET BCM89500_A0_G_LPNXP_EXT_P4r_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXT_P4r BCM89500_A0_READ_G_LPNXP_EXT_P4r
#define WRITE_G_LPNXP_EXT_P4r BCM89500_A0_WRITE_G_LPNXP_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_LPNXP_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_LPNXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_LPNXP_EXT_P5r 0x00008510

#define BCM89500_A0_G_LPNXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_LPNXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext_p5[1];
	uint32_t _g_lpnxp_ext_p5;
} BCM89500_A0_G_LPNXP_EXT_P5r_t;

#define BCM89500_A0_G_LPNXP_EXT_P5r_CLR(r) (r).g_lpnxp_ext_p5[0] = 0
#define BCM89500_A0_G_LPNXP_EXT_P5r_SET(r,d) (r).g_lpnxp_ext_p5[0] = d
#define BCM89500_A0_G_LPNXP_EXT_P5r_GET(r) (r).g_lpnxp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_LPNXP_EXT_P5r_TOGGLEf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P5r_TOGGLEf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_LPNXP_EXT_P5r_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P5r_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_LPNXP_EXT_P5r_ACKf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P5r_ACKf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_LPNXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_LPNXP_EXT_P5r,(r._g_lpnxp_ext_p5),2)
#define BCM89500_A0_WRITE_G_LPNXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_LPNXP_EXT_P5r,&(r._g_lpnxp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXT_P5r BCM89500_A0_G_LPNXP_EXT_P5r
#define G_LPNXP_EXT_P5r_SIZE BCM89500_A0_G_LPNXP_EXT_P5r_SIZE
typedef BCM89500_A0_G_LPNXP_EXT_P5r_t G_LPNXP_EXT_P5r_t;
#define G_LPNXP_EXT_P5r_CLR BCM89500_A0_G_LPNXP_EXT_P5r_CLR
#define G_LPNXP_EXT_P5r_SET BCM89500_A0_G_LPNXP_EXT_P5r_SET
#define G_LPNXP_EXT_P5r_GET BCM89500_A0_G_LPNXP_EXT_P5r_GET
#define G_LPNXP_EXT_P5r_CODE_FIELDf_GET BCM89500_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_GET
#define G_LPNXP_EXT_P5r_CODE_FIELDf_SET BCM89500_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_SET
#define G_LPNXP_EXT_P5r_TOGGLEf_GET BCM89500_A0_G_LPNXP_EXT_P5r_TOGGLEf_GET
#define G_LPNXP_EXT_P5r_TOGGLEf_SET BCM89500_A0_G_LPNXP_EXT_P5r_TOGGLEf_SET
#define G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_GET BCM89500_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_SET BCM89500_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXT_P5r_MES_PAGEf_GET BCM89500_A0_G_LPNXP_EXT_P5r_MES_PAGEf_GET
#define G_LPNXP_EXT_P5r_MES_PAGEf_SET BCM89500_A0_G_LPNXP_EXT_P5r_MES_PAGEf_SET
#define G_LPNXP_EXT_P5r_ACKf_GET BCM89500_A0_G_LPNXP_EXT_P5r_ACKf_GET
#define G_LPNXP_EXT_P5r_ACKf_SET BCM89500_A0_G_LPNXP_EXT_P5r_ACKf_SET
#define G_LPNXP_EXT_P5r_NEXT_PAGEf_GET BCM89500_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_GET
#define G_LPNXP_EXT_P5r_NEXT_PAGEf_SET BCM89500_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXT_P5r BCM89500_A0_READ_G_LPNXP_EXT_P5r
#define WRITE_G_LPNXP_EXT_P5r BCM89500_A0_WRITE_G_LPNXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_LPNXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_LPNXP_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_LPNXP_EXT_PNr 0x00008010

#define BCM89500_A0_G_LPNXP_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_LPNXP_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext_pn[1];
	uint32_t _g_lpnxp_ext_pn;
} BCM89500_A0_G_LPNXP_EXT_PNr_t;

#define BCM89500_A0_G_LPNXP_EXT_PNr_CLR(r) (r).g_lpnxp_ext_pn[0] = 0
#define BCM89500_A0_G_LPNXP_EXT_PNr_SET(r,d) (r).g_lpnxp_ext_pn[0] = d
#define BCM89500_A0_G_LPNXP_EXT_PNr_GET(r) (r).g_lpnxp_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_LPNXP_EXT_PNr_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_PNr_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext_pn[0]=(((r).g_lpnxp_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_LPNXP_EXT_PNr_TOGGLEf_GET(r) ((((r).g_lpnxp_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_PNr_TOGGLEf_SET(r,f) (r).g_lpnxp_ext_pn[0]=(((r).g_lpnxp_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_LPNXP_EXT_PNr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_PNr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext_pn[0]=(((r).g_lpnxp_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_LPNXP_EXT_PNr_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_PNr_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext_pn[0]=(((r).g_lpnxp_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_LPNXP_EXT_PNr_ACKf_GET(r) ((((r).g_lpnxp_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_PNr_ACKf_SET(r,f) (r).g_lpnxp_ext_pn[0]=(((r).g_lpnxp_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_LPNXP_EXT_PNr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_LPNXP_EXT_PNr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext_pn[0]=(((r).g_lpnxp_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_LPNXP_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_LPNXP_EXT_PNr,(r._g_lpnxp_ext_pn),2)
#define BCM89500_A0_WRITE_G_LPNXP_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_LPNXP_EXT_PNr,&(r._g_lpnxp_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXT_PNr BCM89500_A0_G_LPNXP_EXT_PNr
#define G_LPNXP_EXT_PNr_SIZE BCM89500_A0_G_LPNXP_EXT_PNr_SIZE
typedef BCM89500_A0_G_LPNXP_EXT_PNr_t G_LPNXP_EXT_PNr_t;
#define G_LPNXP_EXT_PNr_CLR BCM89500_A0_G_LPNXP_EXT_PNr_CLR
#define G_LPNXP_EXT_PNr_SET BCM89500_A0_G_LPNXP_EXT_PNr_SET
#define G_LPNXP_EXT_PNr_GET BCM89500_A0_G_LPNXP_EXT_PNr_GET
#define G_LPNXP_EXT_PNr_CODE_FIELDf_GET BCM89500_A0_G_LPNXP_EXT_PNr_CODE_FIELDf_GET
#define G_LPNXP_EXT_PNr_CODE_FIELDf_SET BCM89500_A0_G_LPNXP_EXT_PNr_CODE_FIELDf_SET
#define G_LPNXP_EXT_PNr_TOGGLEf_GET BCM89500_A0_G_LPNXP_EXT_PNr_TOGGLEf_GET
#define G_LPNXP_EXT_PNr_TOGGLEf_SET BCM89500_A0_G_LPNXP_EXT_PNr_TOGGLEf_SET
#define G_LPNXP_EXT_PNr_ACKNOWLEDGE_2f_GET BCM89500_A0_G_LPNXP_EXT_PNr_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXT_PNr_ACKNOWLEDGE_2f_SET BCM89500_A0_G_LPNXP_EXT_PNr_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXT_PNr_MES_PAGEf_GET BCM89500_A0_G_LPNXP_EXT_PNr_MES_PAGEf_GET
#define G_LPNXP_EXT_PNr_MES_PAGEf_SET BCM89500_A0_G_LPNXP_EXT_PNr_MES_PAGEf_SET
#define G_LPNXP_EXT_PNr_ACKf_GET BCM89500_A0_G_LPNXP_EXT_PNr_ACKf_GET
#define G_LPNXP_EXT_PNr_ACKf_SET BCM89500_A0_G_LPNXP_EXT_PNr_ACKf_SET
#define G_LPNXP_EXT_PNr_NEXT_PAGEf_GET BCM89500_A0_G_LPNXP_EXT_PNr_NEXT_PAGEf_GET
#define G_LPNXP_EXT_PNr_NEXT_PAGEf_SET BCM89500_A0_G_LPNXP_EXT_PNr_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXT_PNr BCM89500_A0_READ_G_LPNXP_EXT_PNr
#define WRITE_G_LPNXP_EXT_PNr BCM89500_A0_WRITE_G_LPNXP_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_LPNXP_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_LPNXP_P7
 * BLOCKS:   SYS
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM89500_A0_G_LPNXP_P7r 0x00001710

#define BCM89500_A0_G_LPNXP_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_P7.
 *
 */
typedef union BCM89500_A0_G_LPNXP_P7r_s {
	uint32_t v[1];
	uint32_t g_lpnxp_p7[1];
	uint32_t _g_lpnxp_p7;
} BCM89500_A0_G_LPNXP_P7r_t;

#define BCM89500_A0_G_LPNXP_P7r_CLR(r) (r).g_lpnxp_p7[0] = 0
#define BCM89500_A0_G_LPNXP_P7r_SET(r,d) (r).g_lpnxp_p7[0] = d
#define BCM89500_A0_G_LPNXP_P7r_GET(r) (r).g_lpnxp_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_LPNXP_P7r_CODE_FIELDf_GET(r) ((((r).g_lpnxp_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_LPNXP_P7r_CODE_FIELDf_SET(r,f) (r).g_lpnxp_p7[0]=(((r).g_lpnxp_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_LPNXP_P7r_TOGGLEf_GET(r) ((((r).g_lpnxp_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_LPNXP_P7r_TOGGLEf_SET(r,f) (r).g_lpnxp_p7[0]=(((r).g_lpnxp_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_LPNXP_P7r_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_LPNXP_P7r_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_p7[0]=(((r).g_lpnxp_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_LPNXP_P7r_MES_PAGEf_GET(r) ((((r).g_lpnxp_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_LPNXP_P7r_MES_PAGEf_SET(r,f) (r).g_lpnxp_p7[0]=(((r).g_lpnxp_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_LPNXP_P7r_ACKf_GET(r) ((((r).g_lpnxp_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_LPNXP_P7r_ACKf_SET(r,f) (r).g_lpnxp_p7[0]=(((r).g_lpnxp_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_LPNXP_P7r_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_LPNXP_P7r_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_p7[0]=(((r).g_lpnxp_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_P7.
 *
 */
#define BCM89500_A0_READ_G_LPNXP_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_LPNXP_P7r,(r._g_lpnxp_p7),2)
#define BCM89500_A0_WRITE_G_LPNXP_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_LPNXP_P7r,&(r._g_lpnxp_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_P7r BCM89500_A0_G_LPNXP_P7r
#define G_LPNXP_P7r_SIZE BCM89500_A0_G_LPNXP_P7r_SIZE
typedef BCM89500_A0_G_LPNXP_P7r_t G_LPNXP_P7r_t;
#define G_LPNXP_P7r_CLR BCM89500_A0_G_LPNXP_P7r_CLR
#define G_LPNXP_P7r_SET BCM89500_A0_G_LPNXP_P7r_SET
#define G_LPNXP_P7r_GET BCM89500_A0_G_LPNXP_P7r_GET
#define G_LPNXP_P7r_CODE_FIELDf_GET BCM89500_A0_G_LPNXP_P7r_CODE_FIELDf_GET
#define G_LPNXP_P7r_CODE_FIELDf_SET BCM89500_A0_G_LPNXP_P7r_CODE_FIELDf_SET
#define G_LPNXP_P7r_TOGGLEf_GET BCM89500_A0_G_LPNXP_P7r_TOGGLEf_GET
#define G_LPNXP_P7r_TOGGLEf_SET BCM89500_A0_G_LPNXP_P7r_TOGGLEf_SET
#define G_LPNXP_P7r_ACKNOWLEDGE_2f_GET BCM89500_A0_G_LPNXP_P7r_ACKNOWLEDGE_2f_GET
#define G_LPNXP_P7r_ACKNOWLEDGE_2f_SET BCM89500_A0_G_LPNXP_P7r_ACKNOWLEDGE_2f_SET
#define G_LPNXP_P7r_MES_PAGEf_GET BCM89500_A0_G_LPNXP_P7r_MES_PAGEf_GET
#define G_LPNXP_P7r_MES_PAGEf_SET BCM89500_A0_G_LPNXP_P7r_MES_PAGEf_SET
#define G_LPNXP_P7r_ACKf_GET BCM89500_A0_G_LPNXP_P7r_ACKf_GET
#define G_LPNXP_P7r_ACKf_SET BCM89500_A0_G_LPNXP_P7r_ACKf_SET
#define G_LPNXP_P7r_NEXT_PAGEf_GET BCM89500_A0_G_LPNXP_P7r_NEXT_PAGEf_GET
#define G_LPNXP_P7r_NEXT_PAGEf_SET BCM89500_A0_G_LPNXP_P7r_NEXT_PAGEf_SET
#define READ_G_LPNXP_P7r BCM89500_A0_READ_G_LPNXP_P7r
#define WRITE_G_LPNXP_P7r BCM89500_A0_WRITE_G_LPNXP_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_LPNXP_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MASTER_SLAVE_SEED
 * BLOCKS:   SYS
 * DESC:     Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM89500_A0_G_MASTER_SLAVE_SEEDr 0x0000143a

#define BCM89500_A0_G_MASTER_SLAVE_SEEDr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED.
 *
 */
typedef union BCM89500_A0_G_MASTER_SLAVE_SEEDr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed[1];
	uint32_t _g_master_slave_seed;
} BCM89500_A0_G_MASTER_SLAVE_SEEDr_t;

#define BCM89500_A0_G_MASTER_SLAVE_SEEDr_CLR(r) (r).g_master_slave_seed[0] = 0
#define BCM89500_A0_G_MASTER_SLAVE_SEEDr_SET(r,d) (r).g_master_slave_seed[0] = d
#define BCM89500_A0_G_MASTER_SLAVE_SEEDr_GET(r) (r).g_master_slave_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MASTER_SLAVE_SEEDr_SEEDf_GET(r) (((r).g_master_slave_seed[0]) & 0xffff)
#define BCM89500_A0_G_MASTER_SLAVE_SEEDr_SEEDf_SET(r,f) (r).g_master_slave_seed[0]=(((r).g_master_slave_seed[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED.
 *
 */
#define BCM89500_A0_READ_G_MASTER_SLAVE_SEEDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MASTER_SLAVE_SEEDr,(r._g_master_slave_seed),2)
#define BCM89500_A0_WRITE_G_MASTER_SLAVE_SEEDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MASTER_SLAVE_SEEDr,&(r._g_master_slave_seed),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEEDr BCM89500_A0_G_MASTER_SLAVE_SEEDr
#define G_MASTER_SLAVE_SEEDr_SIZE BCM89500_A0_G_MASTER_SLAVE_SEEDr_SIZE
typedef BCM89500_A0_G_MASTER_SLAVE_SEEDr_t G_MASTER_SLAVE_SEEDr_t;
#define G_MASTER_SLAVE_SEEDr_CLR BCM89500_A0_G_MASTER_SLAVE_SEEDr_CLR
#define G_MASTER_SLAVE_SEEDr_SET BCM89500_A0_G_MASTER_SLAVE_SEEDr_SET
#define G_MASTER_SLAVE_SEEDr_GET BCM89500_A0_G_MASTER_SLAVE_SEEDr_GET
#define G_MASTER_SLAVE_SEEDr_SEEDf_GET BCM89500_A0_G_MASTER_SLAVE_SEEDr_SEEDf_GET
#define G_MASTER_SLAVE_SEEDr_SEEDf_SET BCM89500_A0_G_MASTER_SLAVE_SEEDr_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEEDr BCM89500_A0_READ_G_MASTER_SLAVE_SEEDr
#define WRITE_G_MASTER_SLAVE_SEEDr BCM89500_A0_WRITE_G_MASTER_SLAVE_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MASTER_SLAVE_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr 0x0000883a

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT.
 *
 */
typedef union BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext[1];
	uint32_t _g_master_slave_seed_ext;
} BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_t;

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_CLR(r) (r).g_master_slave_seed_ext[0] = 0
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SET(r,d) (r).g_master_slave_seed_ext[0] = d
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_GET(r) (r).g_master_slave_seed_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET(r) (((r).g_master_slave_seed_ext[0]) & 0xffff)
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET(r,f) (r).g_master_slave_seed_ext[0]=(((r).g_master_slave_seed_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT.
 *
 */
#define BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr,(r._g_master_slave_seed_ext),2)
#define BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr,&(r._g_master_slave_seed_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXTr BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr
#define G_MASTER_SLAVE_SEED_EXTr_SIZE BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE
typedef BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_t G_MASTER_SLAVE_SEED_EXTr_t;
#define G_MASTER_SLAVE_SEED_EXTr_CLR BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_CLR
#define G_MASTER_SLAVE_SEED_EXTr_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SET
#define G_MASTER_SLAVE_SEED_EXTr_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXTr BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXTr
#define WRITE_G_MASTER_SLAVE_SEED_EXTr BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MASTER_SLAVE_SEED_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r 0x0000843a

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext_p4[1];
	uint32_t _g_master_slave_seed_ext_p4;
} BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_t;

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_CLR(r) (r).g_master_slave_seed_ext_p4[0] = 0
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SET(r,d) (r).g_master_slave_seed_ext_p4[0] = d
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_GET(r) (r).g_master_slave_seed_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SEEDf_GET(r) (((r).g_master_slave_seed_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SEEDf_SET(r,f) (r).g_master_slave_seed_ext_p4[0]=(((r).g_master_slave_seed_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r,(r._g_master_slave_seed_ext_p4),2)
#define BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r,&(r._g_master_slave_seed_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXT_P4r BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r
#define G_MASTER_SLAVE_SEED_EXT_P4r_SIZE BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SIZE
typedef BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_t G_MASTER_SLAVE_SEED_EXT_P4r_t;
#define G_MASTER_SLAVE_SEED_EXT_P4r_CLR BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_CLR
#define G_MASTER_SLAVE_SEED_EXT_P4r_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SET
#define G_MASTER_SLAVE_SEED_EXT_P4r_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_GET
#define G_MASTER_SLAVE_SEED_EXT_P4r_SEEDf_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXT_P4r_SEEDf_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXT_P4r BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXT_P4r
#define WRITE_G_MASTER_SLAVE_SEED_EXT_P4r BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r 0x0000853a

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext_p5[1];
	uint32_t _g_master_slave_seed_ext_p5;
} BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_t;

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_CLR(r) (r).g_master_slave_seed_ext_p5[0] = 0
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SET(r,d) (r).g_master_slave_seed_ext_p5[0] = d
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_GET(r) (r).g_master_slave_seed_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEEDf_GET(r) (((r).g_master_slave_seed_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEEDf_SET(r,f) (r).g_master_slave_seed_ext_p5[0]=(((r).g_master_slave_seed_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r,(r._g_master_slave_seed_ext_p5),2)
#define BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r,&(r._g_master_slave_seed_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXT_P5r BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r
#define G_MASTER_SLAVE_SEED_EXT_P5r_SIZE BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SIZE
typedef BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_t G_MASTER_SLAVE_SEED_EXT_P5r_t;
#define G_MASTER_SLAVE_SEED_EXT_P5r_CLR BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_CLR
#define G_MASTER_SLAVE_SEED_EXT_P5r_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SET
#define G_MASTER_SLAVE_SEED_EXT_P5r_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_GET
#define G_MASTER_SLAVE_SEED_EXT_P5r_SEEDf_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXT_P5r_SEEDf_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXT_P5r BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXT_P5r
#define WRITE_G_MASTER_SLAVE_SEED_EXT_P5r BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr 0x0000803a

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext_pn[1];
	uint32_t _g_master_slave_seed_ext_pn;
} BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_t;

#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_CLR(r) (r).g_master_slave_seed_ext_pn[0] = 0
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SET(r,d) (r).g_master_slave_seed_ext_pn[0] = d
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_GET(r) (r).g_master_slave_seed_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SEEDf_GET(r) (((r).g_master_slave_seed_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SEEDf_SET(r,f) (r).g_master_slave_seed_ext_pn[0]=(((r).g_master_slave_seed_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr,(r._g_master_slave_seed_ext_pn),2)
#define BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr,&(r._g_master_slave_seed_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXT_PNr BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr
#define G_MASTER_SLAVE_SEED_EXT_PNr_SIZE BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SIZE
typedef BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_t G_MASTER_SLAVE_SEED_EXT_PNr_t;
#define G_MASTER_SLAVE_SEED_EXT_PNr_CLR BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_CLR
#define G_MASTER_SLAVE_SEED_EXT_PNr_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SET
#define G_MASTER_SLAVE_SEED_EXT_PNr_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_GET
#define G_MASTER_SLAVE_SEED_EXT_PNr_SEEDf_GET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXT_PNr_SEEDf_SET BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXT_PNr BCM89500_A0_READ_G_MASTER_SLAVE_SEED_EXT_PNr
#define WRITE_G_MASTER_SLAVE_SEED_EXT_PNr BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MASTER_SLAVE_SEED_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_P7
 * BLOCKS:   SYS
 * DESC:     Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r 0x0000173a

#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_P7.
 *
 */
typedef union BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_p7[1];
	uint32_t _g_master_slave_seed_p7;
} BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_t;

#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_CLR(r) (r).g_master_slave_seed_p7[0] = 0
#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SET(r,d) (r).g_master_slave_seed_p7[0] = d
#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_GET(r) (r).g_master_slave_seed_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SEEDf_GET(r) (((r).g_master_slave_seed_p7[0]) & 0xffff)
#define BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SEEDf_SET(r,f) (r).g_master_slave_seed_p7[0]=(((r).g_master_slave_seed_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_P7.
 *
 */
#define BCM89500_A0_READ_G_MASTER_SLAVE_SEED_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MASTER_SLAVE_SEED_P7r,(r._g_master_slave_seed_p7),2)
#define BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MASTER_SLAVE_SEED_P7r,&(r._g_master_slave_seed_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_P7r BCM89500_A0_G_MASTER_SLAVE_SEED_P7r
#define G_MASTER_SLAVE_SEED_P7r_SIZE BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SIZE
typedef BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_t G_MASTER_SLAVE_SEED_P7r_t;
#define G_MASTER_SLAVE_SEED_P7r_CLR BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_CLR
#define G_MASTER_SLAVE_SEED_P7r_SET BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SET
#define G_MASTER_SLAVE_SEED_P7r_GET BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_GET
#define G_MASTER_SLAVE_SEED_P7r_SEEDf_GET BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SEEDf_GET
#define G_MASTER_SLAVE_SEED_P7r_SEEDf_SET BCM89500_A0_G_MASTER_SLAVE_SEED_P7r_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_P7r BCM89500_A0_READ_G_MASTER_SLAVE_SEED_P7r
#define WRITE_G_MASTER_SLAVE_SEED_P7r BCM89500_A0_WRITE_G_MASTER_SLAVE_SEED_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MASTER_SLAVE_SEED_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIICTL
 * BLOCKS:   SYS
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     UNIDIRECTIONAL_ENABLE valid when bit12=0, and bit8=11 = able to transmit packets when no link0 = requires link in order to transmit packets
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIICTLr 0x00001400

#define BCM89500_A0_G_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL.
 *
 */
typedef union BCM89500_A0_G_MIICTLr_s {
	uint32_t v[1];
	uint32_t g_miictl[1];
	uint32_t _g_miictl;
} BCM89500_A0_G_MIICTLr_t;

#define BCM89500_A0_G_MIICTLr_CLR(r) (r).g_miictl[0] = 0
#define BCM89500_A0_G_MIICTLr_SET(r,d) (r).g_miictl[0] = d
#define BCM89500_A0_G_MIICTLr_GET(r) (r).g_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIICTLr_RESERVEDf_GET(r) (((r).g_miictl[0]) & 0x1f)
#define BCM89500_A0_G_MIICTLr_RESERVEDf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_G_MIICTLr_UNIDIRECTIONAL_ENABLEf_GET(r) ((((r).g_miictl[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIICTLr_UNIDIRECTIONAL_ENABLEf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIICTLr_COL_TESTf_GET(r) ((((r).g_miictl[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIICTLr_COL_TESTf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIICTLr_DUPLEX_MODf_GET(r) ((((r).g_miictl[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIICTLr_DUPLEX_MODf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIICTLr_RE_ANf_GET(r) ((((r).g_miictl[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIICTLr_RE_ANf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIICTLr_ISOLATEf_GET(r) ((((r).g_miictl[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIICTLr_ISOLATEf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIICTLr_PWR_DOWNf_GET(r) ((((r).g_miictl[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIICTLr_PWR_DOWNf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIICTLr_AN_ENf_GET(r) ((((r).g_miictl[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIICTLr_AN_ENf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIICTLr_LOOPBACKf_GET(r) ((((r).g_miictl[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIICTLr_LOOPBACKf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIICTLr_RESETf_GET(r) ((((r).g_miictl[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIICTLr_RESETf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL.
 *
 */
#define BCM89500_A0_READ_G_MIICTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIICTLr,(r._g_miictl),2)
#define BCM89500_A0_WRITE_G_MIICTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIICTLr,&(r._g_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTLr BCM89500_A0_G_MIICTLr
#define G_MIICTLr_SIZE BCM89500_A0_G_MIICTLr_SIZE
typedef BCM89500_A0_G_MIICTLr_t G_MIICTLr_t;
#define G_MIICTLr_CLR BCM89500_A0_G_MIICTLr_CLR
#define G_MIICTLr_SET BCM89500_A0_G_MIICTLr_SET
#define G_MIICTLr_GET BCM89500_A0_G_MIICTLr_GET
#define G_MIICTLr_RESERVEDf_GET BCM89500_A0_G_MIICTLr_RESERVEDf_GET
#define G_MIICTLr_RESERVEDf_SET BCM89500_A0_G_MIICTLr_RESERVEDf_SET
#define G_MIICTLr_UNIDIRECTIONAL_ENABLEf_GET BCM89500_A0_G_MIICTLr_UNIDIRECTIONAL_ENABLEf_GET
#define G_MIICTLr_UNIDIRECTIONAL_ENABLEf_SET BCM89500_A0_G_MIICTLr_UNIDIRECTIONAL_ENABLEf_SET
#define G_MIICTLr_SPD_SEL_MSBf_GET BCM89500_A0_G_MIICTLr_SPD_SEL_MSBf_GET
#define G_MIICTLr_SPD_SEL_MSBf_SET BCM89500_A0_G_MIICTLr_SPD_SEL_MSBf_SET
#define G_MIICTLr_COL_TESTf_GET BCM89500_A0_G_MIICTLr_COL_TESTf_GET
#define G_MIICTLr_COL_TESTf_SET BCM89500_A0_G_MIICTLr_COL_TESTf_SET
#define G_MIICTLr_DUPLEX_MODf_GET BCM89500_A0_G_MIICTLr_DUPLEX_MODf_GET
#define G_MIICTLr_DUPLEX_MODf_SET BCM89500_A0_G_MIICTLr_DUPLEX_MODf_SET
#define G_MIICTLr_RE_ANf_GET BCM89500_A0_G_MIICTLr_RE_ANf_GET
#define G_MIICTLr_RE_ANf_SET BCM89500_A0_G_MIICTLr_RE_ANf_SET
#define G_MIICTLr_ISOLATEf_GET BCM89500_A0_G_MIICTLr_ISOLATEf_GET
#define G_MIICTLr_ISOLATEf_SET BCM89500_A0_G_MIICTLr_ISOLATEf_SET
#define G_MIICTLr_PWR_DOWNf_GET BCM89500_A0_G_MIICTLr_PWR_DOWNf_GET
#define G_MIICTLr_PWR_DOWNf_SET BCM89500_A0_G_MIICTLr_PWR_DOWNf_SET
#define G_MIICTLr_AN_ENf_GET BCM89500_A0_G_MIICTLr_AN_ENf_GET
#define G_MIICTLr_AN_ENf_SET BCM89500_A0_G_MIICTLr_AN_ENf_SET
#define G_MIICTLr_SPD_SEL_LSBf_GET BCM89500_A0_G_MIICTLr_SPD_SEL_LSBf_GET
#define G_MIICTLr_SPD_SEL_LSBf_SET BCM89500_A0_G_MIICTLr_SPD_SEL_LSBf_SET
#define G_MIICTLr_LOOPBACKf_GET BCM89500_A0_G_MIICTLr_LOOPBACKf_GET
#define G_MIICTLr_LOOPBACKf_SET BCM89500_A0_G_MIICTLr_LOOPBACKf_SET
#define G_MIICTLr_RESETf_GET BCM89500_A0_G_MIICTLr_RESETf_GET
#define G_MIICTLr_RESETf_SET BCM89500_A0_G_MIICTLr_RESETf_SET
#define READ_G_MIICTLr BCM89500_A0_READ_G_MIICTLr
#define WRITE_G_MIICTLr BCM89500_A0_WRITE_G_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIICTL_EXT
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIICTL_EXTr 0x00008800

#define BCM89500_A0_G_MIICTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT.
 *
 */
typedef union BCM89500_A0_G_MIICTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_miictl_ext[1];
	uint32_t _g_miictl_ext;
} BCM89500_A0_G_MIICTL_EXTr_t;

#define BCM89500_A0_G_MIICTL_EXTr_CLR(r) (r).g_miictl_ext[0] = 0
#define BCM89500_A0_G_MIICTL_EXTr_SET(r,d) (r).g_miictl_ext[0] = d
#define BCM89500_A0_G_MIICTL_EXTr_GET(r) (r).g_miictl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIICTL_EXTr_RESERVEDf_GET(r) (((r).g_miictl_ext[0]) & 0x3f)
#define BCM89500_A0_G_MIICTL_EXTr_RESERVEDf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIICTL_EXTr_COL_TESTf_GET(r) ((((r).g_miictl_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_COL_TESTf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIICTL_EXTr_RE_ANf_GET(r) ((((r).g_miictl_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_RE_ANf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIICTL_EXTr_ISOLATEf_GET(r) ((((r).g_miictl_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_ISOLATEf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIICTL_EXTr_PWR_DOWNf_GET(r) ((((r).g_miictl_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_PWR_DOWNf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIICTL_EXTr_AN_ENf_GET(r) ((((r).g_miictl_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_AN_ENf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIICTL_EXTr_LOOPBACKf_GET(r) ((((r).g_miictl_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_LOOPBACKf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIICTL_EXTr_RESETf_GET(r) ((((r).g_miictl_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIICTL_EXTr_RESETf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT.
 *
 */
#define BCM89500_A0_READ_G_MIICTL_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIICTL_EXTr,(r._g_miictl_ext),2)
#define BCM89500_A0_WRITE_G_MIICTL_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIICTL_EXTr,&(r._g_miictl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXTr BCM89500_A0_G_MIICTL_EXTr
#define G_MIICTL_EXTr_SIZE BCM89500_A0_G_MIICTL_EXTr_SIZE
typedef BCM89500_A0_G_MIICTL_EXTr_t G_MIICTL_EXTr_t;
#define G_MIICTL_EXTr_CLR BCM89500_A0_G_MIICTL_EXTr_CLR
#define G_MIICTL_EXTr_SET BCM89500_A0_G_MIICTL_EXTr_SET
#define G_MIICTL_EXTr_GET BCM89500_A0_G_MIICTL_EXTr_GET
#define G_MIICTL_EXTr_RESERVEDf_GET BCM89500_A0_G_MIICTL_EXTr_RESERVEDf_GET
#define G_MIICTL_EXTr_RESERVEDf_SET BCM89500_A0_G_MIICTL_EXTr_RESERVEDf_SET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_GET BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_SET BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET
#define G_MIICTL_EXTr_COL_TESTf_GET BCM89500_A0_G_MIICTL_EXTr_COL_TESTf_GET
#define G_MIICTL_EXTr_COL_TESTf_SET BCM89500_A0_G_MIICTL_EXTr_COL_TESTf_SET
#define G_MIICTL_EXTr_DUPLEX_MODf_GET BCM89500_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET
#define G_MIICTL_EXTr_DUPLEX_MODf_SET BCM89500_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET
#define G_MIICTL_EXTr_RE_ANf_GET BCM89500_A0_G_MIICTL_EXTr_RE_ANf_GET
#define G_MIICTL_EXTr_RE_ANf_SET BCM89500_A0_G_MIICTL_EXTr_RE_ANf_SET
#define G_MIICTL_EXTr_ISOLATEf_GET BCM89500_A0_G_MIICTL_EXTr_ISOLATEf_GET
#define G_MIICTL_EXTr_ISOLATEf_SET BCM89500_A0_G_MIICTL_EXTr_ISOLATEf_SET
#define G_MIICTL_EXTr_PWR_DOWNf_GET BCM89500_A0_G_MIICTL_EXTr_PWR_DOWNf_GET
#define G_MIICTL_EXTr_PWR_DOWNf_SET BCM89500_A0_G_MIICTL_EXTr_PWR_DOWNf_SET
#define G_MIICTL_EXTr_AN_ENf_GET BCM89500_A0_G_MIICTL_EXTr_AN_ENf_GET
#define G_MIICTL_EXTr_AN_ENf_SET BCM89500_A0_G_MIICTL_EXTr_AN_ENf_SET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_GET BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_SET BCM89500_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET
#define G_MIICTL_EXTr_LOOPBACKf_GET BCM89500_A0_G_MIICTL_EXTr_LOOPBACKf_GET
#define G_MIICTL_EXTr_LOOPBACKf_SET BCM89500_A0_G_MIICTL_EXTr_LOOPBACKf_SET
#define G_MIICTL_EXTr_RESETf_GET BCM89500_A0_G_MIICTL_EXTr_RESETf_GET
#define G_MIICTL_EXTr_RESETf_SET BCM89500_A0_G_MIICTL_EXTr_RESETf_SET
#define READ_G_MIICTL_EXTr BCM89500_A0_READ_G_MIICTL_EXTr
#define WRITE_G_MIICTL_EXTr BCM89500_A0_WRITE_G_MIICTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIICTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIICTL_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIICTL_EXT_P4r 0x00008400

#define BCM89500_A0_G_MIICTL_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_MIICTL_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_miictl_ext_p4[1];
	uint32_t _g_miictl_ext_p4;
} BCM89500_A0_G_MIICTL_EXT_P4r_t;

#define BCM89500_A0_G_MIICTL_EXT_P4r_CLR(r) (r).g_miictl_ext_p4[0] = 0
#define BCM89500_A0_G_MIICTL_EXT_P4r_SET(r,d) (r).g_miictl_ext_p4[0] = d
#define BCM89500_A0_G_MIICTL_EXT_P4r_GET(r) (r).g_miictl_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIICTL_EXT_P4r_RESERVEDf_GET(r) (((r).g_miictl_ext_p4[0]) & 0x3f)
#define BCM89500_A0_G_MIICTL_EXT_P4r_RESERVEDf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIICTL_EXT_P4r_COL_TESTf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_COL_TESTf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIICTL_EXT_P4r_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIICTL_EXT_P4r_RE_ANf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_RE_ANf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIICTL_EXT_P4r_ISOLATEf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_ISOLATEf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIICTL_EXT_P4r_PWR_DOWNf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_PWR_DOWNf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIICTL_EXT_P4r_AN_ENf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_AN_ENf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIICTL_EXT_P4r_LOOPBACKf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_LOOPBACKf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIICTL_EXT_P4r_RESETf_GET(r) ((((r).g_miictl_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P4r_RESETf_SET(r,f) (r).g_miictl_ext_p4[0]=(((r).g_miictl_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_MIICTL_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIICTL_EXT_P4r,(r._g_miictl_ext_p4),2)
#define BCM89500_A0_WRITE_G_MIICTL_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIICTL_EXT_P4r,&(r._g_miictl_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXT_P4r BCM89500_A0_G_MIICTL_EXT_P4r
#define G_MIICTL_EXT_P4r_SIZE BCM89500_A0_G_MIICTL_EXT_P4r_SIZE
typedef BCM89500_A0_G_MIICTL_EXT_P4r_t G_MIICTL_EXT_P4r_t;
#define G_MIICTL_EXT_P4r_CLR BCM89500_A0_G_MIICTL_EXT_P4r_CLR
#define G_MIICTL_EXT_P4r_SET BCM89500_A0_G_MIICTL_EXT_P4r_SET
#define G_MIICTL_EXT_P4r_GET BCM89500_A0_G_MIICTL_EXT_P4r_GET
#define G_MIICTL_EXT_P4r_RESERVEDf_GET BCM89500_A0_G_MIICTL_EXT_P4r_RESERVEDf_GET
#define G_MIICTL_EXT_P4r_RESERVEDf_SET BCM89500_A0_G_MIICTL_EXT_P4r_RESERVEDf_SET
#define G_MIICTL_EXT_P4r_SPD_SEL_MSBf_GET BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_MSBf_GET
#define G_MIICTL_EXT_P4r_SPD_SEL_MSBf_SET BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_MSBf_SET
#define G_MIICTL_EXT_P4r_COL_TESTf_GET BCM89500_A0_G_MIICTL_EXT_P4r_COL_TESTf_GET
#define G_MIICTL_EXT_P4r_COL_TESTf_SET BCM89500_A0_G_MIICTL_EXT_P4r_COL_TESTf_SET
#define G_MIICTL_EXT_P4r_DUPLEX_MODf_GET BCM89500_A0_G_MIICTL_EXT_P4r_DUPLEX_MODf_GET
#define G_MIICTL_EXT_P4r_DUPLEX_MODf_SET BCM89500_A0_G_MIICTL_EXT_P4r_DUPLEX_MODf_SET
#define G_MIICTL_EXT_P4r_RE_ANf_GET BCM89500_A0_G_MIICTL_EXT_P4r_RE_ANf_GET
#define G_MIICTL_EXT_P4r_RE_ANf_SET BCM89500_A0_G_MIICTL_EXT_P4r_RE_ANf_SET
#define G_MIICTL_EXT_P4r_ISOLATEf_GET BCM89500_A0_G_MIICTL_EXT_P4r_ISOLATEf_GET
#define G_MIICTL_EXT_P4r_ISOLATEf_SET BCM89500_A0_G_MIICTL_EXT_P4r_ISOLATEf_SET
#define G_MIICTL_EXT_P4r_PWR_DOWNf_GET BCM89500_A0_G_MIICTL_EXT_P4r_PWR_DOWNf_GET
#define G_MIICTL_EXT_P4r_PWR_DOWNf_SET BCM89500_A0_G_MIICTL_EXT_P4r_PWR_DOWNf_SET
#define G_MIICTL_EXT_P4r_AN_ENf_GET BCM89500_A0_G_MIICTL_EXT_P4r_AN_ENf_GET
#define G_MIICTL_EXT_P4r_AN_ENf_SET BCM89500_A0_G_MIICTL_EXT_P4r_AN_ENf_SET
#define G_MIICTL_EXT_P4r_SPD_SEL_LSBf_GET BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_LSBf_GET
#define G_MIICTL_EXT_P4r_SPD_SEL_LSBf_SET BCM89500_A0_G_MIICTL_EXT_P4r_SPD_SEL_LSBf_SET
#define G_MIICTL_EXT_P4r_LOOPBACKf_GET BCM89500_A0_G_MIICTL_EXT_P4r_LOOPBACKf_GET
#define G_MIICTL_EXT_P4r_LOOPBACKf_SET BCM89500_A0_G_MIICTL_EXT_P4r_LOOPBACKf_SET
#define G_MIICTL_EXT_P4r_RESETf_GET BCM89500_A0_G_MIICTL_EXT_P4r_RESETf_GET
#define G_MIICTL_EXT_P4r_RESETf_SET BCM89500_A0_G_MIICTL_EXT_P4r_RESETf_SET
#define READ_G_MIICTL_EXT_P4r BCM89500_A0_READ_G_MIICTL_EXT_P4r
#define WRITE_G_MIICTL_EXT_P4r BCM89500_A0_WRITE_G_MIICTL_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIICTL_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIICTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIICTL_EXT_P5r 0x00008500

#define BCM89500_A0_G_MIICTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_MIICTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_miictl_ext_p5[1];
	uint32_t _g_miictl_ext_p5;
} BCM89500_A0_G_MIICTL_EXT_P5r_t;

#define BCM89500_A0_G_MIICTL_EXT_P5r_CLR(r) (r).g_miictl_ext_p5[0] = 0
#define BCM89500_A0_G_MIICTL_EXT_P5r_SET(r,d) (r).g_miictl_ext_p5[0] = d
#define BCM89500_A0_G_MIICTL_EXT_P5r_GET(r) (r).g_miictl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIICTL_EXT_P5r_RESERVEDf_GET(r) (((r).g_miictl_ext_p5[0]) & 0x3f)
#define BCM89500_A0_G_MIICTL_EXT_P5r_RESERVEDf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIICTL_EXT_P5r_COL_TESTf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_COL_TESTf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIICTL_EXT_P5r_RE_ANf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_RE_ANf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIICTL_EXT_P5r_ISOLATEf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_ISOLATEf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIICTL_EXT_P5r_AN_ENf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_AN_ENf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIICTL_EXT_P5r_LOOPBACKf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_LOOPBACKf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIICTL_EXT_P5r_RESETf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_P5r_RESETf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_MIICTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIICTL_EXT_P5r,(r._g_miictl_ext_p5),2)
#define BCM89500_A0_WRITE_G_MIICTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIICTL_EXT_P5r,&(r._g_miictl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXT_P5r BCM89500_A0_G_MIICTL_EXT_P5r
#define G_MIICTL_EXT_P5r_SIZE BCM89500_A0_G_MIICTL_EXT_P5r_SIZE
typedef BCM89500_A0_G_MIICTL_EXT_P5r_t G_MIICTL_EXT_P5r_t;
#define G_MIICTL_EXT_P5r_CLR BCM89500_A0_G_MIICTL_EXT_P5r_CLR
#define G_MIICTL_EXT_P5r_SET BCM89500_A0_G_MIICTL_EXT_P5r_SET
#define G_MIICTL_EXT_P5r_GET BCM89500_A0_G_MIICTL_EXT_P5r_GET
#define G_MIICTL_EXT_P5r_RESERVEDf_GET BCM89500_A0_G_MIICTL_EXT_P5r_RESERVEDf_GET
#define G_MIICTL_EXT_P5r_RESERVEDf_SET BCM89500_A0_G_MIICTL_EXT_P5r_RESERVEDf_SET
#define G_MIICTL_EXT_P5r_SPD_SEL_MSBf_GET BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_GET
#define G_MIICTL_EXT_P5r_SPD_SEL_MSBf_SET BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_SET
#define G_MIICTL_EXT_P5r_COL_TESTf_GET BCM89500_A0_G_MIICTL_EXT_P5r_COL_TESTf_GET
#define G_MIICTL_EXT_P5r_COL_TESTf_SET BCM89500_A0_G_MIICTL_EXT_P5r_COL_TESTf_SET
#define G_MIICTL_EXT_P5r_DUPLEX_MODf_GET BCM89500_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_GET
#define G_MIICTL_EXT_P5r_DUPLEX_MODf_SET BCM89500_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_SET
#define G_MIICTL_EXT_P5r_RE_ANf_GET BCM89500_A0_G_MIICTL_EXT_P5r_RE_ANf_GET
#define G_MIICTL_EXT_P5r_RE_ANf_SET BCM89500_A0_G_MIICTL_EXT_P5r_RE_ANf_SET
#define G_MIICTL_EXT_P5r_ISOLATEf_GET BCM89500_A0_G_MIICTL_EXT_P5r_ISOLATEf_GET
#define G_MIICTL_EXT_P5r_ISOLATEf_SET BCM89500_A0_G_MIICTL_EXT_P5r_ISOLATEf_SET
#define G_MIICTL_EXT_P5r_PWR_DOWNf_GET BCM89500_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_GET
#define G_MIICTL_EXT_P5r_PWR_DOWNf_SET BCM89500_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_SET
#define G_MIICTL_EXT_P5r_AN_ENf_GET BCM89500_A0_G_MIICTL_EXT_P5r_AN_ENf_GET
#define G_MIICTL_EXT_P5r_AN_ENf_SET BCM89500_A0_G_MIICTL_EXT_P5r_AN_ENf_SET
#define G_MIICTL_EXT_P5r_SPD_SEL_LSBf_GET BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_GET
#define G_MIICTL_EXT_P5r_SPD_SEL_LSBf_SET BCM89500_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_SET
#define G_MIICTL_EXT_P5r_LOOPBACKf_GET BCM89500_A0_G_MIICTL_EXT_P5r_LOOPBACKf_GET
#define G_MIICTL_EXT_P5r_LOOPBACKf_SET BCM89500_A0_G_MIICTL_EXT_P5r_LOOPBACKf_SET
#define G_MIICTL_EXT_P5r_RESETf_GET BCM89500_A0_G_MIICTL_EXT_P5r_RESETf_GET
#define G_MIICTL_EXT_P5r_RESETf_SET BCM89500_A0_G_MIICTL_EXT_P5r_RESETf_SET
#define READ_G_MIICTL_EXT_P5r BCM89500_A0_READ_G_MIICTL_EXT_P5r
#define WRITE_G_MIICTL_EXT_P5r BCM89500_A0_WRITE_G_MIICTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIICTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIICTL_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIICTL_EXT_PNr 0x00008000

#define BCM89500_A0_G_MIICTL_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_MIICTL_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_miictl_ext_pn[1];
	uint32_t _g_miictl_ext_pn;
} BCM89500_A0_G_MIICTL_EXT_PNr_t;

#define BCM89500_A0_G_MIICTL_EXT_PNr_CLR(r) (r).g_miictl_ext_pn[0] = 0
#define BCM89500_A0_G_MIICTL_EXT_PNr_SET(r,d) (r).g_miictl_ext_pn[0] = d
#define BCM89500_A0_G_MIICTL_EXT_PNr_GET(r) (r).g_miictl_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIICTL_EXT_PNr_RESERVEDf_GET(r) (((r).g_miictl_ext_pn[0]) & 0x3f)
#define BCM89500_A0_G_MIICTL_EXT_PNr_RESERVEDf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIICTL_EXT_PNr_COL_TESTf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_COL_TESTf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIICTL_EXT_PNr_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIICTL_EXT_PNr_RE_ANf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_RE_ANf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIICTL_EXT_PNr_ISOLATEf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_ISOLATEf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIICTL_EXT_PNr_PWR_DOWNf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_PWR_DOWNf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIICTL_EXT_PNr_AN_ENf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_AN_ENf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIICTL_EXT_PNr_LOOPBACKf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_LOOPBACKf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIICTL_EXT_PNr_RESETf_GET(r) ((((r).g_miictl_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIICTL_EXT_PNr_RESETf_SET(r,f) (r).g_miictl_ext_pn[0]=(((r).g_miictl_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_MIICTL_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_MIICTL_EXT_PNr,(r._g_miictl_ext_pn),2)
#define BCM89500_A0_WRITE_G_MIICTL_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_MIICTL_EXT_PNr,&(r._g_miictl_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXT_PNr BCM89500_A0_G_MIICTL_EXT_PNr
#define G_MIICTL_EXT_PNr_SIZE BCM89500_A0_G_MIICTL_EXT_PNr_SIZE
typedef BCM89500_A0_G_MIICTL_EXT_PNr_t G_MIICTL_EXT_PNr_t;
#define G_MIICTL_EXT_PNr_CLR BCM89500_A0_G_MIICTL_EXT_PNr_CLR
#define G_MIICTL_EXT_PNr_SET BCM89500_A0_G_MIICTL_EXT_PNr_SET
#define G_MIICTL_EXT_PNr_GET BCM89500_A0_G_MIICTL_EXT_PNr_GET
#define G_MIICTL_EXT_PNr_RESERVEDf_GET BCM89500_A0_G_MIICTL_EXT_PNr_RESERVEDf_GET
#define G_MIICTL_EXT_PNr_RESERVEDf_SET BCM89500_A0_G_MIICTL_EXT_PNr_RESERVEDf_SET
#define G_MIICTL_EXT_PNr_SPD_SEL_MSBf_GET BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_MSBf_GET
#define G_MIICTL_EXT_PNr_SPD_SEL_MSBf_SET BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_MSBf_SET
#define G_MIICTL_EXT_PNr_COL_TESTf_GET BCM89500_A0_G_MIICTL_EXT_PNr_COL_TESTf_GET
#define G_MIICTL_EXT_PNr_COL_TESTf_SET BCM89500_A0_G_MIICTL_EXT_PNr_COL_TESTf_SET
#define G_MIICTL_EXT_PNr_DUPLEX_MODf_GET BCM89500_A0_G_MIICTL_EXT_PNr_DUPLEX_MODf_GET
#define G_MIICTL_EXT_PNr_DUPLEX_MODf_SET BCM89500_A0_G_MIICTL_EXT_PNr_DUPLEX_MODf_SET
#define G_MIICTL_EXT_PNr_RE_ANf_GET BCM89500_A0_G_MIICTL_EXT_PNr_RE_ANf_GET
#define G_MIICTL_EXT_PNr_RE_ANf_SET BCM89500_A0_G_MIICTL_EXT_PNr_RE_ANf_SET
#define G_MIICTL_EXT_PNr_ISOLATEf_GET BCM89500_A0_G_MIICTL_EXT_PNr_ISOLATEf_GET
#define G_MIICTL_EXT_PNr_ISOLATEf_SET BCM89500_A0_G_MIICTL_EXT_PNr_ISOLATEf_SET
#define G_MIICTL_EXT_PNr_PWR_DOWNf_GET BCM89500_A0_G_MIICTL_EXT_PNr_PWR_DOWNf_GET
#define G_MIICTL_EXT_PNr_PWR_DOWNf_SET BCM89500_A0_G_MIICTL_EXT_PNr_PWR_DOWNf_SET
#define G_MIICTL_EXT_PNr_AN_ENf_GET BCM89500_A0_G_MIICTL_EXT_PNr_AN_ENf_GET
#define G_MIICTL_EXT_PNr_AN_ENf_SET BCM89500_A0_G_MIICTL_EXT_PNr_AN_ENf_SET
#define G_MIICTL_EXT_PNr_SPD_SEL_LSBf_GET BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_LSBf_GET
#define G_MIICTL_EXT_PNr_SPD_SEL_LSBf_SET BCM89500_A0_G_MIICTL_EXT_PNr_SPD_SEL_LSBf_SET
#define G_MIICTL_EXT_PNr_LOOPBACKf_GET BCM89500_A0_G_MIICTL_EXT_PNr_LOOPBACKf_GET
#define G_MIICTL_EXT_PNr_LOOPBACKf_SET BCM89500_A0_G_MIICTL_EXT_PNr_LOOPBACKf_SET
#define G_MIICTL_EXT_PNr_RESETf_GET BCM89500_A0_G_MIICTL_EXT_PNr_RESETf_GET
#define G_MIICTL_EXT_PNr_RESETf_SET BCM89500_A0_G_MIICTL_EXT_PNr_RESETf_SET
#define READ_G_MIICTL_EXT_PNr BCM89500_A0_READ_G_MIICTL_EXT_PNr
#define WRITE_G_MIICTL_EXT_PNr BCM89500_A0_WRITE_G_MIICTL_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIICTL_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIICTL_P7
 * BLOCKS:   SYS
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIICTL_P7r 0x00001700

#define BCM89500_A0_G_MIICTL_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_P7.
 *
 */
typedef union BCM89500_A0_G_MIICTL_P7r_s {
	uint32_t v[1];
	uint32_t g_miictl_p7[1];
	uint32_t _g_miictl_p7;
} BCM89500_A0_G_MIICTL_P7r_t;

#define BCM89500_A0_G_MIICTL_P7r_CLR(r) (r).g_miictl_p7[0] = 0
#define BCM89500_A0_G_MIICTL_P7r_SET(r,d) (r).g_miictl_p7[0] = d
#define BCM89500_A0_G_MIICTL_P7r_GET(r) (r).g_miictl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIICTL_P7r_RESERVEDf_GET(r) (((r).g_miictl_p7[0]) & 0x3f)
#define BCM89500_A0_G_MIICTL_P7r_RESERVEDf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_G_MIICTL_P7r_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIICTL_P7r_COL_TESTf_GET(r) ((((r).g_miictl_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_COL_TESTf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIICTL_P7r_DUPLEX_MODf_GET(r) ((((r).g_miictl_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_DUPLEX_MODf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIICTL_P7r_RE_ANf_GET(r) ((((r).g_miictl_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_RE_ANf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIICTL_P7r_ISOLATEf_GET(r) ((((r).g_miictl_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_ISOLATEf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIICTL_P7r_PWR_DOWNf_GET(r) ((((r).g_miictl_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_PWR_DOWNf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIICTL_P7r_AN_ENf_GET(r) ((((r).g_miictl_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_AN_ENf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIICTL_P7r_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIICTL_P7r_LOOPBACKf_GET(r) ((((r).g_miictl_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_LOOPBACKf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIICTL_P7r_RESETf_GET(r) ((((r).g_miictl_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIICTL_P7r_RESETf_SET(r,f) (r).g_miictl_p7[0]=(((r).g_miictl_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_P7.
 *
 */
#define BCM89500_A0_READ_G_MIICTL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIICTL_P7r,(r._g_miictl_p7),2)
#define BCM89500_A0_WRITE_G_MIICTL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIICTL_P7r,&(r._g_miictl_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_P7r BCM89500_A0_G_MIICTL_P7r
#define G_MIICTL_P7r_SIZE BCM89500_A0_G_MIICTL_P7r_SIZE
typedef BCM89500_A0_G_MIICTL_P7r_t G_MIICTL_P7r_t;
#define G_MIICTL_P7r_CLR BCM89500_A0_G_MIICTL_P7r_CLR
#define G_MIICTL_P7r_SET BCM89500_A0_G_MIICTL_P7r_SET
#define G_MIICTL_P7r_GET BCM89500_A0_G_MIICTL_P7r_GET
#define G_MIICTL_P7r_RESERVEDf_GET BCM89500_A0_G_MIICTL_P7r_RESERVEDf_GET
#define G_MIICTL_P7r_RESERVEDf_SET BCM89500_A0_G_MIICTL_P7r_RESERVEDf_SET
#define G_MIICTL_P7r_SPD_SEL_MSBf_GET BCM89500_A0_G_MIICTL_P7r_SPD_SEL_MSBf_GET
#define G_MIICTL_P7r_SPD_SEL_MSBf_SET BCM89500_A0_G_MIICTL_P7r_SPD_SEL_MSBf_SET
#define G_MIICTL_P7r_COL_TESTf_GET BCM89500_A0_G_MIICTL_P7r_COL_TESTf_GET
#define G_MIICTL_P7r_COL_TESTf_SET BCM89500_A0_G_MIICTL_P7r_COL_TESTf_SET
#define G_MIICTL_P7r_DUPLEX_MODf_GET BCM89500_A0_G_MIICTL_P7r_DUPLEX_MODf_GET
#define G_MIICTL_P7r_DUPLEX_MODf_SET BCM89500_A0_G_MIICTL_P7r_DUPLEX_MODf_SET
#define G_MIICTL_P7r_RE_ANf_GET BCM89500_A0_G_MIICTL_P7r_RE_ANf_GET
#define G_MIICTL_P7r_RE_ANf_SET BCM89500_A0_G_MIICTL_P7r_RE_ANf_SET
#define G_MIICTL_P7r_ISOLATEf_GET BCM89500_A0_G_MIICTL_P7r_ISOLATEf_GET
#define G_MIICTL_P7r_ISOLATEf_SET BCM89500_A0_G_MIICTL_P7r_ISOLATEf_SET
#define G_MIICTL_P7r_PWR_DOWNf_GET BCM89500_A0_G_MIICTL_P7r_PWR_DOWNf_GET
#define G_MIICTL_P7r_PWR_DOWNf_SET BCM89500_A0_G_MIICTL_P7r_PWR_DOWNf_SET
#define G_MIICTL_P7r_AN_ENf_GET BCM89500_A0_G_MIICTL_P7r_AN_ENf_GET
#define G_MIICTL_P7r_AN_ENf_SET BCM89500_A0_G_MIICTL_P7r_AN_ENf_SET
#define G_MIICTL_P7r_SPD_SEL_LSBf_GET BCM89500_A0_G_MIICTL_P7r_SPD_SEL_LSBf_GET
#define G_MIICTL_P7r_SPD_SEL_LSBf_SET BCM89500_A0_G_MIICTL_P7r_SPD_SEL_LSBf_SET
#define G_MIICTL_P7r_LOOPBACKf_GET BCM89500_A0_G_MIICTL_P7r_LOOPBACKf_GET
#define G_MIICTL_P7r_LOOPBACKf_SET BCM89500_A0_G_MIICTL_P7r_LOOPBACKf_SET
#define G_MIICTL_P7r_RESETf_GET BCM89500_A0_G_MIICTL_P7r_RESETf_GET
#define G_MIICTL_P7r_RESETf_SET BCM89500_A0_G_MIICTL_P7r_RESETf_SET
#define READ_G_MIICTL_P7r BCM89500_A0_READ_G_MIICTL_P7r
#define WRITE_G_MIICTL_P7r BCM89500_A0_WRITE_G_MIICTL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIICTL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIISTS
 * BLOCKS:   SYS
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     UNIDIRECTIONAL_CAP Capable of unidirectional transmit.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIISTSr 0x00001402

#define BCM89500_A0_G_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS.
 *
 */
typedef union BCM89500_A0_G_MIISTSr_s {
	uint32_t v[1];
	uint32_t g_miists[1];
	uint32_t _g_miists;
} BCM89500_A0_G_MIISTSr_t;

#define BCM89500_A0_G_MIISTSr_CLR(r) (r).g_miists[0] = 0
#define BCM89500_A0_G_MIISTSr_SET(r,d) (r).g_miists[0] = d
#define BCM89500_A0_G_MIISTSr_GET(r) (r).g_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIISTSr_EXT_CAPf_GET(r) (((r).g_miists[0]) & 0x1)
#define BCM89500_A0_G_MIISTSr_EXT_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_MIISTSr_JABBER_DETf_GET(r) ((((r).g_miists[0]) >> 1) & 0x1)
#define BCM89500_A0_G_MIISTSr_JABBER_DETf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_MIISTSr_LINK_STAf_GET(r) ((((r).g_miists[0]) >> 2) & 0x1)
#define BCM89500_A0_G_MIISTSr_LINK_STAf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists[0]) >> 3) & 0x1)
#define BCM89500_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_MIISTSr_REMOTE_FAULTf_GET(r) ((((r).g_miists[0]) >> 4) & 0x1)
#define BCM89500_A0_G_MIISTSr_REMOTE_FAULTf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).g_miists[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIISTSr_UNIDIRECTIONAL_CAPf_GET(r) ((((r).g_miists[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIISTSr_UNIDIRECTIONAL_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIISTSr_EXT_STSf_GET(r) ((((r).g_miists[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIISTSr_EXT_STSf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIISTSr_B100T2_HD_CAPf_GET(r) ((((r).g_miists[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIISTSr_B100T2_HD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIISTSr_B100T2_FD_CAPf_GET(r) ((((r).g_miists[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIISTSr_B100T2_FD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIISTSr_B10T_CAPf_GET(r) ((((r).g_miists[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIISTSr_B10T_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIISTSr_B100TX_CAPf_GET(r) ((((r).g_miists[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIISTSr_B100TX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIISTSr_B100T4_CAPf_GET(r) ((((r).g_miists[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIISTSr_B100T4_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS.
 *
 */
#define BCM89500_A0_READ_G_MIISTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIISTSr,(r._g_miists),2)
#define BCM89500_A0_WRITE_G_MIISTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIISTSr,&(r._g_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTSr BCM89500_A0_G_MIISTSr
#define G_MIISTSr_SIZE BCM89500_A0_G_MIISTSr_SIZE
typedef BCM89500_A0_G_MIISTSr_t G_MIISTSr_t;
#define G_MIISTSr_CLR BCM89500_A0_G_MIISTSr_CLR
#define G_MIISTSr_SET BCM89500_A0_G_MIISTSr_SET
#define G_MIISTSr_GET BCM89500_A0_G_MIISTSr_GET
#define G_MIISTSr_EXT_CAPf_GET BCM89500_A0_G_MIISTSr_EXT_CAPf_GET
#define G_MIISTSr_EXT_CAPf_SET BCM89500_A0_G_MIISTSr_EXT_CAPf_SET
#define G_MIISTSr_JABBER_DETf_GET BCM89500_A0_G_MIISTSr_JABBER_DETf_GET
#define G_MIISTSr_JABBER_DETf_SET BCM89500_A0_G_MIISTSr_JABBER_DETf_SET
#define G_MIISTSr_LINK_STAf_GET BCM89500_A0_G_MIISTSr_LINK_STAf_GET
#define G_MIISTSr_LINK_STAf_SET BCM89500_A0_G_MIISTSr_LINK_STAf_SET
#define G_MIISTSr_AUTO_NEGO_CAPf_GET BCM89500_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET
#define G_MIISTSr_AUTO_NEGO_CAPf_SET BCM89500_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET
#define G_MIISTSr_REMOTE_FAULTf_GET BCM89500_A0_G_MIISTSr_REMOTE_FAULTf_GET
#define G_MIISTSr_REMOTE_FAULTf_SET BCM89500_A0_G_MIISTSr_REMOTE_FAULTf_SET
#define G_MIISTSr_AUTO_NEGO_COMPf_GET BCM89500_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET
#define G_MIISTSr_AUTO_NEGO_COMPf_SET BCM89500_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET
#define G_MIISTSr_MF_PRE_SUPf_GET BCM89500_A0_G_MIISTSr_MF_PRE_SUPf_GET
#define G_MIISTSr_MF_PRE_SUPf_SET BCM89500_A0_G_MIISTSr_MF_PRE_SUPf_SET
#define G_MIISTSr_UNIDIRECTIONAL_CAPf_GET BCM89500_A0_G_MIISTSr_UNIDIRECTIONAL_CAPf_GET
#define G_MIISTSr_UNIDIRECTIONAL_CAPf_SET BCM89500_A0_G_MIISTSr_UNIDIRECTIONAL_CAPf_SET
#define G_MIISTSr_EXT_STSf_GET BCM89500_A0_G_MIISTSr_EXT_STSf_GET
#define G_MIISTSr_EXT_STSf_SET BCM89500_A0_G_MIISTSr_EXT_STSf_SET
#define G_MIISTSr_B100T2_HD_CAPf_GET BCM89500_A0_G_MIISTSr_B100T2_HD_CAPf_GET
#define G_MIISTSr_B100T2_HD_CAPf_SET BCM89500_A0_G_MIISTSr_B100T2_HD_CAPf_SET
#define G_MIISTSr_B100T2_FD_CAPf_GET BCM89500_A0_G_MIISTSr_B100T2_FD_CAPf_GET
#define G_MIISTSr_B100T2_FD_CAPf_SET BCM89500_A0_G_MIISTSr_B100T2_FD_CAPf_SET
#define G_MIISTSr_B10T_CAPf_GET BCM89500_A0_G_MIISTSr_B10T_CAPf_GET
#define G_MIISTSr_B10T_CAPf_SET BCM89500_A0_G_MIISTSr_B10T_CAPf_SET
#define G_MIISTSr_B10T_FDX_CAPf_GET BCM89500_A0_G_MIISTSr_B10T_FDX_CAPf_GET
#define G_MIISTSr_B10T_FDX_CAPf_SET BCM89500_A0_G_MIISTSr_B10T_FDX_CAPf_SET
#define G_MIISTSr_B100TX_CAPf_GET BCM89500_A0_G_MIISTSr_B100TX_CAPf_GET
#define G_MIISTSr_B100TX_CAPf_SET BCM89500_A0_G_MIISTSr_B100TX_CAPf_SET
#define G_MIISTSr_B100TX_FDX_CAPf_GET BCM89500_A0_G_MIISTSr_B100TX_FDX_CAPf_GET
#define G_MIISTSr_B100TX_FDX_CAPf_SET BCM89500_A0_G_MIISTSr_B100TX_FDX_CAPf_SET
#define G_MIISTSr_B100T4_CAPf_GET BCM89500_A0_G_MIISTSr_B100T4_CAPf_GET
#define G_MIISTSr_B100T4_CAPf_SET BCM89500_A0_G_MIISTSr_B100T4_CAPf_SET
#define READ_G_MIISTSr BCM89500_A0_READ_G_MIISTSr
#define WRITE_G_MIISTSr BCM89500_A0_WRITE_G_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIISTS_EXT
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIISTS_EXTr 0x00008802

#define BCM89500_A0_G_MIISTS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT.
 *
 */
typedef union BCM89500_A0_G_MIISTS_EXTr_s {
	uint32_t v[1];
	uint32_t g_miists_ext[1];
	uint32_t _g_miists_ext;
} BCM89500_A0_G_MIISTS_EXTr_t;

#define BCM89500_A0_G_MIISTS_EXTr_CLR(r) (r).g_miists_ext[0] = 0
#define BCM89500_A0_G_MIISTS_EXTr_SET(r,d) (r).g_miists_ext[0] = d
#define BCM89500_A0_G_MIISTS_EXTr_GET(r) (r).g_miists_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIISTS_EXTr_EXT_CAPf_GET(r) (((r).g_miists_ext[0]) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_EXT_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_MIISTS_EXTr_JABBER_DETf_GET(r) ((((r).g_miists_ext[0]) >> 1) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_JABBER_DETf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_MIISTS_EXTr_LINK_STAf_GET(r) ((((r).g_miists_ext[0]) >> 2) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_LINK_STAf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 3) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_MIISTS_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext[0]) >> 4) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIISTS_EXTr_RESERVEDf_GET(r) ((((r).g_miists_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_RESERVEDf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIISTS_EXTr_EXT_STSf_GET(r) ((((r).g_miists_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_EXT_STSf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIISTS_EXTr_B10T_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B10T_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIISTS_EXTr_B100TX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B100TX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIISTS_EXTr_B100T4_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIISTS_EXTr_B100T4_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT.
 *
 */
#define BCM89500_A0_READ_G_MIISTS_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIISTS_EXTr,(r._g_miists_ext),2)
#define BCM89500_A0_WRITE_G_MIISTS_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIISTS_EXTr,&(r._g_miists_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXTr BCM89500_A0_G_MIISTS_EXTr
#define G_MIISTS_EXTr_SIZE BCM89500_A0_G_MIISTS_EXTr_SIZE
typedef BCM89500_A0_G_MIISTS_EXTr_t G_MIISTS_EXTr_t;
#define G_MIISTS_EXTr_CLR BCM89500_A0_G_MIISTS_EXTr_CLR
#define G_MIISTS_EXTr_SET BCM89500_A0_G_MIISTS_EXTr_SET
#define G_MIISTS_EXTr_GET BCM89500_A0_G_MIISTS_EXTr_GET
#define G_MIISTS_EXTr_EXT_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_EXT_CAPf_GET
#define G_MIISTS_EXTr_EXT_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_EXT_CAPf_SET
#define G_MIISTS_EXTr_JABBER_DETf_GET BCM89500_A0_G_MIISTS_EXTr_JABBER_DETf_GET
#define G_MIISTS_EXTr_JABBER_DETf_SET BCM89500_A0_G_MIISTS_EXTr_JABBER_DETf_SET
#define G_MIISTS_EXTr_LINK_STAf_GET BCM89500_A0_G_MIISTS_EXTr_LINK_STAf_GET
#define G_MIISTS_EXTr_LINK_STAf_SET BCM89500_A0_G_MIISTS_EXTr_LINK_STAf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXTr_REMOTE_FAULTf_GET BCM89500_A0_G_MIISTS_EXTr_REMOTE_FAULTf_GET
#define G_MIISTS_EXTr_REMOTE_FAULTf_SET BCM89500_A0_G_MIISTS_EXTr_REMOTE_FAULTf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET BCM89500_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXTr_MF_PRE_SUPf_GET BCM89500_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET
#define G_MIISTS_EXTr_MF_PRE_SUPf_SET BCM89500_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET
#define G_MIISTS_EXTr_RESERVEDf_GET BCM89500_A0_G_MIISTS_EXTr_RESERVEDf_GET
#define G_MIISTS_EXTr_RESERVEDf_SET BCM89500_A0_G_MIISTS_EXTr_RESERVEDf_SET
#define G_MIISTS_EXTr_EXT_STSf_GET BCM89500_A0_G_MIISTS_EXTr_EXT_STSf_GET
#define G_MIISTS_EXTr_EXT_STSf_SET BCM89500_A0_G_MIISTS_EXTr_EXT_STSf_SET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET
#define G_MIISTS_EXTr_B10T_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B10T_CAPf_GET
#define G_MIISTS_EXTr_B10T_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B10T_CAPf_SET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B100TX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B100TX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100T4_CAPf_GET BCM89500_A0_G_MIISTS_EXTr_B100T4_CAPf_GET
#define G_MIISTS_EXTr_B100T4_CAPf_SET BCM89500_A0_G_MIISTS_EXTr_B100T4_CAPf_SET
#define READ_G_MIISTS_EXTr BCM89500_A0_READ_G_MIISTS_EXTr
#define WRITE_G_MIISTS_EXTr BCM89500_A0_WRITE_G_MIISTS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIISTS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIISTS_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIISTS_EXT_P4r 0x00008402

#define BCM89500_A0_G_MIISTS_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_MIISTS_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_miists_ext_p4[1];
	uint32_t _g_miists_ext_p4;
} BCM89500_A0_G_MIISTS_EXT_P4r_t;

#define BCM89500_A0_G_MIISTS_EXT_P4r_CLR(r) (r).g_miists_ext_p4[0] = 0
#define BCM89500_A0_G_MIISTS_EXT_P4r_SET(r,d) (r).g_miists_ext_p4[0] = d
#define BCM89500_A0_G_MIISTS_EXT_P4r_GET(r) (r).g_miists_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIISTS_EXT_P4r_EXT_CAPf_GET(r) (((r).g_miists_ext_p4[0]) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_EXT_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_MIISTS_EXT_P4r_JABBER_DETf_GET(r) ((((r).g_miists_ext_p4[0]) >> 1) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_JABBER_DETf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_MIISTS_EXT_P4r_LINK_STAf_GET(r) ((((r).g_miists_ext_p4[0]) >> 2) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_LINK_STAf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 3) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_MIISTS_EXT_P4r_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext_p4[0]) >> 4) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIISTS_EXT_P4r_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIISTS_EXT_P4r_RESERVEDf_GET(r) ((((r).g_miists_ext_p4[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_RESERVEDf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIISTS_EXT_P4r_EXT_STSf_GET(r) ((((r).g_miists_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_EXT_STSf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B10T_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B10T_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100T4_CAPf_GET(r) ((((r).g_miists_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P4r_B100T4_CAPf_SET(r,f) (r).g_miists_ext_p4[0]=(((r).g_miists_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_MIISTS_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIISTS_EXT_P4r,(r._g_miists_ext_p4),2)
#define BCM89500_A0_WRITE_G_MIISTS_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIISTS_EXT_P4r,&(r._g_miists_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXT_P4r BCM89500_A0_G_MIISTS_EXT_P4r
#define G_MIISTS_EXT_P4r_SIZE BCM89500_A0_G_MIISTS_EXT_P4r_SIZE
typedef BCM89500_A0_G_MIISTS_EXT_P4r_t G_MIISTS_EXT_P4r_t;
#define G_MIISTS_EXT_P4r_CLR BCM89500_A0_G_MIISTS_EXT_P4r_CLR
#define G_MIISTS_EXT_P4r_SET BCM89500_A0_G_MIISTS_EXT_P4r_SET
#define G_MIISTS_EXT_P4r_GET BCM89500_A0_G_MIISTS_EXT_P4r_GET
#define G_MIISTS_EXT_P4r_EXT_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_EXT_CAPf_GET
#define G_MIISTS_EXT_P4r_EXT_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_EXT_CAPf_SET
#define G_MIISTS_EXT_P4r_JABBER_DETf_GET BCM89500_A0_G_MIISTS_EXT_P4r_JABBER_DETf_GET
#define G_MIISTS_EXT_P4r_JABBER_DETf_SET BCM89500_A0_G_MIISTS_EXT_P4r_JABBER_DETf_SET
#define G_MIISTS_EXT_P4r_LINK_STAf_GET BCM89500_A0_G_MIISTS_EXT_P4r_LINK_STAf_GET
#define G_MIISTS_EXT_P4r_LINK_STAf_SET BCM89500_A0_G_MIISTS_EXT_P4r_LINK_STAf_SET
#define G_MIISTS_EXT_P4r_AUTO_NEGO_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXT_P4r_AUTO_NEGO_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXT_P4r_REMOTE_FAULTf_GET BCM89500_A0_G_MIISTS_EXT_P4r_REMOTE_FAULTf_GET
#define G_MIISTS_EXT_P4r_REMOTE_FAULTf_SET BCM89500_A0_G_MIISTS_EXT_P4r_REMOTE_FAULTf_SET
#define G_MIISTS_EXT_P4r_AUTO_NEGO_COMPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXT_P4r_AUTO_NEGO_COMPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXT_P4r_MF_PRE_SUPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_MF_PRE_SUPf_GET
#define G_MIISTS_EXT_P4r_MF_PRE_SUPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_MF_PRE_SUPf_SET
#define G_MIISTS_EXT_P4r_RESERVEDf_GET BCM89500_A0_G_MIISTS_EXT_P4r_RESERVEDf_GET
#define G_MIISTS_EXT_P4r_RESERVEDf_SET BCM89500_A0_G_MIISTS_EXT_P4r_RESERVEDf_SET
#define G_MIISTS_EXT_P4r_EXT_STSf_GET BCM89500_A0_G_MIISTS_EXT_P4r_EXT_STSf_GET
#define G_MIISTS_EXT_P4r_EXT_STSf_SET BCM89500_A0_G_MIISTS_EXT_P4r_EXT_STSf_SET
#define G_MIISTS_EXT_P4r_B100T2_HD_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_HD_CAPf_GET
#define G_MIISTS_EXT_P4r_B100T2_HD_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_HD_CAPf_SET
#define G_MIISTS_EXT_P4r_B100T2_FD_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_FD_CAPf_GET
#define G_MIISTS_EXT_P4r_B100T2_FD_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B100T2_FD_CAPf_SET
#define G_MIISTS_EXT_P4r_B10T_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B10T_CAPf_GET
#define G_MIISTS_EXT_P4r_B10T_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B10T_CAPf_SET
#define G_MIISTS_EXT_P4r_B10T_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B10T_FDX_CAPf_GET
#define G_MIISTS_EXT_P4r_B10T_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B10T_FDX_CAPf_SET
#define G_MIISTS_EXT_P4r_B100TX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_CAPf_GET
#define G_MIISTS_EXT_P4r_B100TX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_CAPf_SET
#define G_MIISTS_EXT_P4r_B100TX_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXT_P4r_B100TX_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXT_P4r_B100T4_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P4r_B100T4_CAPf_GET
#define G_MIISTS_EXT_P4r_B100T4_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P4r_B100T4_CAPf_SET
#define READ_G_MIISTS_EXT_P4r BCM89500_A0_READ_G_MIISTS_EXT_P4r
#define WRITE_G_MIISTS_EXT_P4r BCM89500_A0_WRITE_G_MIISTS_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIISTS_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIISTS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIISTS_EXT_P5r 0x00008502

#define BCM89500_A0_G_MIISTS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_MIISTS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_miists_ext_p5[1];
	uint32_t _g_miists_ext_p5;
} BCM89500_A0_G_MIISTS_EXT_P5r_t;

#define BCM89500_A0_G_MIISTS_EXT_P5r_CLR(r) (r).g_miists_ext_p5[0] = 0
#define BCM89500_A0_G_MIISTS_EXT_P5r_SET(r,d) (r).g_miists_ext_p5[0] = d
#define BCM89500_A0_G_MIISTS_EXT_P5r_GET(r) (r).g_miists_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIISTS_EXT_P5r_EXT_CAPf_GET(r) (((r).g_miists_ext_p5[0]) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_EXT_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_MIISTS_EXT_P5r_JABBER_DETf_GET(r) ((((r).g_miists_ext_p5[0]) >> 1) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_JABBER_DETf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_MIISTS_EXT_P5r_LINK_STAf_GET(r) ((((r).g_miists_ext_p5[0]) >> 2) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_LINK_STAf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 3) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_MIISTS_EXT_P5r_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext_p5[0]) >> 4) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIISTS_EXT_P5r_RESERVEDf_GET(r) ((((r).g_miists_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_RESERVEDf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIISTS_EXT_P5r_EXT_STSf_GET(r) ((((r).g_miists_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_EXT_STSf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B10T_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B10T_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_MIISTS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIISTS_EXT_P5r,(r._g_miists_ext_p5),2)
#define BCM89500_A0_WRITE_G_MIISTS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIISTS_EXT_P5r,&(r._g_miists_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXT_P5r BCM89500_A0_G_MIISTS_EXT_P5r
#define G_MIISTS_EXT_P5r_SIZE BCM89500_A0_G_MIISTS_EXT_P5r_SIZE
typedef BCM89500_A0_G_MIISTS_EXT_P5r_t G_MIISTS_EXT_P5r_t;
#define G_MIISTS_EXT_P5r_CLR BCM89500_A0_G_MIISTS_EXT_P5r_CLR
#define G_MIISTS_EXT_P5r_SET BCM89500_A0_G_MIISTS_EXT_P5r_SET
#define G_MIISTS_EXT_P5r_GET BCM89500_A0_G_MIISTS_EXT_P5r_GET
#define G_MIISTS_EXT_P5r_EXT_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_EXT_CAPf_GET
#define G_MIISTS_EXT_P5r_EXT_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_EXT_CAPf_SET
#define G_MIISTS_EXT_P5r_JABBER_DETf_GET BCM89500_A0_G_MIISTS_EXT_P5r_JABBER_DETf_GET
#define G_MIISTS_EXT_P5r_JABBER_DETf_SET BCM89500_A0_G_MIISTS_EXT_P5r_JABBER_DETf_SET
#define G_MIISTS_EXT_P5r_LINK_STAf_GET BCM89500_A0_G_MIISTS_EXT_P5r_LINK_STAf_GET
#define G_MIISTS_EXT_P5r_LINK_STAf_SET BCM89500_A0_G_MIISTS_EXT_P5r_LINK_STAf_SET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXT_P5r_REMOTE_FAULTf_GET BCM89500_A0_G_MIISTS_EXT_P5r_REMOTE_FAULTf_GET
#define G_MIISTS_EXT_P5r_REMOTE_FAULTf_SET BCM89500_A0_G_MIISTS_EXT_P5r_REMOTE_FAULTf_SET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXT_P5r_MF_PRE_SUPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_GET
#define G_MIISTS_EXT_P5r_MF_PRE_SUPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_SET
#define G_MIISTS_EXT_P5r_RESERVEDf_GET BCM89500_A0_G_MIISTS_EXT_P5r_RESERVEDf_GET
#define G_MIISTS_EXT_P5r_RESERVEDf_SET BCM89500_A0_G_MIISTS_EXT_P5r_RESERVEDf_SET
#define G_MIISTS_EXT_P5r_EXT_STSf_GET BCM89500_A0_G_MIISTS_EXT_P5r_EXT_STSf_GET
#define G_MIISTS_EXT_P5r_EXT_STSf_SET BCM89500_A0_G_MIISTS_EXT_P5r_EXT_STSf_SET
#define G_MIISTS_EXT_P5r_B100T2_HD_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_GET
#define G_MIISTS_EXT_P5r_B100T2_HD_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_SET
#define G_MIISTS_EXT_P5r_B100T2_FD_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_GET
#define G_MIISTS_EXT_P5r_B100T2_FD_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_SET
#define G_MIISTS_EXT_P5r_B10T_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B10T_CAPf_GET
#define G_MIISTS_EXT_P5r_B10T_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B10T_CAPf_SET
#define G_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET
#define G_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET
#define G_MIISTS_EXT_P5r_B100TX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_GET
#define G_MIISTS_EXT_P5r_B100TX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_SET
#define G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXT_P5r_B100T4_CAPf_GET BCM89500_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_GET
#define G_MIISTS_EXT_P5r_B100T4_CAPf_SET BCM89500_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_SET
#define READ_G_MIISTS_EXT_P5r BCM89500_A0_READ_G_MIISTS_EXT_P5r
#define WRITE_G_MIISTS_EXT_P5r BCM89500_A0_WRITE_G_MIISTS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIISTS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIISTS_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIISTS_EXT_PNr 0x00008002

#define BCM89500_A0_G_MIISTS_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_MIISTS_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_miists_ext_pn[1];
	uint32_t _g_miists_ext_pn;
} BCM89500_A0_G_MIISTS_EXT_PNr_t;

#define BCM89500_A0_G_MIISTS_EXT_PNr_CLR(r) (r).g_miists_ext_pn[0] = 0
#define BCM89500_A0_G_MIISTS_EXT_PNr_SET(r,d) (r).g_miists_ext_pn[0] = d
#define BCM89500_A0_G_MIISTS_EXT_PNr_GET(r) (r).g_miists_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIISTS_EXT_PNr_EXT_CAPf_GET(r) (((r).g_miists_ext_pn[0]) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_EXT_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_MIISTS_EXT_PNr_JABBER_DETf_GET(r) ((((r).g_miists_ext_pn[0]) >> 1) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_JABBER_DETf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_MIISTS_EXT_PNr_LINK_STAf_GET(r) ((((r).g_miists_ext_pn[0]) >> 2) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_LINK_STAf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 3) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_MIISTS_EXT_PNr_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext_pn[0]) >> 4) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIISTS_EXT_PNr_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIISTS_EXT_PNr_RESERVEDf_GET(r) ((((r).g_miists_ext_pn[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_RESERVEDf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIISTS_EXT_PNr_EXT_STSf_GET(r) ((((r).g_miists_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_EXT_STSf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B10T_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B10T_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100T4_CAPf_GET(r) ((((r).g_miists_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIISTS_EXT_PNr_B100T4_CAPf_SET(r,f) (r).g_miists_ext_pn[0]=(((r).g_miists_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_MIISTS_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_MIISTS_EXT_PNr,(r._g_miists_ext_pn),2)
#define BCM89500_A0_WRITE_G_MIISTS_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_MIISTS_EXT_PNr,&(r._g_miists_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXT_PNr BCM89500_A0_G_MIISTS_EXT_PNr
#define G_MIISTS_EXT_PNr_SIZE BCM89500_A0_G_MIISTS_EXT_PNr_SIZE
typedef BCM89500_A0_G_MIISTS_EXT_PNr_t G_MIISTS_EXT_PNr_t;
#define G_MIISTS_EXT_PNr_CLR BCM89500_A0_G_MIISTS_EXT_PNr_CLR
#define G_MIISTS_EXT_PNr_SET BCM89500_A0_G_MIISTS_EXT_PNr_SET
#define G_MIISTS_EXT_PNr_GET BCM89500_A0_G_MIISTS_EXT_PNr_GET
#define G_MIISTS_EXT_PNr_EXT_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_EXT_CAPf_GET
#define G_MIISTS_EXT_PNr_EXT_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_EXT_CAPf_SET
#define G_MIISTS_EXT_PNr_JABBER_DETf_GET BCM89500_A0_G_MIISTS_EXT_PNr_JABBER_DETf_GET
#define G_MIISTS_EXT_PNr_JABBER_DETf_SET BCM89500_A0_G_MIISTS_EXT_PNr_JABBER_DETf_SET
#define G_MIISTS_EXT_PNr_LINK_STAf_GET BCM89500_A0_G_MIISTS_EXT_PNr_LINK_STAf_GET
#define G_MIISTS_EXT_PNr_LINK_STAf_SET BCM89500_A0_G_MIISTS_EXT_PNr_LINK_STAf_SET
#define G_MIISTS_EXT_PNr_AUTO_NEGO_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXT_PNr_AUTO_NEGO_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXT_PNr_REMOTE_FAULTf_GET BCM89500_A0_G_MIISTS_EXT_PNr_REMOTE_FAULTf_GET
#define G_MIISTS_EXT_PNr_REMOTE_FAULTf_SET BCM89500_A0_G_MIISTS_EXT_PNr_REMOTE_FAULTf_SET
#define G_MIISTS_EXT_PNr_AUTO_NEGO_COMPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXT_PNr_AUTO_NEGO_COMPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXT_PNr_MF_PRE_SUPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_MF_PRE_SUPf_GET
#define G_MIISTS_EXT_PNr_MF_PRE_SUPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_MF_PRE_SUPf_SET
#define G_MIISTS_EXT_PNr_RESERVEDf_GET BCM89500_A0_G_MIISTS_EXT_PNr_RESERVEDf_GET
#define G_MIISTS_EXT_PNr_RESERVEDf_SET BCM89500_A0_G_MIISTS_EXT_PNr_RESERVEDf_SET
#define G_MIISTS_EXT_PNr_EXT_STSf_GET BCM89500_A0_G_MIISTS_EXT_PNr_EXT_STSf_GET
#define G_MIISTS_EXT_PNr_EXT_STSf_SET BCM89500_A0_G_MIISTS_EXT_PNr_EXT_STSf_SET
#define G_MIISTS_EXT_PNr_B100T2_HD_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_HD_CAPf_GET
#define G_MIISTS_EXT_PNr_B100T2_HD_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_HD_CAPf_SET
#define G_MIISTS_EXT_PNr_B100T2_FD_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_FD_CAPf_GET
#define G_MIISTS_EXT_PNr_B100T2_FD_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B100T2_FD_CAPf_SET
#define G_MIISTS_EXT_PNr_B10T_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B10T_CAPf_GET
#define G_MIISTS_EXT_PNr_B10T_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B10T_CAPf_SET
#define G_MIISTS_EXT_PNr_B10T_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B10T_FDX_CAPf_GET
#define G_MIISTS_EXT_PNr_B10T_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B10T_FDX_CAPf_SET
#define G_MIISTS_EXT_PNr_B100TX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_CAPf_GET
#define G_MIISTS_EXT_PNr_B100TX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_CAPf_SET
#define G_MIISTS_EXT_PNr_B100TX_FDX_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXT_PNr_B100TX_FDX_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXT_PNr_B100T4_CAPf_GET BCM89500_A0_G_MIISTS_EXT_PNr_B100T4_CAPf_GET
#define G_MIISTS_EXT_PNr_B100T4_CAPf_SET BCM89500_A0_G_MIISTS_EXT_PNr_B100T4_CAPf_SET
#define READ_G_MIISTS_EXT_PNr BCM89500_A0_READ_G_MIISTS_EXT_PNr
#define WRITE_G_MIISTS_EXT_PNr BCM89500_A0_WRITE_G_MIISTS_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIISTS_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MIISTS_P7
 * BLOCKS:   SYS
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_G_MIISTS_P7r 0x00001702

#define BCM89500_A0_G_MIISTS_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_P7.
 *
 */
typedef union BCM89500_A0_G_MIISTS_P7r_s {
	uint32_t v[1];
	uint32_t g_miists_p7[1];
	uint32_t _g_miists_p7;
} BCM89500_A0_G_MIISTS_P7r_t;

#define BCM89500_A0_G_MIISTS_P7r_CLR(r) (r).g_miists_p7[0] = 0
#define BCM89500_A0_G_MIISTS_P7r_SET(r,d) (r).g_miists_p7[0] = d
#define BCM89500_A0_G_MIISTS_P7r_GET(r) (r).g_miists_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MIISTS_P7r_EXT_CAPf_GET(r) (((r).g_miists_p7[0]) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_EXT_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_MIISTS_P7r_JABBER_DETf_GET(r) ((((r).g_miists_p7[0]) >> 1) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_JABBER_DETf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_MIISTS_P7r_LINK_STAf_GET(r) ((((r).g_miists_p7[0]) >> 2) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_LINK_STAf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 3) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_MIISTS_P7r_REMOTE_FAULTf_GET(r) ((((r).g_miists_p7[0]) >> 4) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_REMOTE_FAULTf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_MIISTS_P7r_MF_PRE_SUPf_GET(r) ((((r).g_miists_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_MF_PRE_SUPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_MIISTS_P7r_RESERVEDf_GET(r) ((((r).g_miists_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_RESERVEDf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_MIISTS_P7r_EXT_STSf_GET(r) ((((r).g_miists_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_EXT_STSf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_MIISTS_P7r_B100T2_HD_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B100T2_HD_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_MIISTS_P7r_B100T2_FD_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B100T2_FD_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_MIISTS_P7r_B10T_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B10T_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_MIISTS_P7r_B10T_FDX_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B10T_FDX_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_MIISTS_P7r_B100TX_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B100TX_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_MIISTS_P7r_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_MIISTS_P7r_B100T4_CAPf_GET(r) ((((r).g_miists_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MIISTS_P7r_B100T4_CAPf_SET(r,f) (r).g_miists_p7[0]=(((r).g_miists_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_P7.
 *
 */
#define BCM89500_A0_READ_G_MIISTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MIISTS_P7r,(r._g_miists_p7),2)
#define BCM89500_A0_WRITE_G_MIISTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MIISTS_P7r,&(r._g_miists_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_P7r BCM89500_A0_G_MIISTS_P7r
#define G_MIISTS_P7r_SIZE BCM89500_A0_G_MIISTS_P7r_SIZE
typedef BCM89500_A0_G_MIISTS_P7r_t G_MIISTS_P7r_t;
#define G_MIISTS_P7r_CLR BCM89500_A0_G_MIISTS_P7r_CLR
#define G_MIISTS_P7r_SET BCM89500_A0_G_MIISTS_P7r_SET
#define G_MIISTS_P7r_GET BCM89500_A0_G_MIISTS_P7r_GET
#define G_MIISTS_P7r_EXT_CAPf_GET BCM89500_A0_G_MIISTS_P7r_EXT_CAPf_GET
#define G_MIISTS_P7r_EXT_CAPf_SET BCM89500_A0_G_MIISTS_P7r_EXT_CAPf_SET
#define G_MIISTS_P7r_JABBER_DETf_GET BCM89500_A0_G_MIISTS_P7r_JABBER_DETf_GET
#define G_MIISTS_P7r_JABBER_DETf_SET BCM89500_A0_G_MIISTS_P7r_JABBER_DETf_SET
#define G_MIISTS_P7r_LINK_STAf_GET BCM89500_A0_G_MIISTS_P7r_LINK_STAf_GET
#define G_MIISTS_P7r_LINK_STAf_SET BCM89500_A0_G_MIISTS_P7r_LINK_STAf_SET
#define G_MIISTS_P7r_AUTO_NEGO_CAPf_GET BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_CAPf_GET
#define G_MIISTS_P7r_AUTO_NEGO_CAPf_SET BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_CAPf_SET
#define G_MIISTS_P7r_REMOTE_FAULTf_GET BCM89500_A0_G_MIISTS_P7r_REMOTE_FAULTf_GET
#define G_MIISTS_P7r_REMOTE_FAULTf_SET BCM89500_A0_G_MIISTS_P7r_REMOTE_FAULTf_SET
#define G_MIISTS_P7r_AUTO_NEGO_COMPf_GET BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_COMPf_GET
#define G_MIISTS_P7r_AUTO_NEGO_COMPf_SET BCM89500_A0_G_MIISTS_P7r_AUTO_NEGO_COMPf_SET
#define G_MIISTS_P7r_MF_PRE_SUPf_GET BCM89500_A0_G_MIISTS_P7r_MF_PRE_SUPf_GET
#define G_MIISTS_P7r_MF_PRE_SUPf_SET BCM89500_A0_G_MIISTS_P7r_MF_PRE_SUPf_SET
#define G_MIISTS_P7r_RESERVEDf_GET BCM89500_A0_G_MIISTS_P7r_RESERVEDf_GET
#define G_MIISTS_P7r_RESERVEDf_SET BCM89500_A0_G_MIISTS_P7r_RESERVEDf_SET
#define G_MIISTS_P7r_EXT_STSf_GET BCM89500_A0_G_MIISTS_P7r_EXT_STSf_GET
#define G_MIISTS_P7r_EXT_STSf_SET BCM89500_A0_G_MIISTS_P7r_EXT_STSf_SET
#define G_MIISTS_P7r_B100T2_HD_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B100T2_HD_CAPf_GET
#define G_MIISTS_P7r_B100T2_HD_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B100T2_HD_CAPf_SET
#define G_MIISTS_P7r_B100T2_FD_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B100T2_FD_CAPf_GET
#define G_MIISTS_P7r_B100T2_FD_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B100T2_FD_CAPf_SET
#define G_MIISTS_P7r_B10T_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B10T_CAPf_GET
#define G_MIISTS_P7r_B10T_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B10T_CAPf_SET
#define G_MIISTS_P7r_B10T_FDX_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B10T_FDX_CAPf_GET
#define G_MIISTS_P7r_B10T_FDX_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B10T_FDX_CAPf_SET
#define G_MIISTS_P7r_B100TX_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B100TX_CAPf_GET
#define G_MIISTS_P7r_B100TX_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B100TX_CAPf_SET
#define G_MIISTS_P7r_B100TX_FDX_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B100TX_FDX_CAPf_GET
#define G_MIISTS_P7r_B100TX_FDX_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B100TX_FDX_CAPf_SET
#define G_MIISTS_P7r_B100T4_CAPf_GET BCM89500_A0_G_MIISTS_P7r_B100T4_CAPf_GET
#define G_MIISTS_P7r_B100T4_CAPf_SET BCM89500_A0_G_MIISTS_P7r_B100T4_CAPf_SET
#define READ_G_MIISTS_P7r BCM89500_A0_READ_G_MIISTS_P7r
#define WRITE_G_MIISTS_P7r BCM89500_A0_WRITE_G_MIISTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MIISTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MISC_SHADOW
 * BLOCKS:   SYS
 * DESC:     Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     MISC_CTRL        spare control 3:bit 9 : DLL lock enable during auto-power downbit 8 : txc/rxc disable during auto-power downbit 7-6 : reservedbit 5 : sd/energy detect change mux selectbit 4 : low power enc disablebit 3 : reservedbit 2 : sigdet deassert timer lengthbit 1 : auto-power down dll off disabalebit 0 : reservedauto-power down:bit 9-6 : reservedbit 5 : auto-power down mode enablebit 4: sleep timer select (1=5.4 seconds, 0=2.7 seconds)bit 3-0 : wake-up timer in units of 84msspare control 4:bit 9-7 : reservedbit 6 : soft-reset enablebit 5-0 : reservedspare control 5:bit 9-1 : reservedbit 0 : software IDDQ (1=iddq, 0=normal)
 *     SHADOW_REG_SEL   Shadow register selector5'h05 : spare control 35'h0a : auto-power down5'h0b : spare control 45'h0c : spare control 5
 *     WRITE_ENABLE     1 = write bits [9:0]0 = read bits [9:0]
 *
 ******************************************************************************/
#define BCM89500_A0_G_MISC_SHADOWr 0x00001438

#define BCM89500_A0_G_MISC_SHADOWr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW.
 *
 */
typedef union BCM89500_A0_G_MISC_SHADOWr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow[1];
	uint32_t _g_misc_shadow;
} BCM89500_A0_G_MISC_SHADOWr_t;

#define BCM89500_A0_G_MISC_SHADOWr_CLR(r) (r).g_misc_shadow[0] = 0
#define BCM89500_A0_G_MISC_SHADOWr_SET(r,d) (r).g_misc_shadow[0] = d
#define BCM89500_A0_G_MISC_SHADOWr_GET(r) (r).g_misc_shadow[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MISC_SHADOWr_MISC_CTRLf_GET(r) (((r).g_misc_shadow[0]) & 0x3ff)
#define BCM89500_A0_G_MISC_SHADOWr_MISC_CTRLf_SET(r,f) (r).g_misc_shadow[0]=(((r).g_misc_shadow[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_G_MISC_SHADOWr_SHADOW_REG_SELf_GET(r) ((((r).g_misc_shadow[0]) >> 10) & 0x1f)
#define BCM89500_A0_G_MISC_SHADOWr_SHADOW_REG_SELf_SET(r,f) (r).g_misc_shadow[0]=(((r).g_misc_shadow[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM89500_A0_G_MISC_SHADOWr_WRITE_ENABLEf_GET(r) ((((r).g_misc_shadow[0]) >> 15) & 0x1)
#define BCM89500_A0_G_MISC_SHADOWr_WRITE_ENABLEf_SET(r,f) (r).g_misc_shadow[0]=(((r).g_misc_shadow[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MISC_SHADOW.
 *
 */
#define BCM89500_A0_READ_G_MISC_SHADOWr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MISC_SHADOWr,(r._g_misc_shadow),2)
#define BCM89500_A0_WRITE_G_MISC_SHADOWr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MISC_SHADOWr,&(r._g_misc_shadow),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOWr BCM89500_A0_G_MISC_SHADOWr
#define G_MISC_SHADOWr_SIZE BCM89500_A0_G_MISC_SHADOWr_SIZE
typedef BCM89500_A0_G_MISC_SHADOWr_t G_MISC_SHADOWr_t;
#define G_MISC_SHADOWr_CLR BCM89500_A0_G_MISC_SHADOWr_CLR
#define G_MISC_SHADOWr_SET BCM89500_A0_G_MISC_SHADOWr_SET
#define G_MISC_SHADOWr_GET BCM89500_A0_G_MISC_SHADOWr_GET
#define G_MISC_SHADOWr_MISC_CTRLf_GET BCM89500_A0_G_MISC_SHADOWr_MISC_CTRLf_GET
#define G_MISC_SHADOWr_MISC_CTRLf_SET BCM89500_A0_G_MISC_SHADOWr_MISC_CTRLf_SET
#define G_MISC_SHADOWr_SHADOW_REG_SELf_GET BCM89500_A0_G_MISC_SHADOWr_SHADOW_REG_SELf_GET
#define G_MISC_SHADOWr_SHADOW_REG_SELf_SET BCM89500_A0_G_MISC_SHADOWr_SHADOW_REG_SELf_SET
#define G_MISC_SHADOWr_WRITE_ENABLEf_GET BCM89500_A0_G_MISC_SHADOWr_WRITE_ENABLEf_GET
#define G_MISC_SHADOWr_WRITE_ENABLEf_SET BCM89500_A0_G_MISC_SHADOWr_WRITE_ENABLEf_SET
#define READ_G_MISC_SHADOWr BCM89500_A0_READ_G_MISC_SHADOWr
#define WRITE_G_MISC_SHADOWr BCM89500_A0_WRITE_G_MISC_SHADOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MISC_SHADOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MISC_SHADOW_EXT
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_MISC_SHADOW_EXTr 0x00008838

#define BCM89500_A0_G_MISC_SHADOW_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT.
 *
 */
typedef union BCM89500_A0_G_MISC_SHADOW_EXTr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext[1];
	uint32_t _g_misc_shadow_ext;
} BCM89500_A0_G_MISC_SHADOW_EXTr_t;

#define BCM89500_A0_G_MISC_SHADOW_EXTr_CLR(r) (r).g_misc_shadow_ext[0] = 0
#define BCM89500_A0_G_MISC_SHADOW_EXTr_SET(r,d) (r).g_misc_shadow_ext[0] = d
#define BCM89500_A0_G_MISC_SHADOW_EXTr_GET(r) (r).g_misc_shadow_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext[0]) & 0xffff)
#define BCM89500_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext[0]=(((r).g_misc_shadow_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT.
 *
 */
#define BCM89500_A0_READ_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MISC_SHADOW_EXTr,(r._g_misc_shadow_ext),2)
#define BCM89500_A0_WRITE_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MISC_SHADOW_EXTr,&(r._g_misc_shadow_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXTr BCM89500_A0_G_MISC_SHADOW_EXTr
#define G_MISC_SHADOW_EXTr_SIZE BCM89500_A0_G_MISC_SHADOW_EXTr_SIZE
typedef BCM89500_A0_G_MISC_SHADOW_EXTr_t G_MISC_SHADOW_EXTr_t;
#define G_MISC_SHADOW_EXTr_CLR BCM89500_A0_G_MISC_SHADOW_EXTr_CLR
#define G_MISC_SHADOW_EXTr_SET BCM89500_A0_G_MISC_SHADOW_EXTr_SET
#define G_MISC_SHADOW_EXTr_GET BCM89500_A0_G_MISC_SHADOW_EXTr_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET BCM89500_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET BCM89500_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXTr BCM89500_A0_READ_G_MISC_SHADOW_EXTr
#define WRITE_G_MISC_SHADOW_EXTr BCM89500_A0_WRITE_G_MISC_SHADOW_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MISC_SHADOW_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MISC_SHADOW_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r 0x00008438

#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_MISC_SHADOW_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext_p4[1];
	uint32_t _g_misc_shadow_ext_p4;
} BCM89500_A0_G_MISC_SHADOW_EXT_P4r_t;

#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r_CLR(r) (r).g_misc_shadow_ext_p4[0] = 0
#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r_SET(r,d) (r).g_misc_shadow_ext_p4[0] = d
#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r_GET(r) (r).g_misc_shadow_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_MISC_SHADOW_EXT_P4r_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext_p4[0]=(((r).g_misc_shadow_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_MISC_SHADOW_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MISC_SHADOW_EXT_P4r,(r._g_misc_shadow_ext_p4),2)
#define BCM89500_A0_WRITE_G_MISC_SHADOW_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MISC_SHADOW_EXT_P4r,&(r._g_misc_shadow_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXT_P4r BCM89500_A0_G_MISC_SHADOW_EXT_P4r
#define G_MISC_SHADOW_EXT_P4r_SIZE BCM89500_A0_G_MISC_SHADOW_EXT_P4r_SIZE
typedef BCM89500_A0_G_MISC_SHADOW_EXT_P4r_t G_MISC_SHADOW_EXT_P4r_t;
#define G_MISC_SHADOW_EXT_P4r_CLR BCM89500_A0_G_MISC_SHADOW_EXT_P4r_CLR
#define G_MISC_SHADOW_EXT_P4r_SET BCM89500_A0_G_MISC_SHADOW_EXT_P4r_SET
#define G_MISC_SHADOW_EXT_P4r_GET BCM89500_A0_G_MISC_SHADOW_EXT_P4r_GET
#define G_MISC_SHADOW_EXT_P4r_INTERRUPT_MSKf_GET BCM89500_A0_G_MISC_SHADOW_EXT_P4r_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXT_P4r_INTERRUPT_MSKf_SET BCM89500_A0_G_MISC_SHADOW_EXT_P4r_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXT_P4r BCM89500_A0_READ_G_MISC_SHADOW_EXT_P4r
#define WRITE_G_MISC_SHADOW_EXT_P4r BCM89500_A0_WRITE_G_MISC_SHADOW_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MISC_SHADOW_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MISC_SHADOW_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r 0x00008538

#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_MISC_SHADOW_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext_p5[1];
	uint32_t _g_misc_shadow_ext_p5;
} BCM89500_A0_G_MISC_SHADOW_EXT_P5r_t;

#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r_CLR(r) (r).g_misc_shadow_ext_p5[0] = 0
#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r_SET(r,d) (r).g_misc_shadow_ext_p5[0] = d
#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r_GET(r) (r).g_misc_shadow_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext_p5[0]=(((r).g_misc_shadow_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_MISC_SHADOW_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MISC_SHADOW_EXT_P5r,(r._g_misc_shadow_ext_p5),2)
#define BCM89500_A0_WRITE_G_MISC_SHADOW_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MISC_SHADOW_EXT_P5r,&(r._g_misc_shadow_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXT_P5r BCM89500_A0_G_MISC_SHADOW_EXT_P5r
#define G_MISC_SHADOW_EXT_P5r_SIZE BCM89500_A0_G_MISC_SHADOW_EXT_P5r_SIZE
typedef BCM89500_A0_G_MISC_SHADOW_EXT_P5r_t G_MISC_SHADOW_EXT_P5r_t;
#define G_MISC_SHADOW_EXT_P5r_CLR BCM89500_A0_G_MISC_SHADOW_EXT_P5r_CLR
#define G_MISC_SHADOW_EXT_P5r_SET BCM89500_A0_G_MISC_SHADOW_EXT_P5r_SET
#define G_MISC_SHADOW_EXT_P5r_GET BCM89500_A0_G_MISC_SHADOW_EXT_P5r_GET
#define G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_GET BCM89500_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_SET BCM89500_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXT_P5r BCM89500_A0_READ_G_MISC_SHADOW_EXT_P5r
#define WRITE_G_MISC_SHADOW_EXT_P5r BCM89500_A0_WRITE_G_MISC_SHADOW_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MISC_SHADOW_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MISC_SHADOW_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr 0x00008038

#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_MISC_SHADOW_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext_pn[1];
	uint32_t _g_misc_shadow_ext_pn;
} BCM89500_A0_G_MISC_SHADOW_EXT_PNr_t;

#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr_CLR(r) (r).g_misc_shadow_ext_pn[0] = 0
#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr_SET(r,d) (r).g_misc_shadow_ext_pn[0] = d
#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr_GET(r) (r).g_misc_shadow_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_MISC_SHADOW_EXT_PNr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext_pn[0]=(((r).g_misc_shadow_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_MISC_SHADOW_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_MISC_SHADOW_EXT_PNr,(r._g_misc_shadow_ext_pn),2)
#define BCM89500_A0_WRITE_G_MISC_SHADOW_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_MISC_SHADOW_EXT_PNr,&(r._g_misc_shadow_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXT_PNr BCM89500_A0_G_MISC_SHADOW_EXT_PNr
#define G_MISC_SHADOW_EXT_PNr_SIZE BCM89500_A0_G_MISC_SHADOW_EXT_PNr_SIZE
typedef BCM89500_A0_G_MISC_SHADOW_EXT_PNr_t G_MISC_SHADOW_EXT_PNr_t;
#define G_MISC_SHADOW_EXT_PNr_CLR BCM89500_A0_G_MISC_SHADOW_EXT_PNr_CLR
#define G_MISC_SHADOW_EXT_PNr_SET BCM89500_A0_G_MISC_SHADOW_EXT_PNr_SET
#define G_MISC_SHADOW_EXT_PNr_GET BCM89500_A0_G_MISC_SHADOW_EXT_PNr_GET
#define G_MISC_SHADOW_EXT_PNr_INTERRUPT_MSKf_GET BCM89500_A0_G_MISC_SHADOW_EXT_PNr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXT_PNr_INTERRUPT_MSKf_SET BCM89500_A0_G_MISC_SHADOW_EXT_PNr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXT_PNr BCM89500_A0_READ_G_MISC_SHADOW_EXT_PNr
#define WRITE_G_MISC_SHADOW_EXT_PNr BCM89500_A0_WRITE_G_MISC_SHADOW_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MISC_SHADOW_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_MISC_SHADOW_P7
 * BLOCKS:   SYS
 * DESC:     Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM89500_A0_G_MISC_SHADOW_P7r 0x00001738

#define BCM89500_A0_G_MISC_SHADOW_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_P7.
 *
 */
typedef union BCM89500_A0_G_MISC_SHADOW_P7r_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_p7[1];
	uint32_t _g_misc_shadow_p7;
} BCM89500_A0_G_MISC_SHADOW_P7r_t;

#define BCM89500_A0_G_MISC_SHADOW_P7r_CLR(r) (r).g_misc_shadow_p7[0] = 0
#define BCM89500_A0_G_MISC_SHADOW_P7r_SET(r,d) (r).g_misc_shadow_p7[0] = d
#define BCM89500_A0_G_MISC_SHADOW_P7r_GET(r) (r).g_misc_shadow_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_MISC_SHADOW_P7r_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_p7[0]) & 0xffff)
#define BCM89500_A0_G_MISC_SHADOW_P7r_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_p7[0]=(((r).g_misc_shadow_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_P7.
 *
 */
#define BCM89500_A0_READ_G_MISC_SHADOW_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_MISC_SHADOW_P7r,(r._g_misc_shadow_p7),2)
#define BCM89500_A0_WRITE_G_MISC_SHADOW_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_MISC_SHADOW_P7r,&(r._g_misc_shadow_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_P7r BCM89500_A0_G_MISC_SHADOW_P7r
#define G_MISC_SHADOW_P7r_SIZE BCM89500_A0_G_MISC_SHADOW_P7r_SIZE
typedef BCM89500_A0_G_MISC_SHADOW_P7r_t G_MISC_SHADOW_P7r_t;
#define G_MISC_SHADOW_P7r_CLR BCM89500_A0_G_MISC_SHADOW_P7r_CLR
#define G_MISC_SHADOW_P7r_SET BCM89500_A0_G_MISC_SHADOW_P7r_SET
#define G_MISC_SHADOW_P7r_GET BCM89500_A0_G_MISC_SHADOW_P7r_GET
#define G_MISC_SHADOW_P7r_INTERRUPT_MSKf_GET BCM89500_A0_G_MISC_SHADOW_P7r_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_P7r_INTERRUPT_MSKf_SET BCM89500_A0_G_MISC_SHADOW_P7r_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_P7r BCM89500_A0_READ_G_MISC_SHADOW_P7r
#define WRITE_G_MISC_SHADOW_P7r BCM89500_A0_WRITE_G_MISC_SHADOW_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_MISC_SHADOW_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   GPIC0
 * DESC:     Port N 10/100/1000 Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED         Reserved
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3b'b000: No Spanning Tree(default by HW_FWDG_EN).3b'b001: Disable State(default by ~HW_FWDG_EN).3b'b010: Blocking State.3b'b011: Listening State.3b'b100: Learning State.3b'b101: Forwarding State.3b'b110 - 3b'b111: ReservedProgrammed from the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PCTLr 0x00000000

#define BCM89500_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 *
 */
typedef union BCM89500_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM89500_A0_G_PCTLr_t;

#define BCM89500_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM89500_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM89500_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PCTLr_RX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM89500_A0_G_PCTLr_RX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PCTLr_TX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PCTLr_TX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PCTLr_RESERVEDf_GET(r) ((((r).g_pctl[0]) >> 2) & 0x7)
#define BCM89500_A0_G_PCTLr_RESERVEDf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM89500_A0_G_PCTLr_G_MISTP_STATEf_GET(r) ((((r).g_pctl[0]) >> 5) & 0x7)
#define BCM89500_A0_G_PCTLr_G_MISTP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access G_PCTL.
 *
 */
#define BCM89500_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_PCTLr,(r._g_pctl),1)
#define BCM89500_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM89500_A0_G_PCTLr
#define G_PCTLr_SIZE BCM89500_A0_G_PCTLr_SIZE
typedef BCM89500_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM89500_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM89500_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM89500_A0_G_PCTLr_GET
#define G_PCTLr_RX_DISf_GET BCM89500_A0_G_PCTLr_RX_DISf_GET
#define G_PCTLr_RX_DISf_SET BCM89500_A0_G_PCTLr_RX_DISf_SET
#define G_PCTLr_TX_DISf_GET BCM89500_A0_G_PCTLr_TX_DISf_GET
#define G_PCTLr_TX_DISf_SET BCM89500_A0_G_PCTLr_TX_DISf_SET
#define G_PCTLr_RESERVEDf_GET BCM89500_A0_G_PCTLr_RESERVEDf_GET
#define G_PCTLr_RESERVEDf_SET BCM89500_A0_G_PCTLr_RESERVEDf_SET
#define G_PCTLr_G_MISTP_STATEf_GET BCM89500_A0_G_PCTLr_G_MISTP_STATEf_GET
#define G_PCTLr_G_MISTP_STATEf_SET BCM89500_A0_G_PCTLr_G_MISTP_STATEf_SET
#define READ_G_PCTLr BCM89500_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM89500_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDH
 * BLOCKS:   SYS
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDHr 0x00001404

#define BCM89500_A0_G_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH.
 *
 */
typedef union BCM89500_A0_G_PHYIDHr_s {
	uint32_t v[1];
	uint32_t g_phyidh[1];
	uint32_t _g_phyidh;
} BCM89500_A0_G_PHYIDHr_t;

#define BCM89500_A0_G_PHYIDHr_CLR(r) (r).g_phyidh[0] = 0
#define BCM89500_A0_G_PHYIDHr_SET(r,d) (r).g_phyidh[0] = d
#define BCM89500_A0_G_PHYIDHr_GET(r) (r).g_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDHr_OUIf_GET(r) (((r).g_phyidh[0]) & 0xffff)
#define BCM89500_A0_G_PHYIDHr_OUIf_SET(r,f) (r).g_phyidh[0]=(((r).g_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH.
 *
 */
#define BCM89500_A0_READ_G_PHYIDHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDHr,(r._g_phyidh),2)
#define BCM89500_A0_WRITE_G_PHYIDHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDHr,&(r._g_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDHr BCM89500_A0_G_PHYIDHr
#define G_PHYIDHr_SIZE BCM89500_A0_G_PHYIDHr_SIZE
typedef BCM89500_A0_G_PHYIDHr_t G_PHYIDHr_t;
#define G_PHYIDHr_CLR BCM89500_A0_G_PHYIDHr_CLR
#define G_PHYIDHr_SET BCM89500_A0_G_PHYIDHr_SET
#define G_PHYIDHr_GET BCM89500_A0_G_PHYIDHr_GET
#define G_PHYIDHr_OUIf_GET BCM89500_A0_G_PHYIDHr_OUIf_GET
#define G_PHYIDHr_OUIf_SET BCM89500_A0_G_PHYIDHr_OUIf_SET
#define READ_G_PHYIDHr BCM89500_A0_READ_G_PHYIDHr
#define WRITE_G_PHYIDHr BCM89500_A0_WRITE_G_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDH_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDH_EXTr 0x00008804

#define BCM89500_A0_G_PHYIDH_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT.
 *
 */
typedef union BCM89500_A0_G_PHYIDH_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext[1];
	uint32_t _g_phyidh_ext;
} BCM89500_A0_G_PHYIDH_EXTr_t;

#define BCM89500_A0_G_PHYIDH_EXTr_CLR(r) (r).g_phyidh_ext[0] = 0
#define BCM89500_A0_G_PHYIDH_EXTr_SET(r,d) (r).g_phyidh_ext[0] = d
#define BCM89500_A0_G_PHYIDH_EXTr_GET(r) (r).g_phyidh_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDH_EXTr_OUIf_GET(r) (((r).g_phyidh_ext[0]) & 0xffff)
#define BCM89500_A0_G_PHYIDH_EXTr_OUIf_SET(r,f) (r).g_phyidh_ext[0]=(((r).g_phyidh_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT.
 *
 */
#define BCM89500_A0_READ_G_PHYIDH_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDH_EXTr,(r._g_phyidh_ext),2)
#define BCM89500_A0_WRITE_G_PHYIDH_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDH_EXTr,&(r._g_phyidh_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXTr BCM89500_A0_G_PHYIDH_EXTr
#define G_PHYIDH_EXTr_SIZE BCM89500_A0_G_PHYIDH_EXTr_SIZE
typedef BCM89500_A0_G_PHYIDH_EXTr_t G_PHYIDH_EXTr_t;
#define G_PHYIDH_EXTr_CLR BCM89500_A0_G_PHYIDH_EXTr_CLR
#define G_PHYIDH_EXTr_SET BCM89500_A0_G_PHYIDH_EXTr_SET
#define G_PHYIDH_EXTr_GET BCM89500_A0_G_PHYIDH_EXTr_GET
#define G_PHYIDH_EXTr_OUIf_GET BCM89500_A0_G_PHYIDH_EXTr_OUIf_GET
#define G_PHYIDH_EXTr_OUIf_SET BCM89500_A0_G_PHYIDH_EXTr_OUIf_SET
#define READ_G_PHYIDH_EXTr BCM89500_A0_READ_G_PHYIDH_EXTr
#define WRITE_G_PHYIDH_EXTr BCM89500_A0_WRITE_G_PHYIDH_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDH_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDH_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDH_EXT_P4r 0x00008404

#define BCM89500_A0_G_PHYIDH_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_PHYIDH_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext_p4[1];
	uint32_t _g_phyidh_ext_p4;
} BCM89500_A0_G_PHYIDH_EXT_P4r_t;

#define BCM89500_A0_G_PHYIDH_EXT_P4r_CLR(r) (r).g_phyidh_ext_p4[0] = 0
#define BCM89500_A0_G_PHYIDH_EXT_P4r_SET(r,d) (r).g_phyidh_ext_p4[0] = d
#define BCM89500_A0_G_PHYIDH_EXT_P4r_GET(r) (r).g_phyidh_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDH_EXT_P4r_OUIf_GET(r) (((r).g_phyidh_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_PHYIDH_EXT_P4r_OUIf_SET(r,f) (r).g_phyidh_ext_p4[0]=(((r).g_phyidh_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_PHYIDH_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDH_EXT_P4r,(r._g_phyidh_ext_p4),2)
#define BCM89500_A0_WRITE_G_PHYIDH_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDH_EXT_P4r,&(r._g_phyidh_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXT_P4r BCM89500_A0_G_PHYIDH_EXT_P4r
#define G_PHYIDH_EXT_P4r_SIZE BCM89500_A0_G_PHYIDH_EXT_P4r_SIZE
typedef BCM89500_A0_G_PHYIDH_EXT_P4r_t G_PHYIDH_EXT_P4r_t;
#define G_PHYIDH_EXT_P4r_CLR BCM89500_A0_G_PHYIDH_EXT_P4r_CLR
#define G_PHYIDH_EXT_P4r_SET BCM89500_A0_G_PHYIDH_EXT_P4r_SET
#define G_PHYIDH_EXT_P4r_GET BCM89500_A0_G_PHYIDH_EXT_P4r_GET
#define G_PHYIDH_EXT_P4r_OUIf_GET BCM89500_A0_G_PHYIDH_EXT_P4r_OUIf_GET
#define G_PHYIDH_EXT_P4r_OUIf_SET BCM89500_A0_G_PHYIDH_EXT_P4r_OUIf_SET
#define READ_G_PHYIDH_EXT_P4r BCM89500_A0_READ_G_PHYIDH_EXT_P4r
#define WRITE_G_PHYIDH_EXT_P4r BCM89500_A0_WRITE_G_PHYIDH_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDH_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDH_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDH_EXT_P5r 0x00008504

#define BCM89500_A0_G_PHYIDH_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_PHYIDH_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext_p5[1];
	uint32_t _g_phyidh_ext_p5;
} BCM89500_A0_G_PHYIDH_EXT_P5r_t;

#define BCM89500_A0_G_PHYIDH_EXT_P5r_CLR(r) (r).g_phyidh_ext_p5[0] = 0
#define BCM89500_A0_G_PHYIDH_EXT_P5r_SET(r,d) (r).g_phyidh_ext_p5[0] = d
#define BCM89500_A0_G_PHYIDH_EXT_P5r_GET(r) (r).g_phyidh_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDH_EXT_P5r_OUIf_GET(r) (((r).g_phyidh_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_PHYIDH_EXT_P5r_OUIf_SET(r,f) (r).g_phyidh_ext_p5[0]=(((r).g_phyidh_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_PHYIDH_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDH_EXT_P5r,(r._g_phyidh_ext_p5),2)
#define BCM89500_A0_WRITE_G_PHYIDH_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDH_EXT_P5r,&(r._g_phyidh_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXT_P5r BCM89500_A0_G_PHYIDH_EXT_P5r
#define G_PHYIDH_EXT_P5r_SIZE BCM89500_A0_G_PHYIDH_EXT_P5r_SIZE
typedef BCM89500_A0_G_PHYIDH_EXT_P5r_t G_PHYIDH_EXT_P5r_t;
#define G_PHYIDH_EXT_P5r_CLR BCM89500_A0_G_PHYIDH_EXT_P5r_CLR
#define G_PHYIDH_EXT_P5r_SET BCM89500_A0_G_PHYIDH_EXT_P5r_SET
#define G_PHYIDH_EXT_P5r_GET BCM89500_A0_G_PHYIDH_EXT_P5r_GET
#define G_PHYIDH_EXT_P5r_OUIf_GET BCM89500_A0_G_PHYIDH_EXT_P5r_OUIf_GET
#define G_PHYIDH_EXT_P5r_OUIf_SET BCM89500_A0_G_PHYIDH_EXT_P5r_OUIf_SET
#define READ_G_PHYIDH_EXT_P5r BCM89500_A0_READ_G_PHYIDH_EXT_P5r
#define WRITE_G_PHYIDH_EXT_P5r BCM89500_A0_WRITE_G_PHYIDH_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDH_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDH_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDH_EXT_PNr 0x00008004

#define BCM89500_A0_G_PHYIDH_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_PHYIDH_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext_pn[1];
	uint32_t _g_phyidh_ext_pn;
} BCM89500_A0_G_PHYIDH_EXT_PNr_t;

#define BCM89500_A0_G_PHYIDH_EXT_PNr_CLR(r) (r).g_phyidh_ext_pn[0] = 0
#define BCM89500_A0_G_PHYIDH_EXT_PNr_SET(r,d) (r).g_phyidh_ext_pn[0] = d
#define BCM89500_A0_G_PHYIDH_EXT_PNr_GET(r) (r).g_phyidh_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDH_EXT_PNr_OUIf_GET(r) (((r).g_phyidh_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_PHYIDH_EXT_PNr_OUIf_SET(r,f) (r).g_phyidh_ext_pn[0]=(((r).g_phyidh_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_PHYIDH_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_PHYIDH_EXT_PNr,(r._g_phyidh_ext_pn),2)
#define BCM89500_A0_WRITE_G_PHYIDH_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_PHYIDH_EXT_PNr,&(r._g_phyidh_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXT_PNr BCM89500_A0_G_PHYIDH_EXT_PNr
#define G_PHYIDH_EXT_PNr_SIZE BCM89500_A0_G_PHYIDH_EXT_PNr_SIZE
typedef BCM89500_A0_G_PHYIDH_EXT_PNr_t G_PHYIDH_EXT_PNr_t;
#define G_PHYIDH_EXT_PNr_CLR BCM89500_A0_G_PHYIDH_EXT_PNr_CLR
#define G_PHYIDH_EXT_PNr_SET BCM89500_A0_G_PHYIDH_EXT_PNr_SET
#define G_PHYIDH_EXT_PNr_GET BCM89500_A0_G_PHYIDH_EXT_PNr_GET
#define G_PHYIDH_EXT_PNr_OUIf_GET BCM89500_A0_G_PHYIDH_EXT_PNr_OUIf_GET
#define G_PHYIDH_EXT_PNr_OUIf_SET BCM89500_A0_G_PHYIDH_EXT_PNr_OUIf_SET
#define READ_G_PHYIDH_EXT_PNr BCM89500_A0_READ_G_PHYIDH_EXT_PNr
#define WRITE_G_PHYIDH_EXT_PNr BCM89500_A0_WRITE_G_PHYIDH_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDH_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDH_P7
 * BLOCKS:   SYS
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDH_P7r 0x00001704

#define BCM89500_A0_G_PHYIDH_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_P7.
 *
 */
typedef union BCM89500_A0_G_PHYIDH_P7r_s {
	uint32_t v[1];
	uint32_t g_phyidh_p7[1];
	uint32_t _g_phyidh_p7;
} BCM89500_A0_G_PHYIDH_P7r_t;

#define BCM89500_A0_G_PHYIDH_P7r_CLR(r) (r).g_phyidh_p7[0] = 0
#define BCM89500_A0_G_PHYIDH_P7r_SET(r,d) (r).g_phyidh_p7[0] = d
#define BCM89500_A0_G_PHYIDH_P7r_GET(r) (r).g_phyidh_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDH_P7r_OUIf_GET(r) (((r).g_phyidh_p7[0]) & 0xffff)
#define BCM89500_A0_G_PHYIDH_P7r_OUIf_SET(r,f) (r).g_phyidh_p7[0]=(((r).g_phyidh_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_P7.
 *
 */
#define BCM89500_A0_READ_G_PHYIDH_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDH_P7r,(r._g_phyidh_p7),2)
#define BCM89500_A0_WRITE_G_PHYIDH_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDH_P7r,&(r._g_phyidh_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_P7r BCM89500_A0_G_PHYIDH_P7r
#define G_PHYIDH_P7r_SIZE BCM89500_A0_G_PHYIDH_P7r_SIZE
typedef BCM89500_A0_G_PHYIDH_P7r_t G_PHYIDH_P7r_t;
#define G_PHYIDH_P7r_CLR BCM89500_A0_G_PHYIDH_P7r_CLR
#define G_PHYIDH_P7r_SET BCM89500_A0_G_PHYIDH_P7r_SET
#define G_PHYIDH_P7r_GET BCM89500_A0_G_PHYIDH_P7r_GET
#define G_PHYIDH_P7r_OUIf_GET BCM89500_A0_G_PHYIDH_P7r_OUIf_GET
#define G_PHYIDH_P7r_OUIf_SET BCM89500_A0_G_PHYIDH_P7r_OUIf_SET
#define READ_G_PHYIDH_P7r BCM89500_A0_READ_G_PHYIDH_P7r
#define WRITE_G_PHYIDH_P7r BCM89500_A0_WRITE_G_PHYIDH_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDH_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDL
 * BLOCKS:   SYS
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDLr 0x00001406

#define BCM89500_A0_G_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL.
 *
 */
typedef union BCM89500_A0_G_PHYIDLr_s {
	uint32_t v[1];
	uint32_t g_phyidl[1];
	uint32_t _g_phyidl;
} BCM89500_A0_G_PHYIDLr_t;

#define BCM89500_A0_G_PHYIDLr_CLR(r) (r).g_phyidl[0] = 0
#define BCM89500_A0_G_PHYIDLr_SET(r,d) (r).g_phyidl[0] = d
#define BCM89500_A0_G_PHYIDLr_GET(r) (r).g_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDLr_REVISIONf_GET(r) (((r).g_phyidl[0]) & 0xf)
#define BCM89500_A0_G_PHYIDLr_REVISIONf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_G_PHYIDLr_MODELf_GET(r) ((((r).g_phyidl[0]) >> 4) & 0x3f)
#define BCM89500_A0_G_PHYIDLr_MODELf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_G_PHYIDLr_OUIf_GET(r) ((((r).g_phyidl[0]) >> 10) & 0x3f)
#define BCM89500_A0_G_PHYIDLr_OUIf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL.
 *
 */
#define BCM89500_A0_READ_G_PHYIDLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDLr,(r._g_phyidl),2)
#define BCM89500_A0_WRITE_G_PHYIDLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDLr,&(r._g_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDLr BCM89500_A0_G_PHYIDLr
#define G_PHYIDLr_SIZE BCM89500_A0_G_PHYIDLr_SIZE
typedef BCM89500_A0_G_PHYIDLr_t G_PHYIDLr_t;
#define G_PHYIDLr_CLR BCM89500_A0_G_PHYIDLr_CLR
#define G_PHYIDLr_SET BCM89500_A0_G_PHYIDLr_SET
#define G_PHYIDLr_GET BCM89500_A0_G_PHYIDLr_GET
#define G_PHYIDLr_REVISIONf_GET BCM89500_A0_G_PHYIDLr_REVISIONf_GET
#define G_PHYIDLr_REVISIONf_SET BCM89500_A0_G_PHYIDLr_REVISIONf_SET
#define G_PHYIDLr_MODELf_GET BCM89500_A0_G_PHYIDLr_MODELf_GET
#define G_PHYIDLr_MODELf_SET BCM89500_A0_G_PHYIDLr_MODELf_SET
#define G_PHYIDLr_OUIf_GET BCM89500_A0_G_PHYIDLr_OUIf_GET
#define G_PHYIDLr_OUIf_SET BCM89500_A0_G_PHYIDLr_OUIf_SET
#define READ_G_PHYIDLr BCM89500_A0_READ_G_PHYIDLr
#define WRITE_G_PHYIDLr BCM89500_A0_WRITE_G_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDL_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).Note: this register read value come from exteranl PHY.
 *     MODEL            Device model number (metal programmable).Note: this register read value come from exteranl PHY.
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDL_EXTr 0x00008806

#define BCM89500_A0_G_PHYIDL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT.
 *
 */
typedef union BCM89500_A0_G_PHYIDL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext[1];
	uint32_t _g_phyidl_ext;
} BCM89500_A0_G_PHYIDL_EXTr_t;

#define BCM89500_A0_G_PHYIDL_EXTr_CLR(r) (r).g_phyidl_ext[0] = 0
#define BCM89500_A0_G_PHYIDL_EXTr_SET(r,d) (r).g_phyidl_ext[0] = d
#define BCM89500_A0_G_PHYIDL_EXTr_GET(r) (r).g_phyidl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDL_EXTr_REVISIONf_GET(r) (((r).g_phyidl_ext[0]) & 0xf)
#define BCM89500_A0_G_PHYIDL_EXTr_REVISIONf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_G_PHYIDL_EXTr_MODELf_GET(r) ((((r).g_phyidl_ext[0]) >> 4) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXTr_MODELf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_G_PHYIDL_EXTr_OUIf_GET(r) ((((r).g_phyidl_ext[0]) >> 10) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXTr_OUIf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT.
 *
 */
#define BCM89500_A0_READ_G_PHYIDL_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDL_EXTr,(r._g_phyidl_ext),2)
#define BCM89500_A0_WRITE_G_PHYIDL_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDL_EXTr,&(r._g_phyidl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXTr BCM89500_A0_G_PHYIDL_EXTr
#define G_PHYIDL_EXTr_SIZE BCM89500_A0_G_PHYIDL_EXTr_SIZE
typedef BCM89500_A0_G_PHYIDL_EXTr_t G_PHYIDL_EXTr_t;
#define G_PHYIDL_EXTr_CLR BCM89500_A0_G_PHYIDL_EXTr_CLR
#define G_PHYIDL_EXTr_SET BCM89500_A0_G_PHYIDL_EXTr_SET
#define G_PHYIDL_EXTr_GET BCM89500_A0_G_PHYIDL_EXTr_GET
#define G_PHYIDL_EXTr_REVISIONf_GET BCM89500_A0_G_PHYIDL_EXTr_REVISIONf_GET
#define G_PHYIDL_EXTr_REVISIONf_SET BCM89500_A0_G_PHYIDL_EXTr_REVISIONf_SET
#define G_PHYIDL_EXTr_MODELf_GET BCM89500_A0_G_PHYIDL_EXTr_MODELf_GET
#define G_PHYIDL_EXTr_MODELf_SET BCM89500_A0_G_PHYIDL_EXTr_MODELf_SET
#define G_PHYIDL_EXTr_OUIf_GET BCM89500_A0_G_PHYIDL_EXTr_OUIf_GET
#define G_PHYIDL_EXTr_OUIf_SET BCM89500_A0_G_PHYIDL_EXTr_OUIf_SET
#define READ_G_PHYIDL_EXTr BCM89500_A0_READ_G_PHYIDL_EXTr
#define WRITE_G_PHYIDL_EXTr BCM89500_A0_WRITE_G_PHYIDL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDL_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).Note: this register read value come from exteranl PHY.
 *     MODEL            Device model number (metal programmable).Note: this register read value come from exteranl PHY.
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDL_EXT_P4r 0x00008406

#define BCM89500_A0_G_PHYIDL_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_PHYIDL_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext_p4[1];
	uint32_t _g_phyidl_ext_p4;
} BCM89500_A0_G_PHYIDL_EXT_P4r_t;

#define BCM89500_A0_G_PHYIDL_EXT_P4r_CLR(r) (r).g_phyidl_ext_p4[0] = 0
#define BCM89500_A0_G_PHYIDL_EXT_P4r_SET(r,d) (r).g_phyidl_ext_p4[0] = d
#define BCM89500_A0_G_PHYIDL_EXT_P4r_GET(r) (r).g_phyidl_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDL_EXT_P4r_REVISIONf_GET(r) (((r).g_phyidl_ext_p4[0]) & 0xf)
#define BCM89500_A0_G_PHYIDL_EXT_P4r_REVISIONf_SET(r,f) (r).g_phyidl_ext_p4[0]=(((r).g_phyidl_ext_p4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_G_PHYIDL_EXT_P4r_MODELf_GET(r) ((((r).g_phyidl_ext_p4[0]) >> 4) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXT_P4r_MODELf_SET(r,f) (r).g_phyidl_ext_p4[0]=(((r).g_phyidl_ext_p4[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_G_PHYIDL_EXT_P4r_OUIf_GET(r) ((((r).g_phyidl_ext_p4[0]) >> 10) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXT_P4r_OUIf_SET(r,f) (r).g_phyidl_ext_p4[0]=(((r).g_phyidl_ext_p4[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_PHYIDL_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDL_EXT_P4r,(r._g_phyidl_ext_p4),2)
#define BCM89500_A0_WRITE_G_PHYIDL_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDL_EXT_P4r,&(r._g_phyidl_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXT_P4r BCM89500_A0_G_PHYIDL_EXT_P4r
#define G_PHYIDL_EXT_P4r_SIZE BCM89500_A0_G_PHYIDL_EXT_P4r_SIZE
typedef BCM89500_A0_G_PHYIDL_EXT_P4r_t G_PHYIDL_EXT_P4r_t;
#define G_PHYIDL_EXT_P4r_CLR BCM89500_A0_G_PHYIDL_EXT_P4r_CLR
#define G_PHYIDL_EXT_P4r_SET BCM89500_A0_G_PHYIDL_EXT_P4r_SET
#define G_PHYIDL_EXT_P4r_GET BCM89500_A0_G_PHYIDL_EXT_P4r_GET
#define G_PHYIDL_EXT_P4r_REVISIONf_GET BCM89500_A0_G_PHYIDL_EXT_P4r_REVISIONf_GET
#define G_PHYIDL_EXT_P4r_REVISIONf_SET BCM89500_A0_G_PHYIDL_EXT_P4r_REVISIONf_SET
#define G_PHYIDL_EXT_P4r_MODELf_GET BCM89500_A0_G_PHYIDL_EXT_P4r_MODELf_GET
#define G_PHYIDL_EXT_P4r_MODELf_SET BCM89500_A0_G_PHYIDL_EXT_P4r_MODELf_SET
#define G_PHYIDL_EXT_P4r_OUIf_GET BCM89500_A0_G_PHYIDL_EXT_P4r_OUIf_GET
#define G_PHYIDL_EXT_P4r_OUIf_SET BCM89500_A0_G_PHYIDL_EXT_P4r_OUIf_SET
#define READ_G_PHYIDL_EXT_P4r BCM89500_A0_READ_G_PHYIDL_EXT_P4r
#define WRITE_G_PHYIDL_EXT_P4r BCM89500_A0_WRITE_G_PHYIDL_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDL_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).Note: this register read value come from exteranl PHY.
 *     MODEL            Device model number (metal programmable).Note: this register read value come from exteranl PHY.
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDL_EXT_P5r 0x00008506

#define BCM89500_A0_G_PHYIDL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_PHYIDL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext_p5[1];
	uint32_t _g_phyidl_ext_p5;
} BCM89500_A0_G_PHYIDL_EXT_P5r_t;

#define BCM89500_A0_G_PHYIDL_EXT_P5r_CLR(r) (r).g_phyidl_ext_p5[0] = 0
#define BCM89500_A0_G_PHYIDL_EXT_P5r_SET(r,d) (r).g_phyidl_ext_p5[0] = d
#define BCM89500_A0_G_PHYIDL_EXT_P5r_GET(r) (r).g_phyidl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDL_EXT_P5r_REVISIONf_GET(r) (((r).g_phyidl_ext_p5[0]) & 0xf)
#define BCM89500_A0_G_PHYIDL_EXT_P5r_REVISIONf_SET(r,f) (r).g_phyidl_ext_p5[0]=(((r).g_phyidl_ext_p5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_G_PHYIDL_EXT_P5r_MODELf_GET(r) ((((r).g_phyidl_ext_p5[0]) >> 4) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXT_P5r_MODELf_SET(r,f) (r).g_phyidl_ext_p5[0]=(((r).g_phyidl_ext_p5[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_G_PHYIDL_EXT_P5r_OUIf_GET(r) ((((r).g_phyidl_ext_p5[0]) >> 10) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXT_P5r_OUIf_SET(r,f) (r).g_phyidl_ext_p5[0]=(((r).g_phyidl_ext_p5[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_PHYIDL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDL_EXT_P5r,(r._g_phyidl_ext_p5),2)
#define BCM89500_A0_WRITE_G_PHYIDL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDL_EXT_P5r,&(r._g_phyidl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXT_P5r BCM89500_A0_G_PHYIDL_EXT_P5r
#define G_PHYIDL_EXT_P5r_SIZE BCM89500_A0_G_PHYIDL_EXT_P5r_SIZE
typedef BCM89500_A0_G_PHYIDL_EXT_P5r_t G_PHYIDL_EXT_P5r_t;
#define G_PHYIDL_EXT_P5r_CLR BCM89500_A0_G_PHYIDL_EXT_P5r_CLR
#define G_PHYIDL_EXT_P5r_SET BCM89500_A0_G_PHYIDL_EXT_P5r_SET
#define G_PHYIDL_EXT_P5r_GET BCM89500_A0_G_PHYIDL_EXT_P5r_GET
#define G_PHYIDL_EXT_P5r_REVISIONf_GET BCM89500_A0_G_PHYIDL_EXT_P5r_REVISIONf_GET
#define G_PHYIDL_EXT_P5r_REVISIONf_SET BCM89500_A0_G_PHYIDL_EXT_P5r_REVISIONf_SET
#define G_PHYIDL_EXT_P5r_MODELf_GET BCM89500_A0_G_PHYIDL_EXT_P5r_MODELf_GET
#define G_PHYIDL_EXT_P5r_MODELf_SET BCM89500_A0_G_PHYIDL_EXT_P5r_MODELf_SET
#define G_PHYIDL_EXT_P5r_OUIf_GET BCM89500_A0_G_PHYIDL_EXT_P5r_OUIf_GET
#define G_PHYIDL_EXT_P5r_OUIf_SET BCM89500_A0_G_PHYIDL_EXT_P5r_OUIf_SET
#define READ_G_PHYIDL_EXT_P5r BCM89500_A0_READ_G_PHYIDL_EXT_P5r
#define WRITE_G_PHYIDL_EXT_P5r BCM89500_A0_WRITE_G_PHYIDL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDL_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).Note: this register read value come from exteranl PHY.
 *     MODEL            Device model number (metal programmable).Note: this register read value come from exteranl PHY.
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDL_EXT_PNr 0x00008006

#define BCM89500_A0_G_PHYIDL_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_PHYIDL_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext_pn[1];
	uint32_t _g_phyidl_ext_pn;
} BCM89500_A0_G_PHYIDL_EXT_PNr_t;

#define BCM89500_A0_G_PHYIDL_EXT_PNr_CLR(r) (r).g_phyidl_ext_pn[0] = 0
#define BCM89500_A0_G_PHYIDL_EXT_PNr_SET(r,d) (r).g_phyidl_ext_pn[0] = d
#define BCM89500_A0_G_PHYIDL_EXT_PNr_GET(r) (r).g_phyidl_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDL_EXT_PNr_REVISIONf_GET(r) (((r).g_phyidl_ext_pn[0]) & 0xf)
#define BCM89500_A0_G_PHYIDL_EXT_PNr_REVISIONf_SET(r,f) (r).g_phyidl_ext_pn[0]=(((r).g_phyidl_ext_pn[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_G_PHYIDL_EXT_PNr_MODELf_GET(r) ((((r).g_phyidl_ext_pn[0]) >> 4) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXT_PNr_MODELf_SET(r,f) (r).g_phyidl_ext_pn[0]=(((r).g_phyidl_ext_pn[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_G_PHYIDL_EXT_PNr_OUIf_GET(r) ((((r).g_phyidl_ext_pn[0]) >> 10) & 0x3f)
#define BCM89500_A0_G_PHYIDL_EXT_PNr_OUIf_SET(r,f) (r).g_phyidl_ext_pn[0]=(((r).g_phyidl_ext_pn[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_PHYIDL_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_PHYIDL_EXT_PNr,(r._g_phyidl_ext_pn),2)
#define BCM89500_A0_WRITE_G_PHYIDL_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_PHYIDL_EXT_PNr,&(r._g_phyidl_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXT_PNr BCM89500_A0_G_PHYIDL_EXT_PNr
#define G_PHYIDL_EXT_PNr_SIZE BCM89500_A0_G_PHYIDL_EXT_PNr_SIZE
typedef BCM89500_A0_G_PHYIDL_EXT_PNr_t G_PHYIDL_EXT_PNr_t;
#define G_PHYIDL_EXT_PNr_CLR BCM89500_A0_G_PHYIDL_EXT_PNr_CLR
#define G_PHYIDL_EXT_PNr_SET BCM89500_A0_G_PHYIDL_EXT_PNr_SET
#define G_PHYIDL_EXT_PNr_GET BCM89500_A0_G_PHYIDL_EXT_PNr_GET
#define G_PHYIDL_EXT_PNr_REVISIONf_GET BCM89500_A0_G_PHYIDL_EXT_PNr_REVISIONf_GET
#define G_PHYIDL_EXT_PNr_REVISIONf_SET BCM89500_A0_G_PHYIDL_EXT_PNr_REVISIONf_SET
#define G_PHYIDL_EXT_PNr_MODELf_GET BCM89500_A0_G_PHYIDL_EXT_PNr_MODELf_GET
#define G_PHYIDL_EXT_PNr_MODELf_SET BCM89500_A0_G_PHYIDL_EXT_PNr_MODELf_SET
#define G_PHYIDL_EXT_PNr_OUIf_GET BCM89500_A0_G_PHYIDL_EXT_PNr_OUIf_GET
#define G_PHYIDL_EXT_PNr_OUIf_SET BCM89500_A0_G_PHYIDL_EXT_PNr_OUIf_SET
#define READ_G_PHYIDL_EXT_PNr BCM89500_A0_READ_G_PHYIDL_EXT_PNr
#define WRITE_G_PHYIDL_EXT_PNr BCM89500_A0_WRITE_G_PHYIDL_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDL_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHYIDL_P7
 * BLOCKS:   SYS
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Chip Version ID.Bit 3:2 - Revision ID-00 = A-01 = B-10 = C-11 = DBit 1:0 - Revision number
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHYIDL_P7r 0x00001706

#define BCM89500_A0_G_PHYIDL_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_P7.
 *
 */
typedef union BCM89500_A0_G_PHYIDL_P7r_s {
	uint32_t v[1];
	uint32_t g_phyidl_p7[1];
	uint32_t _g_phyidl_p7;
} BCM89500_A0_G_PHYIDL_P7r_t;

#define BCM89500_A0_G_PHYIDL_P7r_CLR(r) (r).g_phyidl_p7[0] = 0
#define BCM89500_A0_G_PHYIDL_P7r_SET(r,d) (r).g_phyidl_p7[0] = d
#define BCM89500_A0_G_PHYIDL_P7r_GET(r) (r).g_phyidl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHYIDL_P7r_REVISIONf_GET(r) (((r).g_phyidl_p7[0]) & 0xf)
#define BCM89500_A0_G_PHYIDL_P7r_REVISIONf_SET(r,f) (r).g_phyidl_p7[0]=(((r).g_phyidl_p7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_G_PHYIDL_P7r_MODELf_GET(r) ((((r).g_phyidl_p7[0]) >> 4) & 0x3f)
#define BCM89500_A0_G_PHYIDL_P7r_MODELf_SET(r,f) (r).g_phyidl_p7[0]=(((r).g_phyidl_p7[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_G_PHYIDL_P7r_OUIf_GET(r) ((((r).g_phyidl_p7[0]) >> 10) & 0x3f)
#define BCM89500_A0_G_PHYIDL_P7r_OUIf_SET(r,f) (r).g_phyidl_p7[0]=(((r).g_phyidl_p7[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_P7.
 *
 */
#define BCM89500_A0_READ_G_PHYIDL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHYIDL_P7r,(r._g_phyidl_p7),2)
#define BCM89500_A0_WRITE_G_PHYIDL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHYIDL_P7r,&(r._g_phyidl_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_P7r BCM89500_A0_G_PHYIDL_P7r
#define G_PHYIDL_P7r_SIZE BCM89500_A0_G_PHYIDL_P7r_SIZE
typedef BCM89500_A0_G_PHYIDL_P7r_t G_PHYIDL_P7r_t;
#define G_PHYIDL_P7r_CLR BCM89500_A0_G_PHYIDL_P7r_CLR
#define G_PHYIDL_P7r_SET BCM89500_A0_G_PHYIDL_P7r_SET
#define G_PHYIDL_P7r_GET BCM89500_A0_G_PHYIDL_P7r_GET
#define G_PHYIDL_P7r_REVISIONf_GET BCM89500_A0_G_PHYIDL_P7r_REVISIONf_GET
#define G_PHYIDL_P7r_REVISIONf_SET BCM89500_A0_G_PHYIDL_P7r_REVISIONf_SET
#define G_PHYIDL_P7r_MODELf_GET BCM89500_A0_G_PHYIDL_P7r_MODELf_GET
#define G_PHYIDL_P7r_MODELf_SET BCM89500_A0_G_PHYIDL_P7r_MODELf_SET
#define G_PHYIDL_P7r_OUIf_GET BCM89500_A0_G_PHYIDL_P7r_OUIf_GET
#define G_PHYIDL_P7r_OUIf_SET BCM89500_A0_G_PHYIDL_P7r_OUIf_SET
#define READ_G_PHYIDL_P7r BCM89500_A0_READ_G_PHYIDL_P7r
#define WRITE_G_PHYIDL_P7r BCM89500_A0_WRITE_G_PHYIDL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHYIDL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_CTL
 * BLOCKS:   SYS
 * DESC:     PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Write as 0, ignore on read.
 *     UNIDIRECTIONAL_ENABLE 1 = able to transmit packets when no link0 = requires link in order to transmit packets(similar to IEEE register 0, bit 5.
 *     BLK_TXEN_MOD     1 = extend transmit IPG to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into "OFF" state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into "ON" state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     RESERVED_1       Write as 0.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_CTLr 0x00001420

#define BCM89500_A0_G_PHY_EXT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_CTLr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl[1];
	uint32_t _g_phy_ext_ctl;
} BCM89500_A0_G_PHY_EXT_CTLr_t;

#define BCM89500_A0_G_PHY_EXT_CTLr_CLR(r) (r).g_phy_ext_ctl[0] = 0
#define BCM89500_A0_G_PHY_EXT_CTLr_SET(r,d) (r).g_phy_ext_ctl[0] = d
#define BCM89500_A0_G_PHY_EXT_CTLr_GET(r) (r).g_phy_ext_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_0f_GET(r) (((r).g_phy_ext_ctl[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_0f_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_1f_GET(r) ((((r).g_phy_ext_ctl[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_1f_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_CTLr,(r._g_phy_ext_ctl),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_CTLr,&(r._g_phy_ext_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTLr BCM89500_A0_G_PHY_EXT_CTLr
#define G_PHY_EXT_CTLr_SIZE BCM89500_A0_G_PHY_EXT_CTLr_SIZE
typedef BCM89500_A0_G_PHY_EXT_CTLr_t G_PHY_EXT_CTLr_t;
#define G_PHY_EXT_CTLr_CLR BCM89500_A0_G_PHY_EXT_CTLr_CLR
#define G_PHY_EXT_CTLr_SET BCM89500_A0_G_PHY_EXT_CTLr_SET
#define G_PHY_EXT_CTLr_GET BCM89500_A0_G_PHY_EXT_CTLr_GET
#define G_PHY_EXT_CTLr_RESERVED_0f_GET BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_0f_GET
#define G_PHY_EXT_CTLr_RESERVED_0f_SET BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_0f_SET
#define G_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_GET BCM89500_A0_G_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_GET
#define G_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_SET BCM89500_A0_G_PHY_EXT_CTLr_UNIDIRECTIONAL_ENABLEf_SET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET BCM89500_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET BCM89500_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_GET BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_SET BCM89500_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET BCM89500_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET BCM89500_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET BCM89500_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_GET BCM89500_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_SET BCM89500_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_GET BCM89500_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_SET BCM89500_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTLr_RESERVED_1f_GET BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_1f_GET
#define G_PHY_EXT_CTLr_RESERVED_1f_SET BCM89500_A0_G_PHY_EXT_CTLr_RESERVED_1f_SET
#define READ_G_PHY_EXT_CTLr BCM89500_A0_READ_G_PHY_EXT_CTLr
#define WRITE_G_PHY_EXT_CTLr BCM89500_A0_WRITE_G_PHY_EXT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr 0x00008820

#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext[1];
	uint32_t _g_phy_ext_ctl_ext;
} BCM89500_A0_G_PHY_EXT_CTL_EXTr_t;

#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_CLR(r) (r).g_phy_ext_ctl_ext[0] = 0
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_SET(r,d) (r).g_phy_ext_ctl_ext[0] = d
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_GET(r) (r).g_phy_ext_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_CTL_EXTr,(r._g_phy_ext_ctl_ext),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_CTL_EXTr,&(r._g_phy_ext_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXTr BCM89500_A0_G_PHY_EXT_CTL_EXTr
#define G_PHY_EXT_CTL_EXTr_SIZE BCM89500_A0_G_PHY_EXT_CTL_EXTr_SIZE
typedef BCM89500_A0_G_PHY_EXT_CTL_EXTr_t G_PHY_EXT_CTL_EXTr_t;
#define G_PHY_EXT_CTL_EXTr_CLR BCM89500_A0_G_PHY_EXT_CTL_EXTr_CLR
#define G_PHY_EXT_CTL_EXTr_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_SET
#define G_PHY_EXT_CTL_EXTr_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXTr BCM89500_A0_READ_G_PHY_EXT_CTL_EXTr
#define WRITE_G_PHY_EXT_CTL_EXTr BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r 0x00008420

#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext_p4[1];
	uint32_t _g_phy_ext_ctl_ext_p4;
} BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_t;

#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_CLR(r) (r).g_phy_ext_ctl_ext_p4[0] = 0
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_SET(r,d) (r).g_phy_ext_ctl_ext_p4[0] = d
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_GET(r) (r).g_phy_ext_ctl_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext_p4[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p4[0]=(((r).g_phy_ext_ctl_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_CTL_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r,(r._g_phy_ext_ctl_ext_p4),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r,&(r._g_phy_ext_ctl_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXT_P4r BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r
#define G_PHY_EXT_CTL_EXT_P4r_SIZE BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_SIZE
typedef BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_t G_PHY_EXT_CTL_EXT_P4r_t;
#define G_PHY_EXT_CTL_EXT_P4r_CLR BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_CLR
#define G_PHY_EXT_CTL_EXT_P4r_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_SET
#define G_PHY_EXT_CTL_EXT_P4r_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_GET
#define G_PHY_EXT_CTL_EXT_P4r_B1000T_PCS_TRANS_FIFOf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXT_P4r_B1000T_PCS_TRANS_FIFOf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXT_P4r_GMII_FIFO_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXT_P4r_GMII_FIFO_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXT_P4r_BLK_TXEN_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXT_P4r_BLK_TXEN_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_OFFf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_OFFf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_ONf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_ONf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXT_P4r_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXT_P4r_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXT_P4r_RST_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P4r_RST_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_ALIGNMENTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_ALIGNMENTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_NRZI_MLT3f_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_NRZI_MLT3f_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_ENCODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXT_P4r_BYPASS_ENCODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXT_P4r_FORCE_INTERRUPTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXT_P4r_FORCE_INTERRUPTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXT_P4r_INTERRUPT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P4r_INTERRUPT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P4r_TRANSMIT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P4r_TRANSMIT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P4r_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXT_P4r_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXT_P4r_MAC_PHY_MODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXT_P4r_MAC_PHY_MODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXT_P4r BCM89500_A0_READ_G_PHY_EXT_CTL_EXT_P4r
#define WRITE_G_PHY_EXT_CTL_EXT_P4r BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_CTL_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r 0x00008520

#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext_p5[1];
	uint32_t _g_phy_ext_ctl_ext_p5;
} BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_t;

#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_CLR(r) (r).g_phy_ext_ctl_ext_p5[0] = 0
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_SET(r,d) (r).g_phy_ext_ctl_ext_p5[0] = d
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_GET(r) (r).g_phy_ext_ctl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext_p5[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_CTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r,(r._g_phy_ext_ctl_ext_p5),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r,&(r._g_phy_ext_ctl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXT_P5r BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r
#define G_PHY_EXT_CTL_EXT_P5r_SIZE BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_SIZE
typedef BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_t G_PHY_EXT_CTL_EXT_P5r_t;
#define G_PHY_EXT_CTL_EXT_P5r_CLR BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_CLR
#define G_PHY_EXT_CTL_EXT_P5r_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_SET
#define G_PHY_EXT_CTL_EXT_P5r_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_GET
#define G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXT_P5r BCM89500_A0_READ_G_PHY_EXT_CTL_EXT_P5r
#define WRITE_G_PHY_EXT_CTL_EXT_P5r BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_CTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr 0x00008020

#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext_pn[1];
	uint32_t _g_phy_ext_ctl_ext_pn;
} BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_t;

#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_CLR(r) (r).g_phy_ext_ctl_ext_pn[0] = 0
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_SET(r,d) (r).g_phy_ext_ctl_ext_pn[0] = d
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_GET(r) (r).g_phy_ext_ctl_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext_pn[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext_pn[0]=(((r).g_phy_ext_ctl_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_CTL_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr,(r._g_phy_ext_ctl_ext_pn),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr,&(r._g_phy_ext_ctl_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXT_PNr BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr
#define G_PHY_EXT_CTL_EXT_PNr_SIZE BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_SIZE
typedef BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_t G_PHY_EXT_CTL_EXT_PNr_t;
#define G_PHY_EXT_CTL_EXT_PNr_CLR BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_CLR
#define G_PHY_EXT_CTL_EXT_PNr_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_SET
#define G_PHY_EXT_CTL_EXT_PNr_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_GET
#define G_PHY_EXT_CTL_EXT_PNr_B1000T_PCS_TRANS_FIFOf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXT_PNr_B1000T_PCS_TRANS_FIFOf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXT_PNr_GMII_FIFO_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXT_PNr_GMII_FIFO_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXT_PNr_BLK_TXEN_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXT_PNr_BLK_TXEN_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_OFFf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_OFFf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_ONf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_ONf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXT_PNr_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXT_PNr_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXT_PNr_RST_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_PNr_RST_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_ALIGNMENTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_ALIGNMENTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_NRZI_MLT3f_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_NRZI_MLT3f_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_ENCODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXT_PNr_BYPASS_ENCODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXT_PNr_FORCE_INTERRUPTf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXT_PNr_FORCE_INTERRUPTf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXT_PNr_INTERRUPT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXT_PNr_INTERRUPT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXT_PNr_TRANSMIT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXT_PNr_TRANSMIT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXT_PNr_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXT_PNr_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXT_PNr_MAC_PHY_MODEf_GET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXT_PNr_MAC_PHY_MODEf_SET BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXT_PNr BCM89500_A0_READ_G_PHY_EXT_CTL_EXT_PNr
#define WRITE_G_PHY_EXT_CTL_EXT_PNr BCM89500_A0_WRITE_G_PHY_EXT_CTL_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_CTL_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_CTL_P7
 * BLOCKS:   SYS
 * DESC:     PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_CTL_P7r 0x00001720

#define BCM89500_A0_G_PHY_EXT_CTL_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_P7.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_CTL_P7r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_p7[1];
	uint32_t _g_phy_ext_ctl_p7;
} BCM89500_A0_G_PHY_EXT_CTL_P7r_t;

#define BCM89500_A0_G_PHY_EXT_CTL_P7r_CLR(r) (r).g_phy_ext_ctl_p7[0] = 0
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_SET(r,d) (r).g_phy_ext_ctl_p7[0] = d
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_GET(r) (r).g_phy_ext_ctl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_p7[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_CTL_P7r_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_p7[0]=(((r).g_phy_ext_ctl_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_P7.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_CTL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_CTL_P7r,(r._g_phy_ext_ctl_p7),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_CTL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_CTL_P7r,&(r._g_phy_ext_ctl_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_P7r BCM89500_A0_G_PHY_EXT_CTL_P7r
#define G_PHY_EXT_CTL_P7r_SIZE BCM89500_A0_G_PHY_EXT_CTL_P7r_SIZE
typedef BCM89500_A0_G_PHY_EXT_CTL_P7r_t G_PHY_EXT_CTL_P7r_t;
#define G_PHY_EXT_CTL_P7r_CLR BCM89500_A0_G_PHY_EXT_CTL_P7r_CLR
#define G_PHY_EXT_CTL_P7r_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_SET
#define G_PHY_EXT_CTL_P7r_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_GET
#define G_PHY_EXT_CTL_P7r_B1000T_PCS_TRANS_FIFOf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_P7r_B1000T_PCS_TRANS_FIFOf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_P7r_GMII_FIFO_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_P7r_GMII_FIFO_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_P7r_BLK_TXEN_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_P7r_BLK_TXEN_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_P7r_FORCE_LED_OFFf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_P7r_FORCE_LED_OFFf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_P7r_FORCE_LED_ONf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_P7r_FORCE_LED_ONf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_P7r_EN_LED_TRAFFIC_MODf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_P7r_EN_LED_TRAFFIC_MODf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_P7r_RST_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_P7r_RST_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_P7r_BYPASS_ALIGNMENTf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_P7r_BYPASS_ALIGNMENTf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_P7r_BYPASS_NRZI_MLT3f_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_P7r_BYPASS_NRZI_MLT3f_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_P7r_BYPASS_SCRAMBLERf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_P7r_BYPASS_SCRAMBLERf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_P7r_BYPASS_ENCODEf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_P7r_BYPASS_ENCODEf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_P7r_FORCE_INTERRUPTf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_P7r_FORCE_INTERRUPTf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_P7r_INTERRUPT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_P7r_INTERRUPT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_P7r_TRANSMIT_DISf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_P7r_TRANSMIT_DISf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_P7r_DIS_AUTO_MDI_CROSf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_P7r_DIS_AUTO_MDI_CROSf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_P7r_MAC_PHY_MODEf_GET BCM89500_A0_G_PHY_EXT_CTL_P7r_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_P7r_MAC_PHY_MODEf_SET BCM89500_A0_G_PHY_EXT_CTL_P7r_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_P7r BCM89500_A0_READ_G_PHY_EXT_CTL_P7r
#define WRITE_G_PHY_EXT_CTL_P7r BCM89500_A0_WRITE_G_PHY_EXT_CTL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_CTL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_STS
 * BLOCKS:   SYS
 * DESC:     PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_STSr 0x00001422

#define BCM89500_A0_G_PHY_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts[1];
	uint32_t _g_phy_ext_sts;
} BCM89500_A0_G_PHY_EXT_STSr_t;

#define BCM89500_A0_G_PHY_EXT_STSr_CLR(r) (r).g_phy_ext_sts[0] = 0
#define BCM89500_A0_G_PHY_EXT_STSr_SET(r,d) (r).g_phy_ext_sts[0] = d
#define BCM89500_A0_G_PHY_EXT_STSr_GET(r) (r).g_phy_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_STSr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_STSr_LOCKf_GET(r) ((((r).g_phy_ext_sts[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_LOCKf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_STSr,(r._g_phy_ext_sts),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_STSr,&(r._g_phy_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STSr BCM89500_A0_G_PHY_EXT_STSr
#define G_PHY_EXT_STSr_SIZE BCM89500_A0_G_PHY_EXT_STSr_SIZE
typedef BCM89500_A0_G_PHY_EXT_STSr_t G_PHY_EXT_STSr_t;
#define G_PHY_EXT_STSr_CLR BCM89500_A0_G_PHY_EXT_STSr_CLR
#define G_PHY_EXT_STSr_SET BCM89500_A0_G_PHY_EXT_STSr_SET
#define G_PHY_EXT_STSr_GET BCM89500_A0_G_PHY_EXT_STSr_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STSr_REC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET
#define G_PHY_EXT_STSr_REC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STSr_LINK_STSf_GET BCM89500_A0_G_PHY_EXT_STSr_LINK_STSf_GET
#define G_PHY_EXT_STSr_LINK_STSf_SET BCM89500_A0_G_PHY_EXT_STSr_LINK_STSf_SET
#define G_PHY_EXT_STSr_LOCKf_GET BCM89500_A0_G_PHY_EXT_STSr_LOCKf_GET
#define G_PHY_EXT_STSr_LOCKf_SET BCM89500_A0_G_PHY_EXT_STSr_LOCKf_SET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_GET BCM89500_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_SET BCM89500_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_GET BCM89500_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_SET BCM89500_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STSr BCM89500_A0_READ_G_PHY_EXT_STSr
#define WRITE_G_PHY_EXT_STSr BCM89500_A0_WRITE_G_PHY_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_STS_EXTr 0x00008822

#define BCM89500_A0_G_PHY_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext[1];
	uint32_t _g_phy_ext_sts_ext;
} BCM89500_A0_G_PHY_EXT_STS_EXTr_t;

#define BCM89500_A0_G_PHY_EXT_STS_EXTr_CLR(r) (r).g_phy_ext_sts_ext[0] = 0
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_SET(r,d) (r).g_phy_ext_sts_ext[0] = d
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_GET(r) (r).g_phy_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_STS_EXTr,(r._g_phy_ext_sts_ext),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_STS_EXTr,&(r._g_phy_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXTr BCM89500_A0_G_PHY_EXT_STS_EXTr
#define G_PHY_EXT_STS_EXTr_SIZE BCM89500_A0_G_PHY_EXT_STS_EXTr_SIZE
typedef BCM89500_A0_G_PHY_EXT_STS_EXTr_t G_PHY_EXT_STS_EXTr_t;
#define G_PHY_EXT_STS_EXTr_CLR BCM89500_A0_G_PHY_EXT_STS_EXTr_CLR
#define G_PHY_EXT_STS_EXTr_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_SET
#define G_PHY_EXT_STS_EXTr_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET
#define G_PHY_EXT_STS_EXTr_LOCKf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCKf_GET
#define G_PHY_EXT_STS_EXTr_LOCKf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCKf_SET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXTr BCM89500_A0_READ_G_PHY_EXT_STS_EXTr
#define WRITE_G_PHY_EXT_STS_EXTr BCM89500_A0_WRITE_G_PHY_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_STS_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r 0x00008422

#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext_p4[1];
	uint32_t _g_phy_ext_sts_ext_p4;
} BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_t;

#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CLR(r) (r).g_phy_ext_sts_ext_p4[0] = 0
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_SET(r,d) (r).g_phy_ext_sts_ext_p4[0] = d
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_GET(r) (r).g_phy_ext_sts_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext_p4[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext_p4[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext_p4[0]=(((r).g_phy_ext_sts_ext_p4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_STS_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_STS_EXT_P4r,(r._g_phy_ext_sts_ext_p4),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_STS_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_STS_EXT_P4r,&(r._g_phy_ext_sts_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXT_P4r BCM89500_A0_G_PHY_EXT_STS_EXT_P4r
#define G_PHY_EXT_STS_EXT_P4r_SIZE BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_SIZE
typedef BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_t G_PHY_EXT_STS_EXT_P4r_t;
#define G_PHY_EXT_STS_EXT_P4r_CLR BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CLR
#define G_PHY_EXT_STS_EXT_P4r_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_SET
#define G_PHY_EXT_STS_EXT_P4r_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_GET
#define G_PHY_EXT_STS_EXT_P4r_MLT3_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_MLT3_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_LCK_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_LCK_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_TRMIT_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_TRMIT_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_REC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_REC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_BAD_ESD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_BAD_ESD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_BAD_SSD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_BAD_SSD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_CARR_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_CARR_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_CRC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P4r_CRC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P4r_LINK_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LINK_STSf_GET
#define G_PHY_EXT_STS_EXT_P4r_LINK_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LINK_STSf_SET
#define G_PHY_EXT_STS_EXT_P4r_LOCKf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCKf_GET
#define G_PHY_EXT_STS_EXT_P4r_LOCKf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCKf_SET
#define G_PHY_EXT_STS_EXT_P4r_LOCAL_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P4r_LOCAL_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P4r_REMOTE_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P4r_REMOTE_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P4r_INTERRUPT_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXT_P4r_INTERRUPT_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXT_P4r_MDI_CROS_STATEf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXT_P4r_MDI_CROS_STATEf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXT_P4r_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXT_P4r_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXT_P4r_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXT_P4r_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P4r_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXT_P4r BCM89500_A0_READ_G_PHY_EXT_STS_EXT_P4r
#define WRITE_G_PHY_EXT_STS_EXT_P4r BCM89500_A0_WRITE_G_PHY_EXT_STS_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_STS_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r 0x00008522

#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext_p5[1];
	uint32_t _g_phy_ext_sts_ext_p5;
} BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_t;

#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CLR(r) (r).g_phy_ext_sts_ext_p5[0] = 0
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_SET(r,d) (r).g_phy_ext_sts_ext_p5[0] = d
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_GET(r) (r).g_phy_ext_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext_p5[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_STS_EXT_P5r,(r._g_phy_ext_sts_ext_p5),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_STS_EXT_P5r,&(r._g_phy_ext_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXT_P5r BCM89500_A0_G_PHY_EXT_STS_EXT_P5r
#define G_PHY_EXT_STS_EXT_P5r_SIZE BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_SIZE
typedef BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_t G_PHY_EXT_STS_EXT_P5r_t;
#define G_PHY_EXT_STS_EXT_P5r_CLR BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CLR
#define G_PHY_EXT_STS_EXT_P5r_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_SET
#define G_PHY_EXT_STS_EXT_P5r_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_GET
#define G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_LINK_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_LINK_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_LOCKf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCKf_GET
#define G_PHY_EXT_STS_EXT_P5r_LOCKf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCKf_SET
#define G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXT_P5r BCM89500_A0_READ_G_PHY_EXT_STS_EXT_P5r
#define WRITE_G_PHY_EXT_STS_EXT_P5r BCM89500_A0_WRITE_G_PHY_EXT_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_STS_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr 0x00008022

#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext_pn[1];
	uint32_t _g_phy_ext_sts_ext_pn;
} BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_t;

#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CLR(r) (r).g_phy_ext_sts_ext_pn[0] = 0
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_SET(r,d) (r).g_phy_ext_sts_ext_pn[0] = d
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_GET(r) (r).g_phy_ext_sts_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext_pn[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext_pn[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext_pn[0]=(((r).g_phy_ext_sts_ext_pn[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_PHY_EXT_STS_EXT_PNr,(r._g_phy_ext_sts_ext_pn),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_STS_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_PHY_EXT_STS_EXT_PNr,&(r._g_phy_ext_sts_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXT_PNr BCM89500_A0_G_PHY_EXT_STS_EXT_PNr
#define G_PHY_EXT_STS_EXT_PNr_SIZE BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_SIZE
typedef BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_t G_PHY_EXT_STS_EXT_PNr_t;
#define G_PHY_EXT_STS_EXT_PNr_CLR BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CLR
#define G_PHY_EXT_STS_EXT_PNr_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_SET
#define G_PHY_EXT_STS_EXT_PNr_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_GET
#define G_PHY_EXT_STS_EXT_PNr_MLT3_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_MLT3_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_LCK_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_LCK_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_TRMIT_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_TRMIT_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_REC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_REC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_BAD_ESD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_BAD_ESD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_BAD_SSD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_BAD_SSD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_CARR_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_CARR_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_CRC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_PNr_CRC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_PNr_LINK_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LINK_STSf_GET
#define G_PHY_EXT_STS_EXT_PNr_LINK_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LINK_STSf_SET
#define G_PHY_EXT_STS_EXT_PNr_LOCKf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCKf_GET
#define G_PHY_EXT_STS_EXT_PNr_LOCKf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCKf_SET
#define G_PHY_EXT_STS_EXT_PNr_LOCAL_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_PNr_LOCAL_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_PNr_REMOTE_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_PNr_REMOTE_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_PNr_INTERRUPT_STSf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXT_PNr_INTERRUPT_STSf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXT_PNr_MDI_CROS_STATEf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXT_PNr_MDI_CROS_STATEf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXT_PNr_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXT_PNr_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXT_PNr_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXT_PNr_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_G_PHY_EXT_STS_EXT_PNr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXT_PNr BCM89500_A0_READ_G_PHY_EXT_STS_EXT_PNr
#define WRITE_G_PHY_EXT_STS_EXT_PNr BCM89500_A0_WRITE_G_PHY_EXT_STS_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_STS_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_PHY_EXT_STS_P7
 * BLOCKS:   SYS
 * DESC:     PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM89500_A0_G_PHY_EXT_STS_P7r 0x00001722

#define BCM89500_A0_G_PHY_EXT_STS_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_P7.
 *
 */
typedef union BCM89500_A0_G_PHY_EXT_STS_P7r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_p7[1];
	uint32_t _g_phy_ext_sts_p7;
} BCM89500_A0_G_PHY_EXT_STS_P7r_t;

#define BCM89500_A0_G_PHY_EXT_STS_P7r_CLR(r) (r).g_phy_ext_sts_p7[0] = 0
#define BCM89500_A0_G_PHY_EXT_STS_P7r_SET(r,d) (r).g_phy_ext_sts_p7[0] = d
#define BCM89500_A0_G_PHY_EXT_STS_P7r_GET(r) (r).g_phy_ext_sts_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_PHY_EXT_STS_P7r_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_p7[0]) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 1) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 2) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 3) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 4) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 8) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LOCKf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 9) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LOCKf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 10) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 11) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 12) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 13) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 14) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_PHY_EXT_STS_P7r_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_p7[0]) >> 15) & 0x1)
#define BCM89500_A0_G_PHY_EXT_STS_P7r_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_p7[0]=(((r).g_phy_ext_sts_p7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_P7.
 *
 */
#define BCM89500_A0_READ_G_PHY_EXT_STS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_PHY_EXT_STS_P7r,(r._g_phy_ext_sts_p7),2)
#define BCM89500_A0_WRITE_G_PHY_EXT_STS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_PHY_EXT_STS_P7r,&(r._g_phy_ext_sts_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_P7r BCM89500_A0_G_PHY_EXT_STS_P7r
#define G_PHY_EXT_STS_P7r_SIZE BCM89500_A0_G_PHY_EXT_STS_P7r_SIZE
typedef BCM89500_A0_G_PHY_EXT_STS_P7r_t G_PHY_EXT_STS_P7r_t;
#define G_PHY_EXT_STS_P7r_CLR BCM89500_A0_G_PHY_EXT_STS_P7r_CLR
#define G_PHY_EXT_STS_P7r_SET BCM89500_A0_G_PHY_EXT_STS_P7r_SET
#define G_PHY_EXT_STS_P7r_GET BCM89500_A0_G_PHY_EXT_STS_P7r_GET
#define G_PHY_EXT_STS_P7r_MLT3_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_P7r_MLT3_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_P7r_LCK_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_P7r_LCK_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_P7r_TRMIT_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_P7r_TRMIT_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_P7r_REC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_P7r_REC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_P7r_BAD_ESD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_P7r_BAD_ESD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_P7r_BAD_SSD_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_P7r_BAD_SSD_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_P7r_CARR_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_P7r_CARR_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_P7r_CRC_ERR_DETf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_P7r_CRC_ERR_DETf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_P7r_LINK_STSf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_LINK_STSf_GET
#define G_PHY_EXT_STS_P7r_LINK_STSf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_LINK_STSf_SET
#define G_PHY_EXT_STS_P7r_LOCKf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_LOCKf_GET
#define G_PHY_EXT_STS_P7r_LOCKf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_LOCKf_SET
#define G_PHY_EXT_STS_P7r_LOCAL_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_P7r_LOCAL_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_P7r_REMOTE_REC_STSf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_P7r_REMOTE_REC_STSf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_P7r_INTERRUPT_STSf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_P7r_INTERRUPT_STSf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_P7r_MDI_CROS_STATEf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_P7r_MDI_CROS_STATEf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_P7r_WIRESPEED_DOWNGRADEf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_P7r_WIRESPEED_DOWNGRADEf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_P7r_AN_PAGE_SEL_MISMATCHf_GET BCM89500_A0_G_PHY_EXT_STS_P7r_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_P7r_AN_PAGE_SEL_MISMATCHf_SET BCM89500_A0_G_PHY_EXT_STS_P7r_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_P7r BCM89500_A0_READ_G_PHY_EXT_STS_P7r
#define WRITE_G_PHY_EXT_STS_P7r BCM89500_A0_WRITE_G_PHY_EXT_STS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_PHY_EXT_STS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_ERR_CNT
 * BLOCKS:   SYS
 * DESC:     Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_ERR_CNTr 0x00001424

#define BCM89500_A0_G_REC_ERR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT.
 *
 */
typedef union BCM89500_A0_G_REC_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt[1];
	uint32_t _g_rec_err_cnt;
} BCM89500_A0_G_REC_ERR_CNTr_t;

#define BCM89500_A0_G_REC_ERR_CNTr_CLR(r) (r).g_rec_err_cnt[0] = 0
#define BCM89500_A0_G_REC_ERR_CNTr_SET(r,d) (r).g_rec_err_cnt[0] = d
#define BCM89500_A0_G_REC_ERR_CNTr_GET(r) (r).g_rec_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt[0]) & 0xffff)
#define BCM89500_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt[0]=(((r).g_rec_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT.
 *
 */
#define BCM89500_A0_READ_G_REC_ERR_CNTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_ERR_CNTr,(r._g_rec_err_cnt),2)
#define BCM89500_A0_WRITE_G_REC_ERR_CNTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_ERR_CNTr,&(r._g_rec_err_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNTr BCM89500_A0_G_REC_ERR_CNTr
#define G_REC_ERR_CNTr_SIZE BCM89500_A0_G_REC_ERR_CNTr_SIZE
typedef BCM89500_A0_G_REC_ERR_CNTr_t G_REC_ERR_CNTr_t;
#define G_REC_ERR_CNTr_CLR BCM89500_A0_G_REC_ERR_CNTr_CLR
#define G_REC_ERR_CNTr_SET BCM89500_A0_G_REC_ERR_CNTr_SET
#define G_REC_ERR_CNTr_GET BCM89500_A0_G_REC_ERR_CNTr_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_GET BCM89500_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_SET BCM89500_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNTr BCM89500_A0_READ_G_REC_ERR_CNTr
#define WRITE_G_REC_ERR_CNTr BCM89500_A0_WRITE_G_REC_ERR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_ERR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_ERR_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_ERR_CNT_EXTr 0x00008824

#define BCM89500_A0_G_REC_ERR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT.
 *
 */
typedef union BCM89500_A0_G_REC_ERR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext[1];
	uint32_t _g_rec_err_cnt_ext;
} BCM89500_A0_G_REC_ERR_CNT_EXTr_t;

#define BCM89500_A0_G_REC_ERR_CNT_EXTr_CLR(r) (r).g_rec_err_cnt_ext[0] = 0
#define BCM89500_A0_G_REC_ERR_CNT_EXTr_SET(r,d) (r).g_rec_err_cnt_ext[0] = d
#define BCM89500_A0_G_REC_ERR_CNT_EXTr_GET(r) (r).g_rec_err_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext[0]) & 0xffff)
#define BCM89500_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext[0]=(((r).g_rec_err_cnt_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT.
 *
 */
#define BCM89500_A0_READ_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_ERR_CNT_EXTr,(r._g_rec_err_cnt_ext),2)
#define BCM89500_A0_WRITE_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_ERR_CNT_EXTr,&(r._g_rec_err_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXTr BCM89500_A0_G_REC_ERR_CNT_EXTr
#define G_REC_ERR_CNT_EXTr_SIZE BCM89500_A0_G_REC_ERR_CNT_EXTr_SIZE
typedef BCM89500_A0_G_REC_ERR_CNT_EXTr_t G_REC_ERR_CNT_EXTr_t;
#define G_REC_ERR_CNT_EXTr_CLR BCM89500_A0_G_REC_ERR_CNT_EXTr_CLR
#define G_REC_ERR_CNT_EXTr_SET BCM89500_A0_G_REC_ERR_CNT_EXTr_SET
#define G_REC_ERR_CNT_EXTr_GET BCM89500_A0_G_REC_ERR_CNT_EXTr_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET BCM89500_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET BCM89500_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXTr BCM89500_A0_READ_G_REC_ERR_CNT_EXTr
#define WRITE_G_REC_ERR_CNT_EXTr BCM89500_A0_WRITE_G_REC_ERR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_ERR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_ERR_CNT_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r 0x00008424

#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext_p4[1];
	uint32_t _g_rec_err_cnt_ext_p4;
} BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_t;

#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_CLR(r) (r).g_rec_err_cnt_ext_p4[0] = 0
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_SET(r,d) (r).g_rec_err_cnt_ext_p4[0] = d
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_GET(r) (r).g_rec_err_cnt_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext_p4[0]=(((r).g_rec_err_cnt_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_REC_ERR_CNT_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_ERR_CNT_EXT_P4r,(r._g_rec_err_cnt_ext_p4),2)
#define BCM89500_A0_WRITE_G_REC_ERR_CNT_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_ERR_CNT_EXT_P4r,&(r._g_rec_err_cnt_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXT_P4r BCM89500_A0_G_REC_ERR_CNT_EXT_P4r
#define G_REC_ERR_CNT_EXT_P4r_SIZE BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_SIZE
typedef BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_t G_REC_ERR_CNT_EXT_P4r_t;
#define G_REC_ERR_CNT_EXT_P4r_CLR BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_CLR
#define G_REC_ERR_CNT_EXT_P4r_SET BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_SET
#define G_REC_ERR_CNT_EXT_P4r_GET BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_GET
#define G_REC_ERR_CNT_EXT_P4r_REC_ERR_CNTf_GET BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXT_P4r_REC_ERR_CNTf_SET BCM89500_A0_G_REC_ERR_CNT_EXT_P4r_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXT_P4r BCM89500_A0_READ_G_REC_ERR_CNT_EXT_P4r
#define WRITE_G_REC_ERR_CNT_EXT_P4r BCM89500_A0_WRITE_G_REC_ERR_CNT_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_ERR_CNT_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_ERR_CNT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r 0x00008524

#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext_p5[1];
	uint32_t _g_rec_err_cnt_ext_p5;
} BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_t;

#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_CLR(r) (r).g_rec_err_cnt_ext_p5[0] = 0
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_SET(r,d) (r).g_rec_err_cnt_ext_p5[0] = d
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_GET(r) (r).g_rec_err_cnt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext_p5[0]=(((r).g_rec_err_cnt_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_REC_ERR_CNT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_ERR_CNT_EXT_P5r,(r._g_rec_err_cnt_ext_p5),2)
#define BCM89500_A0_WRITE_G_REC_ERR_CNT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_ERR_CNT_EXT_P5r,&(r._g_rec_err_cnt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXT_P5r BCM89500_A0_G_REC_ERR_CNT_EXT_P5r
#define G_REC_ERR_CNT_EXT_P5r_SIZE BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_SIZE
typedef BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_t G_REC_ERR_CNT_EXT_P5r_t;
#define G_REC_ERR_CNT_EXT_P5r_CLR BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_CLR
#define G_REC_ERR_CNT_EXT_P5r_SET BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_SET
#define G_REC_ERR_CNT_EXT_P5r_GET BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_GET
#define G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_GET BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_SET BCM89500_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXT_P5r BCM89500_A0_READ_G_REC_ERR_CNT_EXT_P5r
#define WRITE_G_REC_ERR_CNT_EXT_P5r BCM89500_A0_WRITE_G_REC_ERR_CNT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_ERR_CNT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_ERR_CNT_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr 0x00008024

#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext_pn[1];
	uint32_t _g_rec_err_cnt_ext_pn;
} BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_t;

#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_CLR(r) (r).g_rec_err_cnt_ext_pn[0] = 0
#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_SET(r,d) (r).g_rec_err_cnt_ext_pn[0] = d
#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_GET(r) (r).g_rec_err_cnt_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext_pn[0]=(((r).g_rec_err_cnt_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_REC_ERR_CNT_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_REC_ERR_CNT_EXT_PNr,(r._g_rec_err_cnt_ext_pn),2)
#define BCM89500_A0_WRITE_G_REC_ERR_CNT_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_REC_ERR_CNT_EXT_PNr,&(r._g_rec_err_cnt_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXT_PNr BCM89500_A0_G_REC_ERR_CNT_EXT_PNr
#define G_REC_ERR_CNT_EXT_PNr_SIZE BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_SIZE
typedef BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_t G_REC_ERR_CNT_EXT_PNr_t;
#define G_REC_ERR_CNT_EXT_PNr_CLR BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_CLR
#define G_REC_ERR_CNT_EXT_PNr_SET BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_SET
#define G_REC_ERR_CNT_EXT_PNr_GET BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_GET
#define G_REC_ERR_CNT_EXT_PNr_REC_ERR_CNTf_GET BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXT_PNr_REC_ERR_CNTf_SET BCM89500_A0_G_REC_ERR_CNT_EXT_PNr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXT_PNr BCM89500_A0_READ_G_REC_ERR_CNT_EXT_PNr
#define WRITE_G_REC_ERR_CNT_EXT_PNr BCM89500_A0_WRITE_G_REC_ERR_CNT_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_ERR_CNT_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_ERR_CNT_P7
 * BLOCKS:   SYS
 * DESC:     Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_ERR_CNT_P7r 0x00001724

#define BCM89500_A0_G_REC_ERR_CNT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_P7.
 *
 */
typedef union BCM89500_A0_G_REC_ERR_CNT_P7r_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_p7[1];
	uint32_t _g_rec_err_cnt_p7;
} BCM89500_A0_G_REC_ERR_CNT_P7r_t;

#define BCM89500_A0_G_REC_ERR_CNT_P7r_CLR(r) (r).g_rec_err_cnt_p7[0] = 0
#define BCM89500_A0_G_REC_ERR_CNT_P7r_SET(r,d) (r).g_rec_err_cnt_p7[0] = d
#define BCM89500_A0_G_REC_ERR_CNT_P7r_GET(r) (r).g_rec_err_cnt_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_ERR_CNT_P7r_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_p7[0]) & 0xffff)
#define BCM89500_A0_G_REC_ERR_CNT_P7r_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_p7[0]=(((r).g_rec_err_cnt_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_P7.
 *
 */
#define BCM89500_A0_READ_G_REC_ERR_CNT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_ERR_CNT_P7r,(r._g_rec_err_cnt_p7),2)
#define BCM89500_A0_WRITE_G_REC_ERR_CNT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_ERR_CNT_P7r,&(r._g_rec_err_cnt_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_P7r BCM89500_A0_G_REC_ERR_CNT_P7r
#define G_REC_ERR_CNT_P7r_SIZE BCM89500_A0_G_REC_ERR_CNT_P7r_SIZE
typedef BCM89500_A0_G_REC_ERR_CNT_P7r_t G_REC_ERR_CNT_P7r_t;
#define G_REC_ERR_CNT_P7r_CLR BCM89500_A0_G_REC_ERR_CNT_P7r_CLR
#define G_REC_ERR_CNT_P7r_SET BCM89500_A0_G_REC_ERR_CNT_P7r_SET
#define G_REC_ERR_CNT_P7r_GET BCM89500_A0_G_REC_ERR_CNT_P7r_GET
#define G_REC_ERR_CNT_P7r_REC_ERR_CNTf_GET BCM89500_A0_G_REC_ERR_CNT_P7r_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_P7r_REC_ERR_CNTf_SET BCM89500_A0_G_REC_ERR_CNT_P7r_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_P7r BCM89500_A0_READ_G_REC_ERR_CNT_P7r
#define WRITE_G_REC_ERR_CNT_P7r BCM89500_A0_WRITE_G_REC_ERR_CNT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_ERR_CNT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_NOTOK_CNT
 * BLOCKS:   SYS
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_NOTOK_CNTr 0x00001428

#define BCM89500_A0_G_REC_NOTOK_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT.
 *
 */
typedef union BCM89500_A0_G_REC_NOTOK_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt[1];
	uint32_t _g_rec_notok_cnt;
} BCM89500_A0_G_REC_NOTOK_CNTr_t;

#define BCM89500_A0_G_REC_NOTOK_CNTr_CLR(r) (r).g_rec_notok_cnt[0] = 0
#define BCM89500_A0_G_REC_NOTOK_CNTr_SET(r,d) (r).g_rec_notok_cnt[0] = d
#define BCM89500_A0_G_REC_NOTOK_CNTr_GET(r) (r).g_rec_notok_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt[0]) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt[0]) >> 8) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT.
 *
 */
#define BCM89500_A0_READ_G_REC_NOTOK_CNTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_NOTOK_CNTr,(r._g_rec_notok_cnt),2)
#define BCM89500_A0_WRITE_G_REC_NOTOK_CNTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_NOTOK_CNTr,&(r._g_rec_notok_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNTr BCM89500_A0_G_REC_NOTOK_CNTr
#define G_REC_NOTOK_CNTr_SIZE BCM89500_A0_G_REC_NOTOK_CNTr_SIZE
typedef BCM89500_A0_G_REC_NOTOK_CNTr_t G_REC_NOTOK_CNTr_t;
#define G_REC_NOTOK_CNTr_CLR BCM89500_A0_G_REC_NOTOK_CNTr_CLR
#define G_REC_NOTOK_CNTr_SET BCM89500_A0_G_REC_NOTOK_CNTr_SET
#define G_REC_NOTOK_CNTr_GET BCM89500_A0_G_REC_NOTOK_CNTr_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNTr BCM89500_A0_READ_G_REC_NOTOK_CNTr
#define WRITE_G_REC_NOTOK_CNTr BCM89500_A0_WRITE_G_REC_NOTOK_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_NOTOK_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr 0x00008828

#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT.
 *
 */
typedef union BCM89500_A0_G_REC_NOTOK_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext[1];
	uint32_t _g_rec_notok_cnt_ext;
} BCM89500_A0_G_REC_NOTOK_CNT_EXTr_t;

#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_CLR(r) (r).g_rec_notok_cnt_ext[0] = 0
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_SET(r,d) (r).g_rec_notok_cnt_ext[0] = d
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_GET(r) (r).g_rec_notok_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext[0]) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext[0]) >> 8) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT.
 *
 */
#define BCM89500_A0_READ_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_NOTOK_CNT_EXTr,(r._g_rec_notok_cnt_ext),2)
#define BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_NOTOK_CNT_EXTr,&(r._g_rec_notok_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXTr BCM89500_A0_G_REC_NOTOK_CNT_EXTr
#define G_REC_NOTOK_CNT_EXTr_SIZE BCM89500_A0_G_REC_NOTOK_CNT_EXTr_SIZE
typedef BCM89500_A0_G_REC_NOTOK_CNT_EXTr_t G_REC_NOTOK_CNT_EXTr_t;
#define G_REC_NOTOK_CNT_EXTr_CLR BCM89500_A0_G_REC_NOTOK_CNT_EXTr_CLR
#define G_REC_NOTOK_CNT_EXTr_SET BCM89500_A0_G_REC_NOTOK_CNT_EXTr_SET
#define G_REC_NOTOK_CNT_EXTr_GET BCM89500_A0_G_REC_NOTOK_CNT_EXTr_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXTr BCM89500_A0_READ_G_REC_NOTOK_CNT_EXTr
#define WRITE_G_REC_NOTOK_CNT_EXTr BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_NOTOK_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r 0x00008428

#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext_p4[1];
	uint32_t _g_rec_notok_cnt_ext_p4;
} BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_t;

#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_CLR(r) (r).g_rec_notok_cnt_ext_p4[0] = 0
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_SET(r,d) (r).g_rec_notok_cnt_ext_p4[0] = d
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_GET(r) (r).g_rec_notok_cnt_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext_p4[0]) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p4[0]=(((r).g_rec_notok_cnt_ext_p4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext_p4[0]) >> 8) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p4[0]=(((r).g_rec_notok_cnt_ext_p4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_REC_NOTOK_CNT_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r,(r._g_rec_notok_cnt_ext_p4),2)
#define BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r,&(r._g_rec_notok_cnt_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXT_P4r BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r
#define G_REC_NOTOK_CNT_EXT_P4r_SIZE BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_SIZE
typedef BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_t G_REC_NOTOK_CNT_EXT_P4r_t;
#define G_REC_NOTOK_CNT_EXT_P4r_CLR BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_CLR
#define G_REC_NOTOK_CNT_EXT_P4r_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_SET
#define G_REC_NOTOK_CNT_EXT_P4r_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_GET
#define G_REC_NOTOK_CNT_EXT_P4r_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P4r_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXT_P4r_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P4r_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXT_P4r BCM89500_A0_READ_G_REC_NOTOK_CNT_EXT_P4r
#define WRITE_G_REC_NOTOK_CNT_EXT_P4r BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_NOTOK_CNT_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r 0x00008528

#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext_p5[1];
	uint32_t _g_rec_notok_cnt_ext_p5;
} BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_t;

#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_CLR(r) (r).g_rec_notok_cnt_ext_p5[0] = 0
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_SET(r,d) (r).g_rec_notok_cnt_ext_p5[0] = d
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_GET(r) (r).g_rec_notok_cnt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext_p5[0]) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p5[0]=(((r).g_rec_notok_cnt_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext_p5[0]) >> 8) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p5[0]=(((r).g_rec_notok_cnt_ext_p5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_REC_NOTOK_CNT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r,(r._g_rec_notok_cnt_ext_p5),2)
#define BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r,&(r._g_rec_notok_cnt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXT_P5r BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r
#define G_REC_NOTOK_CNT_EXT_P5r_SIZE BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_SIZE
typedef BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_t G_REC_NOTOK_CNT_EXT_P5r_t;
#define G_REC_NOTOK_CNT_EXT_P5r_CLR BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_CLR
#define G_REC_NOTOK_CNT_EXT_P5r_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_SET
#define G_REC_NOTOK_CNT_EXT_P5r_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_GET
#define G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXT_P5r BCM89500_A0_READ_G_REC_NOTOK_CNT_EXT_P5r
#define WRITE_G_REC_NOTOK_CNT_EXT_P5r BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_NOTOK_CNT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr 0x00008028

#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext_pn[1];
	uint32_t _g_rec_notok_cnt_ext_pn;
} BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_t;

#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_CLR(r) (r).g_rec_notok_cnt_ext_pn[0] = 0
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_SET(r,d) (r).g_rec_notok_cnt_ext_pn[0] = d
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_GET(r) (r).g_rec_notok_cnt_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext_pn[0]) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_pn[0]=(((r).g_rec_notok_cnt_ext_pn[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext_pn[0]) >> 8) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_pn[0]=(((r).g_rec_notok_cnt_ext_pn[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_REC_NOTOK_CNT_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr,(r._g_rec_notok_cnt_ext_pn),2)
#define BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr,&(r._g_rec_notok_cnt_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXT_PNr BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr
#define G_REC_NOTOK_CNT_EXT_PNr_SIZE BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_SIZE
typedef BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_t G_REC_NOTOK_CNT_EXT_PNr_t;
#define G_REC_NOTOK_CNT_EXT_PNr_CLR BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_CLR
#define G_REC_NOTOK_CNT_EXT_PNr_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_SET
#define G_REC_NOTOK_CNT_EXT_PNr_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_GET
#define G_REC_NOTOK_CNT_EXT_PNr_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_PNr_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXT_PNr_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_PNr_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXT_PNr BCM89500_A0_READ_G_REC_NOTOK_CNT_EXT_PNr
#define WRITE_G_REC_NOTOK_CNT_EXT_PNr BCM89500_A0_WRITE_G_REC_NOTOK_CNT_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_NOTOK_CNT_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_REC_NOTOK_CNT_P7
 * BLOCKS:   SYS
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r 0x00001728

#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_P7.
 *
 */
typedef union BCM89500_A0_G_REC_NOTOK_CNT_P7r_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_p7[1];
	uint32_t _g_rec_notok_cnt_p7;
} BCM89500_A0_G_REC_NOTOK_CNT_P7r_t;

#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_CLR(r) (r).g_rec_notok_cnt_p7[0] = 0
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_SET(r,d) (r).g_rec_notok_cnt_p7[0] = d
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_GET(r) (r).g_rec_notok_cnt_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_p7[0]) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_p7[0]=(((r).g_rec_notok_cnt_p7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_p7[0]) >> 8) & 0xff)
#define BCM89500_A0_G_REC_NOTOK_CNT_P7r_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_p7[0]=(((r).g_rec_notok_cnt_p7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_P7.
 *
 */
#define BCM89500_A0_READ_G_REC_NOTOK_CNT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_REC_NOTOK_CNT_P7r,(r._g_rec_notok_cnt_p7),2)
#define BCM89500_A0_WRITE_G_REC_NOTOK_CNT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_REC_NOTOK_CNT_P7r,&(r._g_rec_notok_cnt_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_P7r BCM89500_A0_G_REC_NOTOK_CNT_P7r
#define G_REC_NOTOK_CNT_P7r_SIZE BCM89500_A0_G_REC_NOTOK_CNT_P7r_SIZE
typedef BCM89500_A0_G_REC_NOTOK_CNT_P7r_t G_REC_NOTOK_CNT_P7r_t;
#define G_REC_NOTOK_CNT_P7r_CLR BCM89500_A0_G_REC_NOTOK_CNT_P7r_CLR
#define G_REC_NOTOK_CNT_P7r_SET BCM89500_A0_G_REC_NOTOK_CNT_P7r_SET
#define G_REC_NOTOK_CNT_P7r_GET BCM89500_A0_G_REC_NOTOK_CNT_P7r_GET
#define G_REC_NOTOK_CNT_P7r_REMOTE_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_P7r_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_P7r_REMOTE_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_P7r_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_P7r_LOCAL_REC_NOTOK_CNTf_GET BCM89500_A0_G_REC_NOTOK_CNT_P7r_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_P7r_LOCAL_REC_NOTOK_CNTf_SET BCM89500_A0_G_REC_NOTOK_CNT_P7r_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_P7r BCM89500_A0_READ_G_REC_NOTOK_CNT_P7r
#define WRITE_G_REC_NOTOK_CNT_P7r BCM89500_A0_WRITE_G_REC_NOTOK_CNT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_REC_NOTOK_CNT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST1
 * BLOCKS:   SYS
 * DESC:     Test Register 1
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Write as 0, ignore on read.
 *     MANUAL_SWAP_MDI_STATE 1 = Swap0 = off
 *     RESERVED_1       Write as 0, ignore on read.
 *     FORCE_LINK       1 = force link state machine into pass state0 = normal operation
 *     RESERVED_2       Write as 00, ignore on read.
 *     CRC_ERROR_COUNT  1 = receiver NOT_OK counters merged into one 16 bit counter to count CRC errors instead (crc errors will only be counted after this bit is set!)0 = normal operation
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST1r 0x0000143c

#define BCM89500_A0_G_TEST1r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1.
 *
 */
typedef union BCM89500_A0_G_TEST1r_s {
	uint32_t v[1];
	uint32_t g_test1[1];
	uint32_t _g_test1;
} BCM89500_A0_G_TEST1r_t;

#define BCM89500_A0_G_TEST1r_CLR(r) (r).g_test1[0] = 0
#define BCM89500_A0_G_TEST1r_SET(r,d) (r).g_test1[0] = d
#define BCM89500_A0_G_TEST1r_GET(r) (r).g_test1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST1r_RESERVED_0f_GET(r) (((r).g_test1[0]) & 0x7f)
#define BCM89500_A0_G_TEST1r_RESERVED_0f_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM89500_A0_G_TEST1r_MANUAL_SWAP_MDI_STATEf_GET(r) ((((r).g_test1[0]) >> 7) & 0x1)
#define BCM89500_A0_G_TEST1r_MANUAL_SWAP_MDI_STATEf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_TEST1r_RESERVED_1f_GET(r) ((((r).g_test1[0]) >> 8) & 0xf)
#define BCM89500_A0_G_TEST1r_RESERVED_1f_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_G_TEST1r_FORCE_LINKf_GET(r) ((((r).g_test1[0]) >> 12) & 0x1)
#define BCM89500_A0_G_TEST1r_FORCE_LINKf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_TEST1r_RESERVED_2f_GET(r) ((((r).g_test1[0]) >> 13) & 0x3)
#define BCM89500_A0_G_TEST1r_RESERVED_2f_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_G_TEST1r_CRC_ERROR_COUNTf_GET(r) ((((r).g_test1[0]) >> 15) & 0x1)
#define BCM89500_A0_G_TEST1r_CRC_ERROR_COUNTf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_TEST1.
 *
 */
#define BCM89500_A0_READ_G_TEST1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST1r,(r._g_test1),2)
#define BCM89500_A0_WRITE_G_TEST1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST1r,&(r._g_test1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1r BCM89500_A0_G_TEST1r
#define G_TEST1r_SIZE BCM89500_A0_G_TEST1r_SIZE
typedef BCM89500_A0_G_TEST1r_t G_TEST1r_t;
#define G_TEST1r_CLR BCM89500_A0_G_TEST1r_CLR
#define G_TEST1r_SET BCM89500_A0_G_TEST1r_SET
#define G_TEST1r_GET BCM89500_A0_G_TEST1r_GET
#define G_TEST1r_RESERVED_0f_GET BCM89500_A0_G_TEST1r_RESERVED_0f_GET
#define G_TEST1r_RESERVED_0f_SET BCM89500_A0_G_TEST1r_RESERVED_0f_SET
#define G_TEST1r_MANUAL_SWAP_MDI_STATEf_GET BCM89500_A0_G_TEST1r_MANUAL_SWAP_MDI_STATEf_GET
#define G_TEST1r_MANUAL_SWAP_MDI_STATEf_SET BCM89500_A0_G_TEST1r_MANUAL_SWAP_MDI_STATEf_SET
#define G_TEST1r_RESERVED_1f_GET BCM89500_A0_G_TEST1r_RESERVED_1f_GET
#define G_TEST1r_RESERVED_1f_SET BCM89500_A0_G_TEST1r_RESERVED_1f_SET
#define G_TEST1r_FORCE_LINKf_GET BCM89500_A0_G_TEST1r_FORCE_LINKf_GET
#define G_TEST1r_FORCE_LINKf_SET BCM89500_A0_G_TEST1r_FORCE_LINKf_SET
#define G_TEST1r_RESERVED_2f_GET BCM89500_A0_G_TEST1r_RESERVED_2f_GET
#define G_TEST1r_RESERVED_2f_SET BCM89500_A0_G_TEST1r_RESERVED_2f_SET
#define G_TEST1r_CRC_ERROR_COUNTf_GET BCM89500_A0_G_TEST1r_CRC_ERROR_COUNTf_GET
#define G_TEST1r_CRC_ERROR_COUNTf_SET BCM89500_A0_G_TEST1r_CRC_ERROR_COUNTf_SET
#define READ_G_TEST1r BCM89500_A0_READ_G_TEST1r
#define WRITE_G_TEST1r BCM89500_A0_WRITE_G_TEST1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST1_EXT
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     MAN_SWP_MDI_ST   
 *     FORCE_LINK       
 *     TX_ERR_CODE_VIS  
 *     CRC_ERR_CNT_SEL  
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST1_EXTr 0x0000883c

#define BCM89500_A0_G_TEST1_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT.
 *
 */
typedef union BCM89500_A0_G_TEST1_EXTr_s {
	uint32_t v[1];
	uint32_t g_test1_ext[1];
	uint32_t _g_test1_ext;
} BCM89500_A0_G_TEST1_EXTr_t;

#define BCM89500_A0_G_TEST1_EXTr_CLR(r) (r).g_test1_ext[0] = 0
#define BCM89500_A0_G_TEST1_EXTr_SET(r,d) (r).g_test1_ext[0] = d
#define BCM89500_A0_G_TEST1_EXTr_GET(r) (r).g_test1_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_GET(r) ((((r).g_test1_ext[0]) >> 7) & 0x1)
#define BCM89500_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_TEST1_EXTr_FORCE_LINKf_GET(r) ((((r).g_test1_ext[0]) >> 12) & 0x1)
#define BCM89500_A0_G_TEST1_EXTr_FORCE_LINKf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_GET(r) ((((r).g_test1_ext[0]) >> 14) & 0x1)
#define BCM89500_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_GET(r) ((((r).g_test1_ext[0]) >> 15) & 0x1)
#define BCM89500_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_TEST1_EXT.
 *
 */
#define BCM89500_A0_READ_G_TEST1_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST1_EXTr,(r._g_test1_ext),2)
#define BCM89500_A0_WRITE_G_TEST1_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST1_EXTr,&(r._g_test1_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXTr BCM89500_A0_G_TEST1_EXTr
#define G_TEST1_EXTr_SIZE BCM89500_A0_G_TEST1_EXTr_SIZE
typedef BCM89500_A0_G_TEST1_EXTr_t G_TEST1_EXTr_t;
#define G_TEST1_EXTr_CLR BCM89500_A0_G_TEST1_EXTr_CLR
#define G_TEST1_EXTr_SET BCM89500_A0_G_TEST1_EXTr_SET
#define G_TEST1_EXTr_GET BCM89500_A0_G_TEST1_EXTr_GET
#define G_TEST1_EXTr_MAN_SWP_MDI_STf_GET BCM89500_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_GET
#define G_TEST1_EXTr_MAN_SWP_MDI_STf_SET BCM89500_A0_G_TEST1_EXTr_MAN_SWP_MDI_STf_SET
#define G_TEST1_EXTr_FORCE_LINKf_GET BCM89500_A0_G_TEST1_EXTr_FORCE_LINKf_GET
#define G_TEST1_EXTr_FORCE_LINKf_SET BCM89500_A0_G_TEST1_EXTr_FORCE_LINKf_SET
#define G_TEST1_EXTr_TX_ERR_CODE_VISf_GET BCM89500_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_GET
#define G_TEST1_EXTr_TX_ERR_CODE_VISf_SET BCM89500_A0_G_TEST1_EXTr_TX_ERR_CODE_VISf_SET
#define G_TEST1_EXTr_CRC_ERR_CNT_SELf_GET BCM89500_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_GET
#define G_TEST1_EXTr_CRC_ERR_CNT_SELf_SET BCM89500_A0_G_TEST1_EXTr_CRC_ERR_CNT_SELf_SET
#define READ_G_TEST1_EXTr BCM89500_A0_READ_G_TEST1_EXTr
#define WRITE_G_TEST1_EXTr BCM89500_A0_WRITE_G_TEST1_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST1_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST1_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST1_EXT_P4r 0x0000843c

#define BCM89500_A0_G_TEST1_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_TEST1_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_test1_ext_p4[1];
	uint32_t _g_test1_ext_p4;
} BCM89500_A0_G_TEST1_EXT_P4r_t;

#define BCM89500_A0_G_TEST1_EXT_P4r_CLR(r) (r).g_test1_ext_p4[0] = 0
#define BCM89500_A0_G_TEST1_EXT_P4r_SET(r,d) (r).g_test1_ext_p4[0] = d
#define BCM89500_A0_G_TEST1_EXT_P4r_GET(r) (r).g_test1_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST1_EXT_P4r_TESTf_GET(r) (((r).g_test1_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_TEST1_EXT_P4r_TESTf_SET(r,f) (r).g_test1_ext_p4[0]=(((r).g_test1_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_TEST1_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST1_EXT_P4r,(r._g_test1_ext_p4),2)
#define BCM89500_A0_WRITE_G_TEST1_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST1_EXT_P4r,&(r._g_test1_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXT_P4r BCM89500_A0_G_TEST1_EXT_P4r
#define G_TEST1_EXT_P4r_SIZE BCM89500_A0_G_TEST1_EXT_P4r_SIZE
typedef BCM89500_A0_G_TEST1_EXT_P4r_t G_TEST1_EXT_P4r_t;
#define G_TEST1_EXT_P4r_CLR BCM89500_A0_G_TEST1_EXT_P4r_CLR
#define G_TEST1_EXT_P4r_SET BCM89500_A0_G_TEST1_EXT_P4r_SET
#define G_TEST1_EXT_P4r_GET BCM89500_A0_G_TEST1_EXT_P4r_GET
#define G_TEST1_EXT_P4r_TESTf_GET BCM89500_A0_G_TEST1_EXT_P4r_TESTf_GET
#define G_TEST1_EXT_P4r_TESTf_SET BCM89500_A0_G_TEST1_EXT_P4r_TESTf_SET
#define READ_G_TEST1_EXT_P4r BCM89500_A0_READ_G_TEST1_EXT_P4r
#define WRITE_G_TEST1_EXT_P4r BCM89500_A0_WRITE_G_TEST1_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST1_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST1_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     MAN_SWP_MDI_ST   
 *     FORCE_LINK       
 *     TX_ERR_CODE_VIS  
 *     CRC_ERR_CNT_SEL  
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST1_EXT_P5r 0x0000853c

#define BCM89500_A0_G_TEST1_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_TEST1_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_test1_ext_p5[1];
	uint32_t _g_test1_ext_p5;
} BCM89500_A0_G_TEST1_EXT_P5r_t;

#define BCM89500_A0_G_TEST1_EXT_P5r_CLR(r) (r).g_test1_ext_p5[0] = 0
#define BCM89500_A0_G_TEST1_EXT_P5r_SET(r,d) (r).g_test1_ext_p5[0] = d
#define BCM89500_A0_G_TEST1_EXT_P5r_GET(r) (r).g_test1_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST1_EXT_P5r_MAN_SWP_MDI_STf_GET(r) ((((r).g_test1_ext_p5[0]) >> 7) & 0x1)
#define BCM89500_A0_G_TEST1_EXT_P5r_MAN_SWP_MDI_STf_SET(r,f) (r).g_test1_ext_p5[0]=(((r).g_test1_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_G_TEST1_EXT_P5r_FORCE_LINKf_GET(r) ((((r).g_test1_ext_p5[0]) >> 12) & 0x1)
#define BCM89500_A0_G_TEST1_EXT_P5r_FORCE_LINKf_SET(r,f) (r).g_test1_ext_p5[0]=(((r).g_test1_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_G_TEST1_EXT_P5r_TX_ERR_CODE_VISf_GET(r) ((((r).g_test1_ext_p5[0]) >> 14) & 0x1)
#define BCM89500_A0_G_TEST1_EXT_P5r_TX_ERR_CODE_VISf_SET(r,f) (r).g_test1_ext_p5[0]=(((r).g_test1_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_G_TEST1_EXT_P5r_CRC_ERR_CNT_SELf_GET(r) ((((r).g_test1_ext_p5[0]) >> 15) & 0x1)
#define BCM89500_A0_G_TEST1_EXT_P5r_CRC_ERR_CNT_SELf_SET(r,f) (r).g_test1_ext_p5[0]=(((r).g_test1_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_TEST1_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_TEST1_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST1_EXT_P5r,(r._g_test1_ext_p5),2)
#define BCM89500_A0_WRITE_G_TEST1_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST1_EXT_P5r,&(r._g_test1_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXT_P5r BCM89500_A0_G_TEST1_EXT_P5r
#define G_TEST1_EXT_P5r_SIZE BCM89500_A0_G_TEST1_EXT_P5r_SIZE
typedef BCM89500_A0_G_TEST1_EXT_P5r_t G_TEST1_EXT_P5r_t;
#define G_TEST1_EXT_P5r_CLR BCM89500_A0_G_TEST1_EXT_P5r_CLR
#define G_TEST1_EXT_P5r_SET BCM89500_A0_G_TEST1_EXT_P5r_SET
#define G_TEST1_EXT_P5r_GET BCM89500_A0_G_TEST1_EXT_P5r_GET
#define G_TEST1_EXT_P5r_MAN_SWP_MDI_STf_GET BCM89500_A0_G_TEST1_EXT_P5r_MAN_SWP_MDI_STf_GET
#define G_TEST1_EXT_P5r_MAN_SWP_MDI_STf_SET BCM89500_A0_G_TEST1_EXT_P5r_MAN_SWP_MDI_STf_SET
#define G_TEST1_EXT_P5r_FORCE_LINKf_GET BCM89500_A0_G_TEST1_EXT_P5r_FORCE_LINKf_GET
#define G_TEST1_EXT_P5r_FORCE_LINKf_SET BCM89500_A0_G_TEST1_EXT_P5r_FORCE_LINKf_SET
#define G_TEST1_EXT_P5r_TX_ERR_CODE_VISf_GET BCM89500_A0_G_TEST1_EXT_P5r_TX_ERR_CODE_VISf_GET
#define G_TEST1_EXT_P5r_TX_ERR_CODE_VISf_SET BCM89500_A0_G_TEST1_EXT_P5r_TX_ERR_CODE_VISf_SET
#define G_TEST1_EXT_P5r_CRC_ERR_CNT_SELf_GET BCM89500_A0_G_TEST1_EXT_P5r_CRC_ERR_CNT_SELf_GET
#define G_TEST1_EXT_P5r_CRC_ERR_CNT_SELf_SET BCM89500_A0_G_TEST1_EXT_P5r_CRC_ERR_CNT_SELf_SET
#define READ_G_TEST1_EXT_P5r BCM89500_A0_READ_G_TEST1_EXT_P5r
#define WRITE_G_TEST1_EXT_P5r BCM89500_A0_WRITE_G_TEST1_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST1_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST1_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST1_EXT_PNr 0x0000803c

#define BCM89500_A0_G_TEST1_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_TEST1_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_test1_ext_pn[1];
	uint32_t _g_test1_ext_pn;
} BCM89500_A0_G_TEST1_EXT_PNr_t;

#define BCM89500_A0_G_TEST1_EXT_PNr_CLR(r) (r).g_test1_ext_pn[0] = 0
#define BCM89500_A0_G_TEST1_EXT_PNr_SET(r,d) (r).g_test1_ext_pn[0] = d
#define BCM89500_A0_G_TEST1_EXT_PNr_GET(r) (r).g_test1_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST1_EXT_PNr_TESTf_GET(r) (((r).g_test1_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_TEST1_EXT_PNr_TESTf_SET(r,f) (r).g_test1_ext_pn[0]=(((r).g_test1_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_TEST1_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_TEST1_EXT_PNr,(r._g_test1_ext_pn),2)
#define BCM89500_A0_WRITE_G_TEST1_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_TEST1_EXT_PNr,&(r._g_test1_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXT_PNr BCM89500_A0_G_TEST1_EXT_PNr
#define G_TEST1_EXT_PNr_SIZE BCM89500_A0_G_TEST1_EXT_PNr_SIZE
typedef BCM89500_A0_G_TEST1_EXT_PNr_t G_TEST1_EXT_PNr_t;
#define G_TEST1_EXT_PNr_CLR BCM89500_A0_G_TEST1_EXT_PNr_CLR
#define G_TEST1_EXT_PNr_SET BCM89500_A0_G_TEST1_EXT_PNr_SET
#define G_TEST1_EXT_PNr_GET BCM89500_A0_G_TEST1_EXT_PNr_GET
#define G_TEST1_EXT_PNr_TESTf_GET BCM89500_A0_G_TEST1_EXT_PNr_TESTf_GET
#define G_TEST1_EXT_PNr_TESTf_SET BCM89500_A0_G_TEST1_EXT_PNr_TESTf_SET
#define READ_G_TEST1_EXT_PNr BCM89500_A0_READ_G_TEST1_EXT_PNr
#define WRITE_G_TEST1_EXT_PNr BCM89500_A0_WRITE_G_TEST1_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST1_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST1_P7
 * BLOCKS:   SYS
 * DESC:     Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST1_P7r 0x0000173c

#define BCM89500_A0_G_TEST1_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_P7.
 *
 */
typedef union BCM89500_A0_G_TEST1_P7r_s {
	uint32_t v[1];
	uint32_t g_test1_p7[1];
	uint32_t _g_test1_p7;
} BCM89500_A0_G_TEST1_P7r_t;

#define BCM89500_A0_G_TEST1_P7r_CLR(r) (r).g_test1_p7[0] = 0
#define BCM89500_A0_G_TEST1_P7r_SET(r,d) (r).g_test1_p7[0] = d
#define BCM89500_A0_G_TEST1_P7r_GET(r) (r).g_test1_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST1_P7r_TESTf_GET(r) (((r).g_test1_p7[0]) & 0xffff)
#define BCM89500_A0_G_TEST1_P7r_TESTf_SET(r,f) (r).g_test1_p7[0]=(((r).g_test1_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1_P7.
 *
 */
#define BCM89500_A0_READ_G_TEST1_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST1_P7r,(r._g_test1_p7),2)
#define BCM89500_A0_WRITE_G_TEST1_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST1_P7r,&(r._g_test1_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_P7r BCM89500_A0_G_TEST1_P7r
#define G_TEST1_P7r_SIZE BCM89500_A0_G_TEST1_P7r_SIZE
typedef BCM89500_A0_G_TEST1_P7r_t G_TEST1_P7r_t;
#define G_TEST1_P7r_CLR BCM89500_A0_G_TEST1_P7r_CLR
#define G_TEST1_P7r_SET BCM89500_A0_G_TEST1_P7r_SET
#define G_TEST1_P7r_GET BCM89500_A0_G_TEST1_P7r_GET
#define G_TEST1_P7r_TESTf_GET BCM89500_A0_G_TEST1_P7r_TESTf_GET
#define G_TEST1_P7r_TESTf_SET BCM89500_A0_G_TEST1_P7r_TESTf_SET
#define READ_G_TEST1_P7r BCM89500_A0_READ_G_TEST1_P7r
#define WRITE_G_TEST1_P7r BCM89500_A0_WRITE_G_TEST1_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST1_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST2_EXT
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST2_EXTr 0x0000883e

#define BCM89500_A0_G_TEST2_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT.
 *
 */
typedef union BCM89500_A0_G_TEST2_EXTr_s {
	uint32_t v[1];
	uint32_t g_test2_ext[1];
	uint32_t _g_test2_ext;
} BCM89500_A0_G_TEST2_EXTr_t;

#define BCM89500_A0_G_TEST2_EXTr_CLR(r) (r).g_test2_ext[0] = 0
#define BCM89500_A0_G_TEST2_EXTr_SET(r,d) (r).g_test2_ext[0] = d
#define BCM89500_A0_G_TEST2_EXTr_GET(r) (r).g_test2_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST2_EXTr_TESTf_GET(r) (((r).g_test2_ext[0]) & 0xffff)
#define BCM89500_A0_G_TEST2_EXTr_TESTf_SET(r,f) (r).g_test2_ext[0]=(((r).g_test2_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT.
 *
 */
#define BCM89500_A0_READ_G_TEST2_EXTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST2_EXTr,(r._g_test2_ext),2)
#define BCM89500_A0_WRITE_G_TEST2_EXTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST2_EXTr,&(r._g_test2_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXTr BCM89500_A0_G_TEST2_EXTr
#define G_TEST2_EXTr_SIZE BCM89500_A0_G_TEST2_EXTr_SIZE
typedef BCM89500_A0_G_TEST2_EXTr_t G_TEST2_EXTr_t;
#define G_TEST2_EXTr_CLR BCM89500_A0_G_TEST2_EXTr_CLR
#define G_TEST2_EXTr_SET BCM89500_A0_G_TEST2_EXTr_SET
#define G_TEST2_EXTr_GET BCM89500_A0_G_TEST2_EXTr_GET
#define G_TEST2_EXTr_TESTf_GET BCM89500_A0_G_TEST2_EXTr_TESTf_GET
#define G_TEST2_EXTr_TESTf_SET BCM89500_A0_G_TEST2_EXTr_TESTf_SET
#define READ_G_TEST2_EXTr BCM89500_A0_READ_G_TEST2_EXTr
#define WRITE_G_TEST2_EXTr BCM89500_A0_WRITE_G_TEST2_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST2_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST2_EXT_P4
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST2_EXT_P4r 0x0000843e

#define BCM89500_A0_G_TEST2_EXT_P4r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT_P4.
 *
 */
typedef union BCM89500_A0_G_TEST2_EXT_P4r_s {
	uint32_t v[1];
	uint32_t g_test2_ext_p4[1];
	uint32_t _g_test2_ext_p4;
} BCM89500_A0_G_TEST2_EXT_P4r_t;

#define BCM89500_A0_G_TEST2_EXT_P4r_CLR(r) (r).g_test2_ext_p4[0] = 0
#define BCM89500_A0_G_TEST2_EXT_P4r_SET(r,d) (r).g_test2_ext_p4[0] = d
#define BCM89500_A0_G_TEST2_EXT_P4r_GET(r) (r).g_test2_ext_p4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST2_EXT_P4r_TESTf_GET(r) (((r).g_test2_ext_p4[0]) & 0xffff)
#define BCM89500_A0_G_TEST2_EXT_P4r_TESTf_SET(r,f) (r).g_test2_ext_p4[0]=(((r).g_test2_ext_p4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT_P4.
 *
 */
#define BCM89500_A0_READ_G_TEST2_EXT_P4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST2_EXT_P4r,(r._g_test2_ext_p4),2)
#define BCM89500_A0_WRITE_G_TEST2_EXT_P4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST2_EXT_P4r,&(r._g_test2_ext_p4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXT_P4r BCM89500_A0_G_TEST2_EXT_P4r
#define G_TEST2_EXT_P4r_SIZE BCM89500_A0_G_TEST2_EXT_P4r_SIZE
typedef BCM89500_A0_G_TEST2_EXT_P4r_t G_TEST2_EXT_P4r_t;
#define G_TEST2_EXT_P4r_CLR BCM89500_A0_G_TEST2_EXT_P4r_CLR
#define G_TEST2_EXT_P4r_SET BCM89500_A0_G_TEST2_EXT_P4r_SET
#define G_TEST2_EXT_P4r_GET BCM89500_A0_G_TEST2_EXT_P4r_GET
#define G_TEST2_EXT_P4r_TESTf_GET BCM89500_A0_G_TEST2_EXT_P4r_TESTf_GET
#define G_TEST2_EXT_P4r_TESTf_SET BCM89500_A0_G_TEST2_EXT_P4r_TESTf_SET
#define READ_G_TEST2_EXT_P4r BCM89500_A0_READ_G_TEST2_EXT_P4r
#define WRITE_G_TEST2_EXT_P4r BCM89500_A0_WRITE_G_TEST2_EXT_P4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST2_EXT_P4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST2_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST2_EXT_P5r 0x0000853e

#define BCM89500_A0_G_TEST2_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT_P5.
 *
 */
typedef union BCM89500_A0_G_TEST2_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_test2_ext_p5[1];
	uint32_t _g_test2_ext_p5;
} BCM89500_A0_G_TEST2_EXT_P5r_t;

#define BCM89500_A0_G_TEST2_EXT_P5r_CLR(r) (r).g_test2_ext_p5[0] = 0
#define BCM89500_A0_G_TEST2_EXT_P5r_SET(r,d) (r).g_test2_ext_p5[0] = d
#define BCM89500_A0_G_TEST2_EXT_P5r_GET(r) (r).g_test2_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST2_EXT_P5r_TESTf_GET(r) (((r).g_test2_ext_p5[0]) & 0xffff)
#define BCM89500_A0_G_TEST2_EXT_P5r_TESTf_SET(r,f) (r).g_test2_ext_p5[0]=(((r).g_test2_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT_P5.
 *
 */
#define BCM89500_A0_READ_G_TEST2_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST2_EXT_P5r,(r._g_test2_ext_p5),2)
#define BCM89500_A0_WRITE_G_TEST2_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST2_EXT_P5r,&(r._g_test2_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXT_P5r BCM89500_A0_G_TEST2_EXT_P5r
#define G_TEST2_EXT_P5r_SIZE BCM89500_A0_G_TEST2_EXT_P5r_SIZE
typedef BCM89500_A0_G_TEST2_EXT_P5r_t G_TEST2_EXT_P5r_t;
#define G_TEST2_EXT_P5r_CLR BCM89500_A0_G_TEST2_EXT_P5r_CLR
#define G_TEST2_EXT_P5r_SET BCM89500_A0_G_TEST2_EXT_P5r_SET
#define G_TEST2_EXT_P5r_GET BCM89500_A0_G_TEST2_EXT_P5r_GET
#define G_TEST2_EXT_P5r_TESTf_GET BCM89500_A0_G_TEST2_EXT_P5r_TESTf_GET
#define G_TEST2_EXT_P5r_TESTf_SET BCM89500_A0_G_TEST2_EXT_P5r_TESTf_SET
#define READ_G_TEST2_EXT_P5r BCM89500_A0_READ_G_TEST2_EXT_P5r
#define WRITE_G_TEST2_EXT_P5r BCM89500_A0_WRITE_G_TEST2_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST2_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST2_EXT_PN
 * BLOCKS:   GPIC0
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST2_EXT_PNr 0x0000803e

#define BCM89500_A0_G_TEST2_EXT_PNr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT_PN.
 *
 */
typedef union BCM89500_A0_G_TEST2_EXT_PNr_s {
	uint32_t v[1];
	uint32_t g_test2_ext_pn[1];
	uint32_t _g_test2_ext_pn;
} BCM89500_A0_G_TEST2_EXT_PNr_t;

#define BCM89500_A0_G_TEST2_EXT_PNr_CLR(r) (r).g_test2_ext_pn[0] = 0
#define BCM89500_A0_G_TEST2_EXT_PNr_SET(r,d) (r).g_test2_ext_pn[0] = d
#define BCM89500_A0_G_TEST2_EXT_PNr_GET(r) (r).g_test2_ext_pn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST2_EXT_PNr_TESTf_GET(r) (((r).g_test2_ext_pn[0]) & 0xffff)
#define BCM89500_A0_G_TEST2_EXT_PNr_TESTf_SET(r,f) (r).g_test2_ext_pn[0]=(((r).g_test2_ext_pn[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT_PN.
 *
 */
#define BCM89500_A0_READ_G_TEST2_EXT_PNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_G_TEST2_EXT_PNr,(r._g_test2_ext_pn),2)
#define BCM89500_A0_WRITE_G_TEST2_EXT_PNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_G_TEST2_EXT_PNr,&(r._g_test2_ext_pn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXT_PNr BCM89500_A0_G_TEST2_EXT_PNr
#define G_TEST2_EXT_PNr_SIZE BCM89500_A0_G_TEST2_EXT_PNr_SIZE
typedef BCM89500_A0_G_TEST2_EXT_PNr_t G_TEST2_EXT_PNr_t;
#define G_TEST2_EXT_PNr_CLR BCM89500_A0_G_TEST2_EXT_PNr_CLR
#define G_TEST2_EXT_PNr_SET BCM89500_A0_G_TEST2_EXT_PNr_SET
#define G_TEST2_EXT_PNr_GET BCM89500_A0_G_TEST2_EXT_PNr_GET
#define G_TEST2_EXT_PNr_TESTf_GET BCM89500_A0_G_TEST2_EXT_PNr_TESTf_GET
#define G_TEST2_EXT_PNr_TESTf_SET BCM89500_A0_G_TEST2_EXT_PNr_TESTf_SET
#define READ_G_TEST2_EXT_PNr BCM89500_A0_READ_G_TEST2_EXT_PNr
#define WRITE_G_TEST2_EXT_PNr BCM89500_A0_WRITE_G_TEST2_EXT_PNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST2_EXT_PNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  G_TEST2_P7
 * BLOCKS:   SYS
 * DESC:     Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM89500_A0_G_TEST2_P7r 0x0000173e

#define BCM89500_A0_G_TEST2_P7r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_P7.
 *
 */
typedef union BCM89500_A0_G_TEST2_P7r_s {
	uint32_t v[1];
	uint32_t g_test2_p7[1];
	uint32_t _g_test2_p7;
} BCM89500_A0_G_TEST2_P7r_t;

#define BCM89500_A0_G_TEST2_P7r_CLR(r) (r).g_test2_p7[0] = 0
#define BCM89500_A0_G_TEST2_P7r_SET(r,d) (r).g_test2_p7[0] = d
#define BCM89500_A0_G_TEST2_P7r_GET(r) (r).g_test2_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_G_TEST2_P7r_TESTf_GET(r) (((r).g_test2_p7[0]) & 0xffff)
#define BCM89500_A0_G_TEST2_P7r_TESTf_SET(r,f) (r).g_test2_p7[0]=(((r).g_test2_p7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_P7.
 *
 */
#define BCM89500_A0_READ_G_TEST2_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_G_TEST2_P7r,(r._g_test2_p7),2)
#define BCM89500_A0_WRITE_G_TEST2_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_G_TEST2_P7r,&(r._g_test2_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_P7r BCM89500_A0_G_TEST2_P7r
#define G_TEST2_P7r_SIZE BCM89500_A0_G_TEST2_P7r_SIZE
typedef BCM89500_A0_G_TEST2_P7r_t G_TEST2_P7r_t;
#define G_TEST2_P7r_CLR BCM89500_A0_G_TEST2_P7r_CLR
#define G_TEST2_P7r_SET BCM89500_A0_G_TEST2_P7r_SET
#define G_TEST2_P7r_GET BCM89500_A0_G_TEST2_P7r_GET
#define G_TEST2_P7r_TESTf_GET BCM89500_A0_G_TEST2_P7r_TESTf_GET
#define G_TEST2_P7r_TESTf_SET BCM89500_A0_G_TEST2_P7r_TESTf_SET
#define READ_G_TEST2_P7r BCM89500_A0_READ_G_TEST2_P7r
#define WRITE_G_TEST2_P7r BCM89500_A0_WRITE_G_TEST2_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_G_TEST2_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  HEARTBEAT_N
 * BLOCKS:   SYS
 * DESC:     Heartbeat Register N
 * SIZE:     16
 * FIELDS:
 *     HEARTBEAT_N      Output of the snapshot of the time stamp, when TS_CAPTURE is enabled and frame sync is triggered. TS_CAPTURE is located at NSE_NCO_6[13]. frame sync source is selected by the setting of NSE_NCO_6[5:2].HEARTBEAT = {HEARTBEAT_2, HEARTBEAT_1, HEARTBEAT_0}
 *
 ******************************************************************************/
#define BCM89500_A0_HEARTBEAT_Nr 0x00009402

#define BCM89500_A0_HEARTBEAT_Nr_SIZE 2

/*
 * This structure should be used to declare and program HEARTBEAT_N.
 *
 */
typedef union BCM89500_A0_HEARTBEAT_Nr_s {
	uint32_t v[1];
	uint32_t heartbeat_n[1];
	uint32_t _heartbeat_n;
} BCM89500_A0_HEARTBEAT_Nr_t;

#define BCM89500_A0_HEARTBEAT_Nr_CLR(r) (r).heartbeat_n[0] = 0
#define BCM89500_A0_HEARTBEAT_Nr_SET(r,d) (r).heartbeat_n[0] = d
#define BCM89500_A0_HEARTBEAT_Nr_GET(r) (r).heartbeat_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_HEARTBEAT_Nr_HEARTBEAT_Nf_GET(r) (((r).heartbeat_n[0]) & 0xffff)
#define BCM89500_A0_HEARTBEAT_Nr_HEARTBEAT_Nf_SET(r,f) (r).heartbeat_n[0]=(((r).heartbeat_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HEARTBEAT_N.
 *
 */
#define BCM89500_A0_READ_HEARTBEAT_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_HEARTBEAT_Nr+(2*(i)),(r._heartbeat_n),2)
#define BCM89500_A0_WRITE_HEARTBEAT_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_HEARTBEAT_Nr+(2*(i)),&(r._heartbeat_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HEARTBEAT_Nr BCM89500_A0_HEARTBEAT_Nr
#define HEARTBEAT_Nr_SIZE BCM89500_A0_HEARTBEAT_Nr_SIZE
typedef BCM89500_A0_HEARTBEAT_Nr_t HEARTBEAT_Nr_t;
#define HEARTBEAT_Nr_CLR BCM89500_A0_HEARTBEAT_Nr_CLR
#define HEARTBEAT_Nr_SET BCM89500_A0_HEARTBEAT_Nr_SET
#define HEARTBEAT_Nr_GET BCM89500_A0_HEARTBEAT_Nr_GET
#define HEARTBEAT_Nr_HEARTBEAT_Nf_GET BCM89500_A0_HEARTBEAT_Nr_HEARTBEAT_Nf_GET
#define HEARTBEAT_Nr_HEARTBEAT_Nf_SET BCM89500_A0_HEARTBEAT_Nr_HEARTBEAT_Nf_SET
#define READ_HEARTBEAT_Nr BCM89500_A0_READ_HEARTBEAT_Nr
#define WRITE_HEARTBEAT_Nr BCM89500_A0_WRITE_HEARTBEAT_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_HEARTBEAT_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  HL_PRTC_CTRL
 * BLOCKS:   SYS
 * DESC:     High Level Protocol Control Register
 * SIZE:     32
 * FIELDS:
 *     ARP_EN           ARP Snooping Enable1: ARP frames will be forwarded by L2 result and also copied to CPU.0: ARP frames will be forwarded by L2 result .
 *     RARP_EN          RARP Snooping Enable1: RARP frames will be forwarded by L2 result and also copied to CPU.0: RARP frames will be forwarded by L2 result .
 *     DHCP_EN          DHCP Snooping Enable1: DHCP frames will be forwarded by L2 result and also copied to CPU.0: DHCP frames will be forwarded by L2 result.
 *     ICMPV4_EN        ICMPv4 Snooping Enable1: ICMPv4 frames will be forwarded by L2 result and also copied to CPU.0: ICMPv4 frames will be forwarded by L2 result.
 *     ICMPV6_EN        ICMPv6(exclude MLD) Snooping/ Redirect EnableICMPv6, with a next header value of 58, will be classified by IPv6 datagram.
 *     ICMPV6_FWD_MODE  ICMPv6(exclude MLD) Forwarding Mode1: ICMPv6 frames will be trapped to CPU port only.0: ICMPv6 frames will be forwarded by L2 result and also copied to CPU.
 *     RESERVED_0       Reserved
 *     IGMP_DIP_EN      IGMP L3 DIP Checking EnableIn addition to the IP datagram with a protocol value of 2, IGMP will be classified by matching its DIP with the Class D IP address (224.0.0.0 ~ 239.255.255.255).
 *     IGMP_RPTLVE_EN   IGMP Report/Leave Message Snooping/Redirect Enable1: Enable IGMP Report/Leave Message Snooping/Redirect.0: Disable.
 *     IGMP_RPTLVE_FWD_MODE IGMP Report/Leave Message Forwarding Mode1: IGMP Report/Leave Message frames will be trapped to CPU port only.0: IGMP Report/Leave Message frames will be forwarded by L2 result and also copied to CPU.
 *     IGMP_QRY_EN      IGMP Query Message Snooping/Redirect Enable1: Enable IGMP Query Message Snooping/Redirect.0: Disable.
 *     IGMP_QRY_FWD_MODE IGMP Query Message Forwarding Mode1: IGMP Query Message frames will be trapped to CPU port only.0: IGMP Query Message frames will be forwarded by L2 result and also copied to CPU.
 *     IGMP_UKN_EN      IGMP Unknown Message Snooping/Redirect Enable1: Enable IGMP Unknown Message Snooping/Redirect.0: Disable.
 *     IGMP_UKN_FWD_MODE IGMP Unknown Message Forwarding Mode1: IGMP Unknown Message frames will be trapped to CPU port only.0: IGMP Unknown Message frames will be forwarded by L2 result and also copied to CPU.
 *     MLD_RPTDONE_EN   MLD Report/Done Message Snooping/Redirect Enable1: Enable MLD Report/Done Message Snooping/Redirect.0: Disable.
 *     MLD_RPTDONE_FWD_MODE MLD Report/Done Message Forwarding Mode1: MLD Report/Done Message frames will be trapped to CPU port only.0: MLD Report/Done Message frames will be forwarded by L2 result and also copied to CPU.
 *     MLD_QRY_EN       MLD Query Message Snooping/Redirect Enable1: Enable MLD Query Message Snooping/Redirect.0: Disable.
 *     MLD_QRY_FWD_MODE MLD Query Message Forwarding Mode1: MLD Query Message frames will be trapped to CPU port only.0: MLD Query Message frames will be forwarded by L2 result and also copied to CPU.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_HL_PRTC_CTRLr 0x00000250

#define BCM89500_A0_HL_PRTC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program HL_PRTC_CTRL.
 *
 */
typedef union BCM89500_A0_HL_PRTC_CTRLr_s {
	uint32_t v[1];
	uint32_t hl_prtc_ctrl[1];
	uint32_t _hl_prtc_ctrl;
} BCM89500_A0_HL_PRTC_CTRLr_t;

#define BCM89500_A0_HL_PRTC_CTRLr_CLR(r) (r).hl_prtc_ctrl[0] = 0
#define BCM89500_A0_HL_PRTC_CTRLr_SET(r,d) (r).hl_prtc_ctrl[0] = d
#define BCM89500_A0_HL_PRTC_CTRLr_GET(r) (r).hl_prtc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_HL_PRTC_CTRLr_ARP_ENf_GET(r) (((r).hl_prtc_ctrl[0]) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_ARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_HL_PRTC_CTRLr_RARP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_RARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_HL_PRTC_CTRLr_DHCP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_DHCP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_HL_PRTC_CTRLr_RESERVED_0f_GET(r) ((((r).hl_prtc_ctrl[0]) >> 6) & 0x3)
#define BCM89500_A0_HL_PRTC_CTRLr_RESERVED_0f_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 8) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 9) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 10) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 11) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 12) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 13) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 14) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 15) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 16) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 17) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 18) & 0x1)
#define BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM89500_A0_HL_PRTC_CTRLr_RESERVED_1f_GET(r) ((((r).hl_prtc_ctrl[0]) >> 19) & 0x1fff)
#define BCM89500_A0_HL_PRTC_CTRLr_RESERVED_1f_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access HL_PRTC_CTRL.
 *
 */
#define BCM89500_A0_READ_HL_PRTC_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_HL_PRTC_CTRLr,(r._hl_prtc_ctrl),4)
#define BCM89500_A0_WRITE_HL_PRTC_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_HL_PRTC_CTRLr,&(r._hl_prtc_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HL_PRTC_CTRLr BCM89500_A0_HL_PRTC_CTRLr
#define HL_PRTC_CTRLr_SIZE BCM89500_A0_HL_PRTC_CTRLr_SIZE
typedef BCM89500_A0_HL_PRTC_CTRLr_t HL_PRTC_CTRLr_t;
#define HL_PRTC_CTRLr_CLR BCM89500_A0_HL_PRTC_CTRLr_CLR
#define HL_PRTC_CTRLr_SET BCM89500_A0_HL_PRTC_CTRLr_SET
#define HL_PRTC_CTRLr_GET BCM89500_A0_HL_PRTC_CTRLr_GET
#define HL_PRTC_CTRLr_ARP_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_ARP_ENf_GET
#define HL_PRTC_CTRLr_ARP_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_ARP_ENf_SET
#define HL_PRTC_CTRLr_RARP_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_RARP_ENf_GET
#define HL_PRTC_CTRLr_RARP_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_RARP_ENf_SET
#define HL_PRTC_CTRLr_DHCP_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_DHCP_ENf_GET
#define HL_PRTC_CTRLr_DHCP_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_DHCP_ENf_SET
#define HL_PRTC_CTRLr_ICMPV4_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET
#define HL_PRTC_CTRLr_ICMPV4_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET
#define HL_PRTC_CTRLr_ICMPV6_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET BCM89500_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_0f_GET BCM89500_A0_HL_PRTC_CTRLr_RESERVED_0f_GET
#define HL_PRTC_CTRLr_RESERVED_0f_SET BCM89500_A0_HL_PRTC_CTRLr_RESERVED_0f_SET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET BCM89500_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET BCM89500_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_GET BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_SET BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET BCM89500_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_1f_GET BCM89500_A0_HL_PRTC_CTRLr_RESERVED_1f_GET
#define HL_PRTC_CTRLr_RESERVED_1f_SET BCM89500_A0_HL_PRTC_CTRLr_RESERVED_1f_SET
#define READ_HL_PRTC_CTRLr BCM89500_A0_READ_HL_PRTC_CTRLr
#define WRITE_HL_PRTC_CTRLr BCM89500_A0_WRITE_HL_PRTC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_HL_PRTC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IDDQ_CTRL
 * BLOCKS:   SYS
 * DESC:     Low Power Expansion II Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QPHY_IDDQ        (Not2Release)IDDQ Control for Quad BR-PHY.Set 1'b1 to this bit will force the Quad BR-PHY (P0~P3) to IDDQ mode. Analog transceiver and receiver, digital logic, and PLL will be power down.
 *     RESERVED_0       Reserved
 *     SPHY_IDDQ        (Not2Release)IDDQ Control for Single BR-PHY.Set 1'b1 to this bit will force the Signal BR-PHY (P4) to IDDQ mode. Analog transceiver and receiver, digital logic, and PLL will be power down.
 *     RESERVED_1       Reserved
 *     MII1_IDDQ        (Not2Release)IDDQ Control for MII1 DLL.Set 1'b1 to this bit will force the MII1's DLL (P8) to IDDQ mode. Thus, the delay function of TX and RX clocks are disabled and must be bypassed.
 *     MII2_IDDQ        (Not2Release)IDDQ Control for MII2 DLL.Set 1'b1 to this bit will force the MII2's DLL (P5) to IDDQ mode. Thus, the delay function of TX and RX clocks are disabled and must be bypassed.
 *     MII3_IDDQ        (Not2Release)IDDQ Control for MII3 DLL.Set 1'b1 to this bit will force the MII3's DLL (P4) to IDDQ mode. Thus, the delay function of TX and RX clocks are disabled and must be bypassed.
 *     SD_IDDQ          (Not2Release)IDDQ Control for SerdesSet 1'b1 to this bit will force the SerDes (P5) to IDDQ mode. Analog transceiver and receiver, digital logic, and PLL will be power down. The clk25 output will be shutdown as well. Thus, there is no reference clock to other PLLs and digital logic. Only external reset can recover the system.
 *     TEMP_IDDQ        (Not2Release)IDDQ Control for temperature monitor.Set 1'b1 to this bit will force the temperature monitor to IDDQ mode.
 *     SOC_IDDQ         (Not2Release)IDDQ Control for the CPU subsystem.Set 1'b1 to this bit will force the cpu subsystem to IDDQ mode. The SoC PLL and Random number generator will be power down. All clocks in the cpu subsystem will be shutdown as well. Thus, only external reset or external CPU can recover the CPU subsystem.
 *     PLL_IDDQ         (Not2Release)IDDQ control for the switch PLL.Set 1'b1 to this bit will force the switch PLL to power down mode.
 *     POWER_OFF_STROBE Power Off Strobe EnableWriting 1 to this bit will toggle six pulses to the power off circuit. This bit is self-cleared when the pulses are toggled. The programming sequence for entering ultra low power mode is to toggle six pulses on the strobe signal, and set the power down register (bit 12 of expansion register at 0x0e) in the BR-PHY, then toggle another six pulses on the strobe signal to take effect.
 *
 ******************************************************************************/
#define BCM89500_A0_IDDQ_CTRLr 0x0000004e

#define BCM89500_A0_IDDQ_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program IDDQ_CTRL.
 *
 */
typedef union BCM89500_A0_IDDQ_CTRLr_s {
	uint32_t v[1];
	uint32_t iddq_ctrl[1];
	uint32_t _iddq_ctrl;
} BCM89500_A0_IDDQ_CTRLr_t;

#define BCM89500_A0_IDDQ_CTRLr_CLR(r) (r).iddq_ctrl[0] = 0
#define BCM89500_A0_IDDQ_CTRLr_SET(r,d) (r).iddq_ctrl[0] = d
#define BCM89500_A0_IDDQ_CTRLr_GET(r) (r).iddq_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IDDQ_CTRLr_QPHY_IDDQf_GET(r) (((r).iddq_ctrl[0]) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_QPHY_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_IDDQ_CTRLr_RESERVED_0f_GET(r) ((((r).iddq_ctrl[0]) >> 1) & 0x7)
#define BCM89500_A0_IDDQ_CTRLr_RESERVED_0f_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_IDDQ_CTRLr_SPHY_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_SPHY_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_IDDQ_CTRLr_RESERVED_1f_GET(r) ((((r).iddq_ctrl[0]) >> 5) & 0x7)
#define BCM89500_A0_IDDQ_CTRLr_RESERVED_1f_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_IDDQ_CTRLr_MII1_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 8) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_MII1_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_IDDQ_CTRLr_MII2_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 9) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_MII2_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_IDDQ_CTRLr_MII3_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 10) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_MII3_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_IDDQ_CTRLr_SD_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 11) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_SD_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_IDDQ_CTRLr_TEMP_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 12) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_TEMP_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_IDDQ_CTRLr_SOC_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 13) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_SOC_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_IDDQ_CTRLr_PLL_IDDQf_GET(r) ((((r).iddq_ctrl[0]) >> 14) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_PLL_IDDQf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_IDDQ_CTRLr_POWER_OFF_STROBEf_GET(r) ((((r).iddq_ctrl[0]) >> 15) & 0x1)
#define BCM89500_A0_IDDQ_CTRLr_POWER_OFF_STROBEf_SET(r,f) (r).iddq_ctrl[0]=(((r).iddq_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access IDDQ_CTRL.
 *
 */
#define BCM89500_A0_READ_IDDQ_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IDDQ_CTRLr,(r._iddq_ctrl),2)
#define BCM89500_A0_WRITE_IDDQ_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IDDQ_CTRLr,&(r._iddq_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IDDQ_CTRLr BCM89500_A0_IDDQ_CTRLr
#define IDDQ_CTRLr_SIZE BCM89500_A0_IDDQ_CTRLr_SIZE
typedef BCM89500_A0_IDDQ_CTRLr_t IDDQ_CTRLr_t;
#define IDDQ_CTRLr_CLR BCM89500_A0_IDDQ_CTRLr_CLR
#define IDDQ_CTRLr_SET BCM89500_A0_IDDQ_CTRLr_SET
#define IDDQ_CTRLr_GET BCM89500_A0_IDDQ_CTRLr_GET
#define IDDQ_CTRLr_QPHY_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_QPHY_IDDQf_GET
#define IDDQ_CTRLr_QPHY_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_QPHY_IDDQf_SET
#define IDDQ_CTRLr_RESERVED_0f_GET BCM89500_A0_IDDQ_CTRLr_RESERVED_0f_GET
#define IDDQ_CTRLr_RESERVED_0f_SET BCM89500_A0_IDDQ_CTRLr_RESERVED_0f_SET
#define IDDQ_CTRLr_SPHY_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_SPHY_IDDQf_GET
#define IDDQ_CTRLr_SPHY_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_SPHY_IDDQf_SET
#define IDDQ_CTRLr_RESERVED_1f_GET BCM89500_A0_IDDQ_CTRLr_RESERVED_1f_GET
#define IDDQ_CTRLr_RESERVED_1f_SET BCM89500_A0_IDDQ_CTRLr_RESERVED_1f_SET
#define IDDQ_CTRLr_MII1_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_MII1_IDDQf_GET
#define IDDQ_CTRLr_MII1_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_MII1_IDDQf_SET
#define IDDQ_CTRLr_MII2_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_MII2_IDDQf_GET
#define IDDQ_CTRLr_MII2_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_MII2_IDDQf_SET
#define IDDQ_CTRLr_MII3_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_MII3_IDDQf_GET
#define IDDQ_CTRLr_MII3_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_MII3_IDDQf_SET
#define IDDQ_CTRLr_SD_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_SD_IDDQf_GET
#define IDDQ_CTRLr_SD_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_SD_IDDQf_SET
#define IDDQ_CTRLr_TEMP_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_TEMP_IDDQf_GET
#define IDDQ_CTRLr_TEMP_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_TEMP_IDDQf_SET
#define IDDQ_CTRLr_SOC_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_SOC_IDDQf_GET
#define IDDQ_CTRLr_SOC_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_SOC_IDDQf_SET
#define IDDQ_CTRLr_PLL_IDDQf_GET BCM89500_A0_IDDQ_CTRLr_PLL_IDDQf_GET
#define IDDQ_CTRLr_PLL_IDDQf_SET BCM89500_A0_IDDQ_CTRLr_PLL_IDDQf_SET
#define IDDQ_CTRLr_POWER_OFF_STROBEf_GET BCM89500_A0_IDDQ_CTRLr_POWER_OFF_STROBEf_GET
#define IDDQ_CTRLr_POWER_OFF_STROBEf_SET BCM89500_A0_IDDQ_CTRLr_POWER_OFF_STROBEf_SET
#define READ_IDDQ_CTRLr BCM89500_A0_READ_IDDQ_CTRLr
#define WRITE_IDDQ_CTRLr BCM89500_A0_WRITE_IDDQ_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IDDQ_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IFG_BYTES
 * BLOCKS:   SYS
 * DESC:     IFG Correction Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     IFG_BYTES        Enable/Disable IFG correction for each egress port.0: Exclude the preamble and the IPG bytes from the shaping counter.1: Include the preamble and the IPG bytes in the shaping counter.Preamble is counted as 8 bytes. IPG is counted as 12 bytes by default, but when IPG shrinking is enabled, it should reflect the actual IPG count in the shaping counter.bit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IFG_BYTESr 0x00003700

#define BCM89500_A0_IFG_BYTESr_SIZE 2

/*
 * This structure should be used to declare and program IFG_BYTES.
 *
 */
typedef union BCM89500_A0_IFG_BYTESr_s {
	uint32_t v[1];
	uint32_t ifg_bytes[1];
	uint32_t _ifg_bytes;
} BCM89500_A0_IFG_BYTESr_t;

#define BCM89500_A0_IFG_BYTESr_CLR(r) (r).ifg_bytes[0] = 0
#define BCM89500_A0_IFG_BYTESr_SET(r,d) (r).ifg_bytes[0] = d
#define BCM89500_A0_IFG_BYTESr_GET(r) (r).ifg_bytes[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IFG_BYTESr_IFG_BYTESf_GET(r) (((r).ifg_bytes[0]) & 0x1ff)
#define BCM89500_A0_IFG_BYTESr_IFG_BYTESf_SET(r,f) (r).ifg_bytes[0]=(((r).ifg_bytes[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_IFG_BYTESr_RESERVEDf_GET(r) ((((r).ifg_bytes[0]) >> 9) & 0x7f)
#define BCM89500_A0_IFG_BYTESr_RESERVEDf_SET(r,f) (r).ifg_bytes[0]=(((r).ifg_bytes[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access IFG_BYTES.
 *
 */
#define BCM89500_A0_READ_IFG_BYTESr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IFG_BYTESr,(r._ifg_bytes),2)
#define BCM89500_A0_WRITE_IFG_BYTESr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IFG_BYTESr,&(r._ifg_bytes),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IFG_BYTESr BCM89500_A0_IFG_BYTESr
#define IFG_BYTESr_SIZE BCM89500_A0_IFG_BYTESr_SIZE
typedef BCM89500_A0_IFG_BYTESr_t IFG_BYTESr_t;
#define IFG_BYTESr_CLR BCM89500_A0_IFG_BYTESr_CLR
#define IFG_BYTESr_SET BCM89500_A0_IFG_BYTESr_SET
#define IFG_BYTESr_GET BCM89500_A0_IFG_BYTESr_GET
#define IFG_BYTESr_IFG_BYTESf_GET BCM89500_A0_IFG_BYTESr_IFG_BYTESf_GET
#define IFG_BYTESr_IFG_BYTESf_SET BCM89500_A0_IFG_BYTESr_IFG_BYTESf_SET
#define IFG_BYTESr_RESERVEDf_GET BCM89500_A0_IFG_BYTESr_RESERVEDf_GET
#define IFG_BYTESr_RESERVEDf_SET BCM89500_A0_IFG_BYTESr_RESERVEDf_SET
#define READ_IFG_BYTESr BCM89500_A0_READ_IFG_BYTESr
#define WRITE_IFG_BYTESr BCM89500_A0_WRITE_IFG_BYTESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IFG_BYTESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_MSK       Ingress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-5 = Port 0-5Bit 7 = Port 7Bit 8 = IMP Port.
 *     RESERVED         Reserved
 *     IN_DIV_EN        Ingress Divider Enable.Mirror every nth received frame (n=IN_MIRROR_DIV + 1) that has passed through the IN_MIRROR_FILTER.
 *     IN_MIR_FLTR      Ingress Mirror Filter.Defines the conditions under which frames received on a port that has been selected in the IN_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all ingress frames.01: Mirror all received frames with DA = IN_MIRROR_MAC.10: Mirror all received frames with SA = IN_MIRROR_MAC.11: Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IGMIRCTLr 0x00000212

#define BCM89500_A0_IGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRCTL.
 *
 */
typedef union BCM89500_A0_IGMIRCTLr_s {
	uint32_t v[1];
	uint32_t igmirctl[1];
	uint32_t _igmirctl;
} BCM89500_A0_IGMIRCTLr_t;

#define BCM89500_A0_IGMIRCTLr_CLR(r) (r).igmirctl[0] = 0
#define BCM89500_A0_IGMIRCTLr_SET(r,d) (r).igmirctl[0] = d
#define BCM89500_A0_IGMIRCTLr_GET(r) (r).igmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) (((r).igmirctl[0]) & 0x1ff)
#define BCM89500_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_IGMIRCTLr_RESERVEDf_GET(r) ((((r).igmirctl[0]) >> 9) & 0xf)
#define BCM89500_A0_IGMIRCTLr_RESERVEDf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM89500_A0_IGMIRCTLr_IN_DIV_ENf_GET(r) ((((r).igmirctl[0]) >> 13) & 0x1)
#define BCM89500_A0_IGMIRCTLr_IN_DIV_ENf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_IGMIRCTLr_IN_MIR_FLTRf_GET(r) ((((r).igmirctl[0]) >> 14) & 0x3)
#define BCM89500_A0_IGMIRCTLr_IN_MIR_FLTRf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IGMIRCTL.
 *
 */
#define BCM89500_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IGMIRCTLr,(r._igmirctl),2)
#define BCM89500_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IGMIRCTLr,&(r._igmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM89500_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM89500_A0_IGMIRCTLr_SIZE
typedef BCM89500_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM89500_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM89500_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM89500_A0_IGMIRCTLr_GET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM89500_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM89500_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_RESERVEDf_GET BCM89500_A0_IGMIRCTLr_RESERVEDf_GET
#define IGMIRCTLr_RESERVEDf_SET BCM89500_A0_IGMIRCTLr_RESERVEDf_SET
#define IGMIRCTLr_IN_DIV_ENf_GET BCM89500_A0_IGMIRCTLr_IN_DIV_ENf_GET
#define IGMIRCTLr_IN_DIV_ENf_SET BCM89500_A0_IGMIRCTLr_IN_DIV_ENf_SET
#define IGMIRCTLr_IN_MIR_FLTRf_GET BCM89500_A0_IGMIRCTLr_IN_MIR_FLTRf_GET
#define IGMIRCTLr_IN_MIR_FLTRf_SET BCM89500_A0_IGMIRCTLr_IN_MIR_FLTRf_SET
#define READ_IGMIRCTLr BCM89500_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM89500_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_DIV       Ingress Mirror Divider.Receive frames that have passed the IN_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the IN_DIV_EN bit in the Ingress Mirror Control register is set, frames that pass the IN_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = IN_MIRROR_DIV + 1) will be mirrored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IGMIRDIVr 0x00000214

#define BCM89500_A0_IGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRDIV.
 *
 */
typedef union BCM89500_A0_IGMIRDIVr_s {
	uint32_t v[1];
	uint32_t igmirdiv[1];
	uint32_t _igmirdiv;
} BCM89500_A0_IGMIRDIVr_t;

#define BCM89500_A0_IGMIRDIVr_CLR(r) (r).igmirdiv[0] = 0
#define BCM89500_A0_IGMIRDIVr_SET(r,d) (r).igmirdiv[0] = d
#define BCM89500_A0_IGMIRDIVr_GET(r) (r).igmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IGMIRDIVr_IN_MIR_DIVf_GET(r) (((r).igmirdiv[0]) & 0x3ff)
#define BCM89500_A0_IGMIRDIVr_IN_MIR_DIVf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_IGMIRDIVr_RESERVEDf_GET(r) ((((r).igmirdiv[0]) >> 10) & 0x3f)
#define BCM89500_A0_IGMIRDIVr_RESERVEDf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access IGMIRDIV.
 *
 */
#define BCM89500_A0_READ_IGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IGMIRDIVr,(r._igmirdiv),2)
#define BCM89500_A0_WRITE_IGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IGMIRDIVr,&(r._igmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRDIVr BCM89500_A0_IGMIRDIVr
#define IGMIRDIVr_SIZE BCM89500_A0_IGMIRDIVr_SIZE
typedef BCM89500_A0_IGMIRDIVr_t IGMIRDIVr_t;
#define IGMIRDIVr_CLR BCM89500_A0_IGMIRDIVr_CLR
#define IGMIRDIVr_SET BCM89500_A0_IGMIRDIVr_SET
#define IGMIRDIVr_GET BCM89500_A0_IGMIRDIVr_GET
#define IGMIRDIVr_IN_MIR_DIVf_GET BCM89500_A0_IGMIRDIVr_IN_MIR_DIVf_GET
#define IGMIRDIVr_IN_MIR_DIVf_SET BCM89500_A0_IGMIRDIVr_IN_MIR_DIVf_SET
#define IGMIRDIVr_RESERVEDf_GET BCM89500_A0_IGMIRDIVr_RESERVEDf_GET
#define IGMIRDIVr_RESERVEDf_SET BCM89500_A0_IGMIRDIVr_RESERVEDf_SET
#define READ_IGMIRDIVr BCM89500_A0_READ_IGMIRDIVr
#define WRITE_IGMIRDIVr BCM89500_A0_WRITE_IGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Mac Address Register
 * SIZE:     48
 * FIELDS:
 *     IN_MIR_MAC       Ingress Mirror MAC AddressMAC address that will be compared against ingress frames in accordance with the IN_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM89500_A0_IGMIRMACr 0x00000216

#define BCM89500_A0_IGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program IGMIRMAC.
 *
 */
typedef union BCM89500_A0_IGMIRMACr_s {
	uint32_t v[2];
	uint32_t igmirmac[2];
	uint32_t _igmirmac;
} BCM89500_A0_IGMIRMACr_t;

#define BCM89500_A0_IGMIRMACr_CLR(r) CDK_MEMSET(&((r)._igmirmac), 0, sizeof(BCM89500_A0_IGMIRMACr_t))
#define BCM89500_A0_IGMIRMACr_SET(r,i,d) (r).igmirmac[i] = d
#define BCM89500_A0_IGMIRMACr_GET(r,i) (r).igmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IGMIRMACr_IN_MIR_MACf_GET(r,a) cdk_field_get((r).igmirmac,0,47,a)
#define BCM89500_A0_IGMIRMACr_IN_MIR_MACf_SET(r,a) cdk_field_set((r).igmirmac,0,47,a)

/*
 * These macros can be used to access IGMIRMAC.
 *
 */
#define BCM89500_A0_READ_IGMIRMACr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IGMIRMACr,(r._igmirmac),6)
#define BCM89500_A0_WRITE_IGMIRMACr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IGMIRMACr,&(r._igmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRMACr BCM89500_A0_IGMIRMACr
#define IGMIRMACr_SIZE BCM89500_A0_IGMIRMACr_SIZE
typedef BCM89500_A0_IGMIRMACr_t IGMIRMACr_t;
#define IGMIRMACr_CLR BCM89500_A0_IGMIRMACr_CLR
#define IGMIRMACr_SET BCM89500_A0_IGMIRMACr_SET
#define IGMIRMACr_GET BCM89500_A0_IGMIRMACr_GET
#define IGMIRMACr_IN_MIR_MACf_GET BCM89500_A0_IGMIRMACr_IN_MIR_MACf_GET
#define IGMIRMACr_IN_MIR_MACf_SET BCM89500_A0_IGMIRMACr_IN_MIR_MACf_SET
#define READ_IGMIRMACr BCM89500_A0_READ_IGMIRMACr
#define WRITE_IGMIRMACr BCM89500_A0_WRITE_IGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP0_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP/IMP0 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP0_PRT_ID      IMP/IMP0 Port IDThis field specifies the port ID of the IMP/IMP0 port.In polar, IMP/IMP0 is fixed at Port 8.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP0_PRT_IDr 0x00000201

#define BCM89500_A0_IMP0_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP0_PRT_ID.
 *
 */
typedef union BCM89500_A0_IMP0_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp0_prt_id[1];
	uint32_t _imp0_prt_id;
} BCM89500_A0_IMP0_PRT_IDr_t;

#define BCM89500_A0_IMP0_PRT_IDr_CLR(r) (r).imp0_prt_id[0] = 0
#define BCM89500_A0_IMP0_PRT_IDr_SET(r,d) (r).imp0_prt_id[0] = d
#define BCM89500_A0_IMP0_PRT_IDr_GET(r) (r).imp0_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET(r) (((r).imp0_prt_id[0]) & 0xf)
#define BCM89500_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_IMP0_PRT_IDr_RESERVEDf_GET(r) ((((r).imp0_prt_id[0]) >> 4) & 0xf)
#define BCM89500_A0_IMP0_PRT_IDr_RESERVEDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP0_PRT_ID.
 *
 */
#define BCM89500_A0_READ_IMP0_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP0_PRT_IDr,(r._imp0_prt_id),1)
#define BCM89500_A0_WRITE_IMP0_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP0_PRT_IDr,&(r._imp0_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP0_PRT_IDr BCM89500_A0_IMP0_PRT_IDr
#define IMP0_PRT_IDr_SIZE BCM89500_A0_IMP0_PRT_IDr_SIZE
typedef BCM89500_A0_IMP0_PRT_IDr_t IMP0_PRT_IDr_t;
#define IMP0_PRT_IDr_CLR BCM89500_A0_IMP0_PRT_IDr_CLR
#define IMP0_PRT_IDr_SET BCM89500_A0_IMP0_PRT_IDr_SET
#define IMP0_PRT_IDr_GET BCM89500_A0_IMP0_PRT_IDr_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_GET BCM89500_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_SET BCM89500_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET
#define IMP0_PRT_IDr_RESERVEDf_GET BCM89500_A0_IMP0_PRT_IDr_RESERVEDf_GET
#define IMP0_PRT_IDr_RESERVEDf_SET BCM89500_A0_IMP0_PRT_IDr_RESERVEDf_SET
#define READ_IMP0_PRT_IDr BCM89500_A0_READ_IMP0_PRT_IDr
#define WRITE_IMP0_PRT_IDr BCM89500_A0_WRITE_IMP0_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP0_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP1_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP1 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP1_PRT_ID      IMP/IMP1 Port IDThis field specifies the port ID of the IMP/IMP1 port.In polar, IMP/IMP1 is fixed at Port 5.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP1_PRT_IDr 0x00000202

#define BCM89500_A0_IMP1_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP1_PRT_ID.
 *
 */
typedef union BCM89500_A0_IMP1_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp1_prt_id[1];
	uint32_t _imp1_prt_id;
} BCM89500_A0_IMP1_PRT_IDr_t;

#define BCM89500_A0_IMP1_PRT_IDr_CLR(r) (r).imp1_prt_id[0] = 0
#define BCM89500_A0_IMP1_PRT_IDr_SET(r,d) (r).imp1_prt_id[0] = d
#define BCM89500_A0_IMP1_PRT_IDr_GET(r) (r).imp1_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_GET(r) (((r).imp1_prt_id[0]) & 0xf)
#define BCM89500_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_SET(r,f) (r).imp1_prt_id[0]=(((r).imp1_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_IMP1_PRT_IDr_RESERVEDf_GET(r) ((((r).imp1_prt_id[0]) >> 4) & 0xf)
#define BCM89500_A0_IMP1_PRT_IDr_RESERVEDf_SET(r,f) (r).imp1_prt_id[0]=(((r).imp1_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP1_PRT_ID.
 *
 */
#define BCM89500_A0_READ_IMP1_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP1_PRT_IDr,(r._imp1_prt_id),1)
#define BCM89500_A0_WRITE_IMP1_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP1_PRT_IDr,&(r._imp1_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP1_PRT_IDr BCM89500_A0_IMP1_PRT_IDr
#define IMP1_PRT_IDr_SIZE BCM89500_A0_IMP1_PRT_IDr_SIZE
typedef BCM89500_A0_IMP1_PRT_IDr_t IMP1_PRT_IDr_t;
#define IMP1_PRT_IDr_CLR BCM89500_A0_IMP1_PRT_IDr_CLR
#define IMP1_PRT_IDr_SET BCM89500_A0_IMP1_PRT_IDr_SET
#define IMP1_PRT_IDr_GET BCM89500_A0_IMP1_PRT_IDr_GET
#define IMP1_PRT_IDr_IMP1_PRT_IDf_GET BCM89500_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_GET
#define IMP1_PRT_IDr_IMP1_PRT_IDf_SET BCM89500_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_SET
#define IMP1_PRT_IDr_RESERVEDf_GET BCM89500_A0_IMP1_PRT_IDr_RESERVEDf_GET
#define IMP1_PRT_IDr_RESERVEDf_SET BCM89500_A0_IMP1_PRT_IDr_RESERVEDf_SET
#define READ_IMP1_PRT_IDr BCM89500_A0_READ_IMP1_PRT_IDr
#define WRITE_IMP1_PRT_IDr BCM89500_A0_WRITE_IMP1_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP1_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_CTL
 * BLOCKS:   CPIC
 * DESC:     IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level(Not2Release).
 *     TX_DIS           Disables the transmit function of the port at the MAC level(Not2Release).
 *     RX_BCST_EN       Receive Broadcast Enable.Allow broadcast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_MCST_EN       Receive Multicast Enable.Allow multicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flodded due to no matching address table entry.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_UCST_EN       Receive Unicast Enable.Allow unicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flooded due to no matching address table entry.When cleared, unicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_CTLr 0x00000008

#define BCM89500_A0_IMP_CTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_CTL.
 *
 */
typedef union BCM89500_A0_IMP_CTLr_s {
	uint32_t v[1];
	uint32_t imp_ctl[1];
	uint32_t _imp_ctl;
} BCM89500_A0_IMP_CTLr_t;

#define BCM89500_A0_IMP_CTLr_CLR(r) (r).imp_ctl[0] = 0
#define BCM89500_A0_IMP_CTLr_SET(r,d) (r).imp_ctl[0] = d
#define BCM89500_A0_IMP_CTLr_GET(r) (r).imp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_CTLr_RX_DISf_GET(r) (((r).imp_ctl[0]) & 0x1)
#define BCM89500_A0_IMP_CTLr_RX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_IMP_CTLr_TX_DISf_GET(r) ((((r).imp_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_IMP_CTLr_TX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_IMP_CTLr_RX_BCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_IMP_CTLr_RX_BCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_IMP_CTLr_RX_MCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_IMP_CTLr_RX_MCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_IMP_CTLr_RX_UCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_IMP_CTLr_RX_UCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_IMP_CTLr_RESERVEDf_GET(r) ((((r).imp_ctl[0]) >> 5) & 0x7)
#define BCM89500_A0_IMP_CTLr_RESERVEDf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access IMP_CTL.
 *
 */
#define BCM89500_A0_READ_IMP_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_CTLr,(r._imp_ctl),1)
#define BCM89500_A0_WRITE_IMP_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_CTLr,&(r._imp_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_CTLr BCM89500_A0_IMP_CTLr
#define IMP_CTLr_SIZE BCM89500_A0_IMP_CTLr_SIZE
typedef BCM89500_A0_IMP_CTLr_t IMP_CTLr_t;
#define IMP_CTLr_CLR BCM89500_A0_IMP_CTLr_CLR
#define IMP_CTLr_SET BCM89500_A0_IMP_CTLr_SET
#define IMP_CTLr_GET BCM89500_A0_IMP_CTLr_GET
#define IMP_CTLr_RX_DISf_GET BCM89500_A0_IMP_CTLr_RX_DISf_GET
#define IMP_CTLr_RX_DISf_SET BCM89500_A0_IMP_CTLr_RX_DISf_SET
#define IMP_CTLr_TX_DISf_GET BCM89500_A0_IMP_CTLr_TX_DISf_GET
#define IMP_CTLr_TX_DISf_SET BCM89500_A0_IMP_CTLr_TX_DISf_SET
#define IMP_CTLr_RX_BCST_ENf_GET BCM89500_A0_IMP_CTLr_RX_BCST_ENf_GET
#define IMP_CTLr_RX_BCST_ENf_SET BCM89500_A0_IMP_CTLr_RX_BCST_ENf_SET
#define IMP_CTLr_RX_MCST_ENf_GET BCM89500_A0_IMP_CTLr_RX_MCST_ENf_GET
#define IMP_CTLr_RX_MCST_ENf_SET BCM89500_A0_IMP_CTLr_RX_MCST_ENf_SET
#define IMP_CTLr_RX_UCST_ENf_GET BCM89500_A0_IMP_CTLr_RX_UCST_ENf_GET
#define IMP_CTLr_RX_UCST_ENf_SET BCM89500_A0_IMP_CTLr_RX_UCST_ENf_SET
#define IMP_CTLr_RESERVEDf_GET BCM89500_A0_IMP_CTLr_RESERVEDf_GET
#define IMP_CTLr_RESERVEDf_SET BCM89500_A0_IMP_CTLr_RESERVEDf_SET
#define READ_IMP_CTLr BCM89500_A0_READ_IMP_CTLr
#define WRITE_IMP_CTLr BCM89500_A0_WRITE_IMP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_EGRESS_RATE_CTRL_CFG_REG
 * BLOCKS:   SYS
 * DESC:     IMP N Egress Rate Control Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     RATE_INDEX       The rate_index is used to configure different egress rate for IMP in terms of Packet Per Second(PPS). When setting to 0, the egress rate is limited to a maximum of 384 packets/second for continuous minimum sized packet(68 bytes, including 4 byte BRCM header). When setting to 63, the egress rate control function is disabled and all packets are transmitted at wire-speed. The rate_index setting is not affected by the network speed configuration. For example, once you set the rate_index at certain value, the egress rate is limitted to the corresponding speed no matter the switch is running at 10Mbps, 100Mbps or 1Gbps. However, the maximum rate you programmed should be a reasonable value under the corresponding network speed configuration. For example, it doesn't make sense to set a value of 63 with the network configuration at 10Mbps. In that case, the egress rate is limitted up to 10Mbps no matter what.      Rate_index :        Packets/sec           (0 : 384),            (1 : 512),           (2 : 639),            (3 : 768),           (4 : 1024),           (5 : 1280),           (6 : 1536),           (7 : 1791),           (8 : 2048),           (9 : 2303),          (10 : 2559),          (11 : 2815),          (12 : 3328),          (13 : 3840),          (14 : 4352),          (15 : 4863),          (16 : 5376),          (17 : 5887),          (18 : 6400),          (19 : 6911),          (20 : 7936),          (21 : 8960),          (22 : 9984),          (23 : 11008),          (24 : 12030),         (25 : 13054),          (26 : 14076),         (27 : 15105),          (28 : 17146),         (29 : 19201),          (30 : 21240),         (31 : 23299),          (32 : 25354),         (33 : 27382),          (34 : 29446),         (35 : 31486),          (36 : 35561),         (37 : 39682),          (38 : 42589),         (39 : 56818),          (40 : 71023),         (41 : 85324),          (42 : 99602),         (43 : 113636),          (44 : 127551),        (45 : 142045),          (46 : 213675),        (47 : 284091),          (48 : 357143),        (49 : 423729),          (50 : 500000),        (51 : 568182),          (52 : 641026),        (53 : 714286),          (54 : 781250),        (55 : 862069),          (56 : 925926),        (57 : 1000000),          (58 : 1086957),       (59 : 1136364),          (60 : 1190476),       (61 : 1250000),          (62 : 1315789),       (63 : 1388889)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr 0x000041c0

#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE 1

/*
 * This structure should be used to declare and program IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
typedef union BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_s {
	uint32_t v[1];
	uint32_t imp_egress_rate_ctrl_cfg_reg[1];
	uint32_t _imp_egress_rate_ctrl_cfg_reg;
} BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t;

#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR(r) (r).imp_egress_rate_ctrl_cfg_reg[0] = 0
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET(r,d) (r).imp_egress_rate_ctrl_cfg_reg[0] = d
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET(r) (r).imp_egress_rate_ctrl_cfg_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET(r) (((r).imp_egress_rate_ctrl_cfg_reg[0]) & 0x3f)
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET(r) ((((r).imp_egress_rate_ctrl_cfg_reg[0]) >> 6) & 0x3)
#define BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
#define BCM89500_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr+(1*(i)),(r._imp_egress_rate_ctrl_cfg_reg),1)
#define BCM89500_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr+(1*(i)),&(r._imp_egress_rate_ctrl_cfg_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_EGRESS_RATE_CTRL_CFG_REGr BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE
typedef BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t IMP_EGRESS_RATE_CTRL_CFG_REGr_t;
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SET BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_GET BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET
#define READ_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM89500_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM89500_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_LEVEL1_QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Port 8, First Level QOS Weight Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     Q0_WEIGHT        Queue 0 Weight.
 *     Q1_WEIGHT        Queue 1 Weight.
 *     Q2_WEIGHT        Queue 2 Weight.
 *     Q3_WEIGHT        Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program higher Queue with higher weight. And this field mustn't be programmed as zero.Queue 3 Weight.
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr 0x00003b30

#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_SIZE 4

/*
 * This structure should be used to declare and program IMP_LEVEL1_QOS_WEIGHT.
 *
 */
typedef union BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t imp_level1_qos_weight[1];
	uint32_t _imp_level1_qos_weight;
} BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_t;

#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_CLR(r) (r).imp_level1_qos_weight[0] = 0
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_SET(r,d) (r).imp_level1_qos_weight[0] = d
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_GET(r) (r).imp_level1_qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET(r) (((r).imp_level1_qos_weight[0]) & 0xff)
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET(r,f) (r).imp_level1_qos_weight[0]=(((r).imp_level1_qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET(r) ((((r).imp_level1_qos_weight[0]) >> 8) & 0xff)
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET(r,f) (r).imp_level1_qos_weight[0]=(((r).imp_level1_qos_weight[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET(r) ((((r).imp_level1_qos_weight[0]) >> 16) & 0xff)
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET(r,f) (r).imp_level1_qos_weight[0]=(((r).imp_level1_qos_weight[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET(r) ((((r).imp_level1_qos_weight[0]) >> 24) & 0xff)
#define BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET(r,f) (r).imp_level1_qos_weight[0]=(((r).imp_level1_qos_weight[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access IMP_LEVEL1_QOS_WEIGHT.
 *
 */
#define BCM89500_A0_READ_IMP_LEVEL1_QOS_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr,(r._imp_level1_qos_weight),4)
#define BCM89500_A0_WRITE_IMP_LEVEL1_QOS_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr,&(r._imp_level1_qos_weight),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_LEVEL1_QOS_WEIGHTr BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr
#define IMP_LEVEL1_QOS_WEIGHTr_SIZE BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_SIZE
typedef BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_t IMP_LEVEL1_QOS_WEIGHTr_t;
#define IMP_LEVEL1_QOS_WEIGHTr_CLR BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_CLR
#define IMP_LEVEL1_QOS_WEIGHTr_SET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_SET
#define IMP_LEVEL1_QOS_WEIGHTr_GET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_GET
#define IMP_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET
#define IMP_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET
#define IMP_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET
#define IMP_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET
#define IMP_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET
#define IMP_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET
#define IMP_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET
#define IMP_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET
#define READ_IMP_LEVEL1_QOS_WEIGHTr BCM89500_A0_READ_IMP_LEVEL1_QOS_WEIGHTr
#define WRITE_IMP_LEVEL1_QOS_WEIGHTr BCM89500_A0_WRITE_IMP_LEVEL1_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_LEVEL1_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_LEVEL2_QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Port 8, Second Level QOS Weight Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     LEVEL1_OUTPUT_WEIGHT Ouput of First Level QOS Weight.
 *     Q4_WEIGHT        Queue 4 Weight.
 *     Q5_WEIGHT        Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program higher Queue with higher weight. And this field mustn't be programmed as zero.Queue 5 Weight.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr 0x00003b60

#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_SIZE 4

/*
 * This structure should be used to declare and program IMP_LEVEL2_QOS_WEIGHT.
 *
 */
typedef union BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t imp_level2_qos_weight[1];
	uint32_t _imp_level2_qos_weight;
} BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_t;

#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_CLR(r) (r).imp_level2_qos_weight[0] = 0
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_SET(r,d) (r).imp_level2_qos_weight[0] = d
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_GET(r) (r).imp_level2_qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET(r) (((r).imp_level2_qos_weight[0]) & 0xff)
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET(r,f) (r).imp_level2_qos_weight[0]=(((r).imp_level2_qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET(r) ((((r).imp_level2_qos_weight[0]) >> 8) & 0xff)
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET(r,f) (r).imp_level2_qos_weight[0]=(((r).imp_level2_qos_weight[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET(r) ((((r).imp_level2_qos_weight[0]) >> 16) & 0xff)
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET(r,f) (r).imp_level2_qos_weight[0]=(((r).imp_level2_qos_weight[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET(r) ((((r).imp_level2_qos_weight[0]) >> 24) & 0xff)
#define BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET(r,f) (r).imp_level2_qos_weight[0]=(((r).imp_level2_qos_weight[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access IMP_LEVEL2_QOS_WEIGHT.
 *
 */
#define BCM89500_A0_READ_IMP_LEVEL2_QOS_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr,(r._imp_level2_qos_weight),4)
#define BCM89500_A0_WRITE_IMP_LEVEL2_QOS_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr,&(r._imp_level2_qos_weight),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_LEVEL2_QOS_WEIGHTr BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr
#define IMP_LEVEL2_QOS_WEIGHTr_SIZE BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_SIZE
typedef BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_t IMP_LEVEL2_QOS_WEIGHTr_t;
#define IMP_LEVEL2_QOS_WEIGHTr_CLR BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_CLR
#define IMP_LEVEL2_QOS_WEIGHTr_SET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_SET
#define IMP_LEVEL2_QOS_WEIGHTr_GET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_GET
#define IMP_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET
#define IMP_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET
#define IMP_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET
#define IMP_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET
#define IMP_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET
#define IMP_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET
#define IMP_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET
#define IMP_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET
#define READ_IMP_LEVEL2_QOS_WEIGHTr BCM89500_A0_READ_IMP_LEVEL2_QOS_WEIGHTr
#define WRITE_IMP_LEVEL2_QOS_WEIGHTr BCM89500_A0_WRITE_IMP_LEVEL2_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_LEVEL2_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_LOW_QUEUE_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port 8, Low Queue (Q0-Q3) Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr 0x00003820

#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program IMP_LOW_QUEUE_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t imp_low_queue_max_refresh[1];
	uint32_t _imp_low_queue_max_refresh;
} BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_t;

#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_CLR(r) (r).imp_low_queue_max_refresh[0] = 0
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_SET(r,d) (r).imp_low_queue_max_refresh[0] = d
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_GET(r) (r).imp_low_queue_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).imp_low_queue_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).imp_low_queue_max_refresh[0]=(((r).imp_low_queue_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).imp_low_queue_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).imp_low_queue_max_refresh[0]=(((r).imp_low_queue_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IMP_LOW_QUEUE_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_IMP_LOW_QUEUE_MAX_REFRESHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr,(r._imp_low_queue_max_refresh),4)
#define BCM89500_A0_WRITE_IMP_LOW_QUEUE_MAX_REFRESHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr,&(r._imp_low_queue_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr
#define IMP_LOW_QUEUE_MAX_REFRESHr_SIZE BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_SIZE
typedef BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_t IMP_LOW_QUEUE_MAX_REFRESHr_t;
#define IMP_LOW_QUEUE_MAX_REFRESHr_CLR BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_CLR
#define IMP_LOW_QUEUE_MAX_REFRESHr_SET BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_SET
#define IMP_LOW_QUEUE_MAX_REFRESHr_GET BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_GET
#define IMP_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET
#define IMP_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET
#define IMP_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET
#define IMP_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET
#define READ_IMP_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_READ_IMP_LOW_QUEUE_MAX_REFRESHr
#define WRITE_IMP_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_WRITE_IMP_LOW_QUEUE_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_LOW_QUEUE_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_LOW_QUEUE_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port 8, Low Queue (Q0-Q3) Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr 0x00003850

#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program IMP_LOW_QUEUE_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t imp_low_queue_max_thd_sel[1];
	uint32_t _imp_low_queue_max_thd_sel;
} BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_t;

#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_CLR(r) (r).imp_low_queue_max_thd_sel[0] = 0
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_SET(r,d) (r).imp_low_queue_max_thd_sel[0] = d
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_GET(r) (r).imp_low_queue_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).imp_low_queue_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).imp_low_queue_max_thd_sel[0]=(((r).imp_low_queue_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).imp_low_queue_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).imp_low_queue_max_thd_sel[0]=(((r).imp_low_queue_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IMP_LOW_QUEUE_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_IMP_LOW_QUEUE_MAX_THD_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr,(r._imp_low_queue_max_thd_sel),4)
#define BCM89500_A0_WRITE_IMP_LOW_QUEUE_MAX_THD_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr,&(r._imp_low_queue_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr
#define IMP_LOW_QUEUE_MAX_THD_SELr_SIZE BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_SIZE
typedef BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_t IMP_LOW_QUEUE_MAX_THD_SELr_t;
#define IMP_LOW_QUEUE_MAX_THD_SELr_CLR BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_CLR
#define IMP_LOW_QUEUE_MAX_THD_SELr_SET BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_SET
#define IMP_LOW_QUEUE_MAX_THD_SELr_GET BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_GET
#define IMP_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET
#define IMP_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET
#define IMP_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET
#define IMP_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET
#define READ_IMP_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_READ_IMP_LOW_QUEUE_MAX_THD_SELr
#define WRITE_IMP_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_WRITE_IMP_LOW_QUEUE_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_LOW_QUEUE_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_LOW_QUEUE_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port 8, Low Queue (Q0-Q3) Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr 0x00003880

#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program IMP_LOW_QUEUE_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t imp_low_queue_shaper_sts[1];
	uint32_t _imp_low_queue_shaper_sts;
} BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_t;

#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_CLR(r) (r).imp_low_queue_shaper_sts[0] = 0
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_SET(r,d) (r).imp_low_queue_shaper_sts[0] = d
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_GET(r) (r).imp_low_queue_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).imp_low_queue_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).imp_low_queue_shaper_sts[0]=(((r).imp_low_queue_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET(r) ((((r).imp_low_queue_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET(r,f) (r).imp_low_queue_shaper_sts[0]=(((r).imp_low_queue_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).imp_low_queue_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).imp_low_queue_shaper_sts[0]=(((r).imp_low_queue_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access IMP_LOW_QUEUE_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_IMP_LOW_QUEUE_SHAPER_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr,(r._imp_low_queue_shaper_sts),4)
#define BCM89500_A0_WRITE_IMP_LOW_QUEUE_SHAPER_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr,&(r._imp_low_queue_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_LOW_QUEUE_SHAPER_STSr BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr
#define IMP_LOW_QUEUE_SHAPER_STSr_SIZE BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_SIZE
typedef BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_t IMP_LOW_QUEUE_SHAPER_STSr_t;
#define IMP_LOW_QUEUE_SHAPER_STSr_CLR BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_CLR
#define IMP_LOW_QUEUE_SHAPER_STSr_SET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_SET
#define IMP_LOW_QUEUE_SHAPER_STSr_GET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_GET
#define IMP_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET
#define IMP_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET
#define IMP_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET
#define IMP_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET
#define IMP_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define IMP_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_IMP_LOW_QUEUE_SHAPER_STSr BCM89500_A0_READ_IMP_LOW_QUEUE_SHAPER_STSr
#define WRITE_IMP_LOW_QUEUE_SHAPER_STSr BCM89500_A0_WRITE_IMP_LOW_QUEUE_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_LOW_QUEUE_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_PCP2TC
 * BLOCKS:   CPIC
 * DESC:     Port 8 PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_PCP2TCr 0x0000302c

#define BCM89500_A0_IMP_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program IMP_PCP2TC.
 *
 */
typedef union BCM89500_A0_IMP_PCP2TCr_s {
	uint32_t v[1];
	uint32_t imp_pcp2tc[1];
	uint32_t _imp_pcp2tc;
} BCM89500_A0_IMP_PCP2TCr_t;

#define BCM89500_A0_IMP_PCP2TCr_CLR(r) (r).imp_pcp2tc[0] = 0
#define BCM89500_A0_IMP_PCP2TCr_SET(r,d) (r).imp_pcp2tc[0] = d
#define BCM89500_A0_IMP_PCP2TCr_GET(r) (r).imp_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).imp_pcp2tc[0]) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 3) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 6) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 9) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 12) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 15) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 18) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 21) & 0x7)
#define BCM89500_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_IMP_PCP2TCr_RESERVEDf_GET(r) ((((r).imp_pcp2tc[0]) >> 24) & 0xff)
#define BCM89500_A0_IMP_PCP2TCr_RESERVEDf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access IMP_PCP2TC.
 *
 */
#define BCM89500_A0_READ_IMP_PCP2TCr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_PCP2TCr,(r._imp_pcp2tc),4)
#define BCM89500_A0_WRITE_IMP_PCP2TCr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_PCP2TCr,&(r._imp_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_PCP2TCr BCM89500_A0_IMP_PCP2TCr
#define IMP_PCP2TCr_SIZE BCM89500_A0_IMP_PCP2TCr_SIZE
typedef BCM89500_A0_IMP_PCP2TCr_t IMP_PCP2TCr_t;
#define IMP_PCP2TCr_CLR BCM89500_A0_IMP_PCP2TCr_CLR
#define IMP_PCP2TCr_SET BCM89500_A0_IMP_PCP2TCr_SET
#define IMP_PCP2TCr_GET BCM89500_A0_IMP_PCP2TCr_GET
#define IMP_PCP2TCr_TAG000_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG000_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG001_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG001_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG010_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG010_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG011_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG011_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG100_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG100_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG101_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG101_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG110_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG110_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG111_PRI_MAPf_GET BCM89500_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG111_PRI_MAPf_SET BCM89500_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_SET
#define IMP_PCP2TCr_RESERVEDf_GET BCM89500_A0_IMP_PCP2TCr_RESERVEDf_GET
#define IMP_PCP2TCr_RESERVEDf_SET BCM89500_A0_IMP_PCP2TCr_RESERVEDf_SET
#define READ_IMP_PCP2TCr BCM89500_A0_READ_IMP_PCP2TCr
#define WRITE_IMP_PCP2TCr BCM89500_A0_WRITE_IMP_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QOS_PRI_CTL
 * BLOCKS:   SYS
 * DESC:     Port 8, QOS Priority Control Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     LEVEL1_QOS_PRI_CTL First level QoS priority for Q0 to Q32'b00: for Q0 - 3 are WRR2'b01: for COS3 (SP) and COS2-COS0 (WRR)2'b10: for COS3 (SP), COS2 (SP) and COS1-COS0 (WRR)2'b11: for COS3-COS0 (SP)
 *     LEVEL2_QOS_PRI_CTL Second level QoS priority for Queue 4, Queue 5, and the output of LEVEL1_QOS_PRI2'b00: for COS5, COS4 and the output of LEVEL1_QOS_PRI are WRR2'b01: for COS5 (SP), COS4 and the output of LEVEL1_QOS_PRI (WRR)2'b10: for COS5 (SP), COS4 (SP) and the output of LEVEL1_QOS_PRI (SP)2'b11: for Reserve
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QOS_PRI_CTLr 0x00003b08

#define BCM89500_A0_IMP_QOS_PRI_CTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_QOS_PRI_CTL.
 *
 */
typedef union BCM89500_A0_IMP_QOS_PRI_CTLr_s {
	uint32_t v[1];
	uint32_t imp_qos_pri_ctl[1];
	uint32_t _imp_qos_pri_ctl;
} BCM89500_A0_IMP_QOS_PRI_CTLr_t;

#define BCM89500_A0_IMP_QOS_PRI_CTLr_CLR(r) (r).imp_qos_pri_ctl[0] = 0
#define BCM89500_A0_IMP_QOS_PRI_CTLr_SET(r,d) (r).imp_qos_pri_ctl[0] = d
#define BCM89500_A0_IMP_QOS_PRI_CTLr_GET(r) (r).imp_qos_pri_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET(r) (((r).imp_qos_pri_ctl[0]) & 0x3)
#define BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET(r,f) (r).imp_qos_pri_ctl[0]=(((r).imp_qos_pri_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET(r) ((((r).imp_qos_pri_ctl[0]) >> 2) & 0x3)
#define BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET(r,f) (r).imp_qos_pri_ctl[0]=(((r).imp_qos_pri_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_IMP_QOS_PRI_CTLr_RESERVEDf_GET(r) ((((r).imp_qos_pri_ctl[0]) >> 4) & 0xf)
#define BCM89500_A0_IMP_QOS_PRI_CTLr_RESERVEDf_SET(r,f) (r).imp_qos_pri_ctl[0]=(((r).imp_qos_pri_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP_QOS_PRI_CTL.
 *
 */
#define BCM89500_A0_READ_IMP_QOS_PRI_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QOS_PRI_CTLr,(r._imp_qos_pri_ctl),1)
#define BCM89500_A0_WRITE_IMP_QOS_PRI_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QOS_PRI_CTLr,&(r._imp_qos_pri_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QOS_PRI_CTLr BCM89500_A0_IMP_QOS_PRI_CTLr
#define IMP_QOS_PRI_CTLr_SIZE BCM89500_A0_IMP_QOS_PRI_CTLr_SIZE
typedef BCM89500_A0_IMP_QOS_PRI_CTLr_t IMP_QOS_PRI_CTLr_t;
#define IMP_QOS_PRI_CTLr_CLR BCM89500_A0_IMP_QOS_PRI_CTLr_CLR
#define IMP_QOS_PRI_CTLr_SET BCM89500_A0_IMP_QOS_PRI_CTLr_SET
#define IMP_QOS_PRI_CTLr_GET BCM89500_A0_IMP_QOS_PRI_CTLr_GET
#define IMP_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET
#define IMP_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET
#define IMP_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET
#define IMP_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET BCM89500_A0_IMP_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET
#define IMP_QOS_PRI_CTLr_RESERVEDf_GET BCM89500_A0_IMP_QOS_PRI_CTLr_RESERVEDf_GET
#define IMP_QOS_PRI_CTLr_RESERVEDf_SET BCM89500_A0_IMP_QOS_PRI_CTLr_RESERVEDf_SET
#define READ_IMP_QOS_PRI_CTLr BCM89500_A0_READ_IMP_QOS_PRI_CTLr
#define WRITE_IMP_QOS_PRI_CTLr BCM89500_A0_WRITE_IMP_QOS_PRI_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QOS_PRI_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QUEUE4_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port 8, Queue 4 Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr 0x00003920

#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program IMP_QUEUE4_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t imp_queue4_max_refresh[1];
	uint32_t _imp_queue4_max_refresh;
} BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_t;

#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_CLR(r) (r).imp_queue4_max_refresh[0] = 0
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_SET(r,d) (r).imp_queue4_max_refresh[0] = d
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_GET(r) (r).imp_queue4_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).imp_queue4_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).imp_queue4_max_refresh[0]=(((r).imp_queue4_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).imp_queue4_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).imp_queue4_max_refresh[0]=(((r).imp_queue4_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IMP_QUEUE4_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_IMP_QUEUE4_MAX_REFRESHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr,(r._imp_queue4_max_refresh),4)
#define BCM89500_A0_WRITE_IMP_QUEUE4_MAX_REFRESHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr,&(r._imp_queue4_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QUEUE4_MAX_REFRESHr BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr
#define IMP_QUEUE4_MAX_REFRESHr_SIZE BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_SIZE
typedef BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_t IMP_QUEUE4_MAX_REFRESHr_t;
#define IMP_QUEUE4_MAX_REFRESHr_CLR BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_CLR
#define IMP_QUEUE4_MAX_REFRESHr_SET BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_SET
#define IMP_QUEUE4_MAX_REFRESHr_GET BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_GET
#define IMP_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET
#define IMP_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET
#define IMP_QUEUE4_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_RESERVEDf_GET
#define IMP_QUEUE4_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr_RESERVEDf_SET
#define READ_IMP_QUEUE4_MAX_REFRESHr BCM89500_A0_READ_IMP_QUEUE4_MAX_REFRESHr
#define WRITE_IMP_QUEUE4_MAX_REFRESHr BCM89500_A0_WRITE_IMP_QUEUE4_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QUEUE4_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QUEUE4_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port 8, Queue 4 Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr 0x00003950

#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program IMP_QUEUE4_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t imp_queue4_max_thd_sel[1];
	uint32_t _imp_queue4_max_thd_sel;
} BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_t;

#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_CLR(r) (r).imp_queue4_max_thd_sel[0] = 0
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_SET(r,d) (r).imp_queue4_max_thd_sel[0] = d
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_GET(r) (r).imp_queue4_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).imp_queue4_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).imp_queue4_max_thd_sel[0]=(((r).imp_queue4_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).imp_queue4_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).imp_queue4_max_thd_sel[0]=(((r).imp_queue4_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IMP_QUEUE4_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_IMP_QUEUE4_MAX_THD_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr,(r._imp_queue4_max_thd_sel),4)
#define BCM89500_A0_WRITE_IMP_QUEUE4_MAX_THD_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr,&(r._imp_queue4_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QUEUE4_MAX_THD_SELr BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr
#define IMP_QUEUE4_MAX_THD_SELr_SIZE BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_SIZE
typedef BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_t IMP_QUEUE4_MAX_THD_SELr_t;
#define IMP_QUEUE4_MAX_THD_SELr_CLR BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_CLR
#define IMP_QUEUE4_MAX_THD_SELr_SET BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_SET
#define IMP_QUEUE4_MAX_THD_SELr_GET BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_GET
#define IMP_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET
#define IMP_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET
#define IMP_QUEUE4_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_RESERVEDf_GET
#define IMP_QUEUE4_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr_RESERVEDf_SET
#define READ_IMP_QUEUE4_MAX_THD_SELr BCM89500_A0_READ_IMP_QUEUE4_MAX_THD_SELr
#define WRITE_IMP_QUEUE4_MAX_THD_SELr BCM89500_A0_WRITE_IMP_QUEUE4_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QUEUE4_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QUEUE4_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port 8, Queue 4 Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr 0x00003980

#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program IMP_QUEUE4_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t imp_queue4_shaper_sts[1];
	uint32_t _imp_queue4_shaper_sts;
} BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_t;

#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_CLR(r) (r).imp_queue4_shaper_sts[0] = 0
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_SET(r,d) (r).imp_queue4_shaper_sts[0] = d
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_GET(r) (r).imp_queue4_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).imp_queue4_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).imp_queue4_shaper_sts[0]=(((r).imp_queue4_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_RESERVEDf_GET(r) ((((r).imp_queue4_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_RESERVEDf_SET(r,f) (r).imp_queue4_shaper_sts[0]=(((r).imp_queue4_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).imp_queue4_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).imp_queue4_shaper_sts[0]=(((r).imp_queue4_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access IMP_QUEUE4_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_IMP_QUEUE4_SHAPER_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QUEUE4_SHAPER_STSr,(r._imp_queue4_shaper_sts),4)
#define BCM89500_A0_WRITE_IMP_QUEUE4_SHAPER_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QUEUE4_SHAPER_STSr,&(r._imp_queue4_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QUEUE4_SHAPER_STSr BCM89500_A0_IMP_QUEUE4_SHAPER_STSr
#define IMP_QUEUE4_SHAPER_STSr_SIZE BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_SIZE
typedef BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_t IMP_QUEUE4_SHAPER_STSr_t;
#define IMP_QUEUE4_SHAPER_STSr_CLR BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_CLR
#define IMP_QUEUE4_SHAPER_STSr_SET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_SET
#define IMP_QUEUE4_SHAPER_STSr_GET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_GET
#define IMP_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET
#define IMP_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET
#define IMP_QUEUE4_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_RESERVEDf_GET
#define IMP_QUEUE4_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_RESERVEDf_SET
#define IMP_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define IMP_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_IMP_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_IMP_QUEUE4_SHAPER_STSr BCM89500_A0_READ_IMP_QUEUE4_SHAPER_STSr
#define WRITE_IMP_QUEUE4_SHAPER_STSr BCM89500_A0_WRITE_IMP_QUEUE4_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QUEUE4_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QUEUE5_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port 8, Queue 5 Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr 0x00003a20

#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program IMP_QUEUE5_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t imp_queue5_max_refresh[1];
	uint32_t _imp_queue5_max_refresh;
} BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_t;

#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_CLR(r) (r).imp_queue5_max_refresh[0] = 0
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_SET(r,d) (r).imp_queue5_max_refresh[0] = d
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_GET(r) (r).imp_queue5_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).imp_queue5_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).imp_queue5_max_refresh[0]=(((r).imp_queue5_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).imp_queue5_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).imp_queue5_max_refresh[0]=(((r).imp_queue5_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IMP_QUEUE5_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_IMP_QUEUE5_MAX_REFRESHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr,(r._imp_queue5_max_refresh),4)
#define BCM89500_A0_WRITE_IMP_QUEUE5_MAX_REFRESHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr,&(r._imp_queue5_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QUEUE5_MAX_REFRESHr BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr
#define IMP_QUEUE5_MAX_REFRESHr_SIZE BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_SIZE
typedef BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_t IMP_QUEUE5_MAX_REFRESHr_t;
#define IMP_QUEUE5_MAX_REFRESHr_CLR BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_CLR
#define IMP_QUEUE5_MAX_REFRESHr_SET BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_SET
#define IMP_QUEUE5_MAX_REFRESHr_GET BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_GET
#define IMP_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET
#define IMP_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET
#define IMP_QUEUE5_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_RESERVEDf_GET
#define IMP_QUEUE5_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr_RESERVEDf_SET
#define READ_IMP_QUEUE5_MAX_REFRESHr BCM89500_A0_READ_IMP_QUEUE5_MAX_REFRESHr
#define WRITE_IMP_QUEUE5_MAX_REFRESHr BCM89500_A0_WRITE_IMP_QUEUE5_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QUEUE5_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QUEUE5_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port 8, Queue 5 Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr 0x00003a50

#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program IMP_QUEUE5_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t imp_queue5_max_thd_sel[1];
	uint32_t _imp_queue5_max_thd_sel;
} BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_t;

#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_CLR(r) (r).imp_queue5_max_thd_sel[0] = 0
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_SET(r,d) (r).imp_queue5_max_thd_sel[0] = d
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_GET(r) (r).imp_queue5_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).imp_queue5_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).imp_queue5_max_thd_sel[0]=(((r).imp_queue5_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).imp_queue5_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).imp_queue5_max_thd_sel[0]=(((r).imp_queue5_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IMP_QUEUE5_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_IMP_QUEUE5_MAX_THD_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr,(r._imp_queue5_max_thd_sel),4)
#define BCM89500_A0_WRITE_IMP_QUEUE5_MAX_THD_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr,&(r._imp_queue5_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QUEUE5_MAX_THD_SELr BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr
#define IMP_QUEUE5_MAX_THD_SELr_SIZE BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_SIZE
typedef BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_t IMP_QUEUE5_MAX_THD_SELr_t;
#define IMP_QUEUE5_MAX_THD_SELr_CLR BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_CLR
#define IMP_QUEUE5_MAX_THD_SELr_SET BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_SET
#define IMP_QUEUE5_MAX_THD_SELr_GET BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_GET
#define IMP_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET
#define IMP_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET
#define IMP_QUEUE5_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_RESERVEDf_GET
#define IMP_QUEUE5_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr_RESERVEDf_SET
#define READ_IMP_QUEUE5_MAX_THD_SELr BCM89500_A0_READ_IMP_QUEUE5_MAX_THD_SELr
#define WRITE_IMP_QUEUE5_MAX_THD_SELr BCM89500_A0_WRITE_IMP_QUEUE5_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QUEUE5_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_QUEUE5_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port 8, Queue 5 Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr 0x00003a80

#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program IMP_QUEUE5_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t imp_queue5_shaper_sts[1];
	uint32_t _imp_queue5_shaper_sts;
} BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_t;

#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_CLR(r) (r).imp_queue5_shaper_sts[0] = 0
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_SET(r,d) (r).imp_queue5_shaper_sts[0] = d
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_GET(r) (r).imp_queue5_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).imp_queue5_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).imp_queue5_shaper_sts[0]=(((r).imp_queue5_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_RESERVEDf_GET(r) ((((r).imp_queue5_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_RESERVEDf_SET(r,f) (r).imp_queue5_shaper_sts[0]=(((r).imp_queue5_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).imp_queue5_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).imp_queue5_shaper_sts[0]=(((r).imp_queue5_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access IMP_QUEUE5_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_IMP_QUEUE5_SHAPER_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_QUEUE5_SHAPER_STSr,(r._imp_queue5_shaper_sts),4)
#define BCM89500_A0_WRITE_IMP_QUEUE5_SHAPER_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_QUEUE5_SHAPER_STSr,&(r._imp_queue5_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_QUEUE5_SHAPER_STSr BCM89500_A0_IMP_QUEUE5_SHAPER_STSr
#define IMP_QUEUE5_SHAPER_STSr_SIZE BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_SIZE
typedef BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_t IMP_QUEUE5_SHAPER_STSr_t;
#define IMP_QUEUE5_SHAPER_STSr_CLR BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_CLR
#define IMP_QUEUE5_SHAPER_STSr_SET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_SET
#define IMP_QUEUE5_SHAPER_STSr_GET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_GET
#define IMP_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET
#define IMP_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET
#define IMP_QUEUE5_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_RESERVEDf_GET
#define IMP_QUEUE5_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_RESERVEDf_SET
#define IMP_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define IMP_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_IMP_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_IMP_QUEUE5_SHAPER_STSr BCM89500_A0_READ_IMP_QUEUE5_SHAPER_STSr
#define WRITE_IMP_QUEUE5_SHAPER_STSr BCM89500_A0_WRITE_IMP_QUEUE5_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_QUEUE5_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_RGMII_CTL_GP
 * BLOCKS:   CPIC
 * DESC:     IMP RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     EN_RGMII_DLL_TXC 1: RGMII tx_clk delayed timing mode(Delay Mode)0: RGMII tx_clk aligned timing mode(Normal Mode)
 *     EN_RGMII_DLL_RXC 1: clock delay by DLL is enabled(Delay Mode)0: clock delay by DLL is disabled (Normal Mode)
 *     BYPASS_2NS_DEL   1: bypass dll65_2ns_del IP0: use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affected by bit[0] and bit[1]{Bit[2], Bit[0]}= 2'b10, Bypass tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b11, use tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b0X, use tx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b10, Bypass rx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b11, use rx side dll65_2ns_del IP{Bit[2], Bit[1}= 2'b0X, use rx side dll65_2ns_del IP(Not2Release)
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_RGMII_CTL_GPr 0x00000060

#define BCM89500_A0_IMP_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_CTL_GP.
 *
 */
typedef union BCM89500_A0_IMP_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_ctl_gp[1];
	uint32_t _imp_rgmii_ctl_gp;
} BCM89500_A0_IMP_RGMII_CTL_GPr_t;

#define BCM89500_A0_IMP_RGMII_CTL_GPr_CLR(r) (r).imp_rgmii_ctl_gp[0] = 0
#define BCM89500_A0_IMP_RGMII_CTL_GPr_SET(r,d) (r).imp_rgmii_ctl_gp[0] = d
#define BCM89500_A0_IMP_RGMII_CTL_GPr_GET(r) (r).imp_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET(r) (((r).imp_rgmii_ctl_gp[0]) & 0x1)
#define BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_IMP_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM89500_A0_IMP_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_0f_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 3) & 0x1)
#define BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_0f_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP_RGMII_CTL_GP.
 *
 */
#define BCM89500_A0_READ_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_RGMII_CTL_GPr,(r._imp_rgmii_ctl_gp),1)
#define BCM89500_A0_WRITE_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_RGMII_CTL_GPr,&(r._imp_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_CTL_GPr BCM89500_A0_IMP_RGMII_CTL_GPr
#define IMP_RGMII_CTL_GPr_SIZE BCM89500_A0_IMP_RGMII_CTL_GPr_SIZE
typedef BCM89500_A0_IMP_RGMII_CTL_GPr_t IMP_RGMII_CTL_GPr_t;
#define IMP_RGMII_CTL_GPr_CLR BCM89500_A0_IMP_RGMII_CTL_GPr_CLR
#define IMP_RGMII_CTL_GPr_SET BCM89500_A0_IMP_RGMII_CTL_GPr_SET
#define IMP_RGMII_CTL_GPr_GET BCM89500_A0_IMP_RGMII_CTL_GPr_GET
#define IMP_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET
#define IMP_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET
#define IMP_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET
#define IMP_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET BCM89500_A0_IMP_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET
#define IMP_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET BCM89500_A0_IMP_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET
#define IMP_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET BCM89500_A0_IMP_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET
#define IMP_RGMII_CTL_GPr_RESERVED_0f_GET BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_0f_GET
#define IMP_RGMII_CTL_GPr_RESERVED_0f_SET BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_0f_SET
#define IMP_RGMII_CTL_GPr_RESERVED_1f_GET BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_GET
#define IMP_RGMII_CTL_GPr_RESERVED_1f_SET BCM89500_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_SET
#define READ_IMP_RGMII_CTL_GPr BCM89500_A0_READ_IMP_RGMII_CTL_GPr
#define WRITE_IMP_RGMII_CTL_GPr BCM89500_A0_WRITE_IMP_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_RGMII_TIME_DLY_GP
 * BLOCKS:   CPIC
 * DESC:     IMP Port RGMII TIMING DELAY register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr 0x00000068

#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_time_dly_gp[1];
	uint32_t _imp_rgmii_time_dly_gp;
} BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_t;

#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_CLR(r) (r).imp_rgmii_time_dly_gp[0] = 0
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_SET(r,d) (r).imp_rgmii_time_dly_gp[0] = d
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_GET(r) (r).imp_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).imp_rgmii_time_dly_gp[0]) & 0xf)
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access IMP_RGMII_TIME_DLY_GP.
 *
 */
#define BCM89500_A0_READ_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_RGMII_TIME_DLY_GPr,(r._imp_rgmii_time_dly_gp),1)
#define BCM89500_A0_WRITE_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_RGMII_TIME_DLY_GPr,&(r._imp_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_TIME_DLY_GPr BCM89500_A0_IMP_RGMII_TIME_DLY_GPr
#define IMP_RGMII_TIME_DLY_GPr_SIZE BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_SIZE
typedef BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_t IMP_RGMII_TIME_DLY_GPr_t;
#define IMP_RGMII_TIME_DLY_GPr_CLR BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_CLR
#define IMP_RGMII_TIME_DLY_GPr_SET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_SET
#define IMP_RGMII_TIME_DLY_GPr_GET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM89500_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_IMP_RGMII_TIME_DLY_GPr BCM89500_A0_READ_IMP_RGMII_TIME_DLY_GPr
#define WRITE_IMP_RGMII_TIME_DLY_GPr BCM89500_A0_WRITE_IMP_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_SLEEP_TIMER
 * BLOCKS:   SYS
 * DESC:     IMP Port(port 8) Sleep Timer Register
 * SIZE:     16
 * FIELDS:
 *     IMP_SLEEP_TIMER  IMP Sleep Timer.The configuration value of IMP port(port 8) sleep timer to indicate the desired sleep recovery time(i.e. wake-up time). When the timer is set by the CPU to a non-zero value. it puts the IMP port to sleep. The wake-up time is the set value decrease 1.The unit is 1 usec
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_SLEEP_TIMERr 0x00000310

#define BCM89500_A0_IMP_SLEEP_TIMERr_SIZE 2

/*
 * This structure should be used to declare and program IMP_SLEEP_TIMER.
 *
 */
typedef union BCM89500_A0_IMP_SLEEP_TIMERr_s {
	uint32_t v[1];
	uint32_t imp_sleep_timer[1];
	uint32_t _imp_sleep_timer;
} BCM89500_A0_IMP_SLEEP_TIMERr_t;

#define BCM89500_A0_IMP_SLEEP_TIMERr_CLR(r) (r).imp_sleep_timer[0] = 0
#define BCM89500_A0_IMP_SLEEP_TIMERr_SET(r,d) (r).imp_sleep_timer[0] = d
#define BCM89500_A0_IMP_SLEEP_TIMERr_GET(r) (r).imp_sleep_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_GET(r) (((r).imp_sleep_timer[0]) & 0x1fff)
#define BCM89500_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_SET(r,f) (r).imp_sleep_timer[0]=(((r).imp_sleep_timer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM89500_A0_IMP_SLEEP_TIMERr_RESERVEDf_GET(r) ((((r).imp_sleep_timer[0]) >> 13) & 0x7)
#define BCM89500_A0_IMP_SLEEP_TIMERr_RESERVEDf_SET(r,f) (r).imp_sleep_timer[0]=(((r).imp_sleep_timer[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access IMP_SLEEP_TIMER.
 *
 */
#define BCM89500_A0_READ_IMP_SLEEP_TIMERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_SLEEP_TIMERr,(r._imp_sleep_timer),2)
#define BCM89500_A0_WRITE_IMP_SLEEP_TIMERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_SLEEP_TIMERr,&(r._imp_sleep_timer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_SLEEP_TIMERr BCM89500_A0_IMP_SLEEP_TIMERr
#define IMP_SLEEP_TIMERr_SIZE BCM89500_A0_IMP_SLEEP_TIMERr_SIZE
typedef BCM89500_A0_IMP_SLEEP_TIMERr_t IMP_SLEEP_TIMERr_t;
#define IMP_SLEEP_TIMERr_CLR BCM89500_A0_IMP_SLEEP_TIMERr_CLR
#define IMP_SLEEP_TIMERr_SET BCM89500_A0_IMP_SLEEP_TIMERr_SET
#define IMP_SLEEP_TIMERr_GET BCM89500_A0_IMP_SLEEP_TIMERr_GET
#define IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_GET BCM89500_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_GET
#define IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_SET BCM89500_A0_IMP_SLEEP_TIMERr_IMP_SLEEP_TIMERf_SET
#define IMP_SLEEP_TIMERr_RESERVEDf_GET BCM89500_A0_IMP_SLEEP_TIMERr_RESERVEDf_GET
#define IMP_SLEEP_TIMERr_RESERVEDf_SET BCM89500_A0_IMP_SLEEP_TIMERr_RESERVEDf_SET
#define READ_IMP_SLEEP_TIMERr BCM89500_A0_READ_IMP_SLEEP_TIMERr
#define WRITE_IMP_SLEEP_TIMERr BCM89500_A0_WRITE_IMP_SLEEP_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_SLEEP_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     Port 8 TC to COS Mapping Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.
 *     PRT111_TO_QID    *** Note that ***Queue ID 0: 000Queue ID 1: 001Queue ID 2: 010Queue ID 3: 011Queue ID 4: 100Queue ID 5: 101Priority ID 111 mapped to TX Queue ID.
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_TC2COS_MAPr 0x00003090

#define BCM89500_A0_IMP_TC2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program IMP_TC2COS_MAP.
 *
 */
typedef union BCM89500_A0_IMP_TC2COS_MAPr_s {
	uint32_t v[1];
	uint32_t imp_tc2cos_map[1];
	uint32_t _imp_tc2cos_map;
} BCM89500_A0_IMP_TC2COS_MAPr_t;

#define BCM89500_A0_IMP_TC2COS_MAPr_CLR(r) (r).imp_tc2cos_map[0] = 0
#define BCM89500_A0_IMP_TC2COS_MAPr_SET(r,d) (r).imp_tc2cos_map[0] = d
#define BCM89500_A0_IMP_TC2COS_MAPr_GET(r) (r).imp_tc2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT000_TO_QIDf_GET(r) (((r).imp_tc2cos_map[0]) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT000_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT001_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 3) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT001_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT010_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 6) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT010_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT011_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 9) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT011_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT100_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 12) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT100_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT101_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 15) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT101_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT110_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 18) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT110_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT111_TO_QIDf_GET(r) ((((r).imp_tc2cos_map[0]) >> 21) & 0x7)
#define BCM89500_A0_IMP_TC2COS_MAPr_PRT111_TO_QIDf_SET(r,f) (r).imp_tc2cos_map[0]=(((r).imp_tc2cos_map[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access IMP_TC2COS_MAP.
 *
 */
#define BCM89500_A0_READ_IMP_TC2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_TC2COS_MAPr,(r._imp_tc2cos_map),4)
#define BCM89500_A0_WRITE_IMP_TC2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_TC2COS_MAPr,&(r._imp_tc2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_TC2COS_MAPr BCM89500_A0_IMP_TC2COS_MAPr
#define IMP_TC2COS_MAPr_SIZE BCM89500_A0_IMP_TC2COS_MAPr_SIZE
typedef BCM89500_A0_IMP_TC2COS_MAPr_t IMP_TC2COS_MAPr_t;
#define IMP_TC2COS_MAPr_CLR BCM89500_A0_IMP_TC2COS_MAPr_CLR
#define IMP_TC2COS_MAPr_SET BCM89500_A0_IMP_TC2COS_MAPr_SET
#define IMP_TC2COS_MAPr_GET BCM89500_A0_IMP_TC2COS_MAPr_GET
#define IMP_TC2COS_MAPr_PRT000_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT000_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT000_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT000_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT001_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT001_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT001_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT001_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT010_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT010_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT010_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT010_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT011_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT011_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT011_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT011_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT100_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT100_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT100_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT100_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT101_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT101_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT101_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT101_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT110_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT110_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT110_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT110_TO_QIDf_SET
#define IMP_TC2COS_MAPr_PRT111_TO_QIDf_GET BCM89500_A0_IMP_TC2COS_MAPr_PRT111_TO_QIDf_GET
#define IMP_TC2COS_MAPr_PRT111_TO_QIDf_SET BCM89500_A0_IMP_TC2COS_MAPr_PRT111_TO_QIDf_SET
#define READ_IMP_TC2COS_MAPr BCM89500_A0_READ_IMP_TC2COS_MAPr
#define WRITE_IMP_TC2COS_MAPr BCM89500_A0_WRITE_IMP_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IMP_TC_SEL_TABLE
 * BLOCKS:   SYS
 * DESC:     Port 8 TC Select Table Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     TC_SEL_0         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_1         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_2         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_3         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_4         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_5         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_6         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_7         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *
 ******************************************************************************/
#define BCM89500_A0_IMP_TC_SEL_TABLEr 0x00003060

#define BCM89500_A0_IMP_TC_SEL_TABLEr_SIZE 2

/*
 * This structure should be used to declare and program IMP_TC_SEL_TABLE.
 *
 */
typedef union BCM89500_A0_IMP_TC_SEL_TABLEr_s {
	uint32_t v[1];
	uint32_t imp_tc_sel_table[1];
	uint32_t _imp_tc_sel_table;
} BCM89500_A0_IMP_TC_SEL_TABLEr_t;

#define BCM89500_A0_IMP_TC_SEL_TABLEr_CLR(r) (r).imp_tc_sel_table[0] = 0
#define BCM89500_A0_IMP_TC_SEL_TABLEr_SET(r,d) (r).imp_tc_sel_table[0] = d
#define BCM89500_A0_IMP_TC_SEL_TABLEr_GET(r) (r).imp_tc_sel_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_0f_GET(r) (((r).imp_tc_sel_table[0]) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_0f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_1f_GET(r) ((((r).imp_tc_sel_table[0]) >> 2) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_1f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_2f_GET(r) ((((r).imp_tc_sel_table[0]) >> 4) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_2f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_3f_GET(r) ((((r).imp_tc_sel_table[0]) >> 6) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_3f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_4f_GET(r) ((((r).imp_tc_sel_table[0]) >> 8) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_4f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_5f_GET(r) ((((r).imp_tc_sel_table[0]) >> 10) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_5f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_6f_GET(r) ((((r).imp_tc_sel_table[0]) >> 12) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_6f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_7f_GET(r) ((((r).imp_tc_sel_table[0]) >> 14) & 0x3)
#define BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_7f_SET(r,f) (r).imp_tc_sel_table[0]=(((r).imp_tc_sel_table[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IMP_TC_SEL_TABLE.
 *
 */
#define BCM89500_A0_READ_IMP_TC_SEL_TABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IMP_TC_SEL_TABLEr,(r._imp_tc_sel_table),2)
#define BCM89500_A0_WRITE_IMP_TC_SEL_TABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IMP_TC_SEL_TABLEr,&(r._imp_tc_sel_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_TC_SEL_TABLEr BCM89500_A0_IMP_TC_SEL_TABLEr
#define IMP_TC_SEL_TABLEr_SIZE BCM89500_A0_IMP_TC_SEL_TABLEr_SIZE
typedef BCM89500_A0_IMP_TC_SEL_TABLEr_t IMP_TC_SEL_TABLEr_t;
#define IMP_TC_SEL_TABLEr_CLR BCM89500_A0_IMP_TC_SEL_TABLEr_CLR
#define IMP_TC_SEL_TABLEr_SET BCM89500_A0_IMP_TC_SEL_TABLEr_SET
#define IMP_TC_SEL_TABLEr_GET BCM89500_A0_IMP_TC_SEL_TABLEr_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_0f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_0f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_0f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_0f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_1f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_1f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_1f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_1f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_2f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_2f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_2f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_2f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_3f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_3f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_3f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_3f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_4f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_4f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_4f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_4f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_5f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_5f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_5f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_5f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_6f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_6f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_6f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_6f_SET
#define IMP_TC_SEL_TABLEr_TC_SEL_7f_GET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_7f_GET
#define IMP_TC_SEL_TABLEr_TC_SEL_7f_SET BCM89500_A0_IMP_TC_SEL_TABLEr_TC_SEL_7f_SET
#define READ_IMP_TC_SEL_TABLEr BCM89500_A0_READ_IMP_TC_SEL_TABLEr
#define WRITE_IMP_TC_SEL_TABLEr BCM89500_A0_WRITE_IMP_TC_SEL_TABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IMP_TC_SEL_TABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  INT_EN
 * BLOCKS:   SYS
 * DESC:     External Host Interrupt Enable Register
 * SIZE:     32
 * FIELDS:
 *     INT_EN           Interrupt Enable Register.To control individual interrupt enable bits for each interrupt type1 = enable0 = disableBit 31:25 - ReservedBit 24:16 - linkStatusChangeEnable[8:0].9 bit field indicating that the link status change interrupt is enableor not.-Bits 21-16 = port 5 - port 0-Bit 22 = Reserved-Bit 23 = port 7-Bit 24 = IMP port(port 8)Bits 15:9 - ReservedBit 8 - arbiter GNT interrupt1 bit field indicating arbiter grant interrupt is enable or not.Bits 7:6 - ReservedBit 5 - Phy interrupt enable  (not2release) Bit 4 - Time Sync(1588) interrupt enableBit 3 - Internal CPU to External Host Mailbox Doorbell InterruptBit 2 - Internal CPU to External Host Semaphore Interrupt1 bit field indicating internal CPU trigger an interrupt to externalCPU is enable or not.Bit 1:0 - impSleepTimerRunningEnable[1:0]2 bit field indicating that IMP sleep interrupt is enable or not.-Bit 1 = IMP1 Port (WAN / Port 5)-Bit 0 = IMP0 Port (Port 8)
 *
 ******************************************************************************/
#define BCM89500_A0_INT_ENr 0x00000308

#define BCM89500_A0_INT_ENr_SIZE 4

/*
 * This structure should be used to declare and program INT_EN.
 *
 */
typedef union BCM89500_A0_INT_ENr_s {
	uint32_t v[1];
	uint32_t int_en[1];
	uint32_t _int_en;
} BCM89500_A0_INT_ENr_t;

#define BCM89500_A0_INT_ENr_CLR(r) (r).int_en[0] = 0
#define BCM89500_A0_INT_ENr_SET(r,d) (r).int_en[0] = d
#define BCM89500_A0_INT_ENr_GET(r) (r).int_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_INT_ENr_INT_ENf_GET(r) ((r).int_en[0])
#define BCM89500_A0_INT_ENr_INT_ENf_SET(r,f) (r).int_en[0]=((uint32_t)f)

/*
 * These macros can be used to access INT_EN.
 *
 */
#define BCM89500_A0_READ_INT_ENr(u,r) cdk_robo_reg_read(u,BCM89500_A0_INT_ENr,(r._int_en),4)
#define BCM89500_A0_WRITE_INT_ENr(u,r) cdk_robo_reg_write(u,BCM89500_A0_INT_ENr,&(r._int_en),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_ENr BCM89500_A0_INT_ENr
#define INT_ENr_SIZE BCM89500_A0_INT_ENr_SIZE
typedef BCM89500_A0_INT_ENr_t INT_ENr_t;
#define INT_ENr_CLR BCM89500_A0_INT_ENr_CLR
#define INT_ENr_SET BCM89500_A0_INT_ENr_SET
#define INT_ENr_GET BCM89500_A0_INT_ENr_GET
#define INT_ENr_INT_ENf_GET BCM89500_A0_INT_ENr_INT_ENf_GET
#define INT_ENr_INT_ENf_SET BCM89500_A0_INT_ENr_INT_ENf_SET
#define READ_INT_ENr BCM89500_A0_READ_INT_ENr
#define WRITE_INT_ENr BCM89500_A0_WRITE_INT_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INT_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  INT_MASK
 * BLOCKS:   SYS
 * DESC:     Interrupt Mask Registers
 * SIZE:     16
 * FIELDS:
 *     INTC_FSYNC_MASK  Framesync timestamp interrupt status mask bit.  User needs to disablethe TS_CAPTURE register also.
 *     INTC_SOP_MASK    Packet timestamp interrupt status mask bit.  User needs to disablethe TX_CAP and RX_CAP registers also.
 *     SPARE_REG        Reserved
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_INT_MASKr 0x0000939c

#define BCM89500_A0_INT_MASKr_SIZE 2

/*
 * This structure should be used to declare and program INT_MASK.
 *
 */
typedef union BCM89500_A0_INT_MASKr_s {
	uint32_t v[1];
	uint32_t int_mask[1];
	uint32_t _int_mask;
} BCM89500_A0_INT_MASKr_t;

#define BCM89500_A0_INT_MASKr_CLR(r) (r).int_mask[0] = 0
#define BCM89500_A0_INT_MASKr_SET(r,d) (r).int_mask[0] = d
#define BCM89500_A0_INT_MASKr_GET(r) (r).int_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_INT_MASKr_INTC_FSYNC_MASKf_GET(r) (((r).int_mask[0]) & 0x1)
#define BCM89500_A0_INT_MASKr_INTC_FSYNC_MASKf_SET(r,f) (r).int_mask[0]=(((r).int_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_INT_MASKr_INTC_SOP_MASKf_GET(r) ((((r).int_mask[0]) >> 1) & 0xff)
#define BCM89500_A0_INT_MASKr_INTC_SOP_MASKf_SET(r,f) (r).int_mask[0]=(((r).int_mask[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM89500_A0_INT_MASKr_SPARE_REGf_GET(r) ((((r).int_mask[0]) >> 9) & 0x3)
#define BCM89500_A0_INT_MASKr_SPARE_REGf_SET(r,f) (r).int_mask[0]=(((r).int_mask[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_INT_MASKr_RESERVEDf_GET(r) ((((r).int_mask[0]) >> 11) & 0x1f)
#define BCM89500_A0_INT_MASKr_RESERVEDf_SET(r,f) (r).int_mask[0]=(((r).int_mask[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access INT_MASK.
 *
 */
#define BCM89500_A0_READ_INT_MASKr(u,r) cdk_robo_reg_read(u,BCM89500_A0_INT_MASKr,(r._int_mask),2)
#define BCM89500_A0_WRITE_INT_MASKr(u,r) cdk_robo_reg_write(u,BCM89500_A0_INT_MASKr,&(r._int_mask),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_MASKr BCM89500_A0_INT_MASKr
#define INT_MASKr_SIZE BCM89500_A0_INT_MASKr_SIZE
typedef BCM89500_A0_INT_MASKr_t INT_MASKr_t;
#define INT_MASKr_CLR BCM89500_A0_INT_MASKr_CLR
#define INT_MASKr_SET BCM89500_A0_INT_MASKr_SET
#define INT_MASKr_GET BCM89500_A0_INT_MASKr_GET
#define INT_MASKr_INTC_FSYNC_MASKf_GET BCM89500_A0_INT_MASKr_INTC_FSYNC_MASKf_GET
#define INT_MASKr_INTC_FSYNC_MASKf_SET BCM89500_A0_INT_MASKr_INTC_FSYNC_MASKf_SET
#define INT_MASKr_INTC_SOP_MASKf_GET BCM89500_A0_INT_MASKr_INTC_SOP_MASKf_GET
#define INT_MASKr_INTC_SOP_MASKf_SET BCM89500_A0_INT_MASKr_INTC_SOP_MASKf_SET
#define INT_MASKr_SPARE_REGf_GET BCM89500_A0_INT_MASKr_SPARE_REGf_GET
#define INT_MASKr_SPARE_REGf_SET BCM89500_A0_INT_MASKr_SPARE_REGf_SET
#define INT_MASKr_RESERVEDf_GET BCM89500_A0_INT_MASKr_RESERVEDf_GET
#define INT_MASKr_RESERVEDf_SET BCM89500_A0_INT_MASKr_RESERVEDf_SET
#define READ_INT_MASKr BCM89500_A0_READ_INT_MASKr
#define WRITE_INT_MASKr BCM89500_A0_WRITE_INT_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  INT_STAT
 * BLOCKS:   SYS
 * DESC:     Interrupt Status Registers
 * SIZE:     16
 * FIELDS:
 *     INTC_FSYNC       Framesync timestamp interrupt status. Clear on Read.
 *     INTC_SOP         Packet timestamp interrupt status. Clear on Read.
 *     INTC_RESERVED    Reserved
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_INT_STATr 0x0000939e

#define BCM89500_A0_INT_STATr_SIZE 2

/*
 * This structure should be used to declare and program INT_STAT.
 *
 */
typedef union BCM89500_A0_INT_STATr_s {
	uint32_t v[1];
	uint32_t int_stat[1];
	uint32_t _int_stat;
} BCM89500_A0_INT_STATr_t;

#define BCM89500_A0_INT_STATr_CLR(r) (r).int_stat[0] = 0
#define BCM89500_A0_INT_STATr_SET(r,d) (r).int_stat[0] = d
#define BCM89500_A0_INT_STATr_GET(r) (r).int_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_INT_STATr_INTC_FSYNCf_GET(r) (((r).int_stat[0]) & 0x1)
#define BCM89500_A0_INT_STATr_INTC_FSYNCf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_INT_STATr_INTC_SOPf_GET(r) ((((r).int_stat[0]) >> 1) & 0xff)
#define BCM89500_A0_INT_STATr_INTC_SOPf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM89500_A0_INT_STATr_INTC_RESERVEDf_GET(r) ((((r).int_stat[0]) >> 9) & 0x3)
#define BCM89500_A0_INT_STATr_INTC_RESERVEDf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM89500_A0_INT_STATr_RESERVEDf_GET(r) ((((r).int_stat[0]) >> 11) & 0x1f)
#define BCM89500_A0_INT_STATr_RESERVEDf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access INT_STAT.
 *
 */
#define BCM89500_A0_READ_INT_STATr(u,r) cdk_robo_reg_read(u,BCM89500_A0_INT_STATr,(r._int_stat),2)
#define BCM89500_A0_WRITE_INT_STATr(u,r) cdk_robo_reg_write(u,BCM89500_A0_INT_STATr,&(r._int_stat),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_STATr BCM89500_A0_INT_STATr
#define INT_STATr_SIZE BCM89500_A0_INT_STATr_SIZE
typedef BCM89500_A0_INT_STATr_t INT_STATr_t;
#define INT_STATr_CLR BCM89500_A0_INT_STATr_CLR
#define INT_STATr_SET BCM89500_A0_INT_STATr_SET
#define INT_STATr_GET BCM89500_A0_INT_STATr_GET
#define INT_STATr_INTC_FSYNCf_GET BCM89500_A0_INT_STATr_INTC_FSYNCf_GET
#define INT_STATr_INTC_FSYNCf_SET BCM89500_A0_INT_STATr_INTC_FSYNCf_SET
#define INT_STATr_INTC_SOPf_GET BCM89500_A0_INT_STATr_INTC_SOPf_GET
#define INT_STATr_INTC_SOPf_SET BCM89500_A0_INT_STATr_INTC_SOPf_SET
#define INT_STATr_INTC_RESERVEDf_GET BCM89500_A0_INT_STATr_INTC_RESERVEDf_GET
#define INT_STATr_INTC_RESERVEDf_SET BCM89500_A0_INT_STATr_INTC_RESERVEDf_SET
#define INT_STATr_RESERVEDf_GET BCM89500_A0_INT_STATr_RESERVEDf_GET
#define INT_STATr_RESERVEDf_SET BCM89500_A0_INT_STATr_RESERVEDf_SET
#define READ_INT_STATr BCM89500_A0_READ_INT_STATr
#define WRITE_INT_STATr BCM89500_A0_WRITE_INT_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INT_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  INT_STS
 * BLOCKS:   SYS
 * DESC:     External Host Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     INT_STS          Interrupt Status Register.Interrupt Status bits to indicate the cause of the interrupt.1= to indicate which interrupt is triggered.CPU write a "1" to the interrupt status register to reset the cause of the interrupt and reset the corresponding interrupt status bit.Bit 31:25 - ReservedBit 24:16 - linkStatusChangeInterrupt[8:0].9 bit field indicating that the its link status has changed.(enable by page: 0x03, Offset: 0x24-0x25linkStatusChangeInterrupt Enable registeror by page: 0x03, Offset: 0x28-0x29 Energy detectionInterrupt Enable register )-Bits 21-16 = port 5 - port 0-Bit 22 = Reserved-Bit 23 = port 7-Bit 24 = IMP port(port 8)Bits 15:9 - ReservedBit 8 - arbiter GNT interrupt1 bit field indicating resource arbiter grant interrupt when catchthe rising edge of the external CPU GNT signal.Bit 7:6 - ReservedBit 5 - Phy interrupt status (not2release) Bit 4 - Time Sync(1588) interruptBit 3 - Internal CPU to External Host Mailbox Doorbell InterruptBit 2 - Internal CPU to External Host Semaphore Interrupt1 bit field indicating internal CPU trigger an interrupt to externalCPU.Bit 1:0 - impSleepTimerRunningInterrupt[1:0]2 bit field indicating which of the timers has been triggered.-Bit 1 = IMP1 Port (WAN / Port 5)-Bit 0 = IMP0 Port (Port 8)
 *
 ******************************************************************************/
#define BCM89500_A0_INT_STSr 0x00000300

#define BCM89500_A0_INT_STSr_SIZE 4

/*
 * This structure should be used to declare and program INT_STS.
 *
 */
typedef union BCM89500_A0_INT_STSr_s {
	uint32_t v[1];
	uint32_t int_sts[1];
	uint32_t _int_sts;
} BCM89500_A0_INT_STSr_t;

#define BCM89500_A0_INT_STSr_CLR(r) (r).int_sts[0] = 0
#define BCM89500_A0_INT_STSr_SET(r,d) (r).int_sts[0] = d
#define BCM89500_A0_INT_STSr_GET(r) (r).int_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_INT_STSr_INT_STSf_GET(r) ((r).int_sts[0])
#define BCM89500_A0_INT_STSr_INT_STSf_SET(r,f) (r).int_sts[0]=((uint32_t)f)

/*
 * These macros can be used to access INT_STS.
 *
 */
#define BCM89500_A0_READ_INT_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_INT_STSr,(r._int_sts),4)
#define BCM89500_A0_WRITE_INT_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_INT_STSr,&(r._int_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_STSr BCM89500_A0_INT_STSr
#define INT_STSr_SIZE BCM89500_A0_INT_STSr_SIZE
typedef BCM89500_A0_INT_STSr_t INT_STSr_t;
#define INT_STSr_CLR BCM89500_A0_INT_STSr_CLR
#define INT_STSr_SET BCM89500_A0_INT_STSr_SET
#define INT_STSr_GET BCM89500_A0_INT_STSr_GET
#define INT_STSr_INT_STSf_GET BCM89500_A0_INT_STSr_INT_STSf_GET
#define INT_STSr_INT_STSf_SET BCM89500_A0_INT_STSr_INT_STSf_SET
#define READ_INT_STSr BCM89500_A0_READ_INT_STSr
#define WRITE_INT_STSr BCM89500_A0_WRITE_INT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  INT_TRIGGER
 * BLOCKS:   SYS
 * DESC:     Interrupt Trigger Register
 * SIZE:     8
 * FIELDS:
 *     EXT_CPU_INT      external-to-internal CPU Semaphore interrupt.When the bit is set to 1, external CPU trigger an interrupt tointernal CPU. Hardware self-clear.
 *     EXT_CPU_DOORBELL EXT CPU to INT CPU Mailbox doorbell interruptWhen the bit is set to 1, external CPU trigger an interrupt tointernal CPU for Mailbox doorbell. Hardware self-clear.
 *     INT_CPU_DOORBELL INT CPU to EXT CPU Mailbox doorbell interruptWhen the bit is set to 1, internal CPU trigger an interrupt toexternal CPU for Mailbox doorbell. Hardware self-clear.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_INT_TRIGGERr 0x00000320

#define BCM89500_A0_INT_TRIGGERr_SIZE 1

/*
 * This structure should be used to declare and program INT_TRIGGER.
 *
 */
typedef union BCM89500_A0_INT_TRIGGERr_s {
	uint32_t v[1];
	uint32_t int_trigger[1];
	uint32_t _int_trigger;
} BCM89500_A0_INT_TRIGGERr_t;

#define BCM89500_A0_INT_TRIGGERr_CLR(r) (r).int_trigger[0] = 0
#define BCM89500_A0_INT_TRIGGERr_SET(r,d) (r).int_trigger[0] = d
#define BCM89500_A0_INT_TRIGGERr_GET(r) (r).int_trigger[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_INT_TRIGGERr_EXT_CPU_INTf_GET(r) (((r).int_trigger[0]) & 0x1)
#define BCM89500_A0_INT_TRIGGERr_EXT_CPU_INTf_SET(r,f) (r).int_trigger[0]=(((r).int_trigger[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_INT_TRIGGERr_EXT_CPU_DOORBELLf_GET(r) ((((r).int_trigger[0]) >> 1) & 0x1)
#define BCM89500_A0_INT_TRIGGERr_EXT_CPU_DOORBELLf_SET(r,f) (r).int_trigger[0]=(((r).int_trigger[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_INT_TRIGGERr_INT_CPU_DOORBELLf_GET(r) ((((r).int_trigger[0]) >> 2) & 0x1)
#define BCM89500_A0_INT_TRIGGERr_INT_CPU_DOORBELLf_SET(r,f) (r).int_trigger[0]=(((r).int_trigger[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_INT_TRIGGERr_RESERVEDf_GET(r) ((((r).int_trigger[0]) >> 3) & 0x1fffffff)
#define BCM89500_A0_INT_TRIGGERr_RESERVEDf_SET(r,f) (r).int_trigger[0]=(((r).int_trigger[0] & ~((uint32_t)0x1fffffff << 3)) | ((((uint32_t)f) & 0x1fffffff) << 3))

/*
 * These macros can be used to access INT_TRIGGER.
 *
 */
#define BCM89500_A0_READ_INT_TRIGGERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_INT_TRIGGERr,(r._int_trigger),1)
#define BCM89500_A0_WRITE_INT_TRIGGERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_INT_TRIGGERr,&(r._int_trigger),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INT_TRIGGERr BCM89500_A0_INT_TRIGGERr
#define INT_TRIGGERr_SIZE BCM89500_A0_INT_TRIGGERr_SIZE
typedef BCM89500_A0_INT_TRIGGERr_t INT_TRIGGERr_t;
#define INT_TRIGGERr_CLR BCM89500_A0_INT_TRIGGERr_CLR
#define INT_TRIGGERr_SET BCM89500_A0_INT_TRIGGERr_SET
#define INT_TRIGGERr_GET BCM89500_A0_INT_TRIGGERr_GET
#define INT_TRIGGERr_EXT_CPU_INTf_GET BCM89500_A0_INT_TRIGGERr_EXT_CPU_INTf_GET
#define INT_TRIGGERr_EXT_CPU_INTf_SET BCM89500_A0_INT_TRIGGERr_EXT_CPU_INTf_SET
#define INT_TRIGGERr_EXT_CPU_DOORBELLf_GET BCM89500_A0_INT_TRIGGERr_EXT_CPU_DOORBELLf_GET
#define INT_TRIGGERr_EXT_CPU_DOORBELLf_SET BCM89500_A0_INT_TRIGGERr_EXT_CPU_DOORBELLf_SET
#define INT_TRIGGERr_INT_CPU_DOORBELLf_GET BCM89500_A0_INT_TRIGGERr_INT_CPU_DOORBELLf_GET
#define INT_TRIGGERr_INT_CPU_DOORBELLf_SET BCM89500_A0_INT_TRIGGERr_INT_CPU_DOORBELLf_SET
#define INT_TRIGGERr_RESERVEDf_GET BCM89500_A0_INT_TRIGGERr_RESERVEDf_GET
#define INT_TRIGGERr_RESERVEDf_SET BCM89500_A0_INT_TRIGGERr_RESERVEDf_SET
#define READ_INT_TRIGGERr BCM89500_A0_READ_INT_TRIGGERr
#define WRITE_INT_TRIGGERr BCM89500_A0_WRITE_INT_TRIGGERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INT_TRIGGERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IO_DS_SEL0
 * BLOCKS:   SYS
 * DESC:     I/O Pad Drive Strength Select 0 Register (Engineering use only) (polar feature)
 * SIZE:     32
 * FIELDS:
 *     IO_DS_SEL0       Bit 18: rs232_txdBit 17: rs232_rxdBit 16: fclkBit 15: fsiBit 14: fcsbBit 13: fsoBit 12: leddataBit 11: ledclkBit 10: mdcBit 9: mdioBit 8: misoBit 7: ssBit 6: mosiBit 5: sckBit 4: intr_bBit 3: sync_outBit 2: sync_inBit 1: sclBit 0: sda(default 1 for 8mA)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IO_DS_SEL0r 0x0000e024

#define BCM89500_A0_IO_DS_SEL0r_SIZE 4

/*
 * This structure should be used to declare and program IO_DS_SEL0.
 *
 */
typedef union BCM89500_A0_IO_DS_SEL0r_s {
	uint32_t v[1];
	uint32_t io_ds_sel0[1];
	uint32_t _io_ds_sel0;
} BCM89500_A0_IO_DS_SEL0r_t;

#define BCM89500_A0_IO_DS_SEL0r_CLR(r) (r).io_ds_sel0[0] = 0
#define BCM89500_A0_IO_DS_SEL0r_SET(r,d) (r).io_ds_sel0[0] = d
#define BCM89500_A0_IO_DS_SEL0r_GET(r) (r).io_ds_sel0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IO_DS_SEL0r_IO_DS_SEL0f_GET(r) (((r).io_ds_sel0[0]) & 0x7ffff)
#define BCM89500_A0_IO_DS_SEL0r_IO_DS_SEL0f_SET(r,f) (r).io_ds_sel0[0]=(((r).io_ds_sel0[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))
#define BCM89500_A0_IO_DS_SEL0r_RESERVEDf_GET(r) ((((r).io_ds_sel0[0]) >> 19) & 0x1fff)
#define BCM89500_A0_IO_DS_SEL0r_RESERVEDf_SET(r,f) (r).io_ds_sel0[0]=(((r).io_ds_sel0[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access IO_DS_SEL0.
 *
 */
#define BCM89500_A0_READ_IO_DS_SEL0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_IO_DS_SEL0r,(r._io_ds_sel0),4)
#define BCM89500_A0_WRITE_IO_DS_SEL0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_IO_DS_SEL0r,&(r._io_ds_sel0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IO_DS_SEL0r BCM89500_A0_IO_DS_SEL0r
#define IO_DS_SEL0r_SIZE BCM89500_A0_IO_DS_SEL0r_SIZE
typedef BCM89500_A0_IO_DS_SEL0r_t IO_DS_SEL0r_t;
#define IO_DS_SEL0r_CLR BCM89500_A0_IO_DS_SEL0r_CLR
#define IO_DS_SEL0r_SET BCM89500_A0_IO_DS_SEL0r_SET
#define IO_DS_SEL0r_GET BCM89500_A0_IO_DS_SEL0r_GET
#define IO_DS_SEL0r_IO_DS_SEL0f_GET BCM89500_A0_IO_DS_SEL0r_IO_DS_SEL0f_GET
#define IO_DS_SEL0r_IO_DS_SEL0f_SET BCM89500_A0_IO_DS_SEL0r_IO_DS_SEL0f_SET
#define IO_DS_SEL0r_RESERVEDf_GET BCM89500_A0_IO_DS_SEL0r_RESERVEDf_GET
#define IO_DS_SEL0r_RESERVEDf_SET BCM89500_A0_IO_DS_SEL0r_RESERVEDf_SET
#define READ_IO_DS_SEL0r BCM89500_A0_READ_IO_DS_SEL0r
#define WRITE_IO_DS_SEL0r BCM89500_A0_WRITE_IO_DS_SEL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IO_DS_SEL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IO_DS_SEL2
 * BLOCKS:   SYS
 * DESC:     I/O Pad Drive Strength Select 2 Register (Engineering use only) (polar feature)
 * SIZE:     32
 * FIELDS:
 *     IO_DS_SEL2       (sel0,sel2)= (1,0) : 2mA, (sel0,sel2)= (0,0) : 4mA, (sel0,sel2)= (0,1) : 6mA, (sel0,sel2)= (1,1) : 8mABit 18: rs232_txdBit 17: rs232_rxdBit 16: fclkBit 15: fsiBit 14: fcsbBit 13: fsoBit 12: leddataBit 11: ledclkBit 10: mdcBit 9: mdioBit 8: misoBit 7: ssBit 6: mosiBit 5: sckBit 4: intr_bBit 3: sync_outBit 2: sync_inBit 1: sclBit 0: sda(default 1 for 8mA)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IO_DS_SEL2r 0x0000e02c

#define BCM89500_A0_IO_DS_SEL2r_SIZE 4

/*
 * This structure should be used to declare and program IO_DS_SEL2.
 *
 */
typedef union BCM89500_A0_IO_DS_SEL2r_s {
	uint32_t v[1];
	uint32_t io_ds_sel2[1];
	uint32_t _io_ds_sel2;
} BCM89500_A0_IO_DS_SEL2r_t;

#define BCM89500_A0_IO_DS_SEL2r_CLR(r) (r).io_ds_sel2[0] = 0
#define BCM89500_A0_IO_DS_SEL2r_SET(r,d) (r).io_ds_sel2[0] = d
#define BCM89500_A0_IO_DS_SEL2r_GET(r) (r).io_ds_sel2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IO_DS_SEL2r_IO_DS_SEL2f_GET(r) (((r).io_ds_sel2[0]) & 0x7ffff)
#define BCM89500_A0_IO_DS_SEL2r_IO_DS_SEL2f_SET(r,f) (r).io_ds_sel2[0]=(((r).io_ds_sel2[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))
#define BCM89500_A0_IO_DS_SEL2r_RESERVEDf_GET(r) ((((r).io_ds_sel2[0]) >> 19) & 0x1fff)
#define BCM89500_A0_IO_DS_SEL2r_RESERVEDf_SET(r,f) (r).io_ds_sel2[0]=(((r).io_ds_sel2[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access IO_DS_SEL2.
 *
 */
#define BCM89500_A0_READ_IO_DS_SEL2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_IO_DS_SEL2r,(r._io_ds_sel2),4)
#define BCM89500_A0_WRITE_IO_DS_SEL2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_IO_DS_SEL2r,&(r._io_ds_sel2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IO_DS_SEL2r BCM89500_A0_IO_DS_SEL2r
#define IO_DS_SEL2r_SIZE BCM89500_A0_IO_DS_SEL2r_SIZE
typedef BCM89500_A0_IO_DS_SEL2r_t IO_DS_SEL2r_t;
#define IO_DS_SEL2r_CLR BCM89500_A0_IO_DS_SEL2r_CLR
#define IO_DS_SEL2r_SET BCM89500_A0_IO_DS_SEL2r_SET
#define IO_DS_SEL2r_GET BCM89500_A0_IO_DS_SEL2r_GET
#define IO_DS_SEL2r_IO_DS_SEL2f_GET BCM89500_A0_IO_DS_SEL2r_IO_DS_SEL2f_GET
#define IO_DS_SEL2r_IO_DS_SEL2f_SET BCM89500_A0_IO_DS_SEL2r_IO_DS_SEL2f_SET
#define IO_DS_SEL2r_RESERVEDf_GET BCM89500_A0_IO_DS_SEL2r_RESERVEDf_GET
#define IO_DS_SEL2r_RESERVEDf_SET BCM89500_A0_IO_DS_SEL2r_RESERVEDf_SET
#define READ_IO_DS_SEL2r BCM89500_A0_READ_IO_DS_SEL2r
#define WRITE_IO_DS_SEL2r BCM89500_A0_WRITE_IO_DS_SEL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IO_DS_SEL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IO_SR_CTL
 * BLOCKS:   SYS
 * DESC:     I/O Pad Slew Rate Control Register (Engineering use only) (polar feature)
 * SIZE:     32
 * FIELDS:
 *     IO_SR_CTL        1'b1: Normal; 1'b0: High speedBit 18: rs232_txdBit 17: rs232_rxdBit 16: fclkBit 15: fsiBit 14: fcsbBit 13: fsoBit 12: leddataBit 11: ledclkBit 10: mdcBit 9: mdioBit 8: misoBit 7: ssBit 6: mosiBit 5: sckBit 4: intr_bBit 3: sync_outBit 2: sync_inBit 1: sclBit 0: sda(default 0 for high speed)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IO_SR_CTLr 0x0000e020

#define BCM89500_A0_IO_SR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program IO_SR_CTL.
 *
 */
typedef union BCM89500_A0_IO_SR_CTLr_s {
	uint32_t v[1];
	uint32_t io_sr_ctl[1];
	uint32_t _io_sr_ctl;
} BCM89500_A0_IO_SR_CTLr_t;

#define BCM89500_A0_IO_SR_CTLr_CLR(r) (r).io_sr_ctl[0] = 0
#define BCM89500_A0_IO_SR_CTLr_SET(r,d) (r).io_sr_ctl[0] = d
#define BCM89500_A0_IO_SR_CTLr_GET(r) (r).io_sr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IO_SR_CTLr_IO_SR_CTLf_GET(r) (((r).io_sr_ctl[0]) & 0x7ffff)
#define BCM89500_A0_IO_SR_CTLr_IO_SR_CTLf_SET(r,f) (r).io_sr_ctl[0]=(((r).io_sr_ctl[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))
#define BCM89500_A0_IO_SR_CTLr_RESERVEDf_GET(r) ((((r).io_sr_ctl[0]) >> 19) & 0x1fff)
#define BCM89500_A0_IO_SR_CTLr_RESERVEDf_SET(r,f) (r).io_sr_ctl[0]=(((r).io_sr_ctl[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access IO_SR_CTL.
 *
 */
#define BCM89500_A0_READ_IO_SR_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IO_SR_CTLr,(r._io_sr_ctl),4)
#define BCM89500_A0_WRITE_IO_SR_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IO_SR_CTLr,&(r._io_sr_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IO_SR_CTLr BCM89500_A0_IO_SR_CTLr
#define IO_SR_CTLr_SIZE BCM89500_A0_IO_SR_CTLr_SIZE
typedef BCM89500_A0_IO_SR_CTLr_t IO_SR_CTLr_t;
#define IO_SR_CTLr_CLR BCM89500_A0_IO_SR_CTLr_CLR
#define IO_SR_CTLr_SET BCM89500_A0_IO_SR_CTLr_SET
#define IO_SR_CTLr_GET BCM89500_A0_IO_SR_CTLr_GET
#define IO_SR_CTLr_IO_SR_CTLf_GET BCM89500_A0_IO_SR_CTLr_IO_SR_CTLf_GET
#define IO_SR_CTLr_IO_SR_CTLf_SET BCM89500_A0_IO_SR_CTLr_IO_SR_CTLf_SET
#define IO_SR_CTLr_RESERVEDf_GET BCM89500_A0_IO_SR_CTLr_RESERVEDf_GET
#define IO_SR_CTLr_RESERVEDf_SET BCM89500_A0_IO_SR_CTLr_RESERVEDf_SET
#define READ_IO_SR_CTLr BCM89500_A0_READ_IO_SR_CTLr
#define WRITE_IO_SR_CTLr BCM89500_A0_WRITE_IO_SR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IO_SR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  IPG_SHRNK_CTRL
 * BLOCKS:   SYS
 * DESC:     IPG Shrink Control Register
 * SIZE:     32
 * FIELDS:
 *     IPG_SHKCTRL      IPG Shrink ControlThis field specifies the IPG for each port.IPG shrinking at Egress.00: No IPG shrinking(default)01: IPG shrinking of 1-byte10: IPG shrinking of 4-byte11: IPG shrinking of 5-bytebit[17:16] = Port 8(IMP port)bit[15:14] = Port 7bit[13:12] = Reservedbit[11:0] = Port 5 ~ Port 0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_IPG_SHRNK_CTRLr 0x0000020c

#define BCM89500_A0_IPG_SHRNK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program IPG_SHRNK_CTRL.
 *
 */
typedef union BCM89500_A0_IPG_SHRNK_CTRLr_s {
	uint32_t v[1];
	uint32_t ipg_shrnk_ctrl[1];
	uint32_t _ipg_shrnk_ctrl;
} BCM89500_A0_IPG_SHRNK_CTRLr_t;

#define BCM89500_A0_IPG_SHRNK_CTRLr_CLR(r) (r).ipg_shrnk_ctrl[0] = 0
#define BCM89500_A0_IPG_SHRNK_CTRLr_SET(r,d) (r).ipg_shrnk_ctrl[0] = d
#define BCM89500_A0_IPG_SHRNK_CTRLr_GET(r) (r).ipg_shrnk_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET(r) (((r).ipg_shrnk_ctrl[0]) & 0x3ffff)
#define BCM89500_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_IPG_SHRNK_CTRLr_RESERVEDf_GET(r) ((((r).ipg_shrnk_ctrl[0]) >> 18) & 0x3fff)
#define BCM89500_A0_IPG_SHRNK_CTRLr_RESERVEDf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IPG_SHRNK_CTRL.
 *
 */
#define BCM89500_A0_READ_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_IPG_SHRNK_CTRLr,(r._ipg_shrnk_ctrl),4)
#define BCM89500_A0_WRITE_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_IPG_SHRNK_CTRLr,&(r._ipg_shrnk_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPG_SHRNK_CTRLr BCM89500_A0_IPG_SHRNK_CTRLr
#define IPG_SHRNK_CTRLr_SIZE BCM89500_A0_IPG_SHRNK_CTRLr_SIZE
typedef BCM89500_A0_IPG_SHRNK_CTRLr_t IPG_SHRNK_CTRLr_t;
#define IPG_SHRNK_CTRLr_CLR BCM89500_A0_IPG_SHRNK_CTRLr_CLR
#define IPG_SHRNK_CTRLr_SET BCM89500_A0_IPG_SHRNK_CTRLr_SET
#define IPG_SHRNK_CTRLr_GET BCM89500_A0_IPG_SHRNK_CTRLr_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET BCM89500_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET BCM89500_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET
#define IPG_SHRNK_CTRLr_RESERVEDf_GET BCM89500_A0_IPG_SHRNK_CTRLr_RESERVEDf_GET
#define IPG_SHRNK_CTRLr_RESERVEDf_SET BCM89500_A0_IPG_SHRNK_CTRLr_RESERVEDf_SET
#define READ_IPG_SHRNK_CTRLr BCM89500_A0_READ_IPG_SHRNK_CTRLr
#define WRITE_IPG_SHRNK_CTRLr BCM89500_A0_WRITE_IPG_SHRNK_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_IPG_SHRNK_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ISP_SEL_PORTMAP
 * BLOCKS:   SYS
 * DESC:     ISP Port Selection Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_PORTMAP      Bittmap to define which port as ISP-port.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ISP_SEL_PORTMAPr 0x00003432

#define BCM89500_A0_ISP_SEL_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program ISP_SEL_PORTMAP.
 *
 */
typedef union BCM89500_A0_ISP_SEL_PORTMAPr_s {
	uint32_t v[1];
	uint32_t isp_sel_portmap[1];
	uint32_t _isp_sel_portmap;
} BCM89500_A0_ISP_SEL_PORTMAPr_t;

#define BCM89500_A0_ISP_SEL_PORTMAPr_CLR(r) (r).isp_sel_portmap[0] = 0
#define BCM89500_A0_ISP_SEL_PORTMAPr_SET(r,d) (r).isp_sel_portmap[0] = d
#define BCM89500_A0_ISP_SEL_PORTMAPr_GET(r) (r).isp_sel_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET(r) (((r).isp_sel_portmap[0]) & 0x1ff)
#define BCM89500_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET(r) ((((r).isp_sel_portmap[0]) >> 9) & 0x7f)
#define BCM89500_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ISP_SEL_PORTMAP.
 *
 */
#define BCM89500_A0_READ_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ISP_SEL_PORTMAPr,(r._isp_sel_portmap),2)
#define BCM89500_A0_WRITE_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ISP_SEL_PORTMAPr,&(r._isp_sel_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_SEL_PORTMAPr BCM89500_A0_ISP_SEL_PORTMAPr
#define ISP_SEL_PORTMAPr_SIZE BCM89500_A0_ISP_SEL_PORTMAPr_SIZE
typedef BCM89500_A0_ISP_SEL_PORTMAPr_t ISP_SEL_PORTMAPr_t;
#define ISP_SEL_PORTMAPr_CLR BCM89500_A0_ISP_SEL_PORTMAPr_CLR
#define ISP_SEL_PORTMAPr_SET BCM89500_A0_ISP_SEL_PORTMAPr_SET
#define ISP_SEL_PORTMAPr_GET BCM89500_A0_ISP_SEL_PORTMAPr_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET BCM89500_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET BCM89500_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET
#define ISP_SEL_PORTMAPr_RESERVEDf_GET BCM89500_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET
#define ISP_SEL_PORTMAPr_RESERVEDf_SET BCM89500_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET
#define READ_ISP_SEL_PORTMAPr BCM89500_A0_READ_ISP_SEL_PORTMAPr
#define WRITE_ISP_SEL_PORTMAPr BCM89500_A0_WRITE_ISP_SEL_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ISP_SEL_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  InRangeErrCount
 * BLOCKS:   GPIC0 CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_INRANGEERRCOUNTr 0x000020b0

#define BCM89500_A0_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount.
 *
 */
typedef union BCM89500_A0_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount[1];
	uint32_t _inrangeerrcount;
} BCM89500_A0_INRANGEERRCOUNTr_t;

#define BCM89500_A0_INRANGEERRCOUNTr_CLR(r) (r).inrangeerrcount[0] = 0
#define BCM89500_A0_INRANGEERRCOUNTr_SET(r,d) (r).inrangeerrcount[0] = d
#define BCM89500_A0_INRANGEERRCOUNTr_GET(r) (r).inrangeerrcount[0]


/*
 * These macros can be used to access InRangeErrCount.
 *
 */
#define BCM89500_A0_READ_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_INRANGEERRCOUNTr,(r._inrangeerrcount),4)
#define BCM89500_A0_WRITE_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_INRANGEERRCOUNTr,&(r._inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNTr BCM89500_A0_INRANGEERRCOUNTr
#define INRANGEERRCOUNTr_SIZE BCM89500_A0_INRANGEERRCOUNTr_SIZE
typedef BCM89500_A0_INRANGEERRCOUNTr_t INRANGEERRCOUNTr_t;
#define INRANGEERRCOUNTr_CLR BCM89500_A0_INRANGEERRCOUNTr_CLR
#define INRANGEERRCOUNTr_SET BCM89500_A0_INRANGEERRCOUNTr_SET
#define INRANGEERRCOUNTr_GET BCM89500_A0_INRANGEERRCOUNTr_GET
#define READ_INRANGEERRCOUNTr BCM89500_A0_READ_INRANGEERRCOUNTr
#define WRITE_INRANGEERRCOUNTr BCM89500_A0_WRITE_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  InRangeErrCount_IMP
 * BLOCKS:   CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_INRANGEERRCOUNT_IMPr 0x000028b0

#define BCM89500_A0_INRANGEERRCOUNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount_IMP.
 *
 */
typedef union BCM89500_A0_INRANGEERRCOUNT_IMPr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount_imp[1];
	uint32_t _inrangeerrcount_imp;
} BCM89500_A0_INRANGEERRCOUNT_IMPr_t;

#define BCM89500_A0_INRANGEERRCOUNT_IMPr_CLR(r) (r).inrangeerrcount_imp[0] = 0
#define BCM89500_A0_INRANGEERRCOUNT_IMPr_SET(r,d) (r).inrangeerrcount_imp[0] = d
#define BCM89500_A0_INRANGEERRCOUNT_IMPr_GET(r) (r).inrangeerrcount_imp[0]


/*
 * These macros can be used to access InRangeErrCount_IMP.
 *
 */
#define BCM89500_A0_READ_INRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_INRANGEERRCOUNT_IMPr,(r._inrangeerrcount_imp),4)
#define BCM89500_A0_WRITE_INRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_INRANGEERRCOUNT_IMPr,&(r._inrangeerrcount_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNT_IMPr BCM89500_A0_INRANGEERRCOUNT_IMPr
#define INRANGEERRCOUNT_IMPr_SIZE BCM89500_A0_INRANGEERRCOUNT_IMPr_SIZE
typedef BCM89500_A0_INRANGEERRCOUNT_IMPr_t INRANGEERRCOUNT_IMPr_t;
#define INRANGEERRCOUNT_IMPr_CLR BCM89500_A0_INRANGEERRCOUNT_IMPr_CLR
#define INRANGEERRCOUNT_IMPr_SET BCM89500_A0_INRANGEERRCOUNT_IMPr_SET
#define INRANGEERRCOUNT_IMPr_GET BCM89500_A0_INRANGEERRCOUNT_IMPr_GET
#define READ_INRANGEERRCOUNT_IMPr BCM89500_A0_READ_INRANGEERRCOUNT_IMPr
#define WRITE_INRANGEERRCOUNT_IMPr BCM89500_A0_WRITE_INRANGEERRCOUNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INRANGEERRCOUNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  InRangeErrCount_P7
 * BLOCKS:   GPIC7
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_INRANGEERRCOUNT_P7r 0x000027b0

#define BCM89500_A0_INRANGEERRCOUNT_P7r_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount_P7.
 *
 */
typedef union BCM89500_A0_INRANGEERRCOUNT_P7r_s {
	uint32_t v[1];
	uint32_t inrangeerrcount_p7[1];
	uint32_t _inrangeerrcount_p7;
} BCM89500_A0_INRANGEERRCOUNT_P7r_t;

#define BCM89500_A0_INRANGEERRCOUNT_P7r_CLR(r) (r).inrangeerrcount_p7[0] = 0
#define BCM89500_A0_INRANGEERRCOUNT_P7r_SET(r,d) (r).inrangeerrcount_p7[0] = d
#define BCM89500_A0_INRANGEERRCOUNT_P7r_GET(r) (r).inrangeerrcount_p7[0]


/*
 * These macros can be used to access InRangeErrCount_P7.
 *
 */
#define BCM89500_A0_READ_INRANGEERRCOUNT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_INRANGEERRCOUNT_P7r,(r._inrangeerrcount_p7),4)
#define BCM89500_A0_WRITE_INRANGEERRCOUNT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_INRANGEERRCOUNT_P7r,&(r._inrangeerrcount_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNT_P7r BCM89500_A0_INRANGEERRCOUNT_P7r
#define INRANGEERRCOUNT_P7r_SIZE BCM89500_A0_INRANGEERRCOUNT_P7r_SIZE
typedef BCM89500_A0_INRANGEERRCOUNT_P7r_t INRANGEERRCOUNT_P7r_t;
#define INRANGEERRCOUNT_P7r_CLR BCM89500_A0_INRANGEERRCOUNT_P7r_CLR
#define INRANGEERRCOUNT_P7r_SET BCM89500_A0_INRANGEERRCOUNT_P7r_SET
#define INRANGEERRCOUNT_P7r_GET BCM89500_A0_INRANGEERRCOUNT_P7r_GET
#define READ_INRANGEERRCOUNT_P7r BCM89500_A0_READ_INRANGEERRCOUNT_P7r
#define WRITE_INRANGEERRCOUNT_P7r BCM89500_A0_WRITE_INRANGEERRCOUNT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_INRANGEERRCOUNT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  JUMBO_PORT_MASK
 * BLOCKS:   SYS
 * DESC:     Jumbo Frame Port Mask Registers
 * SIZE:     32
 * FIELDS:
 *     JUMBO_FM_PORT_MASK Jumbo Frame Port Mask.Ports defined in the Jumbo Frame Port Mask Register can Receive/Transmit Jumbo Frame ( Frame Size over the bytes defined in "Standard Max. Frame Size" register and less than 9720B).Bit7:0 = Port 7-0 in chip 0.0 : Disable Jumbo Frame Capability,1 : Enable Jumbo Frame Capability,Jumbo Frames can be allowed to be delivered among these Ports. Non-Jumbo Frame will not be constrained by the register. It is recommended that no more than two ports be enabled simultaneously to ensure system performance.
 *     RESERVED_0       Reserved
 *     EN_10_100_JUMBO  Enable 10/100 Port can receive and transmit jumbo frame Only Giga Port can #receive jumbo frame as default.(Not2Release)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_JUMBO_PORT_MASKr 0x00004001

#define BCM89500_A0_JUMBO_PORT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program JUMBO_PORT_MASK.
 *
 */
typedef union BCM89500_A0_JUMBO_PORT_MASKr_s {
	uint32_t v[1];
	uint32_t jumbo_port_mask[1];
	uint32_t _jumbo_port_mask;
} BCM89500_A0_JUMBO_PORT_MASKr_t;

#define BCM89500_A0_JUMBO_PORT_MASKr_CLR(r) (r).jumbo_port_mask[0] = 0
#define BCM89500_A0_JUMBO_PORT_MASKr_SET(r,d) (r).jumbo_port_mask[0] = d
#define BCM89500_A0_JUMBO_PORT_MASKr_GET(r) (r).jumbo_port_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET(r) (((r).jumbo_port_mask[0]) & 0x1ff)
#define BCM89500_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_0f_GET(r) ((((r).jumbo_port_mask[0]) >> 9) & 0x7fff)
#define BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_0f_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7fff << 9)) | ((((uint32_t)f) & 0x7fff) << 9))
#define BCM89500_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET(r) ((((r).jumbo_port_mask[0]) >> 24) & 0x1)
#define BCM89500_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_1f_GET(r) ((((r).jumbo_port_mask[0]) >> 25) & 0x7f)
#define BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_1f_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access JUMBO_PORT_MASK.
 *
 */
#define BCM89500_A0_READ_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_read(u,BCM89500_A0_JUMBO_PORT_MASKr,(r._jumbo_port_mask),4)
#define BCM89500_A0_WRITE_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_write(u,BCM89500_A0_JUMBO_PORT_MASKr,&(r._jumbo_port_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBO_PORT_MASKr BCM89500_A0_JUMBO_PORT_MASKr
#define JUMBO_PORT_MASKr_SIZE BCM89500_A0_JUMBO_PORT_MASKr_SIZE
typedef BCM89500_A0_JUMBO_PORT_MASKr_t JUMBO_PORT_MASKr_t;
#define JUMBO_PORT_MASKr_CLR BCM89500_A0_JUMBO_PORT_MASKr_CLR
#define JUMBO_PORT_MASKr_SET BCM89500_A0_JUMBO_PORT_MASKr_SET
#define JUMBO_PORT_MASKr_GET BCM89500_A0_JUMBO_PORT_MASKr_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET BCM89500_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET BCM89500_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET
#define JUMBO_PORT_MASKr_RESERVED_0f_GET BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_0f_GET
#define JUMBO_PORT_MASKr_RESERVED_0f_SET BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_0f_SET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET BCM89500_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET BCM89500_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET
#define JUMBO_PORT_MASKr_RESERVED_1f_GET BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_1f_GET
#define JUMBO_PORT_MASKr_RESERVED_1f_SET BCM89500_A0_JUMBO_PORT_MASKr_RESERVED_1f_SET
#define READ_JUMBO_PORT_MASKr BCM89500_A0_READ_JUMBO_PORT_MASKr
#define WRITE_JUMBO_PORT_MASKr BCM89500_A0_WRITE_JUMBO_PORT_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_JUMBO_PORT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  JumboPkt
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_JUMBOPKTr 0x000020a8

#define BCM89500_A0_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt.
 *
 */
typedef union BCM89500_A0_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t jumbopkt[1];
	uint32_t _jumbopkt;
} BCM89500_A0_JUMBOPKTr_t;

#define BCM89500_A0_JUMBOPKTr_CLR(r) (r).jumbopkt[0] = 0
#define BCM89500_A0_JUMBOPKTr_SET(r,d) (r).jumbopkt[0] = d
#define BCM89500_A0_JUMBOPKTr_GET(r) (r).jumbopkt[0]


/*
 * These macros can be used to access JumboPkt.
 *
 */
#define BCM89500_A0_READ_JUMBOPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_JUMBOPKTr,(r._jumbopkt),4)
#define BCM89500_A0_WRITE_JUMBOPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_JUMBOPKTr,&(r._jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKTr BCM89500_A0_JUMBOPKTr
#define JUMBOPKTr_SIZE BCM89500_A0_JUMBOPKTr_SIZE
typedef BCM89500_A0_JUMBOPKTr_t JUMBOPKTr_t;
#define JUMBOPKTr_CLR BCM89500_A0_JUMBOPKTr_CLR
#define JUMBOPKTr_SET BCM89500_A0_JUMBOPKTr_SET
#define JUMBOPKTr_GET BCM89500_A0_JUMBOPKTr_GET
#define READ_JUMBOPKTr BCM89500_A0_READ_JUMBOPKTr
#define WRITE_JUMBOPKTr BCM89500_A0_WRITE_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  JumboPkt_IMP
 * BLOCKS:   CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_JUMBOPKT_IMPr 0x000028a8

#define BCM89500_A0_JUMBOPKT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt_IMP.
 *
 */
typedef union BCM89500_A0_JUMBOPKT_IMPr_s {
	uint32_t v[1];
	uint32_t jumbopkt_imp[1];
	uint32_t _jumbopkt_imp;
} BCM89500_A0_JUMBOPKT_IMPr_t;

#define BCM89500_A0_JUMBOPKT_IMPr_CLR(r) (r).jumbopkt_imp[0] = 0
#define BCM89500_A0_JUMBOPKT_IMPr_SET(r,d) (r).jumbopkt_imp[0] = d
#define BCM89500_A0_JUMBOPKT_IMPr_GET(r) (r).jumbopkt_imp[0]


/*
 * These macros can be used to access JumboPkt_IMP.
 *
 */
#define BCM89500_A0_READ_JUMBOPKT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_JUMBOPKT_IMPr,(r._jumbopkt_imp),4)
#define BCM89500_A0_WRITE_JUMBOPKT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_JUMBOPKT_IMPr,&(r._jumbopkt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKT_IMPr BCM89500_A0_JUMBOPKT_IMPr
#define JUMBOPKT_IMPr_SIZE BCM89500_A0_JUMBOPKT_IMPr_SIZE
typedef BCM89500_A0_JUMBOPKT_IMPr_t JUMBOPKT_IMPr_t;
#define JUMBOPKT_IMPr_CLR BCM89500_A0_JUMBOPKT_IMPr_CLR
#define JUMBOPKT_IMPr_SET BCM89500_A0_JUMBOPKT_IMPr_SET
#define JUMBOPKT_IMPr_GET BCM89500_A0_JUMBOPKT_IMPr_GET
#define READ_JUMBOPKT_IMPr BCM89500_A0_READ_JUMBOPKT_IMPr
#define WRITE_JUMBOPKT_IMPr BCM89500_A0_WRITE_JUMBOPKT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_JUMBOPKT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  JumboPkt_P7
 * BLOCKS:   GPIC7
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_JUMBOPKT_P7r 0x000027a8

#define BCM89500_A0_JUMBOPKT_P7r_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt_P7.
 *
 */
typedef union BCM89500_A0_JUMBOPKT_P7r_s {
	uint32_t v[1];
	uint32_t jumbopkt_p7[1];
	uint32_t _jumbopkt_p7;
} BCM89500_A0_JUMBOPKT_P7r_t;

#define BCM89500_A0_JUMBOPKT_P7r_CLR(r) (r).jumbopkt_p7[0] = 0
#define BCM89500_A0_JUMBOPKT_P7r_SET(r,d) (r).jumbopkt_p7[0] = d
#define BCM89500_A0_JUMBOPKT_P7r_GET(r) (r).jumbopkt_p7[0]


/*
 * These macros can be used to access JumboPkt_P7.
 *
 */
#define BCM89500_A0_READ_JUMBOPKT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_JUMBOPKT_P7r,(r._jumbopkt_p7),4)
#define BCM89500_A0_WRITE_JUMBOPKT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_JUMBOPKT_P7r,&(r._jumbopkt_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKT_P7r BCM89500_A0_JUMBOPKT_P7r
#define JUMBOPKT_P7r_SIZE BCM89500_A0_JUMBOPKT_P7r_SIZE
typedef BCM89500_A0_JUMBOPKT_P7r_t JUMBOPKT_P7r_t;
#define JUMBOPKT_P7r_CLR BCM89500_A0_JUMBOPKT_P7r_CLR
#define JUMBOPKT_P7r_SET BCM89500_A0_JUMBOPKT_P7r_SET
#define JUMBOPKT_P7r_GET BCM89500_A0_JUMBOPKT_P7r_GET
#define READ_JUMBOPKT_P7r BCM89500_A0_READ_JUMBOPKT_P7r
#define WRITE_JUMBOPKT_P7r BCM89500_A0_WRITE_JUMBOPKT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_JUMBOPKT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     65
 * FIELDS:
 *     MACADDR_47_12    Source Address[47:12]
 *     VID              VID 
 *     MULTCAST_PORTMAP Multicast Portmap
 *     CONTROL          ARL control :2b'b00 : Normal ARL function.2b'b01 : Drop if MAC_DA match.(Please also set the "Static" bit)2b'b01 : Drop if MAC_SA match.(Please also set the "Static" bit)2b'b11 : Forward the destination port specified by ARL, Also send a copy to CPU.
 *     TC               Traffic Class
 *     AGE              Age bit
 *     STATIC           Static status
 *     VALID            Valid status
 *
 ******************************************************************************/
#define BCM89500_A0_L2_ARLm 0x12120808

#define BCM89500_A0_L2_ARLm_MIN 0
#define BCM89500_A0_L2_ARLm_MAX 4095
#define BCM89500_A0_L2_ARLm_CMAX(u) 4095
#define BCM89500_A0_L2_ARLm_SIZE 9

/*
 * This structure should be used to declare and program L2_ARL.
 *
 */
typedef union BCM89500_A0_L2_ARLm_s {
	uint32_t v[3];
	uint32_t l2_arl[3];
	uint32_t _l2_arl;
} BCM89500_A0_L2_ARLm_t;

#define BCM89500_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM89500_A0_L2_ARLm_t))
#define BCM89500_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM89500_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,2,37,a)
#define BCM89500_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,2,37,a)
#define BCM89500_A0_L2_ARLm_VIDf_GET(r) ((((r).l2_arl[1]) >> 6) & 0xfff)
#define BCM89500_A0_L2_ARLm_VIDf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM89500_A0_L2_ARLm_MULTCAST_PORTMAPf_GET(r) ((((r).l2_arl[1]) >> 18) & 0x7f)
#define BCM89500_A0_L2_ARLm_MULTCAST_PORTMAPf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7f << 18)) | ((((uint32_t)f) & 0x7f) << 18))
#define BCM89500_A0_L2_ARLm_CONTROLf_GET(r) ((((r).l2_arl[1]) >> 25) & 0x3)
#define BCM89500_A0_L2_ARLm_CONTROLf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM89500_A0_L2_ARLm_TCf_GET(r) ((((r).l2_arl[1]) >> 27) & 0x7)
#define BCM89500_A0_L2_ARLm_TCf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM89500_A0_L2_ARLm_AGEf_GET(r) ((((r).l2_arl[1]) >> 30) & 0x1)
#define BCM89500_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_L2_ARLm_STATICf_GET(r) ((((r).l2_arl[1]) >> 31) & 0x1)
#define BCM89500_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM89500_A0_L2_ARLm_VALIDf_GET(r) (((r).l2_arl[2]) & 0x1)
#define BCM89500_A0_L2_ARLm_VALIDf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access L2_ARL.
 *
 */
#define BCM89500_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_L2_ARLm,i,(m),9)
#define BCM89500_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_L2_ARLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM89500_A0_L2_ARLm
#define L2_ARLm_MIN BCM89500_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM89500_A0_L2_ARLm_MAX
#define L2_ARLm_CMAX(u) BCM89500_A0_L2_ARLm_CMAX(u)
#define L2_ARLm_SIZE BCM89500_A0_L2_ARLm_SIZE
typedef BCM89500_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM89500_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM89500_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM89500_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM89500_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM89500_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_VIDf_GET BCM89500_A0_L2_ARLm_VIDf_GET
#define L2_ARLm_VIDf_SET BCM89500_A0_L2_ARLm_VIDf_SET
#define L2_ARLm_MULTCAST_PORTMAPf_GET BCM89500_A0_L2_ARLm_MULTCAST_PORTMAPf_GET
#define L2_ARLm_MULTCAST_PORTMAPf_SET BCM89500_A0_L2_ARLm_MULTCAST_PORTMAPf_SET
#define L2_ARLm_CONTROLf_GET BCM89500_A0_L2_ARLm_CONTROLf_GET
#define L2_ARLm_CONTROLf_SET BCM89500_A0_L2_ARLm_CONTROLf_SET
#define L2_ARLm_TCf_GET BCM89500_A0_L2_ARLm_TCf_GET
#define L2_ARLm_TCf_SET BCM89500_A0_L2_ARLm_TCf_SET
#define L2_ARLm_AGEf_GET BCM89500_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM89500_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_STATICf_GET BCM89500_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM89500_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_VALIDf_GET BCM89500_A0_L2_ARLm_VALIDf_GET
#define L2_ARLm_VALIDf_SET BCM89500_A0_L2_ARLm_VALIDf_SET
#define READ_L2_ARLm BCM89500_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM89500_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_L2_ARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     16
 * FIELDS:
 *     LED_EN_MAP       Per port enable function bit,1: Enable LED function0: Disable LED functionbit[8]: port8.bit[7:6] reserved.bit[5:0]: port5 - port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_EN_MAPr 0x00000016

#define BCM89500_A0_LED_EN_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_EN_MAP.
 *
 */
typedef union BCM89500_A0_LED_EN_MAPr_s {
	uint32_t v[1];
	uint32_t led_en_map[1];
	uint32_t _led_en_map;
} BCM89500_A0_LED_EN_MAPr_t;

#define BCM89500_A0_LED_EN_MAPr_CLR(r) (r).led_en_map[0] = 0
#define BCM89500_A0_LED_EN_MAPr_SET(r,d) (r).led_en_map[0] = d
#define BCM89500_A0_LED_EN_MAPr_GET(r) (r).led_en_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) (((r).led_en_map[0]) & 0x1ff)
#define BCM89500_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LED_EN_MAPr_RESERVEDf_GET(r) ((((r).led_en_map[0]) >> 9) & 0x7f)
#define BCM89500_A0_LED_EN_MAPr_RESERVEDf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_EN_MAP.
 *
 */
#define BCM89500_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_EN_MAPr,(r._led_en_map),2)
#define BCM89500_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_EN_MAPr,&(r._led_en_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM89500_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM89500_A0_LED_EN_MAPr_SIZE
typedef BCM89500_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM89500_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM89500_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM89500_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM89500_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM89500_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVEDf_GET BCM89500_A0_LED_EN_MAPr_RESERVEDf_GET
#define LED_EN_MAPr_RESERVEDf_SET BCM89500_A0_LED_EN_MAPr_RESERVEDf_SET
#define READ_LED_EN_MAPr BCM89500_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM89500_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_EN_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        Bit 15:PHYLED3Bit 14:AVB linkBit 13:1G/ACT        (blink in auto_mode)Bit 12:10/100M/ACT   (blink in auto_mode)Bit 11:100M/ACT      (blink in auto_mode)Bit 10:10M/ACT       (blink in auto_mode)Bit 9:SPD1GBit 8:SPD100MBit 7:SPD10MBit 6:DPX/COL        (blink in auto_mode)Bit 5:LNK/ACT        (blink in auto_mode)Bit 4:COL            (blink in auto_mode)Bit 3:ACT            (blink in auto_mode)Bit 2:DPXBit 1:LNKBit 0:PHYLED4
 *
 ******************************************************************************/
#define BCM89500_A0_LED_FUNC0_CTLr 0x00000010

#define BCM89500_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 *
 */
typedef union BCM89500_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM89500_A0_LED_FUNC0_CTLr_t;

#define BCM89500_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM89500_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM89500_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET(r) (((r).led_func0_ctl[0]) & 0xffff)
#define BCM89500_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 *
 */
#define BCM89500_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM89500_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM89500_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM89500_A0_LED_FUNC0_CTLr_SIZE
typedef BCM89500_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM89500_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM89500_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM89500_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_GET BCM89500_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_SET BCM89500_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC0_CTLr BCM89500_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM89500_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_FUNC0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_FUNC0_EXTD_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0_EXTD   Bit 1:200M/ACTBit 0:SPD200M
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr 0x00000090

#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_EXTD_CTL.
 *
 */
typedef union BCM89500_A0_LED_FUNC0_EXTD_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_extd_ctl[1];
	uint32_t _led_func0_extd_ctl;
} BCM89500_A0_LED_FUNC0_EXTD_CTLr_t;

#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_CLR(r) (r).led_func0_extd_ctl[0] = 0
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_SET(r,d) (r).led_func0_extd_ctl[0] = d
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_GET(r) (r).led_func0_extd_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_LED_FUNC0_EXTDf_GET(r) (((r).led_func0_extd_ctl[0]) & 0x3)
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_LED_FUNC0_EXTDf_SET(r,f) (r).led_func0_extd_ctl[0]=(((r).led_func0_extd_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_RESERVEDf_GET(r) ((((r).led_func0_extd_ctl[0]) >> 2) & 0x3fff)
#define BCM89500_A0_LED_FUNC0_EXTD_CTLr_RESERVEDf_SET(r,f) (r).led_func0_extd_ctl[0]=(((r).led_func0_extd_ctl[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))

/*
 * These macros can be used to access LED_FUNC0_EXTD_CTL.
 *
 */
#define BCM89500_A0_READ_LED_FUNC0_EXTD_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_FUNC0_EXTD_CTLr,(r._led_func0_extd_ctl),2)
#define BCM89500_A0_WRITE_LED_FUNC0_EXTD_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_FUNC0_EXTD_CTLr,&(r._led_func0_extd_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_EXTD_CTLr BCM89500_A0_LED_FUNC0_EXTD_CTLr
#define LED_FUNC0_EXTD_CTLr_SIZE BCM89500_A0_LED_FUNC0_EXTD_CTLr_SIZE
typedef BCM89500_A0_LED_FUNC0_EXTD_CTLr_t LED_FUNC0_EXTD_CTLr_t;
#define LED_FUNC0_EXTD_CTLr_CLR BCM89500_A0_LED_FUNC0_EXTD_CTLr_CLR
#define LED_FUNC0_EXTD_CTLr_SET BCM89500_A0_LED_FUNC0_EXTD_CTLr_SET
#define LED_FUNC0_EXTD_CTLr_GET BCM89500_A0_LED_FUNC0_EXTD_CTLr_GET
#define LED_FUNC0_EXTD_CTLr_LED_FUNC0_EXTDf_GET BCM89500_A0_LED_FUNC0_EXTD_CTLr_LED_FUNC0_EXTDf_GET
#define LED_FUNC0_EXTD_CTLr_LED_FUNC0_EXTDf_SET BCM89500_A0_LED_FUNC0_EXTD_CTLr_LED_FUNC0_EXTDf_SET
#define LED_FUNC0_EXTD_CTLr_RESERVEDf_GET BCM89500_A0_LED_FUNC0_EXTD_CTLr_RESERVEDf_GET
#define LED_FUNC0_EXTD_CTLr_RESERVEDf_SET BCM89500_A0_LED_FUNC0_EXTD_CTLr_RESERVEDf_SET
#define READ_LED_FUNC0_EXTD_CTLr BCM89500_A0_READ_LED_FUNC0_EXTD_CTLr
#define WRITE_LED_FUNC0_EXTD_CTLr BCM89500_A0_WRITE_LED_FUNC0_EXTD_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_FUNC0_EXTD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC1        Bit 15:PHYLED3Bit 14:AVB linkBit 13:1G/ACT        (blink in auto_mode)Bit 12:10/100M/ACT   (blink in auto_mode)Bit 11:100M/ACT      (blink in auto_mode)Bit 10:10M/ACT       (blink in auto_mode)Bit 9:SPD1GBit 8:SPD100MBit 7:SPD10MBit 6:DPX/COL        (blink in auto_mode)Bit 5:LNK/ACT        (blink in auto_mode)Bit 4:COL            (blink in auto_mode)Bit 3:ACT            (blink in auto_mode)Bit 2:DPXBit 1:LNKBit 0:PHYLED4
 *
 ******************************************************************************/
#define BCM89500_A0_LED_FUNC1_CTLr 0x00000012

#define BCM89500_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 *
 */
typedef union BCM89500_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM89500_A0_LED_FUNC1_CTLr_t;

#define BCM89500_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM89500_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM89500_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET(r) (((r).led_func1_ctl[0]) & 0xffff)
#define BCM89500_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 *
 */
#define BCM89500_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM89500_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM89500_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM89500_A0_LED_FUNC1_CTLr_SIZE
typedef BCM89500_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM89500_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM89500_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM89500_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_GET BCM89500_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_SET BCM89500_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET
#define READ_LED_FUNC1_CTLr BCM89500_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM89500_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_FUNC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_FUNC1_EXTD_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC1_EXTD   Bit 1:200M/ACTBit 0:SPD200M
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr 0x00000092

#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_EXTD_CTL.
 *
 */
typedef union BCM89500_A0_LED_FUNC1_EXTD_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_extd_ctl[1];
	uint32_t _led_func1_extd_ctl;
} BCM89500_A0_LED_FUNC1_EXTD_CTLr_t;

#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_CLR(r) (r).led_func1_extd_ctl[0] = 0
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_SET(r,d) (r).led_func1_extd_ctl[0] = d
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_GET(r) (r).led_func1_extd_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_LED_FUNC1_EXTDf_GET(r) (((r).led_func1_extd_ctl[0]) & 0x3)
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_LED_FUNC1_EXTDf_SET(r,f) (r).led_func1_extd_ctl[0]=(((r).led_func1_extd_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_RESERVEDf_GET(r) ((((r).led_func1_extd_ctl[0]) >> 2) & 0x3fff)
#define BCM89500_A0_LED_FUNC1_EXTD_CTLr_RESERVEDf_SET(r,f) (r).led_func1_extd_ctl[0]=(((r).led_func1_extd_ctl[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))

/*
 * These macros can be used to access LED_FUNC1_EXTD_CTL.
 *
 */
#define BCM89500_A0_READ_LED_FUNC1_EXTD_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_FUNC1_EXTD_CTLr,(r._led_func1_extd_ctl),2)
#define BCM89500_A0_WRITE_LED_FUNC1_EXTD_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_FUNC1_EXTD_CTLr,&(r._led_func1_extd_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_EXTD_CTLr BCM89500_A0_LED_FUNC1_EXTD_CTLr
#define LED_FUNC1_EXTD_CTLr_SIZE BCM89500_A0_LED_FUNC1_EXTD_CTLr_SIZE
typedef BCM89500_A0_LED_FUNC1_EXTD_CTLr_t LED_FUNC1_EXTD_CTLr_t;
#define LED_FUNC1_EXTD_CTLr_CLR BCM89500_A0_LED_FUNC1_EXTD_CTLr_CLR
#define LED_FUNC1_EXTD_CTLr_SET BCM89500_A0_LED_FUNC1_EXTD_CTLr_SET
#define LED_FUNC1_EXTD_CTLr_GET BCM89500_A0_LED_FUNC1_EXTD_CTLr_GET
#define LED_FUNC1_EXTD_CTLr_LED_FUNC1_EXTDf_GET BCM89500_A0_LED_FUNC1_EXTD_CTLr_LED_FUNC1_EXTDf_GET
#define LED_FUNC1_EXTD_CTLr_LED_FUNC1_EXTDf_SET BCM89500_A0_LED_FUNC1_EXTD_CTLr_LED_FUNC1_EXTDf_SET
#define LED_FUNC1_EXTD_CTLr_RESERVEDf_GET BCM89500_A0_LED_FUNC1_EXTD_CTLr_RESERVEDf_GET
#define LED_FUNC1_EXTD_CTLr_RESERVEDf_SET BCM89500_A0_LED_FUNC1_EXTD_CTLr_RESERVEDf_SET
#define READ_LED_FUNC1_EXTD_CTLr BCM89500_A0_READ_LED_FUNC1_EXTD_CTLr
#define WRITE_LED_FUNC1_EXTD_CTLr BCM89500_A0_WRITE_LED_FUNC1_EXTD_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_FUNC1_EXTD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC_MAP     Per port select function bit.1: select function 1,0: select function 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_FUNC_MAPr 0x00000014

#define BCM89500_A0_LED_FUNC_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 *
 */
typedef union BCM89500_A0_LED_FUNC_MAPr_s {
	uint32_t v[1];
	uint32_t led_func_map[1];
	uint32_t _led_func_map;
} BCM89500_A0_LED_FUNC_MAPr_t;

#define BCM89500_A0_LED_FUNC_MAPr_CLR(r) (r).led_func_map[0] = 0
#define BCM89500_A0_LED_FUNC_MAPr_SET(r,d) (r).led_func_map[0] = d
#define BCM89500_A0_LED_FUNC_MAPr_GET(r) (r).led_func_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) (((r).led_func_map[0]) & 0x1ff)
#define BCM89500_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LED_FUNC_MAPr_RESERVEDf_GET(r) ((((r).led_func_map[0]) >> 9) & 0x7f)
#define BCM89500_A0_LED_FUNC_MAPr_RESERVEDf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_FUNC_MAP.
 *
 */
#define BCM89500_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_FUNC_MAPr,(r._led_func_map),2)
#define BCM89500_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_FUNC_MAPr,&(r._led_func_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM89500_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM89500_A0_LED_FUNC_MAPr_SIZE
typedef BCM89500_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM89500_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM89500_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM89500_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM89500_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM89500_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVEDf_GET BCM89500_A0_LED_FUNC_MAPr_RESERVEDf_GET
#define LED_FUNC_MAPr_RESERVEDf_SET BCM89500_A0_LED_FUNC_MAPr_RESERVEDf_SET
#define READ_LED_FUNC_MAPr BCM89500_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM89500_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_FUNC_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP0    Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_MODE_MAP_0r 0x00000018

#define BCM89500_A0_LED_MODE_MAP_0r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 *
 */
typedef union BCM89500_A0_LED_MODE_MAP_0r_s {
	uint32_t v[1];
	uint32_t led_mode_map_0[1];
	uint32_t _led_mode_map_0;
} BCM89500_A0_LED_MODE_MAP_0r_t;

#define BCM89500_A0_LED_MODE_MAP_0r_CLR(r) (r).led_mode_map_0[0] = 0
#define BCM89500_A0_LED_MODE_MAP_0r_SET(r,d) (r).led_mode_map_0[0] = d
#define BCM89500_A0_LED_MODE_MAP_0r_GET(r) (r).led_mode_map_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_GET(r) (((r).led_mode_map_0[0]) & 0x1ff)
#define BCM89500_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LED_MODE_MAP_0r_RESERVEDf_GET(r) ((((r).led_mode_map_0[0]) >> 9) & 0x7f)
#define BCM89500_A0_LED_MODE_MAP_0r_RESERVEDf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 *
 */
#define BCM89500_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),2)
#define BCM89500_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM89500_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM89500_A0_LED_MODE_MAP_0r_SIZE
typedef BCM89500_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM89500_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM89500_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM89500_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_LED_MODE_MAP0f_GET BCM89500_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_GET
#define LED_MODE_MAP_0r_LED_MODE_MAP0f_SET BCM89500_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_SET
#define LED_MODE_MAP_0r_RESERVEDf_GET BCM89500_A0_LED_MODE_MAP_0r_RESERVEDf_GET
#define LED_MODE_MAP_0r_RESERVEDf_SET BCM89500_A0_LED_MODE_MAP_0r_RESERVEDf_SET
#define READ_LED_MODE_MAP_0r BCM89500_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM89500_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_MODE_MAP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP1    Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_MODE_MAP_1r 0x0000001a

#define BCM89500_A0_LED_MODE_MAP_1r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 *
 */
typedef union BCM89500_A0_LED_MODE_MAP_1r_s {
	uint32_t v[1];
	uint32_t led_mode_map_1[1];
	uint32_t _led_mode_map_1;
} BCM89500_A0_LED_MODE_MAP_1r_t;

#define BCM89500_A0_LED_MODE_MAP_1r_CLR(r) (r).led_mode_map_1[0] = 0
#define BCM89500_A0_LED_MODE_MAP_1r_SET(r,d) (r).led_mode_map_1[0] = d
#define BCM89500_A0_LED_MODE_MAP_1r_GET(r) (r).led_mode_map_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_GET(r) (((r).led_mode_map_1[0]) & 0x1ff)
#define BCM89500_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LED_MODE_MAP_1r_RESERVEDf_GET(r) ((((r).led_mode_map_1[0]) >> 9) & 0x7f)
#define BCM89500_A0_LED_MODE_MAP_1r_RESERVEDf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 *
 */
#define BCM89500_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),2)
#define BCM89500_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM89500_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM89500_A0_LED_MODE_MAP_1r_SIZE
typedef BCM89500_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM89500_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM89500_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM89500_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_LED_MODE_MAP1f_GET BCM89500_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_GET
#define LED_MODE_MAP_1r_LED_MODE_MAP1f_SET BCM89500_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_SET
#define LED_MODE_MAP_1r_RESERVEDf_GET BCM89500_A0_LED_MODE_MAP_1r_RESERVEDf_GET
#define LED_MODE_MAP_1r_RESERVEDf_SET BCM89500_A0_LED_MODE_MAP_1r_RESERVEDf_SET
#define READ_LED_MODE_MAP_1r BCM89500_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM89500_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_MODE_MAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_OPTIONS
 * BLOCKS:   SYS
 * DESC:     LED Output Enable Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     OE_PHY_LED       Enable PHY LED output through the LED pinsWhen this bits is set, the PHY LED pins will be output through the chip LED pins, this bit can only be enabled under parallel LED mode.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_OPTIONSr 0x0000001c

#define BCM89500_A0_LED_OPTIONSr_SIZE 1

/*
 * This structure should be used to declare and program LED_OPTIONS.
 *
 */
typedef union BCM89500_A0_LED_OPTIONSr_s {
	uint32_t v[1];
	uint32_t led_options[1];
	uint32_t _led_options;
} BCM89500_A0_LED_OPTIONSr_t;

#define BCM89500_A0_LED_OPTIONSr_CLR(r) (r).led_options[0] = 0
#define BCM89500_A0_LED_OPTIONSr_SET(r,d) (r).led_options[0] = d
#define BCM89500_A0_LED_OPTIONSr_GET(r) (r).led_options[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_OPTIONSr_OE_PHY_LEDf_GET(r) (((r).led_options[0]) & 0x1)
#define BCM89500_A0_LED_OPTIONSr_OE_PHY_LEDf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_LED_OPTIONSr_RESERVEDf_GET(r) ((((r).led_options[0]) >> 1) & 0x7f)
#define BCM89500_A0_LED_OPTIONSr_RESERVEDf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access LED_OPTIONS.
 *
 */
#define BCM89500_A0_READ_LED_OPTIONSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_OPTIONSr,(r._led_options),1)
#define BCM89500_A0_WRITE_LED_OPTIONSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_OPTIONSr,&(r._led_options),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_OPTIONSr BCM89500_A0_LED_OPTIONSr
#define LED_OPTIONSr_SIZE BCM89500_A0_LED_OPTIONSr_SIZE
typedef BCM89500_A0_LED_OPTIONSr_t LED_OPTIONSr_t;
#define LED_OPTIONSr_CLR BCM89500_A0_LED_OPTIONSr_CLR
#define LED_OPTIONSr_SET BCM89500_A0_LED_OPTIONSr_SET
#define LED_OPTIONSr_GET BCM89500_A0_LED_OPTIONSr_GET
#define LED_OPTIONSr_OE_PHY_LEDf_GET BCM89500_A0_LED_OPTIONSr_OE_PHY_LEDf_GET
#define LED_OPTIONSr_OE_PHY_LEDf_SET BCM89500_A0_LED_OPTIONSr_OE_PHY_LEDf_SET
#define LED_OPTIONSr_RESERVEDf_GET BCM89500_A0_LED_OPTIONSr_RESERVEDf_GET
#define LED_OPTIONSr_RESERVEDf_SET BCM89500_A0_LED_OPTIONSr_RESERVEDf_SET
#define READ_LED_OPTIONSr BCM89500_A0_READ_LED_OPTIONSr
#define WRITE_LED_OPTIONSr BCM89500_A0_WRITE_LED_OPTIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_OPTIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_PORTMAP
 * BLOCKS:   SYS
 * DESC:     LED Waming Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     LED_WARNING_PORTMAP LED indication for loop detection foundbit 8 for IMPbit 7:0 for port 7-0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LED_PORTMAPr 0x00007203

#define BCM89500_A0_LED_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_PORTMAP.
 *
 */
typedef union BCM89500_A0_LED_PORTMAPr_s {
	uint32_t v[1];
	uint32_t led_portmap[1];
	uint32_t _led_portmap;
} BCM89500_A0_LED_PORTMAPr_t;

#define BCM89500_A0_LED_PORTMAPr_CLR(r) (r).led_portmap[0] = 0
#define BCM89500_A0_LED_PORTMAPr_SET(r,d) (r).led_portmap[0] = d
#define BCM89500_A0_LED_PORTMAPr_GET(r) (r).led_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET(r) (((r).led_portmap[0]) & 0x1ff)
#define BCM89500_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LED_PORTMAPr_RESERVEDf_GET(r) ((((r).led_portmap[0]) >> 9) & 0x7f)
#define BCM89500_A0_LED_PORTMAPr_RESERVEDf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_PORTMAP.
 *
 */
#define BCM89500_A0_READ_LED_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_PORTMAPr,(r._led_portmap),2)
#define BCM89500_A0_WRITE_LED_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_PORTMAPr,&(r._led_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_PORTMAPr BCM89500_A0_LED_PORTMAPr
#define LED_PORTMAPr_SIZE BCM89500_A0_LED_PORTMAPr_SIZE
typedef BCM89500_A0_LED_PORTMAPr_t LED_PORTMAPr_t;
#define LED_PORTMAPr_CLR BCM89500_A0_LED_PORTMAPr_CLR
#define LED_PORTMAPr_SET BCM89500_A0_LED_PORTMAPr_SET
#define LED_PORTMAPr_GET BCM89500_A0_LED_PORTMAPr_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_GET BCM89500_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_SET BCM89500_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET
#define LED_PORTMAPr_RESERVEDf_GET BCM89500_A0_LED_PORTMAPr_RESERVEDf_GET
#define LED_PORTMAPr_RESERVEDf_SET BCM89500_A0_LED_PORTMAPr_RESERVEDf_SET
#define READ_LED_PORTMAPr BCM89500_A0_READ_LED_PORTMAPr
#define WRITE_LED_PORTMAPr BCM89500_A0_WRITE_LED_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LED_REFLSH_CTL
 * BLOCKS:   SYS
 * DESC:     LED Configuration Register
 * SIZE:     8
 * FIELDS:
 *     LED_RFS_STOP     LED reflsh control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     LED_NORM_CD_EN   Write 1 to active cable diag in normal mode.
 *     LED_POST_CD_EN   Write 1 to active cable diag after POST.
 *     LED_PSCAN_EN     Write 1 to active port scan during POST.
 *     LED_POST_EXEC    Write 1 to re-start POST.
 *     LED_EN           Enable LED.
 *
 ******************************************************************************/
#define BCM89500_A0_LED_REFLSH_CTLr 0x0000000f

#define BCM89500_A0_LED_REFLSH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program LED_REFLSH_CTL.
 *
 */
typedef union BCM89500_A0_LED_REFLSH_CTLr_s {
	uint32_t v[1];
	uint32_t led_reflsh_ctl[1];
	uint32_t _led_reflsh_ctl;
} BCM89500_A0_LED_REFLSH_CTLr_t;

#define BCM89500_A0_LED_REFLSH_CTLr_CLR(r) (r).led_reflsh_ctl[0] = 0
#define BCM89500_A0_LED_REFLSH_CTLr_SET(r,d) (r).led_reflsh_ctl[0] = d
#define BCM89500_A0_LED_REFLSH_CTLr_GET(r) (r).led_reflsh_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET(r) (((r).led_reflsh_ctl[0]) & 0x7)
#define BCM89500_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET(r) ((((r).led_reflsh_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_LED_REFLSH_CTLr_LED_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_LED_REFLSH_CTLr_LED_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access LED_REFLSH_CTL.
 *
 */
#define BCM89500_A0_READ_LED_REFLSH_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LED_REFLSH_CTLr,(r._led_reflsh_ctl),1)
#define BCM89500_A0_WRITE_LED_REFLSH_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LED_REFLSH_CTLr,&(r._led_reflsh_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_REFLSH_CTLr BCM89500_A0_LED_REFLSH_CTLr
#define LED_REFLSH_CTLr_SIZE BCM89500_A0_LED_REFLSH_CTLr_SIZE
typedef BCM89500_A0_LED_REFLSH_CTLr_t LED_REFLSH_CTLr_t;
#define LED_REFLSH_CTLr_CLR BCM89500_A0_LED_REFLSH_CTLr_CLR
#define LED_REFLSH_CTLr_SET BCM89500_A0_LED_REFLSH_CTLr_SET
#define LED_REFLSH_CTLr_GET BCM89500_A0_LED_REFLSH_CTLr_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_GET BCM89500_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_SET BCM89500_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET BCM89500_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET BCM89500_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_GET BCM89500_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_SET BCM89500_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_GET BCM89500_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_SET BCM89500_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_EXECf_GET BCM89500_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET
#define LED_REFLSH_CTLr_LED_POST_EXECf_SET BCM89500_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET
#define LED_REFLSH_CTLr_LED_ENf_GET BCM89500_A0_LED_REFLSH_CTLr_LED_ENf_GET
#define LED_REFLSH_CTLr_LED_ENf_SET BCM89500_A0_LED_REFLSH_CTLr_LED_ENf_SET
#define READ_LED_REFLSH_CTLr BCM89500_A0_READ_LED_REFLSH_CTLr
#define WRITE_LED_REFLSH_CTLr BCM89500_A0_WRITE_LED_REFLSH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LED_REFLSH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LINK_STS_INT_EN
 * BLOCKS:   SYS
 * DESC:     Link Status Interrupt Enable Register
 * SIZE:     16
 * FIELDS:
 *     LINK_STS_INT_EN  It is used to gate link status interruptset "1" to enable interruptBit 0 map to port 0 link status.....Bit 8 map to port 8 link status
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LINK_STS_INT_ENr 0x00000324

#define BCM89500_A0_LINK_STS_INT_ENr_SIZE 2

/*
 * This structure should be used to declare and program LINK_STS_INT_EN.
 *
 */
typedef union BCM89500_A0_LINK_STS_INT_ENr_s {
	uint32_t v[1];
	uint32_t link_sts_int_en[1];
	uint32_t _link_sts_int_en;
} BCM89500_A0_LINK_STS_INT_ENr_t;

#define BCM89500_A0_LINK_STS_INT_ENr_CLR(r) (r).link_sts_int_en[0] = 0
#define BCM89500_A0_LINK_STS_INT_ENr_SET(r,d) (r).link_sts_int_en[0] = d
#define BCM89500_A0_LINK_STS_INT_ENr_GET(r) (r).link_sts_int_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LINK_STS_INT_ENr_LINK_STS_INT_ENf_GET(r) (((r).link_sts_int_en[0]) & 0x1ff)
#define BCM89500_A0_LINK_STS_INT_ENr_LINK_STS_INT_ENf_SET(r,f) (r).link_sts_int_en[0]=(((r).link_sts_int_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LINK_STS_INT_ENr_RESERVEDf_GET(r) ((((r).link_sts_int_en[0]) >> 9) & 0x7f)
#define BCM89500_A0_LINK_STS_INT_ENr_RESERVEDf_SET(r,f) (r).link_sts_int_en[0]=(((r).link_sts_int_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LINK_STS_INT_EN.
 *
 */
#define BCM89500_A0_READ_LINK_STS_INT_ENr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LINK_STS_INT_ENr,(r._link_sts_int_en),2)
#define BCM89500_A0_WRITE_LINK_STS_INT_ENr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LINK_STS_INT_ENr,&(r._link_sts_int_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LINK_STS_INT_ENr BCM89500_A0_LINK_STS_INT_ENr
#define LINK_STS_INT_ENr_SIZE BCM89500_A0_LINK_STS_INT_ENr_SIZE
typedef BCM89500_A0_LINK_STS_INT_ENr_t LINK_STS_INT_ENr_t;
#define LINK_STS_INT_ENr_CLR BCM89500_A0_LINK_STS_INT_ENr_CLR
#define LINK_STS_INT_ENr_SET BCM89500_A0_LINK_STS_INT_ENr_SET
#define LINK_STS_INT_ENr_GET BCM89500_A0_LINK_STS_INT_ENr_GET
#define LINK_STS_INT_ENr_LINK_STS_INT_ENf_GET BCM89500_A0_LINK_STS_INT_ENr_LINK_STS_INT_ENf_GET
#define LINK_STS_INT_ENr_LINK_STS_INT_ENf_SET BCM89500_A0_LINK_STS_INT_ENr_LINK_STS_INT_ENf_SET
#define LINK_STS_INT_ENr_RESERVEDf_GET BCM89500_A0_LINK_STS_INT_ENr_RESERVEDf_GET
#define LINK_STS_INT_ENr_RESERVEDf_SET BCM89500_A0_LINK_STS_INT_ENr_RESERVEDf_SET
#define READ_LINK_STS_INT_ENr BCM89500_A0_READ_LINK_STS_INT_ENr
#define WRITE_LINK_STS_INT_ENr BCM89500_A0_WRITE_LINK_STS_INT_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LINK_STS_INT_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     Link Status Summary Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS          Link Status.9bit field indicating the Link Status for each 10/100/1000 BASE-T port, (bits 0-7 = 10/100/1000 BASE-T, bit 8 IMP port ).0 = Link Fail1 = Link Pass
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LNKSTSr 0x00000100

#define BCM89500_A0_LNKSTSr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTS.
 *
 */
typedef union BCM89500_A0_LNKSTSr_s {
	uint32_t v[1];
	uint32_t lnksts[1];
	uint32_t _lnksts;
} BCM89500_A0_LNKSTSr_t;

#define BCM89500_A0_LNKSTSr_CLR(r) (r).lnksts[0] = 0
#define BCM89500_A0_LNKSTSr_SET(r,d) (r).lnksts[0] = d
#define BCM89500_A0_LNKSTSr_GET(r) (r).lnksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LNKSTSr_LNK_STSf_GET(r) (((r).lnksts[0]) & 0x1ff)
#define BCM89500_A0_LNKSTSr_LNK_STSf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LNKSTSr_RESERVEDf_GET(r) ((((r).lnksts[0]) >> 9) & 0x7f)
#define BCM89500_A0_LNKSTSr_RESERVEDf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTS.
 *
 */
#define BCM89500_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LNKSTSr,(r._lnksts),2)
#define BCM89500_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LNKSTSr,&(r._lnksts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM89500_A0_LNKSTSr
#define LNKSTSr_SIZE BCM89500_A0_LNKSTSr_SIZE
typedef BCM89500_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM89500_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM89500_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM89500_A0_LNKSTSr_GET
#define LNKSTSr_LNK_STSf_GET BCM89500_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM89500_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVEDf_GET BCM89500_A0_LNKSTSr_RESERVEDf_GET
#define LNKSTSr_RESERVEDf_SET BCM89500_A0_LNKSTSr_RESERVEDf_SET
#define READ_LNKSTSr BCM89500_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM89500_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LNKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Link Status Change Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS_CHG      Link Status Change.9 bit field indicating that the Link Status for an individual 10/100/1000BASE-T port had changed since the last read operation (bits 0-23 = 10/100/1000BASE- T ports, bit 8 = IMP port). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant,1 = Link Status Change.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LNKSTSCHGr 0x00000102

#define BCM89500_A0_LNKSTSCHGr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTSCHG.
 *
 */
typedef union BCM89500_A0_LNKSTSCHGr_s {
	uint32_t v[1];
	uint32_t lnkstschg[1];
	uint32_t _lnkstschg;
} BCM89500_A0_LNKSTSCHGr_t;

#define BCM89500_A0_LNKSTSCHGr_CLR(r) (r).lnkstschg[0] = 0
#define BCM89500_A0_LNKSTSCHGr_SET(r,d) (r).lnkstschg[0] = d
#define BCM89500_A0_LNKSTSCHGr_GET(r) (r).lnkstschg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) (((r).lnkstschg[0]) & 0x1ff)
#define BCM89500_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LNKSTSCHGr_RESERVEDf_GET(r) ((((r).lnkstschg[0]) >> 9) & 0x7f)
#define BCM89500_A0_LNKSTSCHGr_RESERVEDf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTSCHG.
 *
 */
#define BCM89500_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LNKSTSCHGr,(r._lnkstschg),2)
#define BCM89500_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LNKSTSCHGr,&(r._lnkstschg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM89500_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM89500_A0_LNKSTSCHGr_SIZE
typedef BCM89500_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM89500_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM89500_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM89500_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM89500_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM89500_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVEDf_GET BCM89500_A0_LNKSTSCHGr_RESERVEDf_GET
#define LNKSTSCHGr_RESERVEDf_SET BCM89500_A0_LNKSTSCHGr_RESERVEDf_SET
#define READ_LNKSTSCHGr BCM89500_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM89500_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LNKSTSCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LOW_POWER_CTRL
 * BLOCKS:   SYS
 * DESC:     LOW Power Control Register
 * SIZE:     16
 * FIELDS:
 *     LOW_POWER_DIVIDER low_power_divider.When bit[4] is 1'b1, this field indicates the divider of the low power clock. The system clock=CK25/((low_power_divider+1)*2).4'h0: 12.5Mhz4'h1: 6.25Mhz4'h2: 4.17Mhz4'h3: 3.125Mhz
 *     EN_LOW_POWER     low power enableWhen enabled, system clock will be switched to low power clock source based on the value of low_power_divider.
 *     TIMER_DISABLE    Disable switch timers.1'b1: disable timer1'b0: normal mode (timer running)
 *     SLEEP_SYS        Writing 1'b1 to this bit will disable switch core system clock. Switch core is put into sleep mode. Programming interfaces and SPI are still active.1'b1: sleep mode1'b0: normal mode
 *     RESERVED_0       reserved
 *     SLEEP_P4         Writing 1'b1 to this bit will disable MII3 clock. Port-4 is put into sleep mode.1'b1: sleep mode1'b0: normal mode
 *     SLEEP_P5         Writing 1'b1 to this bit will disable MII2 clock. Port-5 is put into sleep mode.1'b1: sleep mode1'b0: normal mode
 *     RESERVED_1       reserved
 *     SLEEP_P8         Writing 1'b1 to this bit will disable MII1 clock. Port-8 is put into sleep mode.1'b1: sleep mode1'b0: normal mode
 *
 ******************************************************************************/
#define BCM89500_A0_LOW_POWER_CTRLr 0x000000de

#define BCM89500_A0_LOW_POWER_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program LOW_POWER_CTRL.
 *
 */
typedef union BCM89500_A0_LOW_POWER_CTRLr_s {
	uint32_t v[1];
	uint32_t low_power_ctrl[1];
	uint32_t _low_power_ctrl;
} BCM89500_A0_LOW_POWER_CTRLr_t;

#define BCM89500_A0_LOW_POWER_CTRLr_CLR(r) (r).low_power_ctrl[0] = 0
#define BCM89500_A0_LOW_POWER_CTRLr_SET(r,d) (r).low_power_ctrl[0] = d
#define BCM89500_A0_LOW_POWER_CTRLr_GET(r) (r).low_power_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_GET(r) (((r).low_power_ctrl[0]) & 0xf)
#define BCM89500_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_GET(r) ((((r).low_power_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_GET(r) ((((r).low_power_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_SYSf_GET(r) ((((r).low_power_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_SYSf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_LOW_POWER_CTRLr_RESERVED_0f_GET(r) ((((r).low_power_ctrl[0]) >> 7) & 0xf)
#define BCM89500_A0_LOW_POWER_CTRLr_RESERVED_0f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P4f_GET(r) ((((r).low_power_ctrl[0]) >> 11) & 0x1)
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P4f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P5f_GET(r) ((((r).low_power_ctrl[0]) >> 12) & 0x1)
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P5f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_LOW_POWER_CTRLr_RESERVED_1f_GET(r) ((((r).low_power_ctrl[0]) >> 13) & 0x3)
#define BCM89500_A0_LOW_POWER_CTRLr_RESERVED_1f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P8f_GET(r) ((((r).low_power_ctrl[0]) >> 15) & 0x1)
#define BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P8f_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LOW_POWER_CTRL.
 *
 */
#define BCM89500_A0_READ_LOW_POWER_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LOW_POWER_CTRLr,(r._low_power_ctrl),2)
#define BCM89500_A0_WRITE_LOW_POWER_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LOW_POWER_CTRLr,&(r._low_power_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOW_POWER_CTRLr BCM89500_A0_LOW_POWER_CTRLr
#define LOW_POWER_CTRLr_SIZE BCM89500_A0_LOW_POWER_CTRLr_SIZE
typedef BCM89500_A0_LOW_POWER_CTRLr_t LOW_POWER_CTRLr_t;
#define LOW_POWER_CTRLr_CLR BCM89500_A0_LOW_POWER_CTRLr_CLR
#define LOW_POWER_CTRLr_SET BCM89500_A0_LOW_POWER_CTRLr_SET
#define LOW_POWER_CTRLr_GET BCM89500_A0_LOW_POWER_CTRLr_GET
#define LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_GET BCM89500_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_GET
#define LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_SET BCM89500_A0_LOW_POWER_CTRLr_LOW_POWER_DIVIDERf_SET
#define LOW_POWER_CTRLr_EN_LOW_POWERf_GET BCM89500_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_GET
#define LOW_POWER_CTRLr_EN_LOW_POWERf_SET BCM89500_A0_LOW_POWER_CTRLr_EN_LOW_POWERf_SET
#define LOW_POWER_CTRLr_TIMER_DISABLEf_GET BCM89500_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_GET
#define LOW_POWER_CTRLr_TIMER_DISABLEf_SET BCM89500_A0_LOW_POWER_CTRLr_TIMER_DISABLEf_SET
#define LOW_POWER_CTRLr_SLEEP_SYSf_GET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_SYSf_GET
#define LOW_POWER_CTRLr_SLEEP_SYSf_SET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_SYSf_SET
#define LOW_POWER_CTRLr_RESERVED_0f_GET BCM89500_A0_LOW_POWER_CTRLr_RESERVED_0f_GET
#define LOW_POWER_CTRLr_RESERVED_0f_SET BCM89500_A0_LOW_POWER_CTRLr_RESERVED_0f_SET
#define LOW_POWER_CTRLr_SLEEP_P4f_GET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P4f_GET
#define LOW_POWER_CTRLr_SLEEP_P4f_SET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P4f_SET
#define LOW_POWER_CTRLr_SLEEP_P5f_GET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P5f_GET
#define LOW_POWER_CTRLr_SLEEP_P5f_SET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P5f_SET
#define LOW_POWER_CTRLr_RESERVED_1f_GET BCM89500_A0_LOW_POWER_CTRLr_RESERVED_1f_GET
#define LOW_POWER_CTRLr_RESERVED_1f_SET BCM89500_A0_LOW_POWER_CTRLr_RESERVED_1f_SET
#define LOW_POWER_CTRLr_SLEEP_P8f_GET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P8f_GET
#define LOW_POWER_CTRLr_SLEEP_P8f_SET BCM89500_A0_LOW_POWER_CTRLr_SLEEP_P8f_SET
#define READ_LOW_POWER_CTRLr BCM89500_A0_READ_LOW_POWER_CTRLr
#define WRITE_LOW_POWER_CTRLr BCM89500_A0_WRITE_LOW_POWER_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LOW_POWER_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LOW_POWER_EXP1
 * BLOCKS:   SYS
 * DESC:     Low Power Expansion I Register
 * SIZE:     32
 * FIELDS:
 *     SLEEP_SYSCLK_PORT Set 1'b1 to bit field gates off the corresponding port's system clock.Bits [8:0]: Port8 - Port0
 *     RESERVED_0       Reserved
 *     SLEEP_MACCLK_PORT Set 1'b1 to bit field gates off the corresponding port's MAC TX/RX clocks.Bits [24:16]: Port8 - Port0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LOW_POWER_EXP1r 0x00000040

#define BCM89500_A0_LOW_POWER_EXP1r_SIZE 4

/*
 * This structure should be used to declare and program LOW_POWER_EXP1.
 *
 */
typedef union BCM89500_A0_LOW_POWER_EXP1r_s {
	uint32_t v[1];
	uint32_t low_power_exp1[1];
	uint32_t _low_power_exp1;
} BCM89500_A0_LOW_POWER_EXP1r_t;

#define BCM89500_A0_LOW_POWER_EXP1r_CLR(r) (r).low_power_exp1[0] = 0
#define BCM89500_A0_LOW_POWER_EXP1r_SET(r,d) (r).low_power_exp1[0] = d
#define BCM89500_A0_LOW_POWER_EXP1r_GET(r) (r).low_power_exp1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LOW_POWER_EXP1r_SLEEP_SYSCLK_PORTf_GET(r) (((r).low_power_exp1[0]) & 0x1ff)
#define BCM89500_A0_LOW_POWER_EXP1r_SLEEP_SYSCLK_PORTf_SET(r,f) (r).low_power_exp1[0]=(((r).low_power_exp1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LOW_POWER_EXP1r_RESERVED_0f_GET(r) ((((r).low_power_exp1[0]) >> 9) & 0x7f)
#define BCM89500_A0_LOW_POWER_EXP1r_RESERVED_0f_SET(r,f) (r).low_power_exp1[0]=(((r).low_power_exp1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM89500_A0_LOW_POWER_EXP1r_SLEEP_MACCLK_PORTf_GET(r) ((((r).low_power_exp1[0]) >> 16) & 0x1ff)
#define BCM89500_A0_LOW_POWER_EXP1r_SLEEP_MACCLK_PORTf_SET(r,f) (r).low_power_exp1[0]=(((r).low_power_exp1[0] & ~((uint32_t)0x1ff << 16)) | ((((uint32_t)f) & 0x1ff) << 16))
#define BCM89500_A0_LOW_POWER_EXP1r_RESERVED_1f_GET(r) ((((r).low_power_exp1[0]) >> 25) & 0x7f)
#define BCM89500_A0_LOW_POWER_EXP1r_RESERVED_1f_SET(r,f) (r).low_power_exp1[0]=(((r).low_power_exp1[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access LOW_POWER_EXP1.
 *
 */
#define BCM89500_A0_READ_LOW_POWER_EXP1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_LOW_POWER_EXP1r,(r._low_power_exp1),4)
#define BCM89500_A0_WRITE_LOW_POWER_EXP1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_LOW_POWER_EXP1r,&(r._low_power_exp1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOW_POWER_EXP1r BCM89500_A0_LOW_POWER_EXP1r
#define LOW_POWER_EXP1r_SIZE BCM89500_A0_LOW_POWER_EXP1r_SIZE
typedef BCM89500_A0_LOW_POWER_EXP1r_t LOW_POWER_EXP1r_t;
#define LOW_POWER_EXP1r_CLR BCM89500_A0_LOW_POWER_EXP1r_CLR
#define LOW_POWER_EXP1r_SET BCM89500_A0_LOW_POWER_EXP1r_SET
#define LOW_POWER_EXP1r_GET BCM89500_A0_LOW_POWER_EXP1r_GET
#define LOW_POWER_EXP1r_SLEEP_SYSCLK_PORTf_GET BCM89500_A0_LOW_POWER_EXP1r_SLEEP_SYSCLK_PORTf_GET
#define LOW_POWER_EXP1r_SLEEP_SYSCLK_PORTf_SET BCM89500_A0_LOW_POWER_EXP1r_SLEEP_SYSCLK_PORTf_SET
#define LOW_POWER_EXP1r_RESERVED_0f_GET BCM89500_A0_LOW_POWER_EXP1r_RESERVED_0f_GET
#define LOW_POWER_EXP1r_RESERVED_0f_SET BCM89500_A0_LOW_POWER_EXP1r_RESERVED_0f_SET
#define LOW_POWER_EXP1r_SLEEP_MACCLK_PORTf_GET BCM89500_A0_LOW_POWER_EXP1r_SLEEP_MACCLK_PORTf_GET
#define LOW_POWER_EXP1r_SLEEP_MACCLK_PORTf_SET BCM89500_A0_LOW_POWER_EXP1r_SLEEP_MACCLK_PORTf_SET
#define LOW_POWER_EXP1r_RESERVED_1f_GET BCM89500_A0_LOW_POWER_EXP1r_RESERVED_1f_GET
#define LOW_POWER_EXP1r_RESERVED_1f_SET BCM89500_A0_LOW_POWER_EXP1r_RESERVED_1f_SET
#define READ_LOW_POWER_EXP1r BCM89500_A0_READ_LOW_POWER_EXP1r
#define WRITE_LOW_POWER_EXP1r BCM89500_A0_WRITE_LOW_POWER_EXP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LOW_POWER_EXP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LOW_QUEUE_AVB_SHAPING_MODE
 * BLOCKS:   SYS
 * DESC:     Low Queue (Q0-Q3) AVB Shaping Mode Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     LOW_QUEUE_AVB_SHAPING_MODE Enable/Disable low queue (queue 0~3) AVB Shaping mode for each egress port.0: Disable AVB Shaping mode1: Enable AVB Shaping modebit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr 0x00003702

#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_SIZE 2

/*
 * This structure should be used to declare and program LOW_QUEUE_AVB_SHAPING_MODE.
 *
 */
typedef union BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_s {
	uint32_t v[1];
	uint32_t low_queue_avb_shaping_mode[1];
	uint32_t _low_queue_avb_shaping_mode;
} BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_t;

#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_CLR(r) (r).low_queue_avb_shaping_mode[0] = 0
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_SET(r,d) (r).low_queue_avb_shaping_mode[0] = d
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_GET(r) (r).low_queue_avb_shaping_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_LOW_QUEUE_AVB_SHAPING_MODEf_GET(r) (((r).low_queue_avb_shaping_mode[0]) & 0x1ff)
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_LOW_QUEUE_AVB_SHAPING_MODEf_SET(r,f) (r).low_queue_avb_shaping_mode[0]=(((r).low_queue_avb_shaping_mode[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_RESERVEDf_GET(r) ((((r).low_queue_avb_shaping_mode[0]) >> 9) & 0x7f)
#define BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_RESERVEDf_SET(r,f) (r).low_queue_avb_shaping_mode[0]=(((r).low_queue_avb_shaping_mode[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LOW_QUEUE_AVB_SHAPING_MODE.
 *
 */
#define BCM89500_A0_READ_LOW_QUEUE_AVB_SHAPING_MODEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr,(r._low_queue_avb_shaping_mode),2)
#define BCM89500_A0_WRITE_LOW_QUEUE_AVB_SHAPING_MODEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr,&(r._low_queue_avb_shaping_mode),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOW_QUEUE_AVB_SHAPING_MODEr BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr
#define LOW_QUEUE_AVB_SHAPING_MODEr_SIZE BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_SIZE
typedef BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_t LOW_QUEUE_AVB_SHAPING_MODEr_t;
#define LOW_QUEUE_AVB_SHAPING_MODEr_CLR BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_CLR
#define LOW_QUEUE_AVB_SHAPING_MODEr_SET BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_SET
#define LOW_QUEUE_AVB_SHAPING_MODEr_GET BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_GET
#define LOW_QUEUE_AVB_SHAPING_MODEr_LOW_QUEUE_AVB_SHAPING_MODEf_GET BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_LOW_QUEUE_AVB_SHAPING_MODEf_GET
#define LOW_QUEUE_AVB_SHAPING_MODEr_LOW_QUEUE_AVB_SHAPING_MODEf_SET BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_LOW_QUEUE_AVB_SHAPING_MODEf_SET
#define LOW_QUEUE_AVB_SHAPING_MODEr_RESERVEDf_GET BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_RESERVEDf_GET
#define LOW_QUEUE_AVB_SHAPING_MODEr_RESERVEDf_SET BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr_RESERVEDf_SET
#define READ_LOW_QUEUE_AVB_SHAPING_MODEr BCM89500_A0_READ_LOW_QUEUE_AVB_SHAPING_MODEr
#define WRITE_LOW_QUEUE_AVB_SHAPING_MODEr BCM89500_A0_WRITE_LOW_QUEUE_AVB_SHAPING_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LOW_QUEUE_AVB_SHAPING_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LOW_QUEUE_SHAPER_ENABLE
 * BLOCKS:   SYS
 * DESC:     Low Queue (Q0-Q3) Shaper Enable Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     LOW_QUEUE_SHAPER_ENABLE Enable/Disable low queue (queue 0~3) Shaper for each egress port.0: Disable Shaper1: Enable Shaperbit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr 0x00003710

#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_SIZE 2

/*
 * This structure should be used to declare and program LOW_QUEUE_SHAPER_ENABLE.
 *
 */
typedef union BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_s {
	uint32_t v[1];
	uint32_t low_queue_shaper_enable[1];
	uint32_t _low_queue_shaper_enable;
} BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_t;

#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_CLR(r) (r).low_queue_shaper_enable[0] = 0
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_SET(r,d) (r).low_queue_shaper_enable[0] = d
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_GET(r) (r).low_queue_shaper_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_LOW_QUEUE_SHAPER_ENABLEf_GET(r) (((r).low_queue_shaper_enable[0]) & 0x1ff)
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_LOW_QUEUE_SHAPER_ENABLEf_SET(r,f) (r).low_queue_shaper_enable[0]=(((r).low_queue_shaper_enable[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_RESERVEDf_GET(r) ((((r).low_queue_shaper_enable[0]) >> 9) & 0x7f)
#define BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_RESERVEDf_SET(r,f) (r).low_queue_shaper_enable[0]=(((r).low_queue_shaper_enable[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LOW_QUEUE_SHAPER_ENABLE.
 *
 */
#define BCM89500_A0_READ_LOW_QUEUE_SHAPER_ENABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr,(r._low_queue_shaper_enable),2)
#define BCM89500_A0_WRITE_LOW_QUEUE_SHAPER_ENABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr,&(r._low_queue_shaper_enable),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOW_QUEUE_SHAPER_ENABLEr BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr
#define LOW_QUEUE_SHAPER_ENABLEr_SIZE BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_SIZE
typedef BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_t LOW_QUEUE_SHAPER_ENABLEr_t;
#define LOW_QUEUE_SHAPER_ENABLEr_CLR BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_CLR
#define LOW_QUEUE_SHAPER_ENABLEr_SET BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_SET
#define LOW_QUEUE_SHAPER_ENABLEr_GET BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_GET
#define LOW_QUEUE_SHAPER_ENABLEr_LOW_QUEUE_SHAPER_ENABLEf_GET BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_LOW_QUEUE_SHAPER_ENABLEf_GET
#define LOW_QUEUE_SHAPER_ENABLEr_LOW_QUEUE_SHAPER_ENABLEf_SET BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_LOW_QUEUE_SHAPER_ENABLEf_SET
#define LOW_QUEUE_SHAPER_ENABLEr_RESERVEDf_GET BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_RESERVEDf_GET
#define LOW_QUEUE_SHAPER_ENABLEr_RESERVEDf_SET BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr_RESERVEDf_SET
#define READ_LOW_QUEUE_SHAPER_ENABLEr BCM89500_A0_READ_LOW_QUEUE_SHAPER_ENABLEr
#define WRITE_LOW_QUEUE_SHAPER_ENABLEr BCM89500_A0_WRITE_LOW_QUEUE_SHAPER_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LOW_QUEUE_SHAPER_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LPDET_CFG
 * BLOCKS:   SYS
 * DESC:     Loop Detection Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     DFQ_SEL          specify which queue to be put for received discovery frame, default is Q1.
 *     OV_PAUSE_ON      1'b1: transmit frame in highest queue even the port is in pause on state(might not work if prefetch fifo is occupied by low-Q frame).1'b0: transmit frame follow the pause state rule.
 *     LED_RST_CTL      specify how many times we can miss discovery time before we reset LED_warning_portmap.
 *     LOOP_IMP_SEL     1'b1: IMP support loop detection feature.1'b0: IMP do not support loop detection feature.
 *     EN_LPDET         1'b1: enable loop detection feature.(polar support for unmanaged mode only)1'b0: disable loop detection feature.For BCM53125U:en_lpdet strap pin. For BCM53125M/S:0
 *     EN_TXPASS        QOS_MODE at Page/Offset=30h/80h,bit3:2 MUST match to DFQ_SEL,bit1:0.HQ_Preempt at Page/Offset=30h/80h,bit4 MUST set to 1.1'b1:when EN_LPDET and act_loop_detect are active, LoopDetect frame would send out even if prefetch fifo is occupied by low-Q frame.1'b0:follow OV_PAUSE_ON(bit-2) setting.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_LPDET_CFGr 0x00007200

#define BCM89500_A0_LPDET_CFGr_SIZE 2

/*
 * This structure should be used to declare and program LPDET_CFG.
 *
 */
typedef union BCM89500_A0_LPDET_CFGr_s {
	uint32_t v[1];
	uint32_t lpdet_cfg[1];
	uint32_t _lpdet_cfg;
} BCM89500_A0_LPDET_CFGr_t;

#define BCM89500_A0_LPDET_CFGr_CLR(r) (r).lpdet_cfg[0] = 0
#define BCM89500_A0_LPDET_CFGr_SET(r,d) (r).lpdet_cfg[0] = d
#define BCM89500_A0_LPDET_CFGr_GET(r) (r).lpdet_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LPDET_CFGr_DFQ_SELf_GET(r) (((r).lpdet_cfg[0]) & 0x3)
#define BCM89500_A0_LPDET_CFGr_DFQ_SELf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_LPDET_CFGr_OV_PAUSE_ONf_GET(r) ((((r).lpdet_cfg[0]) >> 2) & 0x1)
#define BCM89500_A0_LPDET_CFGr_OV_PAUSE_ONf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_LPDET_CFGr_LED_RST_CTLf_GET(r) ((((r).lpdet_cfg[0]) >> 3) & 0xff)
#define BCM89500_A0_LPDET_CFGr_LED_RST_CTLf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM89500_A0_LPDET_CFGr_LOOP_IMP_SELf_GET(r) ((((r).lpdet_cfg[0]) >> 11) & 0x1)
#define BCM89500_A0_LPDET_CFGr_LOOP_IMP_SELf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_LPDET_CFGr_EN_LPDETf_GET(r) ((((r).lpdet_cfg[0]) >> 12) & 0x1)
#define BCM89500_A0_LPDET_CFGr_EN_LPDETf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_LPDET_CFGr_EN_TXPASSf_GET(r) ((((r).lpdet_cfg[0]) >> 13) & 0x1)
#define BCM89500_A0_LPDET_CFGr_EN_TXPASSf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_LPDET_CFGr_RESERVEDf_GET(r) ((((r).lpdet_cfg[0]) >> 14) & 0x3)
#define BCM89500_A0_LPDET_CFGr_RESERVEDf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access LPDET_CFG.
 *
 */
#define BCM89500_A0_READ_LPDET_CFGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LPDET_CFGr,(r._lpdet_cfg),2)
#define BCM89500_A0_WRITE_LPDET_CFGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LPDET_CFGr,&(r._lpdet_cfg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_CFGr BCM89500_A0_LPDET_CFGr
#define LPDET_CFGr_SIZE BCM89500_A0_LPDET_CFGr_SIZE
typedef BCM89500_A0_LPDET_CFGr_t LPDET_CFGr_t;
#define LPDET_CFGr_CLR BCM89500_A0_LPDET_CFGr_CLR
#define LPDET_CFGr_SET BCM89500_A0_LPDET_CFGr_SET
#define LPDET_CFGr_GET BCM89500_A0_LPDET_CFGr_GET
#define LPDET_CFGr_DFQ_SELf_GET BCM89500_A0_LPDET_CFGr_DFQ_SELf_GET
#define LPDET_CFGr_DFQ_SELf_SET BCM89500_A0_LPDET_CFGr_DFQ_SELf_SET
#define LPDET_CFGr_OV_PAUSE_ONf_GET BCM89500_A0_LPDET_CFGr_OV_PAUSE_ONf_GET
#define LPDET_CFGr_OV_PAUSE_ONf_SET BCM89500_A0_LPDET_CFGr_OV_PAUSE_ONf_SET
#define LPDET_CFGr_LED_RST_CTLf_GET BCM89500_A0_LPDET_CFGr_LED_RST_CTLf_GET
#define LPDET_CFGr_LED_RST_CTLf_SET BCM89500_A0_LPDET_CFGr_LED_RST_CTLf_SET
#define LPDET_CFGr_LOOP_IMP_SELf_GET BCM89500_A0_LPDET_CFGr_LOOP_IMP_SELf_GET
#define LPDET_CFGr_LOOP_IMP_SELf_SET BCM89500_A0_LPDET_CFGr_LOOP_IMP_SELf_SET
#define LPDET_CFGr_EN_LPDETf_GET BCM89500_A0_LPDET_CFGr_EN_LPDETf_GET
#define LPDET_CFGr_EN_LPDETf_SET BCM89500_A0_LPDET_CFGr_EN_LPDETf_SET
#define LPDET_CFGr_EN_TXPASSf_GET BCM89500_A0_LPDET_CFGr_EN_TXPASSf_GET
#define LPDET_CFGr_EN_TXPASSf_SET BCM89500_A0_LPDET_CFGr_EN_TXPASSf_SET
#define LPDET_CFGr_RESERVEDf_GET BCM89500_A0_LPDET_CFGr_RESERVEDf_GET
#define LPDET_CFGr_RESERVEDf_SET BCM89500_A0_LPDET_CFGr_RESERVEDf_SET
#define READ_LPDET_CFGr BCM89500_A0_READ_LPDET_CFGr
#define WRITE_LPDET_CFGr BCM89500_A0_WRITE_LPDET_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LPDET_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LPDET_SA
 * BLOCKS:   SYS
 * DESC:     Loop Detect Frame SA Registers
 * SIZE:     48
 * FIELDS:
 *     LPDET_SA         Loop Detection Frame SA.
 *
 ******************************************************************************/
#define BCM89500_A0_LPDET_SAr 0x00007211

#define BCM89500_A0_LPDET_SAr_SIZE 6

/*
 * This structure should be used to declare and program LPDET_SA.
 *
 */
typedef union BCM89500_A0_LPDET_SAr_s {
	uint32_t v[2];
	uint32_t lpdet_sa[2];
	uint32_t _lpdet_sa;
} BCM89500_A0_LPDET_SAr_t;

#define BCM89500_A0_LPDET_SAr_CLR(r) CDK_MEMSET(&((r)._lpdet_sa), 0, sizeof(BCM89500_A0_LPDET_SAr_t))
#define BCM89500_A0_LPDET_SAr_SET(r,i,d) (r).lpdet_sa[i] = d
#define BCM89500_A0_LPDET_SAr_GET(r,i) (r).lpdet_sa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LPDET_SAr_LPDET_SAf_GET(r,a) cdk_field_get((r).lpdet_sa,0,47,a)
#define BCM89500_A0_LPDET_SAr_LPDET_SAf_SET(r,a) cdk_field_set((r).lpdet_sa,0,47,a)

/*
 * These macros can be used to access LPDET_SA.
 *
 */
#define BCM89500_A0_READ_LPDET_SAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LPDET_SAr,(r._lpdet_sa),6)
#define BCM89500_A0_WRITE_LPDET_SAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LPDET_SAr,&(r._lpdet_sa),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_SAr BCM89500_A0_LPDET_SAr
#define LPDET_SAr_SIZE BCM89500_A0_LPDET_SAr_SIZE
typedef BCM89500_A0_LPDET_SAr_t LPDET_SAr_t;
#define LPDET_SAr_CLR BCM89500_A0_LPDET_SAr_CLR
#define LPDET_SAr_SET BCM89500_A0_LPDET_SAr_SET
#define LPDET_SAr_GET BCM89500_A0_LPDET_SAr_GET
#define LPDET_SAr_LPDET_SAf_GET BCM89500_A0_LPDET_SAr_LPDET_SAf_GET
#define LPDET_SAr_LPDET_SAf_SET BCM89500_A0_LPDET_SAr_LPDET_SAf_SET
#define READ_LPDET_SAr BCM89500_A0_READ_LPDET_SAr
#define WRITE_LPDET_SAr BCM89500_A0_WRITE_LPDET_SAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LPDET_SAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LSA_MII_PORT
 * BLOCKS:   CPIC
 * DESC:     Port 8 Last Source Address
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address
 *
 ******************************************************************************/
#define BCM89500_A0_LSA_MII_PORTr 0x00000140

#define BCM89500_A0_LSA_MII_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_MII_PORT.
 *
 */
typedef union BCM89500_A0_LSA_MII_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_mii_port[2];
	uint32_t _lsa_mii_port;
} BCM89500_A0_LSA_MII_PORTr_t;

#define BCM89500_A0_LSA_MII_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_mii_port), 0, sizeof(BCM89500_A0_LSA_MII_PORTr_t))
#define BCM89500_A0_LSA_MII_PORTr_SET(r,i,d) (r).lsa_mii_port[i] = d
#define BCM89500_A0_LSA_MII_PORTr_GET(r,i) (r).lsa_mii_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LSA_MII_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_mii_port,0,47,a)
#define BCM89500_A0_LSA_MII_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_mii_port,0,47,a)

/*
 * These macros can be used to access LSA_MII_PORT.
 *
 */
#define BCM89500_A0_READ_LSA_MII_PORTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_LSA_MII_PORTr,(r._lsa_mii_port),6)
#define BCM89500_A0_WRITE_LSA_MII_PORTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_LSA_MII_PORTr,&(r._lsa_mii_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_MII_PORTr BCM89500_A0_LSA_MII_PORTr
#define LSA_MII_PORTr_SIZE BCM89500_A0_LSA_MII_PORTr_SIZE
typedef BCM89500_A0_LSA_MII_PORTr_t LSA_MII_PORTr_t;
#define LSA_MII_PORTr_CLR BCM89500_A0_LSA_MII_PORTr_CLR
#define LSA_MII_PORTr_SET BCM89500_A0_LSA_MII_PORTr_SET
#define LSA_MII_PORTr_GET BCM89500_A0_LSA_MII_PORTr_GET
#define LSA_MII_PORTr_LST_ADDRf_GET BCM89500_A0_LSA_MII_PORTr_LST_ADDRf_GET
#define LSA_MII_PORTr_LST_ADDRf_SET BCM89500_A0_LSA_MII_PORTr_LST_ADDRf_SET
#define READ_LSA_MII_PORTr BCM89500_A0_READ_LSA_MII_PORTr
#define WRITE_LSA_MII_PORTr BCM89500_A0_WRITE_LSA_MII_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LSA_MII_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LSA_PORT
 * BLOCKS:   GPIC0
 * DESC:     Port N Last Source Address
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address
 *
 ******************************************************************************/
#define BCM89500_A0_LSA_PORTr 0x00000110

#define BCM89500_A0_LSA_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_PORT.
 *
 */
typedef union BCM89500_A0_LSA_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_port[2];
	uint32_t _lsa_port;
} BCM89500_A0_LSA_PORTr_t;

#define BCM89500_A0_LSA_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_port), 0, sizeof(BCM89500_A0_LSA_PORTr_t))
#define BCM89500_A0_LSA_PORTr_SET(r,i,d) (r).lsa_port[i] = d
#define BCM89500_A0_LSA_PORTr_GET(r,i) (r).lsa_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LSA_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_port,0,47,a)
#define BCM89500_A0_LSA_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_port,0,47,a)

/*
 * These macros can be used to access LSA_PORT.
 *
 */
#define BCM89500_A0_READ_LSA_PORTr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_LSA_PORTr+(6*(i)),(r._lsa_port),6)
#define BCM89500_A0_WRITE_LSA_PORTr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_LSA_PORTr+(6*(i)),&(r._lsa_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_PORTr BCM89500_A0_LSA_PORTr
#define LSA_PORTr_SIZE BCM89500_A0_LSA_PORTr_SIZE
typedef BCM89500_A0_LSA_PORTr_t LSA_PORTr_t;
#define LSA_PORTr_CLR BCM89500_A0_LSA_PORTr_CLR
#define LSA_PORTr_SET BCM89500_A0_LSA_PORTr_SET
#define LSA_PORTr_GET BCM89500_A0_LSA_PORTr_GET
#define LSA_PORTr_LST_ADDRf_GET BCM89500_A0_LSA_PORTr_LST_ADDRf_GET
#define LSA_PORTr_LST_ADDRf_SET BCM89500_A0_LSA_PORTr_LST_ADDRf_SET
#define READ_LSA_PORTr BCM89500_A0_READ_LSA_PORTr
#define WRITE_LSA_PORTr BCM89500_A0_WRITE_LSA_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LSA_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  LSA_PORT7
 * BLOCKS:   SYS
 * DESC:     Port 7 Last Source Address (polar feature)
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address
 *
 ******************************************************************************/
#define BCM89500_A0_LSA_PORT7r 0x0000013a

#define BCM89500_A0_LSA_PORT7r_SIZE 6

/*
 * This structure should be used to declare and program LSA_PORT7.
 *
 */
typedef union BCM89500_A0_LSA_PORT7r_s {
	uint32_t v[2];
	uint32_t lsa_port7[2];
	uint32_t _lsa_port7;
} BCM89500_A0_LSA_PORT7r_t;

#define BCM89500_A0_LSA_PORT7r_CLR(r) CDK_MEMSET(&((r)._lsa_port7), 0, sizeof(BCM89500_A0_LSA_PORT7r_t))
#define BCM89500_A0_LSA_PORT7r_SET(r,i,d) (r).lsa_port7[i] = d
#define BCM89500_A0_LSA_PORT7r_GET(r,i) (r).lsa_port7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_LSA_PORT7r_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_port7,0,47,a)
#define BCM89500_A0_LSA_PORT7r_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_port7,0,47,a)

/*
 * These macros can be used to access LSA_PORT7.
 *
 */
#define BCM89500_A0_READ_LSA_PORT7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_LSA_PORT7r,(r._lsa_port7),6)
#define BCM89500_A0_WRITE_LSA_PORT7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_LSA_PORT7r,&(r._lsa_port7),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_PORT7r BCM89500_A0_LSA_PORT7r
#define LSA_PORT7r_SIZE BCM89500_A0_LSA_PORT7r_SIZE
typedef BCM89500_A0_LSA_PORT7r_t LSA_PORT7r_t;
#define LSA_PORT7r_CLR BCM89500_A0_LSA_PORT7r_CLR
#define LSA_PORT7r_SET BCM89500_A0_LSA_PORT7r_SET
#define LSA_PORT7r_GET BCM89500_A0_LSA_PORT7r_GET
#define LSA_PORT7r_LST_ADDRf_GET BCM89500_A0_LSA_PORT7r_LST_ADDRf_GET
#define LSA_PORT7r_LST_ADDRf_SET BCM89500_A0_LSA_PORT7r_LST_ADDRf_SET
#define READ_LSA_PORT7r BCM89500_A0_READ_LSA_PORT7r
#define WRITE_LSA_PORT7r BCM89500_A0_WRITE_LSA_PORT7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_LSA_PORT7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MAC_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     MAC Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     HASH_SEL         index selection00 : use hash DA ^ SA) to generate index. ( default=0 )01 : use hash(DA) to generate index.10 : Use hash (SA) to generate index.
 *     SERVER_0         Reserved
 *     EN_TRUNK_LOCAL   Enable Mac trunking .polar  support 2 trunking groups. The trunking group can support up to 4 ports as defined trunking group register.
 *     SERVER_1         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MAC_TRUNK_CTLr 0x00003200

#define BCM89500_A0_MAC_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MAC_TRUNK_CTL.
 *
 */
typedef union BCM89500_A0_MAC_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t mac_trunk_ctl[1];
	uint32_t _mac_trunk_ctl;
} BCM89500_A0_MAC_TRUNK_CTLr_t;

#define BCM89500_A0_MAC_TRUNK_CTLr_CLR(r) (r).mac_trunk_ctl[0] = 0
#define BCM89500_A0_MAC_TRUNK_CTLr_SET(r,d) (r).mac_trunk_ctl[0] = d
#define BCM89500_A0_MAC_TRUNK_CTLr_GET(r) (r).mac_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MAC_TRUNK_CTLr_HASH_SELf_GET(r) (((r).mac_trunk_ctl[0]) & 0x3)
#define BCM89500_A0_MAC_TRUNK_CTLr_HASH_SELf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_MAC_TRUNK_CTLr_SERVER_0f_GET(r) ((((r).mac_trunk_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_MAC_TRUNK_CTLr_SERVER_0f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).mac_trunk_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_MAC_TRUNK_CTLr_SERVER_1f_GET(r) ((((r).mac_trunk_ctl[0]) >> 4) & 0xf)
#define BCM89500_A0_MAC_TRUNK_CTLr_SERVER_1f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access MAC_TRUNK_CTL.
 *
 */
#define BCM89500_A0_READ_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MAC_TRUNK_CTLr,(r._mac_trunk_ctl),1)
#define BCM89500_A0_WRITE_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MAC_TRUNK_CTLr,&(r._mac_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TRUNK_CTLr BCM89500_A0_MAC_TRUNK_CTLr
#define MAC_TRUNK_CTLr_SIZE BCM89500_A0_MAC_TRUNK_CTLr_SIZE
typedef BCM89500_A0_MAC_TRUNK_CTLr_t MAC_TRUNK_CTLr_t;
#define MAC_TRUNK_CTLr_CLR BCM89500_A0_MAC_TRUNK_CTLr_CLR
#define MAC_TRUNK_CTLr_SET BCM89500_A0_MAC_TRUNK_CTLr_SET
#define MAC_TRUNK_CTLr_GET BCM89500_A0_MAC_TRUNK_CTLr_GET
#define MAC_TRUNK_CTLr_HASH_SELf_GET BCM89500_A0_MAC_TRUNK_CTLr_HASH_SELf_GET
#define MAC_TRUNK_CTLr_HASH_SELf_SET BCM89500_A0_MAC_TRUNK_CTLr_HASH_SELf_SET
#define MAC_TRUNK_CTLr_SERVER_0f_GET BCM89500_A0_MAC_TRUNK_CTLr_SERVER_0f_GET
#define MAC_TRUNK_CTLr_SERVER_0f_SET BCM89500_A0_MAC_TRUNK_CTLr_SERVER_0f_SET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM89500_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM89500_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define MAC_TRUNK_CTLr_SERVER_1f_GET BCM89500_A0_MAC_TRUNK_CTLr_SERVER_1f_GET
#define MAC_TRUNK_CTLr_SERVER_1f_SET BCM89500_A0_MAC_TRUNK_CTLr_SERVER_1f_SET
#define READ_MAC_TRUNK_CTLr BCM89500_A0_READ_MAC_TRUNK_CTLr
#define WRITE_MAC_TRUNK_CTLr BCM89500_A0_WRITE_MAC_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MAC_TRUNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  MARL_PBMP
 * BLOCKS:   SYS
 * DESC:     Multicast Table
 * SIZE:     29
 * FIELDS:
 *     PBMP             Multicast forwarding vector
 *
 ******************************************************************************/
#define BCM89500_A0_MARL_PBMPm 0x00000000

#define BCM89500_A0_MARL_PBMPm_MIN 0
#define BCM89500_A0_MARL_PBMPm_MAX 4095
#define BCM89500_A0_MARL_PBMPm_CMAX(u) 4095
#define BCM89500_A0_MARL_PBMPm_SIZE 4

/*
 * This structure should be used to declare and program MARL_PBMP.
 *
 */
typedef union BCM89500_A0_MARL_PBMPm_s {
	uint32_t v[1];
	uint32_t marl_pbmp[1];
	uint32_t _marl_pbmp;
} BCM89500_A0_MARL_PBMPm_t;

#define BCM89500_A0_MARL_PBMPm_CLR(r) (r).marl_pbmp[0] = 0
#define BCM89500_A0_MARL_PBMPm_SET(r,d) (r).marl_pbmp[0] = d
#define BCM89500_A0_MARL_PBMPm_GET(r) (r).marl_pbmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MARL_PBMPm_PBMPf_GET(r) (((r).marl_pbmp[0]) & 0x1fffffff)
#define BCM89500_A0_MARL_PBMPm_PBMPf_SET(r,f) (r).marl_pbmp[0]=(((r).marl_pbmp[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access MARL_PBMP.
 *
 */
#define BCM89500_A0_READ_MARL_PBMPm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_MARL_PBMPm,i,(m),4)
#define BCM89500_A0_WRITE_MARL_PBMPm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_MARL_PBMPm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARL_PBMPm BCM89500_A0_MARL_PBMPm
#define MARL_PBMPm_MIN BCM89500_A0_MARL_PBMPm_MIN
#define MARL_PBMPm_MAX BCM89500_A0_MARL_PBMPm_MAX
#define MARL_PBMPm_CMAX(u) BCM89500_A0_MARL_PBMPm_CMAX(u)
#define MARL_PBMPm_SIZE BCM89500_A0_MARL_PBMPm_SIZE
typedef BCM89500_A0_MARL_PBMPm_t MARL_PBMPm_t;
#define MARL_PBMPm_CLR BCM89500_A0_MARL_PBMPm_CLR
#define MARL_PBMPm_SET BCM89500_A0_MARL_PBMPm_SET
#define MARL_PBMPm_GET BCM89500_A0_MARL_PBMPm_GET
#define MARL_PBMPm_PBMPf_GET BCM89500_A0_MARL_PBMPm_PBMPf_GET
#define MARL_PBMPm_PBMPf_SET BCM89500_A0_MARL_PBMPm_PBMPf_SET
#define READ_MARL_PBMPm BCM89500_A0_READ_MARL_PBMPm
#define WRITE_MARL_PBMPm BCM89500_A0_WRITE_MARL_PBMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MARL_PBMPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MAX_ICMPV4_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv4 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV4_SIZE  MAX_ICMPv4_Size is programable between 0 and 9.6K bytes, inclusive. The default value is set to 512 bytes.
 *
 ******************************************************************************/
#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr 0x00003608

#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV4_SIZE_REG.
 *
 */
typedef union BCM89500_A0_MAX_ICMPV4_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv4_size_reg[1];
	uint32_t _max_icmpv4_size_reg;
} BCM89500_A0_MAX_ICMPV4_SIZE_REGr_t;

#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr_CLR(r) (r).max_icmpv4_size_reg[0] = 0
#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr_SET(r,d) (r).max_icmpv4_size_reg[0] = d
#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr_GET(r) (r).max_icmpv4_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET(r) ((r).max_icmpv4_size_reg[0])
#define BCM89500_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET(r,f) (r).max_icmpv4_size_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access MAX_ICMPV4_SIZE_REG.
 *
 */
#define BCM89500_A0_READ_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MAX_ICMPV4_SIZE_REGr,(r._max_icmpv4_size_reg),4)
#define BCM89500_A0_WRITE_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MAX_ICMPV4_SIZE_REGr,&(r._max_icmpv4_size_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV4_SIZE_REGr BCM89500_A0_MAX_ICMPV4_SIZE_REGr
#define MAX_ICMPV4_SIZE_REGr_SIZE BCM89500_A0_MAX_ICMPV4_SIZE_REGr_SIZE
typedef BCM89500_A0_MAX_ICMPV4_SIZE_REGr_t MAX_ICMPV4_SIZE_REGr_t;
#define MAX_ICMPV4_SIZE_REGr_CLR BCM89500_A0_MAX_ICMPV4_SIZE_REGr_CLR
#define MAX_ICMPV4_SIZE_REGr_SET BCM89500_A0_MAX_ICMPV4_SIZE_REGr_SET
#define MAX_ICMPV4_SIZE_REGr_GET BCM89500_A0_MAX_ICMPV4_SIZE_REGr_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET BCM89500_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET BCM89500_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET
#define READ_MAX_ICMPV4_SIZE_REGr BCM89500_A0_READ_MAX_ICMPV4_SIZE_REGr
#define WRITE_MAX_ICMPV4_SIZE_REGr BCM89500_A0_WRITE_MAX_ICMPV4_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MAX_ICMPV4_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MAX_ICMPV6_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv6 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV6_SIZE  MAX_ICMPv6_Size is programable between 0 and 9.6K bytes, inclusive. The default value is set to 512 bytes.
 *
 ******************************************************************************/
#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr 0x0000360c

#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV6_SIZE_REG.
 *
 */
typedef union BCM89500_A0_MAX_ICMPV6_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv6_size_reg[1];
	uint32_t _max_icmpv6_size_reg;
} BCM89500_A0_MAX_ICMPV6_SIZE_REGr_t;

#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr_CLR(r) (r).max_icmpv6_size_reg[0] = 0
#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr_SET(r,d) (r).max_icmpv6_size_reg[0] = d
#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr_GET(r) (r).max_icmpv6_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET(r) ((r).max_icmpv6_size_reg[0])
#define BCM89500_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET(r,f) (r).max_icmpv6_size_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access MAX_ICMPV6_SIZE_REG.
 *
 */
#define BCM89500_A0_READ_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MAX_ICMPV6_SIZE_REGr,(r._max_icmpv6_size_reg),4)
#define BCM89500_A0_WRITE_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MAX_ICMPV6_SIZE_REGr,&(r._max_icmpv6_size_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV6_SIZE_REGr BCM89500_A0_MAX_ICMPV6_SIZE_REGr
#define MAX_ICMPV6_SIZE_REGr_SIZE BCM89500_A0_MAX_ICMPV6_SIZE_REGr_SIZE
typedef BCM89500_A0_MAX_ICMPV6_SIZE_REGr_t MAX_ICMPV6_SIZE_REGr_t;
#define MAX_ICMPV6_SIZE_REGr_CLR BCM89500_A0_MAX_ICMPV6_SIZE_REGr_CLR
#define MAX_ICMPV6_SIZE_REGr_SET BCM89500_A0_MAX_ICMPV6_SIZE_REGr_SET
#define MAX_ICMPV6_SIZE_REGr_GET BCM89500_A0_MAX_ICMPV6_SIZE_REGr_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET BCM89500_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET BCM89500_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET
#define READ_MAX_ICMPV6_SIZE_REGr BCM89500_A0_READ_MAX_ICMPV6_SIZE_REGr
#define WRITE_MAX_ICMPV6_SIZE_REGr BCM89500_A0_WRITE_MAX_ICMPV6_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MAX_ICMPV6_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MDIO_IMP_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO Port IMP Address Register
 * SIZE:     8
 * FIELDS:
 *     ADDR_IMP         Port IMP MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MDIO_IMP_ADDRr 0x00000078

#define BCM89500_A0_MDIO_IMP_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_IMP_ADDR.
 *
 */
typedef union BCM89500_A0_MDIO_IMP_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_imp_addr[1];
	uint32_t _mdio_imp_addr;
} BCM89500_A0_MDIO_IMP_ADDRr_t;

#define BCM89500_A0_MDIO_IMP_ADDRr_CLR(r) (r).mdio_imp_addr[0] = 0
#define BCM89500_A0_MDIO_IMP_ADDRr_SET(r,d) (r).mdio_imp_addr[0] = d
#define BCM89500_A0_MDIO_IMP_ADDRr_GET(r) (r).mdio_imp_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MDIO_IMP_ADDRr_ADDR_IMPf_GET(r) (((r).mdio_imp_addr[0]) & 0x1f)
#define BCM89500_A0_MDIO_IMP_ADDRr_ADDR_IMPf_SET(r,f) (r).mdio_imp_addr[0]=(((r).mdio_imp_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_MDIO_IMP_ADDRr_RESERVEDf_GET(r) ((((r).mdio_imp_addr[0]) >> 5) & 0x7)
#define BCM89500_A0_MDIO_IMP_ADDRr_RESERVEDf_SET(r,f) (r).mdio_imp_addr[0]=(((r).mdio_imp_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_IMP_ADDR.
 *
 */
#define BCM89500_A0_READ_MDIO_IMP_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MDIO_IMP_ADDRr,(r._mdio_imp_addr),1)
#define BCM89500_A0_WRITE_MDIO_IMP_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MDIO_IMP_ADDRr,&(r._mdio_imp_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_IMP_ADDRr BCM89500_A0_MDIO_IMP_ADDRr
#define MDIO_IMP_ADDRr_SIZE BCM89500_A0_MDIO_IMP_ADDRr_SIZE
typedef BCM89500_A0_MDIO_IMP_ADDRr_t MDIO_IMP_ADDRr_t;
#define MDIO_IMP_ADDRr_CLR BCM89500_A0_MDIO_IMP_ADDRr_CLR
#define MDIO_IMP_ADDRr_SET BCM89500_A0_MDIO_IMP_ADDRr_SET
#define MDIO_IMP_ADDRr_GET BCM89500_A0_MDIO_IMP_ADDRr_GET
#define MDIO_IMP_ADDRr_ADDR_IMPf_GET BCM89500_A0_MDIO_IMP_ADDRr_ADDR_IMPf_GET
#define MDIO_IMP_ADDRr_ADDR_IMPf_SET BCM89500_A0_MDIO_IMP_ADDRr_ADDR_IMPf_SET
#define MDIO_IMP_ADDRr_RESERVEDf_GET BCM89500_A0_MDIO_IMP_ADDRr_RESERVEDf_GET
#define MDIO_IMP_ADDRr_RESERVEDf_SET BCM89500_A0_MDIO_IMP_ADDRr_RESERVEDf_SET
#define READ_MDIO_IMP_ADDRr BCM89500_A0_READ_MDIO_IMP_ADDRr
#define WRITE_MDIO_IMP_ADDRr BCM89500_A0_WRITE_MDIO_IMP_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MDIO_IMP_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MDIO_PORT4_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO Port 4 Address Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     ADDR_PORT4       Port 4 MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MDIO_PORT4_ADDRr 0x00000074

#define BCM89500_A0_MDIO_PORT4_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_PORT4_ADDR.
 *
 */
typedef union BCM89500_A0_MDIO_PORT4_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_port4_addr[1];
	uint32_t _mdio_port4_addr;
} BCM89500_A0_MDIO_PORT4_ADDRr_t;

#define BCM89500_A0_MDIO_PORT4_ADDRr_CLR(r) (r).mdio_port4_addr[0] = 0
#define BCM89500_A0_MDIO_PORT4_ADDRr_SET(r,d) (r).mdio_port4_addr[0] = d
#define BCM89500_A0_MDIO_PORT4_ADDRr_GET(r) (r).mdio_port4_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MDIO_PORT4_ADDRr_ADDR_PORT4f_GET(r) (((r).mdio_port4_addr[0]) & 0x1f)
#define BCM89500_A0_MDIO_PORT4_ADDRr_ADDR_PORT4f_SET(r,f) (r).mdio_port4_addr[0]=(((r).mdio_port4_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_MDIO_PORT4_ADDRr_RESERVEDf_GET(r) ((((r).mdio_port4_addr[0]) >> 5) & 0x7)
#define BCM89500_A0_MDIO_PORT4_ADDRr_RESERVEDf_SET(r,f) (r).mdio_port4_addr[0]=(((r).mdio_port4_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_PORT4_ADDR.
 *
 */
#define BCM89500_A0_READ_MDIO_PORT4_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MDIO_PORT4_ADDRr,(r._mdio_port4_addr),1)
#define BCM89500_A0_WRITE_MDIO_PORT4_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MDIO_PORT4_ADDRr,&(r._mdio_port4_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_PORT4_ADDRr BCM89500_A0_MDIO_PORT4_ADDRr
#define MDIO_PORT4_ADDRr_SIZE BCM89500_A0_MDIO_PORT4_ADDRr_SIZE
typedef BCM89500_A0_MDIO_PORT4_ADDRr_t MDIO_PORT4_ADDRr_t;
#define MDIO_PORT4_ADDRr_CLR BCM89500_A0_MDIO_PORT4_ADDRr_CLR
#define MDIO_PORT4_ADDRr_SET BCM89500_A0_MDIO_PORT4_ADDRr_SET
#define MDIO_PORT4_ADDRr_GET BCM89500_A0_MDIO_PORT4_ADDRr_GET
#define MDIO_PORT4_ADDRr_ADDR_PORT4f_GET BCM89500_A0_MDIO_PORT4_ADDRr_ADDR_PORT4f_GET
#define MDIO_PORT4_ADDRr_ADDR_PORT4f_SET BCM89500_A0_MDIO_PORT4_ADDRr_ADDR_PORT4f_SET
#define MDIO_PORT4_ADDRr_RESERVEDf_GET BCM89500_A0_MDIO_PORT4_ADDRr_RESERVEDf_GET
#define MDIO_PORT4_ADDRr_RESERVEDf_SET BCM89500_A0_MDIO_PORT4_ADDRr_RESERVEDf_SET
#define READ_MDIO_PORT4_ADDRr BCM89500_A0_READ_MDIO_PORT4_ADDRr
#define WRITE_MDIO_PORT4_ADDRr BCM89500_A0_WRITE_MDIO_PORT4_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MDIO_PORT4_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MDIO_PORT_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO Port N Address Register (Not2Release - only for Polar silicon DVT use)(polar feature)
 * SIZE:     8
 * FIELDS:
 *     ADDR_PORT        Port N MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MDIO_PORT_ADDRr 0x00000070

#define BCM89500_A0_MDIO_PORT_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_PORT_ADDR.
 *
 */
typedef union BCM89500_A0_MDIO_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_port_addr[1];
	uint32_t _mdio_port_addr;
} BCM89500_A0_MDIO_PORT_ADDRr_t;

#define BCM89500_A0_MDIO_PORT_ADDRr_CLR(r) (r).mdio_port_addr[0] = 0
#define BCM89500_A0_MDIO_PORT_ADDRr_SET(r,d) (r).mdio_port_addr[0] = d
#define BCM89500_A0_MDIO_PORT_ADDRr_GET(r) (r).mdio_port_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MDIO_PORT_ADDRr_ADDR_PORTf_GET(r) (((r).mdio_port_addr[0]) & 0x1f)
#define BCM89500_A0_MDIO_PORT_ADDRr_ADDR_PORTf_SET(r,f) (r).mdio_port_addr[0]=(((r).mdio_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_MDIO_PORT_ADDRr_RESERVEDf_GET(r) ((((r).mdio_port_addr[0]) >> 5) & 0x7)
#define BCM89500_A0_MDIO_PORT_ADDRr_RESERVEDf_SET(r,f) (r).mdio_port_addr[0]=(((r).mdio_port_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_PORT_ADDR.
 *
 */
#define BCM89500_A0_READ_MDIO_PORT_ADDRr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_MDIO_PORT_ADDRr+(1*(i)),(r._mdio_port_addr),1)
#define BCM89500_A0_WRITE_MDIO_PORT_ADDRr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_MDIO_PORT_ADDRr+(1*(i)),&(r._mdio_port_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_PORT_ADDRr BCM89500_A0_MDIO_PORT_ADDRr
#define MDIO_PORT_ADDRr_SIZE BCM89500_A0_MDIO_PORT_ADDRr_SIZE
typedef BCM89500_A0_MDIO_PORT_ADDRr_t MDIO_PORT_ADDRr_t;
#define MDIO_PORT_ADDRr_CLR BCM89500_A0_MDIO_PORT_ADDRr_CLR
#define MDIO_PORT_ADDRr_SET BCM89500_A0_MDIO_PORT_ADDRr_SET
#define MDIO_PORT_ADDRr_GET BCM89500_A0_MDIO_PORT_ADDRr_GET
#define MDIO_PORT_ADDRr_ADDR_PORTf_GET BCM89500_A0_MDIO_PORT_ADDRr_ADDR_PORTf_GET
#define MDIO_PORT_ADDRr_ADDR_PORTf_SET BCM89500_A0_MDIO_PORT_ADDRr_ADDR_PORTf_SET
#define MDIO_PORT_ADDRr_RESERVEDf_GET BCM89500_A0_MDIO_PORT_ADDRr_RESERVEDf_GET
#define MDIO_PORT_ADDRr_RESERVEDf_SET BCM89500_A0_MDIO_PORT_ADDRr_RESERVEDf_SET
#define READ_MDIO_PORT_ADDRr BCM89500_A0_READ_MDIO_PORT_ADDRr
#define WRITE_MDIO_PORT_ADDRr BCM89500_A0_WRITE_MDIO_PORT_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MDIO_PORT_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MDIO_WAN_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO WAN Port Address Register
 * SIZE:     8
 * FIELDS:
 *     ADDR_WAN         Wan-Port MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MDIO_WAN_ADDRr 0x00000075

#define BCM89500_A0_MDIO_WAN_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_WAN_ADDR.
 *
 */
typedef union BCM89500_A0_MDIO_WAN_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_wan_addr[1];
	uint32_t _mdio_wan_addr;
} BCM89500_A0_MDIO_WAN_ADDRr_t;

#define BCM89500_A0_MDIO_WAN_ADDRr_CLR(r) (r).mdio_wan_addr[0] = 0
#define BCM89500_A0_MDIO_WAN_ADDRr_SET(r,d) (r).mdio_wan_addr[0] = d
#define BCM89500_A0_MDIO_WAN_ADDRr_GET(r) (r).mdio_wan_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MDIO_WAN_ADDRr_ADDR_WANf_GET(r) (((r).mdio_wan_addr[0]) & 0x1f)
#define BCM89500_A0_MDIO_WAN_ADDRr_ADDR_WANf_SET(r,f) (r).mdio_wan_addr[0]=(((r).mdio_wan_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_MDIO_WAN_ADDRr_RESERVEDf_GET(r) ((((r).mdio_wan_addr[0]) >> 5) & 0x7)
#define BCM89500_A0_MDIO_WAN_ADDRr_RESERVEDf_SET(r,f) (r).mdio_wan_addr[0]=(((r).mdio_wan_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_WAN_ADDR.
 *
 */
#define BCM89500_A0_READ_MDIO_WAN_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MDIO_WAN_ADDRr,(r._mdio_wan_addr),1)
#define BCM89500_A0_WRITE_MDIO_WAN_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MDIO_WAN_ADDRr,&(r._mdio_wan_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_WAN_ADDRr BCM89500_A0_MDIO_WAN_ADDRr
#define MDIO_WAN_ADDRr_SIZE BCM89500_A0_MDIO_WAN_ADDRr_SIZE
typedef BCM89500_A0_MDIO_WAN_ADDRr_t MDIO_WAN_ADDRr_t;
#define MDIO_WAN_ADDRr_CLR BCM89500_A0_MDIO_WAN_ADDRr_CLR
#define MDIO_WAN_ADDRr_SET BCM89500_A0_MDIO_WAN_ADDRr_SET
#define MDIO_WAN_ADDRr_GET BCM89500_A0_MDIO_WAN_ADDRr_GET
#define MDIO_WAN_ADDRr_ADDR_WANf_GET BCM89500_A0_MDIO_WAN_ADDRr_ADDR_WANf_GET
#define MDIO_WAN_ADDRr_ADDR_WANf_SET BCM89500_A0_MDIO_WAN_ADDRr_ADDR_WANf_SET
#define MDIO_WAN_ADDRr_RESERVEDf_GET BCM89500_A0_MDIO_WAN_ADDRr_RESERVEDf_GET
#define MDIO_WAN_ADDRr_RESERVEDf_SET BCM89500_A0_MDIO_WAN_ADDRr_RESERVEDf_SET
#define READ_MDIO_WAN_ADDRr BCM89500_A0_READ_MDIO_WAN_ADDRr
#define WRITE_MDIO_WAN_ADDRr BCM89500_A0_WRITE_MDIO_WAN_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MDIO_WAN_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEMORY_TEST_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     ARL_TM           TM control[7:0] for ARL Table, AT0 and AT1
 *     BT_TM            TM control[7:0] for Buffer Tag, BT
 *     PB_TM            TM control[7:0] for Packet Buffer, PB
 *     TXQ_TM           TM control[7:0] for Transmit Queue, TXQ
 *     ACTRAT_TM        TM control[3:0] for Action RAMnd Rate RAM, ACT and RAT.
 *     EVT_TM           TM control[3:0] for EVT RAM, EVT
 *     STA_TM           TM control[3:0] for Statistic RAM, STS.
 *     VL_TM            TM control[3:0] for VLAN Table, VT
 *     RESERVED0        Reserved
 *     TCAM_TM          TM control[10:0] for TCAM, TCAM0 and TCAM1.
 *     RESERVED1        Reserved
 *     OTP_CPU_IF_EN    Enable OTP CPU Interface
 *
 ******************************************************************************/
#define BCM89500_A0_MEMORY_TEST_CTRLr 0x000000e0

#define BCM89500_A0_MEMORY_TEST_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MEMORY_TEST_CTRL.
 *
 */
typedef union BCM89500_A0_MEMORY_TEST_CTRLr_s {
	uint32_t v[2];
	uint32_t memory_test_ctrl[2];
	uint32_t _memory_test_ctrl;
} BCM89500_A0_MEMORY_TEST_CTRLr_t;

#define BCM89500_A0_MEMORY_TEST_CTRLr_CLR(r) CDK_MEMSET(&((r)._memory_test_ctrl), 0, sizeof(BCM89500_A0_MEMORY_TEST_CTRLr_t))
#define BCM89500_A0_MEMORY_TEST_CTRLr_SET(r,i,d) (r).memory_test_ctrl[i] = d
#define BCM89500_A0_MEMORY_TEST_CTRLr_GET(r,i) (r).memory_test_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEMORY_TEST_CTRLr_ARL_TMf_GET(r) (((r).memory_test_ctrl[0]) & 0xff)
#define BCM89500_A0_MEMORY_TEST_CTRLr_ARL_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_MEMORY_TEST_CTRLr_BT_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 8) & 0xff)
#define BCM89500_A0_MEMORY_TEST_CTRLr_BT_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_MEMORY_TEST_CTRLr_PB_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 16) & 0xff)
#define BCM89500_A0_MEMORY_TEST_CTRLr_PB_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_MEMORY_TEST_CTRLr_TXQ_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 24) & 0xff)
#define BCM89500_A0_MEMORY_TEST_CTRLr_TXQ_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM89500_A0_MEMORY_TEST_CTRLr_ACTRAT_TMf_GET(r) (((r).memory_test_ctrl[1]) & 0xf)
#define BCM89500_A0_MEMORY_TEST_CTRLr_ACTRAT_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_MEMORY_TEST_CTRLr_EVT_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 4) & 0xf)
#define BCM89500_A0_MEMORY_TEST_CTRLr_EVT_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_MEMORY_TEST_CTRLr_STA_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 8) & 0xf)
#define BCM89500_A0_MEMORY_TEST_CTRLr_STA_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_MEMORY_TEST_CTRLr_VL_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 12) & 0xf)
#define BCM89500_A0_MEMORY_TEST_CTRLr_VL_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED0f_GET(r) ((((r).memory_test_ctrl[1]) >> 16) & 0x7)
#define BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED0f_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM89500_A0_MEMORY_TEST_CTRLr_TCAM_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 19) & 0x7ff)
#define BCM89500_A0_MEMORY_TEST_CTRLr_TCAM_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x7ff << 19)) | ((((uint32_t)f) & 0x7ff) << 19))
#define BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED1f_GET(r) ((((r).memory_test_ctrl[1]) >> 30) & 0x1)
#define BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED1f_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET(r) ((((r).memory_test_ctrl[1]) >> 31) & 0x1)
#define BCM89500_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MEMORY_TEST_CTRL.
 *
 */
#define BCM89500_A0_READ_MEMORY_TEST_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEMORY_TEST_CTRLr,(r._memory_test_ctrl),8)
#define BCM89500_A0_WRITE_MEMORY_TEST_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEMORY_TEST_CTRLr,&(r._memory_test_ctrl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMORY_TEST_CTRLr BCM89500_A0_MEMORY_TEST_CTRLr
#define MEMORY_TEST_CTRLr_SIZE BCM89500_A0_MEMORY_TEST_CTRLr_SIZE
typedef BCM89500_A0_MEMORY_TEST_CTRLr_t MEMORY_TEST_CTRLr_t;
#define MEMORY_TEST_CTRLr_CLR BCM89500_A0_MEMORY_TEST_CTRLr_CLR
#define MEMORY_TEST_CTRLr_SET BCM89500_A0_MEMORY_TEST_CTRLr_SET
#define MEMORY_TEST_CTRLr_GET BCM89500_A0_MEMORY_TEST_CTRLr_GET
#define MEMORY_TEST_CTRLr_ARL_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_ARL_TMf_GET
#define MEMORY_TEST_CTRLr_ARL_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_ARL_TMf_SET
#define MEMORY_TEST_CTRLr_BT_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_BT_TMf_GET
#define MEMORY_TEST_CTRLr_BT_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_BT_TMf_SET
#define MEMORY_TEST_CTRLr_PB_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_PB_TMf_GET
#define MEMORY_TEST_CTRLr_PB_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_PB_TMf_SET
#define MEMORY_TEST_CTRLr_TXQ_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_TXQ_TMf_GET
#define MEMORY_TEST_CTRLr_TXQ_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_TXQ_TMf_SET
#define MEMORY_TEST_CTRLr_ACTRAT_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_ACTRAT_TMf_GET
#define MEMORY_TEST_CTRLr_ACTRAT_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_ACTRAT_TMf_SET
#define MEMORY_TEST_CTRLr_EVT_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_EVT_TMf_GET
#define MEMORY_TEST_CTRLr_EVT_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_EVT_TMf_SET
#define MEMORY_TEST_CTRLr_STA_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_STA_TMf_GET
#define MEMORY_TEST_CTRLr_STA_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_STA_TMf_SET
#define MEMORY_TEST_CTRLr_VL_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_VL_TMf_GET
#define MEMORY_TEST_CTRLr_VL_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_VL_TMf_SET
#define MEMORY_TEST_CTRLr_RESERVED0f_GET BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED0f_GET
#define MEMORY_TEST_CTRLr_RESERVED0f_SET BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED0f_SET
#define MEMORY_TEST_CTRLr_TCAM_TMf_GET BCM89500_A0_MEMORY_TEST_CTRLr_TCAM_TMf_GET
#define MEMORY_TEST_CTRLr_TCAM_TMf_SET BCM89500_A0_MEMORY_TEST_CTRLr_TCAM_TMf_SET
#define MEMORY_TEST_CTRLr_RESERVED1f_GET BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED1f_GET
#define MEMORY_TEST_CTRLr_RESERVED1f_SET BCM89500_A0_MEMORY_TEST_CTRLr_RESERVED1f_SET
#define MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET BCM89500_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET
#define MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET BCM89500_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET
#define READ_MEMORY_TEST_CTRLr BCM89500_A0_READ_MEMORY_TEST_CTRLr
#define WRITE_MEMORY_TEST_CTRLr BCM89500_A0_WRITE_MEMORY_TEST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEMORY_TEST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEMORY_TEST_CTRL_1
 * BLOCKS:   SYS
 * DESC:     Memory Test Control 1 Register (Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TCAM_CHKSUM_TM   TM control [3:0] for TCAM checksum
 *     CPU_RAM_TM       TM control [3:0] for CPU RAM
 *     CPU_ROM_TM       TM control [4:0] for CPU ROM
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MEMORY_TEST_CTRL_1r 0x000000ec

#define BCM89500_A0_MEMORY_TEST_CTRL_1r_SIZE 2

/*
 * This structure should be used to declare and program MEMORY_TEST_CTRL_1.
 *
 */
typedef union BCM89500_A0_MEMORY_TEST_CTRL_1r_s {
	uint32_t v[1];
	uint32_t memory_test_ctrl_1[1];
	uint32_t _memory_test_ctrl_1;
} BCM89500_A0_MEMORY_TEST_CTRL_1r_t;

#define BCM89500_A0_MEMORY_TEST_CTRL_1r_CLR(r) (r).memory_test_ctrl_1[0] = 0
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_SET(r,d) (r).memory_test_ctrl_1[0] = d
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_GET(r) (r).memory_test_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_TCAM_CHKSUM_TMf_GET(r) (((r).memory_test_ctrl_1[0]) & 0xf)
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_TCAM_CHKSUM_TMf_SET(r,f) (r).memory_test_ctrl_1[0]=(((r).memory_test_ctrl_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_RAM_TMf_GET(r) ((((r).memory_test_ctrl_1[0]) >> 4) & 0xf)
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_RAM_TMf_SET(r,f) (r).memory_test_ctrl_1[0]=(((r).memory_test_ctrl_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_ROM_TMf_GET(r) ((((r).memory_test_ctrl_1[0]) >> 8) & 0x1f)
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_ROM_TMf_SET(r,f) (r).memory_test_ctrl_1[0]=(((r).memory_test_ctrl_1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_RESERVEDf_GET(r) ((((r).memory_test_ctrl_1[0]) >> 13) & 0x7)
#define BCM89500_A0_MEMORY_TEST_CTRL_1r_RESERVEDf_SET(r,f) (r).memory_test_ctrl_1[0]=(((r).memory_test_ctrl_1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MEMORY_TEST_CTRL_1.
 *
 */
#define BCM89500_A0_READ_MEMORY_TEST_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEMORY_TEST_CTRL_1r,(r._memory_test_ctrl_1),2)
#define BCM89500_A0_WRITE_MEMORY_TEST_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEMORY_TEST_CTRL_1r,&(r._memory_test_ctrl_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMORY_TEST_CTRL_1r BCM89500_A0_MEMORY_TEST_CTRL_1r
#define MEMORY_TEST_CTRL_1r_SIZE BCM89500_A0_MEMORY_TEST_CTRL_1r_SIZE
typedef BCM89500_A0_MEMORY_TEST_CTRL_1r_t MEMORY_TEST_CTRL_1r_t;
#define MEMORY_TEST_CTRL_1r_CLR BCM89500_A0_MEMORY_TEST_CTRL_1r_CLR
#define MEMORY_TEST_CTRL_1r_SET BCM89500_A0_MEMORY_TEST_CTRL_1r_SET
#define MEMORY_TEST_CTRL_1r_GET BCM89500_A0_MEMORY_TEST_CTRL_1r_GET
#define MEMORY_TEST_CTRL_1r_TCAM_CHKSUM_TMf_GET BCM89500_A0_MEMORY_TEST_CTRL_1r_TCAM_CHKSUM_TMf_GET
#define MEMORY_TEST_CTRL_1r_TCAM_CHKSUM_TMf_SET BCM89500_A0_MEMORY_TEST_CTRL_1r_TCAM_CHKSUM_TMf_SET
#define MEMORY_TEST_CTRL_1r_CPU_RAM_TMf_GET BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_RAM_TMf_GET
#define MEMORY_TEST_CTRL_1r_CPU_RAM_TMf_SET BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_RAM_TMf_SET
#define MEMORY_TEST_CTRL_1r_CPU_ROM_TMf_GET BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_ROM_TMf_GET
#define MEMORY_TEST_CTRL_1r_CPU_ROM_TMf_SET BCM89500_A0_MEMORY_TEST_CTRL_1r_CPU_ROM_TMf_SET
#define MEMORY_TEST_CTRL_1r_RESERVEDf_GET BCM89500_A0_MEMORY_TEST_CTRL_1r_RESERVEDf_GET
#define MEMORY_TEST_CTRL_1r_RESERVEDf_SET BCM89500_A0_MEMORY_TEST_CTRL_1r_RESERVEDf_SET
#define READ_MEMORY_TEST_CTRL_1r BCM89500_A0_READ_MEMORY_TEST_CTRL_1r
#define WRITE_MEMORY_TEST_CTRL_1r BCM89500_A0_WRITE_MEMORY_TEST_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEMORY_TEST_CTRL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_ADDR
 * BLOCKS:   SYS
 * DESC:     Memory Debug Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_ADDRr 0x00000801

#define BCM89500_A0_MEM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR.
 *
 */
typedef union BCM89500_A0_MEM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_addr[1];
	uint32_t _mem_addr;
} BCM89500_A0_MEM_ADDRr_t;

#define BCM89500_A0_MEM_ADDRr_CLR(r) (r).mem_addr[0] = 0
#define BCM89500_A0_MEM_ADDRr_SET(r,d) (r).mem_addr[0] = d
#define BCM89500_A0_MEM_ADDRr_GET(r) (r).mem_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_ADDRr_MEM_ADRf_GET(r) (((r).mem_addr[0]) & 0x3fff)
#define BCM89500_A0_MEM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM89500_A0_MEM_ADDRr_MEM_RWf_GET(r) ((((r).mem_addr[0]) >> 14) & 0x1)
#define BCM89500_A0_MEM_ADDRr_MEM_RWf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_MEM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_addr[0]) >> 15) & 0x1)
#define BCM89500_A0_MEM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_ADDR.
 *
 */
#define BCM89500_A0_READ_MEM_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_ADDRr,(r._mem_addr),2)
#define BCM89500_A0_WRITE_MEM_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_ADDRr,&(r._mem_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDRr BCM89500_A0_MEM_ADDRr
#define MEM_ADDRr_SIZE BCM89500_A0_MEM_ADDRr_SIZE
typedef BCM89500_A0_MEM_ADDRr_t MEM_ADDRr_t;
#define MEM_ADDRr_CLR BCM89500_A0_MEM_ADDRr_CLR
#define MEM_ADDRr_SET BCM89500_A0_MEM_ADDRr_SET
#define MEM_ADDRr_GET BCM89500_A0_MEM_ADDRr_GET
#define MEM_ADDRr_MEM_ADRf_GET BCM89500_A0_MEM_ADDRr_MEM_ADRf_GET
#define MEM_ADDRr_MEM_ADRf_SET BCM89500_A0_MEM_ADDRr_MEM_ADRf_SET
#define MEM_ADDRr_MEM_RWf_GET BCM89500_A0_MEM_ADDRr_MEM_RWf_GET
#define MEM_ADDRr_MEM_RWf_SET BCM89500_A0_MEM_ADDRr_MEM_RWf_SET
#define MEM_ADDRr_MEM_STDNf_GET BCM89500_A0_MEM_ADDRr_MEM_STDNf_GET
#define MEM_ADDRr_MEM_STDNf_SET BCM89500_A0_MEM_ADDRr_MEM_STDNf_SET
#define READ_MEM_ADDRr BCM89500_A0_READ_MEM_ADDRr
#define WRITE_MEM_ADDRr BCM89500_A0_WRITE_MEM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_BFC_ADDR
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     BFC_ADDR         Specifies the next memmory address to read or write.
 *     RW_CTRL          '1' causes read operation while '0' is for write operation.
 *     MEM_REQ          Initiates the read/write operation for the Buffer Control memmory.The bit will clear one the Read/write Operation is completed.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_BFC_ADDRr 0x00000860

#define BCM89500_A0_MEM_BFC_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_BFC_ADDR.
 *
 */
typedef union BCM89500_A0_MEM_BFC_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_bfc_addr[1];
	uint32_t _mem_bfc_addr;
} BCM89500_A0_MEM_BFC_ADDRr_t;

#define BCM89500_A0_MEM_BFC_ADDRr_CLR(r) (r).mem_bfc_addr[0] = 0
#define BCM89500_A0_MEM_BFC_ADDRr_SET(r,d) (r).mem_bfc_addr[0] = d
#define BCM89500_A0_MEM_BFC_ADDRr_GET(r) (r).mem_bfc_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET(r) (((r).mem_bfc_addr[0]) & 0x3fff)
#define BCM89500_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM89500_A0_MEM_BFC_ADDRr_RW_CTRLf_GET(r) ((((r).mem_bfc_addr[0]) >> 14) & 0x1)
#define BCM89500_A0_MEM_BFC_ADDRr_RW_CTRLf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_MEM_BFC_ADDRr_MEM_REQf_GET(r) ((((r).mem_bfc_addr[0]) >> 15) & 0x1)
#define BCM89500_A0_MEM_BFC_ADDRr_MEM_REQf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_BFC_ADDR.
 *
 */
#define BCM89500_A0_READ_MEM_BFC_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_BFC_ADDRr,(r._mem_bfc_addr),2)
#define BCM89500_A0_WRITE_MEM_BFC_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_BFC_ADDRr,&(r._mem_bfc_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_ADDRr BCM89500_A0_MEM_BFC_ADDRr
#define MEM_BFC_ADDRr_SIZE BCM89500_A0_MEM_BFC_ADDRr_SIZE
typedef BCM89500_A0_MEM_BFC_ADDRr_t MEM_BFC_ADDRr_t;
#define MEM_BFC_ADDRr_CLR BCM89500_A0_MEM_BFC_ADDRr_CLR
#define MEM_BFC_ADDRr_SET BCM89500_A0_MEM_BFC_ADDRr_SET
#define MEM_BFC_ADDRr_GET BCM89500_A0_MEM_BFC_ADDRr_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_GET BCM89500_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_SET BCM89500_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET
#define MEM_BFC_ADDRr_RW_CTRLf_GET BCM89500_A0_MEM_BFC_ADDRr_RW_CTRLf_GET
#define MEM_BFC_ADDRr_RW_CTRLf_SET BCM89500_A0_MEM_BFC_ADDRr_RW_CTRLf_SET
#define MEM_BFC_ADDRr_MEM_REQf_GET BCM89500_A0_MEM_BFC_ADDRr_MEM_REQf_GET
#define MEM_BFC_ADDRr_MEM_REQf_SET BCM89500_A0_MEM_BFC_ADDRr_MEM_REQf_SET
#define READ_MEM_BFC_ADDRr BCM89500_A0_READ_MEM_BFC_ADDRr
#define WRITE_MEM_BFC_ADDRr BCM89500_A0_WRITE_MEM_BFC_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_BFC_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_BFC_DATA
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Data Register
 * SIZE:     64
 * FIELDS:
 *     BFC_DATA         Privides the read from the Buffer Control memmory[63:0].
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_BFC_DATAr 0x00000862

#define BCM89500_A0_MEM_BFC_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_BFC_DATA.
 *
 */
typedef union BCM89500_A0_MEM_BFC_DATAr_s {
	uint32_t v[2];
	uint32_t mem_bfc_data[2];
	uint32_t _mem_bfc_data;
} BCM89500_A0_MEM_BFC_DATAr_t;

#define BCM89500_A0_MEM_BFC_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_bfc_data), 0, sizeof(BCM89500_A0_MEM_BFC_DATAr_t))
#define BCM89500_A0_MEM_BFC_DATAr_SET(r,i,d) (r).mem_bfc_data[i] = d
#define BCM89500_A0_MEM_BFC_DATAr_GET(r,i) (r).mem_bfc_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_BFC_DATAr_BFC_DATAf_GET(r,a) cdk_field_get((r).mem_bfc_data,0,63,a)
#define BCM89500_A0_MEM_BFC_DATAr_BFC_DATAf_SET(r,a) cdk_field_set((r).mem_bfc_data,0,63,a)

/*
 * These macros can be used to access MEM_BFC_DATA.
 *
 */
#define BCM89500_A0_READ_MEM_BFC_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_BFC_DATAr,(r._mem_bfc_data),8)
#define BCM89500_A0_WRITE_MEM_BFC_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_BFC_DATAr,&(r._mem_bfc_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_DATAr BCM89500_A0_MEM_BFC_DATAr
#define MEM_BFC_DATAr_SIZE BCM89500_A0_MEM_BFC_DATAr_SIZE
typedef BCM89500_A0_MEM_BFC_DATAr_t MEM_BFC_DATAr_t;
#define MEM_BFC_DATAr_CLR BCM89500_A0_MEM_BFC_DATAr_CLR
#define MEM_BFC_DATAr_SET BCM89500_A0_MEM_BFC_DATAr_SET
#define MEM_BFC_DATAr_GET BCM89500_A0_MEM_BFC_DATAr_GET
#define MEM_BFC_DATAr_BFC_DATAf_GET BCM89500_A0_MEM_BFC_DATAr_BFC_DATAf_GET
#define MEM_BFC_DATAr_BFC_DATAf_SET BCM89500_A0_MEM_BFC_DATAr_BFC_DATAf_SET
#define READ_MEM_BFC_DATAr BCM89500_A0_READ_MEM_BFC_DATAr
#define WRITE_MEM_BFC_DATAr BCM89500_A0_WRITE_MEM_BFC_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_BFC_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_BTM_DATA0
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 0
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[63:0]Note: Buffer Tag Memory Register Only For Read.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_BTM_DATA0r 0x00000850

#define BCM89500_A0_MEM_BTM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_BTM_DATA0.
 *
 */
typedef union BCM89500_A0_MEM_BTM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_btm_data0[2];
	uint32_t _mem_btm_data0;
} BCM89500_A0_MEM_BTM_DATA0r_t;

#define BCM89500_A0_MEM_BTM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_btm_data0), 0, sizeof(BCM89500_A0_MEM_BTM_DATA0r_t))
#define BCM89500_A0_MEM_BTM_DATA0r_SET(r,i,d) (r).mem_btm_data0[i] = d
#define BCM89500_A0_MEM_BTM_DATA0r_GET(r,i) (r).mem_btm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_BTM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_btm_data0,0,63,a)
#define BCM89500_A0_MEM_BTM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_btm_data0,0,63,a)

/*
 * These macros can be used to access MEM_BTM_DATA0.
 *
 */
#define BCM89500_A0_READ_MEM_BTM_DATA0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_BTM_DATA0r,(r._mem_btm_data0),8)
#define BCM89500_A0_WRITE_MEM_BTM_DATA0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_BTM_DATA0r,&(r._mem_btm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA0r BCM89500_A0_MEM_BTM_DATA0r
#define MEM_BTM_DATA0r_SIZE BCM89500_A0_MEM_BTM_DATA0r_SIZE
typedef BCM89500_A0_MEM_BTM_DATA0r_t MEM_BTM_DATA0r_t;
#define MEM_BTM_DATA0r_CLR BCM89500_A0_MEM_BTM_DATA0r_CLR
#define MEM_BTM_DATA0r_SET BCM89500_A0_MEM_BTM_DATA0r_SET
#define MEM_BTM_DATA0r_GET BCM89500_A0_MEM_BTM_DATA0r_GET
#define MEM_BTM_DATA0r_MEM_DATAf_GET BCM89500_A0_MEM_BTM_DATA0r_MEM_DATAf_GET
#define MEM_BTM_DATA0r_MEM_DATAf_SET BCM89500_A0_MEM_BTM_DATA0r_MEM_DATAf_SET
#define READ_MEM_BTM_DATA0r BCM89500_A0_READ_MEM_BTM_DATA0r
#define WRITE_MEM_BTM_DATA0r BCM89500_A0_WRITE_MEM_BTM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_BTM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_BTM_DATA1
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 1
 * SIZE:     16
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[72:64]Note: Buffer Tag Memory Register Only For Read.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_BTM_DATA1r 0x00000858

#define BCM89500_A0_MEM_BTM_DATA1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_BTM_DATA1.
 *
 */
typedef union BCM89500_A0_MEM_BTM_DATA1r_s {
	uint32_t v[1];
	uint32_t mem_btm_data1[1];
	uint32_t _mem_btm_data1;
} BCM89500_A0_MEM_BTM_DATA1r_t;

#define BCM89500_A0_MEM_BTM_DATA1r_CLR(r) (r).mem_btm_data1[0] = 0
#define BCM89500_A0_MEM_BTM_DATA1r_SET(r,d) (r).mem_btm_data1[0] = d
#define BCM89500_A0_MEM_BTM_DATA1r_GET(r) (r).mem_btm_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_BTM_DATA1r_MEM_DATAf_GET(r) (((r).mem_btm_data1[0]) & 0x1ff)
#define BCM89500_A0_MEM_BTM_DATA1r_MEM_DATAf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MEM_BTM_DATA1r_RESERVEDf_GET(r) ((((r).mem_btm_data1[0]) >> 9) & 0x7f)
#define BCM89500_A0_MEM_BTM_DATA1r_RESERVEDf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MEM_BTM_DATA1.
 *
 */
#define BCM89500_A0_READ_MEM_BTM_DATA1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_BTM_DATA1r,(r._mem_btm_data1),2)
#define BCM89500_A0_WRITE_MEM_BTM_DATA1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_BTM_DATA1r,&(r._mem_btm_data1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA1r BCM89500_A0_MEM_BTM_DATA1r
#define MEM_BTM_DATA1r_SIZE BCM89500_A0_MEM_BTM_DATA1r_SIZE
typedef BCM89500_A0_MEM_BTM_DATA1r_t MEM_BTM_DATA1r_t;
#define MEM_BTM_DATA1r_CLR BCM89500_A0_MEM_BTM_DATA1r_CLR
#define MEM_BTM_DATA1r_SET BCM89500_A0_MEM_BTM_DATA1r_SET
#define MEM_BTM_DATA1r_GET BCM89500_A0_MEM_BTM_DATA1r_GET
#define MEM_BTM_DATA1r_MEM_DATAf_GET BCM89500_A0_MEM_BTM_DATA1r_MEM_DATAf_GET
#define MEM_BTM_DATA1r_MEM_DATAf_SET BCM89500_A0_MEM_BTM_DATA1r_MEM_DATAf_SET
#define MEM_BTM_DATA1r_RESERVEDf_GET BCM89500_A0_MEM_BTM_DATA1r_RESERVEDf_GET
#define MEM_BTM_DATA1r_RESERVEDf_SET BCM89500_A0_MEM_BTM_DATA1r_RESERVEDf_SET
#define READ_MEM_BTM_DATA1r BCM89500_A0_READ_MEM_BTM_DATA1r
#define WRITE_MEM_BTM_DATA1r BCM89500_A0_WRITE_MEM_BTM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_BTM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *     MEM_TYPE         Indicate the memory for the Debugged memory.00 : Internal CPU ROM Memory(ROM table is Read-only)01 : Internal CPU RAM Memory10 : 1Q-VLAN Memory11 : ARL MemoryOthers : Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_CTRLr 0x00000800

#define BCM89500_A0_MEM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_CTRL.
 *
 */
typedef union BCM89500_A0_MEM_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_ctrl[1];
	uint32_t _mem_ctrl;
} BCM89500_A0_MEM_CTRLr_t;

#define BCM89500_A0_MEM_CTRLr_CLR(r) (r).mem_ctrl[0] = 0
#define BCM89500_A0_MEM_CTRLr_SET(r,d) (r).mem_ctrl[0] = d
#define BCM89500_A0_MEM_CTRLr_GET(r) (r).mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_CTRLr_RESERVED_0f_GET(r) (((r).mem_ctrl[0]) & 0xf)
#define BCM89500_A0_MEM_CTRLr_RESERVED_0f_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_MEM_CTRLr_RESERVED_1f_GET(r) ((((r).mem_ctrl[0]) >> 4) & 0x3)
#define BCM89500_A0_MEM_CTRLr_RESERVED_1f_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_MEM_CTRLr_MEM_TYPEf_GET(r) ((((r).mem_ctrl[0]) >> 6) & 0x3)
#define BCM89500_A0_MEM_CTRLr_MEM_TYPEf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MEM_CTRL.
 *
 */
#define BCM89500_A0_READ_MEM_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_CTRLr,(r._mem_ctrl),1)
#define BCM89500_A0_WRITE_MEM_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_CTRLr,&(r._mem_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_CTRLr BCM89500_A0_MEM_CTRLr
#define MEM_CTRLr_SIZE BCM89500_A0_MEM_CTRLr_SIZE
typedef BCM89500_A0_MEM_CTRLr_t MEM_CTRLr_t;
#define MEM_CTRLr_CLR BCM89500_A0_MEM_CTRLr_CLR
#define MEM_CTRLr_SET BCM89500_A0_MEM_CTRLr_SET
#define MEM_CTRLr_GET BCM89500_A0_MEM_CTRLr_GET
#define MEM_CTRLr_RESERVED_0f_GET BCM89500_A0_MEM_CTRLr_RESERVED_0f_GET
#define MEM_CTRLr_RESERVED_0f_SET BCM89500_A0_MEM_CTRLr_RESERVED_0f_SET
#define MEM_CTRLr_RESERVED_1f_GET BCM89500_A0_MEM_CTRLr_RESERVED_1f_GET
#define MEM_CTRLr_RESERVED_1f_SET BCM89500_A0_MEM_CTRLr_RESERVED_1f_SET
#define MEM_CTRLr_MEM_TYPEf_GET BCM89500_A0_MEM_CTRLr_MEM_TYPEf_GET
#define MEM_CTRLr_MEM_TYPEf_SET BCM89500_A0_MEM_CTRLr_MEM_TYPEf_SET
#define READ_MEM_CTRLr BCM89500_A0_READ_MEM_CTRLr
#define WRITE_MEM_CTRLr BCM89500_A0_WRITE_MEM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_DEBUG_DATA_0_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0].For ARL, this field specifies the entry 0 bit[63:0].For VLAN, this field specifies the VLAN entry [11:0].For Internal CPU RAM, this field specifies the bit[63:0].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_DEBUG_DATA_0_0r 0x00000808

#define BCM89500_A0_MEM_DEBUG_DATA_0_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_0.
 *
 */
typedef union BCM89500_A0_MEM_DEBUG_DATA_0_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_0_0[2];
	uint32_t _mem_debug_data_0_0;
} BCM89500_A0_MEM_DEBUG_DATA_0_0r_t;

#define BCM89500_A0_MEM_DEBUG_DATA_0_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_0_0), 0, sizeof(BCM89500_A0_MEM_DEBUG_DATA_0_0r_t))
#define BCM89500_A0_MEM_DEBUG_DATA_0_0r_SET(r,i,d) (r).mem_debug_data_0_0[i] = d
#define BCM89500_A0_MEM_DEBUG_DATA_0_0r_GET(r,i) (r).mem_debug_data_0_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_0_0,0,63,a)
#define BCM89500_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_0_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_0.
 *
 */
#define BCM89500_A0_READ_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_DEBUG_DATA_0_0r,(r._mem_debug_data_0_0),8)
#define BCM89500_A0_WRITE_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_DEBUG_DATA_0_0r,&(r._mem_debug_data_0_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_0r BCM89500_A0_MEM_DEBUG_DATA_0_0r
#define MEM_DEBUG_DATA_0_0r_SIZE BCM89500_A0_MEM_DEBUG_DATA_0_0r_SIZE
typedef BCM89500_A0_MEM_DEBUG_DATA_0_0r_t MEM_DEBUG_DATA_0_0r_t;
#define MEM_DEBUG_DATA_0_0r_CLR BCM89500_A0_MEM_DEBUG_DATA_0_0r_CLR
#define MEM_DEBUG_DATA_0_0r_SET BCM89500_A0_MEM_DEBUG_DATA_0_0r_SET
#define MEM_DEBUG_DATA_0_0r_GET BCM89500_A0_MEM_DEBUG_DATA_0_0r_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_GET BCM89500_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_SET BCM89500_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_0r BCM89500_A0_READ_MEM_DEBUG_DATA_0_0r
#define WRITE_MEM_DEBUG_DATA_0_0r BCM89500_A0_WRITE_MEM_DEBUG_DATA_0_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_DEBUG_DATA_0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_DEBUG_DATA_0_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory.For ARL, this field specifies the entry 0 bit[65:64].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_DEBUG_DATA_0_1r 0x00000810

#define BCM89500_A0_MEM_DEBUG_DATA_0_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_1.
 *
 */
typedef union BCM89500_A0_MEM_DEBUG_DATA_0_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_0_1[1];
	uint32_t _mem_debug_data_0_1;
} BCM89500_A0_MEM_DEBUG_DATA_0_1r_t;

#define BCM89500_A0_MEM_DEBUG_DATA_0_1r_CLR(r) (r).mem_debug_data_0_1[0] = 0
#define BCM89500_A0_MEM_DEBUG_DATA_0_1r_SET(r,d) (r).mem_debug_data_0_1[0] = d
#define BCM89500_A0_MEM_DEBUG_DATA_0_1r_GET(r) (r).mem_debug_data_0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET(r) (((r).mem_debug_data_0_1[0]) & 0xffff)
#define BCM89500_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_0_1[0]=(((r).mem_debug_data_0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_1.
 *
 */
#define BCM89500_A0_READ_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_DEBUG_DATA_0_1r,(r._mem_debug_data_0_1),2)
#define BCM89500_A0_WRITE_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_DEBUG_DATA_0_1r,&(r._mem_debug_data_0_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_1r BCM89500_A0_MEM_DEBUG_DATA_0_1r
#define MEM_DEBUG_DATA_0_1r_SIZE BCM89500_A0_MEM_DEBUG_DATA_0_1r_SIZE
typedef BCM89500_A0_MEM_DEBUG_DATA_0_1r_t MEM_DEBUG_DATA_0_1r_t;
#define MEM_DEBUG_DATA_0_1r_CLR BCM89500_A0_MEM_DEBUG_DATA_0_1r_CLR
#define MEM_DEBUG_DATA_0_1r_SET BCM89500_A0_MEM_DEBUG_DATA_0_1r_SET
#define MEM_DEBUG_DATA_0_1r_GET BCM89500_A0_MEM_DEBUG_DATA_0_1r_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_GET BCM89500_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_SET BCM89500_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_1r BCM89500_A0_READ_MEM_DEBUG_DATA_0_1r
#define WRITE_MEM_DEBUG_DATA_0_1r BCM89500_A0_WRITE_MEM_DEBUG_DATA_0_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_DEBUG_DATA_0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_DEBUG_DATA_1_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory.For ARL, this field specifies the entry 1 bit[63:0].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_DEBUG_DATA_1_0r 0x00000812

#define BCM89500_A0_MEM_DEBUG_DATA_1_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_0.
 *
 */
typedef union BCM89500_A0_MEM_DEBUG_DATA_1_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_1_0[2];
	uint32_t _mem_debug_data_1_0;
} BCM89500_A0_MEM_DEBUG_DATA_1_0r_t;

#define BCM89500_A0_MEM_DEBUG_DATA_1_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_1_0), 0, sizeof(BCM89500_A0_MEM_DEBUG_DATA_1_0r_t))
#define BCM89500_A0_MEM_DEBUG_DATA_1_0r_SET(r,i,d) (r).mem_debug_data_1_0[i] = d
#define BCM89500_A0_MEM_DEBUG_DATA_1_0r_GET(r,i) (r).mem_debug_data_1_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_1_0,0,63,a)
#define BCM89500_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_1_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_0.
 *
 */
#define BCM89500_A0_READ_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_DEBUG_DATA_1_0r,(r._mem_debug_data_1_0),8)
#define BCM89500_A0_WRITE_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_DEBUG_DATA_1_0r,&(r._mem_debug_data_1_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_0r BCM89500_A0_MEM_DEBUG_DATA_1_0r
#define MEM_DEBUG_DATA_1_0r_SIZE BCM89500_A0_MEM_DEBUG_DATA_1_0r_SIZE
typedef BCM89500_A0_MEM_DEBUG_DATA_1_0r_t MEM_DEBUG_DATA_1_0r_t;
#define MEM_DEBUG_DATA_1_0r_CLR BCM89500_A0_MEM_DEBUG_DATA_1_0r_CLR
#define MEM_DEBUG_DATA_1_0r_SET BCM89500_A0_MEM_DEBUG_DATA_1_0r_SET
#define MEM_DEBUG_DATA_1_0r_GET BCM89500_A0_MEM_DEBUG_DATA_1_0r_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_GET BCM89500_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_SET BCM89500_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_0r BCM89500_A0_READ_MEM_DEBUG_DATA_1_0r
#define WRITE_MEM_DEBUG_DATA_1_0r BCM89500_A0_WRITE_MEM_DEBUG_DATA_1_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_DEBUG_DATA_1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_DEBUG_DATA_1_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory.For ARL, this field specifies the entry 1 bit[65:64].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_DEBUG_DATA_1_1r 0x0000081a

#define BCM89500_A0_MEM_DEBUG_DATA_1_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_1.
 *
 */
typedef union BCM89500_A0_MEM_DEBUG_DATA_1_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_1_1[1];
	uint32_t _mem_debug_data_1_1;
} BCM89500_A0_MEM_DEBUG_DATA_1_1r_t;

#define BCM89500_A0_MEM_DEBUG_DATA_1_1r_CLR(r) (r).mem_debug_data_1_1[0] = 0
#define BCM89500_A0_MEM_DEBUG_DATA_1_1r_SET(r,d) (r).mem_debug_data_1_1[0] = d
#define BCM89500_A0_MEM_DEBUG_DATA_1_1r_GET(r) (r).mem_debug_data_1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET(r) (((r).mem_debug_data_1_1[0]) & 0xffff)
#define BCM89500_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_1_1[0]=(((r).mem_debug_data_1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_1.
 *
 */
#define BCM89500_A0_READ_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_DEBUG_DATA_1_1r,(r._mem_debug_data_1_1),2)
#define BCM89500_A0_WRITE_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_DEBUG_DATA_1_1r,&(r._mem_debug_data_1_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_1r BCM89500_A0_MEM_DEBUG_DATA_1_1r
#define MEM_DEBUG_DATA_1_1r_SIZE BCM89500_A0_MEM_DEBUG_DATA_1_1r_SIZE
typedef BCM89500_A0_MEM_DEBUG_DATA_1_1r_t MEM_DEBUG_DATA_1_1r_t;
#define MEM_DEBUG_DATA_1_1r_CLR BCM89500_A0_MEM_DEBUG_DATA_1_1r_CLR
#define MEM_DEBUG_DATA_1_1r_SET BCM89500_A0_MEM_DEBUG_DATA_1_1r_SET
#define MEM_DEBUG_DATA_1_1r_GET BCM89500_A0_MEM_DEBUG_DATA_1_1r_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_GET BCM89500_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_SET BCM89500_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_1r BCM89500_A0_READ_MEM_DEBUG_DATA_1_1r
#define WRITE_MEM_DEBUG_DATA_1_1r BCM89500_A0_WRITE_MEM_DEBUG_DATA_1_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_DEBUG_DATA_1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_FRM_ADDR
 * BLOCKS:   SYS
 * DESC:     Frame Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     RESERVED         Reserved
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the FM memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_FRM_ADDRr 0x00000820

#define BCM89500_A0_MEM_FRM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_FRM_ADDR.
 *
 */
typedef union BCM89500_A0_MEM_FRM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_frm_addr[1];
	uint32_t _mem_frm_addr;
} BCM89500_A0_MEM_FRM_ADDRr_t;

#define BCM89500_A0_MEM_FRM_ADDRr_CLR(r) (r).mem_frm_addr[0] = 0
#define BCM89500_A0_MEM_FRM_ADDRr_SET(r,d) (r).mem_frm_addr[0] = d
#define BCM89500_A0_MEM_FRM_ADDRr_GET(r) (r).mem_frm_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_FRM_ADDRr_MEM_ADRf_GET(r) (((r).mem_frm_addr[0]) & 0xfff)
#define BCM89500_A0_MEM_FRM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_MEM_FRM_ADDRr_RESERVEDf_GET(r) ((((r).mem_frm_addr[0]) >> 12) & 0x3)
#define BCM89500_A0_MEM_FRM_ADDRr_RESERVEDf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_MEM_FRM_ADDRr_MEM_RWf_GET(r) ((((r).mem_frm_addr[0]) >> 14) & 0x1)
#define BCM89500_A0_MEM_FRM_ADDRr_MEM_RWf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_MEM_FRM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_frm_addr[0]) >> 15) & 0x1)
#define BCM89500_A0_MEM_FRM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_FRM_ADDR.
 *
 */
#define BCM89500_A0_READ_MEM_FRM_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_FRM_ADDRr,(r._mem_frm_addr),2)
#define BCM89500_A0_WRITE_MEM_FRM_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_FRM_ADDRr,&(r._mem_frm_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_ADDRr BCM89500_A0_MEM_FRM_ADDRr
#define MEM_FRM_ADDRr_SIZE BCM89500_A0_MEM_FRM_ADDRr_SIZE
typedef BCM89500_A0_MEM_FRM_ADDRr_t MEM_FRM_ADDRr_t;
#define MEM_FRM_ADDRr_CLR BCM89500_A0_MEM_FRM_ADDRr_CLR
#define MEM_FRM_ADDRr_SET BCM89500_A0_MEM_FRM_ADDRr_SET
#define MEM_FRM_ADDRr_GET BCM89500_A0_MEM_FRM_ADDRr_GET
#define MEM_FRM_ADDRr_MEM_ADRf_GET BCM89500_A0_MEM_FRM_ADDRr_MEM_ADRf_GET
#define MEM_FRM_ADDRr_MEM_ADRf_SET BCM89500_A0_MEM_FRM_ADDRr_MEM_ADRf_SET
#define MEM_FRM_ADDRr_RESERVEDf_GET BCM89500_A0_MEM_FRM_ADDRr_RESERVEDf_GET
#define MEM_FRM_ADDRr_RESERVEDf_SET BCM89500_A0_MEM_FRM_ADDRr_RESERVEDf_SET
#define MEM_FRM_ADDRr_MEM_RWf_GET BCM89500_A0_MEM_FRM_ADDRr_MEM_RWf_GET
#define MEM_FRM_ADDRr_MEM_RWf_SET BCM89500_A0_MEM_FRM_ADDRr_MEM_RWf_SET
#define MEM_FRM_ADDRr_MEM_STDNf_GET BCM89500_A0_MEM_FRM_ADDRr_MEM_STDNf_GET
#define MEM_FRM_ADDRr_MEM_STDNf_SET BCM89500_A0_MEM_FRM_ADDRr_MEM_STDNf_SET
#define READ_MEM_FRM_ADDRr BCM89500_A0_READ_MEM_FRM_ADDRr
#define WRITE_MEM_FRM_ADDRr BCM89500_A0_WRITE_MEM_FRM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_FRM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_FRM_DATA0
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 1st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[63:0].
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_FRM_DATA0r 0x00000830

#define BCM89500_A0_MEM_FRM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA0.
 *
 */
typedef union BCM89500_A0_MEM_FRM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_frm_data0[2];
	uint32_t _mem_frm_data0;
} BCM89500_A0_MEM_FRM_DATA0r_t;

#define BCM89500_A0_MEM_FRM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data0), 0, sizeof(BCM89500_A0_MEM_FRM_DATA0r_t))
#define BCM89500_A0_MEM_FRM_DATA0r_SET(r,i,d) (r).mem_frm_data0[i] = d
#define BCM89500_A0_MEM_FRM_DATA0r_GET(r,i) (r).mem_frm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_FRM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data0,0,63,a)
#define BCM89500_A0_MEM_FRM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data0,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA0.
 *
 */
#define BCM89500_A0_READ_MEM_FRM_DATA0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_FRM_DATA0r,(r._mem_frm_data0),8)
#define BCM89500_A0_WRITE_MEM_FRM_DATA0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_FRM_DATA0r,&(r._mem_frm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA0r BCM89500_A0_MEM_FRM_DATA0r
#define MEM_FRM_DATA0r_SIZE BCM89500_A0_MEM_FRM_DATA0r_SIZE
typedef BCM89500_A0_MEM_FRM_DATA0r_t MEM_FRM_DATA0r_t;
#define MEM_FRM_DATA0r_CLR BCM89500_A0_MEM_FRM_DATA0r_CLR
#define MEM_FRM_DATA0r_SET BCM89500_A0_MEM_FRM_DATA0r_SET
#define MEM_FRM_DATA0r_GET BCM89500_A0_MEM_FRM_DATA0r_GET
#define MEM_FRM_DATA0r_MEM_DATAf_GET BCM89500_A0_MEM_FRM_DATA0r_MEM_DATAf_GET
#define MEM_FRM_DATA0r_MEM_DATAf_SET BCM89500_A0_MEM_FRM_DATA0r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA0r BCM89500_A0_READ_MEM_FRM_DATA0r
#define WRITE_MEM_FRM_DATA0r BCM89500_A0_WRITE_MEM_FRM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_FRM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_FRM_DATA1
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 2st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[127:64].
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_FRM_DATA1r 0x00000838

#define BCM89500_A0_MEM_FRM_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA1.
 *
 */
typedef union BCM89500_A0_MEM_FRM_DATA1r_s {
	uint32_t v[2];
	uint32_t mem_frm_data1[2];
	uint32_t _mem_frm_data1;
} BCM89500_A0_MEM_FRM_DATA1r_t;

#define BCM89500_A0_MEM_FRM_DATA1r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data1), 0, sizeof(BCM89500_A0_MEM_FRM_DATA1r_t))
#define BCM89500_A0_MEM_FRM_DATA1r_SET(r,i,d) (r).mem_frm_data1[i] = d
#define BCM89500_A0_MEM_FRM_DATA1r_GET(r,i) (r).mem_frm_data1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_FRM_DATA1r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data1,0,63,a)
#define BCM89500_A0_MEM_FRM_DATA1r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data1,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA1.
 *
 */
#define BCM89500_A0_READ_MEM_FRM_DATA1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_FRM_DATA1r,(r._mem_frm_data1),8)
#define BCM89500_A0_WRITE_MEM_FRM_DATA1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_FRM_DATA1r,&(r._mem_frm_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA1r BCM89500_A0_MEM_FRM_DATA1r
#define MEM_FRM_DATA1r_SIZE BCM89500_A0_MEM_FRM_DATA1r_SIZE
typedef BCM89500_A0_MEM_FRM_DATA1r_t MEM_FRM_DATA1r_t;
#define MEM_FRM_DATA1r_CLR BCM89500_A0_MEM_FRM_DATA1r_CLR
#define MEM_FRM_DATA1r_SET BCM89500_A0_MEM_FRM_DATA1r_SET
#define MEM_FRM_DATA1r_GET BCM89500_A0_MEM_FRM_DATA1r_GET
#define MEM_FRM_DATA1r_MEM_DATAf_GET BCM89500_A0_MEM_FRM_DATA1r_MEM_DATAf_GET
#define MEM_FRM_DATA1r_MEM_DATAf_SET BCM89500_A0_MEM_FRM_DATA1r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA1r BCM89500_A0_READ_MEM_FRM_DATA1r
#define WRITE_MEM_FRM_DATA1r BCM89500_A0_WRITE_MEM_FRM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_FRM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_FRM_DATA2
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 3st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[191:128].
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_FRM_DATA2r 0x00000840

#define BCM89500_A0_MEM_FRM_DATA2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA2.
 *
 */
typedef union BCM89500_A0_MEM_FRM_DATA2r_s {
	uint32_t v[2];
	uint32_t mem_frm_data2[2];
	uint32_t _mem_frm_data2;
} BCM89500_A0_MEM_FRM_DATA2r_t;

#define BCM89500_A0_MEM_FRM_DATA2r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data2), 0, sizeof(BCM89500_A0_MEM_FRM_DATA2r_t))
#define BCM89500_A0_MEM_FRM_DATA2r_SET(r,i,d) (r).mem_frm_data2[i] = d
#define BCM89500_A0_MEM_FRM_DATA2r_GET(r,i) (r).mem_frm_data2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_FRM_DATA2r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data2,0,63,a)
#define BCM89500_A0_MEM_FRM_DATA2r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data2,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA2.
 *
 */
#define BCM89500_A0_READ_MEM_FRM_DATA2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_FRM_DATA2r,(r._mem_frm_data2),8)
#define BCM89500_A0_WRITE_MEM_FRM_DATA2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_FRM_DATA2r,&(r._mem_frm_data2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA2r BCM89500_A0_MEM_FRM_DATA2r
#define MEM_FRM_DATA2r_SIZE BCM89500_A0_MEM_FRM_DATA2r_SIZE
typedef BCM89500_A0_MEM_FRM_DATA2r_t MEM_FRM_DATA2r_t;
#define MEM_FRM_DATA2r_CLR BCM89500_A0_MEM_FRM_DATA2r_CLR
#define MEM_FRM_DATA2r_SET BCM89500_A0_MEM_FRM_DATA2r_SET
#define MEM_FRM_DATA2r_GET BCM89500_A0_MEM_FRM_DATA2r_GET
#define MEM_FRM_DATA2r_MEM_DATAf_GET BCM89500_A0_MEM_FRM_DATA2r_MEM_DATAf_GET
#define MEM_FRM_DATA2r_MEM_DATAf_SET BCM89500_A0_MEM_FRM_DATA2r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA2r BCM89500_A0_READ_MEM_FRM_DATA2r
#define WRITE_MEM_FRM_DATA2r BCM89500_A0_WRITE_MEM_FRM_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_FRM_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MEM_FRM_DATA3
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 4th Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[255:192].
 *
 ******************************************************************************/
#define BCM89500_A0_MEM_FRM_DATA3r 0x00000848

#define BCM89500_A0_MEM_FRM_DATA3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA3.
 *
 */
typedef union BCM89500_A0_MEM_FRM_DATA3r_s {
	uint32_t v[2];
	uint32_t mem_frm_data3[2];
	uint32_t _mem_frm_data3;
} BCM89500_A0_MEM_FRM_DATA3r_t;

#define BCM89500_A0_MEM_FRM_DATA3r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data3), 0, sizeof(BCM89500_A0_MEM_FRM_DATA3r_t))
#define BCM89500_A0_MEM_FRM_DATA3r_SET(r,i,d) (r).mem_frm_data3[i] = d
#define BCM89500_A0_MEM_FRM_DATA3r_GET(r,i) (r).mem_frm_data3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MEM_FRM_DATA3r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data3,0,63,a)
#define BCM89500_A0_MEM_FRM_DATA3r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data3,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA3.
 *
 */
#define BCM89500_A0_READ_MEM_FRM_DATA3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MEM_FRM_DATA3r,(r._mem_frm_data3),8)
#define BCM89500_A0_WRITE_MEM_FRM_DATA3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MEM_FRM_DATA3r,&(r._mem_frm_data3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA3r BCM89500_A0_MEM_FRM_DATA3r
#define MEM_FRM_DATA3r_SIZE BCM89500_A0_MEM_FRM_DATA3r_SIZE
typedef BCM89500_A0_MEM_FRM_DATA3r_t MEM_FRM_DATA3r_t;
#define MEM_FRM_DATA3r_CLR BCM89500_A0_MEM_FRM_DATA3r_CLR
#define MEM_FRM_DATA3r_SET BCM89500_A0_MEM_FRM_DATA3r_SET
#define MEM_FRM_DATA3r_GET BCM89500_A0_MEM_FRM_DATA3r_GET
#define MEM_FRM_DATA3r_MEM_DATAf_GET BCM89500_A0_MEM_FRM_DATA3r_MEM_DATAf_GET
#define MEM_FRM_DATA3r_MEM_DATAf_SET BCM89500_A0_MEM_FRM_DATA3r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA3r BCM89500_A0_READ_MEM_FRM_DATA3r
#define WRITE_MEM_FRM_DATA3r BCM89500_A0_WRITE_MEM_FRM_DATA3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MEM_FRM_DATA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MIB_GD_FM_MAX_SIZE
 * BLOCKS:   SYS
 * DESC:     Jumbo MIB Good Frame Max Size Registers
 * SIZE:     16
 * FIELDS:
 *     MAX_SIZE         Standard Max. Frame Size.The Register defines the Standard MAX. Frame Size for MAC and MIB counter.The register should be either 14'd1518 or 14'd2000.When jumbo is disable, the MAC and MIB counter use this field to check for good frame size.When this field is 1518, the tagged frames will be dropped if the frame size is lager than 1522 bytes; and the untagged frames willbe dropped if the frame size is larger than 1518 bytes.when this field is 2000, both tagged or untagged frames will be dropped if the frame size is larger than 2000 bytes.when jumbo is enable, all the frames will be dropped if the frame size is larger than 9720B.The Register setting will affect those MIB counting includingin RxSAChangeRxgoodOctetsRxUnicastPktsRxMulticastPktsRxBroadcastPktsRxOverSizePkts
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr 0x00004005

#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_SIZE 2

/*
 * This structure should be used to declare and program MIB_GD_FM_MAX_SIZE.
 *
 */
typedef union BCM89500_A0_MIB_GD_FM_MAX_SIZEr_s {
	uint32_t v[1];
	uint32_t mib_gd_fm_max_size[1];
	uint32_t _mib_gd_fm_max_size;
} BCM89500_A0_MIB_GD_FM_MAX_SIZEr_t;

#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_CLR(r) (r).mib_gd_fm_max_size[0] = 0
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_SET(r,d) (r).mib_gd_fm_max_size[0] = d
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_GET(r) (r).mib_gd_fm_max_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET(r) (((r).mib_gd_fm_max_size[0]) & 0x3fff)
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET(r) ((((r).mib_gd_fm_max_size[0]) >> 14) & 0x3)
#define BCM89500_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access MIB_GD_FM_MAX_SIZE.
 *
 */
#define BCM89500_A0_READ_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MIB_GD_FM_MAX_SIZEr,(r._mib_gd_fm_max_size),2)
#define BCM89500_A0_WRITE_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MIB_GD_FM_MAX_SIZEr,&(r._mib_gd_fm_max_size),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_GD_FM_MAX_SIZEr BCM89500_A0_MIB_GD_FM_MAX_SIZEr
#define MIB_GD_FM_MAX_SIZEr_SIZE BCM89500_A0_MIB_GD_FM_MAX_SIZEr_SIZE
typedef BCM89500_A0_MIB_GD_FM_MAX_SIZEr_t MIB_GD_FM_MAX_SIZEr_t;
#define MIB_GD_FM_MAX_SIZEr_CLR BCM89500_A0_MIB_GD_FM_MAX_SIZEr_CLR
#define MIB_GD_FM_MAX_SIZEr_SET BCM89500_A0_MIB_GD_FM_MAX_SIZEr_SET
#define MIB_GD_FM_MAX_SIZEr_GET BCM89500_A0_MIB_GD_FM_MAX_SIZEr_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET BCM89500_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET BCM89500_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET
#define MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET BCM89500_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET
#define MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET BCM89500_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET
#define READ_MIB_GD_FM_MAX_SIZEr BCM89500_A0_READ_MIB_GD_FM_MAX_SIZEr
#define WRITE_MIB_GD_FM_MAX_SIZEr BCM89500_A0_WRITE_MIB_GD_FM_MAX_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MIB_GD_FM_MAX_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Control Register
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     RESERVED         
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but data from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDONE  Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 *
 ******************************************************************************/
#define BCM89500_A0_MIB_SNAPSHOT_CTLr 0x00007000

#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 *
 */
typedef union BCM89500_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM89500_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM89500_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0xf)
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 4) & 0x3)
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 *
 */
#define BCM89500_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM89500_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM89500_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM89500_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM89500_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM89500_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM89500_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM89500_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_GET BCM89500_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_SET BCM89500_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET BCM89500_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM89500_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM89500_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MIB_SNAPSHOT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MINIMUM_TCP_HDR_SZ
 * BLOCKS:   SYS
 * DESC:     Minimum TCP Header Size Register
 * SIZE:     8
 * FIELDS:
 *     MIN_TCP_HDR_SZ   MIN_TCP_Header_Size is programable between 0 and 255 bytes, inclusive. The default value is set to 20 bytes(TCP header without options).
 *
 ******************************************************************************/
#define BCM89500_A0_MINIMUM_TCP_HDR_SZr 0x00003604

#define BCM89500_A0_MINIMUM_TCP_HDR_SZr_SIZE 1

/*
 * This structure should be used to declare and program MINIMUM_TCP_HDR_SZ.
 *
 */
typedef union BCM89500_A0_MINIMUM_TCP_HDR_SZr_s {
	uint32_t v[1];
	uint32_t minimum_tcp_hdr_sz[1];
	uint32_t _minimum_tcp_hdr_sz;
} BCM89500_A0_MINIMUM_TCP_HDR_SZr_t;

#define BCM89500_A0_MINIMUM_TCP_HDR_SZr_CLR(r) (r).minimum_tcp_hdr_sz[0] = 0
#define BCM89500_A0_MINIMUM_TCP_HDR_SZr_SET(r,d) (r).minimum_tcp_hdr_sz[0] = d
#define BCM89500_A0_MINIMUM_TCP_HDR_SZr_GET(r) (r).minimum_tcp_hdr_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET(r) (((r).minimum_tcp_hdr_sz[0]) & 0xff)
#define BCM89500_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET(r,f) (r).minimum_tcp_hdr_sz[0]=(((r).minimum_tcp_hdr_sz[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MINIMUM_TCP_HDR_SZ.
 *
 */
#define BCM89500_A0_READ_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MINIMUM_TCP_HDR_SZr,(r._minimum_tcp_hdr_sz),1)
#define BCM89500_A0_WRITE_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MINIMUM_TCP_HDR_SZr,&(r._minimum_tcp_hdr_sz),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINIMUM_TCP_HDR_SZr BCM89500_A0_MINIMUM_TCP_HDR_SZr
#define MINIMUM_TCP_HDR_SZr_SIZE BCM89500_A0_MINIMUM_TCP_HDR_SZr_SIZE
typedef BCM89500_A0_MINIMUM_TCP_HDR_SZr_t MINIMUM_TCP_HDR_SZr_t;
#define MINIMUM_TCP_HDR_SZr_CLR BCM89500_A0_MINIMUM_TCP_HDR_SZr_CLR
#define MINIMUM_TCP_HDR_SZr_SET BCM89500_A0_MINIMUM_TCP_HDR_SZr_SET
#define MINIMUM_TCP_HDR_SZr_GET BCM89500_A0_MINIMUM_TCP_HDR_SZr_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET BCM89500_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET BCM89500_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET
#define READ_MINIMUM_TCP_HDR_SZr BCM89500_A0_READ_MINIMUM_TCP_HDR_SZr
#define WRITE_MINIMUM_TCP_HDR_SZr BCM89500_A0_WRITE_MINIMUM_TCP_HDR_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MINIMUM_TCP_HDR_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     16
 * FIELDS:
 *     SMIR_CAP_PORT    Mirror Capture Port ID.Port ID which identifies the single unique port which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *     BLK_NOT_MIR      When Enabled, all traffic to Mirror_Capture_Port will be blocked except mirror traffic.
 *     MIR_EN           Global enable/disable for all mirroring on this chip.When reset, mirroring is disabled.When set, mirroring is enabled according to the ingress and egress control rules, to the port designated by the MIRROR_CAPTURE_PORT.
 *
 ******************************************************************************/
#define BCM89500_A0_MIRCAPCTLr 0x00000210

#define BCM89500_A0_MIRCAPCTLr_SIZE 2

/*
 * This structure should be used to declare and program MIRCAPCTL.
 *
 */
typedef union BCM89500_A0_MIRCAPCTLr_s {
	uint32_t v[1];
	uint32_t mircapctl[1];
	uint32_t _mircapctl;
} BCM89500_A0_MIRCAPCTLr_t;

#define BCM89500_A0_MIRCAPCTLr_CLR(r) (r).mircapctl[0] = 0
#define BCM89500_A0_MIRCAPCTLr_SET(r,d) (r).mircapctl[0] = d
#define BCM89500_A0_MIRCAPCTLr_GET(r) (r).mircapctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET(r) (((r).mircapctl[0]) & 0xf)
#define BCM89500_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_MIRCAPCTLr_RESERVED_0f_GET(r) ((((r).mircapctl[0]) >> 4) & 0x3)
#define BCM89500_A0_MIRCAPCTLr_RESERVED_0f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_MIRCAPCTLr_RESERVED_1f_GET(r) ((((r).mircapctl[0]) >> 6) & 0xff)
#define BCM89500_A0_MIRCAPCTLr_RESERVED_1f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM89500_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET(r) ((((r).mircapctl[0]) >> 14) & 0x1)
#define BCM89500_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_MIRCAPCTLr_MIR_ENf_GET(r) ((((r).mircapctl[0]) >> 15) & 0x1)
#define BCM89500_A0_MIRCAPCTLr_MIR_ENf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIRCAPCTL.
 *
 */
#define BCM89500_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MIRCAPCTLr,(r._mircapctl),2)
#define BCM89500_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MIRCAPCTLr,&(r._mircapctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM89500_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM89500_A0_MIRCAPCTLr_SIZE
typedef BCM89500_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM89500_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM89500_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM89500_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_GET BCM89500_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_SET BCM89500_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET
#define MIRCAPCTLr_RESERVED_0f_GET BCM89500_A0_MIRCAPCTLr_RESERVED_0f_GET
#define MIRCAPCTLr_RESERVED_0f_SET BCM89500_A0_MIRCAPCTLr_RESERVED_0f_SET
#define MIRCAPCTLr_RESERVED_1f_GET BCM89500_A0_MIRCAPCTLr_RESERVED_1f_GET
#define MIRCAPCTLr_RESERVED_1f_SET BCM89500_A0_MIRCAPCTLr_RESERVED_1f_SET
#define MIRCAPCTLr_BLK_NOT_MIRf_GET BCM89500_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET
#define MIRCAPCTLr_BLK_NOT_MIRf_SET BCM89500_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET
#define MIRCAPCTLr_MIR_ENf_GET BCM89500_A0_MIRCAPCTLr_MIR_ENf_GET
#define MIRCAPCTLr_MIR_ENf_SET BCM89500_A0_MIRCAPCTLr_MIR_ENf_SET
#define READ_MIRCAPCTLr BCM89500_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM89500_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MIRCAPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MLF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Multicast Lookup Failed Forward Map Register
 * SIZE:     16
 * FIELDS:
 *     MUL_LOOKUP_FAIL_FRW_MAP Multicast Lookup Failed Forward Map.When Multicat lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register setting.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MLF_DROP_MAPr 0x00000034

#define BCM89500_A0_MLF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_DROP_MAP.
 *
 */
typedef union BCM89500_A0_MLF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_drop_map[1];
	uint32_t _mlf_drop_map;
} BCM89500_A0_MLF_DROP_MAPr_t;

#define BCM89500_A0_MLF_DROP_MAPr_CLR(r) (r).mlf_drop_map[0] = 0
#define BCM89500_A0_MLF_DROP_MAPr_SET(r,d) (r).mlf_drop_map[0] = d
#define BCM89500_A0_MLF_DROP_MAPr_GET(r) (r).mlf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET(r) (((r).mlf_drop_map[0]) & 0x1ff)
#define BCM89500_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MLF_DROP_MAPr_RESERVEDf_GET(r) ((((r).mlf_drop_map[0]) >> 9) & 0x7f)
#define BCM89500_A0_MLF_DROP_MAPr_RESERVEDf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_DROP_MAP.
 *
 */
#define BCM89500_A0_READ_MLF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MLF_DROP_MAPr,(r._mlf_drop_map),2)
#define BCM89500_A0_WRITE_MLF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MLF_DROP_MAPr,&(r._mlf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_DROP_MAPr BCM89500_A0_MLF_DROP_MAPr
#define MLF_DROP_MAPr_SIZE BCM89500_A0_MLF_DROP_MAPr_SIZE
typedef BCM89500_A0_MLF_DROP_MAPr_t MLF_DROP_MAPr_t;
#define MLF_DROP_MAPr_CLR BCM89500_A0_MLF_DROP_MAPr_CLR
#define MLF_DROP_MAPr_SET BCM89500_A0_MLF_DROP_MAPr_SET
#define MLF_DROP_MAPr_GET BCM89500_A0_MLF_DROP_MAPr_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET BCM89500_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET BCM89500_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET
#define MLF_DROP_MAPr_RESERVEDf_GET BCM89500_A0_MLF_DROP_MAPr_RESERVEDf_GET
#define MLF_DROP_MAPr_RESERVEDf_SET BCM89500_A0_MLF_DROP_MAPr_RESERVEDf_SET
#define READ_MLF_DROP_MAPr BCM89500_A0_READ_MLF_DROP_MAPr
#define WRITE_MLF_DROP_MAPr BCM89500_A0_WRITE_MLF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MLF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MLF_IPMC_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     IPMC Forward Map Register
 * SIZE:     16
 * FIELDS:
 *     MLF_IPMC_FWD_MAP IPMC Forward map.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MLF_IPMC_FWD_MAPr 0x00000036

#define BCM89500_A0_MLF_IPMC_FWD_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_IPMC_FWD_MAP.
 *
 */
typedef union BCM89500_A0_MLF_IPMC_FWD_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_ipmc_fwd_map[1];
	uint32_t _mlf_ipmc_fwd_map;
} BCM89500_A0_MLF_IPMC_FWD_MAPr_t;

#define BCM89500_A0_MLF_IPMC_FWD_MAPr_CLR(r) (r).mlf_ipmc_fwd_map[0] = 0
#define BCM89500_A0_MLF_IPMC_FWD_MAPr_SET(r,d) (r).mlf_ipmc_fwd_map[0] = d
#define BCM89500_A0_MLF_IPMC_FWD_MAPr_GET(r) (r).mlf_ipmc_fwd_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET(r) (((r).mlf_ipmc_fwd_map[0]) & 0x1ff)
#define BCM89500_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_GET(r) ((((r).mlf_ipmc_fwd_map[0]) >> 9) & 0x7f)
#define BCM89500_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_IPMC_FWD_MAP.
 *
 */
#define BCM89500_A0_READ_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MLF_IPMC_FWD_MAPr,(r._mlf_ipmc_fwd_map),2)
#define BCM89500_A0_WRITE_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MLF_IPMC_FWD_MAPr,&(r._mlf_ipmc_fwd_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_IPMC_FWD_MAPr BCM89500_A0_MLF_IPMC_FWD_MAPr
#define MLF_IPMC_FWD_MAPr_SIZE BCM89500_A0_MLF_IPMC_FWD_MAPr_SIZE
typedef BCM89500_A0_MLF_IPMC_FWD_MAPr_t MLF_IPMC_FWD_MAPr_t;
#define MLF_IPMC_FWD_MAPr_CLR BCM89500_A0_MLF_IPMC_FWD_MAPr_CLR
#define MLF_IPMC_FWD_MAPr_SET BCM89500_A0_MLF_IPMC_FWD_MAPr_SET
#define MLF_IPMC_FWD_MAPr_GET BCM89500_A0_MLF_IPMC_FWD_MAPr_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET BCM89500_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET BCM89500_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET
#define MLF_IPMC_FWD_MAPr_RESERVEDf_GET BCM89500_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_GET
#define MLF_IPMC_FWD_MAPr_RESERVEDf_SET BCM89500_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_SET
#define READ_MLF_IPMC_FWD_MAPr BCM89500_A0_READ_MLF_IPMC_FWD_MAPr
#define WRITE_MLF_IPMC_FWD_MAPr BCM89500_A0_WRITE_MLF_IPMC_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MLF_IPMC_FWD_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MODEL_ID
 * BLOCKS:   SYS
 * DESC:     Model ID Register
 * SIZE:     32
 * FIELDS:
 *     MODELID          Chip Model ID 0x89500 for BCM895000x89501 for BCM895010x89200 for BCM89200
 *
 ******************************************************************************/
#define BCM89500_A0_MODEL_IDr 0x00000230

#define BCM89500_A0_MODEL_IDr_SIZE 4

/*
 * This structure should be used to declare and program MODEL_ID.
 *
 */
typedef union BCM89500_A0_MODEL_IDr_s {
	uint32_t v[1];
	uint32_t model_id[1];
	uint32_t _model_id;
} BCM89500_A0_MODEL_IDr_t;

#define BCM89500_A0_MODEL_IDr_CLR(r) (r).model_id[0] = 0
#define BCM89500_A0_MODEL_IDr_SET(r,d) (r).model_id[0] = d
#define BCM89500_A0_MODEL_IDr_GET(r) (r).model_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MODEL_IDr_MODELIDf_GET(r) ((r).model_id[0])
#define BCM89500_A0_MODEL_IDr_MODELIDf_SET(r,f) (r).model_id[0]=((uint32_t)f)

/*
 * These macros can be used to access MODEL_ID.
 *
 */
#define BCM89500_A0_READ_MODEL_IDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MODEL_IDr,(r._model_id),4)
#define BCM89500_A0_WRITE_MODEL_IDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MODEL_IDr,&(r._model_id),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODEL_IDr BCM89500_A0_MODEL_IDr
#define MODEL_IDr_SIZE BCM89500_A0_MODEL_IDr_SIZE
typedef BCM89500_A0_MODEL_IDr_t MODEL_IDr_t;
#define MODEL_IDr_CLR BCM89500_A0_MODEL_IDr_CLR
#define MODEL_IDr_SET BCM89500_A0_MODEL_IDr_SET
#define MODEL_IDr_GET BCM89500_A0_MODEL_IDr_GET
#define MODEL_IDr_MODELIDf_GET BCM89500_A0_MODEL_IDr_MODELIDf_GET
#define MODEL_IDr_MODELIDf_SET BCM89500_A0_MODEL_IDr_MODELIDf_SET
#define READ_MODEL_IDr BCM89500_A0_READ_MODEL_IDr
#define WRITE_MODEL_IDr BCM89500_A0_WRITE_MODEL_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MODEL_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MODULE_ID0
 * BLOCKS:   SYS
 * DESC:     Module ID 0 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_SA           48 bit SA for module ID.
 *
 ******************************************************************************/
#define BCM89500_A0_MODULE_ID0r 0x00007205

#define BCM89500_A0_MODULE_ID0r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID0.
 *
 */
typedef union BCM89500_A0_MODULE_ID0r_s {
	uint32_t v[2];
	uint32_t module_id0[2];
	uint32_t _module_id0;
} BCM89500_A0_MODULE_ID0r_t;

#define BCM89500_A0_MODULE_ID0r_CLR(r) CDK_MEMSET(&((r)._module_id0), 0, sizeof(BCM89500_A0_MODULE_ID0r_t))
#define BCM89500_A0_MODULE_ID0r_SET(r,i,d) (r).module_id0[i] = d
#define BCM89500_A0_MODULE_ID0r_GET(r,i) (r).module_id0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MODULE_ID0r_MID_SAf_GET(r,a) cdk_field_get((r).module_id0,0,47,a)
#define BCM89500_A0_MODULE_ID0r_MID_SAf_SET(r,a) cdk_field_set((r).module_id0,0,47,a)

/*
 * These macros can be used to access MODULE_ID0.
 *
 */
#define BCM89500_A0_READ_MODULE_ID0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MODULE_ID0r,(r._module_id0),6)
#define BCM89500_A0_WRITE_MODULE_ID0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MODULE_ID0r,&(r._module_id0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID0r BCM89500_A0_MODULE_ID0r
#define MODULE_ID0r_SIZE BCM89500_A0_MODULE_ID0r_SIZE
typedef BCM89500_A0_MODULE_ID0r_t MODULE_ID0r_t;
#define MODULE_ID0r_CLR BCM89500_A0_MODULE_ID0r_CLR
#define MODULE_ID0r_SET BCM89500_A0_MODULE_ID0r_SET
#define MODULE_ID0r_GET BCM89500_A0_MODULE_ID0r_GET
#define MODULE_ID0r_MID_SAf_GET BCM89500_A0_MODULE_ID0r_MID_SAf_GET
#define MODULE_ID0r_MID_SAf_SET BCM89500_A0_MODULE_ID0r_MID_SAf_SET
#define READ_MODULE_ID0r BCM89500_A0_READ_MODULE_ID0r
#define WRITE_MODULE_ID0r BCM89500_A0_WRITE_MODULE_ID0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MODULE_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MODULE_ID1
 * BLOCKS:   SYS
 * DESC:     Module ID 1 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_CRC          32 bits CRC for module ID.
 *     MID_PORTNUM      8 bit portnum for module ID.
 *     RESERVED         Reserved
 *     MID_AVAIL        module ID available , once 1 st packet received.1 : available.0 : unavailable, wait for 1st packet.
 *
 ******************************************************************************/
#define BCM89500_A0_MODULE_ID1r 0x0000720b

#define BCM89500_A0_MODULE_ID1r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID1.
 *
 */
typedef union BCM89500_A0_MODULE_ID1r_s {
	uint32_t v[2];
	uint32_t module_id1[2];
	uint32_t _module_id1;
} BCM89500_A0_MODULE_ID1r_t;

#define BCM89500_A0_MODULE_ID1r_CLR(r) CDK_MEMSET(&((r)._module_id1), 0, sizeof(BCM89500_A0_MODULE_ID1r_t))
#define BCM89500_A0_MODULE_ID1r_SET(r,i,d) (r).module_id1[i] = d
#define BCM89500_A0_MODULE_ID1r_GET(r,i) (r).module_id1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MODULE_ID1r_MID_CRCf_GET(r) ((r).module_id1[0])
#define BCM89500_A0_MODULE_ID1r_MID_CRCf_SET(r,f) (r).module_id1[0]=((uint32_t)f)
#define BCM89500_A0_MODULE_ID1r_MID_PORTNUMf_GET(r) (((r).module_id1[1]) & 0xff)
#define BCM89500_A0_MODULE_ID1r_MID_PORTNUMf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_MODULE_ID1r_RESERVEDf_GET(r) ((((r).module_id1[1]) >> 8) & 0x7f)
#define BCM89500_A0_MODULE_ID1r_RESERVEDf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM89500_A0_MODULE_ID1r_MID_AVAILf_GET(r) ((((r).module_id1[1]) >> 15) & 0x1)
#define BCM89500_A0_MODULE_ID1r_MID_AVAILf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MODULE_ID1.
 *
 */
#define BCM89500_A0_READ_MODULE_ID1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MODULE_ID1r,(r._module_id1),6)
#define BCM89500_A0_WRITE_MODULE_ID1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MODULE_ID1r,&(r._module_id1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID1r BCM89500_A0_MODULE_ID1r
#define MODULE_ID1r_SIZE BCM89500_A0_MODULE_ID1r_SIZE
typedef BCM89500_A0_MODULE_ID1r_t MODULE_ID1r_t;
#define MODULE_ID1r_CLR BCM89500_A0_MODULE_ID1r_CLR
#define MODULE_ID1r_SET BCM89500_A0_MODULE_ID1r_SET
#define MODULE_ID1r_GET BCM89500_A0_MODULE_ID1r_GET
#define MODULE_ID1r_MID_CRCf_GET BCM89500_A0_MODULE_ID1r_MID_CRCf_GET
#define MODULE_ID1r_MID_CRCf_SET BCM89500_A0_MODULE_ID1r_MID_CRCf_SET
#define MODULE_ID1r_MID_PORTNUMf_GET BCM89500_A0_MODULE_ID1r_MID_PORTNUMf_GET
#define MODULE_ID1r_MID_PORTNUMf_SET BCM89500_A0_MODULE_ID1r_MID_PORTNUMf_SET
#define MODULE_ID1r_RESERVEDf_GET BCM89500_A0_MODULE_ID1r_RESERVEDf_GET
#define MODULE_ID1r_RESERVEDf_SET BCM89500_A0_MODULE_ID1r_RESERVEDf_SET
#define MODULE_ID1r_MID_AVAILf_GET BCM89500_A0_MODULE_ID1r_MID_AVAILf_GET
#define MODULE_ID1r_MID_AVAILf_SET BCM89500_A0_MODULE_ID1r_MID_AVAILf_SET
#define READ_MODULE_ID1r BCM89500_A0_READ_MODULE_ID1r
#define WRITE_MODULE_ID1r BCM89500_A0_WRITE_MODULE_ID1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MODULE_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MPORTVEC0
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 0.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 0 register will be forwarded to each port with a bit set in the Multiport Vector 0 bit map.Bits 0-5: Port 0-5.Bit 6: reserved.Bit 7: Port 7. (polar feature)Bit 8: Port 8 (IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MPORTVEC0r 0x00000418

#define BCM89500_A0_MPORTVEC0r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC0.
 *
 */
typedef union BCM89500_A0_MPORTVEC0r_s {
	uint32_t v[1];
	uint32_t mportvec0[1];
	uint32_t _mportvec0;
} BCM89500_A0_MPORTVEC0r_t;

#define BCM89500_A0_MPORTVEC0r_CLR(r) (r).mportvec0[0] = 0
#define BCM89500_A0_MPORTVEC0r_SET(r,d) (r).mportvec0[0] = d
#define BCM89500_A0_MPORTVEC0r_GET(r) (r).mportvec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MPORTVEC0r_PORT_VCTRf_GET(r) (((r).mportvec0[0]) & 0x1ff)
#define BCM89500_A0_MPORTVEC0r_PORT_VCTRf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MPORTVEC0r_RESERVEDf_GET(r) ((((r).mportvec0[0]) >> 9) & 0x7fffff)
#define BCM89500_A0_MPORTVEC0r_RESERVEDf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC0.
 *
 */
#define BCM89500_A0_READ_MPORTVEC0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MPORTVEC0r,(r._mportvec0),4)
#define BCM89500_A0_WRITE_MPORTVEC0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MPORTVEC0r,&(r._mportvec0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC0r BCM89500_A0_MPORTVEC0r
#define MPORTVEC0r_SIZE BCM89500_A0_MPORTVEC0r_SIZE
typedef BCM89500_A0_MPORTVEC0r_t MPORTVEC0r_t;
#define MPORTVEC0r_CLR BCM89500_A0_MPORTVEC0r_CLR
#define MPORTVEC0r_SET BCM89500_A0_MPORTVEC0r_SET
#define MPORTVEC0r_GET BCM89500_A0_MPORTVEC0r_GET
#define MPORTVEC0r_PORT_VCTRf_GET BCM89500_A0_MPORTVEC0r_PORT_VCTRf_GET
#define MPORTVEC0r_PORT_VCTRf_SET BCM89500_A0_MPORTVEC0r_PORT_VCTRf_SET
#define MPORTVEC0r_RESERVEDf_GET BCM89500_A0_MPORTVEC0r_RESERVEDf_GET
#define MPORTVEC0r_RESERVEDf_SET BCM89500_A0_MPORTVEC0r_RESERVEDf_SET
#define READ_MPORTVEC0r BCM89500_A0_READ_MPORTVEC0r
#define WRITE_MPORTVEC0r BCM89500_A0_WRITE_MPORTVEC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MPORTVEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MPORTVEC1
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 1A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 1 register will be forwarded to each port with a bit set in the Multiport Vector 1 bit map.Bits 0-5: Port 0-5.Bit 6: reserved.Bit 7: Port 7. (polar feature)Bit 8: Port 8(IMP)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MPORTVEC1r 0x00000428

#define BCM89500_A0_MPORTVEC1r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC1.
 *
 */
typedef union BCM89500_A0_MPORTVEC1r_s {
	uint32_t v[1];
	uint32_t mportvec1[1];
	uint32_t _mportvec1;
} BCM89500_A0_MPORTVEC1r_t;

#define BCM89500_A0_MPORTVEC1r_CLR(r) (r).mportvec1[0] = 0
#define BCM89500_A0_MPORTVEC1r_SET(r,d) (r).mportvec1[0] = d
#define BCM89500_A0_MPORTVEC1r_GET(r) (r).mportvec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MPORTVEC1r_PORT_VCTRf_GET(r) (((r).mportvec1[0]) & 0x1ff)
#define BCM89500_A0_MPORTVEC1r_PORT_VCTRf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MPORTVEC1r_RESERVEDf_GET(r) ((((r).mportvec1[0]) >> 9) & 0x7fffff)
#define BCM89500_A0_MPORTVEC1r_RESERVEDf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC1.
 *
 */
#define BCM89500_A0_READ_MPORTVEC1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MPORTVEC1r,(r._mportvec1),4)
#define BCM89500_A0_WRITE_MPORTVEC1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MPORTVEC1r,&(r._mportvec1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC1r BCM89500_A0_MPORTVEC1r
#define MPORTVEC1r_SIZE BCM89500_A0_MPORTVEC1r_SIZE
typedef BCM89500_A0_MPORTVEC1r_t MPORTVEC1r_t;
#define MPORTVEC1r_CLR BCM89500_A0_MPORTVEC1r_CLR
#define MPORTVEC1r_SET BCM89500_A0_MPORTVEC1r_SET
#define MPORTVEC1r_GET BCM89500_A0_MPORTVEC1r_GET
#define MPORTVEC1r_PORT_VCTRf_GET BCM89500_A0_MPORTVEC1r_PORT_VCTRf_GET
#define MPORTVEC1r_PORT_VCTRf_SET BCM89500_A0_MPORTVEC1r_PORT_VCTRf_SET
#define MPORTVEC1r_RESERVEDf_GET BCM89500_A0_MPORTVEC1r_RESERVEDf_GET
#define MPORTVEC1r_RESERVEDf_SET BCM89500_A0_MPORTVEC1r_RESERVEDf_SET
#define READ_MPORTVEC1r BCM89500_A0_READ_MPORTVEC1r
#define WRITE_MPORTVEC1r BCM89500_A0_WRITE_MPORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MPORTVEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MPORTVEC2
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 2.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 2 register will be forwarded to each port with a bit set in the Multiport Vector 2 bit map.Bits 0-5: Port 0-5.Bit 6: reserved.Bit 7: Port 7. (polar feature)Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MPORTVEC2r 0x00000438

#define BCM89500_A0_MPORTVEC2r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC2.
 *
 */
typedef union BCM89500_A0_MPORTVEC2r_s {
	uint32_t v[1];
	uint32_t mportvec2[1];
	uint32_t _mportvec2;
} BCM89500_A0_MPORTVEC2r_t;

#define BCM89500_A0_MPORTVEC2r_CLR(r) (r).mportvec2[0] = 0
#define BCM89500_A0_MPORTVEC2r_SET(r,d) (r).mportvec2[0] = d
#define BCM89500_A0_MPORTVEC2r_GET(r) (r).mportvec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MPORTVEC2r_PORT_VCTRf_GET(r) (((r).mportvec2[0]) & 0x1ff)
#define BCM89500_A0_MPORTVEC2r_PORT_VCTRf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MPORTVEC2r_RESERVEDf_GET(r) ((((r).mportvec2[0]) >> 9) & 0x7fffff)
#define BCM89500_A0_MPORTVEC2r_RESERVEDf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC2.
 *
 */
#define BCM89500_A0_READ_MPORTVEC2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MPORTVEC2r,(r._mportvec2),4)
#define BCM89500_A0_WRITE_MPORTVEC2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MPORTVEC2r,&(r._mportvec2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC2r BCM89500_A0_MPORTVEC2r
#define MPORTVEC2r_SIZE BCM89500_A0_MPORTVEC2r_SIZE
typedef BCM89500_A0_MPORTVEC2r_t MPORTVEC2r_t;
#define MPORTVEC2r_CLR BCM89500_A0_MPORTVEC2r_CLR
#define MPORTVEC2r_SET BCM89500_A0_MPORTVEC2r_SET
#define MPORTVEC2r_GET BCM89500_A0_MPORTVEC2r_GET
#define MPORTVEC2r_PORT_VCTRf_GET BCM89500_A0_MPORTVEC2r_PORT_VCTRf_GET
#define MPORTVEC2r_PORT_VCTRf_SET BCM89500_A0_MPORTVEC2r_PORT_VCTRf_SET
#define MPORTVEC2r_RESERVEDf_GET BCM89500_A0_MPORTVEC2r_RESERVEDf_GET
#define MPORTVEC2r_RESERVEDf_SET BCM89500_A0_MPORTVEC2r_RESERVEDf_SET
#define READ_MPORTVEC2r BCM89500_A0_READ_MPORTVEC2r
#define WRITE_MPORTVEC2r BCM89500_A0_WRITE_MPORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MPORTVEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MPORTVEC3
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 3.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 3 register will be forwarded to each port with a bit set in the Multiport Vector 3 bit map.Bits 0-5: Port 0-5.Bit 6: reserved.Bit 7: Port 7. (polar feature)Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MPORTVEC3r 0x00000448

#define BCM89500_A0_MPORTVEC3r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC3.
 *
 */
typedef union BCM89500_A0_MPORTVEC3r_s {
	uint32_t v[1];
	uint32_t mportvec3[1];
	uint32_t _mportvec3;
} BCM89500_A0_MPORTVEC3r_t;

#define BCM89500_A0_MPORTVEC3r_CLR(r) (r).mportvec3[0] = 0
#define BCM89500_A0_MPORTVEC3r_SET(r,d) (r).mportvec3[0] = d
#define BCM89500_A0_MPORTVEC3r_GET(r) (r).mportvec3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MPORTVEC3r_PORT_VCTRf_GET(r) (((r).mportvec3[0]) & 0x1ff)
#define BCM89500_A0_MPORTVEC3r_PORT_VCTRf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MPORTVEC3r_RESERVEDf_GET(r) ((((r).mportvec3[0]) >> 9) & 0x7fffff)
#define BCM89500_A0_MPORTVEC3r_RESERVEDf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC3.
 *
 */
#define BCM89500_A0_READ_MPORTVEC3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MPORTVEC3r,(r._mportvec3),4)
#define BCM89500_A0_WRITE_MPORTVEC3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MPORTVEC3r,&(r._mportvec3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC3r BCM89500_A0_MPORTVEC3r
#define MPORTVEC3r_SIZE BCM89500_A0_MPORTVEC3r_SIZE
typedef BCM89500_A0_MPORTVEC3r_t MPORTVEC3r_t;
#define MPORTVEC3r_CLR BCM89500_A0_MPORTVEC3r_CLR
#define MPORTVEC3r_SET BCM89500_A0_MPORTVEC3r_SET
#define MPORTVEC3r_GET BCM89500_A0_MPORTVEC3r_GET
#define MPORTVEC3r_PORT_VCTRf_GET BCM89500_A0_MPORTVEC3r_PORT_VCTRf_GET
#define MPORTVEC3r_PORT_VCTRf_SET BCM89500_A0_MPORTVEC3r_PORT_VCTRf_SET
#define MPORTVEC3r_RESERVEDf_GET BCM89500_A0_MPORTVEC3r_RESERVEDf_GET
#define MPORTVEC3r_RESERVEDf_SET BCM89500_A0_MPORTVEC3r_RESERVEDf_SET
#define READ_MPORTVEC3r BCM89500_A0_READ_MPORTVEC3r
#define WRITE_MPORTVEC3r BCM89500_A0_WRITE_MPORTVEC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MPORTVEC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MPORTVEC4
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 4 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 4.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 4 register will be forwarded to each port with a bit set in the Multiport Vector 4 bit map.Bits 0-5: Port 0-5.Bit 6: reserved.Bit 7: Port 7. (polar feature)Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MPORTVEC4r 0x00000458

#define BCM89500_A0_MPORTVEC4r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC4.
 *
 */
typedef union BCM89500_A0_MPORTVEC4r_s {
	uint32_t v[1];
	uint32_t mportvec4[1];
	uint32_t _mportvec4;
} BCM89500_A0_MPORTVEC4r_t;

#define BCM89500_A0_MPORTVEC4r_CLR(r) (r).mportvec4[0] = 0
#define BCM89500_A0_MPORTVEC4r_SET(r,d) (r).mportvec4[0] = d
#define BCM89500_A0_MPORTVEC4r_GET(r) (r).mportvec4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MPORTVEC4r_PORT_VCTRf_GET(r) (((r).mportvec4[0]) & 0x1ff)
#define BCM89500_A0_MPORTVEC4r_PORT_VCTRf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MPORTVEC4r_RESERVEDf_GET(r) ((((r).mportvec4[0]) >> 9) & 0x7fffff)
#define BCM89500_A0_MPORTVEC4r_RESERVEDf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC4.
 *
 */
#define BCM89500_A0_READ_MPORTVEC4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MPORTVEC4r,(r._mportvec4),4)
#define BCM89500_A0_WRITE_MPORTVEC4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MPORTVEC4r,&(r._mportvec4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC4r BCM89500_A0_MPORTVEC4r
#define MPORTVEC4r_SIZE BCM89500_A0_MPORTVEC4r_SIZE
typedef BCM89500_A0_MPORTVEC4r_t MPORTVEC4r_t;
#define MPORTVEC4r_CLR BCM89500_A0_MPORTVEC4r_CLR
#define MPORTVEC4r_SET BCM89500_A0_MPORTVEC4r_SET
#define MPORTVEC4r_GET BCM89500_A0_MPORTVEC4r_GET
#define MPORTVEC4r_PORT_VCTRf_GET BCM89500_A0_MPORTVEC4r_PORT_VCTRf_GET
#define MPORTVEC4r_PORT_VCTRf_SET BCM89500_A0_MPORTVEC4r_PORT_VCTRf_SET
#define MPORTVEC4r_RESERVEDf_GET BCM89500_A0_MPORTVEC4r_RESERVEDf_GET
#define MPORTVEC4r_RESERVEDf_SET BCM89500_A0_MPORTVEC4r_RESERVEDf_SET
#define READ_MPORTVEC4r BCM89500_A0_READ_MPORTVEC4r
#define WRITE_MPORTVEC4r BCM89500_A0_WRITE_MPORTVEC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MPORTVEC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MPORTVEC5
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 5 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 5.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 5 register will be forwarded to each port with a bit set in the Multiport Vector 5 bit map.Bits 0-5: Port 0-5.Bit 6: reserved.Bit 7: Port 7. (polar feature)Bit 8: Port 8(IMP).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MPORTVEC5r 0x00000468

#define BCM89500_A0_MPORTVEC5r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC5.
 *
 */
typedef union BCM89500_A0_MPORTVEC5r_s {
	uint32_t v[1];
	uint32_t mportvec5[1];
	uint32_t _mportvec5;
} BCM89500_A0_MPORTVEC5r_t;

#define BCM89500_A0_MPORTVEC5r_CLR(r) (r).mportvec5[0] = 0
#define BCM89500_A0_MPORTVEC5r_SET(r,d) (r).mportvec5[0] = d
#define BCM89500_A0_MPORTVEC5r_GET(r) (r).mportvec5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MPORTVEC5r_PORT_VCTRf_GET(r) (((r).mportvec5[0]) & 0x1ff)
#define BCM89500_A0_MPORTVEC5r_PORT_VCTRf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_MPORTVEC5r_RESERVEDf_GET(r) ((((r).mportvec5[0]) >> 9) & 0x7fffff)
#define BCM89500_A0_MPORTVEC5r_RESERVEDf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC5.
 *
 */
#define BCM89500_A0_READ_MPORTVEC5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MPORTVEC5r,(r._mportvec5),4)
#define BCM89500_A0_WRITE_MPORTVEC5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MPORTVEC5r,&(r._mportvec5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC5r BCM89500_A0_MPORTVEC5r
#define MPORTVEC5r_SIZE BCM89500_A0_MPORTVEC5r_SIZE
typedef BCM89500_A0_MPORTVEC5r_t MPORTVEC5r_t;
#define MPORTVEC5r_CLR BCM89500_A0_MPORTVEC5r_CLR
#define MPORTVEC5r_SET BCM89500_A0_MPORTVEC5r_SET
#define MPORTVEC5r_GET BCM89500_A0_MPORTVEC5r_GET
#define MPORTVEC5r_PORT_VCTRf_GET BCM89500_A0_MPORTVEC5r_PORT_VCTRf_GET
#define MPORTVEC5r_PORT_VCTRf_SET BCM89500_A0_MPORTVEC5r_PORT_VCTRf_SET
#define MPORTVEC5r_RESERVEDf_GET BCM89500_A0_MPORTVEC5r_RESERVEDf_GET
#define MPORTVEC5r_RESERVEDf_SET BCM89500_A0_MPORTVEC5r_RESERVEDf_SET
#define READ_MPORTVEC5r BCM89500_A0_READ_MPORTVEC5r
#define WRITE_MPORTVEC5r BCM89500_A0_WRITE_MPORTVEC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MPORTVEC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MST_AGE
 * BLOCKS:   SYS
 * DESC:     MST Ageing Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PRT       Per-spannibg tree aging enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MST_AGEr 0x00004302

#define BCM89500_A0_MST_AGEr_SIZE 4

/*
 * This structure should be used to declare and program MST_AGE.
 *
 */
typedef union BCM89500_A0_MST_AGEr_s {
	uint32_t v[1];
	uint32_t mst_age[1];
	uint32_t _mst_age;
} BCM89500_A0_MST_AGEr_t;

#define BCM89500_A0_MST_AGEr_CLR(r) (r).mst_age[0] = 0
#define BCM89500_A0_MST_AGEr_SET(r,d) (r).mst_age[0] = d
#define BCM89500_A0_MST_AGEr_GET(r) (r).mst_age[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MST_AGEr_AGE_EN_PRTf_GET(r) (((r).mst_age[0]) & 0xff)
#define BCM89500_A0_MST_AGEr_AGE_EN_PRTf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_MST_AGEr_RESERVEDf_GET(r) ((((r).mst_age[0]) >> 8) & 0xffffff)
#define BCM89500_A0_MST_AGEr_RESERVEDf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access MST_AGE.
 *
 */
#define BCM89500_A0_READ_MST_AGEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MST_AGEr,(r._mst_age),4)
#define BCM89500_A0_WRITE_MST_AGEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MST_AGEr,&(r._mst_age),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_AGEr BCM89500_A0_MST_AGEr
#define MST_AGEr_SIZE BCM89500_A0_MST_AGEr_SIZE
typedef BCM89500_A0_MST_AGEr_t MST_AGEr_t;
#define MST_AGEr_CLR BCM89500_A0_MST_AGEr_CLR
#define MST_AGEr_SET BCM89500_A0_MST_AGEr_SET
#define MST_AGEr_GET BCM89500_A0_MST_AGEr_GET
#define MST_AGEr_AGE_EN_PRTf_GET BCM89500_A0_MST_AGEr_AGE_EN_PRTf_GET
#define MST_AGEr_AGE_EN_PRTf_SET BCM89500_A0_MST_AGEr_AGE_EN_PRTf_SET
#define MST_AGEr_RESERVEDf_GET BCM89500_A0_MST_AGEr_RESERVEDf_GET
#define MST_AGEr_RESERVEDf_SET BCM89500_A0_MST_AGEr_RESERVEDf_SET
#define READ_MST_AGEr BCM89500_A0_READ_MST_AGEr
#define WRITE_MST_AGEr BCM89500_A0_WRITE_MST_AGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MST_AGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MST Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        1: Enable 802.1s0: Only one spanning tree support
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MST_CONr 0x00004300

#define BCM89500_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 *
 */
typedef union BCM89500_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM89500_A0_MST_CONr_t;

#define BCM89500_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM89500_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM89500_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM89500_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_MST_CONr_RESERVEDf_GET(r) ((((r).mst_con[0]) >> 1) & 0x7f)
#define BCM89500_A0_MST_CONr_RESERVEDf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access MST_CON.
 *
 */
#define BCM89500_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MST_CONr,(r._mst_con),1)
#define BCM89500_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM89500_A0_MST_CONr
#define MST_CONr_SIZE BCM89500_A0_MST_CONr_SIZE
typedef BCM89500_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM89500_A0_MST_CONr_CLR
#define MST_CONr_SET BCM89500_A0_MST_CONr_SET
#define MST_CONr_GET BCM89500_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM89500_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM89500_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_RESERVEDf_GET BCM89500_A0_MST_CONr_RESERVEDf_GET
#define MST_CONr_RESERVEDf_SET BCM89500_A0_MST_CONr_RESERVEDf_SET
#define READ_MST_CONr BCM89500_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM89500_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MST_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MST_TAB
 * BLOCKS:   SYS
 * DESC:     MST Table N Enable Registers
 * SIZE:     32
 * FIELDS:
 *     SPT_STA0         Spanning tree state for port 0.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA1         Spanning tree state for port 1.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA2         Spanning tree state for port 2.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA3         Spanning tree state for port 3.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA4         Spanning tree state for port 4.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA5         Spanning tree state for port 5.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     RESERVED_0       Reserved
 *     SPT_STA7         Spanning tree state for port 7.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     RESERVED_1       Reserved
 *     MST_TAB_RSRV     Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_MST_TABr 0x00004310

#define BCM89500_A0_MST_TABr_SIZE 4

/*
 * This structure should be used to declare and program MST_TAB.
 *
 */
typedef union BCM89500_A0_MST_TABr_s {
	uint32_t v[1];
	uint32_t mst_tab[1];
	uint32_t _mst_tab;
} BCM89500_A0_MST_TABr_t;

#define BCM89500_A0_MST_TABr_CLR(r) (r).mst_tab[0] = 0
#define BCM89500_A0_MST_TABr_SET(r,d) (r).mst_tab[0] = d
#define BCM89500_A0_MST_TABr_GET(r) (r).mst_tab[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MST_TABr_SPT_STA0f_GET(r) (((r).mst_tab[0]) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA0f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_MST_TABr_SPT_STA1f_GET(r) ((((r).mst_tab[0]) >> 3) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA1f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_MST_TABr_SPT_STA2f_GET(r) ((((r).mst_tab[0]) >> 6) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA2f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_MST_TABr_SPT_STA3f_GET(r) ((((r).mst_tab[0]) >> 9) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA3f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_MST_TABr_SPT_STA4f_GET(r) ((((r).mst_tab[0]) >> 12) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA4f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_MST_TABr_SPT_STA5f_GET(r) ((((r).mst_tab[0]) >> 15) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA5f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_MST_TABr_RESERVED_0f_GET(r) ((((r).mst_tab[0]) >> 18) & 0x7)
#define BCM89500_A0_MST_TABr_RESERVED_0f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_MST_TABr_SPT_STA7f_GET(r) ((((r).mst_tab[0]) >> 21) & 0x7)
#define BCM89500_A0_MST_TABr_SPT_STA7f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_MST_TABr_RESERVED_1f_GET(r) ((((r).mst_tab[0]) >> 24) & 0x7)
#define BCM89500_A0_MST_TABr_RESERVED_1f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM89500_A0_MST_TABr_MST_TAB_RSRVf_GET(r) ((((r).mst_tab[0]) >> 27) & 0x1f)
#define BCM89500_A0_MST_TABr_MST_TAB_RSRVf_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access MST_TAB.
 *
 */
#define BCM89500_A0_READ_MST_TABr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_MST_TABr+(4*(i)),(r._mst_tab),4)
#define BCM89500_A0_WRITE_MST_TABr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_MST_TABr+(4*(i)),&(r._mst_tab),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_TABr BCM89500_A0_MST_TABr
#define MST_TABr_SIZE BCM89500_A0_MST_TABr_SIZE
typedef BCM89500_A0_MST_TABr_t MST_TABr_t;
#define MST_TABr_CLR BCM89500_A0_MST_TABr_CLR
#define MST_TABr_SET BCM89500_A0_MST_TABr_SET
#define MST_TABr_GET BCM89500_A0_MST_TABr_GET
#define MST_TABr_SPT_STA0f_GET BCM89500_A0_MST_TABr_SPT_STA0f_GET
#define MST_TABr_SPT_STA0f_SET BCM89500_A0_MST_TABr_SPT_STA0f_SET
#define MST_TABr_SPT_STA1f_GET BCM89500_A0_MST_TABr_SPT_STA1f_GET
#define MST_TABr_SPT_STA1f_SET BCM89500_A0_MST_TABr_SPT_STA1f_SET
#define MST_TABr_SPT_STA2f_GET BCM89500_A0_MST_TABr_SPT_STA2f_GET
#define MST_TABr_SPT_STA2f_SET BCM89500_A0_MST_TABr_SPT_STA2f_SET
#define MST_TABr_SPT_STA3f_GET BCM89500_A0_MST_TABr_SPT_STA3f_GET
#define MST_TABr_SPT_STA3f_SET BCM89500_A0_MST_TABr_SPT_STA3f_SET
#define MST_TABr_SPT_STA4f_GET BCM89500_A0_MST_TABr_SPT_STA4f_GET
#define MST_TABr_SPT_STA4f_SET BCM89500_A0_MST_TABr_SPT_STA4f_SET
#define MST_TABr_SPT_STA5f_GET BCM89500_A0_MST_TABr_SPT_STA5f_GET
#define MST_TABr_SPT_STA5f_SET BCM89500_A0_MST_TABr_SPT_STA5f_SET
#define MST_TABr_RESERVED_0f_GET BCM89500_A0_MST_TABr_RESERVED_0f_GET
#define MST_TABr_RESERVED_0f_SET BCM89500_A0_MST_TABr_RESERVED_0f_SET
#define MST_TABr_SPT_STA7f_GET BCM89500_A0_MST_TABr_SPT_STA7f_GET
#define MST_TABr_SPT_STA7f_SET BCM89500_A0_MST_TABr_SPT_STA7f_SET
#define MST_TABr_RESERVED_1f_GET BCM89500_A0_MST_TABr_RESERVED_1f_GET
#define MST_TABr_RESERVED_1f_SET BCM89500_A0_MST_TABr_RESERVED_1f_SET
#define MST_TABr_MST_TAB_RSRVf_GET BCM89500_A0_MST_TABr_MST_TAB_RSRVf_GET
#define MST_TABr_MST_TAB_RSRVf_SET BCM89500_A0_MST_TABr_MST_TAB_RSRVf_SET
#define READ_MST_TABr BCM89500_A0_READ_MST_TABr
#define WRITE_MST_TABr BCM89500_A0_WRITE_MST_TABr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MST_TABr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTIPORT_ADDR0
 * BLOCKS:   SYS
 * DESC:     Multiport Address 0 Register (Default for TS)
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 0.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 0Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM89500_A0_MULTIPORT_ADDR0r 0x00000410

#define BCM89500_A0_MULTIPORT_ADDR0r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR0.
 *
 */
typedef union BCM89500_A0_MULTIPORT_ADDR0r_s {
	uint32_t v[2];
	uint32_t multiport_addr0[2];
	uint32_t _multiport_addr0;
} BCM89500_A0_MULTIPORT_ADDR0r_t;

#define BCM89500_A0_MULTIPORT_ADDR0r_CLR(r) CDK_MEMSET(&((r)._multiport_addr0), 0, sizeof(BCM89500_A0_MULTIPORT_ADDR0r_t))
#define BCM89500_A0_MULTIPORT_ADDR0r_SET(r,i,d) (r).multiport_addr0[i] = d
#define BCM89500_A0_MULTIPORT_ADDR0r_GET(r,i) (r).multiport_addr0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr0,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr0,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr0[1]) >> 16) & 0xffff)
#define BCM89500_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr0[1]=(((r).multiport_addr0[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR0.
 *
 */
#define BCM89500_A0_READ_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTIPORT_ADDR0r,(r._multiport_addr0),8)
#define BCM89500_A0_WRITE_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTIPORT_ADDR0r,&(r._multiport_addr0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR0r BCM89500_A0_MULTIPORT_ADDR0r
#define MULTIPORT_ADDR0r_SIZE BCM89500_A0_MULTIPORT_ADDR0r_SIZE
typedef BCM89500_A0_MULTIPORT_ADDR0r_t MULTIPORT_ADDR0r_t;
#define MULTIPORT_ADDR0r_CLR BCM89500_A0_MULTIPORT_ADDR0r_CLR
#define MULTIPORT_ADDR0r_SET BCM89500_A0_MULTIPORT_ADDR0r_SET
#define MULTIPORT_ADDR0r_GET BCM89500_A0_MULTIPORT_ADDR0r_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_GET BCM89500_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_SET BCM89500_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET BCM89500_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET BCM89500_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR0r BCM89500_A0_READ_MULTIPORT_ADDR0r
#define WRITE_MULTIPORT_ADDR0r BCM89500_A0_WRITE_MULTIPORT_ADDR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTIPORT_ADDR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTIPORT_ADDR1
 * BLOCKS:   SYS
 * DESC:     Multiport Address 1 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 1.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 1Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM89500_A0_MULTIPORT_ADDR1r 0x00000420

#define BCM89500_A0_MULTIPORT_ADDR1r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR1.
 *
 */
typedef union BCM89500_A0_MULTIPORT_ADDR1r_s {
	uint32_t v[2];
	uint32_t multiport_addr1[2];
	uint32_t _multiport_addr1;
} BCM89500_A0_MULTIPORT_ADDR1r_t;

#define BCM89500_A0_MULTIPORT_ADDR1r_CLR(r) CDK_MEMSET(&((r)._multiport_addr1), 0, sizeof(BCM89500_A0_MULTIPORT_ADDR1r_t))
#define BCM89500_A0_MULTIPORT_ADDR1r_SET(r,i,d) (r).multiport_addr1[i] = d
#define BCM89500_A0_MULTIPORT_ADDR1r_GET(r,i) (r).multiport_addr1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr1,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr1,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr1[1]) >> 16) & 0xffff)
#define BCM89500_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr1[1]=(((r).multiport_addr1[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR1.
 *
 */
#define BCM89500_A0_READ_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTIPORT_ADDR1r,(r._multiport_addr1),8)
#define BCM89500_A0_WRITE_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTIPORT_ADDR1r,&(r._multiport_addr1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR1r BCM89500_A0_MULTIPORT_ADDR1r
#define MULTIPORT_ADDR1r_SIZE BCM89500_A0_MULTIPORT_ADDR1r_SIZE
typedef BCM89500_A0_MULTIPORT_ADDR1r_t MULTIPORT_ADDR1r_t;
#define MULTIPORT_ADDR1r_CLR BCM89500_A0_MULTIPORT_ADDR1r_CLR
#define MULTIPORT_ADDR1r_SET BCM89500_A0_MULTIPORT_ADDR1r_SET
#define MULTIPORT_ADDR1r_GET BCM89500_A0_MULTIPORT_ADDR1r_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_GET BCM89500_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_SET BCM89500_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET BCM89500_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET BCM89500_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR1r BCM89500_A0_READ_MULTIPORT_ADDR1r
#define WRITE_MULTIPORT_ADDR1r BCM89500_A0_WRITE_MULTIPORT_ADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTIPORT_ADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTIPORT_ADDR2
 * BLOCKS:   SYS
 * DESC:     Multiport Address 2 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 2.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 2Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM89500_A0_MULTIPORT_ADDR2r 0x00000430

#define BCM89500_A0_MULTIPORT_ADDR2r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR2.
 *
 */
typedef union BCM89500_A0_MULTIPORT_ADDR2r_s {
	uint32_t v[2];
	uint32_t multiport_addr2[2];
	uint32_t _multiport_addr2;
} BCM89500_A0_MULTIPORT_ADDR2r_t;

#define BCM89500_A0_MULTIPORT_ADDR2r_CLR(r) CDK_MEMSET(&((r)._multiport_addr2), 0, sizeof(BCM89500_A0_MULTIPORT_ADDR2r_t))
#define BCM89500_A0_MULTIPORT_ADDR2r_SET(r,i,d) (r).multiport_addr2[i] = d
#define BCM89500_A0_MULTIPORT_ADDR2r_GET(r,i) (r).multiport_addr2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr2,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr2,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr2[1]) >> 16) & 0xffff)
#define BCM89500_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr2[1]=(((r).multiport_addr2[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR2.
 *
 */
#define BCM89500_A0_READ_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTIPORT_ADDR2r,(r._multiport_addr2),8)
#define BCM89500_A0_WRITE_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTIPORT_ADDR2r,&(r._multiport_addr2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR2r BCM89500_A0_MULTIPORT_ADDR2r
#define MULTIPORT_ADDR2r_SIZE BCM89500_A0_MULTIPORT_ADDR2r_SIZE
typedef BCM89500_A0_MULTIPORT_ADDR2r_t MULTIPORT_ADDR2r_t;
#define MULTIPORT_ADDR2r_CLR BCM89500_A0_MULTIPORT_ADDR2r_CLR
#define MULTIPORT_ADDR2r_SET BCM89500_A0_MULTIPORT_ADDR2r_SET
#define MULTIPORT_ADDR2r_GET BCM89500_A0_MULTIPORT_ADDR2r_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_GET BCM89500_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_SET BCM89500_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET BCM89500_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET BCM89500_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR2r BCM89500_A0_READ_MULTIPORT_ADDR2r
#define WRITE_MULTIPORT_ADDR2r BCM89500_A0_WRITE_MULTIPORT_ADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTIPORT_ADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTIPORT_ADDR3
 * BLOCKS:   SYS
 * DESC:     Multiport Address 3 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 3.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 3Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM89500_A0_MULTIPORT_ADDR3r 0x00000440

#define BCM89500_A0_MULTIPORT_ADDR3r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR3.
 *
 */
typedef union BCM89500_A0_MULTIPORT_ADDR3r_s {
	uint32_t v[2];
	uint32_t multiport_addr3[2];
	uint32_t _multiport_addr3;
} BCM89500_A0_MULTIPORT_ADDR3r_t;

#define BCM89500_A0_MULTIPORT_ADDR3r_CLR(r) CDK_MEMSET(&((r)._multiport_addr3), 0, sizeof(BCM89500_A0_MULTIPORT_ADDR3r_t))
#define BCM89500_A0_MULTIPORT_ADDR3r_SET(r,i,d) (r).multiport_addr3[i] = d
#define BCM89500_A0_MULTIPORT_ADDR3r_GET(r,i) (r).multiport_addr3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr3,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr3,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr3[1]) >> 16) & 0xffff)
#define BCM89500_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr3[1]=(((r).multiport_addr3[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR3.
 *
 */
#define BCM89500_A0_READ_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTIPORT_ADDR3r,(r._multiport_addr3),8)
#define BCM89500_A0_WRITE_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTIPORT_ADDR3r,&(r._multiport_addr3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR3r BCM89500_A0_MULTIPORT_ADDR3r
#define MULTIPORT_ADDR3r_SIZE BCM89500_A0_MULTIPORT_ADDR3r_SIZE
typedef BCM89500_A0_MULTIPORT_ADDR3r_t MULTIPORT_ADDR3r_t;
#define MULTIPORT_ADDR3r_CLR BCM89500_A0_MULTIPORT_ADDR3r_CLR
#define MULTIPORT_ADDR3r_SET BCM89500_A0_MULTIPORT_ADDR3r_SET
#define MULTIPORT_ADDR3r_GET BCM89500_A0_MULTIPORT_ADDR3r_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_GET BCM89500_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_SET BCM89500_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET BCM89500_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET BCM89500_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR3r BCM89500_A0_READ_MULTIPORT_ADDR3r
#define WRITE_MULTIPORT_ADDR3r BCM89500_A0_WRITE_MULTIPORT_ADDR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTIPORT_ADDR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTIPORT_ADDR4
 * BLOCKS:   SYS
 * DESC:     Multiport Address 4 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 4.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 4Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM89500_A0_MULTIPORT_ADDR4r 0x00000450

#define BCM89500_A0_MULTIPORT_ADDR4r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR4.
 *
 */
typedef union BCM89500_A0_MULTIPORT_ADDR4r_s {
	uint32_t v[2];
	uint32_t multiport_addr4[2];
	uint32_t _multiport_addr4;
} BCM89500_A0_MULTIPORT_ADDR4r_t;

#define BCM89500_A0_MULTIPORT_ADDR4r_CLR(r) CDK_MEMSET(&((r)._multiport_addr4), 0, sizeof(BCM89500_A0_MULTIPORT_ADDR4r_t))
#define BCM89500_A0_MULTIPORT_ADDR4r_SET(r,i,d) (r).multiport_addr4[i] = d
#define BCM89500_A0_MULTIPORT_ADDR4r_GET(r,i) (r).multiport_addr4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr4,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr4,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr4[1]) >> 16) & 0xffff)
#define BCM89500_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr4[1]=(((r).multiport_addr4[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR4.
 *
 */
#define BCM89500_A0_READ_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTIPORT_ADDR4r,(r._multiport_addr4),8)
#define BCM89500_A0_WRITE_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTIPORT_ADDR4r,&(r._multiport_addr4),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR4r BCM89500_A0_MULTIPORT_ADDR4r
#define MULTIPORT_ADDR4r_SIZE BCM89500_A0_MULTIPORT_ADDR4r_SIZE
typedef BCM89500_A0_MULTIPORT_ADDR4r_t MULTIPORT_ADDR4r_t;
#define MULTIPORT_ADDR4r_CLR BCM89500_A0_MULTIPORT_ADDR4r_CLR
#define MULTIPORT_ADDR4r_SET BCM89500_A0_MULTIPORT_ADDR4r_SET
#define MULTIPORT_ADDR4r_GET BCM89500_A0_MULTIPORT_ADDR4r_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_GET BCM89500_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_SET BCM89500_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET BCM89500_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET BCM89500_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR4r BCM89500_A0_READ_MULTIPORT_ADDR4r
#define WRITE_MULTIPORT_ADDR4r BCM89500_A0_WRITE_MULTIPORT_ADDR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTIPORT_ADDR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTIPORT_ADDR5
 * BLOCKS:   SYS
 * DESC:     Multiport Address 5 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 5.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 5Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM89500_A0_MULTIPORT_ADDR5r 0x00000460

#define BCM89500_A0_MULTIPORT_ADDR5r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR5.
 *
 */
typedef union BCM89500_A0_MULTIPORT_ADDR5r_s {
	uint32_t v[2];
	uint32_t multiport_addr5[2];
	uint32_t _multiport_addr5;
} BCM89500_A0_MULTIPORT_ADDR5r_t;

#define BCM89500_A0_MULTIPORT_ADDR5r_CLR(r) CDK_MEMSET(&((r)._multiport_addr5), 0, sizeof(BCM89500_A0_MULTIPORT_ADDR5r_t))
#define BCM89500_A0_MULTIPORT_ADDR5r_SET(r,i,d) (r).multiport_addr5[i] = d
#define BCM89500_A0_MULTIPORT_ADDR5r_GET(r,i) (r).multiport_addr5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr5,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr5,0,47,a)
#define BCM89500_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr5[1]) >> 16) & 0xffff)
#define BCM89500_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr5[1]=(((r).multiport_addr5[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR5.
 *
 */
#define BCM89500_A0_READ_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTIPORT_ADDR5r,(r._multiport_addr5),8)
#define BCM89500_A0_WRITE_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTIPORT_ADDR5r,&(r._multiport_addr5),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR5r BCM89500_A0_MULTIPORT_ADDR5r
#define MULTIPORT_ADDR5r_SIZE BCM89500_A0_MULTIPORT_ADDR5r_SIZE
typedef BCM89500_A0_MULTIPORT_ADDR5r_t MULTIPORT_ADDR5r_t;
#define MULTIPORT_ADDR5r_CLR BCM89500_A0_MULTIPORT_ADDR5r_CLR
#define MULTIPORT_ADDR5r_SET BCM89500_A0_MULTIPORT_ADDR5r_SET
#define MULTIPORT_ADDR5r_GET BCM89500_A0_MULTIPORT_ADDR5r_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_GET BCM89500_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_SET BCM89500_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET BCM89500_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET BCM89500_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR5r BCM89500_A0_READ_MULTIPORT_ADDR5r
#define WRITE_MULTIPORT_ADDR5r BCM89500_A0_WRITE_MULTIPORT_ADDR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTIPORT_ADDR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  MULTI_PORT_CTL
 * BLOCKS:   SYS
 * DESC:     Multiport Control Register
 * SIZE:     16
 * FIELDS:
 *     MPORT_CTRL0      Multiport 0 Control .1'b00: Disable Multiport 0 Forward1'b10: Compare MPORT_ADD0 only, Forward based on MPORT_Vector 0 if matched1'b01: Compare MPORT_ETYPE0 only, Forward based on MPORT_Vector 0 if matched1'b11: Compare MPORT_ETYPE0 and MPORT_ADD0, Forward based on MPORT_Vector 0 if matched
 *     MPORT_CTRL1      Multiport 1 Control .1'b00: Disable Multiport 1 Forward1'b10: Compare MPORT_ADD1 only, Forward based on MPORT_Vector 1 if matched1'b01: Compare MPORT_ETYPE1 only, Forward based on MPORT_Vector 1 if matched1'b11: Compare MPORT_ETYPE1 and MPORT_ADD1, Forward based on MPORT_Vector 1 if matched
 *     MPORT_CTRL2      Multiport 2 Control .1'b00: Disable Multiport 2 Forward1'b10: Compare MPORT_ADD2 only, Forward based on MPORT_Vector 2 if matched1'b01: Compare MPORT_ETYPE2 only, Forward based on MPORT_Vector 2 if matched1'b11: Compare MPORT_ETYPE2 and MPORT_ADD2, Forward based on MPORT_Vector 2 if matched
 *     MPORT_CTRL3      Multiport 3 Control .1'b00: Disable Multiport 3 Forward1'b10: Compare MPORT_ADD3 only, Forward based on MPORT_Vector 3 if matched1'b01: Compare MPORT_ETYPE3 only, Forward based on MPORT_Vector 3 if matched1'b11: Compare MPORT_ETYPE3 and MPORT_ADD3, Forward based on MPORT_Vector 3 if matched
 *     MPORT_CTRL4      Multiport 4 Control .1'b00: Disable Multiport 4 Forward1'b10: Compare MPORT_ADD4 only, Forward based on MPORT_Vector 4 if matched1'b01: Compare MPORT_ETYPE4 only, Forward based on MPORT_Vector 4 if matched1'b11: Compare MPORT_ETYPE4 and MPORT_ADD4, Forward based on MPORT_Vector 4 if matched
 *     MPORT_CTRL5      Multiport 5 Control .1'b00: Disable Multiport 5 Forward1'b10: Compare MPORT_ADD5 only, Forward based on MPORT_Vector 5 if matched1'b01: Compare MPORT_ETYPE5 only, Forward based on MPORT_Vector 5 if matched1'b11: Compare MPORT_ETYPE5 and MPORT_ADD5, Forward based on MPORT_Vector 5 if matched
 *     RESERVED         Reserved
 *     MPORT0_TS_EN     Mport 0 Time Sync Enable1: Packet will be time stamped if forwarded to CPU.  MPORT_VECTOR0 should be programed to CPU only if the bit is set0: Packet will not be time-stamped
 *
 ******************************************************************************/
#define BCM89500_A0_MULTI_PORT_CTLr 0x0000040e

#define BCM89500_A0_MULTI_PORT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program MULTI_PORT_CTL.
 *
 */
typedef union BCM89500_A0_MULTI_PORT_CTLr_s {
	uint32_t v[1];
	uint32_t multi_port_ctl[1];
	uint32_t _multi_port_ctl;
} BCM89500_A0_MULTI_PORT_CTLr_t;

#define BCM89500_A0_MULTI_PORT_CTLr_CLR(r) (r).multi_port_ctl[0] = 0
#define BCM89500_A0_MULTI_PORT_CTLr_SET(r,d) (r).multi_port_ctl[0] = d
#define BCM89500_A0_MULTI_PORT_CTLr_GET(r) (r).multi_port_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET(r) (((r).multi_port_ctl[0]) & 0x3)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET(r) ((((r).multi_port_ctl[0]) >> 2) & 0x3)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET(r) ((((r).multi_port_ctl[0]) >> 4) & 0x3)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET(r) ((((r).multi_port_ctl[0]) >> 6) & 0x3)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET(r) ((((r).multi_port_ctl[0]) >> 8) & 0x3)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET(r) ((((r).multi_port_ctl[0]) >> 10) & 0x3)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM89500_A0_MULTI_PORT_CTLr_RESERVEDf_GET(r) ((((r).multi_port_ctl[0]) >> 12) & 0x7)
#define BCM89500_A0_MULTI_PORT_CTLr_RESERVEDf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET(r) ((((r).multi_port_ctl[0]) >> 15) & 0x1)
#define BCM89500_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MULTI_PORT_CTL.
 *
 */
#define BCM89500_A0_READ_MULTI_PORT_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_MULTI_PORT_CTLr,(r._multi_port_ctl),2)
#define BCM89500_A0_WRITE_MULTI_PORT_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_MULTI_PORT_CTLr,&(r._multi_port_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTI_PORT_CTLr BCM89500_A0_MULTI_PORT_CTLr
#define MULTI_PORT_CTLr_SIZE BCM89500_A0_MULTI_PORT_CTLr_SIZE
typedef BCM89500_A0_MULTI_PORT_CTLr_t MULTI_PORT_CTLr_t;
#define MULTI_PORT_CTLr_CLR BCM89500_A0_MULTI_PORT_CTLr_CLR
#define MULTI_PORT_CTLr_SET BCM89500_A0_MULTI_PORT_CTLr_SET
#define MULTI_PORT_CTLr_GET BCM89500_A0_MULTI_PORT_CTLr_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET
#define MULTI_PORT_CTLr_RESERVEDf_GET BCM89500_A0_MULTI_PORT_CTLr_RESERVEDf_GET
#define MULTI_PORT_CTLr_RESERVEDf_SET BCM89500_A0_MULTI_PORT_CTLr_RESERVEDf_SET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_GET BCM89500_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_SET BCM89500_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET
#define READ_MULTI_PORT_CTLr BCM89500_A0_READ_MULTI_PORT_CTLr
#define WRITE_MULTI_PORT_CTLr BCM89500_A0_WRITE_MULTI_PORT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_MULTI_PORT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NEW_CTRL
 * BLOCKS:   SYS
 * DESC:     New Control Register
 * SIZE:     8
 * FIELDS:
 *     IP_MC            When set to a '1' it will support the new 4K IP multicast address scheme. It is illegal to set to zero.(Not2Release)
 *     OUTRANGEERR_DISCARD Out of Range Error DiscardWhen enabled, the ingress port will discard the frames with length field between 1500 and 1536 (exclude 1500 and 1536) and with good CRC. This option only controls the length field checking but not the frame length checking.
 *     INRANGEERR_DISCARD In Range Error DiscardWhen enabled, the ingress port will discard the frames with Length field mismatch the frame length. Following is the definition of InRangeErros. InRangeErrors Frames: The frames received with good CRC and one of the following. The value of Length/Type field is between 46 and 1500 inclusive, and does not match the number of(MAC Client Data + PAD)data octets received, OR The value of Length/Type field is less than 46, and the number of data octets received is greater than 46(which does not require padding).
 *     CABLE_DIAG_LEN   If the cable length is less than the setting value, the green mode setting(cable diagnostic) will enable..0: 10 meters.1: 30 meters.
 *     OVERRIDE_AUTO_PD_WAR Override the default setting for enabling the auto power-down work-around.0: Not override.1: Override.
 *     EN_AUTO_PD_WAR   Enable auto power-down work-around when the bit OVERRIDE_AUTO_PD_WAR is set. 0: Disable.1: Enable.
 *     UC_FWD_EN        Unicast Forward Enable when ARL Miss.1: To enable DFL packet with unicast destination address to foward to ports defined as page 0,offset 34h.
 *     MC_FWD_EN        Multicast Foward Enable when ARL Miss.1: To enable DFL packet with multicast destination address to foward to the ports defined as page 0,offset 34h.
 *
 ******************************************************************************/
#define BCM89500_A0_NEW_CTRLr 0x00000021

#define BCM89500_A0_NEW_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CTRL.
 *
 */
typedef union BCM89500_A0_NEW_CTRLr_s {
	uint32_t v[1];
	uint32_t new_ctrl[1];
	uint32_t _new_ctrl;
} BCM89500_A0_NEW_CTRLr_t;

#define BCM89500_A0_NEW_CTRLr_CLR(r) (r).new_ctrl[0] = 0
#define BCM89500_A0_NEW_CTRLr_SET(r,d) (r).new_ctrl[0] = d
#define BCM89500_A0_NEW_CTRLr_GET(r) (r).new_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NEW_CTRLr_IP_MCf_GET(r) (((r).new_ctrl[0]) & 0x1)
#define BCM89500_A0_NEW_CTRLr_IP_MCf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_NEW_CTRLr_CABLE_DIAG_LENf_GET(r) ((((r).new_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_NEW_CTRLr_CABLE_DIAG_LENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_NEW_CTRLr_OVERRIDE_AUTO_PD_WARf_GET(r) ((((r).new_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_NEW_CTRLr_OVERRIDE_AUTO_PD_WARf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_NEW_CTRLr_EN_AUTO_PD_WARf_GET(r) ((((r).new_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_NEW_CTRLr_EN_AUTO_PD_WARf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_NEW_CTRLr_UC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_NEW_CTRLr_UC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_NEW_CTRLr_MC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_NEW_CTRLr_MC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access NEW_CTRL.
 *
 */
#define BCM89500_A0_READ_NEW_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_NEW_CTRLr,(r._new_ctrl),1)
#define BCM89500_A0_WRITE_NEW_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_NEW_CTRLr,&(r._new_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CTRLr BCM89500_A0_NEW_CTRLr
#define NEW_CTRLr_SIZE BCM89500_A0_NEW_CTRLr_SIZE
typedef BCM89500_A0_NEW_CTRLr_t NEW_CTRLr_t;
#define NEW_CTRLr_CLR BCM89500_A0_NEW_CTRLr_CLR
#define NEW_CTRLr_SET BCM89500_A0_NEW_CTRLr_SET
#define NEW_CTRLr_GET BCM89500_A0_NEW_CTRLr_GET
#define NEW_CTRLr_IP_MCf_GET BCM89500_A0_NEW_CTRLr_IP_MCf_GET
#define NEW_CTRLr_IP_MCf_SET BCM89500_A0_NEW_CTRLr_IP_MCf_SET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_GET BCM89500_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_SET BCM89500_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET
#define NEW_CTRLr_INRANGEERR_DISCARDf_GET BCM89500_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET
#define NEW_CTRLr_INRANGEERR_DISCARDf_SET BCM89500_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET
#define NEW_CTRLr_CABLE_DIAG_LENf_GET BCM89500_A0_NEW_CTRLr_CABLE_DIAG_LENf_GET
#define NEW_CTRLr_CABLE_DIAG_LENf_SET BCM89500_A0_NEW_CTRLr_CABLE_DIAG_LENf_SET
#define NEW_CTRLr_OVERRIDE_AUTO_PD_WARf_GET BCM89500_A0_NEW_CTRLr_OVERRIDE_AUTO_PD_WARf_GET
#define NEW_CTRLr_OVERRIDE_AUTO_PD_WARf_SET BCM89500_A0_NEW_CTRLr_OVERRIDE_AUTO_PD_WARf_SET
#define NEW_CTRLr_EN_AUTO_PD_WARf_GET BCM89500_A0_NEW_CTRLr_EN_AUTO_PD_WARf_GET
#define NEW_CTRLr_EN_AUTO_PD_WARf_SET BCM89500_A0_NEW_CTRLr_EN_AUTO_PD_WARf_SET
#define NEW_CTRLr_UC_FWD_ENf_GET BCM89500_A0_NEW_CTRLr_UC_FWD_ENf_GET
#define NEW_CTRLr_UC_FWD_ENf_SET BCM89500_A0_NEW_CTRLr_UC_FWD_ENf_SET
#define NEW_CTRLr_MC_FWD_ENf_GET BCM89500_A0_NEW_CTRLr_MC_FWD_ENf_GET
#define NEW_CTRLr_MC_FWD_ENf_SET BCM89500_A0_NEW_CTRLr_MC_FWD_ENf_SET
#define READ_NEW_CTRLr BCM89500_A0_READ_NEW_CTRLr
#define WRITE_NEW_CTRLr BCM89500_A0_WRITE_NEW_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NEW_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_1
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register 1
 * SIZE:     16
 * FIELDS:
 *     DPLL_SELECT_MODE DPLL select mode0 - phase lock mode1 - frequency lock mode
 *     TEST_BUS_SEL     (Not2Release)NSE test bus selects5:3 - 000 : counter001 : loop filter010 : delta phase2:1 - 00 : word 101 : word 210 : word 311 : word 4
 *     SPARE_REG0       Reserved
 *     RX_TEST_SEL      (Not2Release)0 - Select the RX slice output to tpinout1 - Select the RX slice input to tpinout
 *     TS_DEBUG_EN      (Not2Release)Enable timestamp debug mode
 *     TS_DEBUG         (Not2Release)3'b000:  0000_0000_AAAA;3'b001:  0000_5555_0000;3'b010:  FFFF_FFFF_FFFF;3'b011:  FFFF_5555_FFFF;3'b100:  8000_0000_AAAA;3'b101:  8000_5555_0000;3'b110:  7FFF_FFFF_FFFF;3'b111:  7FFF_5555_AAAA;
 *     SPARE_REG1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_1r 0x000093ac

#define BCM89500_A0_NSE_DPLL_1r_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_1.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_1r_s {
	uint32_t v[1];
	uint32_t nse_dpll_1[1];
	uint32_t _nse_dpll_1;
} BCM89500_A0_NSE_DPLL_1r_t;

#define BCM89500_A0_NSE_DPLL_1r_CLR(r) (r).nse_dpll_1[0] = 0
#define BCM89500_A0_NSE_DPLL_1r_SET(r,d) (r).nse_dpll_1[0] = d
#define BCM89500_A0_NSE_DPLL_1r_GET(r) (r).nse_dpll_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_1r_DPLL_SELECT_MODEf_GET(r) (((r).nse_dpll_1[0]) & 0x1)
#define BCM89500_A0_NSE_DPLL_1r_DPLL_SELECT_MODEf_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_NSE_DPLL_1r_TEST_BUS_SELf_GET(r) ((((r).nse_dpll_1[0]) >> 1) & 0x1f)
#define BCM89500_A0_NSE_DPLL_1r_TEST_BUS_SELf_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM89500_A0_NSE_DPLL_1r_SPARE_REG0f_GET(r) ((((r).nse_dpll_1[0]) >> 6) & 0x1)
#define BCM89500_A0_NSE_DPLL_1r_SPARE_REG0f_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_NSE_DPLL_1r_RX_TEST_SELf_GET(r) ((((r).nse_dpll_1[0]) >> 7) & 0x1)
#define BCM89500_A0_NSE_DPLL_1r_RX_TEST_SELf_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_NSE_DPLL_1r_TS_DEBUG_ENf_GET(r) ((((r).nse_dpll_1[0]) >> 8) & 0x1)
#define BCM89500_A0_NSE_DPLL_1r_TS_DEBUG_ENf_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_NSE_DPLL_1r_TS_DEBUGf_GET(r) ((((r).nse_dpll_1[0]) >> 9) & 0x7)
#define BCM89500_A0_NSE_DPLL_1r_TS_DEBUGf_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_NSE_DPLL_1r_SPARE_REG1f_GET(r) ((((r).nse_dpll_1[0]) >> 12) & 0xf)
#define BCM89500_A0_NSE_DPLL_1r_SPARE_REG1f_SET(r,f) (r).nse_dpll_1[0]=(((r).nse_dpll_1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access NSE_DPLL_1.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_1r,(r._nse_dpll_1),2)
#define BCM89500_A0_WRITE_NSE_DPLL_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_1r,&(r._nse_dpll_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_1r BCM89500_A0_NSE_DPLL_1r
#define NSE_DPLL_1r_SIZE BCM89500_A0_NSE_DPLL_1r_SIZE
typedef BCM89500_A0_NSE_DPLL_1r_t NSE_DPLL_1r_t;
#define NSE_DPLL_1r_CLR BCM89500_A0_NSE_DPLL_1r_CLR
#define NSE_DPLL_1r_SET BCM89500_A0_NSE_DPLL_1r_SET
#define NSE_DPLL_1r_GET BCM89500_A0_NSE_DPLL_1r_GET
#define NSE_DPLL_1r_DPLL_SELECT_MODEf_GET BCM89500_A0_NSE_DPLL_1r_DPLL_SELECT_MODEf_GET
#define NSE_DPLL_1r_DPLL_SELECT_MODEf_SET BCM89500_A0_NSE_DPLL_1r_DPLL_SELECT_MODEf_SET
#define NSE_DPLL_1r_TEST_BUS_SELf_GET BCM89500_A0_NSE_DPLL_1r_TEST_BUS_SELf_GET
#define NSE_DPLL_1r_TEST_BUS_SELf_SET BCM89500_A0_NSE_DPLL_1r_TEST_BUS_SELf_SET
#define NSE_DPLL_1r_SPARE_REG0f_GET BCM89500_A0_NSE_DPLL_1r_SPARE_REG0f_GET
#define NSE_DPLL_1r_SPARE_REG0f_SET BCM89500_A0_NSE_DPLL_1r_SPARE_REG0f_SET
#define NSE_DPLL_1r_RX_TEST_SELf_GET BCM89500_A0_NSE_DPLL_1r_RX_TEST_SELf_GET
#define NSE_DPLL_1r_RX_TEST_SELf_SET BCM89500_A0_NSE_DPLL_1r_RX_TEST_SELf_SET
#define NSE_DPLL_1r_TS_DEBUG_ENf_GET BCM89500_A0_NSE_DPLL_1r_TS_DEBUG_ENf_GET
#define NSE_DPLL_1r_TS_DEBUG_ENf_SET BCM89500_A0_NSE_DPLL_1r_TS_DEBUG_ENf_SET
#define NSE_DPLL_1r_TS_DEBUGf_GET BCM89500_A0_NSE_DPLL_1r_TS_DEBUGf_GET
#define NSE_DPLL_1r_TS_DEBUGf_SET BCM89500_A0_NSE_DPLL_1r_TS_DEBUGf_SET
#define NSE_DPLL_1r_SPARE_REG1f_GET BCM89500_A0_NSE_DPLL_1r_SPARE_REG1f_GET
#define NSE_DPLL_1r_SPARE_REG1f_SET BCM89500_A0_NSE_DPLL_1r_SPARE_REG1f_SET
#define READ_NSE_DPLL_1r BCM89500_A0_READ_NSE_DPLL_1r
#define WRITE_NSE_DPLL_1r BCM89500_A0_WRITE_NSE_DPLL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_2_N
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register 2_ N
 * SIZE:     16
 * FIELDS:
 *     REF_PHASE_N      DPLL initial reference phaseREF_PHASE = {REF_PHASE_2, REF_PHASE_1, REF_PHASE_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_2_Nr 0x000093ae

#define BCM89500_A0_NSE_DPLL_2_Nr_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_2_N.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_2_Nr_s {
	uint32_t v[1];
	uint32_t nse_dpll_2_n[1];
	uint32_t _nse_dpll_2_n;
} BCM89500_A0_NSE_DPLL_2_Nr_t;

#define BCM89500_A0_NSE_DPLL_2_Nr_CLR(r) (r).nse_dpll_2_n[0] = 0
#define BCM89500_A0_NSE_DPLL_2_Nr_SET(r,d) (r).nse_dpll_2_n[0] = d
#define BCM89500_A0_NSE_DPLL_2_Nr_GET(r) (r).nse_dpll_2_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_2_Nr_REF_PHASE_Nf_GET(r) (((r).nse_dpll_2_n[0]) & 0xffff)
#define BCM89500_A0_NSE_DPLL_2_Nr_REF_PHASE_Nf_SET(r,f) (r).nse_dpll_2_n[0]=(((r).nse_dpll_2_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_DPLL_2_N.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_2_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_2_Nr+(2*(i)),(r._nse_dpll_2_n),2)
#define BCM89500_A0_WRITE_NSE_DPLL_2_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_2_Nr+(2*(i)),&(r._nse_dpll_2_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_2_Nr BCM89500_A0_NSE_DPLL_2_Nr
#define NSE_DPLL_2_Nr_SIZE BCM89500_A0_NSE_DPLL_2_Nr_SIZE
typedef BCM89500_A0_NSE_DPLL_2_Nr_t NSE_DPLL_2_Nr_t;
#define NSE_DPLL_2_Nr_CLR BCM89500_A0_NSE_DPLL_2_Nr_CLR
#define NSE_DPLL_2_Nr_SET BCM89500_A0_NSE_DPLL_2_Nr_SET
#define NSE_DPLL_2_Nr_GET BCM89500_A0_NSE_DPLL_2_Nr_GET
#define NSE_DPLL_2_Nr_REF_PHASE_Nf_GET BCM89500_A0_NSE_DPLL_2_Nr_REF_PHASE_Nf_GET
#define NSE_DPLL_2_Nr_REF_PHASE_Nf_SET BCM89500_A0_NSE_DPLL_2_Nr_REF_PHASE_Nf_SET
#define READ_NSE_DPLL_2_Nr BCM89500_A0_READ_NSE_DPLL_2_Nr
#define WRITE_NSE_DPLL_2_Nr BCM89500_A0_WRITE_NSE_DPLL_2_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_2_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_3_N
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register 3_ N
 * SIZE:     16
 * FIELDS:
 *     REF_PHASE_DELTA_N DPLL initial reference delta phaseREF_PHASE_DELTA = {REF_PHASE_DELTA_1, REF_PHASE_DELTA_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_3_Nr 0x000093b4

#define BCM89500_A0_NSE_DPLL_3_Nr_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_3_N.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_3_Nr_s {
	uint32_t v[1];
	uint32_t nse_dpll_3_n[1];
	uint32_t _nse_dpll_3_n;
} BCM89500_A0_NSE_DPLL_3_Nr_t;

#define BCM89500_A0_NSE_DPLL_3_Nr_CLR(r) (r).nse_dpll_3_n[0] = 0
#define BCM89500_A0_NSE_DPLL_3_Nr_SET(r,d) (r).nse_dpll_3_n[0] = d
#define BCM89500_A0_NSE_DPLL_3_Nr_GET(r) (r).nse_dpll_3_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_3_Nr_REF_PHASE_DELTA_Nf_GET(r) (((r).nse_dpll_3_n[0]) & 0xffff)
#define BCM89500_A0_NSE_DPLL_3_Nr_REF_PHASE_DELTA_Nf_SET(r,f) (r).nse_dpll_3_n[0]=(((r).nse_dpll_3_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_DPLL_3_N.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_3_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_3_Nr+(2*(i)),(r._nse_dpll_3_n),2)
#define BCM89500_A0_WRITE_NSE_DPLL_3_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_3_Nr+(2*(i)),&(r._nse_dpll_3_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_3_Nr BCM89500_A0_NSE_DPLL_3_Nr
#define NSE_DPLL_3_Nr_SIZE BCM89500_A0_NSE_DPLL_3_Nr_SIZE
typedef BCM89500_A0_NSE_DPLL_3_Nr_t NSE_DPLL_3_Nr_t;
#define NSE_DPLL_3_Nr_CLR BCM89500_A0_NSE_DPLL_3_Nr_CLR
#define NSE_DPLL_3_Nr_SET BCM89500_A0_NSE_DPLL_3_Nr_SET
#define NSE_DPLL_3_Nr_GET BCM89500_A0_NSE_DPLL_3_Nr_GET
#define NSE_DPLL_3_Nr_REF_PHASE_DELTA_Nf_GET BCM89500_A0_NSE_DPLL_3_Nr_REF_PHASE_DELTA_Nf_GET
#define NSE_DPLL_3_Nr_REF_PHASE_DELTA_Nf_SET BCM89500_A0_NSE_DPLL_3_Nr_REF_PHASE_DELTA_Nf_SET
#define READ_NSE_DPLL_3_Nr BCM89500_A0_READ_NSE_DPLL_3_Nr
#define WRITE_NSE_DPLL_3_Nr BCM89500_A0_WRITE_NSE_DPLL_3_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_3_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_4
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register 4
 * SIZE:     16
 * FIELDS:
 *     DPLL_K1          DPLL K1
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_4r 0x000093b8

#define BCM89500_A0_NSE_DPLL_4r_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_4.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_4r_s {
	uint32_t v[1];
	uint32_t nse_dpll_4[1];
	uint32_t _nse_dpll_4;
} BCM89500_A0_NSE_DPLL_4r_t;

#define BCM89500_A0_NSE_DPLL_4r_CLR(r) (r).nse_dpll_4[0] = 0
#define BCM89500_A0_NSE_DPLL_4r_SET(r,d) (r).nse_dpll_4[0] = d
#define BCM89500_A0_NSE_DPLL_4r_GET(r) (r).nse_dpll_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_4r_DPLL_K1f_GET(r) (((r).nse_dpll_4[0]) & 0xff)
#define BCM89500_A0_NSE_DPLL_4r_DPLL_K1f_SET(r,f) (r).nse_dpll_4[0]=(((r).nse_dpll_4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_NSE_DPLL_4r_RESERVEDf_GET(r) ((((r).nse_dpll_4[0]) >> 8) & 0xff)
#define BCM89500_A0_NSE_DPLL_4r_RESERVEDf_SET(r,f) (r).nse_dpll_4[0]=(((r).nse_dpll_4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access NSE_DPLL_4.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_4r,(r._nse_dpll_4),2)
#define BCM89500_A0_WRITE_NSE_DPLL_4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_4r,&(r._nse_dpll_4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_4r BCM89500_A0_NSE_DPLL_4r
#define NSE_DPLL_4r_SIZE BCM89500_A0_NSE_DPLL_4r_SIZE
typedef BCM89500_A0_NSE_DPLL_4r_t NSE_DPLL_4r_t;
#define NSE_DPLL_4r_CLR BCM89500_A0_NSE_DPLL_4r_CLR
#define NSE_DPLL_4r_SET BCM89500_A0_NSE_DPLL_4r_SET
#define NSE_DPLL_4r_GET BCM89500_A0_NSE_DPLL_4r_GET
#define NSE_DPLL_4r_DPLL_K1f_GET BCM89500_A0_NSE_DPLL_4r_DPLL_K1f_GET
#define NSE_DPLL_4r_DPLL_K1f_SET BCM89500_A0_NSE_DPLL_4r_DPLL_K1f_SET
#define NSE_DPLL_4r_RESERVEDf_GET BCM89500_A0_NSE_DPLL_4r_RESERVEDf_GET
#define NSE_DPLL_4r_RESERVEDf_SET BCM89500_A0_NSE_DPLL_4r_RESERVEDf_SET
#define READ_NSE_DPLL_4r BCM89500_A0_READ_NSE_DPLL_4r
#define WRITE_NSE_DPLL_4r BCM89500_A0_WRITE_NSE_DPLL_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_5
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register 5
 * SIZE:     16
 * FIELDS:
 *     DPLL_K2          DPLL K2
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_5r 0x000093ba

#define BCM89500_A0_NSE_DPLL_5r_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_5.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_5r_s {
	uint32_t v[1];
	uint32_t nse_dpll_5[1];
	uint32_t _nse_dpll_5;
} BCM89500_A0_NSE_DPLL_5r_t;

#define BCM89500_A0_NSE_DPLL_5r_CLR(r) (r).nse_dpll_5[0] = 0
#define BCM89500_A0_NSE_DPLL_5r_SET(r,d) (r).nse_dpll_5[0] = d
#define BCM89500_A0_NSE_DPLL_5r_GET(r) (r).nse_dpll_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_5r_DPLL_K2f_GET(r) (((r).nse_dpll_5[0]) & 0xff)
#define BCM89500_A0_NSE_DPLL_5r_DPLL_K2f_SET(r,f) (r).nse_dpll_5[0]=(((r).nse_dpll_5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_NSE_DPLL_5r_RESERVEDf_GET(r) ((((r).nse_dpll_5[0]) >> 8) & 0xff)
#define BCM89500_A0_NSE_DPLL_5r_RESERVEDf_SET(r,f) (r).nse_dpll_5[0]=(((r).nse_dpll_5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access NSE_DPLL_5.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_5r,(r._nse_dpll_5),2)
#define BCM89500_A0_WRITE_NSE_DPLL_5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_5r,&(r._nse_dpll_5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_5r BCM89500_A0_NSE_DPLL_5r
#define NSE_DPLL_5r_SIZE BCM89500_A0_NSE_DPLL_5r_SIZE
typedef BCM89500_A0_NSE_DPLL_5r_t NSE_DPLL_5r_t;
#define NSE_DPLL_5r_CLR BCM89500_A0_NSE_DPLL_5r_CLR
#define NSE_DPLL_5r_SET BCM89500_A0_NSE_DPLL_5r_SET
#define NSE_DPLL_5r_GET BCM89500_A0_NSE_DPLL_5r_GET
#define NSE_DPLL_5r_DPLL_K2f_GET BCM89500_A0_NSE_DPLL_5r_DPLL_K2f_GET
#define NSE_DPLL_5r_DPLL_K2f_SET BCM89500_A0_NSE_DPLL_5r_DPLL_K2f_SET
#define NSE_DPLL_5r_RESERVEDf_GET BCM89500_A0_NSE_DPLL_5r_RESERVEDf_GET
#define NSE_DPLL_5r_RESERVEDf_SET BCM89500_A0_NSE_DPLL_5r_RESERVEDf_SET
#define READ_NSE_DPLL_5r BCM89500_A0_READ_NSE_DPLL_5r
#define WRITE_NSE_DPLL_5r BCM89500_A0_WRITE_NSE_DPLL_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_6
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register 6
 * SIZE:     16
 * FIELDS:
 *     DPLL_K3          DPLL K3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_6r 0x000093bc

#define BCM89500_A0_NSE_DPLL_6r_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_6.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_6r_s {
	uint32_t v[1];
	uint32_t nse_dpll_6[1];
	uint32_t _nse_dpll_6;
} BCM89500_A0_NSE_DPLL_6r_t;

#define BCM89500_A0_NSE_DPLL_6r_CLR(r) (r).nse_dpll_6[0] = 0
#define BCM89500_A0_NSE_DPLL_6r_SET(r,d) (r).nse_dpll_6[0] = d
#define BCM89500_A0_NSE_DPLL_6r_GET(r) (r).nse_dpll_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_6r_DPLL_K3f_GET(r) (((r).nse_dpll_6[0]) & 0xff)
#define BCM89500_A0_NSE_DPLL_6r_DPLL_K3f_SET(r,f) (r).nse_dpll_6[0]=(((r).nse_dpll_6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_NSE_DPLL_6r_RESERVEDf_GET(r) ((((r).nse_dpll_6[0]) >> 8) & 0xff)
#define BCM89500_A0_NSE_DPLL_6r_RESERVEDf_SET(r,f) (r).nse_dpll_6[0]=(((r).nse_dpll_6[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access NSE_DPLL_6.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_6r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_6r,(r._nse_dpll_6),2)
#define BCM89500_A0_WRITE_NSE_DPLL_6r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_6r,&(r._nse_dpll_6),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_6r BCM89500_A0_NSE_DPLL_6r
#define NSE_DPLL_6r_SIZE BCM89500_A0_NSE_DPLL_6r_SIZE
typedef BCM89500_A0_NSE_DPLL_6r_t NSE_DPLL_6r_t;
#define NSE_DPLL_6r_CLR BCM89500_A0_NSE_DPLL_6r_CLR
#define NSE_DPLL_6r_SET BCM89500_A0_NSE_DPLL_6r_SET
#define NSE_DPLL_6r_GET BCM89500_A0_NSE_DPLL_6r_GET
#define NSE_DPLL_6r_DPLL_K3f_GET BCM89500_A0_NSE_DPLL_6r_DPLL_K3f_GET
#define NSE_DPLL_6r_DPLL_K3f_SET BCM89500_A0_NSE_DPLL_6r_DPLL_K3f_SET
#define NSE_DPLL_6r_RESERVEDf_GET BCM89500_A0_NSE_DPLL_6r_RESERVEDf_GET
#define NSE_DPLL_6r_RESERVEDf_SET BCM89500_A0_NSE_DPLL_6r_RESERVEDf_SET
#define READ_NSE_DPLL_6r BCM89500_A0_READ_NSE_DPLL_6r
#define WRITE_NSE_DPLL_6r BCM89500_A0_WRITE_NSE_DPLL_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_DPLL_7_N
 * BLOCKS:   SYS
 * DESC:     NSE DPLL Register7_ N
 * SIZE:     16
 * FIELDS:
 *     LOOP_FILTER_N    DPLL initial loop filter valueLOOP_FILTER = {LOOP_FILTER_3, LOOP_FILTER_2, LOOP_FILTER_1, LOOP_FILTER_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_DPLL_7_Nr 0x000093be

#define BCM89500_A0_NSE_DPLL_7_Nr_SIZE 2

/*
 * This structure should be used to declare and program NSE_DPLL_7_N.
 *
 */
typedef union BCM89500_A0_NSE_DPLL_7_Nr_s {
	uint32_t v[1];
	uint32_t nse_dpll_7_n[1];
	uint32_t _nse_dpll_7_n;
} BCM89500_A0_NSE_DPLL_7_Nr_t;

#define BCM89500_A0_NSE_DPLL_7_Nr_CLR(r) (r).nse_dpll_7_n[0] = 0
#define BCM89500_A0_NSE_DPLL_7_Nr_SET(r,d) (r).nse_dpll_7_n[0] = d
#define BCM89500_A0_NSE_DPLL_7_Nr_GET(r) (r).nse_dpll_7_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_DPLL_7_Nr_LOOP_FILTER_Nf_GET(r) (((r).nse_dpll_7_n[0]) & 0xffff)
#define BCM89500_A0_NSE_DPLL_7_Nr_LOOP_FILTER_Nf_SET(r,f) (r).nse_dpll_7_n[0]=(((r).nse_dpll_7_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_DPLL_7_N.
 *
 */
#define BCM89500_A0_READ_NSE_DPLL_7_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_DPLL_7_Nr+(2*(i)),(r._nse_dpll_7_n),2)
#define BCM89500_A0_WRITE_NSE_DPLL_7_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_DPLL_7_Nr+(2*(i)),&(r._nse_dpll_7_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_DPLL_7_Nr BCM89500_A0_NSE_DPLL_7_Nr
#define NSE_DPLL_7_Nr_SIZE BCM89500_A0_NSE_DPLL_7_Nr_SIZE
typedef BCM89500_A0_NSE_DPLL_7_Nr_t NSE_DPLL_7_Nr_t;
#define NSE_DPLL_7_Nr_CLR BCM89500_A0_NSE_DPLL_7_Nr_CLR
#define NSE_DPLL_7_Nr_SET BCM89500_A0_NSE_DPLL_7_Nr_SET
#define NSE_DPLL_7_Nr_GET BCM89500_A0_NSE_DPLL_7_Nr_GET
#define NSE_DPLL_7_Nr_LOOP_FILTER_Nf_GET BCM89500_A0_NSE_DPLL_7_Nr_LOOP_FILTER_Nf_GET
#define NSE_DPLL_7_Nr_LOOP_FILTER_Nf_SET BCM89500_A0_NSE_DPLL_7_Nr_LOOP_FILTER_Nf_SET
#define READ_NSE_DPLL_7_Nr BCM89500_A0_READ_NSE_DPLL_7_Nr
#define WRITE_NSE_DPLL_7_Nr BCM89500_A0_WRITE_NSE_DPLL_7_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_DPLL_7_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_1_N
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 1_ N
 * SIZE:     16
 * FIELDS:
 *     NSE_REG_NCO_FREQCNTRL_N Frequency stepping control registers. Only valid when freq_mdio_sel is set to be 1'b1.NSE_REG_NCO_FREQCNTRL = {NSE_REG_NCO_FREQCNTRL_1, NSE_REG_NCO_FREQCNTRL_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_1_Nr 0x000093c6

#define BCM89500_A0_NSE_NCO_1_Nr_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_1_N.
 *
 */
typedef union BCM89500_A0_NSE_NCO_1_Nr_s {
	uint32_t v[1];
	uint32_t nse_nco_1_n[1];
	uint32_t _nse_nco_1_n;
} BCM89500_A0_NSE_NCO_1_Nr_t;

#define BCM89500_A0_NSE_NCO_1_Nr_CLR(r) (r).nse_nco_1_n[0] = 0
#define BCM89500_A0_NSE_NCO_1_Nr_SET(r,d) (r).nse_nco_1_n[0] = d
#define BCM89500_A0_NSE_NCO_1_Nr_GET(r) (r).nse_nco_1_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_1_Nr_NSE_REG_NCO_FREQCNTRL_Nf_GET(r) (((r).nse_nco_1_n[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_1_Nr_NSE_REG_NCO_FREQCNTRL_Nf_SET(r,f) (r).nse_nco_1_n[0]=(((r).nse_nco_1_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_1_N.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_1_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_1_Nr+(2*(i)),(r._nse_nco_1_n),2)
#define BCM89500_A0_WRITE_NSE_NCO_1_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_1_Nr+(2*(i)),&(r._nse_nco_1_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_1_Nr BCM89500_A0_NSE_NCO_1_Nr
#define NSE_NCO_1_Nr_SIZE BCM89500_A0_NSE_NCO_1_Nr_SIZE
typedef BCM89500_A0_NSE_NCO_1_Nr_t NSE_NCO_1_Nr_t;
#define NSE_NCO_1_Nr_CLR BCM89500_A0_NSE_NCO_1_Nr_CLR
#define NSE_NCO_1_Nr_SET BCM89500_A0_NSE_NCO_1_Nr_SET
#define NSE_NCO_1_Nr_GET BCM89500_A0_NSE_NCO_1_Nr_GET
#define NSE_NCO_1_Nr_NSE_REG_NCO_FREQCNTRL_Nf_GET BCM89500_A0_NSE_NCO_1_Nr_NSE_REG_NCO_FREQCNTRL_Nf_GET
#define NSE_NCO_1_Nr_NSE_REG_NCO_FREQCNTRL_Nf_SET BCM89500_A0_NSE_NCO_1_Nr_NSE_REG_NCO_FREQCNTRL_Nf_SET
#define READ_NSE_NCO_1_Nr BCM89500_A0_READ_NSE_NCO_1_Nr
#define WRITE_NSE_NCO_1_Nr BCM89500_A0_WRITE_NSE_NCO_1_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_1_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_2_N
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 2_ N
 * SIZE:     16
 * FIELDS:
 *     LOCAL_TIME_UP_N  Register to control upper 44 bits of local timerLOCAL_TIME_UP = {LOCAL_TIME_UP_2[11:0], LOCAL_TIME_UP_1, LOCAL_TIME_UP_0}LOCAL_TIME_UP_2[15]:reserved.LOCAL_TIME_UP_2[14]:FREQ_MDIO_SEL1'b1: Use NCO_FREQCNTRL_REG as input for NCO adder.1'b0: Use DPLL as input for NCO adder.LOCAL_TIME_UP_2[13:12]:reserved.
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_2_Nr 0x000093ca

#define BCM89500_A0_NSE_NCO_2_Nr_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_2_N.
 *
 */
typedef union BCM89500_A0_NSE_NCO_2_Nr_s {
	uint32_t v[1];
	uint32_t nse_nco_2_n[1];
	uint32_t _nse_nco_2_n;
} BCM89500_A0_NSE_NCO_2_Nr_t;

#define BCM89500_A0_NSE_NCO_2_Nr_CLR(r) (r).nse_nco_2_n[0] = 0
#define BCM89500_A0_NSE_NCO_2_Nr_SET(r,d) (r).nse_nco_2_n[0] = d
#define BCM89500_A0_NSE_NCO_2_Nr_GET(r) (r).nse_nco_2_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_2_Nr_LOCAL_TIME_UP_Nf_GET(r) (((r).nse_nco_2_n[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_2_Nr_LOCAL_TIME_UP_Nf_SET(r,f) (r).nse_nco_2_n[0]=(((r).nse_nco_2_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_2_N.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_2_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_2_Nr+(2*(i)),(r._nse_nco_2_n),2)
#define BCM89500_A0_WRITE_NSE_NCO_2_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_2_Nr+(2*(i)),&(r._nse_nco_2_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_2_Nr BCM89500_A0_NSE_NCO_2_Nr
#define NSE_NCO_2_Nr_SIZE BCM89500_A0_NSE_NCO_2_Nr_SIZE
typedef BCM89500_A0_NSE_NCO_2_Nr_t NSE_NCO_2_Nr_t;
#define NSE_NCO_2_Nr_CLR BCM89500_A0_NSE_NCO_2_Nr_CLR
#define NSE_NCO_2_Nr_SET BCM89500_A0_NSE_NCO_2_Nr_SET
#define NSE_NCO_2_Nr_GET BCM89500_A0_NSE_NCO_2_Nr_GET
#define NSE_NCO_2_Nr_LOCAL_TIME_UP_Nf_GET BCM89500_A0_NSE_NCO_2_Nr_LOCAL_TIME_UP_Nf_GET
#define NSE_NCO_2_Nr_LOCAL_TIME_UP_Nf_SET BCM89500_A0_NSE_NCO_2_Nr_LOCAL_TIME_UP_Nf_SET
#define READ_NSE_NCO_2_Nr BCM89500_A0_READ_NSE_NCO_2_Nr
#define WRITE_NSE_NCO_2_Nr BCM89500_A0_WRITE_NSE_NCO_2_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_2_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_3_0
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 3_ 0
 * SIZE:     16
 * FIELDS:
 *     INTERVAL_LENGTH_0 Specifies the interval length between two synout pulses.  Align at nco[32:3]. unit=8ns.INTERVAL_LENGTH = {INTERVAL_LENGTH_1, INTERVAL_LENGTH_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_3_0r 0x000093d0

#define BCM89500_A0_NSE_NCO_3_0r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_3_0.
 *
 */
typedef union BCM89500_A0_NSE_NCO_3_0r_s {
	uint32_t v[1];
	uint32_t nse_nco_3_0[1];
	uint32_t _nse_nco_3_0;
} BCM89500_A0_NSE_NCO_3_0r_t;

#define BCM89500_A0_NSE_NCO_3_0r_CLR(r) (r).nse_nco_3_0[0] = 0
#define BCM89500_A0_NSE_NCO_3_0r_SET(r,d) (r).nse_nco_3_0[0] = d
#define BCM89500_A0_NSE_NCO_3_0r_GET(r) (r).nse_nco_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_3_0r_INTERVAL_LENGTH_0f_GET(r) (((r).nse_nco_3_0[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_3_0r_INTERVAL_LENGTH_0f_SET(r,f) (r).nse_nco_3_0[0]=(((r).nse_nco_3_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_3_0.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_3_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_3_0r,(r._nse_nco_3_0),2)
#define BCM89500_A0_WRITE_NSE_NCO_3_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_3_0r,&(r._nse_nco_3_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_3_0r BCM89500_A0_NSE_NCO_3_0r
#define NSE_NCO_3_0r_SIZE BCM89500_A0_NSE_NCO_3_0r_SIZE
typedef BCM89500_A0_NSE_NCO_3_0r_t NSE_NCO_3_0r_t;
#define NSE_NCO_3_0r_CLR BCM89500_A0_NSE_NCO_3_0r_CLR
#define NSE_NCO_3_0r_SET BCM89500_A0_NSE_NCO_3_0r_SET
#define NSE_NCO_3_0r_GET BCM89500_A0_NSE_NCO_3_0r_GET
#define NSE_NCO_3_0r_INTERVAL_LENGTH_0f_GET BCM89500_A0_NSE_NCO_3_0r_INTERVAL_LENGTH_0f_GET
#define NSE_NCO_3_0r_INTERVAL_LENGTH_0f_SET BCM89500_A0_NSE_NCO_3_0r_INTERVAL_LENGTH_0f_SET
#define READ_NSE_NCO_3_0r BCM89500_A0_READ_NSE_NCO_3_0r
#define WRITE_NSE_NCO_3_0r BCM89500_A0_WRITE_NSE_NCO_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_3_1
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 3_ 1
 * SIZE:     16
 * FIELDS:
 *     INTERVAL_LENGTH_1 Specifies the interval length between two synout pulses.  Align at nco[32:3]. unit=8ns.INTERVAL_LENGTH = {INTERVAL_LENGTH_1, INTERVAL_LENGTH_0}
 *     PULSE_TRAIN_LENGTH_0 Specifies the width of the first synout pulse.  Align at nco[11:3]. unit=8ns.PULSE_TRAIN_LENGTH = {PULSE_TRAIN_LENGTH_1, PULSE_TRAIN_LENGTH_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_3_1r 0x000093d2

#define BCM89500_A0_NSE_NCO_3_1r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_3_1.
 *
 */
typedef union BCM89500_A0_NSE_NCO_3_1r_s {
	uint32_t v[1];
	uint32_t nse_nco_3_1[1];
	uint32_t _nse_nco_3_1;
} BCM89500_A0_NSE_NCO_3_1r_t;

#define BCM89500_A0_NSE_NCO_3_1r_CLR(r) (r).nse_nco_3_1[0] = 0
#define BCM89500_A0_NSE_NCO_3_1r_SET(r,d) (r).nse_nco_3_1[0] = d
#define BCM89500_A0_NSE_NCO_3_1r_GET(r) (r).nse_nco_3_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_3_1r_INTERVAL_LENGTH_1f_GET(r) (((r).nse_nco_3_1[0]) & 0x3fff)
#define BCM89500_A0_NSE_NCO_3_1r_INTERVAL_LENGTH_1f_SET(r,f) (r).nse_nco_3_1[0]=(((r).nse_nco_3_1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM89500_A0_NSE_NCO_3_1r_PULSE_TRAIN_LENGTH_0f_GET(r) ((((r).nse_nco_3_1[0]) >> 14) & 0x3)
#define BCM89500_A0_NSE_NCO_3_1r_PULSE_TRAIN_LENGTH_0f_SET(r,f) (r).nse_nco_3_1[0]=(((r).nse_nco_3_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access NSE_NCO_3_1.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_3_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_3_1r,(r._nse_nco_3_1),2)
#define BCM89500_A0_WRITE_NSE_NCO_3_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_3_1r,&(r._nse_nco_3_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_3_1r BCM89500_A0_NSE_NCO_3_1r
#define NSE_NCO_3_1r_SIZE BCM89500_A0_NSE_NCO_3_1r_SIZE
typedef BCM89500_A0_NSE_NCO_3_1r_t NSE_NCO_3_1r_t;
#define NSE_NCO_3_1r_CLR BCM89500_A0_NSE_NCO_3_1r_CLR
#define NSE_NCO_3_1r_SET BCM89500_A0_NSE_NCO_3_1r_SET
#define NSE_NCO_3_1r_GET BCM89500_A0_NSE_NCO_3_1r_GET
#define NSE_NCO_3_1r_INTERVAL_LENGTH_1f_GET BCM89500_A0_NSE_NCO_3_1r_INTERVAL_LENGTH_1f_GET
#define NSE_NCO_3_1r_INTERVAL_LENGTH_1f_SET BCM89500_A0_NSE_NCO_3_1r_INTERVAL_LENGTH_1f_SET
#define NSE_NCO_3_1r_PULSE_TRAIN_LENGTH_0f_GET BCM89500_A0_NSE_NCO_3_1r_PULSE_TRAIN_LENGTH_0f_GET
#define NSE_NCO_3_1r_PULSE_TRAIN_LENGTH_0f_SET BCM89500_A0_NSE_NCO_3_1r_PULSE_TRAIN_LENGTH_0f_SET
#define READ_NSE_NCO_3_1r BCM89500_A0_READ_NSE_NCO_3_1r
#define WRITE_NSE_NCO_3_1r BCM89500_A0_WRITE_NSE_NCO_3_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_3_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_3_2
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 3_ 2
 * SIZE:     16
 * FIELDS:
 *     PULSE_TRAIN_LENGTH_1 Specifies the width of the first synout pulse.  Align at nco[11:3]. unit=8ns.PULSE_TRAIN_LENGTH = {PULSE_TRAIN_LENGTH_1, PULSE_TRAIN_LENGTH_0}
 *     FRMSYNC_PULSE_LENGTH Specifies the width of the second synout pulse.  Align at nco[11:3]. unit=8ns.
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_3_2r 0x000093d4

#define BCM89500_A0_NSE_NCO_3_2r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_3_2.
 *
 */
typedef union BCM89500_A0_NSE_NCO_3_2r_s {
	uint32_t v[1];
	uint32_t nse_nco_3_2[1];
	uint32_t _nse_nco_3_2;
} BCM89500_A0_NSE_NCO_3_2r_t;

#define BCM89500_A0_NSE_NCO_3_2r_CLR(r) (r).nse_nco_3_2[0] = 0
#define BCM89500_A0_NSE_NCO_3_2r_SET(r,d) (r).nse_nco_3_2[0] = d
#define BCM89500_A0_NSE_NCO_3_2r_GET(r) (r).nse_nco_3_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_3_2r_PULSE_TRAIN_LENGTH_1f_GET(r) (((r).nse_nco_3_2[0]) & 0x7f)
#define BCM89500_A0_NSE_NCO_3_2r_PULSE_TRAIN_LENGTH_1f_SET(r,f) (r).nse_nco_3_2[0]=(((r).nse_nco_3_2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM89500_A0_NSE_NCO_3_2r_FRMSYNC_PULSE_LENGTHf_GET(r) ((((r).nse_nco_3_2[0]) >> 7) & 0x1ff)
#define BCM89500_A0_NSE_NCO_3_2r_FRMSYNC_PULSE_LENGTHf_SET(r,f) (r).nse_nco_3_2[0]=(((r).nse_nco_3_2[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access NSE_NCO_3_2.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_3_2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_3_2r,(r._nse_nco_3_2),2)
#define BCM89500_A0_WRITE_NSE_NCO_3_2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_3_2r,&(r._nse_nco_3_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_3_2r BCM89500_A0_NSE_NCO_3_2r
#define NSE_NCO_3_2r_SIZE BCM89500_A0_NSE_NCO_3_2r_SIZE
typedef BCM89500_A0_NSE_NCO_3_2r_t NSE_NCO_3_2r_t;
#define NSE_NCO_3_2r_CLR BCM89500_A0_NSE_NCO_3_2r_CLR
#define NSE_NCO_3_2r_SET BCM89500_A0_NSE_NCO_3_2r_SET
#define NSE_NCO_3_2r_GET BCM89500_A0_NSE_NCO_3_2r_GET
#define NSE_NCO_3_2r_PULSE_TRAIN_LENGTH_1f_GET BCM89500_A0_NSE_NCO_3_2r_PULSE_TRAIN_LENGTH_1f_GET
#define NSE_NCO_3_2r_PULSE_TRAIN_LENGTH_1f_SET BCM89500_A0_NSE_NCO_3_2r_PULSE_TRAIN_LENGTH_1f_SET
#define NSE_NCO_3_2r_FRMSYNC_PULSE_LENGTHf_GET BCM89500_A0_NSE_NCO_3_2r_FRMSYNC_PULSE_LENGTHf_GET
#define NSE_NCO_3_2r_FRMSYNC_PULSE_LENGTHf_SET BCM89500_A0_NSE_NCO_3_2r_FRMSYNC_PULSE_LENGTHf_SET
#define READ_NSE_NCO_3_2r BCM89500_A0_READ_NSE_NCO_3_2r
#define WRITE_NSE_NCO_3_2r BCM89500_A0_WRITE_NSE_NCO_3_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_3_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_4
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 4
 * SIZE:     16
 * FIELDS:
 *     NSE_REG_TS_DIVIDER Divider for syncin.  If it is set to 4, TS will generate one pulse to latch local time into ts_sync_time_reg every 4 syncin pulses.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_4r 0x000093d6

#define BCM89500_A0_NSE_NCO_4r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_4.
 *
 */
typedef union BCM89500_A0_NSE_NCO_4r_s {
	uint32_t v[1];
	uint32_t nse_nco_4[1];
	uint32_t _nse_nco_4;
} BCM89500_A0_NSE_NCO_4r_t;

#define BCM89500_A0_NSE_NCO_4r_CLR(r) (r).nse_nco_4[0] = 0
#define BCM89500_A0_NSE_NCO_4r_SET(r,d) (r).nse_nco_4[0] = d
#define BCM89500_A0_NSE_NCO_4r_GET(r) (r).nse_nco_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_4r_NSE_REG_TS_DIVIDERf_GET(r) (((r).nse_nco_4[0]) & 0xfff)
#define BCM89500_A0_NSE_NCO_4r_NSE_REG_TS_DIVIDERf_SET(r,f) (r).nse_nco_4[0]=(((r).nse_nco_4[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_NSE_NCO_4r_RESERVEDf_GET(r) ((((r).nse_nco_4[0]) >> 12) & 0xf)
#define BCM89500_A0_NSE_NCO_4r_RESERVEDf_SET(r,f) (r).nse_nco_4[0]=(((r).nse_nco_4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access NSE_NCO_4.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_4r,(r._nse_nco_4),2)
#define BCM89500_A0_WRITE_NSE_NCO_4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_4r,&(r._nse_nco_4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_4r BCM89500_A0_NSE_NCO_4r
#define NSE_NCO_4r_SIZE BCM89500_A0_NSE_NCO_4r_SIZE
typedef BCM89500_A0_NSE_NCO_4r_t NSE_NCO_4r_t;
#define NSE_NCO_4r_CLR BCM89500_A0_NSE_NCO_4r_CLR
#define NSE_NCO_4r_SET BCM89500_A0_NSE_NCO_4r_SET
#define NSE_NCO_4r_GET BCM89500_A0_NSE_NCO_4r_GET
#define NSE_NCO_4r_NSE_REG_TS_DIVIDERf_GET BCM89500_A0_NSE_NCO_4r_NSE_REG_TS_DIVIDERf_GET
#define NSE_NCO_4r_NSE_REG_TS_DIVIDERf_SET BCM89500_A0_NSE_NCO_4r_NSE_REG_TS_DIVIDERf_SET
#define NSE_NCO_4r_RESERVEDf_GET BCM89500_A0_NSE_NCO_4r_RESERVEDf_GET
#define NSE_NCO_4r_RESERVEDf_SET BCM89500_A0_NSE_NCO_4r_RESERVEDf_SET
#define READ_NSE_NCO_4r BCM89500_A0_READ_NSE_NCO_4r
#define WRITE_NSE_NCO_4r BCM89500_A0_WRITE_NSE_NCO_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_5_0
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 5_0
 * SIZE:     16
 * FIELDS:
 *     SPARE_REG        ReservedSince the lower 4 bits will change depend on freq controlregister, we do not compare the lower 4 bits.It can be used as reserved register.
 *     SYNOUT_TS_REG_0  When local timer is equal to synout_ts_reg, a one-time pulse will be generated on syncout. Note only [47:4] are used here.SYNOUT_TS_REG = {SYNOUT_TS_REG_2, SYNOUT_TS_REG_1, SYNOUT_TS_REG_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_5_0r 0x000093d8

#define BCM89500_A0_NSE_NCO_5_0r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_5_0.
 *
 */
typedef union BCM89500_A0_NSE_NCO_5_0r_s {
	uint32_t v[1];
	uint32_t nse_nco_5_0[1];
	uint32_t _nse_nco_5_0;
} BCM89500_A0_NSE_NCO_5_0r_t;

#define BCM89500_A0_NSE_NCO_5_0r_CLR(r) (r).nse_nco_5_0[0] = 0
#define BCM89500_A0_NSE_NCO_5_0r_SET(r,d) (r).nse_nco_5_0[0] = d
#define BCM89500_A0_NSE_NCO_5_0r_GET(r) (r).nse_nco_5_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_5_0r_SPARE_REGf_GET(r) (((r).nse_nco_5_0[0]) & 0xf)
#define BCM89500_A0_NSE_NCO_5_0r_SPARE_REGf_SET(r,f) (r).nse_nco_5_0[0]=(((r).nse_nco_5_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_NSE_NCO_5_0r_SYNOUT_TS_REG_0f_GET(r) ((((r).nse_nco_5_0[0]) >> 4) & 0xfff)
#define BCM89500_A0_NSE_NCO_5_0r_SYNOUT_TS_REG_0f_SET(r,f) (r).nse_nco_5_0[0]=(((r).nse_nco_5_0[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access NSE_NCO_5_0.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_5_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_5_0r,(r._nse_nco_5_0),2)
#define BCM89500_A0_WRITE_NSE_NCO_5_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_5_0r,&(r._nse_nco_5_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_5_0r BCM89500_A0_NSE_NCO_5_0r
#define NSE_NCO_5_0r_SIZE BCM89500_A0_NSE_NCO_5_0r_SIZE
typedef BCM89500_A0_NSE_NCO_5_0r_t NSE_NCO_5_0r_t;
#define NSE_NCO_5_0r_CLR BCM89500_A0_NSE_NCO_5_0r_CLR
#define NSE_NCO_5_0r_SET BCM89500_A0_NSE_NCO_5_0r_SET
#define NSE_NCO_5_0r_GET BCM89500_A0_NSE_NCO_5_0r_GET
#define NSE_NCO_5_0r_SPARE_REGf_GET BCM89500_A0_NSE_NCO_5_0r_SPARE_REGf_GET
#define NSE_NCO_5_0r_SPARE_REGf_SET BCM89500_A0_NSE_NCO_5_0r_SPARE_REGf_SET
#define NSE_NCO_5_0r_SYNOUT_TS_REG_0f_GET BCM89500_A0_NSE_NCO_5_0r_SYNOUT_TS_REG_0f_GET
#define NSE_NCO_5_0r_SYNOUT_TS_REG_0f_SET BCM89500_A0_NSE_NCO_5_0r_SYNOUT_TS_REG_0f_SET
#define READ_NSE_NCO_5_0r BCM89500_A0_READ_NSE_NCO_5_0r
#define WRITE_NSE_NCO_5_0r BCM89500_A0_WRITE_NSE_NCO_5_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_5_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_5_1
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 5_1
 * SIZE:     16
 * FIELDS:
 *     SYNOUT_TS_REG_1  When local timer is equal to synout_ts_reg, a one-time pulse will be generated on syncout. Note only [47:4] are used here.SYNOUT_TS_REG = {SYNOUT_TS_REG_2, SYNOUT_TS_REG_1, SYNOUT_TS_REG_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_5_1r 0x000093da

#define BCM89500_A0_NSE_NCO_5_1r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_5_1.
 *
 */
typedef union BCM89500_A0_NSE_NCO_5_1r_s {
	uint32_t v[1];
	uint32_t nse_nco_5_1[1];
	uint32_t _nse_nco_5_1;
} BCM89500_A0_NSE_NCO_5_1r_t;

#define BCM89500_A0_NSE_NCO_5_1r_CLR(r) (r).nse_nco_5_1[0] = 0
#define BCM89500_A0_NSE_NCO_5_1r_SET(r,d) (r).nse_nco_5_1[0] = d
#define BCM89500_A0_NSE_NCO_5_1r_GET(r) (r).nse_nco_5_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_5_1r_SYNOUT_TS_REG_1f_GET(r) (((r).nse_nco_5_1[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_5_1r_SYNOUT_TS_REG_1f_SET(r,f) (r).nse_nco_5_1[0]=(((r).nse_nco_5_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_5_1.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_5_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_5_1r,(r._nse_nco_5_1),2)
#define BCM89500_A0_WRITE_NSE_NCO_5_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_5_1r,&(r._nse_nco_5_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_5_1r BCM89500_A0_NSE_NCO_5_1r
#define NSE_NCO_5_1r_SIZE BCM89500_A0_NSE_NCO_5_1r_SIZE
typedef BCM89500_A0_NSE_NCO_5_1r_t NSE_NCO_5_1r_t;
#define NSE_NCO_5_1r_CLR BCM89500_A0_NSE_NCO_5_1r_CLR
#define NSE_NCO_5_1r_SET BCM89500_A0_NSE_NCO_5_1r_SET
#define NSE_NCO_5_1r_GET BCM89500_A0_NSE_NCO_5_1r_GET
#define NSE_NCO_5_1r_SYNOUT_TS_REG_1f_GET BCM89500_A0_NSE_NCO_5_1r_SYNOUT_TS_REG_1f_GET
#define NSE_NCO_5_1r_SYNOUT_TS_REG_1f_SET BCM89500_A0_NSE_NCO_5_1r_SYNOUT_TS_REG_1f_SET
#define READ_NSE_NCO_5_1r BCM89500_A0_READ_NSE_NCO_5_1r
#define WRITE_NSE_NCO_5_1r BCM89500_A0_WRITE_NSE_NCO_5_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_5_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_5_2
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 5_2
 * SIZE:     16
 * FIELDS:
 *     SYNOUT_TS_REG_2  When local timer is equal to synout_ts_reg, a one-time pulse will be generated on syncout. Note only [47:4] are used here.SYNOUT_TS_REG = {SYNOUT_TS_REG_2, SYNOUT_TS_REG_1, SYNOUT_TS_REG_0}
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_5_2r 0x000093dc

#define BCM89500_A0_NSE_NCO_5_2r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_5_2.
 *
 */
typedef union BCM89500_A0_NSE_NCO_5_2r_s {
	uint32_t v[1];
	uint32_t nse_nco_5_2[1];
	uint32_t _nse_nco_5_2;
} BCM89500_A0_NSE_NCO_5_2r_t;

#define BCM89500_A0_NSE_NCO_5_2r_CLR(r) (r).nse_nco_5_2[0] = 0
#define BCM89500_A0_NSE_NCO_5_2r_SET(r,d) (r).nse_nco_5_2[0] = d
#define BCM89500_A0_NSE_NCO_5_2r_GET(r) (r).nse_nco_5_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_5_2r_SYNOUT_TS_REG_2f_GET(r) (((r).nse_nco_5_2[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_5_2r_SYNOUT_TS_REG_2f_SET(r,f) (r).nse_nco_5_2[0]=(((r).nse_nco_5_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_5_2.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_5_2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_5_2r,(r._nse_nco_5_2),2)
#define BCM89500_A0_WRITE_NSE_NCO_5_2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_5_2r,&(r._nse_nco_5_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_5_2r BCM89500_A0_NSE_NCO_5_2r
#define NSE_NCO_5_2r_SIZE BCM89500_A0_NSE_NCO_5_2r_SIZE
typedef BCM89500_A0_NSE_NCO_5_2r_t NSE_NCO_5_2r_t;
#define NSE_NCO_5_2r_CLR BCM89500_A0_NSE_NCO_5_2r_CLR
#define NSE_NCO_5_2r_SET BCM89500_A0_NSE_NCO_5_2r_SET
#define NSE_NCO_5_2r_GET BCM89500_A0_NSE_NCO_5_2r_GET
#define NSE_NCO_5_2r_SYNOUT_TS_REG_2f_GET BCM89500_A0_NSE_NCO_5_2r_SYNOUT_TS_REG_2f_GET
#define NSE_NCO_5_2r_SYNOUT_TS_REG_2f_SET BCM89500_A0_NSE_NCO_5_2r_SYNOUT_TS_REG_2f_SET
#define READ_NSE_NCO_5_2r BCM89500_A0_READ_NSE_NCO_5_2r
#define WRITE_NSE_NCO_5_2r BCM89500_A0_WRITE_NSE_NCO_5_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_5_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_6
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 6
 * SIZE:     16
 * FIELDS:
 *     SYNOUT_MODE      Sync out mode selection2'b00: power-up default. sync_out pin functions as sync_in1.2'b01: generate a one time output pulse on a match with synout_ts_reg2'b10: generate a pulse train.  Detailed pulse train specification is in NSE NCO Register 4.2'b11: generate a pulse train and insert a one time frame sync event, under sync out mode1 condition.
 *     FRAMESYN_MODE    Only valid when gmode is set to 2'b11.  Used when CPU is involved in the system.bit[2]: use long pulse on syncin0 for frame syncbit[3]: use syncin1 as frame syncbit[4]: use internal syncout as frame syncbit[5]: cpu trigger immediate frame sync
 *     SPARE_REG0       Reserved
 *     RESET_SYNC_STATE Diagnostic purpose only:  reset sync FSM back to idle state
 *     RESET_SYNCIN_STATE Diagnostic purpose only:  reset syncin FSM back to idle state
 *     RESET_LOCK_STATE Diagnostic purpose only:  reset lock FSM back to idle state
 *     SPARE_REG1       Reserved
 *     M34_LOCAL_SYNC_DIS Disable syncout treat as local sync in when synin_mode equal to 3 or 4
 *     NSE_INIT         1 - Initialize NSE block
 *     TS_CAPTURE       1 - enable time stamp to be captured by ts_capture_time on the next frame sync event0 - no time stamp will be captured by ts_capture_time register on the next frame sync event
 *     GMODE            Global synchronization mode selection2'b01: Assumes that all PHYs in the system share the same TX clock. No hot plugging. NCO is set to nominal Frequency (equivalent to free-running). SyncIn0  is used as a One-Time reset signal, or alternatively power up reset.2'b10: Assumes that PHYs do not share the same TX clock. No hot plugging. Assumes that CPU is not involved in synchronization process. No MDIO initialization is required. SyncIn0 is used to distribute a reference clock to all PHYs. FrameSync only, at rate = 1kHz. DPLL is used to lock to SyncIn0 signal.2'b11: Assumes that PHYs do not share the same TX clock. Hot plugging allowed. Assumes that a CPU is involved:CPU can control the SyncIn0/1 signal going to the PHYs (via some simple FPGA, or using SyncOut on one of the PHYs).CPU will issue MDIO commands, to be executed on next FrameSync (on SyncIn0 or SyncIn1 inputs). DPLL is used to lock to SyncIn0 Signal.
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_6r 0x000093de

#define BCM89500_A0_NSE_NCO_6r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_6.
 *
 */
typedef union BCM89500_A0_NSE_NCO_6r_s {
	uint32_t v[1];
	uint32_t nse_nco_6[1];
	uint32_t _nse_nco_6;
} BCM89500_A0_NSE_NCO_6r_t;

#define BCM89500_A0_NSE_NCO_6r_CLR(r) (r).nse_nco_6[0] = 0
#define BCM89500_A0_NSE_NCO_6r_SET(r,d) (r).nse_nco_6[0] = d
#define BCM89500_A0_NSE_NCO_6r_GET(r) (r).nse_nco_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_6r_SYNOUT_MODEf_GET(r) (((r).nse_nco_6[0]) & 0x3)
#define BCM89500_A0_NSE_NCO_6r_SYNOUT_MODEf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_NSE_NCO_6r_FRAMESYN_MODEf_GET(r) ((((r).nse_nco_6[0]) >> 2) & 0xf)
#define BCM89500_A0_NSE_NCO_6r_FRAMESYN_MODEf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM89500_A0_NSE_NCO_6r_SPARE_REG0f_GET(r) ((((r).nse_nco_6[0]) >> 6) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_SPARE_REG0f_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_NSE_NCO_6r_RESET_SYNC_STATEf_GET(r) ((((r).nse_nco_6[0]) >> 7) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_RESET_SYNC_STATEf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_NSE_NCO_6r_RESET_SYNCIN_STATEf_GET(r) ((((r).nse_nco_6[0]) >> 8) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_RESET_SYNCIN_STATEf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_NSE_NCO_6r_RESET_LOCK_STATEf_GET(r) ((((r).nse_nco_6[0]) >> 9) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_RESET_LOCK_STATEf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_NSE_NCO_6r_SPARE_REG1f_GET(r) ((((r).nse_nco_6[0]) >> 10) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_SPARE_REG1f_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_NSE_NCO_6r_M34_LOCAL_SYNC_DISf_GET(r) ((((r).nse_nco_6[0]) >> 11) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_M34_LOCAL_SYNC_DISf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_NSE_NCO_6r_NSE_INITf_GET(r) ((((r).nse_nco_6[0]) >> 12) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_NSE_INITf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_NSE_NCO_6r_TS_CAPTUREf_GET(r) ((((r).nse_nco_6[0]) >> 13) & 0x1)
#define BCM89500_A0_NSE_NCO_6r_TS_CAPTUREf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_NSE_NCO_6r_GMODEf_GET(r) ((((r).nse_nco_6[0]) >> 14) & 0x3)
#define BCM89500_A0_NSE_NCO_6r_GMODEf_SET(r,f) (r).nse_nco_6[0]=(((r).nse_nco_6[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access NSE_NCO_6.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_6r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_6r,(r._nse_nco_6),2)
#define BCM89500_A0_WRITE_NSE_NCO_6r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_6r,&(r._nse_nco_6),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_6r BCM89500_A0_NSE_NCO_6r
#define NSE_NCO_6r_SIZE BCM89500_A0_NSE_NCO_6r_SIZE
typedef BCM89500_A0_NSE_NCO_6r_t NSE_NCO_6r_t;
#define NSE_NCO_6r_CLR BCM89500_A0_NSE_NCO_6r_CLR
#define NSE_NCO_6r_SET BCM89500_A0_NSE_NCO_6r_SET
#define NSE_NCO_6r_GET BCM89500_A0_NSE_NCO_6r_GET
#define NSE_NCO_6r_SYNOUT_MODEf_GET BCM89500_A0_NSE_NCO_6r_SYNOUT_MODEf_GET
#define NSE_NCO_6r_SYNOUT_MODEf_SET BCM89500_A0_NSE_NCO_6r_SYNOUT_MODEf_SET
#define NSE_NCO_6r_FRAMESYN_MODEf_GET BCM89500_A0_NSE_NCO_6r_FRAMESYN_MODEf_GET
#define NSE_NCO_6r_FRAMESYN_MODEf_SET BCM89500_A0_NSE_NCO_6r_FRAMESYN_MODEf_SET
#define NSE_NCO_6r_SPARE_REG0f_GET BCM89500_A0_NSE_NCO_6r_SPARE_REG0f_GET
#define NSE_NCO_6r_SPARE_REG0f_SET BCM89500_A0_NSE_NCO_6r_SPARE_REG0f_SET
#define NSE_NCO_6r_RESET_SYNC_STATEf_GET BCM89500_A0_NSE_NCO_6r_RESET_SYNC_STATEf_GET
#define NSE_NCO_6r_RESET_SYNC_STATEf_SET BCM89500_A0_NSE_NCO_6r_RESET_SYNC_STATEf_SET
#define NSE_NCO_6r_RESET_SYNCIN_STATEf_GET BCM89500_A0_NSE_NCO_6r_RESET_SYNCIN_STATEf_GET
#define NSE_NCO_6r_RESET_SYNCIN_STATEf_SET BCM89500_A0_NSE_NCO_6r_RESET_SYNCIN_STATEf_SET
#define NSE_NCO_6r_RESET_LOCK_STATEf_GET BCM89500_A0_NSE_NCO_6r_RESET_LOCK_STATEf_GET
#define NSE_NCO_6r_RESET_LOCK_STATEf_SET BCM89500_A0_NSE_NCO_6r_RESET_LOCK_STATEf_SET
#define NSE_NCO_6r_SPARE_REG1f_GET BCM89500_A0_NSE_NCO_6r_SPARE_REG1f_GET
#define NSE_NCO_6r_SPARE_REG1f_SET BCM89500_A0_NSE_NCO_6r_SPARE_REG1f_SET
#define NSE_NCO_6r_M34_LOCAL_SYNC_DISf_GET BCM89500_A0_NSE_NCO_6r_M34_LOCAL_SYNC_DISf_GET
#define NSE_NCO_6r_M34_LOCAL_SYNC_DISf_SET BCM89500_A0_NSE_NCO_6r_M34_LOCAL_SYNC_DISf_SET
#define NSE_NCO_6r_NSE_INITf_GET BCM89500_A0_NSE_NCO_6r_NSE_INITf_GET
#define NSE_NCO_6r_NSE_INITf_SET BCM89500_A0_NSE_NCO_6r_NSE_INITf_SET
#define NSE_NCO_6r_TS_CAPTUREf_GET BCM89500_A0_NSE_NCO_6r_TS_CAPTUREf_GET
#define NSE_NCO_6r_TS_CAPTUREf_SET BCM89500_A0_NSE_NCO_6r_TS_CAPTUREf_SET
#define NSE_NCO_6r_GMODEf_GET BCM89500_A0_NSE_NCO_6r_GMODEf_GET
#define NSE_NCO_6r_GMODEf_SET BCM89500_A0_NSE_NCO_6r_GMODEf_SET
#define READ_NSE_NCO_6r BCM89500_A0_READ_NSE_NCO_6r
#define WRITE_NSE_NCO_6r BCM89500_A0_WRITE_NSE_NCO_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_7_0
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 7_0
 * SIZE:     16
 * FIELDS:
 *     LENGTH_THRESHOLD Length to specify frame sync condition.  Align at NCO[18:3].
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_7_0r 0x000093e0

#define BCM89500_A0_NSE_NCO_7_0r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_7_0.
 *
 */
typedef union BCM89500_A0_NSE_NCO_7_0r_s {
	uint32_t v[1];
	uint32_t nse_nco_7_0[1];
	uint32_t _nse_nco_7_0;
} BCM89500_A0_NSE_NCO_7_0r_t;

#define BCM89500_A0_NSE_NCO_7_0r_CLR(r) (r).nse_nco_7_0[0] = 0
#define BCM89500_A0_NSE_NCO_7_0r_SET(r,d) (r).nse_nco_7_0[0] = d
#define BCM89500_A0_NSE_NCO_7_0r_GET(r) (r).nse_nco_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_7_0r_LENGTH_THRESHOLDf_GET(r) (((r).nse_nco_7_0[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_7_0r_LENGTH_THRESHOLDf_SET(r,f) (r).nse_nco_7_0[0]=(((r).nse_nco_7_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_7_0.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_7_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_7_0r,(r._nse_nco_7_0),2)
#define BCM89500_A0_WRITE_NSE_NCO_7_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_7_0r,&(r._nse_nco_7_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_7_0r BCM89500_A0_NSE_NCO_7_0r
#define NSE_NCO_7_0r_SIZE BCM89500_A0_NSE_NCO_7_0r_SIZE
typedef BCM89500_A0_NSE_NCO_7_0r_t NSE_NCO_7_0r_t;
#define NSE_NCO_7_0r_CLR BCM89500_A0_NSE_NCO_7_0r_CLR
#define NSE_NCO_7_0r_SET BCM89500_A0_NSE_NCO_7_0r_SET
#define NSE_NCO_7_0r_GET BCM89500_A0_NSE_NCO_7_0r_GET
#define NSE_NCO_7_0r_LENGTH_THRESHOLDf_GET BCM89500_A0_NSE_NCO_7_0r_LENGTH_THRESHOLDf_GET
#define NSE_NCO_7_0r_LENGTH_THRESHOLDf_SET BCM89500_A0_NSE_NCO_7_0r_LENGTH_THRESHOLDf_SET
#define READ_NSE_NCO_7_0r BCM89500_A0_READ_NSE_NCO_7_0r
#define WRITE_NSE_NCO_7_0r BCM89500_A0_WRITE_NSE_NCO_7_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  NSE_NCO_7_1
 * BLOCKS:   SYS
 * DESC:     NSE NCO Register 7_1
 * SIZE:     16
 * FIELDS:
 *     EVENT_OFFSET     Offset timer for frame sync to kick off.  Align at NCO[18:3].
 *
 ******************************************************************************/
#define BCM89500_A0_NSE_NCO_7_1r 0x000093e2

#define BCM89500_A0_NSE_NCO_7_1r_SIZE 2

/*
 * This structure should be used to declare and program NSE_NCO_7_1.
 *
 */
typedef union BCM89500_A0_NSE_NCO_7_1r_s {
	uint32_t v[1];
	uint32_t nse_nco_7_1[1];
	uint32_t _nse_nco_7_1;
} BCM89500_A0_NSE_NCO_7_1r_t;

#define BCM89500_A0_NSE_NCO_7_1r_CLR(r) (r).nse_nco_7_1[0] = 0
#define BCM89500_A0_NSE_NCO_7_1r_SET(r,d) (r).nse_nco_7_1[0] = d
#define BCM89500_A0_NSE_NCO_7_1r_GET(r) (r).nse_nco_7_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_NSE_NCO_7_1r_EVENT_OFFSETf_GET(r) (((r).nse_nco_7_1[0]) & 0xffff)
#define BCM89500_A0_NSE_NCO_7_1r_EVENT_OFFSETf_SET(r,f) (r).nse_nco_7_1[0]=(((r).nse_nco_7_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NSE_NCO_7_1.
 *
 */
#define BCM89500_A0_READ_NSE_NCO_7_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_NSE_NCO_7_1r,(r._nse_nco_7_1),2)
#define BCM89500_A0_WRITE_NSE_NCO_7_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_NSE_NCO_7_1r,&(r._nse_nco_7_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NSE_NCO_7_1r BCM89500_A0_NSE_NCO_7_1r
#define NSE_NCO_7_1r_SIZE BCM89500_A0_NSE_NCO_7_1r_SIZE
typedef BCM89500_A0_NSE_NCO_7_1r_t NSE_NCO_7_1r_t;
#define NSE_NCO_7_1r_CLR BCM89500_A0_NSE_NCO_7_1r_CLR
#define NSE_NCO_7_1r_SET BCM89500_A0_NSE_NCO_7_1r_SET
#define NSE_NCO_7_1r_GET BCM89500_A0_NSE_NCO_7_1r_GET
#define NSE_NCO_7_1r_EVENT_OFFSETf_GET BCM89500_A0_NSE_NCO_7_1r_EVENT_OFFSETf_GET
#define NSE_NCO_7_1r_EVENT_OFFSETf_SET BCM89500_A0_NSE_NCO_7_1r_EVENT_OFFSETf_SET
#define READ_NSE_NCO_7_1r BCM89500_A0_READ_NSE_NCO_7_1r
#define WRITE_NSE_NCO_7_1r BCM89500_A0_WRITE_NSE_NCO_7_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_NSE_NCO_7_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OOB_PAUSE_EN
 * BLOCKS:   SYS
 * DESC:     OOB Pause Signal Enable Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     OOB_PAUSE_EN     Per port out of band (OOB) pause signal enable1: Use out-of-band signal for Switch and SOC flow control0: Use pause frame for Switch and SOC flow controlbit[8]: reservedbit[7]: port7bit[6:0]: reserved
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_OOB_PAUSE_ENr 0x00000ae0

#define BCM89500_A0_OOB_PAUSE_ENr_SIZE 2

/*
 * This structure should be used to declare and program OOB_PAUSE_EN.
 *
 */
typedef union BCM89500_A0_OOB_PAUSE_ENr_s {
	uint32_t v[1];
	uint32_t oob_pause_en[1];
	uint32_t _oob_pause_en;
} BCM89500_A0_OOB_PAUSE_ENr_t;

#define BCM89500_A0_OOB_PAUSE_ENr_CLR(r) (r).oob_pause_en[0] = 0
#define BCM89500_A0_OOB_PAUSE_ENr_SET(r,d) (r).oob_pause_en[0] = d
#define BCM89500_A0_OOB_PAUSE_ENr_GET(r) (r).oob_pause_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OOB_PAUSE_ENr_OOB_PAUSE_ENf_GET(r) (((r).oob_pause_en[0]) & 0x1ff)
#define BCM89500_A0_OOB_PAUSE_ENr_OOB_PAUSE_ENf_SET(r,f) (r).oob_pause_en[0]=(((r).oob_pause_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_OOB_PAUSE_ENr_RESERVEDf_GET(r) ((((r).oob_pause_en[0]) >> 9) & 0x7f)
#define BCM89500_A0_OOB_PAUSE_ENr_RESERVEDf_SET(r,f) (r).oob_pause_en[0]=(((r).oob_pause_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access OOB_PAUSE_EN.
 *
 */
#define BCM89500_A0_READ_OOB_PAUSE_ENr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OOB_PAUSE_ENr,(r._oob_pause_en),2)
#define BCM89500_A0_WRITE_OOB_PAUSE_ENr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OOB_PAUSE_ENr,&(r._oob_pause_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OOB_PAUSE_ENr BCM89500_A0_OOB_PAUSE_ENr
#define OOB_PAUSE_ENr_SIZE BCM89500_A0_OOB_PAUSE_ENr_SIZE
typedef BCM89500_A0_OOB_PAUSE_ENr_t OOB_PAUSE_ENr_t;
#define OOB_PAUSE_ENr_CLR BCM89500_A0_OOB_PAUSE_ENr_CLR
#define OOB_PAUSE_ENr_SET BCM89500_A0_OOB_PAUSE_ENr_SET
#define OOB_PAUSE_ENr_GET BCM89500_A0_OOB_PAUSE_ENr_GET
#define OOB_PAUSE_ENr_OOB_PAUSE_ENf_GET BCM89500_A0_OOB_PAUSE_ENr_OOB_PAUSE_ENf_GET
#define OOB_PAUSE_ENr_OOB_PAUSE_ENf_SET BCM89500_A0_OOB_PAUSE_ENr_OOB_PAUSE_ENf_SET
#define OOB_PAUSE_ENr_RESERVEDf_GET BCM89500_A0_OOB_PAUSE_ENr_RESERVEDf_GET
#define OOB_PAUSE_ENr_RESERVEDf_SET BCM89500_A0_OOB_PAUSE_ENr_RESERVEDf_SET
#define READ_OOB_PAUSE_ENr BCM89500_A0_READ_OOB_PAUSE_ENr
#define WRITE_OOB_PAUSE_ENr BCM89500_A0_WRITE_OOB_PAUSE_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OOB_PAUSE_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OTHER_OTPID
 * BLOCKS:   SYS
 * DESC:     VLAN 2tags Other OTPID Registers
 * SIZE:     16
 * FIELDS:
 *     OTPID_2          The other TPID VLAN 2 tags.
 *
 ******************************************************************************/
#define BCM89500_A0_OTHER_OTPIDr 0x000093aa

#define BCM89500_A0_OTHER_OTPIDr_SIZE 2

/*
 * This structure should be used to declare and program OTHER_OTPID.
 *
 */
typedef union BCM89500_A0_OTHER_OTPIDr_s {
	uint32_t v[1];
	uint32_t other_otpid[1];
	uint32_t _other_otpid;
} BCM89500_A0_OTHER_OTPIDr_t;

#define BCM89500_A0_OTHER_OTPIDr_CLR(r) (r).other_otpid[0] = 0
#define BCM89500_A0_OTHER_OTPIDr_SET(r,d) (r).other_otpid[0] = d
#define BCM89500_A0_OTHER_OTPIDr_GET(r) (r).other_otpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OTHER_OTPIDr_OTPID_2f_GET(r) (((r).other_otpid[0]) & 0xffff)
#define BCM89500_A0_OTHER_OTPIDr_OTPID_2f_SET(r,f) (r).other_otpid[0]=(((r).other_otpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access OTHER_OTPID.
 *
 */
#define BCM89500_A0_READ_OTHER_OTPIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OTHER_OTPIDr,(r._other_otpid),2)
#define BCM89500_A0_WRITE_OTHER_OTPIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OTHER_OTPIDr,&(r._other_otpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTHER_OTPIDr BCM89500_A0_OTHER_OTPIDr
#define OTHER_OTPIDr_SIZE BCM89500_A0_OTHER_OTPIDr_SIZE
typedef BCM89500_A0_OTHER_OTPIDr_t OTHER_OTPIDr_t;
#define OTHER_OTPIDr_CLR BCM89500_A0_OTHER_OTPIDr_CLR
#define OTHER_OTPIDr_SET BCM89500_A0_OTHER_OTPIDr_SET
#define OTHER_OTPIDr_GET BCM89500_A0_OTHER_OTPIDr_GET
#define OTHER_OTPIDr_OTPID_2f_GET BCM89500_A0_OTHER_OTPIDr_OTPID_2f_GET
#define OTHER_OTPIDr_OTPID_2f_SET BCM89500_A0_OTHER_OTPIDr_OTPID_2f_SET
#define READ_OTHER_OTPIDr BCM89500_A0_READ_OTHER_OTPIDr
#define WRITE_OTHER_OTPIDr BCM89500_A0_WRITE_OTHER_OTPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OTHER_OTPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OTP_ADDR_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Address Registers
 * SIZE:     16
 * FIELDS:
 *     CPU_ADDR         The 16 bits CPU OTP address register provides up to 64k bit address space for OTP program,read access from CPU interface.In prog_word command, it determines the address of the entire memory row to be programmed or the data to be read
 *
 ******************************************************************************/
#define BCM89500_A0_OTP_ADDR_REGr 0x0000e004

#define BCM89500_A0_OTP_ADDR_REGr_SIZE 2

/*
 * This structure should be used to declare and program OTP_ADDR_REG.
 *
 */
typedef union BCM89500_A0_OTP_ADDR_REGr_s {
	uint32_t v[1];
	uint32_t otp_addr_reg[1];
	uint32_t _otp_addr_reg;
} BCM89500_A0_OTP_ADDR_REGr_t;

#define BCM89500_A0_OTP_ADDR_REGr_CLR(r) (r).otp_addr_reg[0] = 0
#define BCM89500_A0_OTP_ADDR_REGr_SET(r,d) (r).otp_addr_reg[0] = d
#define BCM89500_A0_OTP_ADDR_REGr_GET(r) (r).otp_addr_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OTP_ADDR_REGr_CPU_ADDRf_GET(r) (((r).otp_addr_reg[0]) & 0xffff)
#define BCM89500_A0_OTP_ADDR_REGr_CPU_ADDRf_SET(r,f) (r).otp_addr_reg[0]=(((r).otp_addr_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access OTP_ADDR_REG.
 *
 */
#define BCM89500_A0_READ_OTP_ADDR_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OTP_ADDR_REGr,(r._otp_addr_reg),2)
#define BCM89500_A0_WRITE_OTP_ADDR_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OTP_ADDR_REGr,&(r._otp_addr_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_ADDR_REGr BCM89500_A0_OTP_ADDR_REGr
#define OTP_ADDR_REGr_SIZE BCM89500_A0_OTP_ADDR_REGr_SIZE
typedef BCM89500_A0_OTP_ADDR_REGr_t OTP_ADDR_REGr_t;
#define OTP_ADDR_REGr_CLR BCM89500_A0_OTP_ADDR_REGr_CLR
#define OTP_ADDR_REGr_SET BCM89500_A0_OTP_ADDR_REGr_SET
#define OTP_ADDR_REGr_GET BCM89500_A0_OTP_ADDR_REGr_GET
#define OTP_ADDR_REGr_CPU_ADDRf_GET BCM89500_A0_OTP_ADDR_REGr_CPU_ADDRf_GET
#define OTP_ADDR_REGr_CPU_ADDRf_SET BCM89500_A0_OTP_ADDR_REGr_CPU_ADDRf_SET
#define READ_OTP_ADDR_REGr BCM89500_A0_READ_OTP_ADDR_REGr
#define WRITE_OTP_ADDR_REGr BCM89500_A0_WRITE_OTP_ADDR_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OTP_ADDR_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OTP_CTL_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Control Registers
 * SIZE:     32
 * FIELDS:
 *     START            Rising edge of the signal will execute OTP command
 *     COMMAND          0: Read1: Program Bit internal clk2: Program Word3: Verify4: Init5: Set6: Reset7: OCST8: Lock9: Prescreen test10: Program bit External clock mode V field programming mode11: Program Word external clock
 *     WRP_PROG_SEL     Program select V debug only, selects which of the 2 analog bit cells to burn(bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_VSEL         verify level select V debug only (bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_PCOUNT       A FAIL was returned from the wrapper logic. The part is bad
 *     WRP_PBYP         OTP cell clock control V debug only (bit [20] of this register must be set in order to see the affect of this bits)
 *     UNUSED           
 *     WRP_SADBYP       sadbpy: senseAmp delay bypass V  debug only (bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_TIME_MARGIN  timing margin - debug only  (bit [20] of this register must be set in order to see the affect of this bits)
 *     WRP_CONTINUE_ON_FAIL 0 = OTP will hang jtag_wrapper module on fail V stay in PROG_FAIL state forever OR until reset is applied (or this bit is made 1). 1= OTP will set the FAIL status and continue to accept commands.Please note that even if this bit is 0, the jtag_otp module as such will not hang and the status indicates that there was programming failure.It is only the wrapper module that hangs.Command_done signal will be asserted even in this condition
 *     OTP_DEBUG_MODE   Causes bits [18:5] to be used for direct OTP control V used by the library group for debugging.The bits [18:5] are control bits of the OTP memory that can be programmed using software (CPU interface)
 *     OTP_PROG_EN      Only when otp_prog_en is 1, otp programming from cpu side is enabled.Set this pin to 0 will disable otp programming from cpu side.This bit is usually driven by chip pin to prevent otp programming from cpu side when chip ship to customer
 *     ACCESS_MODE      00 = Raw. This mode is used for all commands except for prog_bit and prog_word command01= manufacturing  area 10= configuration bits area 11= ram repair bits areaThe modes 01, 10 and 11 are used during prog_bit and prog_word commands
 *     BURST_STAT_SEL   Used during word program command.0=data from the OTP memory is sent out,1= FAIL returned for programmed bits is sent out (used to debug the failed bits during burst program)
 *     CPU_DEBUG_SEL    Select signal used to define if data or debug signals are sent to the o_otp_cpu_data output. 8'd0: data signals are sent to o_otp_cpu_data output8'd1: o_otp_cpu_data monitor otp_jtag_debug[31:0]8'd2: o_otp_cpu_data monitor otp_jtag_debug[63:32]8'd3: o_otp_cpu_data monitor otp_jtag_debug[95:64]8'd4: o_otp_cpu_data monitor otp_jtag_debug[127:96]8'd5: o_otp_cpu_data monitor otp_jtag_status[31:0]8'd6: o_otp_cpu_data monitor otp_jtag_status[63:32]8'd7: o_otp_cpu_data monitor otp_jtag_status[95:64]8'd8: o_otp_cpu_data monitor otp_jtag_status[127:96]Other: data signals are sent to o_otp_cpu_data output(Not2Release)
 *     RESERVED         Reserved for future expansion.
 *     BYPASS_OTP_CLK   When set, use TCK throughout the JTAG_OTP IP. This control bit affects only CPU transactions.
 *
 ******************************************************************************/
#define BCM89500_A0_OTP_CTL_REGr 0x0000e000

#define BCM89500_A0_OTP_CTL_REGr_SIZE 4

/*
 * This structure should be used to declare and program OTP_CTL_REG.
 *
 */
typedef union BCM89500_A0_OTP_CTL_REGr_s {
	uint32_t v[1];
	uint32_t otp_ctl_reg[1];
	uint32_t _otp_ctl_reg;
} BCM89500_A0_OTP_CTL_REGr_t;

#define BCM89500_A0_OTP_CTL_REGr_CLR(r) (r).otp_ctl_reg[0] = 0
#define BCM89500_A0_OTP_CTL_REGr_SET(r,d) (r).otp_ctl_reg[0] = d
#define BCM89500_A0_OTP_CTL_REGr_GET(r) (r).otp_ctl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OTP_CTL_REGr_STARTf_GET(r) (((r).otp_ctl_reg[0]) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_STARTf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_OTP_CTL_REGr_COMMANDf_GET(r) ((((r).otp_ctl_reg[0]) >> 1) & 0xf)
#define BCM89500_A0_OTP_CTL_REGr_COMMANDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM89500_A0_OTP_CTL_REGr_WRP_PROG_SELf_GET(r) ((((r).otp_ctl_reg[0]) >> 5) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_WRP_PROG_SELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_OTP_CTL_REGr_WRP_VSELf_GET(r) ((((r).otp_ctl_reg[0]) >> 6) & 0xf)
#define BCM89500_A0_OTP_CTL_REGr_WRP_VSELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM89500_A0_OTP_CTL_REGr_WRP_PCOUNTf_GET(r) ((((r).otp_ctl_reg[0]) >> 10) & 0x7)
#define BCM89500_A0_OTP_CTL_REGr_WRP_PCOUNTf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_OTP_CTL_REGr_WRP_PBYPf_GET(r) ((((r).otp_ctl_reg[0]) >> 13) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_WRP_PBYPf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_OTP_CTL_REGr_UNUSEDf_GET(r) ((((r).otp_ctl_reg[0]) >> 14) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_UNUSEDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_OTP_CTL_REGr_WRP_SADBYPf_GET(r) ((((r).otp_ctl_reg[0]) >> 15) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_WRP_SADBYPf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_GET(r) ((((r).otp_ctl_reg[0]) >> 16) & 0x7)
#define BCM89500_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM89500_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_GET(r) ((((r).otp_ctl_reg[0]) >> 19) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_GET(r) ((((r).otp_ctl_reg[0]) >> 20) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_OTP_CTL_REGr_OTP_PROG_ENf_GET(r) ((((r).otp_ctl_reg[0]) >> 21) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_OTP_PROG_ENf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM89500_A0_OTP_CTL_REGr_ACCESS_MODEf_GET(r) ((((r).otp_ctl_reg[0]) >> 22) & 0x3)
#define BCM89500_A0_OTP_CTL_REGr_ACCESS_MODEf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM89500_A0_OTP_CTL_REGr_BURST_STAT_SELf_GET(r) ((((r).otp_ctl_reg[0]) >> 24) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_BURST_STAT_SELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM89500_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_GET(r) ((((r).otp_ctl_reg[0]) >> 25) & 0xf)
#define BCM89500_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM89500_A0_OTP_CTL_REGr_RESERVEDf_GET(r) ((((r).otp_ctl_reg[0]) >> 29) & 0x3)
#define BCM89500_A0_OTP_CTL_REGr_RESERVEDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_GET(r) ((((r).otp_ctl_reg[0]) >> 31) & 0x1)
#define BCM89500_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access OTP_CTL_REG.
 *
 */
#define BCM89500_A0_READ_OTP_CTL_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OTP_CTL_REGr,(r._otp_ctl_reg),4)
#define BCM89500_A0_WRITE_OTP_CTL_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OTP_CTL_REGr,&(r._otp_ctl_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_CTL_REGr BCM89500_A0_OTP_CTL_REGr
#define OTP_CTL_REGr_SIZE BCM89500_A0_OTP_CTL_REGr_SIZE
typedef BCM89500_A0_OTP_CTL_REGr_t OTP_CTL_REGr_t;
#define OTP_CTL_REGr_CLR BCM89500_A0_OTP_CTL_REGr_CLR
#define OTP_CTL_REGr_SET BCM89500_A0_OTP_CTL_REGr_SET
#define OTP_CTL_REGr_GET BCM89500_A0_OTP_CTL_REGr_GET
#define OTP_CTL_REGr_STARTf_GET BCM89500_A0_OTP_CTL_REGr_STARTf_GET
#define OTP_CTL_REGr_STARTf_SET BCM89500_A0_OTP_CTL_REGr_STARTf_SET
#define OTP_CTL_REGr_COMMANDf_GET BCM89500_A0_OTP_CTL_REGr_COMMANDf_GET
#define OTP_CTL_REGr_COMMANDf_SET BCM89500_A0_OTP_CTL_REGr_COMMANDf_SET
#define OTP_CTL_REGr_WRP_PROG_SELf_GET BCM89500_A0_OTP_CTL_REGr_WRP_PROG_SELf_GET
#define OTP_CTL_REGr_WRP_PROG_SELf_SET BCM89500_A0_OTP_CTL_REGr_WRP_PROG_SELf_SET
#define OTP_CTL_REGr_WRP_VSELf_GET BCM89500_A0_OTP_CTL_REGr_WRP_VSELf_GET
#define OTP_CTL_REGr_WRP_VSELf_SET BCM89500_A0_OTP_CTL_REGr_WRP_VSELf_SET
#define OTP_CTL_REGr_WRP_PCOUNTf_GET BCM89500_A0_OTP_CTL_REGr_WRP_PCOUNTf_GET
#define OTP_CTL_REGr_WRP_PCOUNTf_SET BCM89500_A0_OTP_CTL_REGr_WRP_PCOUNTf_SET
#define OTP_CTL_REGr_WRP_PBYPf_GET BCM89500_A0_OTP_CTL_REGr_WRP_PBYPf_GET
#define OTP_CTL_REGr_WRP_PBYPf_SET BCM89500_A0_OTP_CTL_REGr_WRP_PBYPf_SET
#define OTP_CTL_REGr_UNUSEDf_GET BCM89500_A0_OTP_CTL_REGr_UNUSEDf_GET
#define OTP_CTL_REGr_UNUSEDf_SET BCM89500_A0_OTP_CTL_REGr_UNUSEDf_SET
#define OTP_CTL_REGr_WRP_SADBYPf_GET BCM89500_A0_OTP_CTL_REGr_WRP_SADBYPf_GET
#define OTP_CTL_REGr_WRP_SADBYPf_SET BCM89500_A0_OTP_CTL_REGr_WRP_SADBYPf_SET
#define OTP_CTL_REGr_WRP_TIME_MARGINf_GET BCM89500_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_GET
#define OTP_CTL_REGr_WRP_TIME_MARGINf_SET BCM89500_A0_OTP_CTL_REGr_WRP_TIME_MARGINf_SET
#define OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_GET BCM89500_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_GET
#define OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_SET BCM89500_A0_OTP_CTL_REGr_WRP_CONTINUE_ON_FAILf_SET
#define OTP_CTL_REGr_OTP_DEBUG_MODEf_GET BCM89500_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_GET
#define OTP_CTL_REGr_OTP_DEBUG_MODEf_SET BCM89500_A0_OTP_CTL_REGr_OTP_DEBUG_MODEf_SET
#define OTP_CTL_REGr_OTP_PROG_ENf_GET BCM89500_A0_OTP_CTL_REGr_OTP_PROG_ENf_GET
#define OTP_CTL_REGr_OTP_PROG_ENf_SET BCM89500_A0_OTP_CTL_REGr_OTP_PROG_ENf_SET
#define OTP_CTL_REGr_ACCESS_MODEf_GET BCM89500_A0_OTP_CTL_REGr_ACCESS_MODEf_GET
#define OTP_CTL_REGr_ACCESS_MODEf_SET BCM89500_A0_OTP_CTL_REGr_ACCESS_MODEf_SET
#define OTP_CTL_REGr_BURST_STAT_SELf_GET BCM89500_A0_OTP_CTL_REGr_BURST_STAT_SELf_GET
#define OTP_CTL_REGr_BURST_STAT_SELf_SET BCM89500_A0_OTP_CTL_REGr_BURST_STAT_SELf_SET
#define OTP_CTL_REGr_CPU_DEBUG_SELf_GET BCM89500_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_GET
#define OTP_CTL_REGr_CPU_DEBUG_SELf_SET BCM89500_A0_OTP_CTL_REGr_CPU_DEBUG_SELf_SET
#define OTP_CTL_REGr_RESERVEDf_GET BCM89500_A0_OTP_CTL_REGr_RESERVEDf_GET
#define OTP_CTL_REGr_RESERVEDf_SET BCM89500_A0_OTP_CTL_REGr_RESERVEDf_SET
#define OTP_CTL_REGr_BYPASS_OTP_CLKf_GET BCM89500_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_GET
#define OTP_CTL_REGr_BYPASS_OTP_CLKf_SET BCM89500_A0_OTP_CTL_REGr_BYPASS_OTP_CLKf_SET
#define READ_OTP_CTL_REGr BCM89500_A0_READ_OTP_CTL_REGr
#define WRITE_OTP_CTL_REGr BCM89500_A0_WRITE_OTP_CTL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OTP_CTL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OTP_RD_DATA
 * BLOCKS:   SYS
 * DESC:     CPU OTP Read Data Registers
 * SIZE:     32
 * FIELDS:
 *     CPU_RD_DATA      The 32 bit CPU OTP read data register outputs the 32 bit read data from read command of CPU interface
 *
 ******************************************************************************/
#define BCM89500_A0_OTP_RD_DATAr 0x0000e00c

#define BCM89500_A0_OTP_RD_DATAr_SIZE 4

/*
 * This structure should be used to declare and program OTP_RD_DATA.
 *
 */
typedef union BCM89500_A0_OTP_RD_DATAr_s {
	uint32_t v[1];
	uint32_t otp_rd_data[1];
	uint32_t _otp_rd_data;
} BCM89500_A0_OTP_RD_DATAr_t;

#define BCM89500_A0_OTP_RD_DATAr_CLR(r) (r).otp_rd_data[0] = 0
#define BCM89500_A0_OTP_RD_DATAr_SET(r,d) (r).otp_rd_data[0] = d
#define BCM89500_A0_OTP_RD_DATAr_GET(r) (r).otp_rd_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OTP_RD_DATAr_CPU_RD_DATAf_GET(r) ((r).otp_rd_data[0])
#define BCM89500_A0_OTP_RD_DATAr_CPU_RD_DATAf_SET(r,f) (r).otp_rd_data[0]=((uint32_t)f)

/*
 * These macros can be used to access OTP_RD_DATA.
 *
 */
#define BCM89500_A0_READ_OTP_RD_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OTP_RD_DATAr,(r._otp_rd_data),4)
#define BCM89500_A0_WRITE_OTP_RD_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OTP_RD_DATAr,&(r._otp_rd_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_RD_DATAr BCM89500_A0_OTP_RD_DATAr
#define OTP_RD_DATAr_SIZE BCM89500_A0_OTP_RD_DATAr_SIZE
typedef BCM89500_A0_OTP_RD_DATAr_t OTP_RD_DATAr_t;
#define OTP_RD_DATAr_CLR BCM89500_A0_OTP_RD_DATAr_CLR
#define OTP_RD_DATAr_SET BCM89500_A0_OTP_RD_DATAr_SET
#define OTP_RD_DATAr_GET BCM89500_A0_OTP_RD_DATAr_GET
#define OTP_RD_DATAr_CPU_RD_DATAf_GET BCM89500_A0_OTP_RD_DATAr_CPU_RD_DATAf_GET
#define OTP_RD_DATAr_CPU_RD_DATAf_SET BCM89500_A0_OTP_RD_DATAr_CPU_RD_DATAf_SET
#define READ_OTP_RD_DATAr BCM89500_A0_READ_OTP_RD_DATAr
#define WRITE_OTP_RD_DATAr BCM89500_A0_WRITE_OTP_RD_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OTP_RD_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OTP_STS_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Status Registers
 * SIZE:     16
 * FIELDS:
 *     COMMAND_DONE     This bit is set when the state machine has returned to IDLE.This will not be set until the last bit of a WORD program is complete.
 *     WRP_DATA_READY   The wrp_dout is now valid to read.
 *     WRP_DOUT         This is the single bit data pointed to by the 12 bit address
 *     WRP_BUSY         A wrp_busy was seen V your request was started. Check command_done (bit 0) to see when it is complete
 *     WRP_FAIL         A FAIL was returned from the wrapper logic. The part is bad
 *     INVALID_PROG_REQ A program request was sent with the incorrect access mode and 12 bit address settings
 *     PROG_BLOCKED     The row is locked and the programming attempt was not allowed
 *     INIT_WAIT_DONE   Can be used to indicate when the OTP is out of RESET.Also if this bit is not a 1, there is no clock to the block OR the block is still in RESET
 *     UNUSED_1         
 *     INVALID_COMMAND  An invalid command was issued.
 *     WRP_ERROR        The wrapper module state machine went into an error state. Else returns 0.
 *     CONTROL_ERR      The control module state machine went into an error state. Else returns 0.
 *     UNUSED_0         
 *
 ******************************************************************************/
#define BCM89500_A0_OTP_STS_REGr 0x0000e006

#define BCM89500_A0_OTP_STS_REGr_SIZE 2

/*
 * This structure should be used to declare and program OTP_STS_REG.
 *
 */
typedef union BCM89500_A0_OTP_STS_REGr_s {
	uint32_t v[1];
	uint32_t otp_sts_reg[1];
	uint32_t _otp_sts_reg;
} BCM89500_A0_OTP_STS_REGr_t;

#define BCM89500_A0_OTP_STS_REGr_CLR(r) (r).otp_sts_reg[0] = 0
#define BCM89500_A0_OTP_STS_REGr_SET(r,d) (r).otp_sts_reg[0] = d
#define BCM89500_A0_OTP_STS_REGr_GET(r) (r).otp_sts_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OTP_STS_REGr_COMMAND_DONEf_GET(r) (((r).otp_sts_reg[0]) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_COMMAND_DONEf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_OTP_STS_REGr_WRP_DATA_READYf_GET(r) ((((r).otp_sts_reg[0]) >> 1) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_WRP_DATA_READYf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_OTP_STS_REGr_WRP_DOUTf_GET(r) ((((r).otp_sts_reg[0]) >> 2) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_WRP_DOUTf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_OTP_STS_REGr_WRP_BUSYf_GET(r) ((((r).otp_sts_reg[0]) >> 3) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_WRP_BUSYf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_OTP_STS_REGr_WRP_FAILf_GET(r) ((((r).otp_sts_reg[0]) >> 4) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_WRP_FAILf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_OTP_STS_REGr_INVALID_PROG_REQf_GET(r) ((((r).otp_sts_reg[0]) >> 5) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_INVALID_PROG_REQf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_OTP_STS_REGr_PROG_BLOCKEDf_GET(r) ((((r).otp_sts_reg[0]) >> 6) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_PROG_BLOCKEDf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_OTP_STS_REGr_INIT_WAIT_DONEf_GET(r) ((((r).otp_sts_reg[0]) >> 7) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_INIT_WAIT_DONEf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_OTP_STS_REGr_UNUSED_1f_GET(r) ((((r).otp_sts_reg[0]) >> 8) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_UNUSED_1f_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_OTP_STS_REGr_INVALID_COMMANDf_GET(r) ((((r).otp_sts_reg[0]) >> 9) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_INVALID_COMMANDf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_OTP_STS_REGr_WRP_ERRORf_GET(r) ((((r).otp_sts_reg[0]) >> 10) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_WRP_ERRORf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_OTP_STS_REGr_CONTROL_ERRf_GET(r) ((((r).otp_sts_reg[0]) >> 11) & 0x1)
#define BCM89500_A0_OTP_STS_REGr_CONTROL_ERRf_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_OTP_STS_REGr_UNUSED_0f_GET(r) ((((r).otp_sts_reg[0]) >> 12) & 0xf)
#define BCM89500_A0_OTP_STS_REGr_UNUSED_0f_SET(r,f) (r).otp_sts_reg[0]=(((r).otp_sts_reg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access OTP_STS_REG.
 *
 */
#define BCM89500_A0_READ_OTP_STS_REGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OTP_STS_REGr,(r._otp_sts_reg),2)
#define BCM89500_A0_WRITE_OTP_STS_REGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OTP_STS_REGr,&(r._otp_sts_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_STS_REGr BCM89500_A0_OTP_STS_REGr
#define OTP_STS_REGr_SIZE BCM89500_A0_OTP_STS_REGr_SIZE
typedef BCM89500_A0_OTP_STS_REGr_t OTP_STS_REGr_t;
#define OTP_STS_REGr_CLR BCM89500_A0_OTP_STS_REGr_CLR
#define OTP_STS_REGr_SET BCM89500_A0_OTP_STS_REGr_SET
#define OTP_STS_REGr_GET BCM89500_A0_OTP_STS_REGr_GET
#define OTP_STS_REGr_COMMAND_DONEf_GET BCM89500_A0_OTP_STS_REGr_COMMAND_DONEf_GET
#define OTP_STS_REGr_COMMAND_DONEf_SET BCM89500_A0_OTP_STS_REGr_COMMAND_DONEf_SET
#define OTP_STS_REGr_WRP_DATA_READYf_GET BCM89500_A0_OTP_STS_REGr_WRP_DATA_READYf_GET
#define OTP_STS_REGr_WRP_DATA_READYf_SET BCM89500_A0_OTP_STS_REGr_WRP_DATA_READYf_SET
#define OTP_STS_REGr_WRP_DOUTf_GET BCM89500_A0_OTP_STS_REGr_WRP_DOUTf_GET
#define OTP_STS_REGr_WRP_DOUTf_SET BCM89500_A0_OTP_STS_REGr_WRP_DOUTf_SET
#define OTP_STS_REGr_WRP_BUSYf_GET BCM89500_A0_OTP_STS_REGr_WRP_BUSYf_GET
#define OTP_STS_REGr_WRP_BUSYf_SET BCM89500_A0_OTP_STS_REGr_WRP_BUSYf_SET
#define OTP_STS_REGr_WRP_FAILf_GET BCM89500_A0_OTP_STS_REGr_WRP_FAILf_GET
#define OTP_STS_REGr_WRP_FAILf_SET BCM89500_A0_OTP_STS_REGr_WRP_FAILf_SET
#define OTP_STS_REGr_INVALID_PROG_REQf_GET BCM89500_A0_OTP_STS_REGr_INVALID_PROG_REQf_GET
#define OTP_STS_REGr_INVALID_PROG_REQf_SET BCM89500_A0_OTP_STS_REGr_INVALID_PROG_REQf_SET
#define OTP_STS_REGr_PROG_BLOCKEDf_GET BCM89500_A0_OTP_STS_REGr_PROG_BLOCKEDf_GET
#define OTP_STS_REGr_PROG_BLOCKEDf_SET BCM89500_A0_OTP_STS_REGr_PROG_BLOCKEDf_SET
#define OTP_STS_REGr_INIT_WAIT_DONEf_GET BCM89500_A0_OTP_STS_REGr_INIT_WAIT_DONEf_GET
#define OTP_STS_REGr_INIT_WAIT_DONEf_SET BCM89500_A0_OTP_STS_REGr_INIT_WAIT_DONEf_SET
#define OTP_STS_REGr_UNUSED_1f_GET BCM89500_A0_OTP_STS_REGr_UNUSED_1f_GET
#define OTP_STS_REGr_UNUSED_1f_SET BCM89500_A0_OTP_STS_REGr_UNUSED_1f_SET
#define OTP_STS_REGr_INVALID_COMMANDf_GET BCM89500_A0_OTP_STS_REGr_INVALID_COMMANDf_GET
#define OTP_STS_REGr_INVALID_COMMANDf_SET BCM89500_A0_OTP_STS_REGr_INVALID_COMMANDf_SET
#define OTP_STS_REGr_WRP_ERRORf_GET BCM89500_A0_OTP_STS_REGr_WRP_ERRORf_GET
#define OTP_STS_REGr_WRP_ERRORf_SET BCM89500_A0_OTP_STS_REGr_WRP_ERRORf_SET
#define OTP_STS_REGr_CONTROL_ERRf_GET BCM89500_A0_OTP_STS_REGr_CONTROL_ERRf_GET
#define OTP_STS_REGr_CONTROL_ERRf_SET BCM89500_A0_OTP_STS_REGr_CONTROL_ERRf_SET
#define OTP_STS_REGr_UNUSED_0f_GET BCM89500_A0_OTP_STS_REGr_UNUSED_0f_GET
#define OTP_STS_REGr_UNUSED_0f_SET BCM89500_A0_OTP_STS_REGr_UNUSED_0f_SET
#define READ_OTP_STS_REGr BCM89500_A0_READ_OTP_STS_REGr
#define WRITE_OTP_STS_REGr BCM89500_A0_WRITE_OTP_STS_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OTP_STS_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OTP_WR_DATA
 * BLOCKS:   SYS
 * DESC:     CPU OTP Write Data Registers
 * SIZE:     32
 * FIELDS:
 *     CPU_WR_DATA      The 32 bit CPU OTP write data register is used to provide write data with burst write command from CPU side.Different than the burst write from JTAG, cpu interface only supports 32 bit burst write data.This is to reduce the number of bits needed to wire to cpu interface at top level
 *
 ******************************************************************************/
#define BCM89500_A0_OTP_WR_DATAr 0x0000e008

#define BCM89500_A0_OTP_WR_DATAr_SIZE 4

/*
 * This structure should be used to declare and program OTP_WR_DATA.
 *
 */
typedef union BCM89500_A0_OTP_WR_DATAr_s {
	uint32_t v[1];
	uint32_t otp_wr_data[1];
	uint32_t _otp_wr_data;
} BCM89500_A0_OTP_WR_DATAr_t;

#define BCM89500_A0_OTP_WR_DATAr_CLR(r) (r).otp_wr_data[0] = 0
#define BCM89500_A0_OTP_WR_DATAr_SET(r,d) (r).otp_wr_data[0] = d
#define BCM89500_A0_OTP_WR_DATAr_GET(r) (r).otp_wr_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_OTP_WR_DATAr_CPU_WR_DATAf_GET(r) ((r).otp_wr_data[0])
#define BCM89500_A0_OTP_WR_DATAr_CPU_WR_DATAf_SET(r,f) (r).otp_wr_data[0]=((uint32_t)f)

/*
 * These macros can be used to access OTP_WR_DATA.
 *
 */
#define BCM89500_A0_READ_OTP_WR_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OTP_WR_DATAr,(r._otp_wr_data),4)
#define BCM89500_A0_WRITE_OTP_WR_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OTP_WR_DATAr,&(r._otp_wr_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_WR_DATAr BCM89500_A0_OTP_WR_DATAr
#define OTP_WR_DATAr_SIZE BCM89500_A0_OTP_WR_DATAr_SIZE
typedef BCM89500_A0_OTP_WR_DATAr_t OTP_WR_DATAr_t;
#define OTP_WR_DATAr_CLR BCM89500_A0_OTP_WR_DATAr_CLR
#define OTP_WR_DATAr_SET BCM89500_A0_OTP_WR_DATAr_SET
#define OTP_WR_DATAr_GET BCM89500_A0_OTP_WR_DATAr_GET
#define OTP_WR_DATAr_CPU_WR_DATAf_GET BCM89500_A0_OTP_WR_DATAr_CPU_WR_DATAf_GET
#define OTP_WR_DATAr_CPU_WR_DATAf_SET BCM89500_A0_OTP_WR_DATAr_CPU_WR_DATAf_SET
#define READ_OTP_WR_DATAr BCM89500_A0_READ_OTP_WR_DATAr
#define WRITE_OTP_WR_DATAr BCM89500_A0_WRITE_OTP_WR_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OTP_WR_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OutRangeErrCount
 * BLOCKS:   GPIC0 CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_OUTRANGEERRCOUNTr 0x000020b4

#define BCM89500_A0_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount.
 *
 */
typedef union BCM89500_A0_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount[1];
	uint32_t _outrangeerrcount;
} BCM89500_A0_OUTRANGEERRCOUNTr_t;

#define BCM89500_A0_OUTRANGEERRCOUNTr_CLR(r) (r).outrangeerrcount[0] = 0
#define BCM89500_A0_OUTRANGEERRCOUNTr_SET(r,d) (r).outrangeerrcount[0] = d
#define BCM89500_A0_OUTRANGEERRCOUNTr_GET(r) (r).outrangeerrcount[0]


/*
 * These macros can be used to access OutRangeErrCount.
 *
 */
#define BCM89500_A0_READ_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_OUTRANGEERRCOUNTr,(r._outrangeerrcount),4)
#define BCM89500_A0_WRITE_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_OUTRANGEERRCOUNTr,&(r._outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNTr BCM89500_A0_OUTRANGEERRCOUNTr
#define OUTRANGEERRCOUNTr_SIZE BCM89500_A0_OUTRANGEERRCOUNTr_SIZE
typedef BCM89500_A0_OUTRANGEERRCOUNTr_t OUTRANGEERRCOUNTr_t;
#define OUTRANGEERRCOUNTr_CLR BCM89500_A0_OUTRANGEERRCOUNTr_CLR
#define OUTRANGEERRCOUNTr_SET BCM89500_A0_OUTRANGEERRCOUNTr_SET
#define OUTRANGEERRCOUNTr_GET BCM89500_A0_OUTRANGEERRCOUNTr_GET
#define READ_OUTRANGEERRCOUNTr BCM89500_A0_READ_OUTRANGEERRCOUNTr
#define WRITE_OUTRANGEERRCOUNTr BCM89500_A0_WRITE_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OutRangeErrCount_IMP
 * BLOCKS:   CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_OUTRANGEERRCOUNT_IMPr 0x000028b4

#define BCM89500_A0_OUTRANGEERRCOUNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount_IMP.
 *
 */
typedef union BCM89500_A0_OUTRANGEERRCOUNT_IMPr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount_imp[1];
	uint32_t _outrangeerrcount_imp;
} BCM89500_A0_OUTRANGEERRCOUNT_IMPr_t;

#define BCM89500_A0_OUTRANGEERRCOUNT_IMPr_CLR(r) (r).outrangeerrcount_imp[0] = 0
#define BCM89500_A0_OUTRANGEERRCOUNT_IMPr_SET(r,d) (r).outrangeerrcount_imp[0] = d
#define BCM89500_A0_OUTRANGEERRCOUNT_IMPr_GET(r) (r).outrangeerrcount_imp[0]


/*
 * These macros can be used to access OutRangeErrCount_IMP.
 *
 */
#define BCM89500_A0_READ_OUTRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_OUTRANGEERRCOUNT_IMPr,(r._outrangeerrcount_imp),4)
#define BCM89500_A0_WRITE_OUTRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_OUTRANGEERRCOUNT_IMPr,&(r._outrangeerrcount_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNT_IMPr BCM89500_A0_OUTRANGEERRCOUNT_IMPr
#define OUTRANGEERRCOUNT_IMPr_SIZE BCM89500_A0_OUTRANGEERRCOUNT_IMPr_SIZE
typedef BCM89500_A0_OUTRANGEERRCOUNT_IMPr_t OUTRANGEERRCOUNT_IMPr_t;
#define OUTRANGEERRCOUNT_IMPr_CLR BCM89500_A0_OUTRANGEERRCOUNT_IMPr_CLR
#define OUTRANGEERRCOUNT_IMPr_SET BCM89500_A0_OUTRANGEERRCOUNT_IMPr_SET
#define OUTRANGEERRCOUNT_IMPr_GET BCM89500_A0_OUTRANGEERRCOUNT_IMPr_GET
#define READ_OUTRANGEERRCOUNT_IMPr BCM89500_A0_READ_OUTRANGEERRCOUNT_IMPr
#define WRITE_OUTRANGEERRCOUNT_IMPr BCM89500_A0_WRITE_OUTRANGEERRCOUNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OUTRANGEERRCOUNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  OutRangeErrCount_P7
 * BLOCKS:   GPIC7
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_OUTRANGEERRCOUNT_P7r 0x000027b4

#define BCM89500_A0_OUTRANGEERRCOUNT_P7r_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount_P7.
 *
 */
typedef union BCM89500_A0_OUTRANGEERRCOUNT_P7r_s {
	uint32_t v[1];
	uint32_t outrangeerrcount_p7[1];
	uint32_t _outrangeerrcount_p7;
} BCM89500_A0_OUTRANGEERRCOUNT_P7r_t;

#define BCM89500_A0_OUTRANGEERRCOUNT_P7r_CLR(r) (r).outrangeerrcount_p7[0] = 0
#define BCM89500_A0_OUTRANGEERRCOUNT_P7r_SET(r,d) (r).outrangeerrcount_p7[0] = d
#define BCM89500_A0_OUTRANGEERRCOUNT_P7r_GET(r) (r).outrangeerrcount_p7[0]


/*
 * These macros can be used to access OutRangeErrCount_P7.
 *
 */
#define BCM89500_A0_READ_OUTRANGEERRCOUNT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_OUTRANGEERRCOUNT_P7r,(r._outrangeerrcount_p7),4)
#define BCM89500_A0_WRITE_OUTRANGEERRCOUNT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_OUTRANGEERRCOUNT_P7r,&(r._outrangeerrcount_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNT_P7r BCM89500_A0_OUTRANGEERRCOUNT_P7r
#define OUTRANGEERRCOUNT_P7r_SIZE BCM89500_A0_OUTRANGEERRCOUNT_P7r_SIZE
typedef BCM89500_A0_OUTRANGEERRCOUNT_P7r_t OUTRANGEERRCOUNT_P7r_t;
#define OUTRANGEERRCOUNT_P7r_CLR BCM89500_A0_OUTRANGEERRCOUNT_P7r_CLR
#define OUTRANGEERRCOUNT_P7r_SET BCM89500_A0_OUTRANGEERRCOUNT_P7r_SET
#define OUTRANGEERRCOUNT_P7r_GET BCM89500_A0_OUTRANGEERRCOUNT_P7r_GET
#define READ_OUTRANGEERRCOUNT_P7r BCM89500_A0_READ_OUTRANGEERRCOUNT_P7r
#define WRITE_OUTRANGEERRCOUNT_P7r BCM89500_A0_WRITE_OUTRANGEERRCOUNT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_OUTRANGEERRCOUNT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P1588_CTRL
 * BLOCKS:   SYS
 * DESC:     P1588 Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     SOP_SEL          Select SOP from 1588 or phy.1'b1: Select SOP from 1588.1'b0: Select SOP from phy.bit[8:7]: for port8 - port 7bit[6]: reservedbit[5:0]: for port5 - port0 Default value is 9'h1e0 for BCM89501, 9'h1f0 for BCM89500.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P1588_CTRLr 0x000090c0

#define BCM89500_A0_P1588_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program P1588_CTRL.
 *
 */
typedef union BCM89500_A0_P1588_CTRLr_s {
	uint32_t v[1];
	uint32_t p1588_ctrl[1];
	uint32_t _p1588_ctrl;
} BCM89500_A0_P1588_CTRLr_t;

#define BCM89500_A0_P1588_CTRLr_CLR(r) (r).p1588_ctrl[0] = 0
#define BCM89500_A0_P1588_CTRLr_SET(r,d) (r).p1588_ctrl[0] = d
#define BCM89500_A0_P1588_CTRLr_GET(r) (r).p1588_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P1588_CTRLr_SOP_SELf_GET(r) (((r).p1588_ctrl[0]) & 0x1ff)
#define BCM89500_A0_P1588_CTRLr_SOP_SELf_SET(r,f) (r).p1588_ctrl[0]=(((r).p1588_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_P1588_CTRLr_RESERVEDf_GET(r) ((((r).p1588_ctrl[0]) >> 9) & 0x7f)
#define BCM89500_A0_P1588_CTRLr_RESERVEDf_SET(r,f) (r).p1588_ctrl[0]=(((r).p1588_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access P1588_CTRL.
 *
 */
#define BCM89500_A0_READ_P1588_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P1588_CTRLr,(r._p1588_ctrl),2)
#define BCM89500_A0_WRITE_P1588_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P1588_CTRLr,&(r._p1588_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P1588_CTRLr BCM89500_A0_P1588_CTRLr
#define P1588_CTRLr_SIZE BCM89500_A0_P1588_CTRLr_SIZE
typedef BCM89500_A0_P1588_CTRLr_t P1588_CTRLr_t;
#define P1588_CTRLr_CLR BCM89500_A0_P1588_CTRLr_CLR
#define P1588_CTRLr_SET BCM89500_A0_P1588_CTRLr_SET
#define P1588_CTRLr_GET BCM89500_A0_P1588_CTRLr_GET
#define P1588_CTRLr_SOP_SELf_GET BCM89500_A0_P1588_CTRLr_SOP_SELf_GET
#define P1588_CTRLr_SOP_SELf_SET BCM89500_A0_P1588_CTRLr_SOP_SELf_SET
#define P1588_CTRLr_RESERVEDf_GET BCM89500_A0_P1588_CTRLr_RESERVEDf_GET
#define P1588_CTRLr_RESERVEDf_SET BCM89500_A0_P1588_CTRLr_RESERVEDf_SET
#define READ_P1588_CTRLr BCM89500_A0_READ_P1588_CTRLr
#define WRITE_P1588_CTRLr BCM89500_A0_WRITE_P1588_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P1588_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P4_RGMII_TIME_DLY_GP
 * BLOCKS:   SYS
 * DESC:     Port 4 RGMII TIMING DELAY register(Not2Release)(polar feature)
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr 0x0000006c

#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program P4_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM89500_A0_P4_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t p4_rgmii_time_dly_gp[1];
	uint32_t _p4_rgmii_time_dly_gp;
} BCM89500_A0_P4_RGMII_TIME_DLY_GPr_t;

#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_CLR(r) (r).p4_rgmii_time_dly_gp[0] = 0
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_SET(r,d) (r).p4_rgmii_time_dly_gp[0] = d
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_GET(r) (r).p4_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).p4_rgmii_time_dly_gp[0]) & 0xf)
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).p4_rgmii_time_dly_gp[0]=(((r).p4_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).p4_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).p4_rgmii_time_dly_gp[0]=(((r).p4_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).p4_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).p4_rgmii_time_dly_gp[0]=(((r).p4_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access P4_RGMII_TIME_DLY_GP.
 *
 */
#define BCM89500_A0_READ_P4_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P4_RGMII_TIME_DLY_GPr,(r._p4_rgmii_time_dly_gp),1)
#define BCM89500_A0_WRITE_P4_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P4_RGMII_TIME_DLY_GPr,&(r._p4_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P4_RGMII_TIME_DLY_GPr BCM89500_A0_P4_RGMII_TIME_DLY_GPr
#define P4_RGMII_TIME_DLY_GPr_SIZE BCM89500_A0_P4_RGMII_TIME_DLY_GPr_SIZE
typedef BCM89500_A0_P4_RGMII_TIME_DLY_GPr_t P4_RGMII_TIME_DLY_GPr_t;
#define P4_RGMII_TIME_DLY_GPr_CLR BCM89500_A0_P4_RGMII_TIME_DLY_GPr_CLR
#define P4_RGMII_TIME_DLY_GPr_SET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_SET
#define P4_RGMII_TIME_DLY_GPr_GET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_GET
#define P4_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define P4_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define P4_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define P4_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define P4_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define P4_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM89500_A0_P4_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_P4_RGMII_TIME_DLY_GPr BCM89500_A0_READ_P4_RGMII_TIME_DLY_GPr
#define WRITE_P4_RGMII_TIME_DLY_GPr BCM89500_A0_WRITE_P4_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P4_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P5_RGMII_TIME_DLY_GP
 * BLOCKS:   SYS
 * DESC:     Port 5 RGMII TIMING DELAY register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr 0x0000006d

#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program P5_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM89500_A0_P5_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t p5_rgmii_time_dly_gp[1];
	uint32_t _p5_rgmii_time_dly_gp;
} BCM89500_A0_P5_RGMII_TIME_DLY_GPr_t;

#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_CLR(r) (r).p5_rgmii_time_dly_gp[0] = 0
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_SET(r,d) (r).p5_rgmii_time_dly_gp[0] = d
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_GET(r) (r).p5_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).p5_rgmii_time_dly_gp[0]) & 0xf)
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).p5_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).p5_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access P5_RGMII_TIME_DLY_GP.
 *
 */
#define BCM89500_A0_READ_P5_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P5_RGMII_TIME_DLY_GPr,(r._p5_rgmii_time_dly_gp),1)
#define BCM89500_A0_WRITE_P5_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P5_RGMII_TIME_DLY_GPr,&(r._p5_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P5_RGMII_TIME_DLY_GPr BCM89500_A0_P5_RGMII_TIME_DLY_GPr
#define P5_RGMII_TIME_DLY_GPr_SIZE BCM89500_A0_P5_RGMII_TIME_DLY_GPr_SIZE
typedef BCM89500_A0_P5_RGMII_TIME_DLY_GPr_t P5_RGMII_TIME_DLY_GPr_t;
#define P5_RGMII_TIME_DLY_GPr_CLR BCM89500_A0_P5_RGMII_TIME_DLY_GPr_CLR
#define P5_RGMII_TIME_DLY_GPr_SET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_SET
#define P5_RGMII_TIME_DLY_GPr_GET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM89500_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_P5_RGMII_TIME_DLY_GPr BCM89500_A0_READ_P5_RGMII_TIME_DLY_GPr
#define WRITE_P5_RGMII_TIME_DLY_GPr BCM89500_A0_WRITE_P5_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P5_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_CTL
 * BLOCKS:   SYS
 * DESC:     Port 7 Control Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED         Reserved
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3b'b000: No Spanning Tree(default by HW_FWDG_EN).3b'b001: Disable State(default by ~HW_FWDG_EN).3b'b010: Blocking State.3b'b011: Listening State.3b'b100: Learning State.3b'b101: Forwarding State.3b'b110 - 3b'b111: ReservedProgrammed from the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 *
 ******************************************************************************/
#define BCM89500_A0_P7_CTLr 0x00000007

#define BCM89500_A0_P7_CTLr_SIZE 1

/*
 * This structure should be used to declare and program P7_CTL.
 *
 */
typedef union BCM89500_A0_P7_CTLr_s {
	uint32_t v[1];
	uint32_t p7_ctl[1];
	uint32_t _p7_ctl;
} BCM89500_A0_P7_CTLr_t;

#define BCM89500_A0_P7_CTLr_CLR(r) (r).p7_ctl[0] = 0
#define BCM89500_A0_P7_CTLr_SET(r,d) (r).p7_ctl[0] = d
#define BCM89500_A0_P7_CTLr_GET(r) (r).p7_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_CTLr_RX_DISf_GET(r) (((r).p7_ctl[0]) & 0x1)
#define BCM89500_A0_P7_CTLr_RX_DISf_SET(r,f) (r).p7_ctl[0]=(((r).p7_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_P7_CTLr_TX_DISf_GET(r) ((((r).p7_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_P7_CTLr_TX_DISf_SET(r,f) (r).p7_ctl[0]=(((r).p7_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_P7_CTLr_RESERVEDf_GET(r) ((((r).p7_ctl[0]) >> 2) & 0x7)
#define BCM89500_A0_P7_CTLr_RESERVEDf_SET(r,f) (r).p7_ctl[0]=(((r).p7_ctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM89500_A0_P7_CTLr_G_MISTP_STATEf_GET(r) ((((r).p7_ctl[0]) >> 5) & 0x7)
#define BCM89500_A0_P7_CTLr_G_MISTP_STATEf_SET(r,f) (r).p7_ctl[0]=(((r).p7_ctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access P7_CTL.
 *
 */
#define BCM89500_A0_READ_P7_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_CTLr,(r._p7_ctl),1)
#define BCM89500_A0_WRITE_P7_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_CTLr,&(r._p7_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_CTLr BCM89500_A0_P7_CTLr
#define P7_CTLr_SIZE BCM89500_A0_P7_CTLr_SIZE
typedef BCM89500_A0_P7_CTLr_t P7_CTLr_t;
#define P7_CTLr_CLR BCM89500_A0_P7_CTLr_CLR
#define P7_CTLr_SET BCM89500_A0_P7_CTLr_SET
#define P7_CTLr_GET BCM89500_A0_P7_CTLr_GET
#define P7_CTLr_RX_DISf_GET BCM89500_A0_P7_CTLr_RX_DISf_GET
#define P7_CTLr_RX_DISf_SET BCM89500_A0_P7_CTLr_RX_DISf_SET
#define P7_CTLr_TX_DISf_GET BCM89500_A0_P7_CTLr_TX_DISf_GET
#define P7_CTLr_TX_DISf_SET BCM89500_A0_P7_CTLr_TX_DISf_SET
#define P7_CTLr_RESERVEDf_GET BCM89500_A0_P7_CTLr_RESERVEDf_GET
#define P7_CTLr_RESERVEDf_SET BCM89500_A0_P7_CTLr_RESERVEDf_SET
#define P7_CTLr_G_MISTP_STATEf_GET BCM89500_A0_P7_CTLr_G_MISTP_STATEf_GET
#define P7_CTLr_G_MISTP_STATEf_SET BCM89500_A0_P7_CTLr_G_MISTP_STATEf_SET
#define READ_P7_CTLr BCM89500_A0_READ_P7_CTLr
#define WRITE_P7_CTLr BCM89500_A0_WRITE_P7_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_LEVEL1_QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Port 7, First Level QOS Weight Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     Q0_WEIGHT        Queue 0 Weight.
 *     Q1_WEIGHT        Queue 1 Weight.
 *     Q2_WEIGHT        Queue 2 Weight.
 *     Q3_WEIGHT        Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program higher Queue with higher weight. And this field mustn't be programmed as zero.Queue 3 Weight.
 *
 ******************************************************************************/
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr 0x00003b2c

#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_SIZE 4

/*
 * This structure should be used to declare and program P7_LEVEL1_QOS_WEIGHT.
 *
 */
typedef union BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t p7_level1_qos_weight[1];
	uint32_t _p7_level1_qos_weight;
} BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_t;

#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_CLR(r) (r).p7_level1_qos_weight[0] = 0
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_SET(r,d) (r).p7_level1_qos_weight[0] = d
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_GET(r) (r).p7_level1_qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET(r) (((r).p7_level1_qos_weight[0]) & 0xff)
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET(r,f) (r).p7_level1_qos_weight[0]=(((r).p7_level1_qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET(r) ((((r).p7_level1_qos_weight[0]) >> 8) & 0xff)
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET(r,f) (r).p7_level1_qos_weight[0]=(((r).p7_level1_qos_weight[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET(r) ((((r).p7_level1_qos_weight[0]) >> 16) & 0xff)
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET(r,f) (r).p7_level1_qos_weight[0]=(((r).p7_level1_qos_weight[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET(r) ((((r).p7_level1_qos_weight[0]) >> 24) & 0xff)
#define BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET(r,f) (r).p7_level1_qos_weight[0]=(((r).p7_level1_qos_weight[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access P7_LEVEL1_QOS_WEIGHT.
 *
 */
#define BCM89500_A0_READ_P7_LEVEL1_QOS_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr,(r._p7_level1_qos_weight),4)
#define BCM89500_A0_WRITE_P7_LEVEL1_QOS_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr,&(r._p7_level1_qos_weight),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_LEVEL1_QOS_WEIGHTr BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr
#define P7_LEVEL1_QOS_WEIGHTr_SIZE BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_SIZE
typedef BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_t P7_LEVEL1_QOS_WEIGHTr_t;
#define P7_LEVEL1_QOS_WEIGHTr_CLR BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_CLR
#define P7_LEVEL1_QOS_WEIGHTr_SET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_SET
#define P7_LEVEL1_QOS_WEIGHTr_GET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_GET
#define P7_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET
#define P7_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET
#define P7_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET
#define P7_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET
#define P7_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET
#define P7_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET
#define P7_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET
#define P7_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET
#define READ_P7_LEVEL1_QOS_WEIGHTr BCM89500_A0_READ_P7_LEVEL1_QOS_WEIGHTr
#define WRITE_P7_LEVEL1_QOS_WEIGHTr BCM89500_A0_WRITE_P7_LEVEL1_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_LEVEL1_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_LEVEL2_QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Port 7, Second Level QOS Weight Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     LEVEL1_OUTPUT_WEIGHT Ouput of First Level QOS Weight.
 *     Q4_WEIGHT        Queue 4 Weight.
 *     Q5_WEIGHT        Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program higher Queue with higher weight. And this field mustn't be programmed as zero.Queue 5 Weight.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr 0x00003b5c

#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_SIZE 4

/*
 * This structure should be used to declare and program P7_LEVEL2_QOS_WEIGHT.
 *
 */
typedef union BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t p7_level2_qos_weight[1];
	uint32_t _p7_level2_qos_weight;
} BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_t;

#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_CLR(r) (r).p7_level2_qos_weight[0] = 0
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_SET(r,d) (r).p7_level2_qos_weight[0] = d
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_GET(r) (r).p7_level2_qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET(r) (((r).p7_level2_qos_weight[0]) & 0xff)
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET(r,f) (r).p7_level2_qos_weight[0]=(((r).p7_level2_qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET(r) ((((r).p7_level2_qos_weight[0]) >> 8) & 0xff)
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET(r,f) (r).p7_level2_qos_weight[0]=(((r).p7_level2_qos_weight[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET(r) ((((r).p7_level2_qos_weight[0]) >> 16) & 0xff)
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET(r,f) (r).p7_level2_qos_weight[0]=(((r).p7_level2_qos_weight[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET(r) ((((r).p7_level2_qos_weight[0]) >> 24) & 0xff)
#define BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET(r,f) (r).p7_level2_qos_weight[0]=(((r).p7_level2_qos_weight[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access P7_LEVEL2_QOS_WEIGHT.
 *
 */
#define BCM89500_A0_READ_P7_LEVEL2_QOS_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr,(r._p7_level2_qos_weight),4)
#define BCM89500_A0_WRITE_P7_LEVEL2_QOS_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr,&(r._p7_level2_qos_weight),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_LEVEL2_QOS_WEIGHTr BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr
#define P7_LEVEL2_QOS_WEIGHTr_SIZE BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_SIZE
typedef BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_t P7_LEVEL2_QOS_WEIGHTr_t;
#define P7_LEVEL2_QOS_WEIGHTr_CLR BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_CLR
#define P7_LEVEL2_QOS_WEIGHTr_SET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_SET
#define P7_LEVEL2_QOS_WEIGHTr_GET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_GET
#define P7_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET
#define P7_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET
#define P7_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET
#define P7_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET
#define P7_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET
#define P7_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET
#define P7_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET
#define P7_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET
#define READ_P7_LEVEL2_QOS_WEIGHTr BCM89500_A0_READ_P7_LEVEL2_QOS_WEIGHTr
#define WRITE_P7_LEVEL2_QOS_WEIGHTr BCM89500_A0_WRITE_P7_LEVEL2_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_LEVEL2_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_LOW_QUEUE_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port 7, Low Queue (Q0-Q3) Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr 0x0000381c

#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program P7_LOW_QUEUE_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t p7_low_queue_max_refresh[1];
	uint32_t _p7_low_queue_max_refresh;
} BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_t;

#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_CLR(r) (r).p7_low_queue_max_refresh[0] = 0
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_SET(r,d) (r).p7_low_queue_max_refresh[0] = d
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_GET(r) (r).p7_low_queue_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).p7_low_queue_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).p7_low_queue_max_refresh[0]=(((r).p7_low_queue_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).p7_low_queue_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).p7_low_queue_max_refresh[0]=(((r).p7_low_queue_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access P7_LOW_QUEUE_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_P7_LOW_QUEUE_MAX_REFRESHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr,(r._p7_low_queue_max_refresh),4)
#define BCM89500_A0_WRITE_P7_LOW_QUEUE_MAX_REFRESHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr,&(r._p7_low_queue_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr
#define P7_LOW_QUEUE_MAX_REFRESHr_SIZE BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_SIZE
typedef BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_t P7_LOW_QUEUE_MAX_REFRESHr_t;
#define P7_LOW_QUEUE_MAX_REFRESHr_CLR BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_CLR
#define P7_LOW_QUEUE_MAX_REFRESHr_SET BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_SET
#define P7_LOW_QUEUE_MAX_REFRESHr_GET BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_GET
#define P7_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET
#define P7_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET
#define P7_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET
#define P7_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET
#define READ_P7_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_READ_P7_LOW_QUEUE_MAX_REFRESHr
#define WRITE_P7_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_WRITE_P7_LOW_QUEUE_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_LOW_QUEUE_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_LOW_QUEUE_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port 7, Low Queue (Q0-Q3) Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr 0x0000384c

#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program P7_LOW_QUEUE_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t p7_low_queue_max_thd_sel[1];
	uint32_t _p7_low_queue_max_thd_sel;
} BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_t;

#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_CLR(r) (r).p7_low_queue_max_thd_sel[0] = 0
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_SET(r,d) (r).p7_low_queue_max_thd_sel[0] = d
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_GET(r) (r).p7_low_queue_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).p7_low_queue_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).p7_low_queue_max_thd_sel[0]=(((r).p7_low_queue_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).p7_low_queue_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).p7_low_queue_max_thd_sel[0]=(((r).p7_low_queue_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access P7_LOW_QUEUE_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_P7_LOW_QUEUE_MAX_THD_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr,(r._p7_low_queue_max_thd_sel),4)
#define BCM89500_A0_WRITE_P7_LOW_QUEUE_MAX_THD_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr,&(r._p7_low_queue_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr
#define P7_LOW_QUEUE_MAX_THD_SELr_SIZE BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_SIZE
typedef BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_t P7_LOW_QUEUE_MAX_THD_SELr_t;
#define P7_LOW_QUEUE_MAX_THD_SELr_CLR BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_CLR
#define P7_LOW_QUEUE_MAX_THD_SELr_SET BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_SET
#define P7_LOW_QUEUE_MAX_THD_SELr_GET BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_GET
#define P7_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET
#define P7_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET
#define P7_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET
#define P7_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET
#define READ_P7_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_READ_P7_LOW_QUEUE_MAX_THD_SELr
#define WRITE_P7_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_WRITE_P7_LOW_QUEUE_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_LOW_QUEUE_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_LOW_QUEUE_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port 7, Low Queue (Q0-Q3) Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr 0x0000387c

#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program P7_LOW_QUEUE_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t p7_low_queue_shaper_sts[1];
	uint32_t _p7_low_queue_shaper_sts;
} BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_t;

#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_CLR(r) (r).p7_low_queue_shaper_sts[0] = 0
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_SET(r,d) (r).p7_low_queue_shaper_sts[0] = d
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_GET(r) (r).p7_low_queue_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).p7_low_queue_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).p7_low_queue_shaper_sts[0]=(((r).p7_low_queue_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET(r) ((((r).p7_low_queue_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET(r,f) (r).p7_low_queue_shaper_sts[0]=(((r).p7_low_queue_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).p7_low_queue_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).p7_low_queue_shaper_sts[0]=(((r).p7_low_queue_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access P7_LOW_QUEUE_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_P7_LOW_QUEUE_SHAPER_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr,(r._p7_low_queue_shaper_sts),4)
#define BCM89500_A0_WRITE_P7_LOW_QUEUE_SHAPER_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr,&(r._p7_low_queue_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_LOW_QUEUE_SHAPER_STSr BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr
#define P7_LOW_QUEUE_SHAPER_STSr_SIZE BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_SIZE
typedef BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_t P7_LOW_QUEUE_SHAPER_STSr_t;
#define P7_LOW_QUEUE_SHAPER_STSr_CLR BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_CLR
#define P7_LOW_QUEUE_SHAPER_STSr_SET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_SET
#define P7_LOW_QUEUE_SHAPER_STSr_GET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_GET
#define P7_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET
#define P7_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET
#define P7_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET
#define P7_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET
#define P7_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define P7_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_P7_LOW_QUEUE_SHAPER_STSr BCM89500_A0_READ_P7_LOW_QUEUE_SHAPER_STSr
#define WRITE_P7_LOW_QUEUE_SHAPER_STSr BCM89500_A0_WRITE_P7_LOW_QUEUE_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_LOW_QUEUE_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_PCP2TC
 * BLOCKS:   GPIC7
 * DESC:     Port 7 PCP to TC Map Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_PCP2TCr 0x00003028

#define BCM89500_A0_P7_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program P7_PCP2TC.
 *
 */
typedef union BCM89500_A0_P7_PCP2TCr_s {
	uint32_t v[1];
	uint32_t p7_pcp2tc[1];
	uint32_t _p7_pcp2tc;
} BCM89500_A0_P7_PCP2TCr_t;

#define BCM89500_A0_P7_PCP2TCr_CLR(r) (r).p7_pcp2tc[0] = 0
#define BCM89500_A0_P7_PCP2TCr_SET(r,d) (r).p7_pcp2tc[0] = d
#define BCM89500_A0_P7_PCP2TCr_GET(r) (r).p7_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).p7_pcp2tc[0]) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_P7_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 3) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_P7_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 6) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_P7_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 9) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_P7_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 12) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_P7_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 15) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_P7_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 18) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_P7_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).p7_pcp2tc[0]) >> 21) & 0x7)
#define BCM89500_A0_P7_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_P7_PCP2TCr_RESERVEDf_GET(r) ((((r).p7_pcp2tc[0]) >> 24) & 0xff)
#define BCM89500_A0_P7_PCP2TCr_RESERVEDf_SET(r,f) (r).p7_pcp2tc[0]=(((r).p7_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access P7_PCP2TC.
 *
 */
#define BCM89500_A0_READ_P7_PCP2TCr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_PCP2TCr,(r._p7_pcp2tc),4)
#define BCM89500_A0_WRITE_P7_PCP2TCr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_PCP2TCr,&(r._p7_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_PCP2TCr BCM89500_A0_P7_PCP2TCr
#define P7_PCP2TCr_SIZE BCM89500_A0_P7_PCP2TCr_SIZE
typedef BCM89500_A0_P7_PCP2TCr_t P7_PCP2TCr_t;
#define P7_PCP2TCr_CLR BCM89500_A0_P7_PCP2TCr_CLR
#define P7_PCP2TCr_SET BCM89500_A0_P7_PCP2TCr_SET
#define P7_PCP2TCr_GET BCM89500_A0_P7_PCP2TCr_GET
#define P7_PCP2TCr_TAG000_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG000_PRI_MAPf_GET
#define P7_PCP2TCr_TAG000_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG000_PRI_MAPf_SET
#define P7_PCP2TCr_TAG001_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG001_PRI_MAPf_GET
#define P7_PCP2TCr_TAG001_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG001_PRI_MAPf_SET
#define P7_PCP2TCr_TAG010_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG010_PRI_MAPf_GET
#define P7_PCP2TCr_TAG010_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG010_PRI_MAPf_SET
#define P7_PCP2TCr_TAG011_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG011_PRI_MAPf_GET
#define P7_PCP2TCr_TAG011_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG011_PRI_MAPf_SET
#define P7_PCP2TCr_TAG100_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG100_PRI_MAPf_GET
#define P7_PCP2TCr_TAG100_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG100_PRI_MAPf_SET
#define P7_PCP2TCr_TAG101_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG101_PRI_MAPf_GET
#define P7_PCP2TCr_TAG101_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG101_PRI_MAPf_SET
#define P7_PCP2TCr_TAG110_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG110_PRI_MAPf_GET
#define P7_PCP2TCr_TAG110_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG110_PRI_MAPf_SET
#define P7_PCP2TCr_TAG111_PRI_MAPf_GET BCM89500_A0_P7_PCP2TCr_TAG111_PRI_MAPf_GET
#define P7_PCP2TCr_TAG111_PRI_MAPf_SET BCM89500_A0_P7_PCP2TCr_TAG111_PRI_MAPf_SET
#define P7_PCP2TCr_RESERVEDf_GET BCM89500_A0_P7_PCP2TCr_RESERVEDf_GET
#define P7_PCP2TCr_RESERVEDf_SET BCM89500_A0_P7_PCP2TCr_RESERVEDf_SET
#define READ_P7_PCP2TCr BCM89500_A0_READ_P7_PCP2TCr
#define WRITE_P7_PCP2TCr BCM89500_A0_WRITE_P7_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QOS_PRI_CTL
 * BLOCKS:   SYS
 * DESC:     Port 7, QOS Priority Control Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     LEVEL1_QOS_PRI_CTL First level QoS priority for Q0 to Q32'b00: for Q0 - 3 are WRR2'b01: for COS3 (SP) and COS2-COS0 (WRR)2'b10: for COS3 (SP), COS2 (SP) and COS1-COS0 (WRR)2'b11: for COS3-COS0 (SP)
 *     LEVEL2_QOS_PRI_CTL Second level QoS priority for Queue 4, Queue 5, and the output of LEVEL1_QOS_PRI2'b00: for COS5, COS4 and the output of LEVEL1_QOS_PRI are WRR2'b01: for COS5 (SP), COS4 and the output of LEVEL1_QOS_PRI (WRR)2'b10: for COS5 (SP), COS4 (SP) and the output of LEVEL1_QOS_PRI (SP)2'b11: for Reserve
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QOS_PRI_CTLr 0x00003b07

#define BCM89500_A0_P7_QOS_PRI_CTLr_SIZE 1

/*
 * This structure should be used to declare and program P7_QOS_PRI_CTL.
 *
 */
typedef union BCM89500_A0_P7_QOS_PRI_CTLr_s {
	uint32_t v[1];
	uint32_t p7_qos_pri_ctl[1];
	uint32_t _p7_qos_pri_ctl;
} BCM89500_A0_P7_QOS_PRI_CTLr_t;

#define BCM89500_A0_P7_QOS_PRI_CTLr_CLR(r) (r).p7_qos_pri_ctl[0] = 0
#define BCM89500_A0_P7_QOS_PRI_CTLr_SET(r,d) (r).p7_qos_pri_ctl[0] = d
#define BCM89500_A0_P7_QOS_PRI_CTLr_GET(r) (r).p7_qos_pri_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET(r) (((r).p7_qos_pri_ctl[0]) & 0x3)
#define BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET(r,f) (r).p7_qos_pri_ctl[0]=(((r).p7_qos_pri_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET(r) ((((r).p7_qos_pri_ctl[0]) >> 2) & 0x3)
#define BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET(r,f) (r).p7_qos_pri_ctl[0]=(((r).p7_qos_pri_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_P7_QOS_PRI_CTLr_RESERVEDf_GET(r) ((((r).p7_qos_pri_ctl[0]) >> 4) & 0xf)
#define BCM89500_A0_P7_QOS_PRI_CTLr_RESERVEDf_SET(r,f) (r).p7_qos_pri_ctl[0]=(((r).p7_qos_pri_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access P7_QOS_PRI_CTL.
 *
 */
#define BCM89500_A0_READ_P7_QOS_PRI_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QOS_PRI_CTLr,(r._p7_qos_pri_ctl),1)
#define BCM89500_A0_WRITE_P7_QOS_PRI_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QOS_PRI_CTLr,&(r._p7_qos_pri_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QOS_PRI_CTLr BCM89500_A0_P7_QOS_PRI_CTLr
#define P7_QOS_PRI_CTLr_SIZE BCM89500_A0_P7_QOS_PRI_CTLr_SIZE
typedef BCM89500_A0_P7_QOS_PRI_CTLr_t P7_QOS_PRI_CTLr_t;
#define P7_QOS_PRI_CTLr_CLR BCM89500_A0_P7_QOS_PRI_CTLr_CLR
#define P7_QOS_PRI_CTLr_SET BCM89500_A0_P7_QOS_PRI_CTLr_SET
#define P7_QOS_PRI_CTLr_GET BCM89500_A0_P7_QOS_PRI_CTLr_GET
#define P7_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET
#define P7_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET
#define P7_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET
#define P7_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET BCM89500_A0_P7_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET
#define P7_QOS_PRI_CTLr_RESERVEDf_GET BCM89500_A0_P7_QOS_PRI_CTLr_RESERVEDf_GET
#define P7_QOS_PRI_CTLr_RESERVEDf_SET BCM89500_A0_P7_QOS_PRI_CTLr_RESERVEDf_SET
#define READ_P7_QOS_PRI_CTLr BCM89500_A0_READ_P7_QOS_PRI_CTLr
#define WRITE_P7_QOS_PRI_CTLr BCM89500_A0_WRITE_P7_QOS_PRI_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QOS_PRI_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QUEUE4_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port 7, Queue 4 Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr 0x0000391c

#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program P7_QUEUE4_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t p7_queue4_max_refresh[1];
	uint32_t _p7_queue4_max_refresh;
} BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_t;

#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_CLR(r) (r).p7_queue4_max_refresh[0] = 0
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_SET(r,d) (r).p7_queue4_max_refresh[0] = d
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_GET(r) (r).p7_queue4_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).p7_queue4_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).p7_queue4_max_refresh[0]=(((r).p7_queue4_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).p7_queue4_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).p7_queue4_max_refresh[0]=(((r).p7_queue4_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access P7_QUEUE4_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_P7_QUEUE4_MAX_REFRESHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QUEUE4_MAX_REFRESHr,(r._p7_queue4_max_refresh),4)
#define BCM89500_A0_WRITE_P7_QUEUE4_MAX_REFRESHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QUEUE4_MAX_REFRESHr,&(r._p7_queue4_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QUEUE4_MAX_REFRESHr BCM89500_A0_P7_QUEUE4_MAX_REFRESHr
#define P7_QUEUE4_MAX_REFRESHr_SIZE BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_SIZE
typedef BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_t P7_QUEUE4_MAX_REFRESHr_t;
#define P7_QUEUE4_MAX_REFRESHr_CLR BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_CLR
#define P7_QUEUE4_MAX_REFRESHr_SET BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_SET
#define P7_QUEUE4_MAX_REFRESHr_GET BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_GET
#define P7_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET
#define P7_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET
#define P7_QUEUE4_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_RESERVEDf_GET
#define P7_QUEUE4_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_P7_QUEUE4_MAX_REFRESHr_RESERVEDf_SET
#define READ_P7_QUEUE4_MAX_REFRESHr BCM89500_A0_READ_P7_QUEUE4_MAX_REFRESHr
#define WRITE_P7_QUEUE4_MAX_REFRESHr BCM89500_A0_WRITE_P7_QUEUE4_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QUEUE4_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QUEUE4_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port 7, Queue 4 Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr 0x0000394c

#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program P7_QUEUE4_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t p7_queue4_max_thd_sel[1];
	uint32_t _p7_queue4_max_thd_sel;
} BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_t;

#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_CLR(r) (r).p7_queue4_max_thd_sel[0] = 0
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_SET(r,d) (r).p7_queue4_max_thd_sel[0] = d
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_GET(r) (r).p7_queue4_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).p7_queue4_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).p7_queue4_max_thd_sel[0]=(((r).p7_queue4_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).p7_queue4_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).p7_queue4_max_thd_sel[0]=(((r).p7_queue4_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access P7_QUEUE4_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_P7_QUEUE4_MAX_THD_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QUEUE4_MAX_THD_SELr,(r._p7_queue4_max_thd_sel),4)
#define BCM89500_A0_WRITE_P7_QUEUE4_MAX_THD_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QUEUE4_MAX_THD_SELr,&(r._p7_queue4_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QUEUE4_MAX_THD_SELr BCM89500_A0_P7_QUEUE4_MAX_THD_SELr
#define P7_QUEUE4_MAX_THD_SELr_SIZE BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_SIZE
typedef BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_t P7_QUEUE4_MAX_THD_SELr_t;
#define P7_QUEUE4_MAX_THD_SELr_CLR BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_CLR
#define P7_QUEUE4_MAX_THD_SELr_SET BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_SET
#define P7_QUEUE4_MAX_THD_SELr_GET BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_GET
#define P7_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET
#define P7_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET
#define P7_QUEUE4_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_RESERVEDf_GET
#define P7_QUEUE4_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_P7_QUEUE4_MAX_THD_SELr_RESERVEDf_SET
#define READ_P7_QUEUE4_MAX_THD_SELr BCM89500_A0_READ_P7_QUEUE4_MAX_THD_SELr
#define WRITE_P7_QUEUE4_MAX_THD_SELr BCM89500_A0_WRITE_P7_QUEUE4_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QUEUE4_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QUEUE4_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port 7, Queue 4 Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr 0x0000397c

#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program P7_QUEUE4_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_P7_QUEUE4_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t p7_queue4_shaper_sts[1];
	uint32_t _p7_queue4_shaper_sts;
} BCM89500_A0_P7_QUEUE4_SHAPER_STSr_t;

#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_CLR(r) (r).p7_queue4_shaper_sts[0] = 0
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_SET(r,d) (r).p7_queue4_shaper_sts[0] = d
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_GET(r) (r).p7_queue4_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).p7_queue4_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).p7_queue4_shaper_sts[0]=(((r).p7_queue4_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_RESERVEDf_GET(r) ((((r).p7_queue4_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_RESERVEDf_SET(r,f) (r).p7_queue4_shaper_sts[0]=(((r).p7_queue4_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).p7_queue4_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_P7_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).p7_queue4_shaper_sts[0]=(((r).p7_queue4_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access P7_QUEUE4_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_P7_QUEUE4_SHAPER_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QUEUE4_SHAPER_STSr,(r._p7_queue4_shaper_sts),4)
#define BCM89500_A0_WRITE_P7_QUEUE4_SHAPER_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QUEUE4_SHAPER_STSr,&(r._p7_queue4_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QUEUE4_SHAPER_STSr BCM89500_A0_P7_QUEUE4_SHAPER_STSr
#define P7_QUEUE4_SHAPER_STSr_SIZE BCM89500_A0_P7_QUEUE4_SHAPER_STSr_SIZE
typedef BCM89500_A0_P7_QUEUE4_SHAPER_STSr_t P7_QUEUE4_SHAPER_STSr_t;
#define P7_QUEUE4_SHAPER_STSr_CLR BCM89500_A0_P7_QUEUE4_SHAPER_STSr_CLR
#define P7_QUEUE4_SHAPER_STSr_SET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_SET
#define P7_QUEUE4_SHAPER_STSr_GET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_GET
#define P7_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET
#define P7_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET
#define P7_QUEUE4_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_RESERVEDf_GET
#define P7_QUEUE4_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_RESERVEDf_SET
#define P7_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define P7_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_P7_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_P7_QUEUE4_SHAPER_STSr BCM89500_A0_READ_P7_QUEUE4_SHAPER_STSr
#define WRITE_P7_QUEUE4_SHAPER_STSr BCM89500_A0_WRITE_P7_QUEUE4_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QUEUE4_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QUEUE5_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port 7, Queue 5 Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr 0x00003a1c

#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program P7_QUEUE5_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t p7_queue5_max_refresh[1];
	uint32_t _p7_queue5_max_refresh;
} BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_t;

#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_CLR(r) (r).p7_queue5_max_refresh[0] = 0
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_SET(r,d) (r).p7_queue5_max_refresh[0] = d
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_GET(r) (r).p7_queue5_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).p7_queue5_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).p7_queue5_max_refresh[0]=(((r).p7_queue5_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).p7_queue5_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).p7_queue5_max_refresh[0]=(((r).p7_queue5_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access P7_QUEUE5_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_P7_QUEUE5_MAX_REFRESHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QUEUE5_MAX_REFRESHr,(r._p7_queue5_max_refresh),4)
#define BCM89500_A0_WRITE_P7_QUEUE5_MAX_REFRESHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QUEUE5_MAX_REFRESHr,&(r._p7_queue5_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QUEUE5_MAX_REFRESHr BCM89500_A0_P7_QUEUE5_MAX_REFRESHr
#define P7_QUEUE5_MAX_REFRESHr_SIZE BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_SIZE
typedef BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_t P7_QUEUE5_MAX_REFRESHr_t;
#define P7_QUEUE5_MAX_REFRESHr_CLR BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_CLR
#define P7_QUEUE5_MAX_REFRESHr_SET BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_SET
#define P7_QUEUE5_MAX_REFRESHr_GET BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_GET
#define P7_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET
#define P7_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET
#define P7_QUEUE5_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_RESERVEDf_GET
#define P7_QUEUE5_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_P7_QUEUE5_MAX_REFRESHr_RESERVEDf_SET
#define READ_P7_QUEUE5_MAX_REFRESHr BCM89500_A0_READ_P7_QUEUE5_MAX_REFRESHr
#define WRITE_P7_QUEUE5_MAX_REFRESHr BCM89500_A0_WRITE_P7_QUEUE5_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QUEUE5_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QUEUE5_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port 7, Queue 5 Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr 0x00003a4c

#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program P7_QUEUE5_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t p7_queue5_max_thd_sel[1];
	uint32_t _p7_queue5_max_thd_sel;
} BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_t;

#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_CLR(r) (r).p7_queue5_max_thd_sel[0] = 0
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_SET(r,d) (r).p7_queue5_max_thd_sel[0] = d
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_GET(r) (r).p7_queue5_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).p7_queue5_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).p7_queue5_max_thd_sel[0]=(((r).p7_queue5_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).p7_queue5_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).p7_queue5_max_thd_sel[0]=(((r).p7_queue5_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access P7_QUEUE5_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_P7_QUEUE5_MAX_THD_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QUEUE5_MAX_THD_SELr,(r._p7_queue5_max_thd_sel),4)
#define BCM89500_A0_WRITE_P7_QUEUE5_MAX_THD_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QUEUE5_MAX_THD_SELr,&(r._p7_queue5_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QUEUE5_MAX_THD_SELr BCM89500_A0_P7_QUEUE5_MAX_THD_SELr
#define P7_QUEUE5_MAX_THD_SELr_SIZE BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_SIZE
typedef BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_t P7_QUEUE5_MAX_THD_SELr_t;
#define P7_QUEUE5_MAX_THD_SELr_CLR BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_CLR
#define P7_QUEUE5_MAX_THD_SELr_SET BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_SET
#define P7_QUEUE5_MAX_THD_SELr_GET BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_GET
#define P7_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET
#define P7_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET
#define P7_QUEUE5_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_RESERVEDf_GET
#define P7_QUEUE5_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_P7_QUEUE5_MAX_THD_SELr_RESERVEDf_SET
#define READ_P7_QUEUE5_MAX_THD_SELr BCM89500_A0_READ_P7_QUEUE5_MAX_THD_SELr
#define WRITE_P7_QUEUE5_MAX_THD_SELr BCM89500_A0_WRITE_P7_QUEUE5_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QUEUE5_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_QUEUE5_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port 7, Queue 5 Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr 0x00003a7c

#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program P7_QUEUE5_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_P7_QUEUE5_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t p7_queue5_shaper_sts[1];
	uint32_t _p7_queue5_shaper_sts;
} BCM89500_A0_P7_QUEUE5_SHAPER_STSr_t;

#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_CLR(r) (r).p7_queue5_shaper_sts[0] = 0
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_SET(r,d) (r).p7_queue5_shaper_sts[0] = d
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_GET(r) (r).p7_queue5_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).p7_queue5_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).p7_queue5_shaper_sts[0]=(((r).p7_queue5_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_RESERVEDf_GET(r) ((((r).p7_queue5_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_RESERVEDf_SET(r,f) (r).p7_queue5_shaper_sts[0]=(((r).p7_queue5_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).p7_queue5_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_P7_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).p7_queue5_shaper_sts[0]=(((r).p7_queue5_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access P7_QUEUE5_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_P7_QUEUE5_SHAPER_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_QUEUE5_SHAPER_STSr,(r._p7_queue5_shaper_sts),4)
#define BCM89500_A0_WRITE_P7_QUEUE5_SHAPER_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_QUEUE5_SHAPER_STSr,&(r._p7_queue5_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_QUEUE5_SHAPER_STSr BCM89500_A0_P7_QUEUE5_SHAPER_STSr
#define P7_QUEUE5_SHAPER_STSr_SIZE BCM89500_A0_P7_QUEUE5_SHAPER_STSr_SIZE
typedef BCM89500_A0_P7_QUEUE5_SHAPER_STSr_t P7_QUEUE5_SHAPER_STSr_t;
#define P7_QUEUE5_SHAPER_STSr_CLR BCM89500_A0_P7_QUEUE5_SHAPER_STSr_CLR
#define P7_QUEUE5_SHAPER_STSr_SET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_SET
#define P7_QUEUE5_SHAPER_STSr_GET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_GET
#define P7_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET
#define P7_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET
#define P7_QUEUE5_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_RESERVEDf_GET
#define P7_QUEUE5_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_RESERVEDf_SET
#define P7_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define P7_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_P7_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_P7_QUEUE5_SHAPER_STSr BCM89500_A0_READ_P7_QUEUE5_SHAPER_STSr
#define WRITE_P7_QUEUE5_SHAPER_STSr BCM89500_A0_WRITE_P7_QUEUE5_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_QUEUE5_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     Port 7 TC to COS Mapping Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.
 *     PRT111_TO_QID    *** Note that ***Queue ID 0: 000Queue ID 1: 001Queue ID 2: 010Queue ID 3: 011Queue ID 4: 100Queue ID 5: 101Priority ID 111 mapped to TX Queue ID.
 *
 ******************************************************************************/
#define BCM89500_A0_P7_TC2COS_MAPr 0x0000308c

#define BCM89500_A0_P7_TC2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program P7_TC2COS_MAP.
 *
 */
typedef union BCM89500_A0_P7_TC2COS_MAPr_s {
	uint32_t v[1];
	uint32_t p7_tc2cos_map[1];
	uint32_t _p7_tc2cos_map;
} BCM89500_A0_P7_TC2COS_MAPr_t;

#define BCM89500_A0_P7_TC2COS_MAPr_CLR(r) (r).p7_tc2cos_map[0] = 0
#define BCM89500_A0_P7_TC2COS_MAPr_SET(r,d) (r).p7_tc2cos_map[0] = d
#define BCM89500_A0_P7_TC2COS_MAPr_GET(r) (r).p7_tc2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_TC2COS_MAPr_PRT000_TO_QIDf_GET(r) (((r).p7_tc2cos_map[0]) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT000_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT001_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 3) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT001_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT010_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 6) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT010_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT011_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 9) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT011_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT100_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 12) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT100_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT101_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 15) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT101_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT110_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 18) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT110_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_P7_TC2COS_MAPr_PRT111_TO_QIDf_GET(r) ((((r).p7_tc2cos_map[0]) >> 21) & 0x7)
#define BCM89500_A0_P7_TC2COS_MAPr_PRT111_TO_QIDf_SET(r,f) (r).p7_tc2cos_map[0]=(((r).p7_tc2cos_map[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access P7_TC2COS_MAP.
 *
 */
#define BCM89500_A0_READ_P7_TC2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_TC2COS_MAPr,(r._p7_tc2cos_map),4)
#define BCM89500_A0_WRITE_P7_TC2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_TC2COS_MAPr,&(r._p7_tc2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_TC2COS_MAPr BCM89500_A0_P7_TC2COS_MAPr
#define P7_TC2COS_MAPr_SIZE BCM89500_A0_P7_TC2COS_MAPr_SIZE
typedef BCM89500_A0_P7_TC2COS_MAPr_t P7_TC2COS_MAPr_t;
#define P7_TC2COS_MAPr_CLR BCM89500_A0_P7_TC2COS_MAPr_CLR
#define P7_TC2COS_MAPr_SET BCM89500_A0_P7_TC2COS_MAPr_SET
#define P7_TC2COS_MAPr_GET BCM89500_A0_P7_TC2COS_MAPr_GET
#define P7_TC2COS_MAPr_PRT000_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT000_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT000_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT000_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT001_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT001_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT001_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT001_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT010_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT010_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT010_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT010_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT011_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT011_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT011_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT011_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT100_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT100_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT100_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT100_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT101_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT101_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT101_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT101_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT110_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT110_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT110_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT110_TO_QIDf_SET
#define P7_TC2COS_MAPr_PRT111_TO_QIDf_GET BCM89500_A0_P7_TC2COS_MAPr_PRT111_TO_QIDf_GET
#define P7_TC2COS_MAPr_PRT111_TO_QIDf_SET BCM89500_A0_P7_TC2COS_MAPr_PRT111_TO_QIDf_SET
#define READ_P7_TC2COS_MAPr BCM89500_A0_READ_P7_TC2COS_MAPr
#define WRITE_P7_TC2COS_MAPr BCM89500_A0_WRITE_P7_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  P7_TC_SEL_TABLE
 * BLOCKS:   SYS
 * DESC:     Port 7 TC Select Table Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     TC_SEL_0         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_1         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_2         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_3         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_4         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_5         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_6         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_7         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *
 ******************************************************************************/
#define BCM89500_A0_P7_TC_SEL_TABLEr 0x0000305e

#define BCM89500_A0_P7_TC_SEL_TABLEr_SIZE 2

/*
 * This structure should be used to declare and program P7_TC_SEL_TABLE.
 *
 */
typedef union BCM89500_A0_P7_TC_SEL_TABLEr_s {
	uint32_t v[1];
	uint32_t p7_tc_sel_table[1];
	uint32_t _p7_tc_sel_table;
} BCM89500_A0_P7_TC_SEL_TABLEr_t;

#define BCM89500_A0_P7_TC_SEL_TABLEr_CLR(r) (r).p7_tc_sel_table[0] = 0
#define BCM89500_A0_P7_TC_SEL_TABLEr_SET(r,d) (r).p7_tc_sel_table[0] = d
#define BCM89500_A0_P7_TC_SEL_TABLEr_GET(r) (r).p7_tc_sel_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_0f_GET(r) (((r).p7_tc_sel_table[0]) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_0f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_1f_GET(r) ((((r).p7_tc_sel_table[0]) >> 2) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_1f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_2f_GET(r) ((((r).p7_tc_sel_table[0]) >> 4) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_2f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_3f_GET(r) ((((r).p7_tc_sel_table[0]) >> 6) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_3f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_4f_GET(r) ((((r).p7_tc_sel_table[0]) >> 8) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_4f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_5f_GET(r) ((((r).p7_tc_sel_table[0]) >> 10) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_5f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_6f_GET(r) ((((r).p7_tc_sel_table[0]) >> 12) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_6f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_7f_GET(r) ((((r).p7_tc_sel_table[0]) >> 14) & 0x3)
#define BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_7f_SET(r,f) (r).p7_tc_sel_table[0]=(((r).p7_tc_sel_table[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access P7_TC_SEL_TABLE.
 *
 */
#define BCM89500_A0_READ_P7_TC_SEL_TABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_P7_TC_SEL_TABLEr,(r._p7_tc_sel_table),2)
#define BCM89500_A0_WRITE_P7_TC_SEL_TABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_P7_TC_SEL_TABLEr,&(r._p7_tc_sel_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P7_TC_SEL_TABLEr BCM89500_A0_P7_TC_SEL_TABLEr
#define P7_TC_SEL_TABLEr_SIZE BCM89500_A0_P7_TC_SEL_TABLEr_SIZE
typedef BCM89500_A0_P7_TC_SEL_TABLEr_t P7_TC_SEL_TABLEr_t;
#define P7_TC_SEL_TABLEr_CLR BCM89500_A0_P7_TC_SEL_TABLEr_CLR
#define P7_TC_SEL_TABLEr_SET BCM89500_A0_P7_TC_SEL_TABLEr_SET
#define P7_TC_SEL_TABLEr_GET BCM89500_A0_P7_TC_SEL_TABLEr_GET
#define P7_TC_SEL_TABLEr_TC_SEL_0f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_0f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_0f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_0f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_1f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_1f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_1f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_1f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_2f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_2f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_2f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_2f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_3f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_3f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_3f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_3f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_4f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_4f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_4f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_4f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_5f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_5f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_5f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_5f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_6f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_6f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_6f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_6f_SET
#define P7_TC_SEL_TABLEr_TC_SEL_7f_GET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_7f_GET
#define P7_TC_SEL_TABLEr_TC_SEL_7f_SET BCM89500_A0_P7_TC_SEL_TABLEr_TC_SEL_7f_SET
#define READ_P7_TC_SEL_TABLEr BCM89500_A0_READ_P7_TC_SEL_TABLEr
#define WRITE_P7_TC_SEL_TABLEr BCM89500_A0_WRITE_P7_TC_SEL_TABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_P7_TC_SEL_TABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PAGEREG
 * BLOCKS:   SPI
 * DESC:     PAGE Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Next Page
 *
 ******************************************************************************/
#define BCM89500_A0_PAGEREGr 0x0000ffff

#define BCM89500_A0_PAGEREGr_SIZE 1

/*
 * This structure should be used to declare and program PAGEREG.
 *
 */
typedef union BCM89500_A0_PAGEREGr_s {
	uint32_t v[1];
	uint32_t pagereg[1];
	uint32_t _pagereg;
} BCM89500_A0_PAGEREGr_t;

#define BCM89500_A0_PAGEREGr_CLR(r) (r).pagereg[0] = 0
#define BCM89500_A0_PAGEREGr_SET(r,d) (r).pagereg[0] = d
#define BCM89500_A0_PAGEREGr_GET(r) (r).pagereg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PAGEREGr_RESERVEDf_GET(r) (((r).pagereg[0]) & 0xff)
#define BCM89500_A0_PAGEREGr_RESERVEDf_SET(r,f) (r).pagereg[0]=(((r).pagereg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PAGEREG.
 *
 */
#define BCM89500_A0_READ_PAGEREGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PAGEREGr,(r._pagereg),1)
#define BCM89500_A0_WRITE_PAGEREGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PAGEREGr,&(r._pagereg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAGEREGr BCM89500_A0_PAGEREGr
#define PAGEREGr_SIZE BCM89500_A0_PAGEREGr_SIZE
typedef BCM89500_A0_PAGEREGr_t PAGEREGr_t;
#define PAGEREGr_CLR BCM89500_A0_PAGEREGr_CLR
#define PAGEREGr_SET BCM89500_A0_PAGEREGr_SET
#define PAGEREGr_GET BCM89500_A0_PAGEREGr_GET
#define PAGEREGr_RESERVEDf_GET BCM89500_A0_PAGEREGr_RESERVEDf_GET
#define PAGEREGr_RESERVEDf_SET BCM89500_A0_PAGEREGr_RESERVEDf_SET
#define READ_PAGEREGr BCM89500_A0_READ_PAGEREGr
#define WRITE_PAGEREGr BCM89500_A0_WRITE_PAGEREGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PAGEREGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PAUSESTS
 * BLOCKS:   SYS
 * DESC:     Pause Status Summary Register
 * SIZE:     32
 * FIELDS:
 *     PAUSE_STS        PAUSE State.18 bit field indicating the PAUSE state for each 10/100/1000BASE-T port and IMP port.Bit 8- 0 = IMP port, Port 7 - Port 0 Transmit Pause CapabilityBit 17-9 = IMP port, Port 7 - Port 0 Receive Pause Capability0 = Disabled1 = Enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PAUSESTSr 0x0000010a

#define BCM89500_A0_PAUSESTSr_SIZE 4

/*
 * This structure should be used to declare and program PAUSESTS.
 *
 */
typedef union BCM89500_A0_PAUSESTSr_s {
	uint32_t v[1];
	uint32_t pausests[1];
	uint32_t _pausests;
} BCM89500_A0_PAUSESTSr_t;

#define BCM89500_A0_PAUSESTSr_CLR(r) (r).pausests[0] = 0
#define BCM89500_A0_PAUSESTSr_SET(r,d) (r).pausests[0] = d
#define BCM89500_A0_PAUSESTSr_GET(r) (r).pausests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PAUSESTSr_PAUSE_STSf_GET(r) (((r).pausests[0]) & 0x3ffff)
#define BCM89500_A0_PAUSESTSr_PAUSE_STSf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PAUSESTSr_RESERVEDf_GET(r) ((((r).pausests[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PAUSESTSr_RESERVEDf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PAUSESTS.
 *
 */
#define BCM89500_A0_READ_PAUSESTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PAUSESTSr,(r._pausests),4)
#define BCM89500_A0_WRITE_PAUSESTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PAUSESTSr,&(r._pausests),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSESTSr BCM89500_A0_PAUSESTSr
#define PAUSESTSr_SIZE BCM89500_A0_PAUSESTSr_SIZE
typedef BCM89500_A0_PAUSESTSr_t PAUSESTSr_t;
#define PAUSESTSr_CLR BCM89500_A0_PAUSESTSr_CLR
#define PAUSESTSr_SET BCM89500_A0_PAUSESTSr_SET
#define PAUSESTSr_GET BCM89500_A0_PAUSESTSr_GET
#define PAUSESTSr_PAUSE_STSf_GET BCM89500_A0_PAUSESTSr_PAUSE_STSf_GET
#define PAUSESTSr_PAUSE_STSf_SET BCM89500_A0_PAUSESTSr_PAUSE_STSf_SET
#define PAUSESTSr_RESERVEDf_GET BCM89500_A0_PAUSESTSr_RESERVEDf_GET
#define PAUSESTSr_RESERVEDf_SET BCM89500_A0_PAUSESTSr_RESERVEDf_SET
#define READ_PAUSESTSr BCM89500_A0_READ_PAUSESTSr
#define WRITE_PAUSESTSr BCM89500_A0_WRITE_PAUSESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PAUSESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PAUSE_CAP
 * BLOCKS:   SYS
 * DESC:     PAUSE Capability Register
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_CAP     Software setting for the capability of Transmitting Pause Frame.Bit 8 = Port 8.Bit 7 = Port 7.Bits 5:0 = Port 5 - Port 0.
 *     RX_PAUSE_CAP     Software setting for the capability of Receiving Pause Frame.Bit 17 = Port 8,Bit 16 = Port 7,Bits 14:9 = Port 5- Port 0.
 *     RESERVED         Reserved
 *     EN_OVERRIDE      Force the contents of the register to be used.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PAUSE_CAPr 0x00000028

#define BCM89500_A0_PAUSE_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CAP.
 *
 */
typedef union BCM89500_A0_PAUSE_CAPr_s {
	uint32_t v[1];
	uint32_t pause_cap[1];
	uint32_t _pause_cap;
} BCM89500_A0_PAUSE_CAPr_t;

#define BCM89500_A0_PAUSE_CAPr_CLR(r) (r).pause_cap[0] = 0
#define BCM89500_A0_PAUSE_CAPr_SET(r,d) (r).pause_cap[0] = d
#define BCM89500_A0_PAUSE_CAPr_GET(r) (r).pause_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET(r) (((r).pause_cap[0]) & 0x1ff)
#define BCM89500_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET(r) ((((r).pause_cap[0]) >> 9) & 0x1ff)
#define BCM89500_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM89500_A0_PAUSE_CAPr_RESERVEDf_GET(r) ((((r).pause_cap[0]) >> 18) & 0x1f)
#define BCM89500_A0_PAUSE_CAPr_RESERVEDf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM89500_A0_PAUSE_CAPr_EN_OVERRIDEf_GET(r) ((((r).pause_cap[0]) >> 23) & 0x1)
#define BCM89500_A0_PAUSE_CAPr_EN_OVERRIDEf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM89500_A0_PAUSE_CAPr_RESERVED_1f_GET(r) ((((r).pause_cap[0]) >> 24) & 0xff)
#define BCM89500_A0_PAUSE_CAPr_RESERVED_1f_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PAUSE_CAP.
 *
 */
#define BCM89500_A0_READ_PAUSE_CAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PAUSE_CAPr,(r._pause_cap),4)
#define BCM89500_A0_WRITE_PAUSE_CAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PAUSE_CAPr,&(r._pause_cap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CAPr BCM89500_A0_PAUSE_CAPr
#define PAUSE_CAPr_SIZE BCM89500_A0_PAUSE_CAPr_SIZE
typedef BCM89500_A0_PAUSE_CAPr_t PAUSE_CAPr_t;
#define PAUSE_CAPr_CLR BCM89500_A0_PAUSE_CAPr_CLR
#define PAUSE_CAPr_SET BCM89500_A0_PAUSE_CAPr_SET
#define PAUSE_CAPr_GET BCM89500_A0_PAUSE_CAPr_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_GET BCM89500_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_SET BCM89500_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RX_PAUSE_CAPf_GET BCM89500_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET
#define PAUSE_CAPr_RX_PAUSE_CAPf_SET BCM89500_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RESERVEDf_GET BCM89500_A0_PAUSE_CAPr_RESERVEDf_GET
#define PAUSE_CAPr_RESERVEDf_SET BCM89500_A0_PAUSE_CAPr_RESERVEDf_SET
#define PAUSE_CAPr_EN_OVERRIDEf_GET BCM89500_A0_PAUSE_CAPr_EN_OVERRIDEf_GET
#define PAUSE_CAPr_EN_OVERRIDEf_SET BCM89500_A0_PAUSE_CAPr_EN_OVERRIDEf_SET
#define PAUSE_CAPr_RESERVED_1f_GET BCM89500_A0_PAUSE_CAPr_RESERVED_1f_GET
#define PAUSE_CAPr_RESERVED_1f_SET BCM89500_A0_PAUSE_CAPr_RESERVED_1f_SET
#define READ_PAUSE_CAPr BCM89500_A0_READ_PAUSE_CAPr
#define WRITE_PAUSE_CAPr BCM89500_A0_WRITE_PAUSE_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PAUSE_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PAUSE_FRM_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause Frame Detection Control Register
 * SIZE:     8
 * FIELDS:
 *     PAUSE_IGNORE_DA  Pause_ignore_DA0: Check DA field on Pause Frame detection1: Ignore DA field on Pause Frame detection
 *     RESERVED_1       Reserved, Should SET 2'b00 for correct operation
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PAUSE_FRM_CTRLr 0x00000080

#define BCM89500_A0_PAUSE_FRM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PAUSE_FRM_CTRL.
 *
 */
typedef union BCM89500_A0_PAUSE_FRM_CTRLr_s {
	uint32_t v[1];
	uint32_t pause_frm_ctrl[1];
	uint32_t _pause_frm_ctrl;
} BCM89500_A0_PAUSE_FRM_CTRLr_t;

#define BCM89500_A0_PAUSE_FRM_CTRLr_CLR(r) (r).pause_frm_ctrl[0] = 0
#define BCM89500_A0_PAUSE_FRM_CTRLr_SET(r,d) (r).pause_frm_ctrl[0] = d
#define BCM89500_A0_PAUSE_FRM_CTRLr_GET(r) (r).pause_frm_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET(r) (((r).pause_frm_ctrl[0]) & 0x1)
#define BCM89500_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_1f_GET(r) ((((r).pause_frm_ctrl[0]) >> 1) & 0x3)
#define BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_1f_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_2f_GET(r) ((((r).pause_frm_ctrl[0]) >> 3) & 0x1f)
#define BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_2f_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PAUSE_FRM_CTRL.
 *
 */
#define BCM89500_A0_READ_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PAUSE_FRM_CTRLr,(r._pause_frm_ctrl),1)
#define BCM89500_A0_WRITE_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PAUSE_FRM_CTRLr,&(r._pause_frm_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_FRM_CTRLr BCM89500_A0_PAUSE_FRM_CTRLr
#define PAUSE_FRM_CTRLr_SIZE BCM89500_A0_PAUSE_FRM_CTRLr_SIZE
typedef BCM89500_A0_PAUSE_FRM_CTRLr_t PAUSE_FRM_CTRLr_t;
#define PAUSE_FRM_CTRLr_CLR BCM89500_A0_PAUSE_FRM_CTRLr_CLR
#define PAUSE_FRM_CTRLr_SET BCM89500_A0_PAUSE_FRM_CTRLr_SET
#define PAUSE_FRM_CTRLr_GET BCM89500_A0_PAUSE_FRM_CTRLr_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET BCM89500_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET BCM89500_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET
#define PAUSE_FRM_CTRLr_RESERVED_1f_GET BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_1f_GET
#define PAUSE_FRM_CTRLr_RESERVED_1f_SET BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_1f_SET
#define PAUSE_FRM_CTRLr_RESERVED_2f_GET BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_2f_GET
#define PAUSE_FRM_CTRLr_RESERVED_2f_SET BCM89500_A0_PAUSE_FRM_CTRLr_RESERVED_2f_SET
#define READ_PAUSE_FRM_CTRLr BCM89500_A0_READ_PAUSE_FRM_CTRLr
#define WRITE_PAUSE_FRM_CTRLr BCM89500_A0_WRITE_PAUSE_FRM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PAUSE_FRM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PAUSE_QUANTA
 * BLOCKS:   SYS
 * DESC:     PAUSE Quanta register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_QUANTA     The number of slot times that the transmitter wishes the link partner to suspend its transmission. The same value is common to all ports which have Auto-Negotiated to full duplex with flow control enabled.
 *
 ******************************************************************************/
#define BCM89500_A0_PAUSE_QUANTAr 0x0000000c

#define BCM89500_A0_PAUSE_QUANTAr_SIZE 2

/*
 * This structure should be used to declare and program PAUSE_QUANTA.
 *
 */
typedef union BCM89500_A0_PAUSE_QUANTAr_s {
	uint32_t v[1];
	uint32_t pause_quanta[1];
	uint32_t _pause_quanta;
} BCM89500_A0_PAUSE_QUANTAr_t;

#define BCM89500_A0_PAUSE_QUANTAr_CLR(r) (r).pause_quanta[0] = 0
#define BCM89500_A0_PAUSE_QUANTAr_SET(r,d) (r).pause_quanta[0] = d
#define BCM89500_A0_PAUSE_QUANTAr_GET(r) (r).pause_quanta[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET(r) (((r).pause_quanta[0]) & 0xffff)
#define BCM89500_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET(r,f) (r).pause_quanta[0]=(((r).pause_quanta[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAUSE_QUANTA.
 *
 */
#define BCM89500_A0_READ_PAUSE_QUANTAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PAUSE_QUANTAr,(r._pause_quanta),2)
#define BCM89500_A0_WRITE_PAUSE_QUANTAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PAUSE_QUANTAr,&(r._pause_quanta),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_QUANTAr BCM89500_A0_PAUSE_QUANTAr
#define PAUSE_QUANTAr_SIZE BCM89500_A0_PAUSE_QUANTAr_SIZE
typedef BCM89500_A0_PAUSE_QUANTAr_t PAUSE_QUANTAr_t;
#define PAUSE_QUANTAr_CLR BCM89500_A0_PAUSE_QUANTAr_CLR
#define PAUSE_QUANTAr_SET BCM89500_A0_PAUSE_QUANTAr_SET
#define PAUSE_QUANTAr_GET BCM89500_A0_PAUSE_QUANTAr_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_GET BCM89500_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_SET BCM89500_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET
#define READ_PAUSE_QUANTAr BCM89500_A0_READ_PAUSE_QUANTAr
#define WRITE_PAUSE_QUANTAr BCM89500_A0_WRITE_PAUSE_QUANTAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PAUSE_QUANTAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PBPTRFIFO_0
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 0(Not2Release)
 * SIZE:     48
 * FIELDS:
 *     VALID_CNT_P0     Valid Counter of pbptrfifo for Port 0
 *     VALID_CNT_P1     Valid Counter of pbptrfifo for Port 1
 *     VALID_CNT_P2     Valid Counter of pbptrfifo for Port 2
 *     VALID_CNT_P3     Valid Counter of pbptrfifo for Port 3
 *     VALID_CNT_P4     Valid Counter of pbptrfifo for Port 4
 *     VALID_CNT_P5     Valid Counter of pbptrfifo for Port 5
 *
 ******************************************************************************/
#define BCM89500_A0_PBPTRFIFO_0r 0x00000150

#define BCM89500_A0_PBPTRFIFO_0r_SIZE 6

/*
 * This structure should be used to declare and program PBPTRFIFO_0.
 *
 */
typedef union BCM89500_A0_PBPTRFIFO_0r_s {
	uint32_t v[2];
	uint32_t pbptrfifo_0[2];
	uint32_t _pbptrfifo_0;
} BCM89500_A0_PBPTRFIFO_0r_t;

#define BCM89500_A0_PBPTRFIFO_0r_CLR(r) CDK_MEMSET(&((r)._pbptrfifo_0), 0, sizeof(BCM89500_A0_PBPTRFIFO_0r_t))
#define BCM89500_A0_PBPTRFIFO_0r_SET(r,i,d) (r).pbptrfifo_0[i] = d
#define BCM89500_A0_PBPTRFIFO_0r_GET(r,i) (r).pbptrfifo_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET(r) (((r).pbptrfifo_0[0]) & 0xff)
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET(r) ((((r).pbptrfifo_0[0]) >> 8) & 0xff)
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET(r) ((((r).pbptrfifo_0[0]) >> 16) & 0xff)
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET(r) ((((r).pbptrfifo_0[0]) >> 24) & 0xff)
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET(r) (((r).pbptrfifo_0[1]) & 0xff)
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET(r) ((((r).pbptrfifo_0[1]) >> 8) & 0xff)
#define BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PBPTRFIFO_0.
 *
 */
#define BCM89500_A0_READ_PBPTRFIFO_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PBPTRFIFO_0r,(r._pbptrfifo_0),6)
#define BCM89500_A0_WRITE_PBPTRFIFO_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PBPTRFIFO_0r,&(r._pbptrfifo_0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_0r BCM89500_A0_PBPTRFIFO_0r
#define PBPTRFIFO_0r_SIZE BCM89500_A0_PBPTRFIFO_0r_SIZE
typedef BCM89500_A0_PBPTRFIFO_0r_t PBPTRFIFO_0r_t;
#define PBPTRFIFO_0r_CLR BCM89500_A0_PBPTRFIFO_0r_CLR
#define PBPTRFIFO_0r_SET BCM89500_A0_PBPTRFIFO_0r_SET
#define PBPTRFIFO_0r_GET BCM89500_A0_PBPTRFIFO_0r_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_GET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_SET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET
#define PBPTRFIFO_0r_VALID_CNT_P1f_GET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET
#define PBPTRFIFO_0r_VALID_CNT_P1f_SET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET
#define PBPTRFIFO_0r_VALID_CNT_P2f_GET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET
#define PBPTRFIFO_0r_VALID_CNT_P2f_SET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET
#define PBPTRFIFO_0r_VALID_CNT_P3f_GET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET
#define PBPTRFIFO_0r_VALID_CNT_P3f_SET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET
#define PBPTRFIFO_0r_VALID_CNT_P4f_GET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET
#define PBPTRFIFO_0r_VALID_CNT_P4f_SET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET
#define PBPTRFIFO_0r_VALID_CNT_P5f_GET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET
#define PBPTRFIFO_0r_VALID_CNT_P5f_SET BCM89500_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET
#define READ_PBPTRFIFO_0r BCM89500_A0_READ_PBPTRFIFO_0r
#define WRITE_PBPTRFIFO_0r BCM89500_A0_WRITE_PBPTRFIFO_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PBPTRFIFO_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PBPTRFIFO_1
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 1(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     RESERVED_0       Reserved
 *     VALID_CNT_P7     Valid Counter of pbptrfifo for Port 7 (polar feature).
 *     VALID_CNT_P8     Valid Counter of pbptrfifo for Port 8(IMP Port).
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PBPTRFIFO_1r 0x00000156

#define BCM89500_A0_PBPTRFIFO_1r_SIZE 4

/*
 * This structure should be used to declare and program PBPTRFIFO_1.
 *
 */
typedef union BCM89500_A0_PBPTRFIFO_1r_s {
	uint32_t v[1];
	uint32_t pbptrfifo_1[1];
	uint32_t _pbptrfifo_1;
} BCM89500_A0_PBPTRFIFO_1r_t;

#define BCM89500_A0_PBPTRFIFO_1r_CLR(r) (r).pbptrfifo_1[0] = 0
#define BCM89500_A0_PBPTRFIFO_1r_SET(r,d) (r).pbptrfifo_1[0] = d
#define BCM89500_A0_PBPTRFIFO_1r_GET(r) (r).pbptrfifo_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PBPTRFIFO_1r_RESERVED_0f_GET(r) (((r).pbptrfifo_1[0]) & 0xff)
#define BCM89500_A0_PBPTRFIFO_1r_RESERVED_0f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P7f_GET(r) ((((r).pbptrfifo_1[0]) >> 8) & 0xff)
#define BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P7f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET(r) ((((r).pbptrfifo_1[0]) >> 16) & 0xff)
#define BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_PBPTRFIFO_1r_RESERVED_1f_GET(r) ((((r).pbptrfifo_1[0]) >> 24) & 0xff)
#define BCM89500_A0_PBPTRFIFO_1r_RESERVED_1f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PBPTRFIFO_1.
 *
 */
#define BCM89500_A0_READ_PBPTRFIFO_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PBPTRFIFO_1r,(r._pbptrfifo_1),4)
#define BCM89500_A0_WRITE_PBPTRFIFO_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PBPTRFIFO_1r,&(r._pbptrfifo_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_1r BCM89500_A0_PBPTRFIFO_1r
#define PBPTRFIFO_1r_SIZE BCM89500_A0_PBPTRFIFO_1r_SIZE
typedef BCM89500_A0_PBPTRFIFO_1r_t PBPTRFIFO_1r_t;
#define PBPTRFIFO_1r_CLR BCM89500_A0_PBPTRFIFO_1r_CLR
#define PBPTRFIFO_1r_SET BCM89500_A0_PBPTRFIFO_1r_SET
#define PBPTRFIFO_1r_GET BCM89500_A0_PBPTRFIFO_1r_GET
#define PBPTRFIFO_1r_RESERVED_0f_GET BCM89500_A0_PBPTRFIFO_1r_RESERVED_0f_GET
#define PBPTRFIFO_1r_RESERVED_0f_SET BCM89500_A0_PBPTRFIFO_1r_RESERVED_0f_SET
#define PBPTRFIFO_1r_VALID_CNT_P7f_GET BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P7f_GET
#define PBPTRFIFO_1r_VALID_CNT_P7f_SET BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P7f_SET
#define PBPTRFIFO_1r_VALID_CNT_P8f_GET BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET
#define PBPTRFIFO_1r_VALID_CNT_P8f_SET BCM89500_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET
#define PBPTRFIFO_1r_RESERVED_1f_GET BCM89500_A0_PBPTRFIFO_1r_RESERVED_1f_GET
#define PBPTRFIFO_1r_RESERVED_1f_SET BCM89500_A0_PBPTRFIFO_1r_RESERVED_1f_SET
#define READ_PBPTRFIFO_1r BCM89500_A0_READ_PBPTRFIFO_1r
#define WRITE_PBPTRFIFO_1r BCM89500_A0_WRITE_PBPTRFIFO_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PBPTRFIFO_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PEAK_TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Peak Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TEMP_DATA   It keeps track the peak temperature monitor result since the last read.- It's the minimum code for the highest temperature since the last read.- After read, the register to be reset to 0x1FF.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_PEAK_TEMP_MON_RESUr 0x00000f04

#define BCM89500_A0_PEAK_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TEMP_MON_RESU.
 *
 */
typedef union BCM89500_A0_PEAK_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t peak_temp_mon_resu[1];
	uint32_t _peak_temp_mon_resu;
} BCM89500_A0_PEAK_TEMP_MON_RESUr_t;

#define BCM89500_A0_PEAK_TEMP_MON_RESUr_CLR(r) (r).peak_temp_mon_resu[0] = 0
#define BCM89500_A0_PEAK_TEMP_MON_RESUr_SET(r,d) (r).peak_temp_mon_resu[0] = d
#define BCM89500_A0_PEAK_TEMP_MON_RESUr_GET(r) (r).peak_temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET(r) (((r).peak_temp_mon_resu[0]) & 0x1ff)
#define BCM89500_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).peak_temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM89500_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PEAK_TEMP_MON_RESU.
 *
 */
#define BCM89500_A0_READ_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PEAK_TEMP_MON_RESUr,(r._peak_temp_mon_resu),2)
#define BCM89500_A0_WRITE_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PEAK_TEMP_MON_RESUr,&(r._peak_temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TEMP_MON_RESUr BCM89500_A0_PEAK_TEMP_MON_RESUr
#define PEAK_TEMP_MON_RESUr_SIZE BCM89500_A0_PEAK_TEMP_MON_RESUr_SIZE
typedef BCM89500_A0_PEAK_TEMP_MON_RESUr_t PEAK_TEMP_MON_RESUr_t;
#define PEAK_TEMP_MON_RESUr_CLR BCM89500_A0_PEAK_TEMP_MON_RESUr_CLR
#define PEAK_TEMP_MON_RESUr_SET BCM89500_A0_PEAK_TEMP_MON_RESUr_SET
#define PEAK_TEMP_MON_RESUr_GET BCM89500_A0_PEAK_TEMP_MON_RESUr_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET BCM89500_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET BCM89500_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_GET BCM89500_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_SET BCM89500_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_PEAK_TEMP_MON_RESUr BCM89500_A0_READ_PEAK_TEMP_MON_RESUr
#define WRITE_PEAK_TEMP_MON_RESUr BCM89500_A0_WRITE_PEAK_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PEAK_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PHY_CTRL
 * BLOCKS:   SYS
 * DESC:     PHY Control Register (Not2Release) (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QPHY_RESET       Quad BR-PHY Reset ControlSetting this bit applies hard reset to quad BR-PHY(P0~P3).1=assert reset0=clear resetNote:When hard reset is cleared, the PHY must be re-initialized.
 *     RESERVED_0       Reserved
 *     SPHY_RESET       BR-PHY Reset ControlSetting this bit applies hard reset to single BR-PHY(P4).1=assert reset0=clear resetNote:When hard reset is cleared, the PHY must be re-initialized.
 *     SD_RESET         SerDes Reset ControlSetting this bit applies hard reset to SerDes(P5).1=assert reset0=clear resetNote:When hard reset is cleared, the SerDes must be re-initialized.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PHY_CTRLr 0x00000048

#define BCM89500_A0_PHY_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program PHY_CTRL.
 *
 */
typedef union BCM89500_A0_PHY_CTRLr_s {
	uint32_t v[1];
	uint32_t phy_ctrl[1];
	uint32_t _phy_ctrl;
} BCM89500_A0_PHY_CTRLr_t;

#define BCM89500_A0_PHY_CTRLr_CLR(r) (r).phy_ctrl[0] = 0
#define BCM89500_A0_PHY_CTRLr_SET(r,d) (r).phy_ctrl[0] = d
#define BCM89500_A0_PHY_CTRLr_GET(r) (r).phy_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PHY_CTRLr_QPHY_RESETf_GET(r) (((r).phy_ctrl[0]) & 0x1)
#define BCM89500_A0_PHY_CTRLr_QPHY_RESETf_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PHY_CTRLr_RESERVED_0f_GET(r) ((((r).phy_ctrl[0]) >> 1) & 0x7)
#define BCM89500_A0_PHY_CTRLr_RESERVED_0f_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_PHY_CTRLr_SPHY_RESETf_GET(r) ((((r).phy_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_PHY_CTRLr_SPHY_RESETf_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_PHY_CTRLr_SD_RESETf_GET(r) ((((r).phy_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_PHY_CTRLr_SD_RESETf_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_PHY_CTRLr_RESERVED_1f_GET(r) ((((r).phy_ctrl[0]) >> 6) & 0x3ff)
#define BCM89500_A0_PHY_CTRLr_RESERVED_1f_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access PHY_CTRL.
 *
 */
#define BCM89500_A0_READ_PHY_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PHY_CTRLr,(r._phy_ctrl),2)
#define BCM89500_A0_WRITE_PHY_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PHY_CTRLr,&(r._phy_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_CTRLr BCM89500_A0_PHY_CTRLr
#define PHY_CTRLr_SIZE BCM89500_A0_PHY_CTRLr_SIZE
typedef BCM89500_A0_PHY_CTRLr_t PHY_CTRLr_t;
#define PHY_CTRLr_CLR BCM89500_A0_PHY_CTRLr_CLR
#define PHY_CTRLr_SET BCM89500_A0_PHY_CTRLr_SET
#define PHY_CTRLr_GET BCM89500_A0_PHY_CTRLr_GET
#define PHY_CTRLr_QPHY_RESETf_GET BCM89500_A0_PHY_CTRLr_QPHY_RESETf_GET
#define PHY_CTRLr_QPHY_RESETf_SET BCM89500_A0_PHY_CTRLr_QPHY_RESETf_SET
#define PHY_CTRLr_RESERVED_0f_GET BCM89500_A0_PHY_CTRLr_RESERVED_0f_GET
#define PHY_CTRLr_RESERVED_0f_SET BCM89500_A0_PHY_CTRLr_RESERVED_0f_SET
#define PHY_CTRLr_SPHY_RESETf_GET BCM89500_A0_PHY_CTRLr_SPHY_RESETf_GET
#define PHY_CTRLr_SPHY_RESETf_SET BCM89500_A0_PHY_CTRLr_SPHY_RESETf_SET
#define PHY_CTRLr_SD_RESETf_GET BCM89500_A0_PHY_CTRLr_SD_RESETf_GET
#define PHY_CTRLr_SD_RESETf_SET BCM89500_A0_PHY_CTRLr_SD_RESETf_SET
#define PHY_CTRLr_RESERVED_1f_GET BCM89500_A0_PHY_CTRLr_RESERVED_1f_GET
#define PHY_CTRLr_RESERVED_1f_SET BCM89500_A0_PHY_CTRLr_RESERVED_1f_SET
#define READ_PHY_CTRLr BCM89500_A0_READ_PHY_CTRLr
#define WRITE_PHY_CTRLr BCM89500_A0_WRITE_PHY_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PHY_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PHY_INT_STS
 * BLOCKS:   SYS
 * DESC:     PHY Interrupt Status Register (Not2Release) (polar feature)
 * SIZE:     16
 * FIELDS:
 *     PHY_INT_STS      bit[4:0]: port4 - port0.
 *     RESERVED         Reserved
 *     PLL_LOCK_CHG_INT_STS Switch PLL lock change interrupt status. This bit filed is cleared upon read. PLL status is reflected in bit [0] of PLL Status Register at offset 0xdd.1: indicates PLL lock has changed.
 *     CFP_TCAM_CHKSUM_ERR_MIR CFP TCAM checksum errorThis bit reflects the bit[15] CFP_TCAM_CHKSUM_ERR of TCAM Checksum Status Register, see detail register description at page address 0x00, offset 0xea.
 *
 ******************************************************************************/
#define BCM89500_A0_PHY_INT_STSr 0x00000044

#define BCM89500_A0_PHY_INT_STSr_SIZE 2

/*
 * This structure should be used to declare and program PHY_INT_STS.
 *
 */
typedef union BCM89500_A0_PHY_INT_STSr_s {
	uint32_t v[1];
	uint32_t phy_int_sts[1];
	uint32_t _phy_int_sts;
} BCM89500_A0_PHY_INT_STSr_t;

#define BCM89500_A0_PHY_INT_STSr_CLR(r) (r).phy_int_sts[0] = 0
#define BCM89500_A0_PHY_INT_STSr_SET(r,d) (r).phy_int_sts[0] = d
#define BCM89500_A0_PHY_INT_STSr_GET(r) (r).phy_int_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PHY_INT_STSr_PHY_INT_STSf_GET(r) (((r).phy_int_sts[0]) & 0x1f)
#define BCM89500_A0_PHY_INT_STSr_PHY_INT_STSf_SET(r,f) (r).phy_int_sts[0]=(((r).phy_int_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_PHY_INT_STSr_RESERVEDf_GET(r) ((((r).phy_int_sts[0]) >> 5) & 0x1ff)
#define BCM89500_A0_PHY_INT_STSr_RESERVEDf_SET(r,f) (r).phy_int_sts[0]=(((r).phy_int_sts[0] & ~((uint32_t)0x1ff << 5)) | ((((uint32_t)f) & 0x1ff) << 5))
#define BCM89500_A0_PHY_INT_STSr_PLL_LOCK_CHG_INT_STSf_GET(r) ((((r).phy_int_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_PHY_INT_STSr_PLL_LOCK_CHG_INT_STSf_SET(r,f) (r).phy_int_sts[0]=(((r).phy_int_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_PHY_INT_STSr_CFP_TCAM_CHKSUM_ERR_MIRf_GET(r) ((((r).phy_int_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_PHY_INT_STSr_CFP_TCAM_CHKSUM_ERR_MIRf_SET(r,f) (r).phy_int_sts[0]=(((r).phy_int_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PHY_INT_STS.
 *
 */
#define BCM89500_A0_READ_PHY_INT_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PHY_INT_STSr,(r._phy_int_sts),2)
#define BCM89500_A0_WRITE_PHY_INT_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PHY_INT_STSr,&(r._phy_int_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_INT_STSr BCM89500_A0_PHY_INT_STSr
#define PHY_INT_STSr_SIZE BCM89500_A0_PHY_INT_STSr_SIZE
typedef BCM89500_A0_PHY_INT_STSr_t PHY_INT_STSr_t;
#define PHY_INT_STSr_CLR BCM89500_A0_PHY_INT_STSr_CLR
#define PHY_INT_STSr_SET BCM89500_A0_PHY_INT_STSr_SET
#define PHY_INT_STSr_GET BCM89500_A0_PHY_INT_STSr_GET
#define PHY_INT_STSr_PHY_INT_STSf_GET BCM89500_A0_PHY_INT_STSr_PHY_INT_STSf_GET
#define PHY_INT_STSr_PHY_INT_STSf_SET BCM89500_A0_PHY_INT_STSr_PHY_INT_STSf_SET
#define PHY_INT_STSr_RESERVEDf_GET BCM89500_A0_PHY_INT_STSr_RESERVEDf_GET
#define PHY_INT_STSr_RESERVEDf_SET BCM89500_A0_PHY_INT_STSr_RESERVEDf_SET
#define PHY_INT_STSr_PLL_LOCK_CHG_INT_STSf_GET BCM89500_A0_PHY_INT_STSr_PLL_LOCK_CHG_INT_STSf_GET
#define PHY_INT_STSr_PLL_LOCK_CHG_INT_STSf_SET BCM89500_A0_PHY_INT_STSr_PLL_LOCK_CHG_INT_STSf_SET
#define PHY_INT_STSr_CFP_TCAM_CHKSUM_ERR_MIRf_GET BCM89500_A0_PHY_INT_STSr_CFP_TCAM_CHKSUM_ERR_MIRf_GET
#define PHY_INT_STSr_CFP_TCAM_CHKSUM_ERR_MIRf_SET BCM89500_A0_PHY_INT_STSr_CFP_TCAM_CHKSUM_ERR_MIRf_SET
#define READ_PHY_INT_STSr BCM89500_A0_READ_PHY_INT_STSr
#define WRITE_PHY_INT_STSr BCM89500_A0_WRITE_PHY_INT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PHY_INT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PHY_PLL_CTRL
 * BLOCKS:   SYS
 * DESC:     PHY PLL Control Register (Not2Release) (polar feature)
 * SIZE:     16
 * FIELDS:
 *     PHY_PLL_CTRL     Single BR-PHY PLL Controlbit[3]: Passive signal detector power on protectionbit[2]: reservedbit[1]: cmos_tvcoi enablebit[0]: txclk[7:0] enabled in BR mode
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PHY_PLL_CTRLr 0x00000046

#define BCM89500_A0_PHY_PLL_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program PHY_PLL_CTRL.
 *
 */
typedef union BCM89500_A0_PHY_PLL_CTRLr_s {
	uint32_t v[1];
	uint32_t phy_pll_ctrl[1];
	uint32_t _phy_pll_ctrl;
} BCM89500_A0_PHY_PLL_CTRLr_t;

#define BCM89500_A0_PHY_PLL_CTRLr_CLR(r) (r).phy_pll_ctrl[0] = 0
#define BCM89500_A0_PHY_PLL_CTRLr_SET(r,d) (r).phy_pll_ctrl[0] = d
#define BCM89500_A0_PHY_PLL_CTRLr_GET(r) (r).phy_pll_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PHY_PLL_CTRLr_PHY_PLL_CTRLf_GET(r) (((r).phy_pll_ctrl[0]) & 0xf)
#define BCM89500_A0_PHY_PLL_CTRLr_PHY_PLL_CTRLf_SET(r,f) (r).phy_pll_ctrl[0]=(((r).phy_pll_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_PHY_PLL_CTRLr_RESERVEDf_GET(r) ((((r).phy_pll_ctrl[0]) >> 4) & 0xfff)
#define BCM89500_A0_PHY_PLL_CTRLr_RESERVEDf_SET(r,f) (r).phy_pll_ctrl[0]=(((r).phy_pll_ctrl[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access PHY_PLL_CTRL.
 *
 */
#define BCM89500_A0_READ_PHY_PLL_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PHY_PLL_CTRLr,(r._phy_pll_ctrl),2)
#define BCM89500_A0_WRITE_PHY_PLL_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PHY_PLL_CTRLr,&(r._phy_pll_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_PLL_CTRLr BCM89500_A0_PHY_PLL_CTRLr
#define PHY_PLL_CTRLr_SIZE BCM89500_A0_PHY_PLL_CTRLr_SIZE
typedef BCM89500_A0_PHY_PLL_CTRLr_t PHY_PLL_CTRLr_t;
#define PHY_PLL_CTRLr_CLR BCM89500_A0_PHY_PLL_CTRLr_CLR
#define PHY_PLL_CTRLr_SET BCM89500_A0_PHY_PLL_CTRLr_SET
#define PHY_PLL_CTRLr_GET BCM89500_A0_PHY_PLL_CTRLr_GET
#define PHY_PLL_CTRLr_PHY_PLL_CTRLf_GET BCM89500_A0_PHY_PLL_CTRLr_PHY_PLL_CTRLf_GET
#define PHY_PLL_CTRLr_PHY_PLL_CTRLf_SET BCM89500_A0_PHY_PLL_CTRLr_PHY_PLL_CTRLf_SET
#define PHY_PLL_CTRLr_RESERVEDf_GET BCM89500_A0_PHY_PLL_CTRLr_RESERVEDf_GET
#define PHY_PLL_CTRLr_RESERVEDf_SET BCM89500_A0_PHY_PLL_CTRLr_RESERVEDf_SET
#define READ_PHY_PLL_CTRLr BCM89500_A0_READ_PHY_PLL_CTRLr
#define WRITE_PHY_PLL_CTRLr BCM89500_A0_WRITE_PHY_PLL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PHY_PLL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PHY_PWR_DOWN
 * BLOCKS:   SYS
 * DESC:     PHY Power Down Mode Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     EXT_PWR_DOWN_PHY_EN PHY power down mode setting.Set this bit to enable ext_pwrdown of BR-PHY. When ext_pwrdown is applied, the PHY except the signal detect circuit will enter standby/power down mode.Bit [4] applies to the P4. The clocks will be shutdown, and the state machines will remain in the same state before the clocks will be shutdown. Once user want to come out of the ext_pwrdown mode then user needs to clear these bits and apply soft reset so the statemachines will be reset and link will establish again.Bit [3:0] applies to P3-0. The analog transmit DAC and receiver functions are powered down. The PLLs and Bias blocks are powered down. When bits [19:16] are enabled, the corresponding port can automatically recover from its standby power down mode when energy is detected on the port. Also, the port's corresponding bit in this field is cleared as well. Otherwise, user needs to clear the corresponding bit in this field in order to recover link status.
 *     RESERVED_0       Reserved
 *     EXT_PWR_DOWN_SD_PHY_EN Set this bit to enable ext_pwrdown_sd of BR-PHY. When ext_pwrdown_sd is applied, the signal detect circuit will be shutdown. bit[12:8]: port4-0.
 *     RESERVED_1       Reserved
 *     EN_AUTO_RECOVER_STD Set this bit to enable automatically link status recover when energy is detected on the port. When enabled, no reset is required to recover the link status. Bit[19:16]: port 3-0.
 *     EN_AUTO_CLEAR_PD Set this bit to enable automatic clear for Single BR-PHY's power down mode setting.When bit [4] is set and bit [12] is clear for Single BR-PHY (Port 4) , the BR-PHY is in its  power down mode. If this bit is set and energy is detected, the bit[4] is cleared by hardware. Subsequently, a reset should be applied to single BR-PHY.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PHY_PWR_DOWNr 0x0000004a

#define BCM89500_A0_PHY_PWR_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program PHY_PWR_DOWN.
 *
 */
typedef union BCM89500_A0_PHY_PWR_DOWNr_s {
	uint32_t v[1];
	uint32_t phy_pwr_down[1];
	uint32_t _phy_pwr_down;
} BCM89500_A0_PHY_PWR_DOWNr_t;

#define BCM89500_A0_PHY_PWR_DOWNr_CLR(r) (r).phy_pwr_down[0] = 0
#define BCM89500_A0_PHY_PWR_DOWNr_SET(r,d) (r).phy_pwr_down[0] = d
#define BCM89500_A0_PHY_PWR_DOWNr_GET(r) (r).phy_pwr_down[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_GET(r) (((r).phy_pwr_down[0]) & 0x1f)
#define BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_PHY_PWR_DOWNr_RESERVED_0f_GET(r) ((((r).phy_pwr_down[0]) >> 5) & 0x7)
#define BCM89500_A0_PHY_PWR_DOWNr_RESERVED_0f_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_SD_PHY_ENf_GET(r) ((((r).phy_pwr_down[0]) >> 8) & 0x1f)
#define BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_SD_PHY_ENf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM89500_A0_PHY_PWR_DOWNr_RESERVED_1f_GET(r) ((((r).phy_pwr_down[0]) >> 13) & 0x7)
#define BCM89500_A0_PHY_PWR_DOWNr_RESERVED_1f_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_RECOVER_STDf_GET(r) ((((r).phy_pwr_down[0]) >> 16) & 0xf)
#define BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_RECOVER_STDf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_CLEAR_PDf_GET(r) ((((r).phy_pwr_down[0]) >> 20) & 0x1)
#define BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_CLEAR_PDf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_PHY_PWR_DOWNr_RESERVED_2f_GET(r) ((((r).phy_pwr_down[0]) >> 21) & 0x7ff)
#define BCM89500_A0_PHY_PWR_DOWNr_RESERVED_2f_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PHY_PWR_DOWN.
 *
 */
#define BCM89500_A0_READ_PHY_PWR_DOWNr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PHY_PWR_DOWNr,(r._phy_pwr_down),4)
#define BCM89500_A0_WRITE_PHY_PWR_DOWNr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PHY_PWR_DOWNr,&(r._phy_pwr_down),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_PWR_DOWNr BCM89500_A0_PHY_PWR_DOWNr
#define PHY_PWR_DOWNr_SIZE BCM89500_A0_PHY_PWR_DOWNr_SIZE
typedef BCM89500_A0_PHY_PWR_DOWNr_t PHY_PWR_DOWNr_t;
#define PHY_PWR_DOWNr_CLR BCM89500_A0_PHY_PWR_DOWNr_CLR
#define PHY_PWR_DOWNr_SET BCM89500_A0_PHY_PWR_DOWNr_SET
#define PHY_PWR_DOWNr_GET BCM89500_A0_PHY_PWR_DOWNr_GET
#define PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_GET BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_GET
#define PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_SET BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_PHY_ENf_SET
#define PHY_PWR_DOWNr_RESERVED_0f_GET BCM89500_A0_PHY_PWR_DOWNr_RESERVED_0f_GET
#define PHY_PWR_DOWNr_RESERVED_0f_SET BCM89500_A0_PHY_PWR_DOWNr_RESERVED_0f_SET
#define PHY_PWR_DOWNr_EXT_PWR_DOWN_SD_PHY_ENf_GET BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_SD_PHY_ENf_GET
#define PHY_PWR_DOWNr_EXT_PWR_DOWN_SD_PHY_ENf_SET BCM89500_A0_PHY_PWR_DOWNr_EXT_PWR_DOWN_SD_PHY_ENf_SET
#define PHY_PWR_DOWNr_RESERVED_1f_GET BCM89500_A0_PHY_PWR_DOWNr_RESERVED_1f_GET
#define PHY_PWR_DOWNr_RESERVED_1f_SET BCM89500_A0_PHY_PWR_DOWNr_RESERVED_1f_SET
#define PHY_PWR_DOWNr_EN_AUTO_RECOVER_STDf_GET BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_RECOVER_STDf_GET
#define PHY_PWR_DOWNr_EN_AUTO_RECOVER_STDf_SET BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_RECOVER_STDf_SET
#define PHY_PWR_DOWNr_EN_AUTO_CLEAR_PDf_GET BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_CLEAR_PDf_GET
#define PHY_PWR_DOWNr_EN_AUTO_CLEAR_PDf_SET BCM89500_A0_PHY_PWR_DOWNr_EN_AUTO_CLEAR_PDf_SET
#define PHY_PWR_DOWNr_RESERVED_2f_GET BCM89500_A0_PHY_PWR_DOWNr_RESERVED_2f_GET
#define PHY_PWR_DOWNr_RESERVED_2f_SET BCM89500_A0_PHY_PWR_DOWNr_RESERVED_2f_SET
#define READ_PHY_PWR_DOWNr BCM89500_A0_READ_PHY_PWR_DOWNr
#define WRITE_PHY_PWR_DOWNr BCM89500_A0_WRITE_PHY_PWR_DOWNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PHY_PWR_DOWNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PID2TC
 * BLOCKS:   SYS
 * DESC:     Port ID to TC Map Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     PID2TC           Port to TC mapping table entry corresponding to the ingress port on which the packet was received.bit[26:24]: TC mapping for port 8.bit[23:21]: TC mapping for port 7.bit[20:18]: reserved.bit[17:15]: TC mapping for port 5.bit[14:12]: TC mapping for port 4.bit[11:9]: TC mapping for port 3.bit[8:6]: TC mapping for port 2.bit[5:3]: TC mapping for port 1.bit[2:0]: TC mapping for port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PID2TCr 0x00003048

#define BCM89500_A0_PID2TCr_SIZE 4

/*
 * This structure should be used to declare and program PID2TC.
 *
 */
typedef union BCM89500_A0_PID2TCr_s {
	uint32_t v[1];
	uint32_t pid2tc[1];
	uint32_t _pid2tc;
} BCM89500_A0_PID2TCr_t;

#define BCM89500_A0_PID2TCr_CLR(r) (r).pid2tc[0] = 0
#define BCM89500_A0_PID2TCr_SET(r,d) (r).pid2tc[0] = d
#define BCM89500_A0_PID2TCr_GET(r) (r).pid2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PID2TCr_PID2TCf_GET(r) (((r).pid2tc[0]) & 0x7ffffff)
#define BCM89500_A0_PID2TCr_PID2TCf_SET(r,f) (r).pid2tc[0]=(((r).pid2tc[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))
#define BCM89500_A0_PID2TCr_RESERVEDf_GET(r) ((((r).pid2tc[0]) >> 27) & 0x1f)
#define BCM89500_A0_PID2TCr_RESERVEDf_SET(r,f) (r).pid2tc[0]=(((r).pid2tc[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access PID2TC.
 *
 */
#define BCM89500_A0_READ_PID2TCr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PID2TCr,(r._pid2tc),4)
#define BCM89500_A0_WRITE_PID2TCr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PID2TCr,&(r._pid2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PID2TCr BCM89500_A0_PID2TCr
#define PID2TCr_SIZE BCM89500_A0_PID2TCr_SIZE
typedef BCM89500_A0_PID2TCr_t PID2TCr_t;
#define PID2TCr_CLR BCM89500_A0_PID2TCr_CLR
#define PID2TCr_SET BCM89500_A0_PID2TCr_SET
#define PID2TCr_GET BCM89500_A0_PID2TCr_GET
#define PID2TCr_PID2TCf_GET BCM89500_A0_PID2TCr_PID2TCf_GET
#define PID2TCr_PID2TCf_SET BCM89500_A0_PID2TCr_PID2TCf_SET
#define PID2TCr_RESERVEDf_GET BCM89500_A0_PID2TCr_RESERVEDf_GET
#define PID2TCr_RESERVEDf_SET BCM89500_A0_PID2TCr_RESERVEDf_SET
#define READ_PID2TCr BCM89500_A0_READ_PID2TCr
#define WRITE_PID2TCr BCM89500_A0_WRITE_PID2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PID2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_CTRL
 * BLOCKS:   SYS
 * DESC:     PLL Control Register
 * SIZE:     8
 * FIELDS:
 *     PLL_LP_CTRL      PLL power down controlbit[4]: PLL global power downbit[3]: clock comparator power downbit[2]: channel 1 power downbit[1]: channel 2 power downbit[0]: channel 3 power down
 *     RESERVED         RESERVED
 *     PLL_DRESET       PLL digital resetSoftware must reset the analog/digital circuit when releasing PLL global power down or releasing PLL clock comparator power down.
 *     PLL_ARESET       PLL analog resetSoftware must reset the analog/digital circuit when releasing PLL global power down or releasing PLL clock comparator power down.
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_CTRLr 0x000000dc

#define BCM89500_A0_PLL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PLL_CTRL.
 *
 */
typedef union BCM89500_A0_PLL_CTRLr_s {
	uint32_t v[1];
	uint32_t pll_ctrl[1];
	uint32_t _pll_ctrl;
} BCM89500_A0_PLL_CTRLr_t;

#define BCM89500_A0_PLL_CTRLr_CLR(r) (r).pll_ctrl[0] = 0
#define BCM89500_A0_PLL_CTRLr_SET(r,d) (r).pll_ctrl[0] = d
#define BCM89500_A0_PLL_CTRLr_GET(r) (r).pll_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_CTRLr_PLL_LP_CTRLf_GET(r) (((r).pll_ctrl[0]) & 0x1f)
#define BCM89500_A0_PLL_CTRLr_PLL_LP_CTRLf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_PLL_CTRLr_RESERVEDf_GET(r) ((((r).pll_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_PLL_CTRLr_RESERVEDf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_PLL_CTRLr_PLL_DRESETf_GET(r) ((((r).pll_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_PLL_CTRLr_PLL_DRESETf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_PLL_CTRLr_PLL_ARESETf_GET(r) ((((r).pll_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_PLL_CTRLr_PLL_ARESETf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_CTRL.
 *
 */
#define BCM89500_A0_READ_PLL_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_CTRLr,(r._pll_ctrl),1)
#define BCM89500_A0_WRITE_PLL_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_CTRLr,&(r._pll_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRLr BCM89500_A0_PLL_CTRLr
#define PLL_CTRLr_SIZE BCM89500_A0_PLL_CTRLr_SIZE
typedef BCM89500_A0_PLL_CTRLr_t PLL_CTRLr_t;
#define PLL_CTRLr_CLR BCM89500_A0_PLL_CTRLr_CLR
#define PLL_CTRLr_SET BCM89500_A0_PLL_CTRLr_SET
#define PLL_CTRLr_GET BCM89500_A0_PLL_CTRLr_GET
#define PLL_CTRLr_PLL_LP_CTRLf_GET BCM89500_A0_PLL_CTRLr_PLL_LP_CTRLf_GET
#define PLL_CTRLr_PLL_LP_CTRLf_SET BCM89500_A0_PLL_CTRLr_PLL_LP_CTRLf_SET
#define PLL_CTRLr_RESERVEDf_GET BCM89500_A0_PLL_CTRLr_RESERVEDf_GET
#define PLL_CTRLr_RESERVEDf_SET BCM89500_A0_PLL_CTRLr_RESERVEDf_SET
#define PLL_CTRLr_PLL_DRESETf_GET BCM89500_A0_PLL_CTRLr_PLL_DRESETf_GET
#define PLL_CTRLr_PLL_DRESETf_SET BCM89500_A0_PLL_CTRLr_PLL_DRESETf_SET
#define PLL_CTRLr_PLL_ARESETf_GET BCM89500_A0_PLL_CTRLr_PLL_ARESETf_GET
#define PLL_CTRLr_PLL_ARESETf_SET BCM89500_A0_PLL_CTRLr_PLL_ARESETf_SET
#define READ_PLL_CTRLr BCM89500_A0_READ_PLL_CTRLr
#define WRITE_PLL_CTRLr BCM89500_A0_WRITE_PLL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_DELOCK_MIB
 * BLOCKS:   SYS
 * DESC:     PLL Delock MIB Counter Register(Not2Release)(polar feature)
 * SIZE:     32
 * FIELDS:
 *     SW_PLL_DELOCK_MIB MIB counter for Switch PLL delock. The counter starts counting when PLL_MIB_EN is set, otherwise this field contains 0. The counter saturates at 0xffff.
 *     SOC_PLL_DELOCK_MIB MIB counter for SoC PLL delock. The counter starts counting when PLL_MIB_EN is set, otherwise this field contains 0. The counter saturates at 0xffff.
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_DELOCK_MIBr 0x000000b6

#define BCM89500_A0_PLL_DELOCK_MIBr_SIZE 4

/*
 * This structure should be used to declare and program PLL_DELOCK_MIB.
 *
 */
typedef union BCM89500_A0_PLL_DELOCK_MIBr_s {
	uint32_t v[1];
	uint32_t pll_delock_mib[1];
	uint32_t _pll_delock_mib;
} BCM89500_A0_PLL_DELOCK_MIBr_t;

#define BCM89500_A0_PLL_DELOCK_MIBr_CLR(r) (r).pll_delock_mib[0] = 0
#define BCM89500_A0_PLL_DELOCK_MIBr_SET(r,d) (r).pll_delock_mib[0] = d
#define BCM89500_A0_PLL_DELOCK_MIBr_GET(r) (r).pll_delock_mib[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_DELOCK_MIBr_SW_PLL_DELOCK_MIBf_GET(r) (((r).pll_delock_mib[0]) & 0xffff)
#define BCM89500_A0_PLL_DELOCK_MIBr_SW_PLL_DELOCK_MIBf_SET(r,f) (r).pll_delock_mib[0]=(((r).pll_delock_mib[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM89500_A0_PLL_DELOCK_MIBr_SOC_PLL_DELOCK_MIBf_GET(r) ((((r).pll_delock_mib[0]) >> 16) & 0xffff)
#define BCM89500_A0_PLL_DELOCK_MIBr_SOC_PLL_DELOCK_MIBf_SET(r,f) (r).pll_delock_mib[0]=(((r).pll_delock_mib[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access PLL_DELOCK_MIB.
 *
 */
#define BCM89500_A0_READ_PLL_DELOCK_MIBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_DELOCK_MIBr,(r._pll_delock_mib),4)
#define BCM89500_A0_WRITE_PLL_DELOCK_MIBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_DELOCK_MIBr,&(r._pll_delock_mib),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_DELOCK_MIBr BCM89500_A0_PLL_DELOCK_MIBr
#define PLL_DELOCK_MIBr_SIZE BCM89500_A0_PLL_DELOCK_MIBr_SIZE
typedef BCM89500_A0_PLL_DELOCK_MIBr_t PLL_DELOCK_MIBr_t;
#define PLL_DELOCK_MIBr_CLR BCM89500_A0_PLL_DELOCK_MIBr_CLR
#define PLL_DELOCK_MIBr_SET BCM89500_A0_PLL_DELOCK_MIBr_SET
#define PLL_DELOCK_MIBr_GET BCM89500_A0_PLL_DELOCK_MIBr_GET
#define PLL_DELOCK_MIBr_SW_PLL_DELOCK_MIBf_GET BCM89500_A0_PLL_DELOCK_MIBr_SW_PLL_DELOCK_MIBf_GET
#define PLL_DELOCK_MIBr_SW_PLL_DELOCK_MIBf_SET BCM89500_A0_PLL_DELOCK_MIBr_SW_PLL_DELOCK_MIBf_SET
#define PLL_DELOCK_MIBr_SOC_PLL_DELOCK_MIBf_GET BCM89500_A0_PLL_DELOCK_MIBr_SOC_PLL_DELOCK_MIBf_GET
#define PLL_DELOCK_MIBr_SOC_PLL_DELOCK_MIBf_SET BCM89500_A0_PLL_DELOCK_MIBr_SOC_PLL_DELOCK_MIBf_SET
#define READ_PLL_DELOCK_MIBr BCM89500_A0_READ_PLL_DELOCK_MIBr
#define WRITE_PLL_DELOCK_MIBr BCM89500_A0_WRITE_PLL_DELOCK_MIBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_DELOCK_MIBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_FREQ_SEL
 * BLOCKS:   SYS
 * DESC:     PLL System Clock Frequency Selector Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     CLKSET_KEY1      This field must be written with 0x68
 *     CLKSET_KEY2      This field must be written with 0xEA
 *     CLKSET_MDIV      Writting this field changes PLL channel 2's clock frequency for system clock, Valid when bit 32 is set to 1.The frequence is determined by this formula.F=VCO/CLKSET_MDIV, where VCO is fixed to 1Ghz, the divider should be larger than or equal to 9(decimal).
 *     RESERVED         Reserved, must be written with all zeros.
 *     CLKSET_RST       Setting this bit to 1'b1 triggers a reset on PLL. Valid, when bit 31 is set to 1. Once the PLL reset is triggered, it requires 500us for PLL to lock. To modify system clock at run time a reset to PLL is not required.
 *     CLKSET_SPI       Setting this bit to 1 enables frequency control of PLL channel 2(system clock).Note: This register is effective only full 32-bit is written. The followings are for polar configuration,111Mhz : 32'hC0_09_EA_68100Mhz : 32'hC0_0A_EA_68(Default)90Mhz : 32'hC0_0B_EA_6883.33Mhz : 32'hC0_0C_EA_68(bit30, CLKSET_RST is optional)
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_FREQ_SELr 0x000000d8

#define BCM89500_A0_PLL_FREQ_SELr_SIZE 4

/*
 * This structure should be used to declare and program PLL_FREQ_SEL.
 *
 */
typedef union BCM89500_A0_PLL_FREQ_SELr_s {
	uint32_t v[1];
	uint32_t pll_freq_sel[1];
	uint32_t _pll_freq_sel;
} BCM89500_A0_PLL_FREQ_SELr_t;

#define BCM89500_A0_PLL_FREQ_SELr_CLR(r) (r).pll_freq_sel[0] = 0
#define BCM89500_A0_PLL_FREQ_SELr_SET(r,d) (r).pll_freq_sel[0] = d
#define BCM89500_A0_PLL_FREQ_SELr_GET(r) (r).pll_freq_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY1f_GET(r) (((r).pll_freq_sel[0]) & 0xff)
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY1f_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY2f_GET(r) ((((r).pll_freq_sel[0]) >> 8) & 0xff)
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY2f_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_MDIVf_GET(r) ((((r).pll_freq_sel[0]) >> 16) & 0xff)
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_MDIVf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_PLL_FREQ_SELr_RESERVEDf_GET(r) ((((r).pll_freq_sel[0]) >> 24) & 0x3f)
#define BCM89500_A0_PLL_FREQ_SELr_RESERVEDf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_RSTf_GET(r) ((((r).pll_freq_sel[0]) >> 30) & 0x1)
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_RSTf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_SPIf_GET(r) ((((r).pll_freq_sel[0]) >> 31) & 0x1)
#define BCM89500_A0_PLL_FREQ_SELr_CLKSET_SPIf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PLL_FREQ_SEL.
 *
 */
#define BCM89500_A0_READ_PLL_FREQ_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_FREQ_SELr,(r._pll_freq_sel),4)
#define BCM89500_A0_WRITE_PLL_FREQ_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_FREQ_SELr,&(r._pll_freq_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_FREQ_SELr BCM89500_A0_PLL_FREQ_SELr
#define PLL_FREQ_SELr_SIZE BCM89500_A0_PLL_FREQ_SELr_SIZE
typedef BCM89500_A0_PLL_FREQ_SELr_t PLL_FREQ_SELr_t;
#define PLL_FREQ_SELr_CLR BCM89500_A0_PLL_FREQ_SELr_CLR
#define PLL_FREQ_SELr_SET BCM89500_A0_PLL_FREQ_SELr_SET
#define PLL_FREQ_SELr_GET BCM89500_A0_PLL_FREQ_SELr_GET
#define PLL_FREQ_SELr_CLKSET_KEY1f_GET BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY1f_GET
#define PLL_FREQ_SELr_CLKSET_KEY1f_SET BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY1f_SET
#define PLL_FREQ_SELr_CLKSET_KEY2f_GET BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY2f_GET
#define PLL_FREQ_SELr_CLKSET_KEY2f_SET BCM89500_A0_PLL_FREQ_SELr_CLKSET_KEY2f_SET
#define PLL_FREQ_SELr_CLKSET_MDIVf_GET BCM89500_A0_PLL_FREQ_SELr_CLKSET_MDIVf_GET
#define PLL_FREQ_SELr_CLKSET_MDIVf_SET BCM89500_A0_PLL_FREQ_SELr_CLKSET_MDIVf_SET
#define PLL_FREQ_SELr_RESERVEDf_GET BCM89500_A0_PLL_FREQ_SELr_RESERVEDf_GET
#define PLL_FREQ_SELr_RESERVEDf_SET BCM89500_A0_PLL_FREQ_SELr_RESERVEDf_SET
#define PLL_FREQ_SELr_CLKSET_RSTf_GET BCM89500_A0_PLL_FREQ_SELr_CLKSET_RSTf_GET
#define PLL_FREQ_SELr_CLKSET_RSTf_SET BCM89500_A0_PLL_FREQ_SELr_CLKSET_RSTf_SET
#define PLL_FREQ_SELr_CLKSET_SPIf_GET BCM89500_A0_PLL_FREQ_SELr_CLKSET_SPIf_GET
#define PLL_FREQ_SELr_CLKSET_SPIf_SET BCM89500_A0_PLL_FREQ_SELr_CLKSET_SPIf_SET
#define READ_PLL_FREQ_SELr BCM89500_A0_READ_PLL_FREQ_SELr
#define WRITE_PLL_FREQ_SELr BCM89500_A0_WRITE_PLL_FREQ_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_FREQ_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_MISC_CTRL
 * BLOCKS:   SYS
 * DESC:     PLL MISC Control Register(Not2Release)(polar feature)
 * SIZE:     16
 * FIELDS:
 *     PLL_MIB_EN       MIB Counter enable for PLL delock.
 *     PLL_FORCE_LOCK   Set this bit to force PLL lock indication to clock switching function between reference clock and pll clock.
 *     PLL_INT_EN       Set this bit enables PLL lock change interrupt.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_MISC_CTRLr 0x000000b4

#define BCM89500_A0_PLL_MISC_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program PLL_MISC_CTRL.
 *
 */
typedef union BCM89500_A0_PLL_MISC_CTRLr_s {
	uint32_t v[1];
	uint32_t pll_misc_ctrl[1];
	uint32_t _pll_misc_ctrl;
} BCM89500_A0_PLL_MISC_CTRLr_t;

#define BCM89500_A0_PLL_MISC_CTRLr_CLR(r) (r).pll_misc_ctrl[0] = 0
#define BCM89500_A0_PLL_MISC_CTRLr_SET(r,d) (r).pll_misc_ctrl[0] = d
#define BCM89500_A0_PLL_MISC_CTRLr_GET(r) (r).pll_misc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_MISC_CTRLr_PLL_MIB_ENf_GET(r) (((r).pll_misc_ctrl[0]) & 0x1)
#define BCM89500_A0_PLL_MISC_CTRLr_PLL_MIB_ENf_SET(r,f) (r).pll_misc_ctrl[0]=(((r).pll_misc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PLL_MISC_CTRLr_PLL_FORCE_LOCKf_GET(r) ((((r).pll_misc_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_PLL_MISC_CTRLr_PLL_FORCE_LOCKf_SET(r,f) (r).pll_misc_ctrl[0]=(((r).pll_misc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_PLL_MISC_CTRLr_PLL_INT_ENf_GET(r) ((((r).pll_misc_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_PLL_MISC_CTRLr_PLL_INT_ENf_SET(r,f) (r).pll_misc_ctrl[0]=(((r).pll_misc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_PLL_MISC_CTRLr_RESERVEDf_GET(r) ((((r).pll_misc_ctrl[0]) >> 3) & 0x1fff)
#define BCM89500_A0_PLL_MISC_CTRLr_RESERVEDf_SET(r,f) (r).pll_misc_ctrl[0]=(((r).pll_misc_ctrl[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access PLL_MISC_CTRL.
 *
 */
#define BCM89500_A0_READ_PLL_MISC_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_MISC_CTRLr,(r._pll_misc_ctrl),2)
#define BCM89500_A0_WRITE_PLL_MISC_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_MISC_CTRLr,&(r._pll_misc_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_MISC_CTRLr BCM89500_A0_PLL_MISC_CTRLr
#define PLL_MISC_CTRLr_SIZE BCM89500_A0_PLL_MISC_CTRLr_SIZE
typedef BCM89500_A0_PLL_MISC_CTRLr_t PLL_MISC_CTRLr_t;
#define PLL_MISC_CTRLr_CLR BCM89500_A0_PLL_MISC_CTRLr_CLR
#define PLL_MISC_CTRLr_SET BCM89500_A0_PLL_MISC_CTRLr_SET
#define PLL_MISC_CTRLr_GET BCM89500_A0_PLL_MISC_CTRLr_GET
#define PLL_MISC_CTRLr_PLL_MIB_ENf_GET BCM89500_A0_PLL_MISC_CTRLr_PLL_MIB_ENf_GET
#define PLL_MISC_CTRLr_PLL_MIB_ENf_SET BCM89500_A0_PLL_MISC_CTRLr_PLL_MIB_ENf_SET
#define PLL_MISC_CTRLr_PLL_FORCE_LOCKf_GET BCM89500_A0_PLL_MISC_CTRLr_PLL_FORCE_LOCKf_GET
#define PLL_MISC_CTRLr_PLL_FORCE_LOCKf_SET BCM89500_A0_PLL_MISC_CTRLr_PLL_FORCE_LOCKf_SET
#define PLL_MISC_CTRLr_PLL_INT_ENf_GET BCM89500_A0_PLL_MISC_CTRLr_PLL_INT_ENf_GET
#define PLL_MISC_CTRLr_PLL_INT_ENf_SET BCM89500_A0_PLL_MISC_CTRLr_PLL_INT_ENf_SET
#define PLL_MISC_CTRLr_RESERVEDf_GET BCM89500_A0_PLL_MISC_CTRLr_RESERVEDf_GET
#define PLL_MISC_CTRLr_RESERVEDf_SET BCM89500_A0_PLL_MISC_CTRLr_RESERVEDf_SET
#define READ_PLL_MISC_CTRLr BCM89500_A0_READ_PLL_MISC_CTRLr
#define WRITE_PLL_MISC_CTRLr BCM89500_A0_WRITE_PLL_MISC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_MISC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_MOD_CTRL_0
 * BLOCKS:   SYS
 * DESC:     PLL Modulator Control Register(Not2Release)(polar feature)
 * SIZE:     32
 * FIELDS:
 *     SS_TIME          Modulation time per step for up/down-spread.
 *     SS_OPT           Modulation Option          o 00: down-spread (default)          o 01: up-spread          o 1x: center-spread
 *     SS_EN            PLL Modulator Enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_MOD_CTRL_0r 0x000000a8

#define BCM89500_A0_PLL_MOD_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_MOD_CTRL_0.
 *
 */
typedef union BCM89500_A0_PLL_MOD_CTRL_0r_s {
	uint32_t v[1];
	uint32_t pll_mod_ctrl_0[1];
	uint32_t _pll_mod_ctrl_0;
} BCM89500_A0_PLL_MOD_CTRL_0r_t;

#define BCM89500_A0_PLL_MOD_CTRL_0r_CLR(r) (r).pll_mod_ctrl_0[0] = 0
#define BCM89500_A0_PLL_MOD_CTRL_0r_SET(r,d) (r).pll_mod_ctrl_0[0] = d
#define BCM89500_A0_PLL_MOD_CTRL_0r_GET(r) (r).pll_mod_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_MOD_CTRL_0r_SS_TIMEf_GET(r) (((r).pll_mod_ctrl_0[0]) & 0xffff)
#define BCM89500_A0_PLL_MOD_CTRL_0r_SS_TIMEf_SET(r,f) (r).pll_mod_ctrl_0[0]=(((r).pll_mod_ctrl_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM89500_A0_PLL_MOD_CTRL_0r_SS_OPTf_GET(r) ((((r).pll_mod_ctrl_0[0]) >> 16) & 0x3)
#define BCM89500_A0_PLL_MOD_CTRL_0r_SS_OPTf_SET(r,f) (r).pll_mod_ctrl_0[0]=(((r).pll_mod_ctrl_0[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM89500_A0_PLL_MOD_CTRL_0r_SS_ENf_GET(r) ((((r).pll_mod_ctrl_0[0]) >> 18) & 0x1)
#define BCM89500_A0_PLL_MOD_CTRL_0r_SS_ENf_SET(r,f) (r).pll_mod_ctrl_0[0]=(((r).pll_mod_ctrl_0[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM89500_A0_PLL_MOD_CTRL_0r_RESERVEDf_GET(r) ((((r).pll_mod_ctrl_0[0]) >> 19) & 0x1fff)
#define BCM89500_A0_PLL_MOD_CTRL_0r_RESERVEDf_SET(r,f) (r).pll_mod_ctrl_0[0]=(((r).pll_mod_ctrl_0[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access PLL_MOD_CTRL_0.
 *
 */
#define BCM89500_A0_READ_PLL_MOD_CTRL_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_MOD_CTRL_0r,(r._pll_mod_ctrl_0),4)
#define BCM89500_A0_WRITE_PLL_MOD_CTRL_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_MOD_CTRL_0r,&(r._pll_mod_ctrl_0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_MOD_CTRL_0r BCM89500_A0_PLL_MOD_CTRL_0r
#define PLL_MOD_CTRL_0r_SIZE BCM89500_A0_PLL_MOD_CTRL_0r_SIZE
typedef BCM89500_A0_PLL_MOD_CTRL_0r_t PLL_MOD_CTRL_0r_t;
#define PLL_MOD_CTRL_0r_CLR BCM89500_A0_PLL_MOD_CTRL_0r_CLR
#define PLL_MOD_CTRL_0r_SET BCM89500_A0_PLL_MOD_CTRL_0r_SET
#define PLL_MOD_CTRL_0r_GET BCM89500_A0_PLL_MOD_CTRL_0r_GET
#define PLL_MOD_CTRL_0r_SS_TIMEf_GET BCM89500_A0_PLL_MOD_CTRL_0r_SS_TIMEf_GET
#define PLL_MOD_CTRL_0r_SS_TIMEf_SET BCM89500_A0_PLL_MOD_CTRL_0r_SS_TIMEf_SET
#define PLL_MOD_CTRL_0r_SS_OPTf_GET BCM89500_A0_PLL_MOD_CTRL_0r_SS_OPTf_GET
#define PLL_MOD_CTRL_0r_SS_OPTf_SET BCM89500_A0_PLL_MOD_CTRL_0r_SS_OPTf_SET
#define PLL_MOD_CTRL_0r_SS_ENf_GET BCM89500_A0_PLL_MOD_CTRL_0r_SS_ENf_GET
#define PLL_MOD_CTRL_0r_SS_ENf_SET BCM89500_A0_PLL_MOD_CTRL_0r_SS_ENf_SET
#define PLL_MOD_CTRL_0r_RESERVEDf_GET BCM89500_A0_PLL_MOD_CTRL_0r_RESERVEDf_GET
#define PLL_MOD_CTRL_0r_RESERVEDf_SET BCM89500_A0_PLL_MOD_CTRL_0r_RESERVEDf_SET
#define READ_PLL_MOD_CTRL_0r BCM89500_A0_READ_PLL_MOD_CTRL_0r
#define WRITE_PLL_MOD_CTRL_0r BCM89500_A0_WRITE_PLL_MOD_CTRL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_MOD_CTRL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_MOD_CTRL_1
 * BLOCKS:   SYS
 * DESC:     PLL Modulator Control for Up/Down-Spread Register(Not2Release)(polar feature)
 * SIZE:     32
 * FIELDS:
 *     SS_AMPLITUDE     Modulation amplitude.
 *     SS_SCALE         Modulation Scale.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_MOD_CTRL_1r 0x000000ac

#define BCM89500_A0_PLL_MOD_CTRL_1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_MOD_CTRL_1.
 *
 */
typedef union BCM89500_A0_PLL_MOD_CTRL_1r_s {
	uint32_t v[1];
	uint32_t pll_mod_ctrl_1[1];
	uint32_t _pll_mod_ctrl_1;
} BCM89500_A0_PLL_MOD_CTRL_1r_t;

#define BCM89500_A0_PLL_MOD_CTRL_1r_CLR(r) (r).pll_mod_ctrl_1[0] = 0
#define BCM89500_A0_PLL_MOD_CTRL_1r_SET(r,d) (r).pll_mod_ctrl_1[0] = d
#define BCM89500_A0_PLL_MOD_CTRL_1r_GET(r) (r).pll_mod_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_MOD_CTRL_1r_SS_AMPLITUDEf_GET(r) (((r).pll_mod_ctrl_1[0]) & 0xffffff)
#define BCM89500_A0_PLL_MOD_CTRL_1r_SS_AMPLITUDEf_SET(r,f) (r).pll_mod_ctrl_1[0]=(((r).pll_mod_ctrl_1[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM89500_A0_PLL_MOD_CTRL_1r_SS_SCALEf_GET(r) ((((r).pll_mod_ctrl_1[0]) >> 24) & 0x1f)
#define BCM89500_A0_PLL_MOD_CTRL_1r_SS_SCALEf_SET(r,f) (r).pll_mod_ctrl_1[0]=(((r).pll_mod_ctrl_1[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM89500_A0_PLL_MOD_CTRL_1r_RESERVEDf_GET(r) ((((r).pll_mod_ctrl_1[0]) >> 29) & 0x7)
#define BCM89500_A0_PLL_MOD_CTRL_1r_RESERVEDf_SET(r,f) (r).pll_mod_ctrl_1[0]=(((r).pll_mod_ctrl_1[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access PLL_MOD_CTRL_1.
 *
 */
#define BCM89500_A0_READ_PLL_MOD_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_MOD_CTRL_1r,(r._pll_mod_ctrl_1),4)
#define BCM89500_A0_WRITE_PLL_MOD_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_MOD_CTRL_1r,&(r._pll_mod_ctrl_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_MOD_CTRL_1r BCM89500_A0_PLL_MOD_CTRL_1r
#define PLL_MOD_CTRL_1r_SIZE BCM89500_A0_PLL_MOD_CTRL_1r_SIZE
typedef BCM89500_A0_PLL_MOD_CTRL_1r_t PLL_MOD_CTRL_1r_t;
#define PLL_MOD_CTRL_1r_CLR BCM89500_A0_PLL_MOD_CTRL_1r_CLR
#define PLL_MOD_CTRL_1r_SET BCM89500_A0_PLL_MOD_CTRL_1r_SET
#define PLL_MOD_CTRL_1r_GET BCM89500_A0_PLL_MOD_CTRL_1r_GET
#define PLL_MOD_CTRL_1r_SS_AMPLITUDEf_GET BCM89500_A0_PLL_MOD_CTRL_1r_SS_AMPLITUDEf_GET
#define PLL_MOD_CTRL_1r_SS_AMPLITUDEf_SET BCM89500_A0_PLL_MOD_CTRL_1r_SS_AMPLITUDEf_SET
#define PLL_MOD_CTRL_1r_SS_SCALEf_GET BCM89500_A0_PLL_MOD_CTRL_1r_SS_SCALEf_GET
#define PLL_MOD_CTRL_1r_SS_SCALEf_SET BCM89500_A0_PLL_MOD_CTRL_1r_SS_SCALEf_SET
#define PLL_MOD_CTRL_1r_RESERVEDf_GET BCM89500_A0_PLL_MOD_CTRL_1r_RESERVEDf_GET
#define PLL_MOD_CTRL_1r_RESERVEDf_SET BCM89500_A0_PLL_MOD_CTRL_1r_RESERVEDf_SET
#define READ_PLL_MOD_CTRL_1r BCM89500_A0_READ_PLL_MOD_CTRL_1r
#define WRITE_PLL_MOD_CTRL_1r BCM89500_A0_WRITE_PLL_MOD_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_MOD_CTRL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_MOD_CTRL_2
 * BLOCKS:   SYS
 * DESC:     PLL Modulator Control for Center-Spread Register(Not2Release)(polar feature)
 * SIZE:     32
 * FIELDS:
 *     SS_STEP          Modulation step.
 *     SS_RNG           Modulation range.
 *     SS_SCALE         Modulation Scale.
 *     SS_HOLD          Modulation hold time for a scale.
 *     SS_LOAD          Modulation Parameter load/reload.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_MOD_CTRL_2r 0x000000b0

#define BCM89500_A0_PLL_MOD_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_MOD_CTRL_2.
 *
 */
typedef union BCM89500_A0_PLL_MOD_CTRL_2r_s {
	uint32_t v[1];
	uint32_t pll_mod_ctrl_2[1];
	uint32_t _pll_mod_ctrl_2;
} BCM89500_A0_PLL_MOD_CTRL_2r_t;

#define BCM89500_A0_PLL_MOD_CTRL_2r_CLR(r) (r).pll_mod_ctrl_2[0] = 0
#define BCM89500_A0_PLL_MOD_CTRL_2r_SET(r,d) (r).pll_mod_ctrl_2[0] = d
#define BCM89500_A0_PLL_MOD_CTRL_2r_GET(r) (r).pll_mod_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_STEPf_GET(r) (((r).pll_mod_ctrl_2[0]) & 0xff)
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_STEPf_SET(r,f) (r).pll_mod_ctrl_2[0]=(((r).pll_mod_ctrl_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_RNGf_GET(r) ((((r).pll_mod_ctrl_2[0]) >> 8) & 0x3f)
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_RNGf_SET(r,f) (r).pll_mod_ctrl_2[0]=(((r).pll_mod_ctrl_2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_SCALEf_GET(r) ((((r).pll_mod_ctrl_2[0]) >> 14) & 0x7)
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_SCALEf_SET(r,f) (r).pll_mod_ctrl_2[0]=(((r).pll_mod_ctrl_2[0] & ~((uint32_t)0x7 << 14)) | ((((uint32_t)f) & 0x7) << 14))
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_HOLDf_GET(r) ((((r).pll_mod_ctrl_2[0]) >> 17) & 0x3)
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_HOLDf_SET(r,f) (r).pll_mod_ctrl_2[0]=(((r).pll_mod_ctrl_2[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_LOADf_GET(r) ((((r).pll_mod_ctrl_2[0]) >> 19) & 0x1)
#define BCM89500_A0_PLL_MOD_CTRL_2r_SS_LOADf_SET(r,f) (r).pll_mod_ctrl_2[0]=(((r).pll_mod_ctrl_2[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM89500_A0_PLL_MOD_CTRL_2r_RESERVEDf_GET(r) ((((r).pll_mod_ctrl_2[0]) >> 20) & 0xfff)
#define BCM89500_A0_PLL_MOD_CTRL_2r_RESERVEDf_SET(r,f) (r).pll_mod_ctrl_2[0]=(((r).pll_mod_ctrl_2[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access PLL_MOD_CTRL_2.
 *
 */
#define BCM89500_A0_READ_PLL_MOD_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_MOD_CTRL_2r,(r._pll_mod_ctrl_2),4)
#define BCM89500_A0_WRITE_PLL_MOD_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_MOD_CTRL_2r,&(r._pll_mod_ctrl_2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_MOD_CTRL_2r BCM89500_A0_PLL_MOD_CTRL_2r
#define PLL_MOD_CTRL_2r_SIZE BCM89500_A0_PLL_MOD_CTRL_2r_SIZE
typedef BCM89500_A0_PLL_MOD_CTRL_2r_t PLL_MOD_CTRL_2r_t;
#define PLL_MOD_CTRL_2r_CLR BCM89500_A0_PLL_MOD_CTRL_2r_CLR
#define PLL_MOD_CTRL_2r_SET BCM89500_A0_PLL_MOD_CTRL_2r_SET
#define PLL_MOD_CTRL_2r_GET BCM89500_A0_PLL_MOD_CTRL_2r_GET
#define PLL_MOD_CTRL_2r_SS_STEPf_GET BCM89500_A0_PLL_MOD_CTRL_2r_SS_STEPf_GET
#define PLL_MOD_CTRL_2r_SS_STEPf_SET BCM89500_A0_PLL_MOD_CTRL_2r_SS_STEPf_SET
#define PLL_MOD_CTRL_2r_SS_RNGf_GET BCM89500_A0_PLL_MOD_CTRL_2r_SS_RNGf_GET
#define PLL_MOD_CTRL_2r_SS_RNGf_SET BCM89500_A0_PLL_MOD_CTRL_2r_SS_RNGf_SET
#define PLL_MOD_CTRL_2r_SS_SCALEf_GET BCM89500_A0_PLL_MOD_CTRL_2r_SS_SCALEf_GET
#define PLL_MOD_CTRL_2r_SS_SCALEf_SET BCM89500_A0_PLL_MOD_CTRL_2r_SS_SCALEf_SET
#define PLL_MOD_CTRL_2r_SS_HOLDf_GET BCM89500_A0_PLL_MOD_CTRL_2r_SS_HOLDf_GET
#define PLL_MOD_CTRL_2r_SS_HOLDf_SET BCM89500_A0_PLL_MOD_CTRL_2r_SS_HOLDf_SET
#define PLL_MOD_CTRL_2r_SS_LOADf_GET BCM89500_A0_PLL_MOD_CTRL_2r_SS_LOADf_GET
#define PLL_MOD_CTRL_2r_SS_LOADf_SET BCM89500_A0_PLL_MOD_CTRL_2r_SS_LOADf_SET
#define PLL_MOD_CTRL_2r_RESERVEDf_GET BCM89500_A0_PLL_MOD_CTRL_2r_RESERVEDf_GET
#define PLL_MOD_CTRL_2r_RESERVEDf_SET BCM89500_A0_PLL_MOD_CTRL_2r_RESERVEDf_SET
#define READ_PLL_MOD_CTRL_2r BCM89500_A0_READ_PLL_MOD_CTRL_2r
#define WRITE_PLL_MOD_CTRL_2r BCM89500_A0_WRITE_PLL_MOD_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_MOD_CTRL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_NDIV_FRAC
 * BLOCKS:   SYS
 * DESC:     PLL Feedback Divider Fractional Control Register(Not2Release)(polar feature)
 * SIZE:     32
 * FIELDS:
 *     PLL_NDIV_FRAC    Fractional part of PLL feedback divider (i_ndiv_frac[23:0])
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_NDIV_FRACr 0x000000a2

#define BCM89500_A0_PLL_NDIV_FRACr_SIZE 4

/*
 * This structure should be used to declare and program PLL_NDIV_FRAC.
 *
 */
typedef union BCM89500_A0_PLL_NDIV_FRACr_s {
	uint32_t v[1];
	uint32_t pll_ndiv_frac[1];
	uint32_t _pll_ndiv_frac;
} BCM89500_A0_PLL_NDIV_FRACr_t;

#define BCM89500_A0_PLL_NDIV_FRACr_CLR(r) (r).pll_ndiv_frac[0] = 0
#define BCM89500_A0_PLL_NDIV_FRACr_SET(r,d) (r).pll_ndiv_frac[0] = d
#define BCM89500_A0_PLL_NDIV_FRACr_GET(r) (r).pll_ndiv_frac[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_NDIV_FRACr_PLL_NDIV_FRACf_GET(r) (((r).pll_ndiv_frac[0]) & 0xffffff)
#define BCM89500_A0_PLL_NDIV_FRACr_PLL_NDIV_FRACf_SET(r,f) (r).pll_ndiv_frac[0]=(((r).pll_ndiv_frac[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM89500_A0_PLL_NDIV_FRACr_RESERVEDf_GET(r) ((((r).pll_ndiv_frac[0]) >> 24) & 0xff)
#define BCM89500_A0_PLL_NDIV_FRACr_RESERVEDf_SET(r,f) (r).pll_ndiv_frac[0]=(((r).pll_ndiv_frac[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PLL_NDIV_FRAC.
 *
 */
#define BCM89500_A0_READ_PLL_NDIV_FRACr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_NDIV_FRACr,(r._pll_ndiv_frac),4)
#define BCM89500_A0_WRITE_PLL_NDIV_FRACr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_NDIV_FRACr,&(r._pll_ndiv_frac),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_NDIV_FRACr BCM89500_A0_PLL_NDIV_FRACr
#define PLL_NDIV_FRACr_SIZE BCM89500_A0_PLL_NDIV_FRACr_SIZE
typedef BCM89500_A0_PLL_NDIV_FRACr_t PLL_NDIV_FRACr_t;
#define PLL_NDIV_FRACr_CLR BCM89500_A0_PLL_NDIV_FRACr_CLR
#define PLL_NDIV_FRACr_SET BCM89500_A0_PLL_NDIV_FRACr_SET
#define PLL_NDIV_FRACr_GET BCM89500_A0_PLL_NDIV_FRACr_GET
#define PLL_NDIV_FRACr_PLL_NDIV_FRACf_GET BCM89500_A0_PLL_NDIV_FRACr_PLL_NDIV_FRACf_GET
#define PLL_NDIV_FRACr_PLL_NDIV_FRACf_SET BCM89500_A0_PLL_NDIV_FRACr_PLL_NDIV_FRACf_SET
#define PLL_NDIV_FRACr_RESERVEDf_GET BCM89500_A0_PLL_NDIV_FRACr_RESERVEDf_GET
#define PLL_NDIV_FRACr_RESERVEDf_SET BCM89500_A0_PLL_NDIV_FRACr_RESERVEDf_SET
#define READ_PLL_NDIV_FRACr BCM89500_A0_READ_PLL_NDIV_FRACr
#define WRITE_PLL_NDIV_FRACr BCM89500_A0_WRITE_PLL_NDIV_FRACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_NDIV_FRACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_NDIV_INT
 * BLOCKS:   SYS
 * DESC:     PLL Feedback Divider Integer Control Register(Not2Release)(polar feature)
 * SIZE:     16
 * FIELDS:
 *     PLL_NDIV_INT     Integer part of PLL feedback divider (i_ndiv_int[8:0])
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_NDIV_INTr 0x000000a0

#define BCM89500_A0_PLL_NDIV_INTr_SIZE 2

/*
 * This structure should be used to declare and program PLL_NDIV_INT.
 *
 */
typedef union BCM89500_A0_PLL_NDIV_INTr_s {
	uint32_t v[1];
	uint32_t pll_ndiv_int[1];
	uint32_t _pll_ndiv_int;
} BCM89500_A0_PLL_NDIV_INTr_t;

#define BCM89500_A0_PLL_NDIV_INTr_CLR(r) (r).pll_ndiv_int[0] = 0
#define BCM89500_A0_PLL_NDIV_INTr_SET(r,d) (r).pll_ndiv_int[0] = d
#define BCM89500_A0_PLL_NDIV_INTr_GET(r) (r).pll_ndiv_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_NDIV_INTr_PLL_NDIV_INTf_GET(r) (((r).pll_ndiv_int[0]) & 0x1ff)
#define BCM89500_A0_PLL_NDIV_INTr_PLL_NDIV_INTf_SET(r,f) (r).pll_ndiv_int[0]=(((r).pll_ndiv_int[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PLL_NDIV_INTr_RESERVEDf_GET(r) ((((r).pll_ndiv_int[0]) >> 9) & 0x7f)
#define BCM89500_A0_PLL_NDIV_INTr_RESERVEDf_SET(r,f) (r).pll_ndiv_int[0]=(((r).pll_ndiv_int[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PLL_NDIV_INT.
 *
 */
#define BCM89500_A0_READ_PLL_NDIV_INTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_NDIV_INTr,(r._pll_ndiv_int),2)
#define BCM89500_A0_WRITE_PLL_NDIV_INTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_NDIV_INTr,&(r._pll_ndiv_int),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_NDIV_INTr BCM89500_A0_PLL_NDIV_INTr
#define PLL_NDIV_INTr_SIZE BCM89500_A0_PLL_NDIV_INTr_SIZE
typedef BCM89500_A0_PLL_NDIV_INTr_t PLL_NDIV_INTr_t;
#define PLL_NDIV_INTr_CLR BCM89500_A0_PLL_NDIV_INTr_CLR
#define PLL_NDIV_INTr_SET BCM89500_A0_PLL_NDIV_INTr_SET
#define PLL_NDIV_INTr_GET BCM89500_A0_PLL_NDIV_INTr_GET
#define PLL_NDIV_INTr_PLL_NDIV_INTf_GET BCM89500_A0_PLL_NDIV_INTr_PLL_NDIV_INTf_GET
#define PLL_NDIV_INTr_PLL_NDIV_INTf_SET BCM89500_A0_PLL_NDIV_INTr_PLL_NDIV_INTf_SET
#define PLL_NDIV_INTr_RESERVEDf_GET BCM89500_A0_PLL_NDIV_INTr_RESERVEDf_GET
#define PLL_NDIV_INTr_RESERVEDf_SET BCM89500_A0_PLL_NDIV_INTr_RESERVEDf_SET
#define READ_PLL_NDIV_INTr BCM89500_A0_READ_PLL_NDIV_INTr
#define WRITE_PLL_NDIV_INTr BCM89500_A0_WRITE_PLL_NDIV_INTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_NDIV_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_SDMOD_CTRL
 * BLOCKS:   SYS
 * DESC:     PLL SDMOD Control Register(Not2Release)(polar feature)
 * SIZE:     16
 * FIELDS:
 *     PLL_NDIV_DITHER_MFB Feedback Divider Modulator Dithering Mode (i_ndiv_dither_mfb)
 *     PLL_NDIV_MODE    Feedback Divider Mode Control (i_ndiv_mode[2:0])
 *     PLL_NDIV_PWRDN   Feedback Divider Power Down (i_ndiv_pwrdn)
 *     PLL_BYP_SDMOD    Feedback Divider Modulator Bypass (i_byp_SDMOD)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_SDMOD_CTRLr 0x000000a6

#define BCM89500_A0_PLL_SDMOD_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program PLL_SDMOD_CTRL.
 *
 */
typedef union BCM89500_A0_PLL_SDMOD_CTRLr_s {
	uint32_t v[1];
	uint32_t pll_sdmod_ctrl[1];
	uint32_t _pll_sdmod_ctrl;
} BCM89500_A0_PLL_SDMOD_CTRLr_t;

#define BCM89500_A0_PLL_SDMOD_CTRLr_CLR(r) (r).pll_sdmod_ctrl[0] = 0
#define BCM89500_A0_PLL_SDMOD_CTRLr_SET(r,d) (r).pll_sdmod_ctrl[0] = d
#define BCM89500_A0_PLL_SDMOD_CTRLr_GET(r) (r).pll_sdmod_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_DITHER_MFBf_GET(r) (((r).pll_sdmod_ctrl[0]) & 0x1)
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_DITHER_MFBf_SET(r,f) (r).pll_sdmod_ctrl[0]=(((r).pll_sdmod_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_MODEf_GET(r) ((((r).pll_sdmod_ctrl[0]) >> 1) & 0x7)
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_MODEf_SET(r,f) (r).pll_sdmod_ctrl[0]=(((r).pll_sdmod_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_PWRDNf_GET(r) ((((r).pll_sdmod_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_PWRDNf_SET(r,f) (r).pll_sdmod_ctrl[0]=(((r).pll_sdmod_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_BYP_SDMODf_GET(r) ((((r).pll_sdmod_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_PLL_SDMOD_CTRLr_PLL_BYP_SDMODf_SET(r,f) (r).pll_sdmod_ctrl[0]=(((r).pll_sdmod_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_PLL_SDMOD_CTRLr_RESERVEDf_GET(r) ((((r).pll_sdmod_ctrl[0]) >> 6) & 0x3ff)
#define BCM89500_A0_PLL_SDMOD_CTRLr_RESERVEDf_SET(r,f) (r).pll_sdmod_ctrl[0]=(((r).pll_sdmod_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access PLL_SDMOD_CTRL.
 *
 */
#define BCM89500_A0_READ_PLL_SDMOD_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_SDMOD_CTRLr,(r._pll_sdmod_ctrl),2)
#define BCM89500_A0_WRITE_PLL_SDMOD_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_SDMOD_CTRLr,&(r._pll_sdmod_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_SDMOD_CTRLr BCM89500_A0_PLL_SDMOD_CTRLr
#define PLL_SDMOD_CTRLr_SIZE BCM89500_A0_PLL_SDMOD_CTRLr_SIZE
typedef BCM89500_A0_PLL_SDMOD_CTRLr_t PLL_SDMOD_CTRLr_t;
#define PLL_SDMOD_CTRLr_CLR BCM89500_A0_PLL_SDMOD_CTRLr_CLR
#define PLL_SDMOD_CTRLr_SET BCM89500_A0_PLL_SDMOD_CTRLr_SET
#define PLL_SDMOD_CTRLr_GET BCM89500_A0_PLL_SDMOD_CTRLr_GET
#define PLL_SDMOD_CTRLr_PLL_NDIV_DITHER_MFBf_GET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_DITHER_MFBf_GET
#define PLL_SDMOD_CTRLr_PLL_NDIV_DITHER_MFBf_SET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_DITHER_MFBf_SET
#define PLL_SDMOD_CTRLr_PLL_NDIV_MODEf_GET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_MODEf_GET
#define PLL_SDMOD_CTRLr_PLL_NDIV_MODEf_SET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_MODEf_SET
#define PLL_SDMOD_CTRLr_PLL_NDIV_PWRDNf_GET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_PWRDNf_GET
#define PLL_SDMOD_CTRLr_PLL_NDIV_PWRDNf_SET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_NDIV_PWRDNf_SET
#define PLL_SDMOD_CTRLr_PLL_BYP_SDMODf_GET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_BYP_SDMODf_GET
#define PLL_SDMOD_CTRLr_PLL_BYP_SDMODf_SET BCM89500_A0_PLL_SDMOD_CTRLr_PLL_BYP_SDMODf_SET
#define PLL_SDMOD_CTRLr_RESERVEDf_GET BCM89500_A0_PLL_SDMOD_CTRLr_RESERVEDf_GET
#define PLL_SDMOD_CTRLr_RESERVEDf_SET BCM89500_A0_PLL_SDMOD_CTRLr_RESERVEDf_SET
#define READ_PLL_SDMOD_CTRLr BCM89500_A0_READ_PLL_SDMOD_CTRLr
#define WRITE_PLL_SDMOD_CTRLr BCM89500_A0_WRITE_PLL_SDMOD_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_SDMOD_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_STS
 * BLOCKS:   SYS
 * DESC:     PLL Status Register
 * SIZE:     8
 * FIELDS:
 *     PLL_LOCK         This bit indicates switch PLL's lock status1=locked0=unlocked
 *     Q_BRPHY_PLL_LOCK (Not2Release)Port 0-3 Quad BR-PHY's PLL status1=locked0=unlocked
 *     S_BRPHY_PLL_LOCK (Not2Release)Port 4 Single BR-PHY's PLL status1=locked0=unlocked
 *     SD_PLL_LOCK      (Not2Release)Port 5 SerDes's PLL status1=locked0=unlocked
 *     RESERVED         RESERVED
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_STSr 0x000000dd

#define BCM89500_A0_PLL_STSr_SIZE 1

/*
 * This structure should be used to declare and program PLL_STS.
 *
 */
typedef union BCM89500_A0_PLL_STSr_s {
	uint32_t v[1];
	uint32_t pll_sts[1];
	uint32_t _pll_sts;
} BCM89500_A0_PLL_STSr_t;

#define BCM89500_A0_PLL_STSr_CLR(r) (r).pll_sts[0] = 0
#define BCM89500_A0_PLL_STSr_SET(r,d) (r).pll_sts[0] = d
#define BCM89500_A0_PLL_STSr_GET(r) (r).pll_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_STSr_PLL_LOCKf_GET(r) (((r).pll_sts[0]) & 0x1)
#define BCM89500_A0_PLL_STSr_PLL_LOCKf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PLL_STSr_Q_BRPHY_PLL_LOCKf_GET(r) ((((r).pll_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_PLL_STSr_Q_BRPHY_PLL_LOCKf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_PLL_STSr_S_BRPHY_PLL_LOCKf_GET(r) ((((r).pll_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_PLL_STSr_S_BRPHY_PLL_LOCKf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_PLL_STSr_SD_PLL_LOCKf_GET(r) ((((r).pll_sts[0]) >> 3) & 0x1)
#define BCM89500_A0_PLL_STSr_SD_PLL_LOCKf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_PLL_STSr_RESERVEDf_GET(r) ((((r).pll_sts[0]) >> 4) & 0xf)
#define BCM89500_A0_PLL_STSr_RESERVEDf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PLL_STS.
 *
 */
#define BCM89500_A0_READ_PLL_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_STSr,(r._pll_sts),1)
#define BCM89500_A0_WRITE_PLL_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_STSr,&(r._pll_sts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_STSr BCM89500_A0_PLL_STSr
#define PLL_STSr_SIZE BCM89500_A0_PLL_STSr_SIZE
typedef BCM89500_A0_PLL_STSr_t PLL_STSr_t;
#define PLL_STSr_CLR BCM89500_A0_PLL_STSr_CLR
#define PLL_STSr_SET BCM89500_A0_PLL_STSr_SET
#define PLL_STSr_GET BCM89500_A0_PLL_STSr_GET
#define PLL_STSr_PLL_LOCKf_GET BCM89500_A0_PLL_STSr_PLL_LOCKf_GET
#define PLL_STSr_PLL_LOCKf_SET BCM89500_A0_PLL_STSr_PLL_LOCKf_SET
#define PLL_STSr_Q_BRPHY_PLL_LOCKf_GET BCM89500_A0_PLL_STSr_Q_BRPHY_PLL_LOCKf_GET
#define PLL_STSr_Q_BRPHY_PLL_LOCKf_SET BCM89500_A0_PLL_STSr_Q_BRPHY_PLL_LOCKf_SET
#define PLL_STSr_S_BRPHY_PLL_LOCKf_GET BCM89500_A0_PLL_STSr_S_BRPHY_PLL_LOCKf_GET
#define PLL_STSr_S_BRPHY_PLL_LOCKf_SET BCM89500_A0_PLL_STSr_S_BRPHY_PLL_LOCKf_SET
#define PLL_STSr_SD_PLL_LOCKf_GET BCM89500_A0_PLL_STSr_SD_PLL_LOCKf_GET
#define PLL_STSr_SD_PLL_LOCKf_SET BCM89500_A0_PLL_STSr_SD_PLL_LOCKf_SET
#define PLL_STSr_RESERVEDf_GET BCM89500_A0_PLL_STSr_RESERVEDf_GET
#define PLL_STSr_RESERVEDf_SET BCM89500_A0_PLL_STSr_RESERVEDf_SET
#define READ_PLL_STSr BCM89500_A0_READ_PLL_STSr
#define WRITE_PLL_STSr BCM89500_A0_WRITE_PLL_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_TEST_CTRL_I
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register I Registrer (Not2Release)(polar feature)
 * SIZE:     8
 * FIELDS:
 *     PLL_SW_RST       
 *     PLL_TEST_EN      
 *     PLL_TEST_SEL     
 *     PLL_VCO_RNG      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_TEST_CTRL_Ir 0x000000d0

#define BCM89500_A0_PLL_TEST_CTRL_Ir_SIZE 1

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_I.
 *
 */
typedef union BCM89500_A0_PLL_TEST_CTRL_Ir_s {
	uint32_t v[1];
	uint32_t pll_test_ctrl_i[1];
	uint32_t _pll_test_ctrl_i;
} BCM89500_A0_PLL_TEST_CTRL_Ir_t;

#define BCM89500_A0_PLL_TEST_CTRL_Ir_CLR(r) (r).pll_test_ctrl_i[0] = 0
#define BCM89500_A0_PLL_TEST_CTRL_Ir_SET(r,d) (r).pll_test_ctrl_i[0] = d
#define BCM89500_A0_PLL_TEST_CTRL_Ir_GET(r) (r).pll_test_ctrl_i[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET(r) (((r).pll_test_ctrl_i[0]) & 0x1)
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 1) & 0x1)
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 2) & 0x7)
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 5) & 0x3)
#define BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM89500_A0_PLL_TEST_CTRL_Ir_RESERVEDf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 7) & 0x1)
#define BCM89500_A0_PLL_TEST_CTRL_Ir_RESERVEDf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_TEST_CTRL_I.
 *
 */
#define BCM89500_A0_READ_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_TEST_CTRL_Ir,(r._pll_test_ctrl_i),1)
#define BCM89500_A0_WRITE_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_TEST_CTRL_Ir,&(r._pll_test_ctrl_i),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_Ir BCM89500_A0_PLL_TEST_CTRL_Ir
#define PLL_TEST_CTRL_Ir_SIZE BCM89500_A0_PLL_TEST_CTRL_Ir_SIZE
typedef BCM89500_A0_PLL_TEST_CTRL_Ir_t PLL_TEST_CTRL_Ir_t;
#define PLL_TEST_CTRL_Ir_CLR BCM89500_A0_PLL_TEST_CTRL_Ir_CLR
#define PLL_TEST_CTRL_Ir_SET BCM89500_A0_PLL_TEST_CTRL_Ir_SET
#define PLL_TEST_CTRL_Ir_GET BCM89500_A0_PLL_TEST_CTRL_Ir_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET BCM89500_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET
#define PLL_TEST_CTRL_Ir_RESERVEDf_GET BCM89500_A0_PLL_TEST_CTRL_Ir_RESERVEDf_GET
#define PLL_TEST_CTRL_Ir_RESERVEDf_SET BCM89500_A0_PLL_TEST_CTRL_Ir_RESERVEDf_SET
#define READ_PLL_TEST_CTRL_Ir BCM89500_A0_READ_PLL_TEST_CTRL_Ir
#define WRITE_PLL_TEST_CTRL_Ir BCM89500_A0_WRITE_PLL_TEST_CTRL_Ir

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_TEST_CTRL_Ir'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PLL_TEST_CTRL_II
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register II Registrer (Not2Release)(polar feature)
 * SIZE:     48
 * FIELDS:
 *     PLL_TEST_CTRL    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PLL_TEST_CTRL_IIr 0x000000d1

#define BCM89500_A0_PLL_TEST_CTRL_IIr_SIZE 6

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_II.
 *
 */
typedef union BCM89500_A0_PLL_TEST_CTRL_IIr_s {
	uint32_t v[2];
	uint32_t pll_test_ctrl_ii[2];
	uint32_t _pll_test_ctrl_ii;
} BCM89500_A0_PLL_TEST_CTRL_IIr_t;

#define BCM89500_A0_PLL_TEST_CTRL_IIr_CLR(r) CDK_MEMSET(&((r)._pll_test_ctrl_ii), 0, sizeof(BCM89500_A0_PLL_TEST_CTRL_IIr_t))
#define BCM89500_A0_PLL_TEST_CTRL_IIr_SET(r,i,d) (r).pll_test_ctrl_ii[i] = d
#define BCM89500_A0_PLL_TEST_CTRL_IIr_GET(r,i) (r).pll_test_ctrl_ii[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET(r,a) cdk_field_get((r).pll_test_ctrl_ii,0,37,a)
#define BCM89500_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET(r,a) cdk_field_set((r).pll_test_ctrl_ii,0,37,a)
#define BCM89500_A0_PLL_TEST_CTRL_IIr_RESERVEDf_GET(r) ((((r).pll_test_ctrl_ii[1]) >> 6) & 0x3ff)
#define BCM89500_A0_PLL_TEST_CTRL_IIr_RESERVEDf_SET(r,f) (r).pll_test_ctrl_ii[1]=(((r).pll_test_ctrl_ii[1] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access PLL_TEST_CTRL_II.
 *
 */
#define BCM89500_A0_READ_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PLL_TEST_CTRL_IIr,(r._pll_test_ctrl_ii),6)
#define BCM89500_A0_WRITE_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PLL_TEST_CTRL_IIr,&(r._pll_test_ctrl_ii),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_IIr BCM89500_A0_PLL_TEST_CTRL_IIr
#define PLL_TEST_CTRL_IIr_SIZE BCM89500_A0_PLL_TEST_CTRL_IIr_SIZE
typedef BCM89500_A0_PLL_TEST_CTRL_IIr_t PLL_TEST_CTRL_IIr_t;
#define PLL_TEST_CTRL_IIr_CLR BCM89500_A0_PLL_TEST_CTRL_IIr_CLR
#define PLL_TEST_CTRL_IIr_SET BCM89500_A0_PLL_TEST_CTRL_IIr_SET
#define PLL_TEST_CTRL_IIr_GET BCM89500_A0_PLL_TEST_CTRL_IIr_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET BCM89500_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET BCM89500_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET
#define PLL_TEST_CTRL_IIr_RESERVEDf_GET BCM89500_A0_PLL_TEST_CTRL_IIr_RESERVEDf_GET
#define PLL_TEST_CTRL_IIr_RESERVEDf_SET BCM89500_A0_PLL_TEST_CTRL_IIr_RESERVEDf_SET
#define READ_PLL_TEST_CTRL_IIr BCM89500_A0_READ_PLL_TEST_CTRL_IIr
#define WRITE_PLL_TEST_CTRL_IIr BCM89500_A0_WRITE_PLL_TEST_CTRL_IIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PLL_TEST_CTRL_IIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_LEVEL1_QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Port N, First Level QOS Weight Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     Q0_WEIGHT        Queue 0 Weight.
 *     Q1_WEIGHT        Queue 1 Weight.
 *     Q2_WEIGHT        Queue 2 Weight.
 *     Q3_WEIGHT        Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program higher Queue with higher weight. And this field mustn't be programmed as zero.Queue 3 Weight.
 *
 ******************************************************************************/
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr 0x00003b10

#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_SIZE 4

/*
 * This structure should be used to declare and program PN_LEVEL1_QOS_WEIGHT.
 *
 */
typedef union BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t pn_level1_qos_weight[1];
	uint32_t _pn_level1_qos_weight;
} BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_t;

#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_CLR(r) (r).pn_level1_qos_weight[0] = 0
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_SET(r,d) (r).pn_level1_qos_weight[0] = d
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_GET(r) (r).pn_level1_qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET(r) (((r).pn_level1_qos_weight[0]) & 0xff)
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET(r,f) (r).pn_level1_qos_weight[0]=(((r).pn_level1_qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET(r) ((((r).pn_level1_qos_weight[0]) >> 8) & 0xff)
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET(r,f) (r).pn_level1_qos_weight[0]=(((r).pn_level1_qos_weight[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET(r) ((((r).pn_level1_qos_weight[0]) >> 16) & 0xff)
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET(r,f) (r).pn_level1_qos_weight[0]=(((r).pn_level1_qos_weight[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET(r) ((((r).pn_level1_qos_weight[0]) >> 24) & 0xff)
#define BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET(r,f) (r).pn_level1_qos_weight[0]=(((r).pn_level1_qos_weight[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PN_LEVEL1_QOS_WEIGHT.
 *
 */
#define BCM89500_A0_READ_PN_LEVEL1_QOS_WEIGHTr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr+(4*(i)),(r._pn_level1_qos_weight),4)
#define BCM89500_A0_WRITE_PN_LEVEL1_QOS_WEIGHTr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr+(4*(i)),&(r._pn_level1_qos_weight),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_LEVEL1_QOS_WEIGHTr BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr
#define PN_LEVEL1_QOS_WEIGHTr_SIZE BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_SIZE
typedef BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_t PN_LEVEL1_QOS_WEIGHTr_t;
#define PN_LEVEL1_QOS_WEIGHTr_CLR BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_CLR
#define PN_LEVEL1_QOS_WEIGHTr_SET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_SET
#define PN_LEVEL1_QOS_WEIGHTr_GET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_GET
#define PN_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_GET
#define PN_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q0_WEIGHTf_SET
#define PN_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_GET
#define PN_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q1_WEIGHTf_SET
#define PN_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_GET
#define PN_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q2_WEIGHTf_SET
#define PN_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_GET
#define PN_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr_Q3_WEIGHTf_SET
#define READ_PN_LEVEL1_QOS_WEIGHTr BCM89500_A0_READ_PN_LEVEL1_QOS_WEIGHTr
#define WRITE_PN_LEVEL1_QOS_WEIGHTr BCM89500_A0_WRITE_PN_LEVEL1_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_LEVEL1_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_LEVEL2_QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Port N, Second Level QOS Weight Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     LEVEL1_OUTPUT_WEIGHT Ouput of First Level QOS Weight.
 *     Q4_WEIGHT        Queue 4 Weight.
 *     Q5_WEIGHT        Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program higher Queue with higher weight. And this field mustn't be programmed as zero.Queue 5 Weight.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr 0x00003b40

#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_SIZE 4

/*
 * This structure should be used to declare and program PN_LEVEL2_QOS_WEIGHT.
 *
 */
typedef union BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t pn_level2_qos_weight[1];
	uint32_t _pn_level2_qos_weight;
} BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_t;

#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_CLR(r) (r).pn_level2_qos_weight[0] = 0
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_SET(r,d) (r).pn_level2_qos_weight[0] = d
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_GET(r) (r).pn_level2_qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET(r) (((r).pn_level2_qos_weight[0]) & 0xff)
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET(r,f) (r).pn_level2_qos_weight[0]=(((r).pn_level2_qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET(r) ((((r).pn_level2_qos_weight[0]) >> 8) & 0xff)
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET(r,f) (r).pn_level2_qos_weight[0]=(((r).pn_level2_qos_weight[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET(r) ((((r).pn_level2_qos_weight[0]) >> 16) & 0xff)
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET(r,f) (r).pn_level2_qos_weight[0]=(((r).pn_level2_qos_weight[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET(r) ((((r).pn_level2_qos_weight[0]) >> 24) & 0xff)
#define BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET(r,f) (r).pn_level2_qos_weight[0]=(((r).pn_level2_qos_weight[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PN_LEVEL2_QOS_WEIGHT.
 *
 */
#define BCM89500_A0_READ_PN_LEVEL2_QOS_WEIGHTr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr+(4*(i)),(r._pn_level2_qos_weight),4)
#define BCM89500_A0_WRITE_PN_LEVEL2_QOS_WEIGHTr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr+(4*(i)),&(r._pn_level2_qos_weight),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_LEVEL2_QOS_WEIGHTr BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr
#define PN_LEVEL2_QOS_WEIGHTr_SIZE BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_SIZE
typedef BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_t PN_LEVEL2_QOS_WEIGHTr_t;
#define PN_LEVEL2_QOS_WEIGHTr_CLR BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_CLR
#define PN_LEVEL2_QOS_WEIGHTr_SET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_SET
#define PN_LEVEL2_QOS_WEIGHTr_GET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_GET
#define PN_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_GET
#define PN_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_LEVEL1_OUTPUT_WEIGHTf_SET
#define PN_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_GET
#define PN_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q4_WEIGHTf_SET
#define PN_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_GET
#define PN_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_Q5_WEIGHTf_SET
#define PN_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_RESERVEDf_GET
#define PN_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr_RESERVEDf_SET
#define READ_PN_LEVEL2_QOS_WEIGHTr BCM89500_A0_READ_PN_LEVEL2_QOS_WEIGHTr
#define WRITE_PN_LEVEL2_QOS_WEIGHTr BCM89500_A0_WRITE_PN_LEVEL2_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_LEVEL2_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_LOW_QUEUE_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port N, Low Queue (Q0-Q3) Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr 0x00003800

#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program PN_LOW_QUEUE_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t pn_low_queue_max_refresh[1];
	uint32_t _pn_low_queue_max_refresh;
} BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_t;

#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_CLR(r) (r).pn_low_queue_max_refresh[0] = 0
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_SET(r,d) (r).pn_low_queue_max_refresh[0] = d
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_GET(r) (r).pn_low_queue_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).pn_low_queue_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).pn_low_queue_max_refresh[0]=(((r).pn_low_queue_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).pn_low_queue_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).pn_low_queue_max_refresh[0]=(((r).pn_low_queue_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PN_LOW_QUEUE_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_PN_LOW_QUEUE_MAX_REFRESHr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr+(4*(i)),(r._pn_low_queue_max_refresh),4)
#define BCM89500_A0_WRITE_PN_LOW_QUEUE_MAX_REFRESHr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr+(4*(i)),&(r._pn_low_queue_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr
#define PN_LOW_QUEUE_MAX_REFRESHr_SIZE BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_SIZE
typedef BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_t PN_LOW_QUEUE_MAX_REFRESHr_t;
#define PN_LOW_QUEUE_MAX_REFRESHr_CLR BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_CLR
#define PN_LOW_QUEUE_MAX_REFRESHr_SET BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_SET
#define PN_LOW_QUEUE_MAX_REFRESHr_GET BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_GET
#define PN_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_GET
#define PN_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_MAX_REFRESHf_SET
#define PN_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_GET
#define PN_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr_RESERVEDf_SET
#define READ_PN_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_READ_PN_LOW_QUEUE_MAX_REFRESHr
#define WRITE_PN_LOW_QUEUE_MAX_REFRESHr BCM89500_A0_WRITE_PN_LOW_QUEUE_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_LOW_QUEUE_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_LOW_QUEUE_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port N, Low Queue (Q0-Q3) Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr 0x00003830

#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program PN_LOW_QUEUE_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t pn_low_queue_max_thd_sel[1];
	uint32_t _pn_low_queue_max_thd_sel;
} BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_t;

#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_CLR(r) (r).pn_low_queue_max_thd_sel[0] = 0
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_SET(r,d) (r).pn_low_queue_max_thd_sel[0] = d
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_GET(r) (r).pn_low_queue_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).pn_low_queue_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).pn_low_queue_max_thd_sel[0]=(((r).pn_low_queue_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).pn_low_queue_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).pn_low_queue_max_thd_sel[0]=(((r).pn_low_queue_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PN_LOW_QUEUE_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_PN_LOW_QUEUE_MAX_THD_SELr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr+(4*(i)),(r._pn_low_queue_max_thd_sel),4)
#define BCM89500_A0_WRITE_PN_LOW_QUEUE_MAX_THD_SELr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr+(4*(i)),&(r._pn_low_queue_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr
#define PN_LOW_QUEUE_MAX_THD_SELr_SIZE BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_SIZE
typedef BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_t PN_LOW_QUEUE_MAX_THD_SELr_t;
#define PN_LOW_QUEUE_MAX_THD_SELr_CLR BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_CLR
#define PN_LOW_QUEUE_MAX_THD_SELr_SET BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_SET
#define PN_LOW_QUEUE_MAX_THD_SELr_GET BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_GET
#define PN_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_GET
#define PN_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_MAX_THD_SELf_SET
#define PN_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_GET
#define PN_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr_RESERVEDf_SET
#define READ_PN_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_READ_PN_LOW_QUEUE_MAX_THD_SELr
#define WRITE_PN_LOW_QUEUE_MAX_THD_SELr BCM89500_A0_WRITE_PN_LOW_QUEUE_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_LOW_QUEUE_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_LOW_QUEUE_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port N, Low Queue (Q0-Q3) Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr 0x00003860

#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program PN_LOW_QUEUE_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t pn_low_queue_shaper_sts[1];
	uint32_t _pn_low_queue_shaper_sts;
} BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_t;

#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_CLR(r) (r).pn_low_queue_shaper_sts[0] = 0
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_SET(r,d) (r).pn_low_queue_shaper_sts[0] = d
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_GET(r) (r).pn_low_queue_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).pn_low_queue_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).pn_low_queue_shaper_sts[0]=(((r).pn_low_queue_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET(r) ((((r).pn_low_queue_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET(r,f) (r).pn_low_queue_shaper_sts[0]=(((r).pn_low_queue_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).pn_low_queue_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).pn_low_queue_shaper_sts[0]=(((r).pn_low_queue_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PN_LOW_QUEUE_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_PN_LOW_QUEUE_SHAPER_STSr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr+(4*(i)),(r._pn_low_queue_shaper_sts),4)
#define BCM89500_A0_WRITE_PN_LOW_QUEUE_SHAPER_STSr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr+(4*(i)),&(r._pn_low_queue_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_LOW_QUEUE_SHAPER_STSr BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr
#define PN_LOW_QUEUE_SHAPER_STSr_SIZE BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_SIZE
typedef BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_t PN_LOW_QUEUE_SHAPER_STSr_t;
#define PN_LOW_QUEUE_SHAPER_STSr_CLR BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_CLR
#define PN_LOW_QUEUE_SHAPER_STSr_SET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_SET
#define PN_LOW_QUEUE_SHAPER_STSr_GET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_GET
#define PN_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_GET
#define PN_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_BUCKET_CNTf_SET
#define PN_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_RESERVEDf_GET
#define PN_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_RESERVEDf_SET
#define PN_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define PN_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_PN_LOW_QUEUE_SHAPER_STSr BCM89500_A0_READ_PN_LOW_QUEUE_SHAPER_STSr
#define WRITE_PN_LOW_QUEUE_SHAPER_STSr BCM89500_A0_WRITE_PN_LOW_QUEUE_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_LOW_QUEUE_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_PCP2TC
 * BLOCKS:   GPIC0
 * DESC:     Port N PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_PCP2TCr 0x00003010

#define BCM89500_A0_PN_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program PN_PCP2TC.
 *
 */
typedef union BCM89500_A0_PN_PCP2TCr_s {
	uint32_t v[1];
	uint32_t pn_pcp2tc[1];
	uint32_t _pn_pcp2tc;
} BCM89500_A0_PN_PCP2TCr_t;

#define BCM89500_A0_PN_PCP2TCr_CLR(r) (r).pn_pcp2tc[0] = 0
#define BCM89500_A0_PN_PCP2TCr_SET(r,d) (r).pn_pcp2tc[0] = d
#define BCM89500_A0_PN_PCP2TCr_GET(r) (r).pn_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).pn_pcp2tc[0]) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 3) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 6) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 9) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 12) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 15) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 18) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 21) & 0x7)
#define BCM89500_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_PN_PCP2TCr_RESERVEDf_GET(r) ((((r).pn_pcp2tc[0]) >> 24) & 0xff)
#define BCM89500_A0_PN_PCP2TCr_RESERVEDf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PN_PCP2TC.
 *
 */
#define BCM89500_A0_READ_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PN_PCP2TCr,(r._pn_pcp2tc),4)
#define BCM89500_A0_WRITE_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PN_PCP2TCr,&(r._pn_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_PCP2TCr BCM89500_A0_PN_PCP2TCr
#define PN_PCP2TCr_SIZE BCM89500_A0_PN_PCP2TCr_SIZE
typedef BCM89500_A0_PN_PCP2TCr_t PN_PCP2TCr_t;
#define PN_PCP2TCr_CLR BCM89500_A0_PN_PCP2TCr_CLR
#define PN_PCP2TCr_SET BCM89500_A0_PN_PCP2TCr_SET
#define PN_PCP2TCr_GET BCM89500_A0_PN_PCP2TCr_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET
#define PN_PCP2TCr_TAG001_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET
#define PN_PCP2TCr_TAG001_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET
#define PN_PCP2TCr_TAG010_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET
#define PN_PCP2TCr_TAG010_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET
#define PN_PCP2TCr_TAG011_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET
#define PN_PCP2TCr_TAG011_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET
#define PN_PCP2TCr_TAG100_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET
#define PN_PCP2TCr_TAG100_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET
#define PN_PCP2TCr_TAG101_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET
#define PN_PCP2TCr_TAG101_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET
#define PN_PCP2TCr_TAG110_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET
#define PN_PCP2TCr_TAG110_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET
#define PN_PCP2TCr_TAG111_PRI_MAPf_GET BCM89500_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET
#define PN_PCP2TCr_TAG111_PRI_MAPf_SET BCM89500_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET
#define PN_PCP2TCr_RESERVEDf_GET BCM89500_A0_PN_PCP2TCr_RESERVEDf_GET
#define PN_PCP2TCr_RESERVEDf_SET BCM89500_A0_PN_PCP2TCr_RESERVEDf_SET
#define READ_PN_PCP2TCr BCM89500_A0_READ_PN_PCP2TCr
#define WRITE_PN_PCP2TCr BCM89500_A0_WRITE_PN_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QOS_PRI_CTL
 * BLOCKS:   SYS
 * DESC:     Port N, QOS Priority Control Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     LEVEL1_QOS_PRI_CTL First level QoS priority for Q0 to Q32'b00: for Q0 - 3 are WRR2'b01: for COS3 (SP) and COS2-COS0 (WRR)2'b10: for COS3 (SP), COS2 (SP) and COS1-COS0 (WRR)2'b11: for COS3-COS0 (SP)
 *     LEVEL2_QOS_PRI_CTL Second level QoS priority for Queue 4, Queue 5, and the output of LEVEL1_QOS_PRI2'b00: for COS5, COS4 and the output of LEVEL1_QOS_PRI are WRR2'b01: for COS5 (SP), COS4 and the output of LEVEL1_QOS_PRI (WRR)2'b10: for COS5 (SP), COS4 (SP) and the output of LEVEL1_QOS_PRI (SP)2'b11: for Reserve
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QOS_PRI_CTLr 0x00003b00

#define BCM89500_A0_PN_QOS_PRI_CTLr_SIZE 1

/*
 * This structure should be used to declare and program PN_QOS_PRI_CTL.
 *
 */
typedef union BCM89500_A0_PN_QOS_PRI_CTLr_s {
	uint32_t v[1];
	uint32_t pn_qos_pri_ctl[1];
	uint32_t _pn_qos_pri_ctl;
} BCM89500_A0_PN_QOS_PRI_CTLr_t;

#define BCM89500_A0_PN_QOS_PRI_CTLr_CLR(r) (r).pn_qos_pri_ctl[0] = 0
#define BCM89500_A0_PN_QOS_PRI_CTLr_SET(r,d) (r).pn_qos_pri_ctl[0] = d
#define BCM89500_A0_PN_QOS_PRI_CTLr_GET(r) (r).pn_qos_pri_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET(r) (((r).pn_qos_pri_ctl[0]) & 0x3)
#define BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET(r,f) (r).pn_qos_pri_ctl[0]=(((r).pn_qos_pri_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET(r) ((((r).pn_qos_pri_ctl[0]) >> 2) & 0x3)
#define BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET(r,f) (r).pn_qos_pri_ctl[0]=(((r).pn_qos_pri_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_PN_QOS_PRI_CTLr_RESERVEDf_GET(r) ((((r).pn_qos_pri_ctl[0]) >> 4) & 0xf)
#define BCM89500_A0_PN_QOS_PRI_CTLr_RESERVEDf_SET(r,f) (r).pn_qos_pri_ctl[0]=(((r).pn_qos_pri_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PN_QOS_PRI_CTL.
 *
 */
#define BCM89500_A0_READ_PN_QOS_PRI_CTLr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QOS_PRI_CTLr+(1*(i)),(r._pn_qos_pri_ctl),1)
#define BCM89500_A0_WRITE_PN_QOS_PRI_CTLr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QOS_PRI_CTLr+(1*(i)),&(r._pn_qos_pri_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QOS_PRI_CTLr BCM89500_A0_PN_QOS_PRI_CTLr
#define PN_QOS_PRI_CTLr_SIZE BCM89500_A0_PN_QOS_PRI_CTLr_SIZE
typedef BCM89500_A0_PN_QOS_PRI_CTLr_t PN_QOS_PRI_CTLr_t;
#define PN_QOS_PRI_CTLr_CLR BCM89500_A0_PN_QOS_PRI_CTLr_CLR
#define PN_QOS_PRI_CTLr_SET BCM89500_A0_PN_QOS_PRI_CTLr_SET
#define PN_QOS_PRI_CTLr_GET BCM89500_A0_PN_QOS_PRI_CTLr_GET
#define PN_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_GET
#define PN_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL1_QOS_PRI_CTLf_SET
#define PN_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_GET
#define PN_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET BCM89500_A0_PN_QOS_PRI_CTLr_LEVEL2_QOS_PRI_CTLf_SET
#define PN_QOS_PRI_CTLr_RESERVEDf_GET BCM89500_A0_PN_QOS_PRI_CTLr_RESERVEDf_GET
#define PN_QOS_PRI_CTLr_RESERVEDf_SET BCM89500_A0_PN_QOS_PRI_CTLr_RESERVEDf_SET
#define READ_PN_QOS_PRI_CTLr BCM89500_A0_READ_PN_QOS_PRI_CTLr
#define WRITE_PN_QOS_PRI_CTLr BCM89500_A0_WRITE_PN_QOS_PRI_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QOS_PRI_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QUEUE4_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port N, Queue 4 Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr 0x00003900

#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program PN_QUEUE4_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t pn_queue4_max_refresh[1];
	uint32_t _pn_queue4_max_refresh;
} BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_t;

#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_CLR(r) (r).pn_queue4_max_refresh[0] = 0
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_SET(r,d) (r).pn_queue4_max_refresh[0] = d
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_GET(r) (r).pn_queue4_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).pn_queue4_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).pn_queue4_max_refresh[0]=(((r).pn_queue4_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).pn_queue4_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).pn_queue4_max_refresh[0]=(((r).pn_queue4_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PN_QUEUE4_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_PN_QUEUE4_MAX_REFRESHr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QUEUE4_MAX_REFRESHr+(4*(i)),(r._pn_queue4_max_refresh),4)
#define BCM89500_A0_WRITE_PN_QUEUE4_MAX_REFRESHr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QUEUE4_MAX_REFRESHr+(4*(i)),&(r._pn_queue4_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QUEUE4_MAX_REFRESHr BCM89500_A0_PN_QUEUE4_MAX_REFRESHr
#define PN_QUEUE4_MAX_REFRESHr_SIZE BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_SIZE
typedef BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_t PN_QUEUE4_MAX_REFRESHr_t;
#define PN_QUEUE4_MAX_REFRESHr_CLR BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_CLR
#define PN_QUEUE4_MAX_REFRESHr_SET BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_SET
#define PN_QUEUE4_MAX_REFRESHr_GET BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_GET
#define PN_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_GET
#define PN_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_MAX_REFRESHf_SET
#define PN_QUEUE4_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_RESERVEDf_GET
#define PN_QUEUE4_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_PN_QUEUE4_MAX_REFRESHr_RESERVEDf_SET
#define READ_PN_QUEUE4_MAX_REFRESHr BCM89500_A0_READ_PN_QUEUE4_MAX_REFRESHr
#define WRITE_PN_QUEUE4_MAX_REFRESHr BCM89500_A0_WRITE_PN_QUEUE4_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QUEUE4_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QUEUE4_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port N, Queue 4 Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr 0x00003930

#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program PN_QUEUE4_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t pn_queue4_max_thd_sel[1];
	uint32_t _pn_queue4_max_thd_sel;
} BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_t;

#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_CLR(r) (r).pn_queue4_max_thd_sel[0] = 0
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_SET(r,d) (r).pn_queue4_max_thd_sel[0] = d
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_GET(r) (r).pn_queue4_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).pn_queue4_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).pn_queue4_max_thd_sel[0]=(((r).pn_queue4_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).pn_queue4_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).pn_queue4_max_thd_sel[0]=(((r).pn_queue4_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PN_QUEUE4_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_PN_QUEUE4_MAX_THD_SELr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QUEUE4_MAX_THD_SELr+(4*(i)),(r._pn_queue4_max_thd_sel),4)
#define BCM89500_A0_WRITE_PN_QUEUE4_MAX_THD_SELr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QUEUE4_MAX_THD_SELr+(4*(i)),&(r._pn_queue4_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QUEUE4_MAX_THD_SELr BCM89500_A0_PN_QUEUE4_MAX_THD_SELr
#define PN_QUEUE4_MAX_THD_SELr_SIZE BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_SIZE
typedef BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_t PN_QUEUE4_MAX_THD_SELr_t;
#define PN_QUEUE4_MAX_THD_SELr_CLR BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_CLR
#define PN_QUEUE4_MAX_THD_SELr_SET BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_SET
#define PN_QUEUE4_MAX_THD_SELr_GET BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_GET
#define PN_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_GET
#define PN_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_MAX_THD_SELf_SET
#define PN_QUEUE4_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_RESERVEDf_GET
#define PN_QUEUE4_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_PN_QUEUE4_MAX_THD_SELr_RESERVEDf_SET
#define READ_PN_QUEUE4_MAX_THD_SELr BCM89500_A0_READ_PN_QUEUE4_MAX_THD_SELr
#define WRITE_PN_QUEUE4_MAX_THD_SELr BCM89500_A0_WRITE_PN_QUEUE4_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QUEUE4_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QUEUE4_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port N, Queue 4 Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr 0x00003960

#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program PN_QUEUE4_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_PN_QUEUE4_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t pn_queue4_shaper_sts[1];
	uint32_t _pn_queue4_shaper_sts;
} BCM89500_A0_PN_QUEUE4_SHAPER_STSr_t;

#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_CLR(r) (r).pn_queue4_shaper_sts[0] = 0
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_SET(r,d) (r).pn_queue4_shaper_sts[0] = d
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_GET(r) (r).pn_queue4_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).pn_queue4_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).pn_queue4_shaper_sts[0]=(((r).pn_queue4_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_RESERVEDf_GET(r) ((((r).pn_queue4_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_RESERVEDf_SET(r,f) (r).pn_queue4_shaper_sts[0]=(((r).pn_queue4_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).pn_queue4_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_PN_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).pn_queue4_shaper_sts[0]=(((r).pn_queue4_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PN_QUEUE4_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_PN_QUEUE4_SHAPER_STSr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QUEUE4_SHAPER_STSr+(4*(i)),(r._pn_queue4_shaper_sts),4)
#define BCM89500_A0_WRITE_PN_QUEUE4_SHAPER_STSr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QUEUE4_SHAPER_STSr+(4*(i)),&(r._pn_queue4_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QUEUE4_SHAPER_STSr BCM89500_A0_PN_QUEUE4_SHAPER_STSr
#define PN_QUEUE4_SHAPER_STSr_SIZE BCM89500_A0_PN_QUEUE4_SHAPER_STSr_SIZE
typedef BCM89500_A0_PN_QUEUE4_SHAPER_STSr_t PN_QUEUE4_SHAPER_STSr_t;
#define PN_QUEUE4_SHAPER_STSr_CLR BCM89500_A0_PN_QUEUE4_SHAPER_STSr_CLR
#define PN_QUEUE4_SHAPER_STSr_SET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_SET
#define PN_QUEUE4_SHAPER_STSr_GET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_GET
#define PN_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_BUCKET_CNTf_GET
#define PN_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_BUCKET_CNTf_SET
#define PN_QUEUE4_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_RESERVEDf_GET
#define PN_QUEUE4_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_RESERVEDf_SET
#define PN_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define PN_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_PN_QUEUE4_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_PN_QUEUE4_SHAPER_STSr BCM89500_A0_READ_PN_QUEUE4_SHAPER_STSr
#define WRITE_PN_QUEUE4_SHAPER_STSr BCM89500_A0_WRITE_PN_QUEUE4_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QUEUE4_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QUEUE5_MAX_REFRESH
 * BLOCKS:   SYS
 * DESC:     Port N, Queue 5 Shaping Rate Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_REFRESH      The number of tokens removed from the bucket in each refresh interval.The shaping rate is determined by  MAX_REFRESH * 0.5bit/7.8125us, (one token=0.5bit)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr 0x00003a00

#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_SIZE 4

/*
 * This structure should be used to declare and program PN_QUEUE5_MAX_REFRESH.
 *
 */
typedef union BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_s {
	uint32_t v[1];
	uint32_t pn_queue5_max_refresh[1];
	uint32_t _pn_queue5_max_refresh;
} BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_t;

#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_CLR(r) (r).pn_queue5_max_refresh[0] = 0
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_SET(r,d) (r).pn_queue5_max_refresh[0] = d
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_GET(r) (r).pn_queue5_max_refresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET(r) (((r).pn_queue5_max_refresh[0]) & 0x3ffff)
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET(r,f) (r).pn_queue5_max_refresh[0]=(((r).pn_queue5_max_refresh[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_RESERVEDf_GET(r) ((((r).pn_queue5_max_refresh[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_RESERVEDf_SET(r,f) (r).pn_queue5_max_refresh[0]=(((r).pn_queue5_max_refresh[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PN_QUEUE5_MAX_REFRESH.
 *
 */
#define BCM89500_A0_READ_PN_QUEUE5_MAX_REFRESHr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QUEUE5_MAX_REFRESHr+(4*(i)),(r._pn_queue5_max_refresh),4)
#define BCM89500_A0_WRITE_PN_QUEUE5_MAX_REFRESHr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QUEUE5_MAX_REFRESHr+(4*(i)),&(r._pn_queue5_max_refresh),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QUEUE5_MAX_REFRESHr BCM89500_A0_PN_QUEUE5_MAX_REFRESHr
#define PN_QUEUE5_MAX_REFRESHr_SIZE BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_SIZE
typedef BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_t PN_QUEUE5_MAX_REFRESHr_t;
#define PN_QUEUE5_MAX_REFRESHr_CLR BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_CLR
#define PN_QUEUE5_MAX_REFRESHr_SET BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_SET
#define PN_QUEUE5_MAX_REFRESHr_GET BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_GET
#define PN_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_GET
#define PN_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_MAX_REFRESHf_SET
#define PN_QUEUE5_MAX_REFRESHr_RESERVEDf_GET BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_RESERVEDf_GET
#define PN_QUEUE5_MAX_REFRESHr_RESERVEDf_SET BCM89500_A0_PN_QUEUE5_MAX_REFRESHr_RESERVEDf_SET
#define READ_PN_QUEUE5_MAX_REFRESHr BCM89500_A0_READ_PN_QUEUE5_MAX_REFRESHr
#define WRITE_PN_QUEUE5_MAX_REFRESHr BCM89500_A0_WRITE_PN_QUEUE5_MAX_REFRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QUEUE5_MAX_REFRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QUEUE5_MAX_THD_SEL
 * BLOCKS:   SYS
 * DESC:     Port N, Queue 5 Burst Size Configure Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Burst size of the meter.Burst size = MAX_THD_SEL * 64B
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr 0x00003a30

#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_SIZE 4

/*
 * This structure should be used to declare and program PN_QUEUE5_MAX_THD_SEL.
 *
 */
typedef union BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_s {
	uint32_t v[1];
	uint32_t pn_queue5_max_thd_sel[1];
	uint32_t _pn_queue5_max_thd_sel;
} BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_t;

#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_CLR(r) (r).pn_queue5_max_thd_sel[0] = 0
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_SET(r,d) (r).pn_queue5_max_thd_sel[0] = d
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_GET(r) (r).pn_queue5_max_thd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET(r) (((r).pn_queue5_max_thd_sel[0]) & 0x3ffff)
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET(r,f) (r).pn_queue5_max_thd_sel[0]=(((r).pn_queue5_max_thd_sel[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_RESERVEDf_GET(r) ((((r).pn_queue5_max_thd_sel[0]) >> 18) & 0x3fff)
#define BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_RESERVEDf_SET(r,f) (r).pn_queue5_max_thd_sel[0]=(((r).pn_queue5_max_thd_sel[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PN_QUEUE5_MAX_THD_SEL.
 *
 */
#define BCM89500_A0_READ_PN_QUEUE5_MAX_THD_SELr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QUEUE5_MAX_THD_SELr+(4*(i)),(r._pn_queue5_max_thd_sel),4)
#define BCM89500_A0_WRITE_PN_QUEUE5_MAX_THD_SELr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QUEUE5_MAX_THD_SELr+(4*(i)),&(r._pn_queue5_max_thd_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QUEUE5_MAX_THD_SELr BCM89500_A0_PN_QUEUE5_MAX_THD_SELr
#define PN_QUEUE5_MAX_THD_SELr_SIZE BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_SIZE
typedef BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_t PN_QUEUE5_MAX_THD_SELr_t;
#define PN_QUEUE5_MAX_THD_SELr_CLR BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_CLR
#define PN_QUEUE5_MAX_THD_SELr_SET BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_SET
#define PN_QUEUE5_MAX_THD_SELr_GET BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_GET
#define PN_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_GET
#define PN_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_MAX_THD_SELf_SET
#define PN_QUEUE5_MAX_THD_SELr_RESERVEDf_GET BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_RESERVEDf_GET
#define PN_QUEUE5_MAX_THD_SELr_RESERVEDf_SET BCM89500_A0_PN_QUEUE5_MAX_THD_SELr_RESERVEDf_SET
#define READ_PN_QUEUE5_MAX_THD_SELr BCM89500_A0_READ_PN_QUEUE5_MAX_THD_SELr
#define WRITE_PN_QUEUE5_MAX_THD_SELr BCM89500_A0_WRITE_PN_QUEUE5_MAX_THD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QUEUE5_MAX_THD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_QUEUE5_SHAPER_STS
 * BLOCKS:   SYS
 * DESC:     Port N, Queue 5 Shaper Status Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     BUCKET_CNT       Current count of the number of tokens in the bucket. Bit 28 is overflow bit.
 *     RESERVED         Reserved
 *     IN_PROFILE_FLAG  Indicates the current state of the maximum bandwidth shaper1: In profile0: Out-of-profile
 *
 ******************************************************************************/
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr 0x00003a60

#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_SIZE 4

/*
 * This structure should be used to declare and program PN_QUEUE5_SHAPER_STS.
 *
 */
typedef union BCM89500_A0_PN_QUEUE5_SHAPER_STSr_s {
	uint32_t v[1];
	uint32_t pn_queue5_shaper_sts[1];
	uint32_t _pn_queue5_shaper_sts;
} BCM89500_A0_PN_QUEUE5_SHAPER_STSr_t;

#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_CLR(r) (r).pn_queue5_shaper_sts[0] = 0
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_SET(r,d) (r).pn_queue5_shaper_sts[0] = d
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_GET(r) (r).pn_queue5_shaper_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET(r) (((r).pn_queue5_shaper_sts[0]) & 0x1fffffff)
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET(r,f) (r).pn_queue5_shaper_sts[0]=(((r).pn_queue5_shaper_sts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_RESERVEDf_GET(r) ((((r).pn_queue5_shaper_sts[0]) >> 29) & 0x3)
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_RESERVEDf_SET(r,f) (r).pn_queue5_shaper_sts[0]=(((r).pn_queue5_shaper_sts[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET(r) ((((r).pn_queue5_shaper_sts[0]) >> 31) & 0x1)
#define BCM89500_A0_PN_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET(r,f) (r).pn_queue5_shaper_sts[0]=(((r).pn_queue5_shaper_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PN_QUEUE5_SHAPER_STS.
 *
 */
#define BCM89500_A0_READ_PN_QUEUE5_SHAPER_STSr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_QUEUE5_SHAPER_STSr+(4*(i)),(r._pn_queue5_shaper_sts),4)
#define BCM89500_A0_WRITE_PN_QUEUE5_SHAPER_STSr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_QUEUE5_SHAPER_STSr+(4*(i)),&(r._pn_queue5_shaper_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_QUEUE5_SHAPER_STSr BCM89500_A0_PN_QUEUE5_SHAPER_STSr
#define PN_QUEUE5_SHAPER_STSr_SIZE BCM89500_A0_PN_QUEUE5_SHAPER_STSr_SIZE
typedef BCM89500_A0_PN_QUEUE5_SHAPER_STSr_t PN_QUEUE5_SHAPER_STSr_t;
#define PN_QUEUE5_SHAPER_STSr_CLR BCM89500_A0_PN_QUEUE5_SHAPER_STSr_CLR
#define PN_QUEUE5_SHAPER_STSr_SET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_SET
#define PN_QUEUE5_SHAPER_STSr_GET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_GET
#define PN_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_BUCKET_CNTf_GET
#define PN_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_BUCKET_CNTf_SET
#define PN_QUEUE5_SHAPER_STSr_RESERVEDf_GET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_RESERVEDf_GET
#define PN_QUEUE5_SHAPER_STSr_RESERVEDf_SET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_RESERVEDf_SET
#define PN_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_GET
#define PN_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET BCM89500_A0_PN_QUEUE5_SHAPER_STSr_IN_PROFILE_FLAGf_SET
#define READ_PN_QUEUE5_SHAPER_STSr BCM89500_A0_READ_PN_QUEUE5_SHAPER_STSr
#define WRITE_PN_QUEUE5_SHAPER_STSr BCM89500_A0_WRITE_PN_QUEUE5_SHAPER_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_QUEUE5_SHAPER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PN_TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     Port N TC to COS Mapping Register (polar feature)
 * SIZE:     32
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.
 *     PRT111_TO_QID    *** Note that ***Queue ID 0: 000Queue ID 1: 001Queue ID 2: 010Queue ID 3: 011Queue ID 4: 100Queue ID 5: 101Priority ID 111 mapped to TX Queue ID.
 *
 ******************************************************************************/
#define BCM89500_A0_PN_TC2COS_MAPr 0x00003070

#define BCM89500_A0_PN_TC2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PN_TC2COS_MAP.
 *
 */
typedef union BCM89500_A0_PN_TC2COS_MAPr_s {
	uint32_t v[1];
	uint32_t pn_tc2cos_map[1];
	uint32_t _pn_tc2cos_map;
} BCM89500_A0_PN_TC2COS_MAPr_t;

#define BCM89500_A0_PN_TC2COS_MAPr_CLR(r) (r).pn_tc2cos_map[0] = 0
#define BCM89500_A0_PN_TC2COS_MAPr_SET(r,d) (r).pn_tc2cos_map[0] = d
#define BCM89500_A0_PN_TC2COS_MAPr_GET(r) (r).pn_tc2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PN_TC2COS_MAPr_PRT000_TO_QIDf_GET(r) (((r).pn_tc2cos_map[0]) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT000_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT001_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 3) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT001_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT010_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 6) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT010_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT011_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 9) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT011_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT100_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 12) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT100_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT101_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 15) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT101_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT110_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 18) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT110_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_PN_TC2COS_MAPr_PRT111_TO_QIDf_GET(r) ((((r).pn_tc2cos_map[0]) >> 21) & 0x7)
#define BCM89500_A0_PN_TC2COS_MAPr_PRT111_TO_QIDf_SET(r,f) (r).pn_tc2cos_map[0]=(((r).pn_tc2cos_map[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access PN_TC2COS_MAP.
 *
 */
#define BCM89500_A0_READ_PN_TC2COS_MAPr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_PN_TC2COS_MAPr+(4*(i)),(r._pn_tc2cos_map),4)
#define BCM89500_A0_WRITE_PN_TC2COS_MAPr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_PN_TC2COS_MAPr+(4*(i)),&(r._pn_tc2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_TC2COS_MAPr BCM89500_A0_PN_TC2COS_MAPr
#define PN_TC2COS_MAPr_SIZE BCM89500_A0_PN_TC2COS_MAPr_SIZE
typedef BCM89500_A0_PN_TC2COS_MAPr_t PN_TC2COS_MAPr_t;
#define PN_TC2COS_MAPr_CLR BCM89500_A0_PN_TC2COS_MAPr_CLR
#define PN_TC2COS_MAPr_SET BCM89500_A0_PN_TC2COS_MAPr_SET
#define PN_TC2COS_MAPr_GET BCM89500_A0_PN_TC2COS_MAPr_GET
#define PN_TC2COS_MAPr_PRT000_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT000_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT000_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT000_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT001_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT001_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT001_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT001_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT010_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT010_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT010_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT010_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT011_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT011_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT011_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT011_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT100_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT100_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT100_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT100_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT101_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT101_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT101_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT101_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT110_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT110_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT110_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT110_TO_QIDf_SET
#define PN_TC2COS_MAPr_PRT111_TO_QIDf_GET BCM89500_A0_PN_TC2COS_MAPr_PRT111_TO_QIDf_GET
#define PN_TC2COS_MAPr_PRT111_TO_QIDf_SET BCM89500_A0_PN_TC2COS_MAPr_PRT111_TO_QIDf_SET
#define READ_PN_TC2COS_MAPr BCM89500_A0_READ_PN_TC2COS_MAPr
#define WRITE_PN_TC2COS_MAPr BCM89500_A0_WRITE_PN_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PN_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT4_RGMII_CTL_GP
 * BLOCKS:   SYS
 * DESC:     Port 4 RGMII Control register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     EN_RGMII_DLL_TXC 1: RGMII tx_clk delayed timing mode(Delay Mode)0: RGMII tx_clk aligned timing mode(Normal Mode)
 *     EN_RGMII_DLL_RXC 1: clock delay by DLL is enabled(Delay Mode)0: clock delay by DLL is disabled (Normal Mode)
 *     BYPASS_2NS_DEL   1: bypass dll65_2ns_del IP0: use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affected by bit[0] and bit[1]{Bit[2], Bit[0]}= 2'b10, Bypass tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b11, use tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b0X, use tx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b10, Bypass rx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b11, use rx side dll65_2ns_del IP{Bit[2], Bit[1}= 2'b0X, use rx side dll65_2ns_del IP(Not2Release)
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT4_RGMII_CTL_GPr 0x00000064

#define BCM89500_A0_PORT4_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program PORT4_RGMII_CTL_GP.
 *
 */
typedef union BCM89500_A0_PORT4_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t port4_rgmii_ctl_gp[1];
	uint32_t _port4_rgmii_ctl_gp;
} BCM89500_A0_PORT4_RGMII_CTL_GPr_t;

#define BCM89500_A0_PORT4_RGMII_CTL_GPr_CLR(r) (r).port4_rgmii_ctl_gp[0] = 0
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_SET(r,d) (r).port4_rgmii_ctl_gp[0] = d
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_GET(r) (r).port4_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET(r) (((r).port4_rgmii_ctl_gp[0]) & 0x1)
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET(r,f) (r).port4_rgmii_ctl_gp[0]=(((r).port4_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET(r) ((((r).port4_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET(r,f) (r).port4_rgmii_ctl_gp[0]=(((r).port4_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET(r) ((((r).port4_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET(r,f) (r).port4_rgmii_ctl_gp[0]=(((r).port4_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_0f_GET(r) ((((r).port4_rgmii_ctl_gp[0]) >> 3) & 0x1)
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_0f_SET(r,f) (r).port4_rgmii_ctl_gp[0]=(((r).port4_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_1f_GET(r) ((((r).port4_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_1f_SET(r,f) (r).port4_rgmii_ctl_gp[0]=(((r).port4_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PORT4_RGMII_CTL_GP.
 *
 */
#define BCM89500_A0_READ_PORT4_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT4_RGMII_CTL_GPr,(r._port4_rgmii_ctl_gp),1)
#define BCM89500_A0_WRITE_PORT4_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT4_RGMII_CTL_GPr,&(r._port4_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT4_RGMII_CTL_GPr BCM89500_A0_PORT4_RGMII_CTL_GPr
#define PORT4_RGMII_CTL_GPr_SIZE BCM89500_A0_PORT4_RGMII_CTL_GPr_SIZE
typedef BCM89500_A0_PORT4_RGMII_CTL_GPr_t PORT4_RGMII_CTL_GPr_t;
#define PORT4_RGMII_CTL_GPr_CLR BCM89500_A0_PORT4_RGMII_CTL_GPr_CLR
#define PORT4_RGMII_CTL_GPr_SET BCM89500_A0_PORT4_RGMII_CTL_GPr_SET
#define PORT4_RGMII_CTL_GPr_GET BCM89500_A0_PORT4_RGMII_CTL_GPr_GET
#define PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET
#define PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET
#define PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET
#define PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET BCM89500_A0_PORT4_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET
#define PORT4_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET BCM89500_A0_PORT4_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET
#define PORT4_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET BCM89500_A0_PORT4_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET
#define PORT4_RGMII_CTL_GPr_RESERVED_0f_GET BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_0f_GET
#define PORT4_RGMII_CTL_GPr_RESERVED_0f_SET BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_0f_SET
#define PORT4_RGMII_CTL_GPr_RESERVED_1f_GET BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_1f_GET
#define PORT4_RGMII_CTL_GPr_RESERVED_1f_SET BCM89500_A0_PORT4_RGMII_CTL_GPr_RESERVED_1f_SET
#define READ_PORT4_RGMII_CTL_GPr BCM89500_A0_READ_PORT4_RGMII_CTL_GPr
#define WRITE_PORT4_RGMII_CTL_GPr BCM89500_A0_WRITE_PORT4_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT4_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT5_RGMII_CTL_GP
 * BLOCKS:   SYS
 * DESC:     Port 5 RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     EN_RGMII_DLL_TXC 1: RGMII tx_clk delayed timing mode(Delay Mode)0: RGMII tx_clk aligned timing mode(Normal Mode)
 *     EN_RGMII_DLL_RXC 1: clock delay by DLL is enabled(Delay Mode)0: clock delay by DLL is disabled (Normal Mode)
 *     BYPASS_2NS_DEL   1: bypass dll65_2ns_del IP0: use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affected by bit[0] and bit[1]{Bit[2], Bit[0]}= 2'b10, Bypass tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b11, use tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b0X, use tx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b10, Bypass rx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b11, use rx side dll65_2ns_del IP{Bit[2], Bit[1}= 2'b0X, use rx side dll65_2ns_del IP(Not2Release)
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT5_RGMII_CTL_GPr 0x00000065

#define BCM89500_A0_PORT5_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program PORT5_RGMII_CTL_GP.
 *
 */
typedef union BCM89500_A0_PORT5_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t port5_rgmii_ctl_gp[1];
	uint32_t _port5_rgmii_ctl_gp;
} BCM89500_A0_PORT5_RGMII_CTL_GPr_t;

#define BCM89500_A0_PORT5_RGMII_CTL_GPr_CLR(r) (r).port5_rgmii_ctl_gp[0] = 0
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_SET(r,d) (r).port5_rgmii_ctl_gp[0] = d
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_GET(r) (r).port5_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET(r) (((r).port5_rgmii_ctl_gp[0]) & 0x1)
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_0f_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 3) & 0x1)
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_0f_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PORT5_RGMII_CTL_GP.
 *
 */
#define BCM89500_A0_READ_PORT5_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT5_RGMII_CTL_GPr,(r._port5_rgmii_ctl_gp),1)
#define BCM89500_A0_WRITE_PORT5_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT5_RGMII_CTL_GPr,&(r._port5_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT5_RGMII_CTL_GPr BCM89500_A0_PORT5_RGMII_CTL_GPr
#define PORT5_RGMII_CTL_GPr_SIZE BCM89500_A0_PORT5_RGMII_CTL_GPr_SIZE
typedef BCM89500_A0_PORT5_RGMII_CTL_GPr_t PORT5_RGMII_CTL_GPr_t;
#define PORT5_RGMII_CTL_GPr_CLR BCM89500_A0_PORT5_RGMII_CTL_GPr_CLR
#define PORT5_RGMII_CTL_GPr_SET BCM89500_A0_PORT5_RGMII_CTL_GPr_SET
#define PORT5_RGMII_CTL_GPr_GET BCM89500_A0_PORT5_RGMII_CTL_GPr_GET
#define PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_GET
#define PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_TXCf_SET
#define PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_GET
#define PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET BCM89500_A0_PORT5_RGMII_CTL_GPr_EN_RGMII_DLL_RXCf_SET
#define PORT5_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET BCM89500_A0_PORT5_RGMII_CTL_GPr_BYPASS_2NS_DELf_GET
#define PORT5_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET BCM89500_A0_PORT5_RGMII_CTL_GPr_BYPASS_2NS_DELf_SET
#define PORT5_RGMII_CTL_GPr_RESERVED_0f_GET BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_0f_GET
#define PORT5_RGMII_CTL_GPr_RESERVED_0f_SET BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_0f_SET
#define PORT5_RGMII_CTL_GPr_RESERVED_1f_GET BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_GET
#define PORT5_RGMII_CTL_GPr_RESERVED_1f_SET BCM89500_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_SET
#define READ_PORT5_RGMII_CTL_GPr BCM89500_A0_READ_PORT5_RGMII_CTL_GPr
#define WRITE_PORT5_RGMII_CTL_GPr BCM89500_A0_WRITE_PORT5_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT5_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT7_SLEEP_TIMER
 * BLOCKS:   SYS
 * DESC:     Port 7 Sleep Timer Register
 * SIZE:     16
 * FIELDS:
 *     PORT7_SLEEP_TIMER Port 7 Sleep Timer.The configuration value of port 7 sleep timer to indicate the desired sleep recovery time(i.e. wake-up time). When the timer is set by the CPU to a non-zero value. it puts the port 7 to sleep. The wake-up time is the set value decrease 1.The unit is 1 usec
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT7_SLEEP_TIMERr 0x00000312

#define BCM89500_A0_PORT7_SLEEP_TIMERr_SIZE 2

/*
 * This structure should be used to declare and program PORT7_SLEEP_TIMER.
 *
 */
typedef union BCM89500_A0_PORT7_SLEEP_TIMERr_s {
	uint32_t v[1];
	uint32_t port7_sleep_timer[1];
	uint32_t _port7_sleep_timer;
} BCM89500_A0_PORT7_SLEEP_TIMERr_t;

#define BCM89500_A0_PORT7_SLEEP_TIMERr_CLR(r) (r).port7_sleep_timer[0] = 0
#define BCM89500_A0_PORT7_SLEEP_TIMERr_SET(r,d) (r).port7_sleep_timer[0] = d
#define BCM89500_A0_PORT7_SLEEP_TIMERr_GET(r) (r).port7_sleep_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT7_SLEEP_TIMERr_PORT7_SLEEP_TIMERf_GET(r) (((r).port7_sleep_timer[0]) & 0x1fff)
#define BCM89500_A0_PORT7_SLEEP_TIMERr_PORT7_SLEEP_TIMERf_SET(r,f) (r).port7_sleep_timer[0]=(((r).port7_sleep_timer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM89500_A0_PORT7_SLEEP_TIMERr_RESERVEDf_GET(r) ((((r).port7_sleep_timer[0]) >> 13) & 0x7)
#define BCM89500_A0_PORT7_SLEEP_TIMERr_RESERVEDf_SET(r,f) (r).port7_sleep_timer[0]=(((r).port7_sleep_timer[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PORT7_SLEEP_TIMER.
 *
 */
#define BCM89500_A0_READ_PORT7_SLEEP_TIMERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT7_SLEEP_TIMERr,(r._port7_sleep_timer),2)
#define BCM89500_A0_WRITE_PORT7_SLEEP_TIMERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT7_SLEEP_TIMERr,&(r._port7_sleep_timer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT7_SLEEP_TIMERr BCM89500_A0_PORT7_SLEEP_TIMERr
#define PORT7_SLEEP_TIMERr_SIZE BCM89500_A0_PORT7_SLEEP_TIMERr_SIZE
typedef BCM89500_A0_PORT7_SLEEP_TIMERr_t PORT7_SLEEP_TIMERr_t;
#define PORT7_SLEEP_TIMERr_CLR BCM89500_A0_PORT7_SLEEP_TIMERr_CLR
#define PORT7_SLEEP_TIMERr_SET BCM89500_A0_PORT7_SLEEP_TIMERr_SET
#define PORT7_SLEEP_TIMERr_GET BCM89500_A0_PORT7_SLEEP_TIMERr_GET
#define PORT7_SLEEP_TIMERr_PORT7_SLEEP_TIMERf_GET BCM89500_A0_PORT7_SLEEP_TIMERr_PORT7_SLEEP_TIMERf_GET
#define PORT7_SLEEP_TIMERr_PORT7_SLEEP_TIMERf_SET BCM89500_A0_PORT7_SLEEP_TIMERr_PORT7_SLEEP_TIMERf_SET
#define PORT7_SLEEP_TIMERr_RESERVEDf_GET BCM89500_A0_PORT7_SLEEP_TIMERr_RESERVEDf_GET
#define PORT7_SLEEP_TIMERr_RESERVEDf_SET BCM89500_A0_PORT7_SLEEP_TIMERr_RESERVEDf_SET
#define READ_PORT7_SLEEP_TIMERr BCM89500_A0_READ_PORT7_SLEEP_TIMERr
#define WRITE_PORT7_SLEEP_TIMERr BCM89500_A0_WRITE_PORT7_SLEEP_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT7_SLEEP_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_EAP_CON
 * BLOCKS:   GPIC0
 * DESC:     Port N EAP Configuration Registers
 * SIZE:     64
 * FIELDS:
 *     EAP_UNI_DA       EAP frame DA register.
 *     EAP_EN_UNI_DA    enable EAP frame with DA.
 *     EAP_BLK_MODE     00: Do not check EAP_BLK_MODE.01: Check EAP_BLK_MODE on ingress port, only frame defined in EAP_GCFG will be forwarded. Otherwise frame will be dropped.10: Reserved11: Check EAP_BLK_MODE on both ingress and egress port, only frame defined in EAP_GCFG will be forwarded. Especially, the forwarding process will check whether each egress port is at block mode or not.
 *     EAP_MODE         00 : Basic mode, do not check SA,01 : Reserved10 : Extend mode, check SA & port-number. Drop if SA is unknown.11 : Simplified mode, check SA & port-number. Trap to mgnt-port if SA is unknown.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_EAP_CONr 0x00004220

#define BCM89500_A0_PORT_EAP_CONr_SIZE 8

/*
 * This structure should be used to declare and program PORT_EAP_CON.
 *
 */
typedef union BCM89500_A0_PORT_EAP_CONr_s {
	uint32_t v[2];
	uint32_t port_eap_con[2];
	uint32_t _port_eap_con;
} BCM89500_A0_PORT_EAP_CONr_t;

#define BCM89500_A0_PORT_EAP_CONr_CLR(r) CDK_MEMSET(&((r)._port_eap_con), 0, sizeof(BCM89500_A0_PORT_EAP_CONr_t))
#define BCM89500_A0_PORT_EAP_CONr_SET(r,i,d) (r).port_eap_con[i] = d
#define BCM89500_A0_PORT_EAP_CONr_GET(r,i) (r).port_eap_con[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_con,0,47,a)
#define BCM89500_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_con,0,47,a)
#define BCM89500_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET(r) ((((r).port_eap_con[1]) >> 16) & 0x1)
#define BCM89500_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET(r) ((((r).port_eap_con[1]) >> 17) & 0x3)
#define BCM89500_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM89500_A0_PORT_EAP_CONr_EAP_MODEf_GET(r) ((((r).port_eap_con[1]) >> 19) & 0x3)
#define BCM89500_A0_PORT_EAP_CONr_EAP_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM89500_A0_PORT_EAP_CONr_RESERVEDf_GET(r) ((((r).port_eap_con[1]) >> 21) & 0x7ff)
#define BCM89500_A0_PORT_EAP_CONr_RESERVEDf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORT_EAP_CON.
 *
 */
#define BCM89500_A0_READ_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PORT_EAP_CONr,(r._port_eap_con),8)
#define BCM89500_A0_WRITE_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PORT_EAP_CONr,&(r._port_eap_con),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_CONr BCM89500_A0_PORT_EAP_CONr
#define PORT_EAP_CONr_SIZE BCM89500_A0_PORT_EAP_CONr_SIZE
typedef BCM89500_A0_PORT_EAP_CONr_t PORT_EAP_CONr_t;
#define PORT_EAP_CONr_CLR BCM89500_A0_PORT_EAP_CONr_CLR
#define PORT_EAP_CONr_SET BCM89500_A0_PORT_EAP_CONr_SET
#define PORT_EAP_CONr_GET BCM89500_A0_PORT_EAP_CONr_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_GET BCM89500_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_SET BCM89500_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_GET BCM89500_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_SET BCM89500_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_BLK_MODEf_GET BCM89500_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET
#define PORT_EAP_CONr_EAP_BLK_MODEf_SET BCM89500_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET
#define PORT_EAP_CONr_EAP_MODEf_GET BCM89500_A0_PORT_EAP_CONr_EAP_MODEf_GET
#define PORT_EAP_CONr_EAP_MODEf_SET BCM89500_A0_PORT_EAP_CONr_EAP_MODEf_SET
#define PORT_EAP_CONr_RESERVEDf_GET BCM89500_A0_PORT_EAP_CONr_RESERVEDf_GET
#define PORT_EAP_CONr_RESERVEDf_SET BCM89500_A0_PORT_EAP_CONr_RESERVEDf_SET
#define READ_PORT_EAP_CONr BCM89500_A0_READ_PORT_EAP_CONr
#define WRITE_PORT_EAP_CONr BCM89500_A0_WRITE_PORT_EAP_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_EAP_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_EAP_CON_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 EAP Configuration Registers (polar feature)
 * SIZE:     64
 * FIELDS:
 *     EAP_UNI_DA       EAP frame DA register.
 *     EAP_EN_UNI_DA    enable EAP frame with DA.
 *     EAP_BLK_MODE     00: Do not check EAP_BLK_MODE.01: Check EAP_BLK_MODE on ingress port, only frame defined in EAP_GCFG will be forwarded. Otherwise frame will be dropped.10: Reserved11: Check EAP_BLK_MODE on both ingress and egress port, only frame defined in EAP_GCFG will be forwarded. Especially, the forwarding process will check whether each egress port is at block mode or not.
 *     EAP_MODE         00 : Basic mode, do not check SA,01 : Reserved10 : Extend mode, check SA & port-number. Drop if SA is unknown.11 : Simplified mode, check SA & port-number. Trap to mgnt-port if SA is unknown.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_EAP_CON_P7r 0x00004258

#define BCM89500_A0_PORT_EAP_CON_P7r_SIZE 8

/*
 * This structure should be used to declare and program PORT_EAP_CON_P7.
 *
 */
typedef union BCM89500_A0_PORT_EAP_CON_P7r_s {
	uint32_t v[2];
	uint32_t port_eap_con_p7[2];
	uint32_t _port_eap_con_p7;
} BCM89500_A0_PORT_EAP_CON_P7r_t;

#define BCM89500_A0_PORT_EAP_CON_P7r_CLR(r) CDK_MEMSET(&((r)._port_eap_con_p7), 0, sizeof(BCM89500_A0_PORT_EAP_CON_P7r_t))
#define BCM89500_A0_PORT_EAP_CON_P7r_SET(r,i,d) (r).port_eap_con_p7[i] = d
#define BCM89500_A0_PORT_EAP_CON_P7r_GET(r,i) (r).port_eap_con_p7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_con_p7,0,47,a)
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_con_p7,0,47,a)
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_EN_UNI_DAf_GET(r) ((((r).port_eap_con_p7[1]) >> 16) & 0x1)
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_EN_UNI_DAf_SET(r,f) (r).port_eap_con_p7[1]=(((r).port_eap_con_p7[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_BLK_MODEf_GET(r) ((((r).port_eap_con_p7[1]) >> 17) & 0x3)
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_BLK_MODEf_SET(r,f) (r).port_eap_con_p7[1]=(((r).port_eap_con_p7[1] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_MODEf_GET(r) ((((r).port_eap_con_p7[1]) >> 19) & 0x3)
#define BCM89500_A0_PORT_EAP_CON_P7r_EAP_MODEf_SET(r,f) (r).port_eap_con_p7[1]=(((r).port_eap_con_p7[1] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM89500_A0_PORT_EAP_CON_P7r_RESERVEDf_GET(r) ((((r).port_eap_con_p7[1]) >> 21) & 0x7ff)
#define BCM89500_A0_PORT_EAP_CON_P7r_RESERVEDf_SET(r,f) (r).port_eap_con_p7[1]=(((r).port_eap_con_p7[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORT_EAP_CON_P7.
 *
 */
#define BCM89500_A0_READ_PORT_EAP_CON_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT_EAP_CON_P7r,(r._port_eap_con_p7),8)
#define BCM89500_A0_WRITE_PORT_EAP_CON_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT_EAP_CON_P7r,&(r._port_eap_con_p7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_CON_P7r BCM89500_A0_PORT_EAP_CON_P7r
#define PORT_EAP_CON_P7r_SIZE BCM89500_A0_PORT_EAP_CON_P7r_SIZE
typedef BCM89500_A0_PORT_EAP_CON_P7r_t PORT_EAP_CON_P7r_t;
#define PORT_EAP_CON_P7r_CLR BCM89500_A0_PORT_EAP_CON_P7r_CLR
#define PORT_EAP_CON_P7r_SET BCM89500_A0_PORT_EAP_CON_P7r_SET
#define PORT_EAP_CON_P7r_GET BCM89500_A0_PORT_EAP_CON_P7r_GET
#define PORT_EAP_CON_P7r_EAP_UNI_DAf_GET BCM89500_A0_PORT_EAP_CON_P7r_EAP_UNI_DAf_GET
#define PORT_EAP_CON_P7r_EAP_UNI_DAf_SET BCM89500_A0_PORT_EAP_CON_P7r_EAP_UNI_DAf_SET
#define PORT_EAP_CON_P7r_EAP_EN_UNI_DAf_GET BCM89500_A0_PORT_EAP_CON_P7r_EAP_EN_UNI_DAf_GET
#define PORT_EAP_CON_P7r_EAP_EN_UNI_DAf_SET BCM89500_A0_PORT_EAP_CON_P7r_EAP_EN_UNI_DAf_SET
#define PORT_EAP_CON_P7r_EAP_BLK_MODEf_GET BCM89500_A0_PORT_EAP_CON_P7r_EAP_BLK_MODEf_GET
#define PORT_EAP_CON_P7r_EAP_BLK_MODEf_SET BCM89500_A0_PORT_EAP_CON_P7r_EAP_BLK_MODEf_SET
#define PORT_EAP_CON_P7r_EAP_MODEf_GET BCM89500_A0_PORT_EAP_CON_P7r_EAP_MODEf_GET
#define PORT_EAP_CON_P7r_EAP_MODEf_SET BCM89500_A0_PORT_EAP_CON_P7r_EAP_MODEf_SET
#define PORT_EAP_CON_P7r_RESERVEDf_GET BCM89500_A0_PORT_EAP_CON_P7r_RESERVEDf_GET
#define PORT_EAP_CON_P7r_RESERVEDf_SET BCM89500_A0_PORT_EAP_CON_P7r_RESERVEDf_SET
#define READ_PORT_EAP_CON_P7r BCM89500_A0_READ_PORT_EAP_CON_P7r
#define WRITE_PORT_EAP_CON_P7r BCM89500_A0_WRITE_PORT_EAP_CON_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_EAP_CON_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_ENABLE
 * BLOCKS:   SYS
 * DESC:     Port Enable Control Registers
 * SIZE:     16
 * FIELDS:
 *     TX_PORT_1588_EN  Enables the 1588 TX slice.Bit 7 -- enable TX port 8Bit 6 -- enable TX port 7Bit 5 -- enable TX port 5Bit 4 -- enable TX port 4Bit 3 -- enable TX port 3Bit 2 -- enable TX port 2Bit 1 -- enable TX port 1Bit 0 -- enable TX port 0
 *     RX_PORT_1588_EN  Enables the 1588 RX slice.Bit 15 -- enable RX port 8Bit 14 -- enable RX port 7Bit 13 -- enable RX port 5Bit 12 -- enable RX port 4Bit 11 -- enable RX port 3Bit 10 -- enable RX port 2Bit 9  -- enable RX port 1Bit 8  -- enable RX port 0
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_ENABLEr 0x00009300

#define BCM89500_A0_PORT_ENABLEr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ENABLE.
 *
 */
typedef union BCM89500_A0_PORT_ENABLEr_s {
	uint32_t v[1];
	uint32_t port_enable[1];
	uint32_t _port_enable;
} BCM89500_A0_PORT_ENABLEr_t;

#define BCM89500_A0_PORT_ENABLEr_CLR(r) (r).port_enable[0] = 0
#define BCM89500_A0_PORT_ENABLEr_SET(r,d) (r).port_enable[0] = d
#define BCM89500_A0_PORT_ENABLEr_GET(r) (r).port_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_ENABLEr_TX_PORT_1588_ENf_GET(r) (((r).port_enable[0]) & 0xff)
#define BCM89500_A0_PORT_ENABLEr_TX_PORT_1588_ENf_SET(r,f) (r).port_enable[0]=(((r).port_enable[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_PORT_ENABLEr_RX_PORT_1588_ENf_GET(r) ((((r).port_enable[0]) >> 8) & 0xff)
#define BCM89500_A0_PORT_ENABLEr_RX_PORT_1588_ENf_SET(r,f) (r).port_enable[0]=(((r).port_enable[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PORT_ENABLE.
 *
 */
#define BCM89500_A0_READ_PORT_ENABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT_ENABLEr,(r._port_enable),2)
#define BCM89500_A0_WRITE_PORT_ENABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT_ENABLEr,&(r._port_enable),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ENABLEr BCM89500_A0_PORT_ENABLEr
#define PORT_ENABLEr_SIZE BCM89500_A0_PORT_ENABLEr_SIZE
typedef BCM89500_A0_PORT_ENABLEr_t PORT_ENABLEr_t;
#define PORT_ENABLEr_CLR BCM89500_A0_PORT_ENABLEr_CLR
#define PORT_ENABLEr_SET BCM89500_A0_PORT_ENABLEr_SET
#define PORT_ENABLEr_GET BCM89500_A0_PORT_ENABLEr_GET
#define PORT_ENABLEr_TX_PORT_1588_ENf_GET BCM89500_A0_PORT_ENABLEr_TX_PORT_1588_ENf_GET
#define PORT_ENABLEr_TX_PORT_1588_ENf_SET BCM89500_A0_PORT_ENABLEr_TX_PORT_1588_ENf_SET
#define PORT_ENABLEr_RX_PORT_1588_ENf_GET BCM89500_A0_PORT_ENABLEr_RX_PORT_1588_ENf_GET
#define PORT_ENABLEr_RX_PORT_1588_ENf_SET BCM89500_A0_PORT_ENABLEr_RX_PORT_1588_ENf_SET
#define READ_PORT_ENABLEr BCM89500_A0_READ_PORT_ENABLEr
#define WRITE_PORT_ENABLEr BCM89500_A0_WRITE_PORT_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_SLEEP_STS
 * BLOCKS:   SYS
 * DESC:     Port Sleep Status Register
 * SIZE:     8
 * FIELDS:
 *     IMP_PORT_SLEEP_STS IMP Port(port88) Sleep Status.0 = IMP port is not in IMP_Sleep mode whenever either reset or the counter of IMP SLEEP Timer is equal to zero.(Note: the port is in IMP_SLEEP INIT state)1 = IMP port is in IMP_Sleep mode when the counter of IMP Sleep Timer is not equal to zero.(Note: the port is not in IMP_SLEEP INIT state)
 *     WAN_PORT_SLEEP_STS WAN Port(port5) Sleep Status.0 = WAN port is not in IMP_Sleep mode whenever either reset or the counter of WAN SLEEP Timer is equal to zero.(Note: the port is in IMP_SLEEP INIT state)1 = WAN port is in IMP_Sleep mode when the counter of WAN Sleep Timer is not equal to zero.(Note: the port is not in IMP_SLEEP INIT state)
 *     PORT7_SLEEP_STS  Port 7 Sleep Status.0 = port 7 is not in IMP_Sleep mode whenever either reset or the counter of port 7 Sleep Timer is equal to zero.(Note: the port is in IMP_SLEEP INIT state)1 = port7 is in IMP_Sleep mode when the counter of port 7 Sleep Timer is not equal to zero.(Note: the port is not in IMP_SLEEP INIT state)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_SLEEP_STSr 0x00000318

#define BCM89500_A0_PORT_SLEEP_STSr_SIZE 1

/*
 * This structure should be used to declare and program PORT_SLEEP_STS.
 *
 */
typedef union BCM89500_A0_PORT_SLEEP_STSr_s {
	uint32_t v[1];
	uint32_t port_sleep_sts[1];
	uint32_t _port_sleep_sts;
} BCM89500_A0_PORT_SLEEP_STSr_t;

#define BCM89500_A0_PORT_SLEEP_STSr_CLR(r) (r).port_sleep_sts[0] = 0
#define BCM89500_A0_PORT_SLEEP_STSr_SET(r,d) (r).port_sleep_sts[0] = d
#define BCM89500_A0_PORT_SLEEP_STSr_GET(r) (r).port_sleep_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_SLEEP_STSr_IMP_PORT_SLEEP_STSf_GET(r) (((r).port_sleep_sts[0]) & 0x1)
#define BCM89500_A0_PORT_SLEEP_STSr_IMP_PORT_SLEEP_STSf_SET(r,f) (r).port_sleep_sts[0]=(((r).port_sleep_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_PORT_SLEEP_STSr_WAN_PORT_SLEEP_STSf_GET(r) ((((r).port_sleep_sts[0]) >> 1) & 0x1)
#define BCM89500_A0_PORT_SLEEP_STSr_WAN_PORT_SLEEP_STSf_SET(r,f) (r).port_sleep_sts[0]=(((r).port_sleep_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_PORT_SLEEP_STSr_PORT7_SLEEP_STSf_GET(r) ((((r).port_sleep_sts[0]) >> 2) & 0x1)
#define BCM89500_A0_PORT_SLEEP_STSr_PORT7_SLEEP_STSf_SET(r,f) (r).port_sleep_sts[0]=(((r).port_sleep_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_PORT_SLEEP_STSr_RESERVEDf_GET(r) ((((r).port_sleep_sts[0]) >> 3) & 0x1f)
#define BCM89500_A0_PORT_SLEEP_STSr_RESERVEDf_SET(r,f) (r).port_sleep_sts[0]=(((r).port_sleep_sts[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PORT_SLEEP_STS.
 *
 */
#define BCM89500_A0_READ_PORT_SLEEP_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT_SLEEP_STSr,(r._port_sleep_sts),1)
#define BCM89500_A0_WRITE_PORT_SLEEP_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT_SLEEP_STSr,&(r._port_sleep_sts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SLEEP_STSr BCM89500_A0_PORT_SLEEP_STSr
#define PORT_SLEEP_STSr_SIZE BCM89500_A0_PORT_SLEEP_STSr_SIZE
typedef BCM89500_A0_PORT_SLEEP_STSr_t PORT_SLEEP_STSr_t;
#define PORT_SLEEP_STSr_CLR BCM89500_A0_PORT_SLEEP_STSr_CLR
#define PORT_SLEEP_STSr_SET BCM89500_A0_PORT_SLEEP_STSr_SET
#define PORT_SLEEP_STSr_GET BCM89500_A0_PORT_SLEEP_STSr_GET
#define PORT_SLEEP_STSr_IMP_PORT_SLEEP_STSf_GET BCM89500_A0_PORT_SLEEP_STSr_IMP_PORT_SLEEP_STSf_GET
#define PORT_SLEEP_STSr_IMP_PORT_SLEEP_STSf_SET BCM89500_A0_PORT_SLEEP_STSr_IMP_PORT_SLEEP_STSf_SET
#define PORT_SLEEP_STSr_WAN_PORT_SLEEP_STSf_GET BCM89500_A0_PORT_SLEEP_STSr_WAN_PORT_SLEEP_STSf_GET
#define PORT_SLEEP_STSr_WAN_PORT_SLEEP_STSf_SET BCM89500_A0_PORT_SLEEP_STSr_WAN_PORT_SLEEP_STSf_SET
#define PORT_SLEEP_STSr_PORT7_SLEEP_STSf_GET BCM89500_A0_PORT_SLEEP_STSr_PORT7_SLEEP_STSf_GET
#define PORT_SLEEP_STSr_PORT7_SLEEP_STSf_SET BCM89500_A0_PORT_SLEEP_STSr_PORT7_SLEEP_STSf_SET
#define PORT_SLEEP_STSr_RESERVEDf_GET BCM89500_A0_PORT_SLEEP_STSr_RESERVEDf_GET
#define PORT_SLEEP_STSr_RESERVEDf_SET BCM89500_A0_PORT_SLEEP_STSr_RESERVEDf_SET
#define READ_PORT_SLEEP_STSr BCM89500_A0_READ_PORT_SLEEP_STSr
#define WRITE_PORT_SLEEP_STSr BCM89500_A0_WRITE_PORT_SLEEP_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_SLEEP_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_VLAN_CTL
 * BLOCKS:   GPIC0
 * DESC:     PORT N VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to '1' to enable forwarding to the egress port. Set '0' inhibit the forwarding.Bit 8: IMP port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_VLAN_CTLr 0x00003100

#define BCM89500_A0_PORT_VLAN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL.
 *
 */
typedef union BCM89500_A0_PORT_VLAN_CTLr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl[1];
	uint32_t _port_vlan_ctl;
} BCM89500_A0_PORT_VLAN_CTLr_t;

#define BCM89500_A0_PORT_VLAN_CTLr_CLR(r) (r).port_vlan_ctl[0] = 0
#define BCM89500_A0_PORT_VLAN_CTLr_SET(r,d) (r).port_vlan_ctl[0] = d
#define BCM89500_A0_PORT_VLAN_CTLr_GET(r) (r).port_vlan_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl[0]) & 0x1ff)
#define BCM89500_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PORT_VLAN_CTLr_RESERVEDf_GET(r) ((((r).port_vlan_ctl[0]) >> 9) & 0x7f)
#define BCM89500_A0_PORT_VLAN_CTLr_RESERVEDf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL.
 *
 */
#define BCM89500_A0_READ_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PORT_VLAN_CTLr,(r._port_vlan_ctl),2)
#define BCM89500_A0_WRITE_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PORT_VLAN_CTLr,&(r._port_vlan_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTLr BCM89500_A0_PORT_VLAN_CTLr
#define PORT_VLAN_CTLr_SIZE BCM89500_A0_PORT_VLAN_CTLr_SIZE
typedef BCM89500_A0_PORT_VLAN_CTLr_t PORT_VLAN_CTLr_t;
#define PORT_VLAN_CTLr_CLR BCM89500_A0_PORT_VLAN_CTLr_CLR
#define PORT_VLAN_CTLr_SET BCM89500_A0_PORT_VLAN_CTLr_SET
#define PORT_VLAN_CTLr_GET BCM89500_A0_PORT_VLAN_CTLr_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET BCM89500_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET BCM89500_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTLr_RESERVEDf_GET BCM89500_A0_PORT_VLAN_CTLr_RESERVEDf_GET
#define PORT_VLAN_CTLr_RESERVEDf_SET BCM89500_A0_PORT_VLAN_CTLr_RESERVEDf_SET
#define READ_PORT_VLAN_CTLr BCM89500_A0_READ_PORT_VLAN_CTLr
#define WRITE_PORT_VLAN_CTLr BCM89500_A0_WRITE_PORT_VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_VLAN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_VLAN_CTL_IMP
 * BLOCKS:   CPIC
 * DESC:     PORT 8 VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to '1' to enable forwarding to the egress port. Set '0' inhibit the forwarding.Bit 8: IMP port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_VLAN_CTL_IMPr 0x00003110

#define BCM89500_A0_PORT_VLAN_CTL_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL_IMP.
 *
 */
typedef union BCM89500_A0_PORT_VLAN_CTL_IMPr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl_imp[1];
	uint32_t _port_vlan_ctl_imp;
} BCM89500_A0_PORT_VLAN_CTL_IMPr_t;

#define BCM89500_A0_PORT_VLAN_CTL_IMPr_CLR(r) (r).port_vlan_ctl_imp[0] = 0
#define BCM89500_A0_PORT_VLAN_CTL_IMPr_SET(r,d) (r).port_vlan_ctl_imp[0] = d
#define BCM89500_A0_PORT_VLAN_CTL_IMPr_GET(r) (r).port_vlan_ctl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl_imp[0]) & 0x1ff)
#define BCM89500_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_GET(r) ((((r).port_vlan_ctl_imp[0]) >> 9) & 0x7f)
#define BCM89500_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL_IMP.
 *
 */
#define BCM89500_A0_READ_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT_VLAN_CTL_IMPr,(r._port_vlan_ctl_imp),2)
#define BCM89500_A0_WRITE_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT_VLAN_CTL_IMPr,&(r._port_vlan_ctl_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTL_IMPr BCM89500_A0_PORT_VLAN_CTL_IMPr
#define PORT_VLAN_CTL_IMPr_SIZE BCM89500_A0_PORT_VLAN_CTL_IMPr_SIZE
typedef BCM89500_A0_PORT_VLAN_CTL_IMPr_t PORT_VLAN_CTL_IMPr_t;
#define PORT_VLAN_CTL_IMPr_CLR BCM89500_A0_PORT_VLAN_CTL_IMPr_CLR
#define PORT_VLAN_CTL_IMPr_SET BCM89500_A0_PORT_VLAN_CTL_IMPr_SET
#define PORT_VLAN_CTL_IMPr_GET BCM89500_A0_PORT_VLAN_CTL_IMPr_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET BCM89500_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET BCM89500_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTL_IMPr_RESERVEDf_GET BCM89500_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_GET
#define PORT_VLAN_CTL_IMPr_RESERVEDf_SET BCM89500_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_SET
#define READ_PORT_VLAN_CTL_IMPr BCM89500_A0_READ_PORT_VLAN_CTL_IMPr
#define WRITE_PORT_VLAN_CTL_IMPr BCM89500_A0_WRITE_PORT_VLAN_CTL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_VLAN_CTL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PORT_VLAN_CTL_P7
 * BLOCKS:   SYS
 * DESC:     PORT 7 VLAN Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to '1' to enable forwarding to the egress port. Set '0' inhibit the forwarding.Bit 8: IMP port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PORT_VLAN_CTL_P7r 0x0000310e

#define BCM89500_A0_PORT_VLAN_CTL_P7r_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL_P7.
 *
 */
typedef union BCM89500_A0_PORT_VLAN_CTL_P7r_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl_p7[1];
	uint32_t _port_vlan_ctl_p7;
} BCM89500_A0_PORT_VLAN_CTL_P7r_t;

#define BCM89500_A0_PORT_VLAN_CTL_P7r_CLR(r) (r).port_vlan_ctl_p7[0] = 0
#define BCM89500_A0_PORT_VLAN_CTL_P7r_SET(r,d) (r).port_vlan_ctl_p7[0] = d
#define BCM89500_A0_PORT_VLAN_CTL_P7r_GET(r) (r).port_vlan_ctl_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PORT_VLAN_CTL_P7r_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl_p7[0]) & 0x1ff)
#define BCM89500_A0_PORT_VLAN_CTL_P7r_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl_p7[0]=(((r).port_vlan_ctl_p7[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PORT_VLAN_CTL_P7r_RESERVEDf_GET(r) ((((r).port_vlan_ctl_p7[0]) >> 9) & 0x7f)
#define BCM89500_A0_PORT_VLAN_CTL_P7r_RESERVEDf_SET(r,f) (r).port_vlan_ctl_p7[0]=(((r).port_vlan_ctl_p7[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL_P7.
 *
 */
#define BCM89500_A0_READ_PORT_VLAN_CTL_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PORT_VLAN_CTL_P7r,(r._port_vlan_ctl_p7),2)
#define BCM89500_A0_WRITE_PORT_VLAN_CTL_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PORT_VLAN_CTL_P7r,&(r._port_vlan_ctl_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTL_P7r BCM89500_A0_PORT_VLAN_CTL_P7r
#define PORT_VLAN_CTL_P7r_SIZE BCM89500_A0_PORT_VLAN_CTL_P7r_SIZE
typedef BCM89500_A0_PORT_VLAN_CTL_P7r_t PORT_VLAN_CTL_P7r_t;
#define PORT_VLAN_CTL_P7r_CLR BCM89500_A0_PORT_VLAN_CTL_P7r_CLR
#define PORT_VLAN_CTL_P7r_SET BCM89500_A0_PORT_VLAN_CTL_P7r_SET
#define PORT_VLAN_CTL_P7r_GET BCM89500_A0_PORT_VLAN_CTL_P7r_GET
#define PORT_VLAN_CTL_P7r_PORT_EGRESS_ENf_GET BCM89500_A0_PORT_VLAN_CTL_P7r_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTL_P7r_PORT_EGRESS_ENf_SET BCM89500_A0_PORT_VLAN_CTL_P7r_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTL_P7r_RESERVEDf_GET BCM89500_A0_PORT_VLAN_CTL_P7r_RESERVEDf_GET
#define PORT_VLAN_CTL_P7r_RESERVEDf_SET BCM89500_A0_PORT_VLAN_CTL_P7r_RESERVEDf_SET
#define READ_PORT_VLAN_CTL_P7r BCM89500_A0_READ_PORT_VLAN_CTL_P7r
#define WRITE_PORT_VLAN_CTL_P7r BCM89500_A0_WRITE_PORT_VLAN_CTL_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PORT_VLAN_CTL_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  POST_LED_CTRL
 * BLOCKS:   SYS
 * DESC:     Post LED Control Register
 * SIZE:     8
 * FIELDS:
 *     POST_LED_TRIGGER Post LED Control.The 4 bits control the LED on/off state during POST to allow dual-color LED to be tested. [3:0] control LED0~LED3 of each port. When '1', the LED pin is activated during POST, when '0', the LED pin is deactivated during POST.Note: polar support up to 4 LEDs per port. If there are only 3 bit are selected in the LED Function Control Register, LED0~LED2 are selected in the POST_LED_TRIGGER Register.
 *     RESERVED         Reserved
 *     ACT_LED_TRIGGER  LED trigger definition for the Active LED in LED Function Register(Page 00h, 10-13h)0 = Active LED is triggered by the TXEN or CRS signal.1 = Active LED is triggered by the TXEN or RXDV signal.(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_POST_LED_CTRLr 0x0000001d

#define BCM89500_A0_POST_LED_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program POST_LED_CTRL.
 *
 */
typedef union BCM89500_A0_POST_LED_CTRLr_s {
	uint32_t v[1];
	uint32_t post_led_ctrl[1];
	uint32_t _post_led_ctrl;
} BCM89500_A0_POST_LED_CTRLr_t;

#define BCM89500_A0_POST_LED_CTRLr_CLR(r) (r).post_led_ctrl[0] = 0
#define BCM89500_A0_POST_LED_CTRLr_SET(r,d) (r).post_led_ctrl[0] = d
#define BCM89500_A0_POST_LED_CTRLr_GET(r) (r).post_led_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_POST_LED_CTRLr_POST_LED_TRIGGERf_GET(r) (((r).post_led_ctrl[0]) & 0xf)
#define BCM89500_A0_POST_LED_CTRLr_POST_LED_TRIGGERf_SET(r,f) (r).post_led_ctrl[0]=(((r).post_led_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_POST_LED_CTRLr_RESERVEDf_GET(r) ((((r).post_led_ctrl[0]) >> 4) & 0x7)
#define BCM89500_A0_POST_LED_CTRLr_RESERVEDf_SET(r,f) (r).post_led_ctrl[0]=(((r).post_led_ctrl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_POST_LED_CTRLr_ACT_LED_TRIGGERf_GET(r) ((((r).post_led_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_POST_LED_CTRLr_ACT_LED_TRIGGERf_SET(r,f) (r).post_led_ctrl[0]=(((r).post_led_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access POST_LED_CTRL.
 *
 */
#define BCM89500_A0_READ_POST_LED_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_POST_LED_CTRLr,(r._post_led_ctrl),1)
#define BCM89500_A0_WRITE_POST_LED_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_POST_LED_CTRLr,&(r._post_led_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define POST_LED_CTRLr BCM89500_A0_POST_LED_CTRLr
#define POST_LED_CTRLr_SIZE BCM89500_A0_POST_LED_CTRLr_SIZE
typedef BCM89500_A0_POST_LED_CTRLr_t POST_LED_CTRLr_t;
#define POST_LED_CTRLr_CLR BCM89500_A0_POST_LED_CTRLr_CLR
#define POST_LED_CTRLr_SET BCM89500_A0_POST_LED_CTRLr_SET
#define POST_LED_CTRLr_GET BCM89500_A0_POST_LED_CTRLr_GET
#define POST_LED_CTRLr_POST_LED_TRIGGERf_GET BCM89500_A0_POST_LED_CTRLr_POST_LED_TRIGGERf_GET
#define POST_LED_CTRLr_POST_LED_TRIGGERf_SET BCM89500_A0_POST_LED_CTRLr_POST_LED_TRIGGERf_SET
#define POST_LED_CTRLr_RESERVEDf_GET BCM89500_A0_POST_LED_CTRLr_RESERVEDf_GET
#define POST_LED_CTRLr_RESERVEDf_SET BCM89500_A0_POST_LED_CTRLr_RESERVEDf_SET
#define POST_LED_CTRLr_ACT_LED_TRIGGERf_GET BCM89500_A0_POST_LED_CTRLr_ACT_LED_TRIGGERf_GET
#define POST_LED_CTRLr_ACT_LED_TRIGGERf_SET BCM89500_A0_POST_LED_CTRLr_ACT_LED_TRIGGERf_SET
#define READ_POST_LED_CTRLr BCM89500_A0_READ_POST_LED_CTRLr
#define WRITE_POST_LED_CTRLr BCM89500_A0_WRITE_POST_LED_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_POST_LED_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PROTECTED_SEL
 * BLOCKS:   SYS
 * DESC:     Protected Port Select Register
 * SIZE:     16
 * FIELDS:
 *     PORT_SEL         Protected Port Selection.When set, the Port will be the protected Port.Protected Ports will not be able to Transmit/Receive Frame to/from each other.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PROTECTED_SELr 0x00000024

#define BCM89500_A0_PROTECTED_SELr_SIZE 2

/*
 * This structure should be used to declare and program PROTECTED_SEL.
 *
 */
typedef union BCM89500_A0_PROTECTED_SELr_s {
	uint32_t v[1];
	uint32_t protected_sel[1];
	uint32_t _protected_sel;
} BCM89500_A0_PROTECTED_SELr_t;

#define BCM89500_A0_PROTECTED_SELr_CLR(r) (r).protected_sel[0] = 0
#define BCM89500_A0_PROTECTED_SELr_SET(r,d) (r).protected_sel[0] = d
#define BCM89500_A0_PROTECTED_SELr_GET(r) (r).protected_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PROTECTED_SELr_PORT_SELf_GET(r) (((r).protected_sel[0]) & 0x1ff)
#define BCM89500_A0_PROTECTED_SELr_PORT_SELf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_PROTECTED_SELr_RESERVEDf_GET(r) ((((r).protected_sel[0]) >> 9) & 0x7f)
#define BCM89500_A0_PROTECTED_SELr_RESERVEDf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PROTECTED_SEL.
 *
 */
#define BCM89500_A0_READ_PROTECTED_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PROTECTED_SELr,(r._protected_sel),2)
#define BCM89500_A0_WRITE_PROTECTED_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PROTECTED_SELr,&(r._protected_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTECTED_SELr BCM89500_A0_PROTECTED_SELr
#define PROTECTED_SELr_SIZE BCM89500_A0_PROTECTED_SELr_SIZE
typedef BCM89500_A0_PROTECTED_SELr_t PROTECTED_SELr_t;
#define PROTECTED_SELr_CLR BCM89500_A0_PROTECTED_SELr_CLR
#define PROTECTED_SELr_SET BCM89500_A0_PROTECTED_SELr_SET
#define PROTECTED_SELr_GET BCM89500_A0_PROTECTED_SELr_GET
#define PROTECTED_SELr_PORT_SELf_GET BCM89500_A0_PROTECTED_SELr_PORT_SELf_GET
#define PROTECTED_SELr_PORT_SELf_SET BCM89500_A0_PROTECTED_SELr_PORT_SELf_SET
#define PROTECTED_SELr_RESERVEDf_GET BCM89500_A0_PROTECTED_SELr_RESERVEDf_GET
#define PROTECTED_SELr_RESERVEDf_SET BCM89500_A0_PROTECTED_SELr_RESERVEDf_SET
#define READ_PROTECTED_SELr BCM89500_A0_READ_PROTECTED_SELr
#define WRITE_PROTECTED_SELr BCM89500_A0_WRITE_PROTECTED_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PROTECTED_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PRS_FIFO_DEBUG_CTRL
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     PRS_FIFO_DBG_CTRL Control the prs_fifo_debug bus muxing[3:2]'d0: slice 0'd1: slice 1'd2: slice 2'd3: slice 3[1:0]'d0: slice[63:0]'d1: slice[127:64]'d2: slice[191:128]'d3: {23'h0,ipv6_vld,ipv4_vld,slice[229:192]}
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr 0x00000870

#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_CTRL.
 *
 */
typedef union BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_s {
	uint32_t v[1];
	uint32_t prs_fifo_debug_ctrl[1];
	uint32_t _prs_fifo_debug_ctrl;
} BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_t;

#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_CLR(r) (r).prs_fifo_debug_ctrl[0] = 0
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_SET(r,d) (r).prs_fifo_debug_ctrl[0] = d
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_GET(r) (r).prs_fifo_debug_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET(r) (((r).prs_fifo_debug_ctrl[0]) & 0xf)
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET(r) ((((r).prs_fifo_debug_ctrl[0]) >> 4) & 0xf)
#define BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PRS_FIFO_DEBUG_CTRL.
 *
 */
#define BCM89500_A0_READ_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PRS_FIFO_DEBUG_CTRLr,(r._prs_fifo_debug_ctrl),1)
#define BCM89500_A0_WRITE_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PRS_FIFO_DEBUG_CTRLr,&(r._prs_fifo_debug_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_CTRLr BCM89500_A0_PRS_FIFO_DEBUG_CTRLr
#define PRS_FIFO_DEBUG_CTRLr_SIZE BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_SIZE
typedef BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_t PRS_FIFO_DEBUG_CTRLr_t;
#define PRS_FIFO_DEBUG_CTRLr_CLR BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_CLR
#define PRS_FIFO_DEBUG_CTRLr_SET BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_SET
#define PRS_FIFO_DEBUG_CTRLr_GET BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET
#define PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET
#define PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET BCM89500_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET
#define READ_PRS_FIFO_DEBUG_CTRLr BCM89500_A0_READ_PRS_FIFO_DEBUG_CTRLr
#define WRITE_PRS_FIFO_DEBUG_CTRLr BCM89500_A0_WRITE_PRS_FIFO_DEBUG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PRS_FIFO_DEBUG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  PRS_FIFO_DEBUG_DATA
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Data Register(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     PRS_FIFO_DBG_DATA Provide 64 bits prs_fifo debug bus data according to the PRS_FIFO_DBG_CTRL.
 *
 ******************************************************************************/
#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr 0x00000871

#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr_SIZE 8

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_DATA.
 *
 */
typedef union BCM89500_A0_PRS_FIFO_DEBUG_DATAr_s {
	uint32_t v[2];
	uint32_t prs_fifo_debug_data[2];
	uint32_t _prs_fifo_debug_data;
} BCM89500_A0_PRS_FIFO_DEBUG_DATAr_t;

#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr_CLR(r) CDK_MEMSET(&((r)._prs_fifo_debug_data), 0, sizeof(BCM89500_A0_PRS_FIFO_DEBUG_DATAr_t))
#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr_SET(r,i,d) (r).prs_fifo_debug_data[i] = d
#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr_GET(r,i) (r).prs_fifo_debug_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET(r,a) cdk_field_get((r).prs_fifo_debug_data,0,63,a)
#define BCM89500_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET(r,a) cdk_field_set((r).prs_fifo_debug_data,0,63,a)

/*
 * These macros can be used to access PRS_FIFO_DEBUG_DATA.
 *
 */
#define BCM89500_A0_READ_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PRS_FIFO_DEBUG_DATAr,(r._prs_fifo_debug_data),8)
#define BCM89500_A0_WRITE_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PRS_FIFO_DEBUG_DATAr,&(r._prs_fifo_debug_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_DATAr BCM89500_A0_PRS_FIFO_DEBUG_DATAr
#define PRS_FIFO_DEBUG_DATAr_SIZE BCM89500_A0_PRS_FIFO_DEBUG_DATAr_SIZE
typedef BCM89500_A0_PRS_FIFO_DEBUG_DATAr_t PRS_FIFO_DEBUG_DATAr_t;
#define PRS_FIFO_DEBUG_DATAr_CLR BCM89500_A0_PRS_FIFO_DEBUG_DATAr_CLR
#define PRS_FIFO_DEBUG_DATAr_SET BCM89500_A0_PRS_FIFO_DEBUG_DATAr_SET
#define PRS_FIFO_DEBUG_DATAr_GET BCM89500_A0_PRS_FIFO_DEBUG_DATAr_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET BCM89500_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET BCM89500_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET
#define READ_PRS_FIFO_DEBUG_DATAr BCM89500_A0_READ_PRS_FIFO_DEBUG_DATAr
#define WRITE_PRS_FIFO_DEBUG_DATAr BCM89500_A0_WRITE_PRS_FIFO_DEBUG_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PRS_FIFO_DEBUG_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts1024toMaxPktOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETSr 0x00002074

#define BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets[1];
	uint32_t _pkts1024tomaxpktoctets;
} BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).pkts1024tomaxpktoctets[0] = 0
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).pkts1024tomaxpktoctets[0] = d
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).pkts1024tomaxpktoctets[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets.
 *
 */
#define BCM89500_A0_READ_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PKTS1024TOMAXPKTOCTETSr,(r._pkts1024tomaxpktoctets),4)
#define BCM89500_A0_WRITE_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PKTS1024TOMAXPKTOCTETSr,&(r._pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETSr BCM89500_A0_PKTS1024TOMAXPKTOCTETSr
#define PKTS1024TOMAXPKTOCTETSr_SIZE BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_t PKTS1024TOMAXPKTOCTETSr_t;
#define PKTS1024TOMAXPKTOCTETSr_CLR BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_CLR
#define PKTS1024TOMAXPKTOCTETSr_SET BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_SET
#define PKTS1024TOMAXPKTOCTETSr_GET BCM89500_A0_PKTS1024TOMAXPKTOCTETSr_GET
#define READ_PKTS1024TOMAXPKTOCTETSr BCM89500_A0_READ_PKTS1024TOMAXPKTOCTETSr
#define WRITE_PKTS1024TOMAXPKTOCTETSr BCM89500_A0_WRITE_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts1024toMaxPktOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr 0x00002874

#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets_IMP.
 *
 */
typedef union BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets_imp[1];
	uint32_t _pkts1024tomaxpktoctets_imp;
} BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_t;

#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_CLR(r) (r).pkts1024tomaxpktoctets_imp[0] = 0
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SET(r,d) (r).pkts1024tomaxpktoctets_imp[0] = d
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_GET(r) (r).pkts1024tomaxpktoctets_imp[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets_IMP.
 *
 */
#define BCM89500_A0_READ_PKTS1024TOMAXPKTOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr,(r._pkts1024tomaxpktoctets_imp),4)
#define BCM89500_A0_WRITE_PKTS1024TOMAXPKTOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr,&(r._pkts1024tomaxpktoctets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETS_IMPr BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr
#define PKTS1024TOMAXPKTOCTETS_IMPr_SIZE BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SIZE
typedef BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_t PKTS1024TOMAXPKTOCTETS_IMPr_t;
#define PKTS1024TOMAXPKTOCTETS_IMPr_CLR BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_CLR
#define PKTS1024TOMAXPKTOCTETS_IMPr_SET BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SET
#define PKTS1024TOMAXPKTOCTETS_IMPr_GET BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr_GET
#define READ_PKTS1024TOMAXPKTOCTETS_IMPr BCM89500_A0_READ_PKTS1024TOMAXPKTOCTETS_IMPr
#define WRITE_PKTS1024TOMAXPKTOCTETS_IMPr BCM89500_A0_WRITE_PKTS1024TOMAXPKTOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS1024TOMAXPKTOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts1024toMaxPktOctets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r 0x00002774

#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets_P7.
 *
 */
typedef union BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets_p7[1];
	uint32_t _pkts1024tomaxpktoctets_p7;
} BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_t;

#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_CLR(r) (r).pkts1024tomaxpktoctets_p7[0] = 0
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_SET(r,d) (r).pkts1024tomaxpktoctets_p7[0] = d
#define BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_GET(r) (r).pkts1024tomaxpktoctets_p7[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets_P7.
 *
 */
#define BCM89500_A0_READ_PKTS1024TOMAXPKTOCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r,(r._pkts1024tomaxpktoctets_p7),4)
#define BCM89500_A0_WRITE_PKTS1024TOMAXPKTOCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r,&(r._pkts1024tomaxpktoctets_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETS_P7r BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r
#define PKTS1024TOMAXPKTOCTETS_P7r_SIZE BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_SIZE
typedef BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_t PKTS1024TOMAXPKTOCTETS_P7r_t;
#define PKTS1024TOMAXPKTOCTETS_P7r_CLR BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_CLR
#define PKTS1024TOMAXPKTOCTETS_P7r_SET BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_SET
#define PKTS1024TOMAXPKTOCTETS_P7r_GET BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r_GET
#define READ_PKTS1024TOMAXPKTOCTETS_P7r BCM89500_A0_READ_PKTS1024TOMAXPKTOCTETS_P7r
#define WRITE_PKTS1024TOMAXPKTOCTETS_P7r BCM89500_A0_WRITE_PKTS1024TOMAXPKTOCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS1024TOMAXPKTOCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts128to255Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS128TO255OCTETSr 0x00002068

#define BCM89500_A0_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets.
 *
 */
typedef union BCM89500_A0_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets[1];
	uint32_t _pkts128to255octets;
} BCM89500_A0_PKTS128TO255OCTETSr_t;

#define BCM89500_A0_PKTS128TO255OCTETSr_CLR(r) (r).pkts128to255octets[0] = 0
#define BCM89500_A0_PKTS128TO255OCTETSr_SET(r,d) (r).pkts128to255octets[0] = d
#define BCM89500_A0_PKTS128TO255OCTETSr_GET(r) (r).pkts128to255octets[0]


/*
 * These macros can be used to access Pkts128to255Octets.
 *
 */
#define BCM89500_A0_READ_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PKTS128TO255OCTETSr,(r._pkts128to255octets),4)
#define BCM89500_A0_WRITE_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PKTS128TO255OCTETSr,&(r._pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETSr BCM89500_A0_PKTS128TO255OCTETSr
#define PKTS128TO255OCTETSr_SIZE BCM89500_A0_PKTS128TO255OCTETSr_SIZE
typedef BCM89500_A0_PKTS128TO255OCTETSr_t PKTS128TO255OCTETSr_t;
#define PKTS128TO255OCTETSr_CLR BCM89500_A0_PKTS128TO255OCTETSr_CLR
#define PKTS128TO255OCTETSr_SET BCM89500_A0_PKTS128TO255OCTETSr_SET
#define PKTS128TO255OCTETSr_GET BCM89500_A0_PKTS128TO255OCTETSr_GET
#define READ_PKTS128TO255OCTETSr BCM89500_A0_READ_PKTS128TO255OCTETSr
#define WRITE_PKTS128TO255OCTETSr BCM89500_A0_WRITE_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts128to255Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS128TO255OCTETS_IMPr 0x00002868

#define BCM89500_A0_PKTS128TO255OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets_IMP.
 *
 */
typedef union BCM89500_A0_PKTS128TO255OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets_imp[1];
	uint32_t _pkts128to255octets_imp;
} BCM89500_A0_PKTS128TO255OCTETS_IMPr_t;

#define BCM89500_A0_PKTS128TO255OCTETS_IMPr_CLR(r) (r).pkts128to255octets_imp[0] = 0
#define BCM89500_A0_PKTS128TO255OCTETS_IMPr_SET(r,d) (r).pkts128to255octets_imp[0] = d
#define BCM89500_A0_PKTS128TO255OCTETS_IMPr_GET(r) (r).pkts128to255octets_imp[0]


/*
 * These macros can be used to access Pkts128to255Octets_IMP.
 *
 */
#define BCM89500_A0_READ_PKTS128TO255OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS128TO255OCTETS_IMPr,(r._pkts128to255octets_imp),4)
#define BCM89500_A0_WRITE_PKTS128TO255OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS128TO255OCTETS_IMPr,&(r._pkts128to255octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETS_IMPr BCM89500_A0_PKTS128TO255OCTETS_IMPr
#define PKTS128TO255OCTETS_IMPr_SIZE BCM89500_A0_PKTS128TO255OCTETS_IMPr_SIZE
typedef BCM89500_A0_PKTS128TO255OCTETS_IMPr_t PKTS128TO255OCTETS_IMPr_t;
#define PKTS128TO255OCTETS_IMPr_CLR BCM89500_A0_PKTS128TO255OCTETS_IMPr_CLR
#define PKTS128TO255OCTETS_IMPr_SET BCM89500_A0_PKTS128TO255OCTETS_IMPr_SET
#define PKTS128TO255OCTETS_IMPr_GET BCM89500_A0_PKTS128TO255OCTETS_IMPr_GET
#define READ_PKTS128TO255OCTETS_IMPr BCM89500_A0_READ_PKTS128TO255OCTETS_IMPr
#define WRITE_PKTS128TO255OCTETS_IMPr BCM89500_A0_WRITE_PKTS128TO255OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS128TO255OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts128to255Octets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS128TO255OCTETS_P7r 0x00002768

#define BCM89500_A0_PKTS128TO255OCTETS_P7r_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets_P7.
 *
 */
typedef union BCM89500_A0_PKTS128TO255OCTETS_P7r_s {
	uint32_t v[1];
	uint32_t pkts128to255octets_p7[1];
	uint32_t _pkts128to255octets_p7;
} BCM89500_A0_PKTS128TO255OCTETS_P7r_t;

#define BCM89500_A0_PKTS128TO255OCTETS_P7r_CLR(r) (r).pkts128to255octets_p7[0] = 0
#define BCM89500_A0_PKTS128TO255OCTETS_P7r_SET(r,d) (r).pkts128to255octets_p7[0] = d
#define BCM89500_A0_PKTS128TO255OCTETS_P7r_GET(r) (r).pkts128to255octets_p7[0]


/*
 * These macros can be used to access Pkts128to255Octets_P7.
 *
 */
#define BCM89500_A0_READ_PKTS128TO255OCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS128TO255OCTETS_P7r,(r._pkts128to255octets_p7),4)
#define BCM89500_A0_WRITE_PKTS128TO255OCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS128TO255OCTETS_P7r,&(r._pkts128to255octets_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETS_P7r BCM89500_A0_PKTS128TO255OCTETS_P7r
#define PKTS128TO255OCTETS_P7r_SIZE BCM89500_A0_PKTS128TO255OCTETS_P7r_SIZE
typedef BCM89500_A0_PKTS128TO255OCTETS_P7r_t PKTS128TO255OCTETS_P7r_t;
#define PKTS128TO255OCTETS_P7r_CLR BCM89500_A0_PKTS128TO255OCTETS_P7r_CLR
#define PKTS128TO255OCTETS_P7r_SET BCM89500_A0_PKTS128TO255OCTETS_P7r_SET
#define PKTS128TO255OCTETS_P7r_GET BCM89500_A0_PKTS128TO255OCTETS_P7r_GET
#define READ_PKTS128TO255OCTETS_P7r BCM89500_A0_READ_PKTS128TO255OCTETS_P7r
#define WRITE_PKTS128TO255OCTETS_P7r BCM89500_A0_WRITE_PKTS128TO255OCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS128TO255OCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts256to511Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS256TO511OCTETSr 0x0000206c

#define BCM89500_A0_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets.
 *
 */
typedef union BCM89500_A0_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets[1];
	uint32_t _pkts256to511octets;
} BCM89500_A0_PKTS256TO511OCTETSr_t;

#define BCM89500_A0_PKTS256TO511OCTETSr_CLR(r) (r).pkts256to511octets[0] = 0
#define BCM89500_A0_PKTS256TO511OCTETSr_SET(r,d) (r).pkts256to511octets[0] = d
#define BCM89500_A0_PKTS256TO511OCTETSr_GET(r) (r).pkts256to511octets[0]


/*
 * These macros can be used to access Pkts256to511Octets.
 *
 */
#define BCM89500_A0_READ_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PKTS256TO511OCTETSr,(r._pkts256to511octets),4)
#define BCM89500_A0_WRITE_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PKTS256TO511OCTETSr,&(r._pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETSr BCM89500_A0_PKTS256TO511OCTETSr
#define PKTS256TO511OCTETSr_SIZE BCM89500_A0_PKTS256TO511OCTETSr_SIZE
typedef BCM89500_A0_PKTS256TO511OCTETSr_t PKTS256TO511OCTETSr_t;
#define PKTS256TO511OCTETSr_CLR BCM89500_A0_PKTS256TO511OCTETSr_CLR
#define PKTS256TO511OCTETSr_SET BCM89500_A0_PKTS256TO511OCTETSr_SET
#define PKTS256TO511OCTETSr_GET BCM89500_A0_PKTS256TO511OCTETSr_GET
#define READ_PKTS256TO511OCTETSr BCM89500_A0_READ_PKTS256TO511OCTETSr
#define WRITE_PKTS256TO511OCTETSr BCM89500_A0_WRITE_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts256to511Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS256TO511OCTETS_IMPr 0x0000286c

#define BCM89500_A0_PKTS256TO511OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets_IMP.
 *
 */
typedef union BCM89500_A0_PKTS256TO511OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets_imp[1];
	uint32_t _pkts256to511octets_imp;
} BCM89500_A0_PKTS256TO511OCTETS_IMPr_t;

#define BCM89500_A0_PKTS256TO511OCTETS_IMPr_CLR(r) (r).pkts256to511octets_imp[0] = 0
#define BCM89500_A0_PKTS256TO511OCTETS_IMPr_SET(r,d) (r).pkts256to511octets_imp[0] = d
#define BCM89500_A0_PKTS256TO511OCTETS_IMPr_GET(r) (r).pkts256to511octets_imp[0]


/*
 * These macros can be used to access Pkts256to511Octets_IMP.
 *
 */
#define BCM89500_A0_READ_PKTS256TO511OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS256TO511OCTETS_IMPr,(r._pkts256to511octets_imp),4)
#define BCM89500_A0_WRITE_PKTS256TO511OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS256TO511OCTETS_IMPr,&(r._pkts256to511octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETS_IMPr BCM89500_A0_PKTS256TO511OCTETS_IMPr
#define PKTS256TO511OCTETS_IMPr_SIZE BCM89500_A0_PKTS256TO511OCTETS_IMPr_SIZE
typedef BCM89500_A0_PKTS256TO511OCTETS_IMPr_t PKTS256TO511OCTETS_IMPr_t;
#define PKTS256TO511OCTETS_IMPr_CLR BCM89500_A0_PKTS256TO511OCTETS_IMPr_CLR
#define PKTS256TO511OCTETS_IMPr_SET BCM89500_A0_PKTS256TO511OCTETS_IMPr_SET
#define PKTS256TO511OCTETS_IMPr_GET BCM89500_A0_PKTS256TO511OCTETS_IMPr_GET
#define READ_PKTS256TO511OCTETS_IMPr BCM89500_A0_READ_PKTS256TO511OCTETS_IMPr
#define WRITE_PKTS256TO511OCTETS_IMPr BCM89500_A0_WRITE_PKTS256TO511OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS256TO511OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts256to511Octets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS256TO511OCTETS_P7r 0x0000276c

#define BCM89500_A0_PKTS256TO511OCTETS_P7r_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets_P7.
 *
 */
typedef union BCM89500_A0_PKTS256TO511OCTETS_P7r_s {
	uint32_t v[1];
	uint32_t pkts256to511octets_p7[1];
	uint32_t _pkts256to511octets_p7;
} BCM89500_A0_PKTS256TO511OCTETS_P7r_t;

#define BCM89500_A0_PKTS256TO511OCTETS_P7r_CLR(r) (r).pkts256to511octets_p7[0] = 0
#define BCM89500_A0_PKTS256TO511OCTETS_P7r_SET(r,d) (r).pkts256to511octets_p7[0] = d
#define BCM89500_A0_PKTS256TO511OCTETS_P7r_GET(r) (r).pkts256to511octets_p7[0]


/*
 * These macros can be used to access Pkts256to511Octets_P7.
 *
 */
#define BCM89500_A0_READ_PKTS256TO511OCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS256TO511OCTETS_P7r,(r._pkts256to511octets_p7),4)
#define BCM89500_A0_WRITE_PKTS256TO511OCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS256TO511OCTETS_P7r,&(r._pkts256to511octets_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETS_P7r BCM89500_A0_PKTS256TO511OCTETS_P7r
#define PKTS256TO511OCTETS_P7r_SIZE BCM89500_A0_PKTS256TO511OCTETS_P7r_SIZE
typedef BCM89500_A0_PKTS256TO511OCTETS_P7r_t PKTS256TO511OCTETS_P7r_t;
#define PKTS256TO511OCTETS_P7r_CLR BCM89500_A0_PKTS256TO511OCTETS_P7r_CLR
#define PKTS256TO511OCTETS_P7r_SET BCM89500_A0_PKTS256TO511OCTETS_P7r_SET
#define PKTS256TO511OCTETS_P7r_GET BCM89500_A0_PKTS256TO511OCTETS_P7r_GET
#define READ_PKTS256TO511OCTETS_P7r BCM89500_A0_READ_PKTS256TO511OCTETS_P7r
#define WRITE_PKTS256TO511OCTETS_P7r BCM89500_A0_WRITE_PKTS256TO511OCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS256TO511OCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts512to1023Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS512TO1023OCTETSr 0x00002070

#define BCM89500_A0_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets.
 *
 */
typedef union BCM89500_A0_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets[1];
	uint32_t _pkts512to1023octets;
} BCM89500_A0_PKTS512TO1023OCTETSr_t;

#define BCM89500_A0_PKTS512TO1023OCTETSr_CLR(r) (r).pkts512to1023octets[0] = 0
#define BCM89500_A0_PKTS512TO1023OCTETSr_SET(r,d) (r).pkts512to1023octets[0] = d
#define BCM89500_A0_PKTS512TO1023OCTETSr_GET(r) (r).pkts512to1023octets[0]


/*
 * These macros can be used to access Pkts512to1023Octets.
 *
 */
#define BCM89500_A0_READ_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PKTS512TO1023OCTETSr,(r._pkts512to1023octets),4)
#define BCM89500_A0_WRITE_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PKTS512TO1023OCTETSr,&(r._pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETSr BCM89500_A0_PKTS512TO1023OCTETSr
#define PKTS512TO1023OCTETSr_SIZE BCM89500_A0_PKTS512TO1023OCTETSr_SIZE
typedef BCM89500_A0_PKTS512TO1023OCTETSr_t PKTS512TO1023OCTETSr_t;
#define PKTS512TO1023OCTETSr_CLR BCM89500_A0_PKTS512TO1023OCTETSr_CLR
#define PKTS512TO1023OCTETSr_SET BCM89500_A0_PKTS512TO1023OCTETSr_SET
#define PKTS512TO1023OCTETSr_GET BCM89500_A0_PKTS512TO1023OCTETSr_GET
#define READ_PKTS512TO1023OCTETSr BCM89500_A0_READ_PKTS512TO1023OCTETSr
#define WRITE_PKTS512TO1023OCTETSr BCM89500_A0_WRITE_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts512to1023Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS512TO1023OCTETS_IMPr 0x00002870

#define BCM89500_A0_PKTS512TO1023OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets_IMP.
 *
 */
typedef union BCM89500_A0_PKTS512TO1023OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets_imp[1];
	uint32_t _pkts512to1023octets_imp;
} BCM89500_A0_PKTS512TO1023OCTETS_IMPr_t;

#define BCM89500_A0_PKTS512TO1023OCTETS_IMPr_CLR(r) (r).pkts512to1023octets_imp[0] = 0
#define BCM89500_A0_PKTS512TO1023OCTETS_IMPr_SET(r,d) (r).pkts512to1023octets_imp[0] = d
#define BCM89500_A0_PKTS512TO1023OCTETS_IMPr_GET(r) (r).pkts512to1023octets_imp[0]


/*
 * These macros can be used to access Pkts512to1023Octets_IMP.
 *
 */
#define BCM89500_A0_READ_PKTS512TO1023OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS512TO1023OCTETS_IMPr,(r._pkts512to1023octets_imp),4)
#define BCM89500_A0_WRITE_PKTS512TO1023OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS512TO1023OCTETS_IMPr,&(r._pkts512to1023octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETS_IMPr BCM89500_A0_PKTS512TO1023OCTETS_IMPr
#define PKTS512TO1023OCTETS_IMPr_SIZE BCM89500_A0_PKTS512TO1023OCTETS_IMPr_SIZE
typedef BCM89500_A0_PKTS512TO1023OCTETS_IMPr_t PKTS512TO1023OCTETS_IMPr_t;
#define PKTS512TO1023OCTETS_IMPr_CLR BCM89500_A0_PKTS512TO1023OCTETS_IMPr_CLR
#define PKTS512TO1023OCTETS_IMPr_SET BCM89500_A0_PKTS512TO1023OCTETS_IMPr_SET
#define PKTS512TO1023OCTETS_IMPr_GET BCM89500_A0_PKTS512TO1023OCTETS_IMPr_GET
#define READ_PKTS512TO1023OCTETS_IMPr BCM89500_A0_READ_PKTS512TO1023OCTETS_IMPr
#define WRITE_PKTS512TO1023OCTETS_IMPr BCM89500_A0_WRITE_PKTS512TO1023OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS512TO1023OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts512to1023Octets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS512TO1023OCTETS_P7r 0x00002770

#define BCM89500_A0_PKTS512TO1023OCTETS_P7r_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets_P7.
 *
 */
typedef union BCM89500_A0_PKTS512TO1023OCTETS_P7r_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets_p7[1];
	uint32_t _pkts512to1023octets_p7;
} BCM89500_A0_PKTS512TO1023OCTETS_P7r_t;

#define BCM89500_A0_PKTS512TO1023OCTETS_P7r_CLR(r) (r).pkts512to1023octets_p7[0] = 0
#define BCM89500_A0_PKTS512TO1023OCTETS_P7r_SET(r,d) (r).pkts512to1023octets_p7[0] = d
#define BCM89500_A0_PKTS512TO1023OCTETS_P7r_GET(r) (r).pkts512to1023octets_p7[0]


/*
 * These macros can be used to access Pkts512to1023Octets_P7.
 *
 */
#define BCM89500_A0_READ_PKTS512TO1023OCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS512TO1023OCTETS_P7r,(r._pkts512to1023octets_p7),4)
#define BCM89500_A0_WRITE_PKTS512TO1023OCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS512TO1023OCTETS_P7r,&(r._pkts512to1023octets_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETS_P7r BCM89500_A0_PKTS512TO1023OCTETS_P7r
#define PKTS512TO1023OCTETS_P7r_SIZE BCM89500_A0_PKTS512TO1023OCTETS_P7r_SIZE
typedef BCM89500_A0_PKTS512TO1023OCTETS_P7r_t PKTS512TO1023OCTETS_P7r_t;
#define PKTS512TO1023OCTETS_P7r_CLR BCM89500_A0_PKTS512TO1023OCTETS_P7r_CLR
#define PKTS512TO1023OCTETS_P7r_SET BCM89500_A0_PKTS512TO1023OCTETS_P7r_SET
#define PKTS512TO1023OCTETS_P7r_GET BCM89500_A0_PKTS512TO1023OCTETS_P7r_GET
#define READ_PKTS512TO1023OCTETS_P7r BCM89500_A0_READ_PKTS512TO1023OCTETS_P7r
#define WRITE_PKTS512TO1023OCTETS_P7r BCM89500_A0_WRITE_PKTS512TO1023OCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS512TO1023OCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts64Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS64OCTETSr 0x00002060

#define BCM89500_A0_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets.
 *
 */
typedef union BCM89500_A0_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts64octets[1];
	uint32_t _pkts64octets;
} BCM89500_A0_PKTS64OCTETSr_t;

#define BCM89500_A0_PKTS64OCTETSr_CLR(r) (r).pkts64octets[0] = 0
#define BCM89500_A0_PKTS64OCTETSr_SET(r,d) (r).pkts64octets[0] = d
#define BCM89500_A0_PKTS64OCTETSr_GET(r) (r).pkts64octets[0]


/*
 * These macros can be used to access Pkts64Octets.
 *
 */
#define BCM89500_A0_READ_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PKTS64OCTETSr,(r._pkts64octets),4)
#define BCM89500_A0_WRITE_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PKTS64OCTETSr,&(r._pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETSr BCM89500_A0_PKTS64OCTETSr
#define PKTS64OCTETSr_SIZE BCM89500_A0_PKTS64OCTETSr_SIZE
typedef BCM89500_A0_PKTS64OCTETSr_t PKTS64OCTETSr_t;
#define PKTS64OCTETSr_CLR BCM89500_A0_PKTS64OCTETSr_CLR
#define PKTS64OCTETSr_SET BCM89500_A0_PKTS64OCTETSr_SET
#define PKTS64OCTETSr_GET BCM89500_A0_PKTS64OCTETSr_GET
#define READ_PKTS64OCTETSr BCM89500_A0_READ_PKTS64OCTETSr
#define WRITE_PKTS64OCTETSr BCM89500_A0_WRITE_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts64Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS64OCTETS_IMPr 0x00002860

#define BCM89500_A0_PKTS64OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets_IMP.
 *
 */
typedef union BCM89500_A0_PKTS64OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts64octets_imp[1];
	uint32_t _pkts64octets_imp;
} BCM89500_A0_PKTS64OCTETS_IMPr_t;

#define BCM89500_A0_PKTS64OCTETS_IMPr_CLR(r) (r).pkts64octets_imp[0] = 0
#define BCM89500_A0_PKTS64OCTETS_IMPr_SET(r,d) (r).pkts64octets_imp[0] = d
#define BCM89500_A0_PKTS64OCTETS_IMPr_GET(r) (r).pkts64octets_imp[0]


/*
 * These macros can be used to access Pkts64Octets_IMP.
 *
 */
#define BCM89500_A0_READ_PKTS64OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS64OCTETS_IMPr,(r._pkts64octets_imp),4)
#define BCM89500_A0_WRITE_PKTS64OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS64OCTETS_IMPr,&(r._pkts64octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETS_IMPr BCM89500_A0_PKTS64OCTETS_IMPr
#define PKTS64OCTETS_IMPr_SIZE BCM89500_A0_PKTS64OCTETS_IMPr_SIZE
typedef BCM89500_A0_PKTS64OCTETS_IMPr_t PKTS64OCTETS_IMPr_t;
#define PKTS64OCTETS_IMPr_CLR BCM89500_A0_PKTS64OCTETS_IMPr_CLR
#define PKTS64OCTETS_IMPr_SET BCM89500_A0_PKTS64OCTETS_IMPr_SET
#define PKTS64OCTETS_IMPr_GET BCM89500_A0_PKTS64OCTETS_IMPr_GET
#define READ_PKTS64OCTETS_IMPr BCM89500_A0_READ_PKTS64OCTETS_IMPr
#define WRITE_PKTS64OCTETS_IMPr BCM89500_A0_WRITE_PKTS64OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS64OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts64Octets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS64OCTETS_P7r 0x00002760

#define BCM89500_A0_PKTS64OCTETS_P7r_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets_P7.
 *
 */
typedef union BCM89500_A0_PKTS64OCTETS_P7r_s {
	uint32_t v[1];
	uint32_t pkts64octets_p7[1];
	uint32_t _pkts64octets_p7;
} BCM89500_A0_PKTS64OCTETS_P7r_t;

#define BCM89500_A0_PKTS64OCTETS_P7r_CLR(r) (r).pkts64octets_p7[0] = 0
#define BCM89500_A0_PKTS64OCTETS_P7r_SET(r,d) (r).pkts64octets_p7[0] = d
#define BCM89500_A0_PKTS64OCTETS_P7r_GET(r) (r).pkts64octets_p7[0]


/*
 * These macros can be used to access Pkts64Octets_P7.
 *
 */
#define BCM89500_A0_READ_PKTS64OCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS64OCTETS_P7r,(r._pkts64octets_p7),4)
#define BCM89500_A0_WRITE_PKTS64OCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS64OCTETS_P7r,&(r._pkts64octets_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETS_P7r BCM89500_A0_PKTS64OCTETS_P7r
#define PKTS64OCTETS_P7r_SIZE BCM89500_A0_PKTS64OCTETS_P7r_SIZE
typedef BCM89500_A0_PKTS64OCTETS_P7r_t PKTS64OCTETS_P7r_t;
#define PKTS64OCTETS_P7r_CLR BCM89500_A0_PKTS64OCTETS_P7r_CLR
#define PKTS64OCTETS_P7r_SET BCM89500_A0_PKTS64OCTETS_P7r_SET
#define PKTS64OCTETS_P7r_GET BCM89500_A0_PKTS64OCTETS_P7r_GET
#define READ_PKTS64OCTETS_P7r BCM89500_A0_READ_PKTS64OCTETS_P7r
#define WRITE_PKTS64OCTETS_P7r BCM89500_A0_WRITE_PKTS64OCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS64OCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts65to127Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS65TO127OCTETSr 0x00002064

#define BCM89500_A0_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets.
 *
 */
typedef union BCM89500_A0_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets[1];
	uint32_t _pkts65to127octets;
} BCM89500_A0_PKTS65TO127OCTETSr_t;

#define BCM89500_A0_PKTS65TO127OCTETSr_CLR(r) (r).pkts65to127octets[0] = 0
#define BCM89500_A0_PKTS65TO127OCTETSr_SET(r,d) (r).pkts65to127octets[0] = d
#define BCM89500_A0_PKTS65TO127OCTETSr_GET(r) (r).pkts65to127octets[0]


/*
 * These macros can be used to access Pkts65to127Octets.
 *
 */
#define BCM89500_A0_READ_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_PKTS65TO127OCTETSr,(r._pkts65to127octets),4)
#define BCM89500_A0_WRITE_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_PKTS65TO127OCTETSr,&(r._pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETSr BCM89500_A0_PKTS65TO127OCTETSr
#define PKTS65TO127OCTETSr_SIZE BCM89500_A0_PKTS65TO127OCTETSr_SIZE
typedef BCM89500_A0_PKTS65TO127OCTETSr_t PKTS65TO127OCTETSr_t;
#define PKTS65TO127OCTETSr_CLR BCM89500_A0_PKTS65TO127OCTETSr_CLR
#define PKTS65TO127OCTETSr_SET BCM89500_A0_PKTS65TO127OCTETSr_SET
#define PKTS65TO127OCTETSr_GET BCM89500_A0_PKTS65TO127OCTETSr_GET
#define READ_PKTS65TO127OCTETSr BCM89500_A0_READ_PKTS65TO127OCTETSr
#define WRITE_PKTS65TO127OCTETSr BCM89500_A0_WRITE_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts65to127Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS65TO127OCTETS_IMPr 0x00002864

#define BCM89500_A0_PKTS65TO127OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets_IMP.
 *
 */
typedef union BCM89500_A0_PKTS65TO127OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets_imp[1];
	uint32_t _pkts65to127octets_imp;
} BCM89500_A0_PKTS65TO127OCTETS_IMPr_t;

#define BCM89500_A0_PKTS65TO127OCTETS_IMPr_CLR(r) (r).pkts65to127octets_imp[0] = 0
#define BCM89500_A0_PKTS65TO127OCTETS_IMPr_SET(r,d) (r).pkts65to127octets_imp[0] = d
#define BCM89500_A0_PKTS65TO127OCTETS_IMPr_GET(r) (r).pkts65to127octets_imp[0]


/*
 * These macros can be used to access Pkts65to127Octets_IMP.
 *
 */
#define BCM89500_A0_READ_PKTS65TO127OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS65TO127OCTETS_IMPr,(r._pkts65to127octets_imp),4)
#define BCM89500_A0_WRITE_PKTS65TO127OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS65TO127OCTETS_IMPr,&(r._pkts65to127octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETS_IMPr BCM89500_A0_PKTS65TO127OCTETS_IMPr
#define PKTS65TO127OCTETS_IMPr_SIZE BCM89500_A0_PKTS65TO127OCTETS_IMPr_SIZE
typedef BCM89500_A0_PKTS65TO127OCTETS_IMPr_t PKTS65TO127OCTETS_IMPr_t;
#define PKTS65TO127OCTETS_IMPr_CLR BCM89500_A0_PKTS65TO127OCTETS_IMPr_CLR
#define PKTS65TO127OCTETS_IMPr_SET BCM89500_A0_PKTS65TO127OCTETS_IMPr_SET
#define PKTS65TO127OCTETS_IMPr_GET BCM89500_A0_PKTS65TO127OCTETS_IMPr_GET
#define READ_PKTS65TO127OCTETS_IMPr BCM89500_A0_READ_PKTS65TO127OCTETS_IMPr
#define WRITE_PKTS65TO127OCTETS_IMPr BCM89500_A0_WRITE_PKTS65TO127OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS65TO127OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  Pkts65to127Octets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_PKTS65TO127OCTETS_P7r 0x00002764

#define BCM89500_A0_PKTS65TO127OCTETS_P7r_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets_P7.
 *
 */
typedef union BCM89500_A0_PKTS65TO127OCTETS_P7r_s {
	uint32_t v[1];
	uint32_t pkts65to127octets_p7[1];
	uint32_t _pkts65to127octets_p7;
} BCM89500_A0_PKTS65TO127OCTETS_P7r_t;

#define BCM89500_A0_PKTS65TO127OCTETS_P7r_CLR(r) (r).pkts65to127octets_p7[0] = 0
#define BCM89500_A0_PKTS65TO127OCTETS_P7r_SET(r,d) (r).pkts65to127octets_p7[0] = d
#define BCM89500_A0_PKTS65TO127OCTETS_P7r_GET(r) (r).pkts65to127octets_p7[0]


/*
 * These macros can be used to access Pkts65to127Octets_P7.
 *
 */
#define BCM89500_A0_READ_PKTS65TO127OCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_PKTS65TO127OCTETS_P7r,(r._pkts65to127octets_p7),4)
#define BCM89500_A0_WRITE_PKTS65TO127OCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_PKTS65TO127OCTETS_P7r,&(r._pkts65to127octets_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETS_P7r BCM89500_A0_PKTS65TO127OCTETS_P7r
#define PKTS65TO127OCTETS_P7r_SIZE BCM89500_A0_PKTS65TO127OCTETS_P7r_SIZE
typedef BCM89500_A0_PKTS65TO127OCTETS_P7r_t PKTS65TO127OCTETS_P7r_t;
#define PKTS65TO127OCTETS_P7r_CLR BCM89500_A0_PKTS65TO127OCTETS_P7r_CLR
#define PKTS65TO127OCTETS_P7r_SET BCM89500_A0_PKTS65TO127OCTETS_P7r_SET
#define PKTS65TO127OCTETS_P7r_GET BCM89500_A0_PKTS65TO127OCTETS_P7r_GET
#define READ_PKTS65TO127OCTETS_P7r BCM89500_A0_READ_PKTS65TO127OCTETS_P7r
#define WRITE_PKTS65TO127OCTETS_P7r BCM89500_A0_WRITE_PKTS65TO127OCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_PKTS65TO127OCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_1P_EN
 * BLOCKS:   SYS
 * DESC:     QoS 802.1P Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_1P_EN        Enable 802.1p priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_1P_ENr 0x00003004

#define BCM89500_A0_QOS_1P_ENr_SIZE 2

/*
 * This structure should be used to declare and program QOS_1P_EN.
 *
 */
typedef union BCM89500_A0_QOS_1P_ENr_s {
	uint32_t v[1];
	uint32_t qos_1p_en[1];
	uint32_t _qos_1p_en;
} BCM89500_A0_QOS_1P_ENr_t;

#define BCM89500_A0_QOS_1P_ENr_CLR(r) (r).qos_1p_en[0] = 0
#define BCM89500_A0_QOS_1P_ENr_SET(r,d) (r).qos_1p_en[0] = d
#define BCM89500_A0_QOS_1P_ENr_GET(r) (r).qos_1p_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_1P_ENr_QOS_1P_ENf_GET(r) (((r).qos_1p_en[0]) & 0x1ff)
#define BCM89500_A0_QOS_1P_ENr_QOS_1P_ENf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_QOS_1P_ENr_RESERVEDf_GET(r) ((((r).qos_1p_en[0]) >> 9) & 0x7f)
#define BCM89500_A0_QOS_1P_ENr_RESERVEDf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_1P_EN.
 *
 */
#define BCM89500_A0_READ_QOS_1P_ENr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_1P_ENr,(r._qos_1p_en),2)
#define BCM89500_A0_WRITE_QOS_1P_ENr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_1P_ENr,&(r._qos_1p_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P_ENr BCM89500_A0_QOS_1P_ENr
#define QOS_1P_ENr_SIZE BCM89500_A0_QOS_1P_ENr_SIZE
typedef BCM89500_A0_QOS_1P_ENr_t QOS_1P_ENr_t;
#define QOS_1P_ENr_CLR BCM89500_A0_QOS_1P_ENr_CLR
#define QOS_1P_ENr_SET BCM89500_A0_QOS_1P_ENr_SET
#define QOS_1P_ENr_GET BCM89500_A0_QOS_1P_ENr_GET
#define QOS_1P_ENr_QOS_1P_ENf_GET BCM89500_A0_QOS_1P_ENr_QOS_1P_ENf_GET
#define QOS_1P_ENr_QOS_1P_ENf_SET BCM89500_A0_QOS_1P_ENr_QOS_1P_ENf_SET
#define QOS_1P_ENr_RESERVEDf_GET BCM89500_A0_QOS_1P_ENr_RESERVEDf_GET
#define QOS_1P_ENr_RESERVEDf_SET BCM89500_A0_QOS_1P_ENr_RESERVEDf_SET
#define READ_QOS_1P_ENr BCM89500_A0_READ_QOS_1P_ENr
#define WRITE_QOS_1P_ENr BCM89500_A0_WRITE_QOS_1P_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_1P_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_DIFF_DSCP0
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 0 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_000000  DiffServ DSCP== 000000 to Priority ID map Register.
 *     PRI_DSCP_000001  DiffServ DSCP== 000001 to Priority ID map Register.
 *     PRI_DSCP_000010  DiffServ DSCP== 000010 to Priority ID map Register.
 *     PRI_DSCP_000011  DiffServ DSCP== 000011 to Priority ID map Register.
 *     PRI_DSCP_000100  DiffServ DSCP== 000100 to Priority ID map Register.
 *     PRI_DSCP_000101  DiffServ DSCP== 000101 to Priority ID map Register.
 *     PRI_DSCP_000110  DiffServ DSCP== 000110 to Priority ID map Register.
 *     PRI_DSCP_000111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_001000  DiffServ DSCP== 001000 to Priority ID map Register.
 *     PRI_DSCP_001001  DiffServ DSCP== 001001 to Priority ID map Register.
 *     PRI_DSCP_001010  DiffServ DSCP== 001010 to Priority ID map Register.
 *     PRI_DSCP_001011  DiffServ DSCP== 001011 to Priority ID map Register.
 *     PRI_DSCP_001100  DiffServ DSCP== 001100 to Priority ID map Register.
 *     PRI_DSCP_001101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_001110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_001111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_DIFF_DSCP0r 0x00003030

#define BCM89500_A0_QOS_DIFF_DSCP0r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP0.
 *
 */
typedef union BCM89500_A0_QOS_DIFF_DSCP0r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp0[2];
	uint32_t _qos_diff_dscp0;
} BCM89500_A0_QOS_DIFF_DSCP0r_t;

#define BCM89500_A0_QOS_DIFF_DSCP0r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp0), 0, sizeof(BCM89500_A0_QOS_DIFF_DSCP0r_t))
#define BCM89500_A0_QOS_DIFF_DSCP0r_SET(r,i,d) (r).qos_diff_dscp0[i] = d
#define BCM89500_A0_QOS_DIFF_DSCP0r_GET(r,i) (r).qos_diff_dscp0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET(r) (((r).qos_diff_dscp0[0]) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 3) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET(r) ((((r).qos_diff_dscp0[0]) >> 6) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET(r) ((((r).qos_diff_dscp0[0]) >> 9) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET(r) ((((r).qos_diff_dscp0[0]) >> 12) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET(r) ((((r).qos_diff_dscp0[0]) >> 15) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET(r) ((((r).qos_diff_dscp0[0]) >> 18) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET(r) ((((r).qos_diff_dscp0[0]) >> 21) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET(r) ((((r).qos_diff_dscp0[0]) >> 24) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 27) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET(r) cdk_field32_get((r).qos_diff_dscp0,30,32)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp0,30,32,f)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET(r) ((((r).qos_diff_dscp0[1]) >> 1) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET(r) ((((r).qos_diff_dscp0[1]) >> 4) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET(r) ((((r).qos_diff_dscp0[1]) >> 7) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET(r) ((((r).qos_diff_dscp0[1]) >> 10) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET(r) ((((r).qos_diff_dscp0[1]) >> 13) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP0.
 *
 */
#define BCM89500_A0_READ_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_DIFF_DSCP0r,(r._qos_diff_dscp0),6)
#define BCM89500_A0_WRITE_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_DIFF_DSCP0r,&(r._qos_diff_dscp0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP0r BCM89500_A0_QOS_DIFF_DSCP0r
#define QOS_DIFF_DSCP0r_SIZE BCM89500_A0_QOS_DIFF_DSCP0r_SIZE
typedef BCM89500_A0_QOS_DIFF_DSCP0r_t QOS_DIFF_DSCP0r_t;
#define QOS_DIFF_DSCP0r_CLR BCM89500_A0_QOS_DIFF_DSCP0r_CLR
#define QOS_DIFF_DSCP0r_SET BCM89500_A0_QOS_DIFF_DSCP0r_SET
#define QOS_DIFF_DSCP0r_GET BCM89500_A0_QOS_DIFF_DSCP0r_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET BCM89500_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET
#define READ_QOS_DIFF_DSCP0r BCM89500_A0_READ_QOS_DIFF_DSCP0r
#define WRITE_QOS_DIFF_DSCP0r BCM89500_A0_WRITE_QOS_DIFF_DSCP0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_DIFF_DSCP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_DIFF_DSCP1
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 1 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_010000  DiffServ DSCP== 010000 to Priority ID map Register.
 *     PRI_DSCP_010001  DiffServ DSCP== 010001 to Priority ID map Register.
 *     PRI_DSCP_010010  DiffServ DSCP== 010010 to Priority ID map Register.
 *     PRI_DSCP_010011  DiffServ DSCP== 010011 to Priority ID map Register.
 *     PRI_DSCP_010100  DiffServ DSCP== 010100 to Priority ID map Register.
 *     PRI_DSCP_010101  DiffServ DSCP== 010101 to Priority ID map Register.
 *     PRI_DSCP_010110  DiffServ DSCP== 010110 to Priority ID map Register.
 *     PRI_DSCP_010111  DiffServ DSCP== 010111 to Priority ID map Register.
 *     PRI_DSCP_011000  DiffServ DSCP== 011000 to Priority ID map Register.
 *     PRI_DSCP_011001  DiffServ DSCP== 011001 to Priority ID map Register.
 *     PRI_DSCP_011010  DiffServ DSCP== 011010 to Priority ID map Register.
 *     PRI_DSCP_011011  DiffServ DSCP== 011011 to Priority ID map Register.
 *     PRI_DSCP_011100  DiffServ DSCP== 011100 to Priority ID map Register.
 *     PRI_DSCP_011101  DiffServ DSCP== 011101 to Priority ID map Register.
 *     PRI_DSCP_011110  DiffServ DSCP== 011110 to Priority ID map Register.
 *     PRI_DSCP_011111  DiffServ DSCP== 011111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_DIFF_DSCP1r 0x00003036

#define BCM89500_A0_QOS_DIFF_DSCP1r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP1.
 *
 */
typedef union BCM89500_A0_QOS_DIFF_DSCP1r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp1[2];
	uint32_t _qos_diff_dscp1;
} BCM89500_A0_QOS_DIFF_DSCP1r_t;

#define BCM89500_A0_QOS_DIFF_DSCP1r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp1), 0, sizeof(BCM89500_A0_QOS_DIFF_DSCP1r_t))
#define BCM89500_A0_QOS_DIFF_DSCP1r_SET(r,i,d) (r).qos_diff_dscp1[i] = d
#define BCM89500_A0_QOS_DIFF_DSCP1r_GET(r,i) (r).qos_diff_dscp1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET(r) (((r).qos_diff_dscp1[0]) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 3) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 6) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 9) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 12) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 15) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 18) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 21) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET(r) ((((r).qos_diff_dscp1[0]) >> 24) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 27) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET(r) cdk_field32_get((r).qos_diff_dscp1,30,32)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp1,30,32,f)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 1) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 4) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 7) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 10) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 13) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP1.
 *
 */
#define BCM89500_A0_READ_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_DIFF_DSCP1r,(r._qos_diff_dscp1),6)
#define BCM89500_A0_WRITE_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_DIFF_DSCP1r,&(r._qos_diff_dscp1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP1r BCM89500_A0_QOS_DIFF_DSCP1r
#define QOS_DIFF_DSCP1r_SIZE BCM89500_A0_QOS_DIFF_DSCP1r_SIZE
typedef BCM89500_A0_QOS_DIFF_DSCP1r_t QOS_DIFF_DSCP1r_t;
#define QOS_DIFF_DSCP1r_CLR BCM89500_A0_QOS_DIFF_DSCP1r_CLR
#define QOS_DIFF_DSCP1r_SET BCM89500_A0_QOS_DIFF_DSCP1r_SET
#define QOS_DIFF_DSCP1r_GET BCM89500_A0_QOS_DIFF_DSCP1r_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET BCM89500_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET
#define READ_QOS_DIFF_DSCP1r BCM89500_A0_READ_QOS_DIFF_DSCP1r
#define WRITE_QOS_DIFF_DSCP1r BCM89500_A0_WRITE_QOS_DIFF_DSCP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_DIFF_DSCP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_DIFF_DSCP2
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 2 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_100000  DiffServ DSCP== 100000 to Priority ID map Register.
 *     PRI_DSCP_100001  DiffServ DSCP== 100001 to Priority ID map Register.
 *     PRI_DSCP_100010  DiffServ DSCP== 100010 to Priority ID map Register.
 *     PRI_DSCP_100011  DiffServ DSCP== 100011 to Priority ID map Register.
 *     PRI_DSCP_100100  DiffServ DSCP== 100100 to Priority ID map Register.
 *     PRI_DSCP_100101  DiffServ DSCP== 100101 to Priority ID map Register.
 *     PRI_DSCP_100110  DiffServ DSCP== 100110 to Priority ID map Register.
 *     PRI_DSCP_100111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_101000  DiffServ DSCP== 101000 to Priority ID map Register.
 *     PRI_DSCP_101001  DiffServ DSCP== 101001 to Priority ID map Register.
 *     PRI_DSCP_101010  DiffServ DSCP== 101010 to Priority ID map Register.
 *     PRI_DSCP_101011  DiffServ DSCP== 101011 to Priority ID map Register.
 *     PRI_DSCP_101100  DiffServ DSCP== 101100 to Priority ID map Register.
 *     PRI_DSCP_101101  DiffServ DSCP== 101101 to Priority ID map Register.
 *     PRI_DSCP_101110  DiffServ DSCP== 101110 to Priority ID map Register.
 *     PRI_DSCP_101111  DiffServ DSCP== 101111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_DIFF_DSCP2r 0x0000303c

#define BCM89500_A0_QOS_DIFF_DSCP2r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP2.
 *
 */
typedef union BCM89500_A0_QOS_DIFF_DSCP2r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp2[2];
	uint32_t _qos_diff_dscp2;
} BCM89500_A0_QOS_DIFF_DSCP2r_t;

#define BCM89500_A0_QOS_DIFF_DSCP2r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp2), 0, sizeof(BCM89500_A0_QOS_DIFF_DSCP2r_t))
#define BCM89500_A0_QOS_DIFF_DSCP2r_SET(r,i,d) (r).qos_diff_dscp2[i] = d
#define BCM89500_A0_QOS_DIFF_DSCP2r_GET(r,i) (r).qos_diff_dscp2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET(r) (((r).qos_diff_dscp2[0]) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 3) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 6) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 9) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 12) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 15) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 18) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 21) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET(r) ((((r).qos_diff_dscp2[0]) >> 24) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 27) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET(r) cdk_field32_get((r).qos_diff_dscp2,30,32)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp2,30,32,f)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 1) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 4) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 7) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 10) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 13) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP2.
 *
 */
#define BCM89500_A0_READ_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_DIFF_DSCP2r,(r._qos_diff_dscp2),6)
#define BCM89500_A0_WRITE_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_DIFF_DSCP2r,&(r._qos_diff_dscp2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP2r BCM89500_A0_QOS_DIFF_DSCP2r
#define QOS_DIFF_DSCP2r_SIZE BCM89500_A0_QOS_DIFF_DSCP2r_SIZE
typedef BCM89500_A0_QOS_DIFF_DSCP2r_t QOS_DIFF_DSCP2r_t;
#define QOS_DIFF_DSCP2r_CLR BCM89500_A0_QOS_DIFF_DSCP2r_CLR
#define QOS_DIFF_DSCP2r_SET BCM89500_A0_QOS_DIFF_DSCP2r_SET
#define QOS_DIFF_DSCP2r_GET BCM89500_A0_QOS_DIFF_DSCP2r_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET BCM89500_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET
#define READ_QOS_DIFF_DSCP2r BCM89500_A0_READ_QOS_DIFF_DSCP2r
#define WRITE_QOS_DIFF_DSCP2r BCM89500_A0_WRITE_QOS_DIFF_DSCP2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_DIFF_DSCP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_DIFF_DSCP3
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 3 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_110000  DiffServ DSCP== 110000 to Priority ID map Register.
 *     PRI_DSCP_110001  DiffServ DSCP== 110001 to Priority ID map Register.
 *     PRI_DSCP_110010  DiffServ DSCP== 110010 to Priority ID map Register.
 *     PRI_DSCP_110011  DiffServ DSCP== 110011 to Priority ID map Register.
 *     PRI_DSCP_110100  DiffServ DSCP== 110100 to Priority ID map Register.
 *     PRI_DSCP_110101  DiffServ DSCP== 110101 to Priority ID map Register.
 *     PRI_DSCP_110110  DiffServ DSCP== 110110 to Priority ID map Register.
 *     PRI_DSCP_110111  DiffServ DSCP== 110111 to Priority ID map Register.
 *     PRI_DSCP_111000  DiffServ DSCP== 111000 to Priority ID map Register.
 *     PRI_DSCP_111001  DiffServ DSCP== 111001 to Priority ID map Register.
 *     PRI_DSCP_111010  DiffServ DSCP== 111010 to Priority ID map Register.
 *     PRI_DSCP_111011  DiffServ DSCP== 111011 to Priority ID map Register.
 *     PRI_DSCP_111100  DiffServ DSCP== 111100 to Priority ID map Register.
 *     PRI_DSCP_111101  DiffServ DSCP== 111101 to Priority ID map Register.
 *     PRI_DSCP_111110  DiffServ DSCP== 111110 to Priority ID map Register.
 *     PRI_DSCP_111111  DiffServ DSCP== 111111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_DIFF_DSCP3r 0x00003042

#define BCM89500_A0_QOS_DIFF_DSCP3r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP3.
 *
 */
typedef union BCM89500_A0_QOS_DIFF_DSCP3r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp3[2];
	uint32_t _qos_diff_dscp3;
} BCM89500_A0_QOS_DIFF_DSCP3r_t;

#define BCM89500_A0_QOS_DIFF_DSCP3r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp3), 0, sizeof(BCM89500_A0_QOS_DIFF_DSCP3r_t))
#define BCM89500_A0_QOS_DIFF_DSCP3r_SET(r,i,d) (r).qos_diff_dscp3[i] = d
#define BCM89500_A0_QOS_DIFF_DSCP3r_GET(r,i) (r).qos_diff_dscp3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET(r) (((r).qos_diff_dscp3[0]) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 3) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET(r) ((((r).qos_diff_dscp3[0]) >> 6) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET(r) ((((r).qos_diff_dscp3[0]) >> 9) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET(r) ((((r).qos_diff_dscp3[0]) >> 12) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET(r) ((((r).qos_diff_dscp3[0]) >> 15) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET(r) ((((r).qos_diff_dscp3[0]) >> 18) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET(r) ((((r).qos_diff_dscp3[0]) >> 21) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET(r) ((((r).qos_diff_dscp3[0]) >> 24) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 27) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET(r) cdk_field32_get((r).qos_diff_dscp3,30,32)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp3,30,32,f)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET(r) ((((r).qos_diff_dscp3[1]) >> 1) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET(r) ((((r).qos_diff_dscp3[1]) >> 4) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET(r) ((((r).qos_diff_dscp3[1]) >> 7) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET(r) ((((r).qos_diff_dscp3[1]) >> 10) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET(r) ((((r).qos_diff_dscp3[1]) >> 13) & 0x7)
#define BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP3.
 *
 */
#define BCM89500_A0_READ_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_DIFF_DSCP3r,(r._qos_diff_dscp3),6)
#define BCM89500_A0_WRITE_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_DIFF_DSCP3r,&(r._qos_diff_dscp3),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP3r BCM89500_A0_QOS_DIFF_DSCP3r
#define QOS_DIFF_DSCP3r_SIZE BCM89500_A0_QOS_DIFF_DSCP3r_SIZE
typedef BCM89500_A0_QOS_DIFF_DSCP3r_t QOS_DIFF_DSCP3r_t;
#define QOS_DIFF_DSCP3r_CLR BCM89500_A0_QOS_DIFF_DSCP3r_CLR
#define QOS_DIFF_DSCP3r_SET BCM89500_A0_QOS_DIFF_DSCP3r_SET
#define QOS_DIFF_DSCP3r_GET BCM89500_A0_QOS_DIFF_DSCP3r_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET BCM89500_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET
#define READ_QOS_DIFF_DSCP3r BCM89500_A0_READ_QOS_DIFF_DSCP3r
#define WRITE_QOS_DIFF_DSCP3r BCM89500_A0_WRITE_QOS_DIFF_DSCP3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_DIFF_DSCP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_EN_DIFFSERV
 * BLOCKS:   SYS
 * DESC:     QOS DiffServ Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_EN_DIFFSERV  Enable DiffServ priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_EN_DIFFSERVr 0x00003006

#define BCM89500_A0_QOS_EN_DIFFSERVr_SIZE 2

/*
 * This structure should be used to declare and program QOS_EN_DIFFSERV.
 *
 */
typedef union BCM89500_A0_QOS_EN_DIFFSERVr_s {
	uint32_t v[1];
	uint32_t qos_en_diffserv[1];
	uint32_t _qos_en_diffserv;
} BCM89500_A0_QOS_EN_DIFFSERVr_t;

#define BCM89500_A0_QOS_EN_DIFFSERVr_CLR(r) (r).qos_en_diffserv[0] = 0
#define BCM89500_A0_QOS_EN_DIFFSERVr_SET(r,d) (r).qos_en_diffserv[0] = d
#define BCM89500_A0_QOS_EN_DIFFSERVr_GET(r) (r).qos_en_diffserv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET(r) (((r).qos_en_diffserv[0]) & 0x1ff)
#define BCM89500_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_QOS_EN_DIFFSERVr_RESERVEDf_GET(r) ((((r).qos_en_diffserv[0]) >> 9) & 0x7f)
#define BCM89500_A0_QOS_EN_DIFFSERVr_RESERVEDf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_EN_DIFFSERV.
 *
 */
#define BCM89500_A0_READ_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_EN_DIFFSERVr,(r._qos_en_diffserv),2)
#define BCM89500_A0_WRITE_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_EN_DIFFSERVr,&(r._qos_en_diffserv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_EN_DIFFSERVr BCM89500_A0_QOS_EN_DIFFSERVr
#define QOS_EN_DIFFSERVr_SIZE BCM89500_A0_QOS_EN_DIFFSERVr_SIZE
typedef BCM89500_A0_QOS_EN_DIFFSERVr_t QOS_EN_DIFFSERVr_t;
#define QOS_EN_DIFFSERVr_CLR BCM89500_A0_QOS_EN_DIFFSERVr_CLR
#define QOS_EN_DIFFSERVr_SET BCM89500_A0_QOS_EN_DIFFSERVr_SET
#define QOS_EN_DIFFSERVr_GET BCM89500_A0_QOS_EN_DIFFSERVr_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET BCM89500_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET BCM89500_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET
#define QOS_EN_DIFFSERVr_RESERVEDf_GET BCM89500_A0_QOS_EN_DIFFSERVr_RESERVEDf_GET
#define QOS_EN_DIFFSERVr_RESERVEDf_SET BCM89500_A0_QOS_EN_DIFFSERVr_RESERVEDf_SET
#define READ_QOS_EN_DIFFSERVr BCM89500_A0_READ_QOS_EN_DIFFSERVr
#define WRITE_QOS_EN_DIFFSERVr BCM89500_A0_WRITE_QOS_EN_DIFFSERVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_EN_DIFFSERVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QOS_GLOBAL_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS Global Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     P5_AGGREGATION_MODE (polar feature)When set the Port5 operated as the uplink port to the upstream network processor and the COS is decided from the TC based the normal packet classification flow. Otherwise, the Port5 operates as the interface to the management CPU, and the COS is decided based on the reasons for forwarding the packet to the CPU.
 *     RESERVED_1       Reserved
 *     P8_AGGREGATION_MODE When set the IMP operated as the uplink port to the upstream network processor and the COS is decided from the TC based the normal packet classification flow. Otherwise, the IMP operates as the interface to the management CPU, and the COS is decided based on the reasons for forwarding the packet to the CPU.
 *
 ******************************************************************************/
#define BCM89500_A0_QOS_GLOBAL_CTRLr 0x00003000

#define BCM89500_A0_QOS_GLOBAL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_GLOBAL_CTRL.
 *
 */
typedef union BCM89500_A0_QOS_GLOBAL_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_global_ctrl[1];
	uint32_t _qos_global_ctrl;
} BCM89500_A0_QOS_GLOBAL_CTRLr_t;

#define BCM89500_A0_QOS_GLOBAL_CTRLr_CLR(r) (r).qos_global_ctrl[0] = 0
#define BCM89500_A0_QOS_GLOBAL_CTRLr_SET(r,d) (r).qos_global_ctrl[0] = d
#define BCM89500_A0_QOS_GLOBAL_CTRLr_GET(r) (r).qos_global_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_GET(r) (((r).qos_global_ctrl[0]) & 0xf)
#define BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_QOS_GLOBAL_CTRLr_P5_AGGREGATION_MODEf_GET(r) ((((r).qos_global_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_QOS_GLOBAL_CTRLr_P5_AGGREGATION_MODEf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_1f_GET(r) ((((r).qos_global_ctrl[0]) >> 5) & 0x3)
#define BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_1f_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM89500_A0_QOS_GLOBAL_CTRLr_P8_AGGREGATION_MODEf_GET(r) ((((r).qos_global_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_QOS_GLOBAL_CTRLr_P8_AGGREGATION_MODEf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access QOS_GLOBAL_CTRL.
 *
 */
#define BCM89500_A0_READ_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QOS_GLOBAL_CTRLr,(r._qos_global_ctrl),1)
#define BCM89500_A0_WRITE_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QOS_GLOBAL_CTRLr,&(r._qos_global_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_GLOBAL_CTRLr BCM89500_A0_QOS_GLOBAL_CTRLr
#define QOS_GLOBAL_CTRLr_SIZE BCM89500_A0_QOS_GLOBAL_CTRLr_SIZE
typedef BCM89500_A0_QOS_GLOBAL_CTRLr_t QOS_GLOBAL_CTRLr_t;
#define QOS_GLOBAL_CTRLr_CLR BCM89500_A0_QOS_GLOBAL_CTRLr_CLR
#define QOS_GLOBAL_CTRLr_SET BCM89500_A0_QOS_GLOBAL_CTRLr_SET
#define QOS_GLOBAL_CTRLr_GET BCM89500_A0_QOS_GLOBAL_CTRLr_GET
#define QOS_GLOBAL_CTRLr_RESERVED_0f_GET BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_GET
#define QOS_GLOBAL_CTRLr_RESERVED_0f_SET BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_SET
#define QOS_GLOBAL_CTRLr_P5_AGGREGATION_MODEf_GET BCM89500_A0_QOS_GLOBAL_CTRLr_P5_AGGREGATION_MODEf_GET
#define QOS_GLOBAL_CTRLr_P5_AGGREGATION_MODEf_SET BCM89500_A0_QOS_GLOBAL_CTRLr_P5_AGGREGATION_MODEf_SET
#define QOS_GLOBAL_CTRLr_RESERVED_1f_GET BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_1f_GET
#define QOS_GLOBAL_CTRLr_RESERVED_1f_SET BCM89500_A0_QOS_GLOBAL_CTRLr_RESERVED_1f_SET
#define QOS_GLOBAL_CTRLr_P8_AGGREGATION_MODEf_GET BCM89500_A0_QOS_GLOBAL_CTRLr_P8_AGGREGATION_MODEf_GET
#define QOS_GLOBAL_CTRLr_P8_AGGREGATION_MODEf_SET BCM89500_A0_QOS_GLOBAL_CTRLr_P8_AGGREGATION_MODEf_SET
#define READ_QOS_GLOBAL_CTRLr BCM89500_A0_READ_QOS_GLOBAL_CTRLr
#define WRITE_QOS_GLOBAL_CTRLr BCM89500_A0_WRITE_QOS_GLOBAL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QOS_GLOBAL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QUEUE4_AVB_SHAPING_MODE
 * BLOCKS:   SYS
 * DESC:     Queue 4 AVB Shaping Mode Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QUEUE4_AVB_SHAPING_MODE Enable/Disable queue 4 AVB Shaping mode for each egress port.0: Disable AVB Shaping mode1: Enable AVB Shaping modebit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr 0x00003704

#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_SIZE 2

/*
 * This structure should be used to declare and program QUEUE4_AVB_SHAPING_MODE.
 *
 */
typedef union BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_s {
	uint32_t v[1];
	uint32_t queue4_avb_shaping_mode[1];
	uint32_t _queue4_avb_shaping_mode;
} BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_t;

#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_CLR(r) (r).queue4_avb_shaping_mode[0] = 0
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_SET(r,d) (r).queue4_avb_shaping_mode[0] = d
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_GET(r) (r).queue4_avb_shaping_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_QUEUE4_AVB_SHAPING_MODEf_GET(r) (((r).queue4_avb_shaping_mode[0]) & 0x1ff)
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_QUEUE4_AVB_SHAPING_MODEf_SET(r,f) (r).queue4_avb_shaping_mode[0]=(((r).queue4_avb_shaping_mode[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_RESERVEDf_GET(r) ((((r).queue4_avb_shaping_mode[0]) >> 9) & 0x7f)
#define BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_RESERVEDf_SET(r,f) (r).queue4_avb_shaping_mode[0]=(((r).queue4_avb_shaping_mode[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QUEUE4_AVB_SHAPING_MODE.
 *
 */
#define BCM89500_A0_READ_QUEUE4_AVB_SHAPING_MODEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr,(r._queue4_avb_shaping_mode),2)
#define BCM89500_A0_WRITE_QUEUE4_AVB_SHAPING_MODEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr,&(r._queue4_avb_shaping_mode),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE4_AVB_SHAPING_MODEr BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr
#define QUEUE4_AVB_SHAPING_MODEr_SIZE BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_SIZE
typedef BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_t QUEUE4_AVB_SHAPING_MODEr_t;
#define QUEUE4_AVB_SHAPING_MODEr_CLR BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_CLR
#define QUEUE4_AVB_SHAPING_MODEr_SET BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_SET
#define QUEUE4_AVB_SHAPING_MODEr_GET BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_GET
#define QUEUE4_AVB_SHAPING_MODEr_QUEUE4_AVB_SHAPING_MODEf_GET BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_QUEUE4_AVB_SHAPING_MODEf_GET
#define QUEUE4_AVB_SHAPING_MODEr_QUEUE4_AVB_SHAPING_MODEf_SET BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_QUEUE4_AVB_SHAPING_MODEf_SET
#define QUEUE4_AVB_SHAPING_MODEr_RESERVEDf_GET BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_RESERVEDf_GET
#define QUEUE4_AVB_SHAPING_MODEr_RESERVEDf_SET BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr_RESERVEDf_SET
#define READ_QUEUE4_AVB_SHAPING_MODEr BCM89500_A0_READ_QUEUE4_AVB_SHAPING_MODEr
#define WRITE_QUEUE4_AVB_SHAPING_MODEr BCM89500_A0_WRITE_QUEUE4_AVB_SHAPING_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QUEUE4_AVB_SHAPING_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QUEUE4_SHAPER_ENABLE
 * BLOCKS:   SYS
 * DESC:     Queue 4 Shaper Enable Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QUEUE4_SHAPER_ENABLE Enable/Disable queue 4 Shaper for each egress port.0: Disable Shaper1: Enable Shaperbit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr 0x00003712

#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_SIZE 2

/*
 * This structure should be used to declare and program QUEUE4_SHAPER_ENABLE.
 *
 */
typedef union BCM89500_A0_QUEUE4_SHAPER_ENABLEr_s {
	uint32_t v[1];
	uint32_t queue4_shaper_enable[1];
	uint32_t _queue4_shaper_enable;
} BCM89500_A0_QUEUE4_SHAPER_ENABLEr_t;

#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_CLR(r) (r).queue4_shaper_enable[0] = 0
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_SET(r,d) (r).queue4_shaper_enable[0] = d
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_GET(r) (r).queue4_shaper_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_QUEUE4_SHAPER_ENABLEf_GET(r) (((r).queue4_shaper_enable[0]) & 0x1ff)
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_QUEUE4_SHAPER_ENABLEf_SET(r,f) (r).queue4_shaper_enable[0]=(((r).queue4_shaper_enable[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_RESERVEDf_GET(r) ((((r).queue4_shaper_enable[0]) >> 9) & 0x7f)
#define BCM89500_A0_QUEUE4_SHAPER_ENABLEr_RESERVEDf_SET(r,f) (r).queue4_shaper_enable[0]=(((r).queue4_shaper_enable[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QUEUE4_SHAPER_ENABLE.
 *
 */
#define BCM89500_A0_READ_QUEUE4_SHAPER_ENABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QUEUE4_SHAPER_ENABLEr,(r._queue4_shaper_enable),2)
#define BCM89500_A0_WRITE_QUEUE4_SHAPER_ENABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QUEUE4_SHAPER_ENABLEr,&(r._queue4_shaper_enable),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE4_SHAPER_ENABLEr BCM89500_A0_QUEUE4_SHAPER_ENABLEr
#define QUEUE4_SHAPER_ENABLEr_SIZE BCM89500_A0_QUEUE4_SHAPER_ENABLEr_SIZE
typedef BCM89500_A0_QUEUE4_SHAPER_ENABLEr_t QUEUE4_SHAPER_ENABLEr_t;
#define QUEUE4_SHAPER_ENABLEr_CLR BCM89500_A0_QUEUE4_SHAPER_ENABLEr_CLR
#define QUEUE4_SHAPER_ENABLEr_SET BCM89500_A0_QUEUE4_SHAPER_ENABLEr_SET
#define QUEUE4_SHAPER_ENABLEr_GET BCM89500_A0_QUEUE4_SHAPER_ENABLEr_GET
#define QUEUE4_SHAPER_ENABLEr_QUEUE4_SHAPER_ENABLEf_GET BCM89500_A0_QUEUE4_SHAPER_ENABLEr_QUEUE4_SHAPER_ENABLEf_GET
#define QUEUE4_SHAPER_ENABLEr_QUEUE4_SHAPER_ENABLEf_SET BCM89500_A0_QUEUE4_SHAPER_ENABLEr_QUEUE4_SHAPER_ENABLEf_SET
#define QUEUE4_SHAPER_ENABLEr_RESERVEDf_GET BCM89500_A0_QUEUE4_SHAPER_ENABLEr_RESERVEDf_GET
#define QUEUE4_SHAPER_ENABLEr_RESERVEDf_SET BCM89500_A0_QUEUE4_SHAPER_ENABLEr_RESERVEDf_SET
#define READ_QUEUE4_SHAPER_ENABLEr BCM89500_A0_READ_QUEUE4_SHAPER_ENABLEr
#define WRITE_QUEUE4_SHAPER_ENABLEr BCM89500_A0_WRITE_QUEUE4_SHAPER_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QUEUE4_SHAPER_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QUEUE5_AVB_SHAPING_MODE
 * BLOCKS:   SYS
 * DESC:     Queue 5 AVB Shaping Mode Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QUEUE5_AVB_SHAPING_MODE Enable/Disable queue 5 AVB Shaping mode for each egress port.0: Disable AVB Shaping mode1: Enable AVB Shaping modebit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr 0x00003706

#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_SIZE 2

/*
 * This structure should be used to declare and program QUEUE5_AVB_SHAPING_MODE.
 *
 */
typedef union BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_s {
	uint32_t v[1];
	uint32_t queue5_avb_shaping_mode[1];
	uint32_t _queue5_avb_shaping_mode;
} BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_t;

#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_CLR(r) (r).queue5_avb_shaping_mode[0] = 0
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_SET(r,d) (r).queue5_avb_shaping_mode[0] = d
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_GET(r) (r).queue5_avb_shaping_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_QUEUE5_AVB_SHAPING_MODEf_GET(r) (((r).queue5_avb_shaping_mode[0]) & 0x1ff)
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_QUEUE5_AVB_SHAPING_MODEf_SET(r,f) (r).queue5_avb_shaping_mode[0]=(((r).queue5_avb_shaping_mode[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_RESERVEDf_GET(r) ((((r).queue5_avb_shaping_mode[0]) >> 9) & 0x7f)
#define BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_RESERVEDf_SET(r,f) (r).queue5_avb_shaping_mode[0]=(((r).queue5_avb_shaping_mode[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QUEUE5_AVB_SHAPING_MODE.
 *
 */
#define BCM89500_A0_READ_QUEUE5_AVB_SHAPING_MODEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr,(r._queue5_avb_shaping_mode),2)
#define BCM89500_A0_WRITE_QUEUE5_AVB_SHAPING_MODEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr,&(r._queue5_avb_shaping_mode),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE5_AVB_SHAPING_MODEr BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr
#define QUEUE5_AVB_SHAPING_MODEr_SIZE BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_SIZE
typedef BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_t QUEUE5_AVB_SHAPING_MODEr_t;
#define QUEUE5_AVB_SHAPING_MODEr_CLR BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_CLR
#define QUEUE5_AVB_SHAPING_MODEr_SET BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_SET
#define QUEUE5_AVB_SHAPING_MODEr_GET BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_GET
#define QUEUE5_AVB_SHAPING_MODEr_QUEUE5_AVB_SHAPING_MODEf_GET BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_QUEUE5_AVB_SHAPING_MODEf_GET
#define QUEUE5_AVB_SHAPING_MODEr_QUEUE5_AVB_SHAPING_MODEf_SET BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_QUEUE5_AVB_SHAPING_MODEf_SET
#define QUEUE5_AVB_SHAPING_MODEr_RESERVEDf_GET BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_RESERVEDf_GET
#define QUEUE5_AVB_SHAPING_MODEr_RESERVEDf_SET BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr_RESERVEDf_SET
#define READ_QUEUE5_AVB_SHAPING_MODEr BCM89500_A0_READ_QUEUE5_AVB_SHAPING_MODEr
#define WRITE_QUEUE5_AVB_SHAPING_MODEr BCM89500_A0_WRITE_QUEUE5_AVB_SHAPING_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QUEUE5_AVB_SHAPING_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  QUEUE5_SHAPER_ENABLE
 * BLOCKS:   SYS
 * DESC:     Queue 5 Shaper Enable Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QUEUE5_SHAPER_ENABLE Enable/Disable queue 5 Shaper for each egress port.0: Disable Shaper1: Enable Shaperbit[8:7]: port8 ~ port7.bit[6]: reserved.bit[5:0]: port5 ~ port0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr 0x00003714

#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_SIZE 2

/*
 * This structure should be used to declare and program QUEUE5_SHAPER_ENABLE.
 *
 */
typedef union BCM89500_A0_QUEUE5_SHAPER_ENABLEr_s {
	uint32_t v[1];
	uint32_t queue5_shaper_enable[1];
	uint32_t _queue5_shaper_enable;
} BCM89500_A0_QUEUE5_SHAPER_ENABLEr_t;

#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_CLR(r) (r).queue5_shaper_enable[0] = 0
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_SET(r,d) (r).queue5_shaper_enable[0] = d
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_GET(r) (r).queue5_shaper_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_QUEUE5_SHAPER_ENABLEf_GET(r) (((r).queue5_shaper_enable[0]) & 0x1ff)
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_QUEUE5_SHAPER_ENABLEf_SET(r,f) (r).queue5_shaper_enable[0]=(((r).queue5_shaper_enable[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_RESERVEDf_GET(r) ((((r).queue5_shaper_enable[0]) >> 9) & 0x7f)
#define BCM89500_A0_QUEUE5_SHAPER_ENABLEr_RESERVEDf_SET(r,f) (r).queue5_shaper_enable[0]=(((r).queue5_shaper_enable[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QUEUE5_SHAPER_ENABLE.
 *
 */
#define BCM89500_A0_READ_QUEUE5_SHAPER_ENABLEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_QUEUE5_SHAPER_ENABLEr,(r._queue5_shaper_enable),2)
#define BCM89500_A0_WRITE_QUEUE5_SHAPER_ENABLEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_QUEUE5_SHAPER_ENABLEr,&(r._queue5_shaper_enable),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE5_SHAPER_ENABLEr BCM89500_A0_QUEUE5_SHAPER_ENABLEr
#define QUEUE5_SHAPER_ENABLEr_SIZE BCM89500_A0_QUEUE5_SHAPER_ENABLEr_SIZE
typedef BCM89500_A0_QUEUE5_SHAPER_ENABLEr_t QUEUE5_SHAPER_ENABLEr_t;
#define QUEUE5_SHAPER_ENABLEr_CLR BCM89500_A0_QUEUE5_SHAPER_ENABLEr_CLR
#define QUEUE5_SHAPER_ENABLEr_SET BCM89500_A0_QUEUE5_SHAPER_ENABLEr_SET
#define QUEUE5_SHAPER_ENABLEr_GET BCM89500_A0_QUEUE5_SHAPER_ENABLEr_GET
#define QUEUE5_SHAPER_ENABLEr_QUEUE5_SHAPER_ENABLEf_GET BCM89500_A0_QUEUE5_SHAPER_ENABLEr_QUEUE5_SHAPER_ENABLEf_GET
#define QUEUE5_SHAPER_ENABLEr_QUEUE5_SHAPER_ENABLEf_SET BCM89500_A0_QUEUE5_SHAPER_ENABLEr_QUEUE5_SHAPER_ENABLEf_SET
#define QUEUE5_SHAPER_ENABLEr_RESERVEDf_GET BCM89500_A0_QUEUE5_SHAPER_ENABLEr_RESERVEDf_GET
#define QUEUE5_SHAPER_ENABLEr_RESERVEDf_SET BCM89500_A0_QUEUE5_SHAPER_ENABLEr_RESERVEDf_SET
#define READ_QUEUE5_SHAPER_ENABLEr BCM89500_A0_READ_QUEUE5_SHAPER_ENABLEr
#define WRITE_QUEUE5_SHAPER_ENABLEr BCM89500_A0_WRITE_QUEUE5_SHAPER_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_QUEUE5_SHAPER_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RATE_INBAND
 * BLOCKS:   SYS
 * DESC:     CFP RATE In-Band Statistic Registers
 * SIZE:     32
 * FIELDS:
 *     INBAND_CNT       In Band CounterThis field contains the data to read from or write to the in-band counter RAM.
 *
 ******************************************************************************/
#define BCM89500_A0_RATE_INBANDr 0x0000a070

#define BCM89500_A0_RATE_INBANDr_SIZE 4

/*
 * This structure should be used to declare and program RATE_INBAND.
 *
 */
typedef union BCM89500_A0_RATE_INBANDr_s {
	uint32_t v[1];
	uint32_t rate_inband[1];
	uint32_t _rate_inband;
} BCM89500_A0_RATE_INBANDr_t;

#define BCM89500_A0_RATE_INBANDr_CLR(r) (r).rate_inband[0] = 0
#define BCM89500_A0_RATE_INBANDr_SET(r,d) (r).rate_inband[0] = d
#define BCM89500_A0_RATE_INBANDr_GET(r) (r).rate_inband[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RATE_INBANDr_INBAND_CNTf_GET(r) ((r).rate_inband[0])
#define BCM89500_A0_RATE_INBANDr_INBAND_CNTf_SET(r,f) (r).rate_inband[0]=((uint32_t)f)

/*
 * These macros can be used to access RATE_INBAND.
 *
 */
#define BCM89500_A0_READ_RATE_INBANDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RATE_INBANDr,(r._rate_inband),4)
#define BCM89500_A0_WRITE_RATE_INBANDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RATE_INBANDr,&(r._rate_inband),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_INBANDr BCM89500_A0_RATE_INBANDr
#define RATE_INBANDr_SIZE BCM89500_A0_RATE_INBANDr_SIZE
typedef BCM89500_A0_RATE_INBANDr_t RATE_INBANDr_t;
#define RATE_INBANDr_CLR BCM89500_A0_RATE_INBANDr_CLR
#define RATE_INBANDr_SET BCM89500_A0_RATE_INBANDr_SET
#define RATE_INBANDr_GET BCM89500_A0_RATE_INBANDr_GET
#define RATE_INBANDr_INBAND_CNTf_GET BCM89500_A0_RATE_INBANDr_INBAND_CNTf_GET
#define RATE_INBANDr_INBAND_CNTf_SET BCM89500_A0_RATE_INBANDr_INBAND_CNTf_SET
#define READ_RATE_INBANDr BCM89500_A0_READ_RATE_INBANDr
#define WRITE_RATE_INBANDr BCM89500_A0_WRITE_RATE_INBANDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RATE_INBANDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RATE_METER0
 * BLOCKS:   SYS
 * DESC:     CFP RATE METER DATA 0 Registers
 * SIZE:     32
 * FIELDS:
 *     CURR_QUOTA       Current Quota.This field is initialized by software as the initial credit for each flow. And hardware will update the current quota according to the per flow rate meter scheme. The unit is in byte.(This field should be programmed at least larger than 12Kbytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RATE_METER0r 0x0000a060

#define BCM89500_A0_RATE_METER0r_SIZE 4

/*
 * This structure should be used to declare and program RATE_METER0.
 *
 */
typedef union BCM89500_A0_RATE_METER0r_s {
	uint32_t v[1];
	uint32_t rate_meter0[1];
	uint32_t _rate_meter0;
} BCM89500_A0_RATE_METER0r_t;

#define BCM89500_A0_RATE_METER0r_CLR(r) (r).rate_meter0[0] = 0
#define BCM89500_A0_RATE_METER0r_SET(r,d) (r).rate_meter0[0] = d
#define BCM89500_A0_RATE_METER0r_GET(r) (r).rate_meter0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RATE_METER0r_CURR_QUOTAf_GET(r) (((r).rate_meter0[0]) & 0xffffff)
#define BCM89500_A0_RATE_METER0r_CURR_QUOTAf_SET(r,f) (r).rate_meter0[0]=(((r).rate_meter0[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM89500_A0_RATE_METER0r_RESERVEDf_GET(r) ((((r).rate_meter0[0]) >> 24) & 0xff)
#define BCM89500_A0_RATE_METER0r_RESERVEDf_SET(r,f) (r).rate_meter0[0]=(((r).rate_meter0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access RATE_METER0.
 *
 */
#define BCM89500_A0_READ_RATE_METER0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RATE_METER0r,(r._rate_meter0),4)
#define BCM89500_A0_WRITE_RATE_METER0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RATE_METER0r,&(r._rate_meter0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_METER0r BCM89500_A0_RATE_METER0r
#define RATE_METER0r_SIZE BCM89500_A0_RATE_METER0r_SIZE
typedef BCM89500_A0_RATE_METER0r_t RATE_METER0r_t;
#define RATE_METER0r_CLR BCM89500_A0_RATE_METER0r_CLR
#define RATE_METER0r_SET BCM89500_A0_RATE_METER0r_SET
#define RATE_METER0r_GET BCM89500_A0_RATE_METER0r_GET
#define RATE_METER0r_CURR_QUOTAf_GET BCM89500_A0_RATE_METER0r_CURR_QUOTAf_GET
#define RATE_METER0r_CURR_QUOTAf_SET BCM89500_A0_RATE_METER0r_CURR_QUOTAf_SET
#define RATE_METER0r_RESERVEDf_GET BCM89500_A0_RATE_METER0r_RESERVEDf_GET
#define RATE_METER0r_RESERVEDf_SET BCM89500_A0_RATE_METER0r_RESERVEDf_SET
#define READ_RATE_METER0r BCM89500_A0_READ_RATE_METER0r
#define WRITE_RATE_METER0r BCM89500_A0_WRITE_RATE_METER0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RATE_METER0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RATE_METER1
 * BLOCKS:   SYS
 * DESC:     CFP RATE METER DATA 1 Registers
 * SIZE:     32
 * FIELDS:
 *     TOKEN_NUM        Token.This token to be added on each refresh cycle(per rule control), the unit is 32 bytes. It can be programmed from 8'd1 to 8'd240.Please refer to the following table for the detail.---------------------------------------------------------------------------------------Token  | Formula(N=token)     | Bit rate                  | resolution | Refresh rate  |---------------------------------------------------------------------------------------1-28   | N*8*1024/125         | 64Kb, 128Kb, 192Kb...     | 64Kb       | 125*32us      |---------------------------------------------------------------------------------------29-127 | (N-27)*1024          | 2Mb, 3Mb, 4Mb...          | 1Mb        | 8*32us        |---------------------------------------------------------------------------------------128-240| (N-115)*1024*8       | 104Mb, 112Mb, 120Mb...    | 8Mb        | 1*32us        |---------------------------------------------------------------------------------------
 *     REF_CAP          Reference CAP.This field indicates the max bucket size per flow need to keep track of(per rule control). The unit is in byte.4'b0000: ref_cap = 24'b1111_1111_1111_1111_1111_1111; (16MB-1)4'b0001: ref_cap = 24'b0111_1111_1111_1111_1111_1111; (8MB-1)4'b0010: ref_cap = 24'b0011_1111_1111_1111_1111_1111; (4MB-1)4'b0011: ref_cap = 24'b0001_1111_1111_1111_1111_1111; (2MB-1)4'b0100: ref_cap = 24'b0000_1111_1111_1111_1111_1111; (1MB-1)4'b0101: ref_cap = 24'b0000_0111_1111_1111_1111_1111; (512KB-1)4'b0110: ref_cap = 24'b0000_0011_1111_1111_1111_1111; (256KB-1)4'b0111: ref_cap = 24'b0000_0001_1111_1111_1111_1111; (128KB-1)4'b1000: ref_cap = 24'b0000_0000_1111_1111_1111_1111; (64KB-1)4'b1001: ref_cap = 24'b0000_0000_0111_1111_1111_1111; (32KB-1)4'b1010: ref_cap = 24'b0000_0000_0011_1111_1111_1111; (16KB-1)others: reserved
 *     RESERVED         Reserved
 *     RATE_REFRESH_EN  Rate Meter Refresh Enable.This field enables hardware for rate meter refresh.Software should set this bit after the rate meter RAM has been initialized, and software would like to start rate meter refresh (Global control).
 *
 ******************************************************************************/
#define BCM89500_A0_RATE_METER1r 0x0000a064

#define BCM89500_A0_RATE_METER1r_SIZE 4

/*
 * This structure should be used to declare and program RATE_METER1.
 *
 */
typedef union BCM89500_A0_RATE_METER1r_s {
	uint32_t v[1];
	uint32_t rate_meter1[1];
	uint32_t _rate_meter1;
} BCM89500_A0_RATE_METER1r_t;

#define BCM89500_A0_RATE_METER1r_CLR(r) (r).rate_meter1[0] = 0
#define BCM89500_A0_RATE_METER1r_SET(r,d) (r).rate_meter1[0] = d
#define BCM89500_A0_RATE_METER1r_GET(r) (r).rate_meter1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RATE_METER1r_TOKEN_NUMf_GET(r) (((r).rate_meter1[0]) & 0xff)
#define BCM89500_A0_RATE_METER1r_TOKEN_NUMf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_RATE_METER1r_REF_CAPf_GET(r) ((((r).rate_meter1[0]) >> 8) & 0xf)
#define BCM89500_A0_RATE_METER1r_REF_CAPf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RATE_METER1r_RESERVEDf_GET(r) ((((r).rate_meter1[0]) >> 12) & 0x7ffff)
#define BCM89500_A0_RATE_METER1r_RESERVEDf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0x7ffff << 12)) | ((((uint32_t)f) & 0x7ffff) << 12))
#define BCM89500_A0_RATE_METER1r_RATE_REFRESH_ENf_GET(r) ((((r).rate_meter1[0]) >> 31) & 0x1)
#define BCM89500_A0_RATE_METER1r_RATE_REFRESH_ENf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access RATE_METER1.
 *
 */
#define BCM89500_A0_READ_RATE_METER1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RATE_METER1r,(r._rate_meter1),4)
#define BCM89500_A0_WRITE_RATE_METER1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RATE_METER1r,&(r._rate_meter1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_METER1r BCM89500_A0_RATE_METER1r
#define RATE_METER1r_SIZE BCM89500_A0_RATE_METER1r_SIZE
typedef BCM89500_A0_RATE_METER1r_t RATE_METER1r_t;
#define RATE_METER1r_CLR BCM89500_A0_RATE_METER1r_CLR
#define RATE_METER1r_SET BCM89500_A0_RATE_METER1r_SET
#define RATE_METER1r_GET BCM89500_A0_RATE_METER1r_GET
#define RATE_METER1r_TOKEN_NUMf_GET BCM89500_A0_RATE_METER1r_TOKEN_NUMf_GET
#define RATE_METER1r_TOKEN_NUMf_SET BCM89500_A0_RATE_METER1r_TOKEN_NUMf_SET
#define RATE_METER1r_REF_CAPf_GET BCM89500_A0_RATE_METER1r_REF_CAPf_GET
#define RATE_METER1r_REF_CAPf_SET BCM89500_A0_RATE_METER1r_REF_CAPf_SET
#define RATE_METER1r_RESERVEDf_GET BCM89500_A0_RATE_METER1r_RESERVEDf_GET
#define RATE_METER1r_RESERVEDf_SET BCM89500_A0_RATE_METER1r_RESERVEDf_SET
#define RATE_METER1r_RATE_REFRESH_ENf_GET BCM89500_A0_RATE_METER1r_RATE_REFRESH_ENf_GET
#define RATE_METER1r_RATE_REFRESH_ENf_SET BCM89500_A0_RATE_METER1r_RATE_REFRESH_ENf_SET
#define READ_RATE_METER1r BCM89500_A0_READ_RATE_METER1r
#define WRITE_RATE_METER1r BCM89500_A0_WRITE_RATE_METER1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RATE_METER1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RATE_OUTBAND
 * BLOCKS:   SYS
 * DESC:     CFP RATE OUT-Band Statistic Registers
 * SIZE:     32
 * FIELDS:
 *     OUTBAND_CNT      Out Band Counter.This field contains the data to read from or write to the out-band counter RAM.
 *
 ******************************************************************************/
#define BCM89500_A0_RATE_OUTBANDr 0x0000a074

#define BCM89500_A0_RATE_OUTBANDr_SIZE 4

/*
 * This structure should be used to declare and program RATE_OUTBAND.
 *
 */
typedef union BCM89500_A0_RATE_OUTBANDr_s {
	uint32_t v[1];
	uint32_t rate_outband[1];
	uint32_t _rate_outband;
} BCM89500_A0_RATE_OUTBANDr_t;

#define BCM89500_A0_RATE_OUTBANDr_CLR(r) (r).rate_outband[0] = 0
#define BCM89500_A0_RATE_OUTBANDr_SET(r,d) (r).rate_outband[0] = d
#define BCM89500_A0_RATE_OUTBANDr_GET(r) (r).rate_outband[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RATE_OUTBANDr_OUTBAND_CNTf_GET(r) ((r).rate_outband[0])
#define BCM89500_A0_RATE_OUTBANDr_OUTBAND_CNTf_SET(r,f) (r).rate_outband[0]=((uint32_t)f)

/*
 * These macros can be used to access RATE_OUTBAND.
 *
 */
#define BCM89500_A0_READ_RATE_OUTBANDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RATE_OUTBANDr,(r._rate_outband),4)
#define BCM89500_A0_WRITE_RATE_OUTBANDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RATE_OUTBANDr,&(r._rate_outband),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_OUTBANDr BCM89500_A0_RATE_OUTBANDr
#define RATE_OUTBANDr_SIZE BCM89500_A0_RATE_OUTBANDr_SIZE
typedef BCM89500_A0_RATE_OUTBANDr_t RATE_OUTBANDr_t;
#define RATE_OUTBANDr_CLR BCM89500_A0_RATE_OUTBANDr_CLR
#define RATE_OUTBANDr_SET BCM89500_A0_RATE_OUTBANDr_SET
#define RATE_OUTBANDr_GET BCM89500_A0_RATE_OUTBANDr_GET
#define RATE_OUTBANDr_OUTBAND_CNTf_GET BCM89500_A0_RATE_OUTBANDr_OUTBAND_CNTf_GET
#define RATE_OUTBANDr_OUTBAND_CNTf_SET BCM89500_A0_RATE_OUTBANDr_OUTBAND_CNTf_SET
#define READ_RATE_OUTBANDr BCM89500_A0_READ_RATE_OUTBANDr
#define WRITE_RATE_OUTBANDr BCM89500_A0_WRITE_RATE_OUTBANDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RATE_OUTBANDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RESET_STATUS
 * BLOCKS:   SYS
 * DESC:     Reset Status Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     QPHY_RST_STS     (Not2Release)Quad BR-PHY Reset Status (Port 0 - Port 3) 1'b1 indicates PHY is in reset state.
 *     RESERVED_0       Reserved
 *     SPHY_RST_STS     (Not2Release)Single BR-PHY Reset Status (Port 4)1'b1 indicates PHY is in reset state.
 *     SD_RST_STS       (Not2Release)Serdes Reset Status (Port 5)1'b1 indicates Serdes is in reset state.
 *     RESERVED_1       Reserved
 *     SW_REG_RST_STS   (Not2Release)Switch Register Reset Status1'b1 indicates switch register is in reset state.Note: reading this bit should always return 0.
 *     SW_CORE_RST_STS  Switch Core Reset Status1'b1 indicates switch core is in reset state.
 *     SOC_BOOT_DN      SoC Boot Status1'b1 indicates SoC is in boot up state.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RESET_STATUSr 0x00000190

#define BCM89500_A0_RESET_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program RESET_STATUS.
 *
 */
typedef union BCM89500_A0_RESET_STATUSr_s {
	uint32_t v[1];
	uint32_t reset_status[1];
	uint32_t _reset_status;
} BCM89500_A0_RESET_STATUSr_t;

#define BCM89500_A0_RESET_STATUSr_CLR(r) (r).reset_status[0] = 0
#define BCM89500_A0_RESET_STATUSr_SET(r,d) (r).reset_status[0] = d
#define BCM89500_A0_RESET_STATUSr_GET(r) (r).reset_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RESET_STATUSr_QPHY_RST_STSf_GET(r) (((r).reset_status[0]) & 0x1)
#define BCM89500_A0_RESET_STATUSr_QPHY_RST_STSf_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_RESET_STATUSr_RESERVED_0f_GET(r) ((((r).reset_status[0]) >> 1) & 0x7)
#define BCM89500_A0_RESET_STATUSr_RESERVED_0f_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_RESET_STATUSr_SPHY_RST_STSf_GET(r) ((((r).reset_status[0]) >> 4) & 0x1)
#define BCM89500_A0_RESET_STATUSr_SPHY_RST_STSf_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_RESET_STATUSr_SD_RST_STSf_GET(r) ((((r).reset_status[0]) >> 5) & 0x1)
#define BCM89500_A0_RESET_STATUSr_SD_RST_STSf_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_RESET_STATUSr_RESERVED_1f_GET(r) ((((r).reset_status[0]) >> 6) & 0x3)
#define BCM89500_A0_RESET_STATUSr_RESERVED_1f_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_RESET_STATUSr_SW_REG_RST_STSf_GET(r) ((((r).reset_status[0]) >> 8) & 0x1)
#define BCM89500_A0_RESET_STATUSr_SW_REG_RST_STSf_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_RESET_STATUSr_SW_CORE_RST_STSf_GET(r) ((((r).reset_status[0]) >> 9) & 0x1)
#define BCM89500_A0_RESET_STATUSr_SW_CORE_RST_STSf_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_RESET_STATUSr_SOC_BOOT_DNf_GET(r) ((((r).reset_status[0]) >> 10) & 0x1)
#define BCM89500_A0_RESET_STATUSr_SOC_BOOT_DNf_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_RESET_STATUSr_RESERVED_2f_GET(r) ((((r).reset_status[0]) >> 11) & 0x1f)
#define BCM89500_A0_RESET_STATUSr_RESERVED_2f_SET(r,f) (r).reset_status[0]=(((r).reset_status[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access RESET_STATUS.
 *
 */
#define BCM89500_A0_READ_RESET_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RESET_STATUSr,(r._reset_status),2)
#define BCM89500_A0_WRITE_RESET_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RESET_STATUSr,&(r._reset_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESET_STATUSr BCM89500_A0_RESET_STATUSr
#define RESET_STATUSr_SIZE BCM89500_A0_RESET_STATUSr_SIZE
typedef BCM89500_A0_RESET_STATUSr_t RESET_STATUSr_t;
#define RESET_STATUSr_CLR BCM89500_A0_RESET_STATUSr_CLR
#define RESET_STATUSr_SET BCM89500_A0_RESET_STATUSr_SET
#define RESET_STATUSr_GET BCM89500_A0_RESET_STATUSr_GET
#define RESET_STATUSr_QPHY_RST_STSf_GET BCM89500_A0_RESET_STATUSr_QPHY_RST_STSf_GET
#define RESET_STATUSr_QPHY_RST_STSf_SET BCM89500_A0_RESET_STATUSr_QPHY_RST_STSf_SET
#define RESET_STATUSr_RESERVED_0f_GET BCM89500_A0_RESET_STATUSr_RESERVED_0f_GET
#define RESET_STATUSr_RESERVED_0f_SET BCM89500_A0_RESET_STATUSr_RESERVED_0f_SET
#define RESET_STATUSr_SPHY_RST_STSf_GET BCM89500_A0_RESET_STATUSr_SPHY_RST_STSf_GET
#define RESET_STATUSr_SPHY_RST_STSf_SET BCM89500_A0_RESET_STATUSr_SPHY_RST_STSf_SET
#define RESET_STATUSr_SD_RST_STSf_GET BCM89500_A0_RESET_STATUSr_SD_RST_STSf_GET
#define RESET_STATUSr_SD_RST_STSf_SET BCM89500_A0_RESET_STATUSr_SD_RST_STSf_SET
#define RESET_STATUSr_RESERVED_1f_GET BCM89500_A0_RESET_STATUSr_RESERVED_1f_GET
#define RESET_STATUSr_RESERVED_1f_SET BCM89500_A0_RESET_STATUSr_RESERVED_1f_SET
#define RESET_STATUSr_SW_REG_RST_STSf_GET BCM89500_A0_RESET_STATUSr_SW_REG_RST_STSf_GET
#define RESET_STATUSr_SW_REG_RST_STSf_SET BCM89500_A0_RESET_STATUSr_SW_REG_RST_STSf_SET
#define RESET_STATUSr_SW_CORE_RST_STSf_GET BCM89500_A0_RESET_STATUSr_SW_CORE_RST_STSf_GET
#define RESET_STATUSr_SW_CORE_RST_STSf_SET BCM89500_A0_RESET_STATUSr_SW_CORE_RST_STSf_SET
#define RESET_STATUSr_SOC_BOOT_DNf_GET BCM89500_A0_RESET_STATUSr_SOC_BOOT_DNf_GET
#define RESET_STATUSr_SOC_BOOT_DNf_SET BCM89500_A0_RESET_STATUSr_SOC_BOOT_DNf_SET
#define RESET_STATUSr_RESERVED_2f_GET BCM89500_A0_RESET_STATUSr_RESERVED_2f_GET
#define RESET_STATUSr_RESERVED_2f_SET BCM89500_A0_RESET_STATUSr_RESERVED_2f_SET
#define READ_RESET_STATUSr BCM89500_A0_READ_RESET_STATUSr
#define WRITE_RESET_STATUSr BCM89500_A0_WRITE_RESET_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RESET_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RMONSTEER
 * BLOCKS:   SYS
 * DESC:     RMON MIB Steering Register
 * SIZE:     16
 * FIELDS:
 *     OR_RMON_RCV      Override RMON Receive.Forces the RMON packet size bucket counters from the normal default of snooping on the receive side of the MAC, to the transmit side. This allows the RMON bucket counters to snoop either transmit or receive, allowing full duplex MAC support.Bit 0-5: Port0-5Bit 7: Port 7Bit 8: Port 8(IMP port)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RMONSTEERr 0x00000204

#define BCM89500_A0_RMONSTEERr_SIZE 2

/*
 * This structure should be used to declare and program RMONSTEER.
 *
 */
typedef union BCM89500_A0_RMONSTEERr_s {
	uint32_t v[1];
	uint32_t rmonsteer[1];
	uint32_t _rmonsteer;
} BCM89500_A0_RMONSTEERr_t;

#define BCM89500_A0_RMONSTEERr_CLR(r) (r).rmonsteer[0] = 0
#define BCM89500_A0_RMONSTEERr_SET(r,d) (r).rmonsteer[0] = d
#define BCM89500_A0_RMONSTEERr_GET(r) (r).rmonsteer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RMONSTEERr_OR_RMON_RCVf_GET(r) (((r).rmonsteer[0]) & 0x1ff)
#define BCM89500_A0_RMONSTEERr_OR_RMON_RCVf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_RMONSTEERr_RESERVEDf_GET(r) ((((r).rmonsteer[0]) >> 9) & 0x7f)
#define BCM89500_A0_RMONSTEERr_RESERVEDf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RMONSTEER.
 *
 */
#define BCM89500_A0_READ_RMONSTEERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RMONSTEERr,(r._rmonsteer),2)
#define BCM89500_A0_WRITE_RMONSTEERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RMONSTEERr,&(r._rmonsteer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RMONSTEERr BCM89500_A0_RMONSTEERr
#define RMONSTEERr_SIZE BCM89500_A0_RMONSTEERr_SIZE
typedef BCM89500_A0_RMONSTEERr_t RMONSTEERr_t;
#define RMONSTEERr_CLR BCM89500_A0_RMONSTEERr_CLR
#define RMONSTEERr_SET BCM89500_A0_RMONSTEERr_SET
#define RMONSTEERr_GET BCM89500_A0_RMONSTEERr_GET
#define RMONSTEERr_OR_RMON_RCVf_GET BCM89500_A0_RMONSTEERr_OR_RMON_RCVf_GET
#define RMONSTEERr_OR_RMON_RCVf_SET BCM89500_A0_RMONSTEERr_OR_RMON_RCVf_SET
#define RMONSTEERr_RESERVEDf_GET BCM89500_A0_RMONSTEERr_RESERVEDf_GET
#define RMONSTEERr_RESERVEDf_SET BCM89500_A0_RMONSTEERr_RESERVEDf_SET
#define READ_RMONSTEERr BCM89500_A0_READ_RMONSTEERr
#define WRITE_RMONSTEERr BCM89500_A0_WRITE_RMONSTEERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RMONSTEERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RM_PINS_DEBUG
 * BLOCKS:   SYS
 * DESC:     Removed Pins Debug Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     ENHDXFLOW_PIN    Enable Automatic Backpressure 1 = Enable(default)0 = Disable
 *     ENFDXFLOW_PIN    Enable Automatic Full-Duplex Flow Control1 = Enable(default)0 = Disable
 *     DIS_IMP_PIN      Disable IMP port0 = Enable IMP port(default)1 = Disable IMP port, and external pull-up resister is required.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RM_PINS_DEBUGr 0x0000001f

#define BCM89500_A0_RM_PINS_DEBUGr_SIZE 1

/*
 * This structure should be used to declare and program RM_PINS_DEBUG.
 *
 */
typedef union BCM89500_A0_RM_PINS_DEBUGr_s {
	uint32_t v[1];
	uint32_t rm_pins_debug[1];
	uint32_t _rm_pins_debug;
} BCM89500_A0_RM_PINS_DEBUGr_t;

#define BCM89500_A0_RM_PINS_DEBUGr_CLR(r) (r).rm_pins_debug[0] = 0
#define BCM89500_A0_RM_PINS_DEBUGr_SET(r,d) (r).rm_pins_debug[0] = d
#define BCM89500_A0_RM_PINS_DEBUGr_GET(r) (r).rm_pins_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RM_PINS_DEBUGr_ENHDXFLOW_PINf_GET(r) (((r).rm_pins_debug[0]) & 0x1)
#define BCM89500_A0_RM_PINS_DEBUGr_ENHDXFLOW_PINf_SET(r,f) (r).rm_pins_debug[0]=(((r).rm_pins_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_RM_PINS_DEBUGr_ENFDXFLOW_PINf_GET(r) ((((r).rm_pins_debug[0]) >> 1) & 0x1)
#define BCM89500_A0_RM_PINS_DEBUGr_ENFDXFLOW_PINf_SET(r,f) (r).rm_pins_debug[0]=(((r).rm_pins_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_RM_PINS_DEBUGr_DIS_IMP_PINf_GET(r) ((((r).rm_pins_debug[0]) >> 2) & 0x1)
#define BCM89500_A0_RM_PINS_DEBUGr_DIS_IMP_PINf_SET(r,f) (r).rm_pins_debug[0]=(((r).rm_pins_debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_RM_PINS_DEBUGr_RESERVEDf_GET(r) ((((r).rm_pins_debug[0]) >> 3) & 0x1f)
#define BCM89500_A0_RM_PINS_DEBUGr_RESERVEDf_SET(r,f) (r).rm_pins_debug[0]=(((r).rm_pins_debug[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access RM_PINS_DEBUG.
 *
 */
#define BCM89500_A0_READ_RM_PINS_DEBUGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RM_PINS_DEBUGr,(r._rm_pins_debug),1)
#define BCM89500_A0_WRITE_RM_PINS_DEBUGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RM_PINS_DEBUGr,&(r._rm_pins_debug),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RM_PINS_DEBUGr BCM89500_A0_RM_PINS_DEBUGr
#define RM_PINS_DEBUGr_SIZE BCM89500_A0_RM_PINS_DEBUGr_SIZE
typedef BCM89500_A0_RM_PINS_DEBUGr_t RM_PINS_DEBUGr_t;
#define RM_PINS_DEBUGr_CLR BCM89500_A0_RM_PINS_DEBUGr_CLR
#define RM_PINS_DEBUGr_SET BCM89500_A0_RM_PINS_DEBUGr_SET
#define RM_PINS_DEBUGr_GET BCM89500_A0_RM_PINS_DEBUGr_GET
#define RM_PINS_DEBUGr_ENHDXFLOW_PINf_GET BCM89500_A0_RM_PINS_DEBUGr_ENHDXFLOW_PINf_GET
#define RM_PINS_DEBUGr_ENHDXFLOW_PINf_SET BCM89500_A0_RM_PINS_DEBUGr_ENHDXFLOW_PINf_SET
#define RM_PINS_DEBUGr_ENFDXFLOW_PINf_GET BCM89500_A0_RM_PINS_DEBUGr_ENFDXFLOW_PINf_GET
#define RM_PINS_DEBUGr_ENFDXFLOW_PINf_SET BCM89500_A0_RM_PINS_DEBUGr_ENFDXFLOW_PINf_SET
#define RM_PINS_DEBUGr_DIS_IMP_PINf_GET BCM89500_A0_RM_PINS_DEBUGr_DIS_IMP_PINf_GET
#define RM_PINS_DEBUGr_DIS_IMP_PINf_SET BCM89500_A0_RM_PINS_DEBUGr_DIS_IMP_PINf_SET
#define RM_PINS_DEBUGr_RESERVEDf_GET BCM89500_A0_RM_PINS_DEBUGr_RESERVEDf_GET
#define RM_PINS_DEBUGr_RESERVEDf_SET BCM89500_A0_RM_PINS_DEBUGr_RESERVEDf_SET
#define READ_RM_PINS_DEBUGr BCM89500_A0_READ_RM_PINS_DEBUGr
#define WRITE_RM_PINS_DEBUGr BCM89500_A0_WRITE_RM_PINS_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RM_PINS_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RSV_MCAST_CTRL
 * BLOCKS:   SYS
 * DESC:     Reserved Multicast Register
 * SIZE:     8
 * FIELDS:
 *     EN_MUL_0         bit[0] :01-80-C2-00-00-00.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_1         bit[1] :01-80-C2-00-00-02 ~ 01-80-C2-00-00-0F.(Can be set in Unmanaged mode only)0: Forward1: Drop (default)
 *     EN_MUL_2         bit[2] :01-80-C2-00-00-10.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_3         bit[3] :01-80-C2-00-00-11 ~ 01-80-C2-00-00-1F.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_4         bit[4] :01-80-C2-00-00-20 ~ 01-80-C2-00-00-2F.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     GREEN_SETTING_TXBIAS The green mode setting is -20% or -50% txbias.1: Choose -20% txbias0: Choose -50% txbias(Not2Release)
 *     GREEN_SETTING_OVERRIDE Used for internal CPU to choose green mode setting as -20% or -50% txbias.1: enable override.0: disable override.Note: The register is related to OVERRIDE_AUTO_PD_WAR register at(Page 00h, Addr 21h, Bit 5:4)(Not2Release)
 *     EN_RES_MUL_LEARN bit[7] : en_reserved_McastDA_learn.0: Don't learn (default )1: Learn
 *
 ******************************************************************************/
#define BCM89500_A0_RSV_MCAST_CTRLr 0x0000002f

#define BCM89500_A0_RSV_MCAST_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program RSV_MCAST_CTRL.
 *
 */
typedef union BCM89500_A0_RSV_MCAST_CTRLr_s {
	uint32_t v[1];
	uint32_t rsv_mcast_ctrl[1];
	uint32_t _rsv_mcast_ctrl;
} BCM89500_A0_RSV_MCAST_CTRLr_t;

#define BCM89500_A0_RSV_MCAST_CTRLr_CLR(r) (r).rsv_mcast_ctrl[0] = 0
#define BCM89500_A0_RSV_MCAST_CTRLr_SET(r,d) (r).rsv_mcast_ctrl[0] = d
#define BCM89500_A0_RSV_MCAST_CTRLr_GET(r) (r).rsv_mcast_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET(r) (((r).rsv_mcast_ctrl[0]) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_TXBIASf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_TXBIASf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_OVERRIDEf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_OVERRIDEf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RSV_MCAST_CTRL.
 *
 */
#define BCM89500_A0_READ_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RSV_MCAST_CTRLr,(r._rsv_mcast_ctrl),1)
#define BCM89500_A0_WRITE_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RSV_MCAST_CTRLr,&(r._rsv_mcast_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_MCAST_CTRLr BCM89500_A0_RSV_MCAST_CTRLr
#define RSV_MCAST_CTRLr_SIZE BCM89500_A0_RSV_MCAST_CTRLr_SIZE
typedef BCM89500_A0_RSV_MCAST_CTRLr_t RSV_MCAST_CTRLr_t;
#define RSV_MCAST_CTRLr_CLR BCM89500_A0_RSV_MCAST_CTRLr_CLR
#define RSV_MCAST_CTRLr_SET BCM89500_A0_RSV_MCAST_CTRLr_SET
#define RSV_MCAST_CTRLr_GET BCM89500_A0_RSV_MCAST_CTRLr_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_GET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_SET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET
#define RSV_MCAST_CTRLr_EN_MUL_1f_GET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET
#define RSV_MCAST_CTRLr_EN_MUL_1f_SET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET
#define RSV_MCAST_CTRLr_EN_MUL_2f_GET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET
#define RSV_MCAST_CTRLr_EN_MUL_2f_SET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET
#define RSV_MCAST_CTRLr_EN_MUL_3f_GET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET
#define RSV_MCAST_CTRLr_EN_MUL_3f_SET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET
#define RSV_MCAST_CTRLr_EN_MUL_4f_GET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET
#define RSV_MCAST_CTRLr_EN_MUL_4f_SET BCM89500_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET
#define RSV_MCAST_CTRLr_GREEN_SETTING_TXBIASf_GET BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_TXBIASf_GET
#define RSV_MCAST_CTRLr_GREEN_SETTING_TXBIASf_SET BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_TXBIASf_SET
#define RSV_MCAST_CTRLr_GREEN_SETTING_OVERRIDEf_GET BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_OVERRIDEf_GET
#define RSV_MCAST_CTRLr_GREEN_SETTING_OVERRIDEf_SET BCM89500_A0_RSV_MCAST_CTRLr_GREEN_SETTING_OVERRIDEf_SET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET BCM89500_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET BCM89500_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET
#define READ_RSV_MCAST_CTRLr BCM89500_A0_READ_RSV_MCAST_CTRLr
#define WRITE_RSV_MCAST_CTRLr BCM89500_A0_WRITE_RSV_MCAST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RSV_MCAST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RXDISCARD
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXDISCARDr 0x000020c0

#define BCM89500_A0_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD.
 *
 */
typedef union BCM89500_A0_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t rxdiscard[1];
	uint32_t _rxdiscard;
} BCM89500_A0_RXDISCARDr_t;

#define BCM89500_A0_RXDISCARDr_CLR(r) (r).rxdiscard[0] = 0
#define BCM89500_A0_RXDISCARDr_SET(r,d) (r).rxdiscard[0] = d
#define BCM89500_A0_RXDISCARDr_GET(r) (r).rxdiscard[0]


/*
 * These macros can be used to access RXDISCARD.
 *
 */
#define BCM89500_A0_READ_RXDISCARDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXDISCARDr,(r._rxdiscard),4)
#define BCM89500_A0_WRITE_RXDISCARDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXDISCARDr,&(r._rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARDr BCM89500_A0_RXDISCARDr
#define RXDISCARDr_SIZE BCM89500_A0_RXDISCARDr_SIZE
typedef BCM89500_A0_RXDISCARDr_t RXDISCARDr_t;
#define RXDISCARDr_CLR BCM89500_A0_RXDISCARDr_CLR
#define RXDISCARDr_SET BCM89500_A0_RXDISCARDr_SET
#define RXDISCARDr_GET BCM89500_A0_RXDISCARDr_GET
#define READ_RXDISCARDr BCM89500_A0_READ_RXDISCARDr
#define WRITE_RXDISCARDr BCM89500_A0_WRITE_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RXDISCARD_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXDISCARD_IMPr 0x000028c0

#define BCM89500_A0_RXDISCARD_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD_IMP.
 *
 */
typedef union BCM89500_A0_RXDISCARD_IMPr_s {
	uint32_t v[1];
	uint32_t rxdiscard_imp[1];
	uint32_t _rxdiscard_imp;
} BCM89500_A0_RXDISCARD_IMPr_t;

#define BCM89500_A0_RXDISCARD_IMPr_CLR(r) (r).rxdiscard_imp[0] = 0
#define BCM89500_A0_RXDISCARD_IMPr_SET(r,d) (r).rxdiscard_imp[0] = d
#define BCM89500_A0_RXDISCARD_IMPr_GET(r) (r).rxdiscard_imp[0]


/*
 * These macros can be used to access RXDISCARD_IMP.
 *
 */
#define BCM89500_A0_READ_RXDISCARD_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXDISCARD_IMPr,(r._rxdiscard_imp),4)
#define BCM89500_A0_WRITE_RXDISCARD_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXDISCARD_IMPr,&(r._rxdiscard_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARD_IMPr BCM89500_A0_RXDISCARD_IMPr
#define RXDISCARD_IMPr_SIZE BCM89500_A0_RXDISCARD_IMPr_SIZE
typedef BCM89500_A0_RXDISCARD_IMPr_t RXDISCARD_IMPr_t;
#define RXDISCARD_IMPr_CLR BCM89500_A0_RXDISCARD_IMPr_CLR
#define RXDISCARD_IMPr_SET BCM89500_A0_RXDISCARD_IMPr_SET
#define RXDISCARD_IMPr_GET BCM89500_A0_RXDISCARD_IMPr_GET
#define READ_RXDISCARD_IMPr BCM89500_A0_READ_RXDISCARD_IMPr
#define WRITE_RXDISCARD_IMPr BCM89500_A0_WRITE_RXDISCARD_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXDISCARD_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RXDISCARD_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXDISCARD_P7r 0x000027c0

#define BCM89500_A0_RXDISCARD_P7r_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD_P7.
 *
 */
typedef union BCM89500_A0_RXDISCARD_P7r_s {
	uint32_t v[1];
	uint32_t rxdiscard_p7[1];
	uint32_t _rxdiscard_p7;
} BCM89500_A0_RXDISCARD_P7r_t;

#define BCM89500_A0_RXDISCARD_P7r_CLR(r) (r).rxdiscard_p7[0] = 0
#define BCM89500_A0_RXDISCARD_P7r_SET(r,d) (r).rxdiscard_p7[0] = d
#define BCM89500_A0_RXDISCARD_P7r_GET(r) (r).rxdiscard_p7[0]


/*
 * These macros can be used to access RXDISCARD_P7.
 *
 */
#define BCM89500_A0_READ_RXDISCARD_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXDISCARD_P7r,(r._rxdiscard_p7),4)
#define BCM89500_A0_WRITE_RXDISCARD_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXDISCARD_P7r,&(r._rxdiscard_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARD_P7r BCM89500_A0_RXDISCARD_P7r
#define RXDISCARD_P7r_SIZE BCM89500_A0_RXDISCARD_P7r_SIZE
typedef BCM89500_A0_RXDISCARD_P7r_t RXDISCARD_P7r_t;
#define RXDISCARD_P7r_CLR BCM89500_A0_RXDISCARD_P7r_CLR
#define RXDISCARD_P7r_SET BCM89500_A0_RXDISCARD_P7r_SET
#define RXDISCARD_P7r_GET BCM89500_A0_RXDISCARD_P7r_GET
#define READ_RXDISCARD_P7r BCM89500_A0_READ_RXDISCARD_P7r
#define WRITE_RXDISCARD_P7r BCM89500_A0_WRITE_RXDISCARD_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXDISCARD_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RXSymblErr
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXSYMBLERRr 0x000020ac

#define BCM89500_A0_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr.
 *
 */
typedef union BCM89500_A0_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t rxsymblerr[1];
	uint32_t _rxsymblerr;
} BCM89500_A0_RXSYMBLERRr_t;

#define BCM89500_A0_RXSYMBLERRr_CLR(r) (r).rxsymblerr[0] = 0
#define BCM89500_A0_RXSYMBLERRr_SET(r,d) (r).rxsymblerr[0] = d
#define BCM89500_A0_RXSYMBLERRr_GET(r) (r).rxsymblerr[0]


/*
 * These macros can be used to access RXSymblErr.
 *
 */
#define BCM89500_A0_READ_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXSYMBLERRr,(r._rxsymblerr),4)
#define BCM89500_A0_WRITE_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXSYMBLERRr,&(r._rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERRr BCM89500_A0_RXSYMBLERRr
#define RXSYMBLERRr_SIZE BCM89500_A0_RXSYMBLERRr_SIZE
typedef BCM89500_A0_RXSYMBLERRr_t RXSYMBLERRr_t;
#define RXSYMBLERRr_CLR BCM89500_A0_RXSYMBLERRr_CLR
#define RXSYMBLERRr_SET BCM89500_A0_RXSYMBLERRr_SET
#define RXSYMBLERRr_GET BCM89500_A0_RXSYMBLERRr_GET
#define READ_RXSYMBLERRr BCM89500_A0_READ_RXSYMBLERRr
#define WRITE_RXSYMBLERRr BCM89500_A0_WRITE_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RXSymblErr_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXSYMBLERR_IMPr 0x000028ac

#define BCM89500_A0_RXSYMBLERR_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr_IMP.
 *
 */
typedef union BCM89500_A0_RXSYMBLERR_IMPr_s {
	uint32_t v[1];
	uint32_t rxsymblerr_imp[1];
	uint32_t _rxsymblerr_imp;
} BCM89500_A0_RXSYMBLERR_IMPr_t;

#define BCM89500_A0_RXSYMBLERR_IMPr_CLR(r) (r).rxsymblerr_imp[0] = 0
#define BCM89500_A0_RXSYMBLERR_IMPr_SET(r,d) (r).rxsymblerr_imp[0] = d
#define BCM89500_A0_RXSYMBLERR_IMPr_GET(r) (r).rxsymblerr_imp[0]


/*
 * These macros can be used to access RXSymblErr_IMP.
 *
 */
#define BCM89500_A0_READ_RXSYMBLERR_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXSYMBLERR_IMPr,(r._rxsymblerr_imp),4)
#define BCM89500_A0_WRITE_RXSYMBLERR_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXSYMBLERR_IMPr,&(r._rxsymblerr_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERR_IMPr BCM89500_A0_RXSYMBLERR_IMPr
#define RXSYMBLERR_IMPr_SIZE BCM89500_A0_RXSYMBLERR_IMPr_SIZE
typedef BCM89500_A0_RXSYMBLERR_IMPr_t RXSYMBLERR_IMPr_t;
#define RXSYMBLERR_IMPr_CLR BCM89500_A0_RXSYMBLERR_IMPr_CLR
#define RXSYMBLERR_IMPr_SET BCM89500_A0_RXSYMBLERR_IMPr_SET
#define RXSYMBLERR_IMPr_GET BCM89500_A0_RXSYMBLERR_IMPr_GET
#define READ_RXSYMBLERR_IMPr BCM89500_A0_READ_RXSYMBLERR_IMPr
#define WRITE_RXSYMBLERR_IMPr BCM89500_A0_WRITE_RXSYMBLERR_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXSYMBLERR_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RXSymblErr_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXSYMBLERR_P7r 0x000027ac

#define BCM89500_A0_RXSYMBLERR_P7r_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr_P7.
 *
 */
typedef union BCM89500_A0_RXSYMBLERR_P7r_s {
	uint32_t v[1];
	uint32_t rxsymblerr_p7[1];
	uint32_t _rxsymblerr_p7;
} BCM89500_A0_RXSYMBLERR_P7r_t;

#define BCM89500_A0_RXSYMBLERR_P7r_CLR(r) (r).rxsymblerr_p7[0] = 0
#define BCM89500_A0_RXSYMBLERR_P7r_SET(r,d) (r).rxsymblerr_p7[0] = d
#define BCM89500_A0_RXSYMBLERR_P7r_GET(r) (r).rxsymblerr_p7[0]


/*
 * These macros can be used to access RXSymblErr_P7.
 *
 */
#define BCM89500_A0_READ_RXSYMBLERR_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXSYMBLERR_P7r,(r._rxsymblerr_p7),4)
#define BCM89500_A0_WRITE_RXSYMBLERR_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXSYMBLERR_P7r,&(r._rxsymblerr_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERR_P7r BCM89500_A0_RXSYMBLERR_P7r
#define RXSYMBLERR_P7r_SIZE BCM89500_A0_RXSYMBLERR_P7r_SIZE
typedef BCM89500_A0_RXSYMBLERR_P7r_t RXSYMBLERR_P7r_t;
#define RXSYMBLERR_P7r_CLR BCM89500_A0_RXSYMBLERR_P7r_CLR
#define RXSYMBLERR_P7r_SET BCM89500_A0_RXSYMBLERR_P7r_SET
#define RXSYMBLERR_P7r_GET BCM89500_A0_RXSYMBLERR_P7r_GET
#define READ_RXSYMBLERR_P7r BCM89500_A0_READ_RXSYMBLERR_P7r
#define WRITE_RXSYMBLERR_P7r BCM89500_A0_WRITE_RXSYMBLERR_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXSYMBLERR_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_CF_SPEC
 * BLOCKS:   SYS
 * DESC:     Enable RX CF update Registers
 * SIZE:     16
 * FIELDS:
 *     RX_CF_SPEC       Individual bits enable CF update when timestamp insertion enable in RX portbit 7 -- enable RX port 8bit 6 -- enable RX port 7bit 5 -- enable RX port 5bit 4 -- enable RX port 4bit 3 -- enable RX port 3bit 2 -- enable RX port 2bit 1 -- enable RX port 1bit 0 -- enable RX port 0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_CF_SPECr 0x00009476

#define BCM89500_A0_RX_CF_SPECr_SIZE 2

/*
 * This structure should be used to declare and program RX_CF_SPEC.
 *
 */
typedef union BCM89500_A0_RX_CF_SPECr_s {
	uint32_t v[1];
	uint32_t rx_cf_spec[1];
	uint32_t _rx_cf_spec;
} BCM89500_A0_RX_CF_SPECr_t;

#define BCM89500_A0_RX_CF_SPECr_CLR(r) (r).rx_cf_spec[0] = 0
#define BCM89500_A0_RX_CF_SPECr_SET(r,d) (r).rx_cf_spec[0] = d
#define BCM89500_A0_RX_CF_SPECr_GET(r) (r).rx_cf_spec[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_CF_SPECr_RX_CF_SPECf_GET(r) (((r).rx_cf_spec[0]) & 0xff)
#define BCM89500_A0_RX_CF_SPECr_RX_CF_SPECf_SET(r,f) (r).rx_cf_spec[0]=(((r).rx_cf_spec[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_RX_CF_SPECr_RESERVEDf_GET(r) ((((r).rx_cf_spec[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_CF_SPECr_RESERVEDf_SET(r,f) (r).rx_cf_spec[0]=(((r).rx_cf_spec[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_CF_SPEC.
 *
 */
#define BCM89500_A0_READ_RX_CF_SPECr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_CF_SPECr,(r._rx_cf_spec),2)
#define BCM89500_A0_WRITE_RX_CF_SPECr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_CF_SPECr,&(r._rx_cf_spec),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_CF_SPECr BCM89500_A0_RX_CF_SPECr
#define RX_CF_SPECr_SIZE BCM89500_A0_RX_CF_SPECr_SIZE
typedef BCM89500_A0_RX_CF_SPECr_t RX_CF_SPECr_t;
#define RX_CF_SPECr_CLR BCM89500_A0_RX_CF_SPECr_CLR
#define RX_CF_SPECr_SET BCM89500_A0_RX_CF_SPECr_SET
#define RX_CF_SPECr_GET BCM89500_A0_RX_CF_SPECr_GET
#define RX_CF_SPECr_RX_CF_SPECf_GET BCM89500_A0_RX_CF_SPECr_RX_CF_SPECf_GET
#define RX_CF_SPECr_RX_CF_SPECf_SET BCM89500_A0_RX_CF_SPECr_RX_CF_SPECf_SET
#define RX_CF_SPECr_RESERVEDf_GET BCM89500_A0_RX_CF_SPECr_RESERVEDf_GET
#define RX_CF_SPECr_RESERVEDf_SET BCM89500_A0_RX_CF_SPECr_RESERVEDf_SET
#define READ_RX_CF_SPECr BCM89500_A0_READ_RX_CF_SPECr
#define WRITE_RX_CF_SPECr BCM89500_A0_WRITE_RX_CF_SPECr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_CF_SPECr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_COUNTER
 * BLOCKS:   SYS
 * DESC:     RX Counter Register
 * SIZE:     16
 * FIELDS:
 *     RX_COUNTER       The number of packets into RX side.
 *
 ******************************************************************************/
#define BCM89500_A0_RX_COUNTERr 0x000093e6

#define BCM89500_A0_RX_COUNTERr_SIZE 2

/*
 * This structure should be used to declare and program RX_COUNTER.
 *
 */
typedef union BCM89500_A0_RX_COUNTERr_s {
	uint32_t v[1];
	uint32_t rx_counter[1];
	uint32_t _rx_counter;
} BCM89500_A0_RX_COUNTERr_t;

#define BCM89500_A0_RX_COUNTERr_CLR(r) (r).rx_counter[0] = 0
#define BCM89500_A0_RX_COUNTERr_SET(r,d) (r).rx_counter[0] = d
#define BCM89500_A0_RX_COUNTERr_GET(r) (r).rx_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_COUNTERr_RX_COUNTERf_GET(r) (((r).rx_counter[0]) & 0xffff)
#define BCM89500_A0_RX_COUNTERr_RX_COUNTERf_SET(r,f) (r).rx_counter[0]=(((r).rx_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_COUNTER.
 *
 */
#define BCM89500_A0_READ_RX_COUNTERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_COUNTERr,(r._rx_counter),2)
#define BCM89500_A0_WRITE_RX_COUNTERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_COUNTERr,&(r._rx_counter),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_COUNTERr BCM89500_A0_RX_COUNTERr
#define RX_COUNTERr_SIZE BCM89500_A0_RX_COUNTERr_SIZE
typedef BCM89500_A0_RX_COUNTERr_t RX_COUNTERr_t;
#define RX_COUNTERr_CLR BCM89500_A0_RX_COUNTERr_CLR
#define RX_COUNTERr_SET BCM89500_A0_RX_COUNTERr_SET
#define RX_COUNTERr_GET BCM89500_A0_RX_COUNTERr_GET
#define RX_COUNTERr_RX_COUNTERf_GET BCM89500_A0_RX_COUNTERr_RX_COUNTERf_GET
#define RX_COUNTERr_RX_COUNTERf_SET BCM89500_A0_RX_COUNTERr_RX_COUNTERf_SET
#define READ_RX_COUNTERr BCM89500_A0_READ_RX_COUNTERr
#define WRITE_RX_COUNTERr BCM89500_A0_WRITE_RX_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_CTL
 * BLOCKS:   SYS
 * DESC:     Receive Control Registers
 * SIZE:     16
 * FIELDS:
 *     RX_IPV6_UDP_EN   Enables the 1588 L4/UDP IPV6 packet detection in receiving side.
 *     RX_IPV4_UDP_EN   Enables the 1588 L4/UDP IPV4 packet detection in receiving side.
 *     RX_L2_EN         Enables the 1588 L2 packet detection in receiving side.
 *     RX_AS_EN         Enables the 802.1as packet detection in receiving side.
 *     RX_L4_IPV6_ADDRESS_EN Enables the Layer4 IP address check when 1588 detection in receiving side.
 *     RX_L4_IP_ADDRESS_EN Enables the Layer4 IP address check when 1588 detection in receiving side.
 *     RX_L2_DA_EN      Enables the Layer2 MAC DA check when 1588 detection in receiving side. 48'h011b_1900_0000 or 48'h0180_c200_000e
 *     RX_AS_DA_EN      Enables the 802.1as MAC DA check when 1588 detection in receiving side.  48'h0180_c200_000e
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_CTLr 0x000093a2

#define BCM89500_A0_RX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program RX_CTL.
 *
 */
typedef union BCM89500_A0_RX_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ctl[1];
	uint32_t _rx_ctl;
} BCM89500_A0_RX_CTLr_t;

#define BCM89500_A0_RX_CTLr_CLR(r) (r).rx_ctl[0] = 0
#define BCM89500_A0_RX_CTLr_SET(r,d) (r).rx_ctl[0] = d
#define BCM89500_A0_RX_CTLr_GET(r) (r).rx_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_CTLr_RX_IPV6_UDP_ENf_GET(r) (((r).rx_ctl[0]) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_IPV6_UDP_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_RX_CTLr_RX_IPV4_UDP_ENf_GET(r) ((((r).rx_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_IPV4_UDP_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_RX_CTLr_RX_L2_ENf_GET(r) ((((r).rx_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_L2_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_RX_CTLr_RX_AS_ENf_GET(r) ((((r).rx_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_AS_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_RX_CTLr_RX_L4_IPV6_ADDRESS_ENf_GET(r) ((((r).rx_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_L4_IPV6_ADDRESS_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_RX_CTLr_RX_L4_IP_ADDRESS_ENf_GET(r) ((((r).rx_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_L4_IP_ADDRESS_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_RX_CTLr_RX_L2_DA_ENf_GET(r) ((((r).rx_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_L2_DA_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_RX_CTLr_RX_AS_DA_ENf_GET(r) ((((r).rx_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_RX_CTLr_RX_AS_DA_ENf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_RX_CTLr_RESERVEDf_GET(r) ((((r).rx_ctl[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_CTLr_RESERVEDf_SET(r,f) (r).rx_ctl[0]=(((r).rx_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_CTL.
 *
 */
#define BCM89500_A0_READ_RX_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_CTLr,(r._rx_ctl),2)
#define BCM89500_A0_WRITE_RX_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_CTLr,&(r._rx_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_CTLr BCM89500_A0_RX_CTLr
#define RX_CTLr_SIZE BCM89500_A0_RX_CTLr_SIZE
typedef BCM89500_A0_RX_CTLr_t RX_CTLr_t;
#define RX_CTLr_CLR BCM89500_A0_RX_CTLr_CLR
#define RX_CTLr_SET BCM89500_A0_RX_CTLr_SET
#define RX_CTLr_GET BCM89500_A0_RX_CTLr_GET
#define RX_CTLr_RX_IPV6_UDP_ENf_GET BCM89500_A0_RX_CTLr_RX_IPV6_UDP_ENf_GET
#define RX_CTLr_RX_IPV6_UDP_ENf_SET BCM89500_A0_RX_CTLr_RX_IPV6_UDP_ENf_SET
#define RX_CTLr_RX_IPV4_UDP_ENf_GET BCM89500_A0_RX_CTLr_RX_IPV4_UDP_ENf_GET
#define RX_CTLr_RX_IPV4_UDP_ENf_SET BCM89500_A0_RX_CTLr_RX_IPV4_UDP_ENf_SET
#define RX_CTLr_RX_L2_ENf_GET BCM89500_A0_RX_CTLr_RX_L2_ENf_GET
#define RX_CTLr_RX_L2_ENf_SET BCM89500_A0_RX_CTLr_RX_L2_ENf_SET
#define RX_CTLr_RX_AS_ENf_GET BCM89500_A0_RX_CTLr_RX_AS_ENf_GET
#define RX_CTLr_RX_AS_ENf_SET BCM89500_A0_RX_CTLr_RX_AS_ENf_SET
#define RX_CTLr_RX_L4_IPV6_ADDRESS_ENf_GET BCM89500_A0_RX_CTLr_RX_L4_IPV6_ADDRESS_ENf_GET
#define RX_CTLr_RX_L4_IPV6_ADDRESS_ENf_SET BCM89500_A0_RX_CTLr_RX_L4_IPV6_ADDRESS_ENf_SET
#define RX_CTLr_RX_L4_IP_ADDRESS_ENf_GET BCM89500_A0_RX_CTLr_RX_L4_IP_ADDRESS_ENf_GET
#define RX_CTLr_RX_L4_IP_ADDRESS_ENf_SET BCM89500_A0_RX_CTLr_RX_L4_IP_ADDRESS_ENf_SET
#define RX_CTLr_RX_L2_DA_ENf_GET BCM89500_A0_RX_CTLr_RX_L2_DA_ENf_GET
#define RX_CTLr_RX_L2_DA_ENf_SET BCM89500_A0_RX_CTLr_RX_L2_DA_ENf_SET
#define RX_CTLr_RX_AS_DA_ENf_GET BCM89500_A0_RX_CTLr_RX_AS_DA_ENf_GET
#define RX_CTLr_RX_AS_DA_ENf_SET BCM89500_A0_RX_CTLr_RX_AS_DA_ENf_SET
#define RX_CTLr_RESERVEDf_GET BCM89500_A0_RX_CTLr_RESERVEDf_GET
#define RX_CTLr_RESERVEDf_SET BCM89500_A0_RX_CTLr_RESERVEDf_SET
#define READ_RX_CTLr BCM89500_A0_READ_RX_CTLr
#define WRITE_RX_CTLr BCM89500_A0_WRITE_RX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     RX Global Control register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     FMOK_LATENCY_CNT fmok latency counter.
 *     DIS_CRC_CHK      Disable Ingress CRC check.
 *     DIS_ECC_CHK      Disable ECC check for all SRAM which implement the ECC, except Buffer Tag and TXQ.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_GLOBAL_CTLr 0x0000000a

#define BCM89500_A0_RX_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RX_GLOBAL_CTL.
 *
 */
typedef union BCM89500_A0_RX_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_global_ctl[1];
	uint32_t _rx_global_ctl;
} BCM89500_A0_RX_GLOBAL_CTLr_t;

#define BCM89500_A0_RX_GLOBAL_CTLr_CLR(r) (r).rx_global_ctl[0] = 0
#define BCM89500_A0_RX_GLOBAL_CTLr_SET(r,d) (r).rx_global_ctl[0] = d
#define BCM89500_A0_RX_GLOBAL_CTLr_GET(r) (r).rx_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET(r) (((r).rx_global_ctl[0]) & 0xf)
#define BCM89500_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_RX_GLOBAL_CTLr_RESERVEDf_GET(r) ((((r).rx_global_ctl[0]) >> 6) & 0x3)
#define BCM89500_A0_RX_GLOBAL_CTLr_RESERVEDf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RX_GLOBAL_CTL.
 *
 */
#define BCM89500_A0_READ_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_GLOBAL_CTLr,(r._rx_global_ctl),1)
#define BCM89500_A0_WRITE_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_GLOBAL_CTLr,&(r._rx_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_GLOBAL_CTLr BCM89500_A0_RX_GLOBAL_CTLr
#define RX_GLOBAL_CTLr_SIZE BCM89500_A0_RX_GLOBAL_CTLr_SIZE
typedef BCM89500_A0_RX_GLOBAL_CTLr_t RX_GLOBAL_CTLr_t;
#define RX_GLOBAL_CTLr_CLR BCM89500_A0_RX_GLOBAL_CTLr_CLR
#define RX_GLOBAL_CTLr_SET BCM89500_A0_RX_GLOBAL_CTLr_SET
#define RX_GLOBAL_CTLr_GET BCM89500_A0_RX_GLOBAL_CTLr_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET BCM89500_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET BCM89500_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET BCM89500_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET BCM89500_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET BCM89500_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET BCM89500_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET
#define RX_GLOBAL_CTLr_RESERVEDf_GET BCM89500_A0_RX_GLOBAL_CTLr_RESERVEDf_GET
#define RX_GLOBAL_CTLr_RESERVEDf_SET BCM89500_A0_RX_GLOBAL_CTLr_RESERVEDf_SET
#define READ_RX_GLOBAL_CTLr BCM89500_A0_READ_RX_GLOBAL_CTLr
#define WRITE_RX_GLOBAL_CTLr BCM89500_A0_WRITE_RX_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_MODE_PORT
 * BLOCKS:   SYS
 * DESC:     Port N RX Event Message Mode1 Selection Registers
 * SIZE:     16
 * FIELDS:
 *     RX_MODE1_M0      RX Port mode selection -- event message 0Example:{bit1, bit0}2'b00: event 0 message - NA2'b01: event 0 message - update correction field2'b10: event 0 message - insert timestamp2'b11: event 0 message - insert internal IEEE time code[63:0] or "previous frame sync time stamp"
 *     RX_MODE1_M1      RX Port mode selection -- event message 1
 *     RX_MODE1_M2      RX Port mode selection -- event message 2
 *     RX_MODE1_M3      RX Port mode selection -- event message 3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_MODE_PORTr 0x00009312

#define BCM89500_A0_RX_MODE_PORTr_SIZE 2

/*
 * This structure should be used to declare and program RX_MODE_PORT.
 *
 */
typedef union BCM89500_A0_RX_MODE_PORTr_s {
	uint32_t v[1];
	uint32_t rx_mode_port[1];
	uint32_t _rx_mode_port;
} BCM89500_A0_RX_MODE_PORTr_t;

#define BCM89500_A0_RX_MODE_PORTr_CLR(r) (r).rx_mode_port[0] = 0
#define BCM89500_A0_RX_MODE_PORTr_SET(r,d) (r).rx_mode_port[0] = d
#define BCM89500_A0_RX_MODE_PORTr_GET(r) (r).rx_mode_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M0f_GET(r) (((r).rx_mode_port[0]) & 0x3)
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M0f_SET(r,f) (r).rx_mode_port[0]=(((r).rx_mode_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M1f_GET(r) ((((r).rx_mode_port[0]) >> 2) & 0x3)
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M1f_SET(r,f) (r).rx_mode_port[0]=(((r).rx_mode_port[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M2f_GET(r) ((((r).rx_mode_port[0]) >> 4) & 0x3)
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M2f_SET(r,f) (r).rx_mode_port[0]=(((r).rx_mode_port[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M3f_GET(r) ((((r).rx_mode_port[0]) >> 6) & 0x3)
#define BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M3f_SET(r,f) (r).rx_mode_port[0]=(((r).rx_mode_port[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_RX_MODE_PORTr_RESERVEDf_GET(r) ((((r).rx_mode_port[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_MODE_PORTr_RESERVEDf_SET(r,f) (r).rx_mode_port[0]=(((r).rx_mode_port[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_MODE_PORT.
 *
 */
#define BCM89500_A0_READ_RX_MODE_PORTr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_RX_MODE_PORTr+(2*(i)),(r._rx_mode_port),2)
#define BCM89500_A0_WRITE_RX_MODE_PORTr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_RX_MODE_PORTr+(2*(i)),&(r._rx_mode_port),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_MODE_PORTr BCM89500_A0_RX_MODE_PORTr
#define RX_MODE_PORTr_SIZE BCM89500_A0_RX_MODE_PORTr_SIZE
typedef BCM89500_A0_RX_MODE_PORTr_t RX_MODE_PORTr_t;
#define RX_MODE_PORTr_CLR BCM89500_A0_RX_MODE_PORTr_CLR
#define RX_MODE_PORTr_SET BCM89500_A0_RX_MODE_PORTr_SET
#define RX_MODE_PORTr_GET BCM89500_A0_RX_MODE_PORTr_GET
#define RX_MODE_PORTr_RX_MODE1_M0f_GET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M0f_GET
#define RX_MODE_PORTr_RX_MODE1_M0f_SET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M0f_SET
#define RX_MODE_PORTr_RX_MODE1_M1f_GET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M1f_GET
#define RX_MODE_PORTr_RX_MODE1_M1f_SET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M1f_SET
#define RX_MODE_PORTr_RX_MODE1_M2f_GET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M2f_GET
#define RX_MODE_PORTr_RX_MODE1_M2f_SET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M2f_SET
#define RX_MODE_PORTr_RX_MODE1_M3f_GET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M3f_GET
#define RX_MODE_PORTr_RX_MODE1_M3f_SET BCM89500_A0_RX_MODE_PORTr_RX_MODE1_M3f_SET
#define RX_MODE_PORTr_RESERVEDf_GET BCM89500_A0_RX_MODE_PORTr_RESERVEDf_GET
#define RX_MODE_PORTr_RESERVEDf_SET BCM89500_A0_RX_MODE_PORTr_RESERVEDf_SET
#define READ_RX_MODE_PORTr BCM89500_A0_READ_RX_MODE_PORTr
#define WRITE_RX_MODE_PORTr BCM89500_A0_WRITE_RX_MODE_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_MODE_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_MODE_PORT_IMP
 * BLOCKS:   SYS
 * DESC:     Port 8 RX Event Message Mode1 Selection Registers
 * SIZE:     16
 * FIELDS:
 *     RX_MODE1_M0      RX Port mode selection -- event message 0Example:{bit1, bit0}2'b00: event 0 message - NA2'b01: event 0 message - update correction field2'b10: event 0 message - insert timestamp2'b11: event 0 message - insert internal IEEE time code[63:0] or "previous frame sync time stamp"
 *     RX_MODE1_M1      RX Port mode selection -- event message 1
 *     RX_MODE1_M2      RX Port mode selection -- event message 2
 *     RX_MODE1_M3      RX Port mode selection -- event message 3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_MODE_PORT_IMPr 0x00009320

#define BCM89500_A0_RX_MODE_PORT_IMPr_SIZE 2

/*
 * This structure should be used to declare and program RX_MODE_PORT_IMP.
 *
 */
typedef union BCM89500_A0_RX_MODE_PORT_IMPr_s {
	uint32_t v[1];
	uint32_t rx_mode_port_imp[1];
	uint32_t _rx_mode_port_imp;
} BCM89500_A0_RX_MODE_PORT_IMPr_t;

#define BCM89500_A0_RX_MODE_PORT_IMPr_CLR(r) (r).rx_mode_port_imp[0] = 0
#define BCM89500_A0_RX_MODE_PORT_IMPr_SET(r,d) (r).rx_mode_port_imp[0] = d
#define BCM89500_A0_RX_MODE_PORT_IMPr_GET(r) (r).rx_mode_port_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M0f_GET(r) (((r).rx_mode_port_imp[0]) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M0f_SET(r,f) (r).rx_mode_port_imp[0]=(((r).rx_mode_port_imp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M1f_GET(r) ((((r).rx_mode_port_imp[0]) >> 2) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M1f_SET(r,f) (r).rx_mode_port_imp[0]=(((r).rx_mode_port_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M2f_GET(r) ((((r).rx_mode_port_imp[0]) >> 4) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M2f_SET(r,f) (r).rx_mode_port_imp[0]=(((r).rx_mode_port_imp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M3f_GET(r) ((((r).rx_mode_port_imp[0]) >> 6) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M3f_SET(r,f) (r).rx_mode_port_imp[0]=(((r).rx_mode_port_imp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_RX_MODE_PORT_IMPr_RESERVEDf_GET(r) ((((r).rx_mode_port_imp[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_MODE_PORT_IMPr_RESERVEDf_SET(r,f) (r).rx_mode_port_imp[0]=(((r).rx_mode_port_imp[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_MODE_PORT_IMP.
 *
 */
#define BCM89500_A0_READ_RX_MODE_PORT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_MODE_PORT_IMPr,(r._rx_mode_port_imp),2)
#define BCM89500_A0_WRITE_RX_MODE_PORT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_MODE_PORT_IMPr,&(r._rx_mode_port_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_MODE_PORT_IMPr BCM89500_A0_RX_MODE_PORT_IMPr
#define RX_MODE_PORT_IMPr_SIZE BCM89500_A0_RX_MODE_PORT_IMPr_SIZE
typedef BCM89500_A0_RX_MODE_PORT_IMPr_t RX_MODE_PORT_IMPr_t;
#define RX_MODE_PORT_IMPr_CLR BCM89500_A0_RX_MODE_PORT_IMPr_CLR
#define RX_MODE_PORT_IMPr_SET BCM89500_A0_RX_MODE_PORT_IMPr_SET
#define RX_MODE_PORT_IMPr_GET BCM89500_A0_RX_MODE_PORT_IMPr_GET
#define RX_MODE_PORT_IMPr_RX_MODE1_M0f_GET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M0f_GET
#define RX_MODE_PORT_IMPr_RX_MODE1_M0f_SET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M0f_SET
#define RX_MODE_PORT_IMPr_RX_MODE1_M1f_GET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M1f_GET
#define RX_MODE_PORT_IMPr_RX_MODE1_M1f_SET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M1f_SET
#define RX_MODE_PORT_IMPr_RX_MODE1_M2f_GET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M2f_GET
#define RX_MODE_PORT_IMPr_RX_MODE1_M2f_SET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M2f_SET
#define RX_MODE_PORT_IMPr_RX_MODE1_M3f_GET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M3f_GET
#define RX_MODE_PORT_IMPr_RX_MODE1_M3f_SET BCM89500_A0_RX_MODE_PORT_IMPr_RX_MODE1_M3f_SET
#define RX_MODE_PORT_IMPr_RESERVEDf_GET BCM89500_A0_RX_MODE_PORT_IMPr_RESERVEDf_GET
#define RX_MODE_PORT_IMPr_RESERVEDf_SET BCM89500_A0_RX_MODE_PORT_IMPr_RESERVEDf_SET
#define READ_RX_MODE_PORT_IMPr BCM89500_A0_READ_RX_MODE_PORT_IMPr
#define WRITE_RX_MODE_PORT_IMPr BCM89500_A0_WRITE_RX_MODE_PORT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_MODE_PORT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_MODE_PORT_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 RX Event Message Mode1 Selection Registers
 * SIZE:     16
 * FIELDS:
 *     RX_MODE1_M0      RX Port mode selection -- event message 0Example:{bit1, bit0}2'b00: event 0 message - NA2'b01: event 0 message - update correction field2'b10: event 0 message - insert timestamp2'b11: event 0 message - insert internal IEEE time code[63:0] or "previous frame sync time stamp"
 *     RX_MODE1_M1      RX Port mode selection -- event message 1
 *     RX_MODE1_M2      RX Port mode selection -- event message 2
 *     RX_MODE1_M3      RX Port mode selection -- event message 3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_MODE_PORT_P7r 0x0000931e

#define BCM89500_A0_RX_MODE_PORT_P7r_SIZE 2

/*
 * This structure should be used to declare and program RX_MODE_PORT_P7.
 *
 */
typedef union BCM89500_A0_RX_MODE_PORT_P7r_s {
	uint32_t v[1];
	uint32_t rx_mode_port_p7[1];
	uint32_t _rx_mode_port_p7;
} BCM89500_A0_RX_MODE_PORT_P7r_t;

#define BCM89500_A0_RX_MODE_PORT_P7r_CLR(r) (r).rx_mode_port_p7[0] = 0
#define BCM89500_A0_RX_MODE_PORT_P7r_SET(r,d) (r).rx_mode_port_p7[0] = d
#define BCM89500_A0_RX_MODE_PORT_P7r_GET(r) (r).rx_mode_port_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M0f_GET(r) (((r).rx_mode_port_p7[0]) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M0f_SET(r,f) (r).rx_mode_port_p7[0]=(((r).rx_mode_port_p7[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M1f_GET(r) ((((r).rx_mode_port_p7[0]) >> 2) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M1f_SET(r,f) (r).rx_mode_port_p7[0]=(((r).rx_mode_port_p7[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M2f_GET(r) ((((r).rx_mode_port_p7[0]) >> 4) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M2f_SET(r,f) (r).rx_mode_port_p7[0]=(((r).rx_mode_port_p7[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M3f_GET(r) ((((r).rx_mode_port_p7[0]) >> 6) & 0x3)
#define BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M3f_SET(r,f) (r).rx_mode_port_p7[0]=(((r).rx_mode_port_p7[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_RX_MODE_PORT_P7r_RESERVEDf_GET(r) ((((r).rx_mode_port_p7[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_MODE_PORT_P7r_RESERVEDf_SET(r,f) (r).rx_mode_port_p7[0]=(((r).rx_mode_port_p7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_MODE_PORT_P7.
 *
 */
#define BCM89500_A0_READ_RX_MODE_PORT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_MODE_PORT_P7r,(r._rx_mode_port_p7),2)
#define BCM89500_A0_WRITE_RX_MODE_PORT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_MODE_PORT_P7r,&(r._rx_mode_port_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_MODE_PORT_P7r BCM89500_A0_RX_MODE_PORT_P7r
#define RX_MODE_PORT_P7r_SIZE BCM89500_A0_RX_MODE_PORT_P7r_SIZE
typedef BCM89500_A0_RX_MODE_PORT_P7r_t RX_MODE_PORT_P7r_t;
#define RX_MODE_PORT_P7r_CLR BCM89500_A0_RX_MODE_PORT_P7r_CLR
#define RX_MODE_PORT_P7r_SET BCM89500_A0_RX_MODE_PORT_P7r_SET
#define RX_MODE_PORT_P7r_GET BCM89500_A0_RX_MODE_PORT_P7r_GET
#define RX_MODE_PORT_P7r_RX_MODE1_M0f_GET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M0f_GET
#define RX_MODE_PORT_P7r_RX_MODE1_M0f_SET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M0f_SET
#define RX_MODE_PORT_P7r_RX_MODE1_M1f_GET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M1f_GET
#define RX_MODE_PORT_P7r_RX_MODE1_M1f_SET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M1f_SET
#define RX_MODE_PORT_P7r_RX_MODE1_M2f_GET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M2f_GET
#define RX_MODE_PORT_P7r_RX_MODE1_M2f_SET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M2f_SET
#define RX_MODE_PORT_P7r_RX_MODE1_M3f_GET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M3f_GET
#define RX_MODE_PORT_P7r_RX_MODE1_M3f_SET BCM89500_A0_RX_MODE_PORT_P7r_RX_MODE1_M3f_SET
#define RX_MODE_PORT_P7r_RESERVEDf_GET BCM89500_A0_RX_MODE_PORT_P7r_RESERVEDf_GET
#define RX_MODE_PORT_P7r_RESERVEDf_SET BCM89500_A0_RX_MODE_PORT_P7r_RESERVEDf_SET
#define READ_RX_MODE_PORT_P7r BCM89500_A0_READ_RX_MODE_PORT_P7r
#define WRITE_RX_MODE_PORT_P7r BCM89500_A0_WRITE_RX_MODE_PORT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_MODE_PORT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for RX Register
 * SIZE:     16
 * FIELDS:
 *     RX_PAUSE_PASS    RX pause pass through map.bit[7] : Port 7.bit[5:0] : Port 5-01 : ignore 802.3x.0 : comply with 802.3x pause frame receiving.
 *     RESERVED_0       Reserved, it is illegal to write to '1'.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PAUSE_PASSr 0x00000038

#define BCM89500_A0_RX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program RX_PAUSE_PASS.
 *
 */
typedef union BCM89500_A0_RX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t rx_pause_pass[1];
	uint32_t _rx_pause_pass;
} BCM89500_A0_RX_PAUSE_PASSr_t;

#define BCM89500_A0_RX_PAUSE_PASSr_CLR(r) (r).rx_pause_pass[0] = 0
#define BCM89500_A0_RX_PAUSE_PASSr_SET(r,d) (r).rx_pause_pass[0] = d
#define BCM89500_A0_RX_PAUSE_PASSr_GET(r) (r).rx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET(r) (((r).rx_pause_pass[0]) & 0xff)
#define BCM89500_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_RX_PAUSE_PASSr_RESERVED_0f_GET(r) ((((r).rx_pause_pass[0]) >> 8) & 0x1)
#define BCM89500_A0_RX_PAUSE_PASSr_RESERVED_0f_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_RX_PAUSE_PASSr_RESERVED_1f_GET(r) ((((r).rx_pause_pass[0]) >> 9) & 0x7f)
#define BCM89500_A0_RX_PAUSE_PASSr_RESERVED_1f_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RX_PAUSE_PASS.
 *
 */
#define BCM89500_A0_READ_RX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PAUSE_PASSr,(r._rx_pause_pass),2)
#define BCM89500_A0_WRITE_RX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PAUSE_PASSr,&(r._rx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PAUSE_PASSr BCM89500_A0_RX_PAUSE_PASSr
#define RX_PAUSE_PASSr_SIZE BCM89500_A0_RX_PAUSE_PASSr_SIZE
typedef BCM89500_A0_RX_PAUSE_PASSr_t RX_PAUSE_PASSr_t;
#define RX_PAUSE_PASSr_CLR BCM89500_A0_RX_PAUSE_PASSr_CLR
#define RX_PAUSE_PASSr_SET BCM89500_A0_RX_PAUSE_PASSr_SET
#define RX_PAUSE_PASSr_GET BCM89500_A0_RX_PAUSE_PASSr_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET BCM89500_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET BCM89500_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET
#define RX_PAUSE_PASSr_RESERVED_0f_GET BCM89500_A0_RX_PAUSE_PASSr_RESERVED_0f_GET
#define RX_PAUSE_PASSr_RESERVED_0f_SET BCM89500_A0_RX_PAUSE_PASSr_RESERVED_0f_SET
#define RX_PAUSE_PASSr_RESERVED_1f_GET BCM89500_A0_RX_PAUSE_PASSr_RESERVED_1f_GET
#define RX_PAUSE_PASSr_RESERVED_1f_SET BCM89500_A0_RX_PAUSE_PASSr_RESERVED_1f_SET
#define READ_RX_PAUSE_PASSr BCM89500_A0_READ_RX_PAUSE_PASSr
#define WRITE_RX_PAUSE_PASSr BCM89500_A0_WRITE_RX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_0_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 0 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr 0x00009328

#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_0_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_0_link_delay_lsb[1];
	uint32_t _rx_port_0_link_delay_lsb;
} BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_CLR(r) (r).rx_port_0_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_0_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_GET(r) (r).rx_port_0_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_0_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_0_link_delay_lsb[0]=(((r).rx_port_0_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_0_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_0_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr,(r._rx_port_0_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_0_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr,&(r._rx_port_0_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_0_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr
#define RX_PORT_0_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_t RX_PORT_0_LINK_DELAY_LSBr_t;
#define RX_PORT_0_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_CLR
#define RX_PORT_0_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_SET
#define RX_PORT_0_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_GET
#define RX_PORT_0_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_0_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_0_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_0_LINK_DELAY_LSBr
#define WRITE_RX_PORT_0_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_0_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_0_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_0_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 0 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr 0x0000932a

#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_0_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_0_link_delay_msb[1];
	uint32_t _rx_port_0_link_delay_msb;
} BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_CLR(r) (r).rx_port_0_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_0_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_GET(r) (r).rx_port_0_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_0_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_0_link_delay_msb[0]=(((r).rx_port_0_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_0_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_0_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr,(r._rx_port_0_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_0_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr,&(r._rx_port_0_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_0_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr
#define RX_PORT_0_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_t RX_PORT_0_LINK_DELAY_MSBr_t;
#define RX_PORT_0_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_CLR
#define RX_PORT_0_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_SET
#define RX_PORT_0_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_GET
#define RX_PORT_0_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_0_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_0_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_0_LINK_DELAY_MSBr
#define WRITE_RX_PORT_0_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_0_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_0_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_0_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 0 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr 0x00009348

#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_0_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_0_ts_offset_lsb[1];
	uint32_t _rx_port_0_ts_offset_lsb;
} BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_CLR(r) (r).rx_port_0_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_0_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_GET(r) (r).rx_port_0_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_0_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_0_ts_offset_lsb[0]=(((r).rx_port_0_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_0_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_0_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr,(r._rx_port_0_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_0_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr,&(r._rx_port_0_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_0_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr
#define RX_PORT_0_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_t RX_PORT_0_TS_OFFSET_LSBr_t;
#define RX_PORT_0_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_CLR
#define RX_PORT_0_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_SET
#define RX_PORT_0_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_GET
#define RX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_0_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_0_TS_OFFSET_LSBr
#define WRITE_RX_PORT_0_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_0_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_0_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_0_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 0 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr 0x0000934a

#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_0_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_0_ts_offset_msb[1];
	uint32_t _rx_port_0_ts_offset_msb;
} BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_CLR(r) (r).rx_port_0_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_0_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_GET(r) (r).rx_port_0_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_0_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_0_ts_offset_msb[0]=(((r).rx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_0_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_0_ts_offset_msb[0]=(((r).rx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_0_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_0_ts_offset_msb[0]=(((r).rx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_0_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_0_ts_offset_msb[0]=(((r).rx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_0_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_0_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr,(r._rx_port_0_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_0_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr,&(r._rx_port_0_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_0_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr
#define RX_PORT_0_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_t RX_PORT_0_TS_OFFSET_MSBr_t;
#define RX_PORT_0_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_CLR
#define RX_PORT_0_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_SET
#define RX_PORT_0_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_GET
#define RX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_0_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_0_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_0_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_0_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_0_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_0_TS_OFFSET_MSBr
#define WRITE_RX_PORT_0_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_0_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_0_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_1_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 1 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr 0x0000932c

#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_1_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_1_link_delay_lsb[1];
	uint32_t _rx_port_1_link_delay_lsb;
} BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_CLR(r) (r).rx_port_1_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_1_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_GET(r) (r).rx_port_1_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_1_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_1_link_delay_lsb[0]=(((r).rx_port_1_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_1_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_1_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr,(r._rx_port_1_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_1_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr,&(r._rx_port_1_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_1_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr
#define RX_PORT_1_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_t RX_PORT_1_LINK_DELAY_LSBr_t;
#define RX_PORT_1_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_CLR
#define RX_PORT_1_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_SET
#define RX_PORT_1_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_GET
#define RX_PORT_1_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_1_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_1_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_1_LINK_DELAY_LSBr
#define WRITE_RX_PORT_1_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_1_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_1_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_1_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 1 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr 0x0000932e

#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_1_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_1_link_delay_msb[1];
	uint32_t _rx_port_1_link_delay_msb;
} BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_CLR(r) (r).rx_port_1_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_1_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_GET(r) (r).rx_port_1_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_1_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_1_link_delay_msb[0]=(((r).rx_port_1_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_1_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_1_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr,(r._rx_port_1_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_1_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr,&(r._rx_port_1_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_1_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr
#define RX_PORT_1_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_t RX_PORT_1_LINK_DELAY_MSBr_t;
#define RX_PORT_1_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_CLR
#define RX_PORT_1_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_SET
#define RX_PORT_1_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_GET
#define RX_PORT_1_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_1_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_1_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_1_LINK_DELAY_MSBr
#define WRITE_RX_PORT_1_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_1_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_1_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_1_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 1 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr 0x0000934c

#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_1_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_1_ts_offset_lsb[1];
	uint32_t _rx_port_1_ts_offset_lsb;
} BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_CLR(r) (r).rx_port_1_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_1_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_GET(r) (r).rx_port_1_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_1_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_1_ts_offset_lsb[0]=(((r).rx_port_1_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_1_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_1_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr,(r._rx_port_1_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_1_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr,&(r._rx_port_1_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_1_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr
#define RX_PORT_1_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_t RX_PORT_1_TS_OFFSET_LSBr_t;
#define RX_PORT_1_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_CLR
#define RX_PORT_1_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_SET
#define RX_PORT_1_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_GET
#define RX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_1_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_1_TS_OFFSET_LSBr
#define WRITE_RX_PORT_1_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_1_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_1_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_1_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 1 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr 0x0000934e

#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_1_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_1_ts_offset_msb[1];
	uint32_t _rx_port_1_ts_offset_msb;
} BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_CLR(r) (r).rx_port_1_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_1_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_GET(r) (r).rx_port_1_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_1_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_1_ts_offset_msb[0]=(((r).rx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_1_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_1_ts_offset_msb[0]=(((r).rx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_1_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_1_ts_offset_msb[0]=(((r).rx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_1_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_1_ts_offset_msb[0]=(((r).rx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_1_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_1_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr,(r._rx_port_1_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_1_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr,&(r._rx_port_1_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_1_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr
#define RX_PORT_1_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_t RX_PORT_1_TS_OFFSET_MSBr_t;
#define RX_PORT_1_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_CLR
#define RX_PORT_1_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_SET
#define RX_PORT_1_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_GET
#define RX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_1_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_1_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_1_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_1_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_1_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_1_TS_OFFSET_MSBr
#define WRITE_RX_PORT_1_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_1_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_1_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_2_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 2 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr 0x00009330

#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_2_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_2_link_delay_lsb[1];
	uint32_t _rx_port_2_link_delay_lsb;
} BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_CLR(r) (r).rx_port_2_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_2_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_GET(r) (r).rx_port_2_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_2_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_2_link_delay_lsb[0]=(((r).rx_port_2_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_2_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_2_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr,(r._rx_port_2_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_2_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr,&(r._rx_port_2_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_2_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr
#define RX_PORT_2_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_t RX_PORT_2_LINK_DELAY_LSBr_t;
#define RX_PORT_2_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_CLR
#define RX_PORT_2_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_SET
#define RX_PORT_2_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_GET
#define RX_PORT_2_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_2_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_2_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_2_LINK_DELAY_LSBr
#define WRITE_RX_PORT_2_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_2_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_2_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_2_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 2 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr 0x00009332

#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_2_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_2_link_delay_msb[1];
	uint32_t _rx_port_2_link_delay_msb;
} BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_CLR(r) (r).rx_port_2_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_2_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_GET(r) (r).rx_port_2_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_2_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_2_link_delay_msb[0]=(((r).rx_port_2_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_2_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_2_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr,(r._rx_port_2_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_2_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr,&(r._rx_port_2_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_2_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr
#define RX_PORT_2_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_t RX_PORT_2_LINK_DELAY_MSBr_t;
#define RX_PORT_2_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_CLR
#define RX_PORT_2_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_SET
#define RX_PORT_2_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_GET
#define RX_PORT_2_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_2_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_2_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_2_LINK_DELAY_MSBr
#define WRITE_RX_PORT_2_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_2_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_2_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_2_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 2 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr 0x00009350

#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_2_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_2_ts_offset_lsb[1];
	uint32_t _rx_port_2_ts_offset_lsb;
} BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_CLR(r) (r).rx_port_2_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_2_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_GET(r) (r).rx_port_2_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_2_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_2_ts_offset_lsb[0]=(((r).rx_port_2_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_2_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_2_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr,(r._rx_port_2_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_2_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr,&(r._rx_port_2_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_2_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr
#define RX_PORT_2_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_t RX_PORT_2_TS_OFFSET_LSBr_t;
#define RX_PORT_2_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_CLR
#define RX_PORT_2_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_SET
#define RX_PORT_2_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_GET
#define RX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_2_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_2_TS_OFFSET_LSBr
#define WRITE_RX_PORT_2_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_2_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_2_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_2_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 2 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr 0x00009352

#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_2_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_2_ts_offset_msb[1];
	uint32_t _rx_port_2_ts_offset_msb;
} BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_CLR(r) (r).rx_port_2_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_2_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_GET(r) (r).rx_port_2_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_2_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_2_ts_offset_msb[0]=(((r).rx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_2_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_2_ts_offset_msb[0]=(((r).rx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_2_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_2_ts_offset_msb[0]=(((r).rx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_2_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_2_ts_offset_msb[0]=(((r).rx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_2_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_2_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr,(r._rx_port_2_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_2_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr,&(r._rx_port_2_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_2_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr
#define RX_PORT_2_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_t RX_PORT_2_TS_OFFSET_MSBr_t;
#define RX_PORT_2_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_CLR
#define RX_PORT_2_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_SET
#define RX_PORT_2_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_GET
#define RX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_2_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_2_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_2_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_2_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_2_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_2_TS_OFFSET_MSBr
#define WRITE_RX_PORT_2_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_2_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_2_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_3_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 3 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr 0x00009334

#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_3_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_3_link_delay_lsb[1];
	uint32_t _rx_port_3_link_delay_lsb;
} BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_CLR(r) (r).rx_port_3_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_3_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_GET(r) (r).rx_port_3_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_3_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_3_link_delay_lsb[0]=(((r).rx_port_3_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_3_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_3_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr,(r._rx_port_3_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_3_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr,&(r._rx_port_3_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_3_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr
#define RX_PORT_3_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_t RX_PORT_3_LINK_DELAY_LSBr_t;
#define RX_PORT_3_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_CLR
#define RX_PORT_3_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_SET
#define RX_PORT_3_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_GET
#define RX_PORT_3_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_3_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_3_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_3_LINK_DELAY_LSBr
#define WRITE_RX_PORT_3_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_3_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_3_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_3_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 3 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr 0x00009336

#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_3_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_3_link_delay_msb[1];
	uint32_t _rx_port_3_link_delay_msb;
} BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_CLR(r) (r).rx_port_3_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_3_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_GET(r) (r).rx_port_3_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_3_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_3_link_delay_msb[0]=(((r).rx_port_3_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_3_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_3_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr,(r._rx_port_3_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_3_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr,&(r._rx_port_3_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_3_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr
#define RX_PORT_3_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_t RX_PORT_3_LINK_DELAY_MSBr_t;
#define RX_PORT_3_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_CLR
#define RX_PORT_3_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_SET
#define RX_PORT_3_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_GET
#define RX_PORT_3_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_3_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_3_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_3_LINK_DELAY_MSBr
#define WRITE_RX_PORT_3_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_3_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_3_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_3_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 3 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr 0x00009354

#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_3_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_3_ts_offset_lsb[1];
	uint32_t _rx_port_3_ts_offset_lsb;
} BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_CLR(r) (r).rx_port_3_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_3_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_GET(r) (r).rx_port_3_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_3_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_3_ts_offset_lsb[0]=(((r).rx_port_3_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_3_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_3_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr,(r._rx_port_3_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_3_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr,&(r._rx_port_3_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_3_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr
#define RX_PORT_3_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_t RX_PORT_3_TS_OFFSET_LSBr_t;
#define RX_PORT_3_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_CLR
#define RX_PORT_3_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_SET
#define RX_PORT_3_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_GET
#define RX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_3_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_3_TS_OFFSET_LSBr
#define WRITE_RX_PORT_3_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_3_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_3_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_3_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 3 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr 0x00009356

#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_3_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_3_ts_offset_msb[1];
	uint32_t _rx_port_3_ts_offset_msb;
} BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_CLR(r) (r).rx_port_3_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_3_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_GET(r) (r).rx_port_3_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_3_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_3_ts_offset_msb[0]=(((r).rx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_3_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_3_ts_offset_msb[0]=(((r).rx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_3_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_3_ts_offset_msb[0]=(((r).rx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_3_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_3_ts_offset_msb[0]=(((r).rx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_3_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_3_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr,(r._rx_port_3_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_3_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr,&(r._rx_port_3_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_3_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr
#define RX_PORT_3_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_t RX_PORT_3_TS_OFFSET_MSBr_t;
#define RX_PORT_3_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_CLR
#define RX_PORT_3_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_SET
#define RX_PORT_3_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_GET
#define RX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_3_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_3_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_3_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_3_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_3_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_3_TS_OFFSET_MSBr
#define WRITE_RX_PORT_3_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_3_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_3_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_4_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 4 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr 0x00009338

#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_4_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_4_link_delay_lsb[1];
	uint32_t _rx_port_4_link_delay_lsb;
} BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_CLR(r) (r).rx_port_4_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_4_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_GET(r) (r).rx_port_4_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_4_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_4_link_delay_lsb[0]=(((r).rx_port_4_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_4_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_4_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr,(r._rx_port_4_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_4_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr,&(r._rx_port_4_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_4_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr
#define RX_PORT_4_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_t RX_PORT_4_LINK_DELAY_LSBr_t;
#define RX_PORT_4_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_CLR
#define RX_PORT_4_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_SET
#define RX_PORT_4_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_GET
#define RX_PORT_4_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_4_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_4_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_4_LINK_DELAY_LSBr
#define WRITE_RX_PORT_4_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_4_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_4_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_4_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 4 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr 0x0000933a

#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_4_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_4_link_delay_msb[1];
	uint32_t _rx_port_4_link_delay_msb;
} BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_CLR(r) (r).rx_port_4_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_4_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_GET(r) (r).rx_port_4_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_4_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_4_link_delay_msb[0]=(((r).rx_port_4_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_4_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_4_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr,(r._rx_port_4_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_4_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr,&(r._rx_port_4_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_4_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr
#define RX_PORT_4_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_t RX_PORT_4_LINK_DELAY_MSBr_t;
#define RX_PORT_4_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_CLR
#define RX_PORT_4_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_SET
#define RX_PORT_4_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_GET
#define RX_PORT_4_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_4_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_4_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_4_LINK_DELAY_MSBr
#define WRITE_RX_PORT_4_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_4_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_4_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_4_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 4 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr 0x00009358

#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_4_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_4_ts_offset_lsb[1];
	uint32_t _rx_port_4_ts_offset_lsb;
} BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_CLR(r) (r).rx_port_4_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_4_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_GET(r) (r).rx_port_4_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_4_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_4_ts_offset_lsb[0]=(((r).rx_port_4_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_4_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_4_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr,(r._rx_port_4_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_4_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr,&(r._rx_port_4_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_4_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr
#define RX_PORT_4_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_t RX_PORT_4_TS_OFFSET_LSBr_t;
#define RX_PORT_4_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_CLR
#define RX_PORT_4_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_SET
#define RX_PORT_4_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_GET
#define RX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_4_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_4_TS_OFFSET_LSBr
#define WRITE_RX_PORT_4_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_4_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_4_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_4_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 4 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr 0x0000935a

#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_4_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_4_ts_offset_msb[1];
	uint32_t _rx_port_4_ts_offset_msb;
} BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_CLR(r) (r).rx_port_4_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_4_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_GET(r) (r).rx_port_4_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_4_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_4_ts_offset_msb[0]=(((r).rx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_4_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_4_ts_offset_msb[0]=(((r).rx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_4_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_4_ts_offset_msb[0]=(((r).rx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_4_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_4_ts_offset_msb[0]=(((r).rx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_4_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_4_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr,(r._rx_port_4_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_4_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr,&(r._rx_port_4_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_4_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr
#define RX_PORT_4_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_t RX_PORT_4_TS_OFFSET_MSBr_t;
#define RX_PORT_4_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_CLR
#define RX_PORT_4_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_SET
#define RX_PORT_4_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_GET
#define RX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_4_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_4_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_4_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_4_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_4_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_4_TS_OFFSET_MSBr
#define WRITE_RX_PORT_4_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_4_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_4_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_5_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 5 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr 0x0000933c

#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_5_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_5_link_delay_lsb[1];
	uint32_t _rx_port_5_link_delay_lsb;
} BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_CLR(r) (r).rx_port_5_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_5_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_GET(r) (r).rx_port_5_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_5_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_5_link_delay_lsb[0]=(((r).rx_port_5_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_5_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_5_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr,(r._rx_port_5_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_5_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr,&(r._rx_port_5_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_5_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr
#define RX_PORT_5_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_t RX_PORT_5_LINK_DELAY_LSBr_t;
#define RX_PORT_5_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_CLR
#define RX_PORT_5_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_SET
#define RX_PORT_5_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_GET
#define RX_PORT_5_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_5_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_5_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_5_LINK_DELAY_LSBr
#define WRITE_RX_PORT_5_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_5_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_5_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_5_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 5 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr 0x0000933e

#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_5_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_5_link_delay_msb[1];
	uint32_t _rx_port_5_link_delay_msb;
} BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_CLR(r) (r).rx_port_5_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_5_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_GET(r) (r).rx_port_5_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_5_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_5_link_delay_msb[0]=(((r).rx_port_5_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_5_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_5_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr,(r._rx_port_5_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_5_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr,&(r._rx_port_5_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_5_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr
#define RX_PORT_5_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_t RX_PORT_5_LINK_DELAY_MSBr_t;
#define RX_PORT_5_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_CLR
#define RX_PORT_5_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_SET
#define RX_PORT_5_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_GET
#define RX_PORT_5_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_5_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_5_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_5_LINK_DELAY_MSBr
#define WRITE_RX_PORT_5_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_5_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_5_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_5_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 5 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr 0x0000935c

#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_5_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_5_ts_offset_lsb[1];
	uint32_t _rx_port_5_ts_offset_lsb;
} BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_CLR(r) (r).rx_port_5_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_5_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_GET(r) (r).rx_port_5_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_5_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_5_ts_offset_lsb[0]=(((r).rx_port_5_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_5_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_5_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr,(r._rx_port_5_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_5_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr,&(r._rx_port_5_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_5_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr
#define RX_PORT_5_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_t RX_PORT_5_TS_OFFSET_LSBr_t;
#define RX_PORT_5_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_CLR
#define RX_PORT_5_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_SET
#define RX_PORT_5_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_GET
#define RX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_5_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_5_TS_OFFSET_LSBr
#define WRITE_RX_PORT_5_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_5_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_5_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_5_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 5 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr 0x0000935e

#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_5_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_5_ts_offset_msb[1];
	uint32_t _rx_port_5_ts_offset_msb;
} BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_CLR(r) (r).rx_port_5_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_5_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_GET(r) (r).rx_port_5_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_5_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_5_ts_offset_msb[0]=(((r).rx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_5_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_5_ts_offset_msb[0]=(((r).rx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_5_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_5_ts_offset_msb[0]=(((r).rx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_5_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_5_ts_offset_msb[0]=(((r).rx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_5_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_5_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr,(r._rx_port_5_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_5_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr,&(r._rx_port_5_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_5_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr
#define RX_PORT_5_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_t RX_PORT_5_TS_OFFSET_MSBr_t;
#define RX_PORT_5_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_CLR
#define RX_PORT_5_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_SET
#define RX_PORT_5_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_GET
#define RX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_5_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_5_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_5_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_5_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_5_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_5_TS_OFFSET_MSBr
#define WRITE_RX_PORT_5_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_5_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_5_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_7_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 7 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr 0x00009340

#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_7_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_7_link_delay_lsb[1];
	uint32_t _rx_port_7_link_delay_lsb;
} BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_CLR(r) (r).rx_port_7_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_7_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_GET(r) (r).rx_port_7_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_7_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_7_link_delay_lsb[0]=(((r).rx_port_7_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_7_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_7_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr,(r._rx_port_7_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_7_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr,&(r._rx_port_7_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_7_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr
#define RX_PORT_7_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_t RX_PORT_7_LINK_DELAY_LSBr_t;
#define RX_PORT_7_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_CLR
#define RX_PORT_7_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_SET
#define RX_PORT_7_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_GET
#define RX_PORT_7_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_7_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_7_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_7_LINK_DELAY_LSBr
#define WRITE_RX_PORT_7_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_7_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_7_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_7_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 7 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr 0x00009342

#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_7_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_7_link_delay_msb[1];
	uint32_t _rx_port_7_link_delay_msb;
} BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_CLR(r) (r).rx_port_7_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_7_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_GET(r) (r).rx_port_7_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_7_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_7_link_delay_msb[0]=(((r).rx_port_7_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_7_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_7_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr,(r._rx_port_7_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_7_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr,&(r._rx_port_7_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_7_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr
#define RX_PORT_7_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_t RX_PORT_7_LINK_DELAY_MSBr_t;
#define RX_PORT_7_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_CLR
#define RX_PORT_7_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_SET
#define RX_PORT_7_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_GET
#define RX_PORT_7_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_7_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_7_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_7_LINK_DELAY_MSBr
#define WRITE_RX_PORT_7_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_7_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_7_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_7_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 7 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr 0x00009360

#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_7_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_7_ts_offset_lsb[1];
	uint32_t _rx_port_7_ts_offset_lsb;
} BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_CLR(r) (r).rx_port_7_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_7_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_GET(r) (r).rx_port_7_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_7_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_7_ts_offset_lsb[0]=(((r).rx_port_7_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_7_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_7_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr,(r._rx_port_7_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_7_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr,&(r._rx_port_7_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_7_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr
#define RX_PORT_7_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_t RX_PORT_7_TS_OFFSET_LSBr_t;
#define RX_PORT_7_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_CLR
#define RX_PORT_7_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_SET
#define RX_PORT_7_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_GET
#define RX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_7_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_7_TS_OFFSET_LSBr
#define WRITE_RX_PORT_7_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_7_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_7_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_7_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 7 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr 0x00009362

#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_7_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_7_ts_offset_msb[1];
	uint32_t _rx_port_7_ts_offset_msb;
} BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_CLR(r) (r).rx_port_7_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_7_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_GET(r) (r).rx_port_7_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_7_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_7_ts_offset_msb[0]=(((r).rx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_7_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_7_ts_offset_msb[0]=(((r).rx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_7_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_7_ts_offset_msb[0]=(((r).rx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_7_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_7_ts_offset_msb[0]=(((r).rx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_7_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_7_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr,(r._rx_port_7_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_7_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr,&(r._rx_port_7_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_7_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr
#define RX_PORT_7_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_t RX_PORT_7_TS_OFFSET_MSBr_t;
#define RX_PORT_7_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_CLR
#define RX_PORT_7_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_SET
#define RX_PORT_7_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_GET
#define RX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_7_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_7_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_7_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_7_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_7_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_7_TS_OFFSET_MSBr
#define WRITE_RX_PORT_7_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_7_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_7_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_8_LINK_DELAY_LSB
 * BLOCKS:   SYS
 * DESC:     Port 8 RX PORT Link delay LSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_LSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr 0x00009344

#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_8_LINK_DELAY_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_8_link_delay_lsb[1];
	uint32_t _rx_port_8_link_delay_lsb;
} BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_t;

#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_CLR(r) (r).rx_port_8_link_delay_lsb[0] = 0
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_SET(r,d) (r).rx_port_8_link_delay_lsb[0] = d
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_GET(r) (r).rx_port_8_link_delay_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET(r) (((r).rx_port_8_link_delay_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET(r,f) (r).rx_port_8_link_delay_lsb[0]=(((r).rx_port_8_link_delay_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_8_LINK_DELAY_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_8_LINK_DELAY_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr,(r._rx_port_8_link_delay_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_8_LINK_DELAY_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr,&(r._rx_port_8_link_delay_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_8_LINK_DELAY_LSBr BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr
#define RX_PORT_8_LINK_DELAY_LSBr_SIZE BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_t RX_PORT_8_LINK_DELAY_LSBr_t;
#define RX_PORT_8_LINK_DELAY_LSBr_CLR BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_CLR
#define RX_PORT_8_LINK_DELAY_LSBr_SET BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_SET
#define RX_PORT_8_LINK_DELAY_LSBr_GET BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_GET
#define RX_PORT_8_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_GET
#define RX_PORT_8_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr_RX_LINK_DELAY_LSBf_SET
#define READ_RX_PORT_8_LINK_DELAY_LSBr BCM89500_A0_READ_RX_PORT_8_LINK_DELAY_LSBr
#define WRITE_RX_PORT_8_LINK_DELAY_LSBr BCM89500_A0_WRITE_RX_PORT_8_LINK_DELAY_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_8_LINK_DELAY_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_8_LINK_DELAY_MSB
 * BLOCKS:   SYS
 * DESC:     Port 8 RX PORT Link delay MSB Registers
 * SIZE:     16
 * FIELDS:
 *     RX_LINK_DELAY_MSB Port RX link delay register, the unit is signed ns.The final port RX link delay ={RX0_LINK_DELAY_MSB,RX0_LINK_DELAY_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr 0x00009346

#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_8_LINK_DELAY_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_8_link_delay_msb[1];
	uint32_t _rx_port_8_link_delay_msb;
} BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_t;

#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_CLR(r) (r).rx_port_8_link_delay_msb[0] = 0
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_SET(r,d) (r).rx_port_8_link_delay_msb[0] = d
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_GET(r) (r).rx_port_8_link_delay_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET(r) (((r).rx_port_8_link_delay_msb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET(r,f) (r).rx_port_8_link_delay_msb[0]=(((r).rx_port_8_link_delay_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_8_LINK_DELAY_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_8_LINK_DELAY_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr,(r._rx_port_8_link_delay_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_8_LINK_DELAY_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr,&(r._rx_port_8_link_delay_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_8_LINK_DELAY_MSBr BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr
#define RX_PORT_8_LINK_DELAY_MSBr_SIZE BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_t RX_PORT_8_LINK_DELAY_MSBr_t;
#define RX_PORT_8_LINK_DELAY_MSBr_CLR BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_CLR
#define RX_PORT_8_LINK_DELAY_MSBr_SET BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_SET
#define RX_PORT_8_LINK_DELAY_MSBr_GET BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_GET
#define RX_PORT_8_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_GET
#define RX_PORT_8_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr_RX_LINK_DELAY_MSBf_SET
#define READ_RX_PORT_8_LINK_DELAY_MSBr BCM89500_A0_READ_RX_PORT_8_LINK_DELAY_MSBr
#define WRITE_RX_PORT_8_LINK_DELAY_MSBr BCM89500_A0_WRITE_RX_PORT_8_LINK_DELAY_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_8_LINK_DELAY_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_8_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 8 RX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_LSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr 0x00009364

#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_8_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t rx_port_8_ts_offset_lsb[1];
	uint32_t _rx_port_8_ts_offset_lsb;
} BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_t;

#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_CLR(r) (r).rx_port_8_ts_offset_lsb[0] = 0
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_SET(r,d) (r).rx_port_8_ts_offset_lsb[0] = d
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_GET(r) (r).rx_port_8_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET(r) (((r).rx_port_8_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET(r,f) (r).rx_port_8_ts_offset_lsb[0]=(((r).rx_port_8_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_PORT_8_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_8_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr,(r._rx_port_8_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_RX_PORT_8_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr,&(r._rx_port_8_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_8_TS_OFFSET_LSBr BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr
#define RX_PORT_8_TS_OFFSET_LSBr_SIZE BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_t RX_PORT_8_TS_OFFSET_LSBr_t;
#define RX_PORT_8_TS_OFFSET_LSBr_CLR BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_CLR
#define RX_PORT_8_TS_OFFSET_LSBr_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_SET
#define RX_PORT_8_TS_OFFSET_LSBr_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_GET
#define RX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_GET
#define RX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_RX_LSBf_SET
#define READ_RX_PORT_8_TS_OFFSET_LSBr BCM89500_A0_READ_RX_PORT_8_TS_OFFSET_LSBr
#define WRITE_RX_PORT_8_TS_OFFSET_LSBr BCM89500_A0_WRITE_RX_PORT_8_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_8_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_PORT_8_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 8 RX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_RX_MSB Port RX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port RX timestamp =NCO timestamp + {TS_OFFSET_RX_MSB, TS_OFFSET_RX_LSB}
 *     RESERVED_0       Reserved
 *     TS_CAP           TS_CAP Port TX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr 0x00009366

#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program RX_PORT_8_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t rx_port_8_ts_offset_msb[1];
	uint32_t _rx_port_8_ts_offset_msb;
} BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_t;

#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_CLR(r) (r).rx_port_8_ts_offset_msb[0] = 0
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_SET(r,d) (r).rx_port_8_ts_offset_msb[0] = d
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_GET(r) (r).rx_port_8_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET(r) (((r).rx_port_8_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET(r,f) (r).rx_port_8_ts_offset_msb[0]=(((r).rx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_0f_GET(r) ((((r).rx_port_8_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_0f_SET(r,f) (r).rx_port_8_ts_offset_msb[0]=(((r).rx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).rx_port_8_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).rx_port_8_ts_offset_msb[0]=(((r).rx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_1f_GET(r) ((((r).rx_port_8_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_1f_SET(r,f) (r).rx_port_8_ts_offset_msb[0]=(((r).rx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RX_PORT_8_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_RX_PORT_8_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr,(r._rx_port_8_ts_offset_msb),2)
#define BCM89500_A0_WRITE_RX_PORT_8_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr,&(r._rx_port_8_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PORT_8_TS_OFFSET_MSBr BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr
#define RX_PORT_8_TS_OFFSET_MSBr_SIZE BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_t RX_PORT_8_TS_OFFSET_MSBr_t;
#define RX_PORT_8_TS_OFFSET_MSBr_CLR BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_CLR
#define RX_PORT_8_TS_OFFSET_MSBr_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_SET
#define RX_PORT_8_TS_OFFSET_MSBr_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_GET
#define RX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_GET
#define RX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_RX_MSBf_SET
#define RX_PORT_8_TS_OFFSET_MSBr_RESERVED_0f_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_0f_GET
#define RX_PORT_8_TS_OFFSET_MSBr_RESERVED_0f_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_0f_SET
#define RX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_GET
#define RX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_SET
#define RX_PORT_8_TS_OFFSET_MSBr_RESERVED_1f_GET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_1f_GET
#define RX_PORT_8_TS_OFFSET_MSBr_RESERVED_1f_SET BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr_RESERVED_1f_SET
#define READ_RX_PORT_8_TS_OFFSET_MSBr BCM89500_A0_READ_RX_PORT_8_TS_OFFSET_MSBr
#define WRITE_RX_PORT_8_TS_OFFSET_MSBr BCM89500_A0_WRITE_RX_PORT_8_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_PORT_8_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_TS_CAP
 * BLOCKS:   SYS
 * DESC:     RX SOP Timestamp Capture Enable Registers
 * SIZE:     16
 * FIELDS:
 *     RX_TS_CAP        Individual bits enable the timestamp capture of the appopriate RX portbit 7 -- enable RX port 8bit 6 -- enable RX port 7bit 5 -- enable RX port 5bit 4 -- enable RX port 4bit 3 -- enable RX port 3bit 2 -- enable RX port 2bit 1 -- enable RX port 1bit 0 -- enable RX port 0
 *     RX_CS_DIS        Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_TS_CAPr 0x00009324

#define BCM89500_A0_RX_TS_CAPr_SIZE 2

/*
 * This structure should be used to declare and program RX_TS_CAP.
 *
 */
typedef union BCM89500_A0_RX_TS_CAPr_s {
	uint32_t v[1];
	uint32_t rx_ts_cap[1];
	uint32_t _rx_ts_cap;
} BCM89500_A0_RX_TS_CAPr_t;

#define BCM89500_A0_RX_TS_CAPr_CLR(r) (r).rx_ts_cap[0] = 0
#define BCM89500_A0_RX_TS_CAPr_SET(r,d) (r).rx_ts_cap[0] = d
#define BCM89500_A0_RX_TS_CAPr_GET(r) (r).rx_ts_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_TS_CAPr_RX_TS_CAPf_GET(r) (((r).rx_ts_cap[0]) & 0xff)
#define BCM89500_A0_RX_TS_CAPr_RX_TS_CAPf_SET(r,f) (r).rx_ts_cap[0]=(((r).rx_ts_cap[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_RX_TS_CAPr_RX_CS_DISf_GET(r) ((((r).rx_ts_cap[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_TS_CAPr_RX_CS_DISf_SET(r,f) (r).rx_ts_cap[0]=(((r).rx_ts_cap[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_TS_CAP.
 *
 */
#define BCM89500_A0_READ_RX_TS_CAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_TS_CAPr,(r._rx_ts_cap),2)
#define BCM89500_A0_WRITE_RX_TS_CAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_TS_CAPr,&(r._rx_ts_cap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_TS_CAPr BCM89500_A0_RX_TS_CAPr
#define RX_TS_CAPr_SIZE BCM89500_A0_RX_TS_CAPr_SIZE
typedef BCM89500_A0_RX_TS_CAPr_t RX_TS_CAPr_t;
#define RX_TS_CAPr_CLR BCM89500_A0_RX_TS_CAPr_CLR
#define RX_TS_CAPr_SET BCM89500_A0_RX_TS_CAPr_SET
#define RX_TS_CAPr_GET BCM89500_A0_RX_TS_CAPr_GET
#define RX_TS_CAPr_RX_TS_CAPf_GET BCM89500_A0_RX_TS_CAPr_RX_TS_CAPf_GET
#define RX_TS_CAPr_RX_TS_CAPf_SET BCM89500_A0_RX_TS_CAPr_RX_TS_CAPf_SET
#define RX_TS_CAPr_RX_CS_DISf_GET BCM89500_A0_RX_TS_CAPr_RX_CS_DISf_GET
#define RX_TS_CAPr_RX_CS_DISf_SET BCM89500_A0_RX_TS_CAPr_RX_CS_DISf_SET
#define READ_RX_TS_CAPr BCM89500_A0_READ_RX_TS_CAPr
#define WRITE_RX_TS_CAPr BCM89500_A0_WRITE_RX_TS_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_TS_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_TX_1588_COUNTER
 * BLOCKS:   SYS
 * DESC:     RX TX 1588 Counter Register
 * SIZE:     16
 * FIELDS:
 *     TX_1588_COUNTER  The number of 1588 packets into TX side.
 *     RX_1588_COUNTER  The number of 1588 packets into RX side.
 *
 ******************************************************************************/
#define BCM89500_A0_RX_TX_1588_COUNTERr 0x000093e8

#define BCM89500_A0_RX_TX_1588_COUNTERr_SIZE 2

/*
 * This structure should be used to declare and program RX_TX_1588_COUNTER.
 *
 */
typedef union BCM89500_A0_RX_TX_1588_COUNTERr_s {
	uint32_t v[1];
	uint32_t rx_tx_1588_counter[1];
	uint32_t _rx_tx_1588_counter;
} BCM89500_A0_RX_TX_1588_COUNTERr_t;

#define BCM89500_A0_RX_TX_1588_COUNTERr_CLR(r) (r).rx_tx_1588_counter[0] = 0
#define BCM89500_A0_RX_TX_1588_COUNTERr_SET(r,d) (r).rx_tx_1588_counter[0] = d
#define BCM89500_A0_RX_TX_1588_COUNTERr_GET(r) (r).rx_tx_1588_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_TX_1588_COUNTERr_TX_1588_COUNTERf_GET(r) (((r).rx_tx_1588_counter[0]) & 0xff)
#define BCM89500_A0_RX_TX_1588_COUNTERr_TX_1588_COUNTERf_SET(r,f) (r).rx_tx_1588_counter[0]=(((r).rx_tx_1588_counter[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_RX_TX_1588_COUNTERr_RX_1588_COUNTERf_GET(r) ((((r).rx_tx_1588_counter[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_TX_1588_COUNTERr_RX_1588_COUNTERf_SET(r,f) (r).rx_tx_1588_counter[0]=(((r).rx_tx_1588_counter[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_TX_1588_COUNTER.
 *
 */
#define BCM89500_A0_READ_RX_TX_1588_COUNTERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_TX_1588_COUNTERr,(r._rx_tx_1588_counter),2)
#define BCM89500_A0_WRITE_RX_TX_1588_COUNTERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_TX_1588_COUNTERr,&(r._rx_tx_1588_counter),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_TX_1588_COUNTERr BCM89500_A0_RX_TX_1588_COUNTERr
#define RX_TX_1588_COUNTERr_SIZE BCM89500_A0_RX_TX_1588_COUNTERr_SIZE
typedef BCM89500_A0_RX_TX_1588_COUNTERr_t RX_TX_1588_COUNTERr_t;
#define RX_TX_1588_COUNTERr_CLR BCM89500_A0_RX_TX_1588_COUNTERr_CLR
#define RX_TX_1588_COUNTERr_SET BCM89500_A0_RX_TX_1588_COUNTERr_SET
#define RX_TX_1588_COUNTERr_GET BCM89500_A0_RX_TX_1588_COUNTERr_GET
#define RX_TX_1588_COUNTERr_TX_1588_COUNTERf_GET BCM89500_A0_RX_TX_1588_COUNTERr_TX_1588_COUNTERf_GET
#define RX_TX_1588_COUNTERr_TX_1588_COUNTERf_SET BCM89500_A0_RX_TX_1588_COUNTERr_TX_1588_COUNTERf_SET
#define RX_TX_1588_COUNTERr_RX_1588_COUNTERf_GET BCM89500_A0_RX_TX_1588_COUNTERr_RX_1588_COUNTERf_GET
#define RX_TX_1588_COUNTERr_RX_1588_COUNTERf_SET BCM89500_A0_RX_TX_1588_COUNTERr_RX_1588_COUNTERf_SET
#define READ_RX_TX_1588_COUNTERr BCM89500_A0_READ_RX_TX_1588_COUNTERr
#define WRITE_RX_TX_1588_COUNTERr BCM89500_A0_WRITE_RX_TX_1588_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_TX_1588_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_TX_CTL
 * BLOCKS:   SYS
 * DESC:     Receive and Transmit Control Registers
 * SIZE:     16
 * FIELDS:
 *     RX_L4_IP_ADDRESS_SEL (Not2Release)Selects the Layer4 IP address check when 1588 detection in receiving side.010 - 32'224.0.1.129001 - reserved000 - 32'224.0.0.107
 *     RX_CRC_EN        Enable the CRC check in PTP detection receiving side.1 - 1588 detection need to check original CRC0 - ignore the original CRC check
 *     TX_L4_IP_ADDRESS_SEL Selects the Layer4 IP address check when 1588 detection in transmission side.010 - 32'224.0.1.129001 - reserved000 - 32'224.0.0.107
 *     TX_CRC_EN        Enable the CRC check in PTP detection transmission side.1 - 1588 detection need to check original CRC0 - ignore the original CRC check
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_TX_CTLr 0x000093a4

#define BCM89500_A0_RX_TX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program RX_TX_CTL.
 *
 */
typedef union BCM89500_A0_RX_TX_CTLr_s {
	uint32_t v[1];
	uint32_t rx_tx_ctl[1];
	uint32_t _rx_tx_ctl;
} BCM89500_A0_RX_TX_CTLr_t;

#define BCM89500_A0_RX_TX_CTLr_CLR(r) (r).rx_tx_ctl[0] = 0
#define BCM89500_A0_RX_TX_CTLr_SET(r,d) (r).rx_tx_ctl[0] = d
#define BCM89500_A0_RX_TX_CTLr_GET(r) (r).rx_tx_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_TX_CTLr_RX_L4_IP_ADDRESS_SELf_GET(r) (((r).rx_tx_ctl[0]) & 0x7)
#define BCM89500_A0_RX_TX_CTLr_RX_L4_IP_ADDRESS_SELf_SET(r,f) (r).rx_tx_ctl[0]=(((r).rx_tx_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_RX_TX_CTLr_RX_CRC_ENf_GET(r) ((((r).rx_tx_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_RX_TX_CTLr_RX_CRC_ENf_SET(r,f) (r).rx_tx_ctl[0]=(((r).rx_tx_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_RX_TX_CTLr_TX_L4_IP_ADDRESS_SELf_GET(r) ((((r).rx_tx_ctl[0]) >> 4) & 0x7)
#define BCM89500_A0_RX_TX_CTLr_TX_L4_IP_ADDRESS_SELf_SET(r,f) (r).rx_tx_ctl[0]=(((r).rx_tx_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM89500_A0_RX_TX_CTLr_TX_CRC_ENf_GET(r) ((((r).rx_tx_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_RX_TX_CTLr_TX_CRC_ENf_SET(r,f) (r).rx_tx_ctl[0]=(((r).rx_tx_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_RX_TX_CTLr_RESERVEDf_GET(r) ((((r).rx_tx_ctl[0]) >> 8) & 0xff)
#define BCM89500_A0_RX_TX_CTLr_RESERVEDf_SET(r,f) (r).rx_tx_ctl[0]=(((r).rx_tx_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_TX_CTL.
 *
 */
#define BCM89500_A0_READ_RX_TX_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_TX_CTLr,(r._rx_tx_ctl),2)
#define BCM89500_A0_WRITE_RX_TX_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_TX_CTLr,&(r._rx_tx_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_TX_CTLr BCM89500_A0_RX_TX_CTLr
#define RX_TX_CTLr_SIZE BCM89500_A0_RX_TX_CTLr_SIZE
typedef BCM89500_A0_RX_TX_CTLr_t RX_TX_CTLr_t;
#define RX_TX_CTLr_CLR BCM89500_A0_RX_TX_CTLr_CLR
#define RX_TX_CTLr_SET BCM89500_A0_RX_TX_CTLr_SET
#define RX_TX_CTLr_GET BCM89500_A0_RX_TX_CTLr_GET
#define RX_TX_CTLr_RX_L4_IP_ADDRESS_SELf_GET BCM89500_A0_RX_TX_CTLr_RX_L4_IP_ADDRESS_SELf_GET
#define RX_TX_CTLr_RX_L4_IP_ADDRESS_SELf_SET BCM89500_A0_RX_TX_CTLr_RX_L4_IP_ADDRESS_SELf_SET
#define RX_TX_CTLr_RX_CRC_ENf_GET BCM89500_A0_RX_TX_CTLr_RX_CRC_ENf_GET
#define RX_TX_CTLr_RX_CRC_ENf_SET BCM89500_A0_RX_TX_CTLr_RX_CRC_ENf_SET
#define RX_TX_CTLr_TX_L4_IP_ADDRESS_SELf_GET BCM89500_A0_RX_TX_CTLr_TX_L4_IP_ADDRESS_SELf_GET
#define RX_TX_CTLr_TX_L4_IP_ADDRESS_SELf_SET BCM89500_A0_RX_TX_CTLr_TX_L4_IP_ADDRESS_SELf_SET
#define RX_TX_CTLr_TX_CRC_ENf_GET BCM89500_A0_RX_TX_CTLr_TX_CRC_ENf_GET
#define RX_TX_CTLr_TX_CRC_ENf_SET BCM89500_A0_RX_TX_CTLr_TX_CRC_ENf_SET
#define RX_TX_CTLr_RESERVEDf_GET BCM89500_A0_RX_TX_CTLr_RESERVEDf_GET
#define RX_TX_CTLr_RESERVEDf_SET BCM89500_A0_RX_TX_CTLr_RESERVEDf_SET
#define READ_RX_TX_CTLr BCM89500_A0_READ_RX_TX_CTLr
#define WRITE_RX_TX_CTLr BCM89500_A0_WRITE_RX_TX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_TX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RX_TX_OPTION
 * BLOCKS:   SYS
 * DESC:     RX and TX Option Registers (Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TX_CRC_KEEP      1 - Keep original TX CRC0 - Update TX CRCReset value is 0.
 *     TX_TIMECODE_ADD_IN Reserved
 *     TX_PTP_VER_DIS   Disable the TX PTP version 2 check1 - disable0 - enable
 *     SPARE_REG0       Reserved
 *     RX_CRC_KEEP      1 - Keep original RX CRC0 - Update RX CRC
 *     RX_TIMECODE_ADD_IN 1 - When RX_MODE1_x is set, "time stamp-previous framsync time stamp" would be inserted into packet.0 - When RX_MODE1_x is set, insert internal IEEE time code[63:0] into packet
 *     RX_PTP_VER_DIS   Disable the RX PTP version 2 check1 - disable0 - enable
 *     SPARE_REG1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_RX_TX_OPTIONr 0x00009326

#define BCM89500_A0_RX_TX_OPTIONr_SIZE 2

/*
 * This structure should be used to declare and program RX_TX_OPTION.
 *
 */
typedef union BCM89500_A0_RX_TX_OPTIONr_s {
	uint32_t v[1];
	uint32_t rx_tx_option[1];
	uint32_t _rx_tx_option;
} BCM89500_A0_RX_TX_OPTIONr_t;

#define BCM89500_A0_RX_TX_OPTIONr_CLR(r) (r).rx_tx_option[0] = 0
#define BCM89500_A0_RX_TX_OPTIONr_SET(r,d) (r).rx_tx_option[0] = d
#define BCM89500_A0_RX_TX_OPTIONr_GET(r) (r).rx_tx_option[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_RX_TX_OPTIONr_TX_CRC_KEEPf_GET(r) (((r).rx_tx_option[0]) & 0x1)
#define BCM89500_A0_RX_TX_OPTIONr_TX_CRC_KEEPf_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_RX_TX_OPTIONr_TX_TIMECODE_ADD_INf_GET(r) ((((r).rx_tx_option[0]) >> 1) & 0x1)
#define BCM89500_A0_RX_TX_OPTIONr_TX_TIMECODE_ADD_INf_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_RX_TX_OPTIONr_TX_PTP_VER_DISf_GET(r) ((((r).rx_tx_option[0]) >> 2) & 0x1)
#define BCM89500_A0_RX_TX_OPTIONr_TX_PTP_VER_DISf_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_RX_TX_OPTIONr_SPARE_REG0f_GET(r) ((((r).rx_tx_option[0]) >> 3) & 0x1f)
#define BCM89500_A0_RX_TX_OPTIONr_SPARE_REG0f_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM89500_A0_RX_TX_OPTIONr_RX_CRC_KEEPf_GET(r) ((((r).rx_tx_option[0]) >> 8) & 0x1)
#define BCM89500_A0_RX_TX_OPTIONr_RX_CRC_KEEPf_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_RX_TX_OPTIONr_RX_TIMECODE_ADD_INf_GET(r) ((((r).rx_tx_option[0]) >> 9) & 0x1)
#define BCM89500_A0_RX_TX_OPTIONr_RX_TIMECODE_ADD_INf_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_RX_TX_OPTIONr_RX_PTP_VER_DISf_GET(r) ((((r).rx_tx_option[0]) >> 10) & 0x1)
#define BCM89500_A0_RX_TX_OPTIONr_RX_PTP_VER_DISf_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_RX_TX_OPTIONr_SPARE_REG1f_GET(r) ((((r).rx_tx_option[0]) >> 11) & 0x1f)
#define BCM89500_A0_RX_TX_OPTIONr_SPARE_REG1f_SET(r,f) (r).rx_tx_option[0]=(((r).rx_tx_option[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access RX_TX_OPTION.
 *
 */
#define BCM89500_A0_READ_RX_TX_OPTIONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RX_TX_OPTIONr,(r._rx_tx_option),2)
#define BCM89500_A0_WRITE_RX_TX_OPTIONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RX_TX_OPTIONr,&(r._rx_tx_option),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_TX_OPTIONr BCM89500_A0_RX_TX_OPTIONr
#define RX_TX_OPTIONr_SIZE BCM89500_A0_RX_TX_OPTIONr_SIZE
typedef BCM89500_A0_RX_TX_OPTIONr_t RX_TX_OPTIONr_t;
#define RX_TX_OPTIONr_CLR BCM89500_A0_RX_TX_OPTIONr_CLR
#define RX_TX_OPTIONr_SET BCM89500_A0_RX_TX_OPTIONr_SET
#define RX_TX_OPTIONr_GET BCM89500_A0_RX_TX_OPTIONr_GET
#define RX_TX_OPTIONr_TX_CRC_KEEPf_GET BCM89500_A0_RX_TX_OPTIONr_TX_CRC_KEEPf_GET
#define RX_TX_OPTIONr_TX_CRC_KEEPf_SET BCM89500_A0_RX_TX_OPTIONr_TX_CRC_KEEPf_SET
#define RX_TX_OPTIONr_TX_TIMECODE_ADD_INf_GET BCM89500_A0_RX_TX_OPTIONr_TX_TIMECODE_ADD_INf_GET
#define RX_TX_OPTIONr_TX_TIMECODE_ADD_INf_SET BCM89500_A0_RX_TX_OPTIONr_TX_TIMECODE_ADD_INf_SET
#define RX_TX_OPTIONr_TX_PTP_VER_DISf_GET BCM89500_A0_RX_TX_OPTIONr_TX_PTP_VER_DISf_GET
#define RX_TX_OPTIONr_TX_PTP_VER_DISf_SET BCM89500_A0_RX_TX_OPTIONr_TX_PTP_VER_DISf_SET
#define RX_TX_OPTIONr_SPARE_REG0f_GET BCM89500_A0_RX_TX_OPTIONr_SPARE_REG0f_GET
#define RX_TX_OPTIONr_SPARE_REG0f_SET BCM89500_A0_RX_TX_OPTIONr_SPARE_REG0f_SET
#define RX_TX_OPTIONr_RX_CRC_KEEPf_GET BCM89500_A0_RX_TX_OPTIONr_RX_CRC_KEEPf_GET
#define RX_TX_OPTIONr_RX_CRC_KEEPf_SET BCM89500_A0_RX_TX_OPTIONr_RX_CRC_KEEPf_SET
#define RX_TX_OPTIONr_RX_TIMECODE_ADD_INf_GET BCM89500_A0_RX_TX_OPTIONr_RX_TIMECODE_ADD_INf_GET
#define RX_TX_OPTIONr_RX_TIMECODE_ADD_INf_SET BCM89500_A0_RX_TX_OPTIONr_RX_TIMECODE_ADD_INf_SET
#define RX_TX_OPTIONr_RX_PTP_VER_DISf_GET BCM89500_A0_RX_TX_OPTIONr_RX_PTP_VER_DISf_GET
#define RX_TX_OPTIONr_RX_PTP_VER_DISf_SET BCM89500_A0_RX_TX_OPTIONr_RX_PTP_VER_DISf_SET
#define RX_TX_OPTIONr_SPARE_REG1f_GET BCM89500_A0_RX_TX_OPTIONr_SPARE_REG1f_GET
#define RX_TX_OPTIONr_SPARE_REG1f_SET BCM89500_A0_RX_TX_OPTIONr_SPARE_REG1f_SET
#define READ_RX_TX_OPTIONr BCM89500_A0_READ_RX_TX_OPTIONr
#define WRITE_RX_TX_OPTIONr BCM89500_A0_WRITE_RX_TX_OPTIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RX_TX_OPTIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXALIGNMENTERRORSr 0x00002080

#define BCM89500_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 *
 */
typedef union BCM89500_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM89500_A0_RXALIGNMENTERRORSr_t;

#define BCM89500_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM89500_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM89500_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 *
 */
#define BCM89500_A0_READ_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM89500_A0_WRITE_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM89500_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM89500_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM89500_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM89500_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM89500_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM89500_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM89500_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM89500_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxAlignmentErrors_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXALIGNMENTERRORS_IMPr 0x00002880

#define BCM89500_A0_RXALIGNMENTERRORS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors_IMP.
 *
 */
typedef union BCM89500_A0_RXALIGNMENTERRORS_IMPr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors_imp[1];
	uint32_t _rxalignmenterrors_imp;
} BCM89500_A0_RXALIGNMENTERRORS_IMPr_t;

#define BCM89500_A0_RXALIGNMENTERRORS_IMPr_CLR(r) (r).rxalignmenterrors_imp[0] = 0
#define BCM89500_A0_RXALIGNMENTERRORS_IMPr_SET(r,d) (r).rxalignmenterrors_imp[0] = d
#define BCM89500_A0_RXALIGNMENTERRORS_IMPr_GET(r) (r).rxalignmenterrors_imp[0]


/*
 * These macros can be used to access RxAlignmentErrors_IMP.
 *
 */
#define BCM89500_A0_READ_RXALIGNMENTERRORS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXALIGNMENTERRORS_IMPr,(r._rxalignmenterrors_imp),4)
#define BCM89500_A0_WRITE_RXALIGNMENTERRORS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXALIGNMENTERRORS_IMPr,&(r._rxalignmenterrors_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORS_IMPr BCM89500_A0_RXALIGNMENTERRORS_IMPr
#define RXALIGNMENTERRORS_IMPr_SIZE BCM89500_A0_RXALIGNMENTERRORS_IMPr_SIZE
typedef BCM89500_A0_RXALIGNMENTERRORS_IMPr_t RXALIGNMENTERRORS_IMPr_t;
#define RXALIGNMENTERRORS_IMPr_CLR BCM89500_A0_RXALIGNMENTERRORS_IMPr_CLR
#define RXALIGNMENTERRORS_IMPr_SET BCM89500_A0_RXALIGNMENTERRORS_IMPr_SET
#define RXALIGNMENTERRORS_IMPr_GET BCM89500_A0_RXALIGNMENTERRORS_IMPr_GET
#define READ_RXALIGNMENTERRORS_IMPr BCM89500_A0_READ_RXALIGNMENTERRORS_IMPr
#define WRITE_RXALIGNMENTERRORS_IMPr BCM89500_A0_WRITE_RXALIGNMENTERRORS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXALIGNMENTERRORS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxAlignmentErrors_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXALIGNMENTERRORS_P7r 0x00002780

#define BCM89500_A0_RXALIGNMENTERRORS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors_P7.
 *
 */
typedef union BCM89500_A0_RXALIGNMENTERRORS_P7r_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors_p7[1];
	uint32_t _rxalignmenterrors_p7;
} BCM89500_A0_RXALIGNMENTERRORS_P7r_t;

#define BCM89500_A0_RXALIGNMENTERRORS_P7r_CLR(r) (r).rxalignmenterrors_p7[0] = 0
#define BCM89500_A0_RXALIGNMENTERRORS_P7r_SET(r,d) (r).rxalignmenterrors_p7[0] = d
#define BCM89500_A0_RXALIGNMENTERRORS_P7r_GET(r) (r).rxalignmenterrors_p7[0]


/*
 * These macros can be used to access RxAlignmentErrors_P7.
 *
 */
#define BCM89500_A0_READ_RXALIGNMENTERRORS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXALIGNMENTERRORS_P7r,(r._rxalignmenterrors_p7),4)
#define BCM89500_A0_WRITE_RXALIGNMENTERRORS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXALIGNMENTERRORS_P7r,&(r._rxalignmenterrors_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORS_P7r BCM89500_A0_RXALIGNMENTERRORS_P7r
#define RXALIGNMENTERRORS_P7r_SIZE BCM89500_A0_RXALIGNMENTERRORS_P7r_SIZE
typedef BCM89500_A0_RXALIGNMENTERRORS_P7r_t RXALIGNMENTERRORS_P7r_t;
#define RXALIGNMENTERRORS_P7r_CLR BCM89500_A0_RXALIGNMENTERRORS_P7r_CLR
#define RXALIGNMENTERRORS_P7r_SET BCM89500_A0_RXALIGNMENTERRORS_P7r_SET
#define RXALIGNMENTERRORS_P7r_GET BCM89500_A0_RXALIGNMENTERRORS_P7r_GET
#define READ_RXALIGNMENTERRORS_P7r BCM89500_A0_READ_RXALIGNMENTERRORS_P7r
#define WRITE_RXALIGNMENTERRORS_P7r BCM89500_A0_WRITE_RXALIGNMENTERRORS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXALIGNMENTERRORS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxBroadcastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXBROADCASTPKTSr 0x0000209c

#define BCM89500_A0_RXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkts.
 *
 */
typedef union BCM89500_A0_RXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkts[1];
	uint32_t _rxbroadcastpkts;
} BCM89500_A0_RXBROADCASTPKTSr_t;

#define BCM89500_A0_RXBROADCASTPKTSr_CLR(r) (r).rxbroadcastpkts[0] = 0
#define BCM89500_A0_RXBROADCASTPKTSr_SET(r,d) (r).rxbroadcastpkts[0] = d
#define BCM89500_A0_RXBROADCASTPKTSr_GET(r) (r).rxbroadcastpkts[0]


/*
 * These macros can be used to access RxBroadcastPkts.
 *
 */
#define BCM89500_A0_READ_RXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXBROADCASTPKTSr,(r._rxbroadcastpkts),4)
#define BCM89500_A0_WRITE_RXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXBROADCASTPKTSr,&(r._rxbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTSr BCM89500_A0_RXBROADCASTPKTSr
#define RXBROADCASTPKTSr_SIZE BCM89500_A0_RXBROADCASTPKTSr_SIZE
typedef BCM89500_A0_RXBROADCASTPKTSr_t RXBROADCASTPKTSr_t;
#define RXBROADCASTPKTSr_CLR BCM89500_A0_RXBROADCASTPKTSr_CLR
#define RXBROADCASTPKTSr_SET BCM89500_A0_RXBROADCASTPKTSr_SET
#define RXBROADCASTPKTSr_GET BCM89500_A0_RXBROADCASTPKTSr_GET
#define READ_RXBROADCASTPKTSr BCM89500_A0_READ_RXBROADCASTPKTSr
#define WRITE_RXBROADCASTPKTSr BCM89500_A0_WRITE_RXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxBroadcastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXBROADCASTPKTS_IMPr 0x0000289c

#define BCM89500_A0_RXBROADCASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkts_IMP.
 *
 */
typedef union BCM89500_A0_RXBROADCASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkts_imp[1];
	uint32_t _rxbroadcastpkts_imp;
} BCM89500_A0_RXBROADCASTPKTS_IMPr_t;

#define BCM89500_A0_RXBROADCASTPKTS_IMPr_CLR(r) (r).rxbroadcastpkts_imp[0] = 0
#define BCM89500_A0_RXBROADCASTPKTS_IMPr_SET(r,d) (r).rxbroadcastpkts_imp[0] = d
#define BCM89500_A0_RXBROADCASTPKTS_IMPr_GET(r) (r).rxbroadcastpkts_imp[0]


/*
 * These macros can be used to access RxBroadcastPkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXBROADCASTPKTS_IMPr,(r._rxbroadcastpkts_imp),4)
#define BCM89500_A0_WRITE_RXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXBROADCASTPKTS_IMPr,&(r._rxbroadcastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTS_IMPr BCM89500_A0_RXBROADCASTPKTS_IMPr
#define RXBROADCASTPKTS_IMPr_SIZE BCM89500_A0_RXBROADCASTPKTS_IMPr_SIZE
typedef BCM89500_A0_RXBROADCASTPKTS_IMPr_t RXBROADCASTPKTS_IMPr_t;
#define RXBROADCASTPKTS_IMPr_CLR BCM89500_A0_RXBROADCASTPKTS_IMPr_CLR
#define RXBROADCASTPKTS_IMPr_SET BCM89500_A0_RXBROADCASTPKTS_IMPr_SET
#define RXBROADCASTPKTS_IMPr_GET BCM89500_A0_RXBROADCASTPKTS_IMPr_GET
#define READ_RXBROADCASTPKTS_IMPr BCM89500_A0_READ_RXBROADCASTPKTS_IMPr
#define WRITE_RXBROADCASTPKTS_IMPr BCM89500_A0_WRITE_RXBROADCASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXBROADCASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxBroadcastPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXBROADCASTPKTS_P7r 0x0000279c

#define BCM89500_A0_RXBROADCASTPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkts_P7.
 *
 */
typedef union BCM89500_A0_RXBROADCASTPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkts_p7[1];
	uint32_t _rxbroadcastpkts_p7;
} BCM89500_A0_RXBROADCASTPKTS_P7r_t;

#define BCM89500_A0_RXBROADCASTPKTS_P7r_CLR(r) (r).rxbroadcastpkts_p7[0] = 0
#define BCM89500_A0_RXBROADCASTPKTS_P7r_SET(r,d) (r).rxbroadcastpkts_p7[0] = d
#define BCM89500_A0_RXBROADCASTPKTS_P7r_GET(r) (r).rxbroadcastpkts_p7[0]


/*
 * These macros can be used to access RxBroadcastPkts_P7.
 *
 */
#define BCM89500_A0_READ_RXBROADCASTPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXBROADCASTPKTS_P7r,(r._rxbroadcastpkts_p7),4)
#define BCM89500_A0_WRITE_RXBROADCASTPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXBROADCASTPKTS_P7r,&(r._rxbroadcastpkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTS_P7r BCM89500_A0_RXBROADCASTPKTS_P7r
#define RXBROADCASTPKTS_P7r_SIZE BCM89500_A0_RXBROADCASTPKTS_P7r_SIZE
typedef BCM89500_A0_RXBROADCASTPKTS_P7r_t RXBROADCASTPKTS_P7r_t;
#define RXBROADCASTPKTS_P7r_CLR BCM89500_A0_RXBROADCASTPKTS_P7r_CLR
#define RXBROADCASTPKTS_P7r_SET BCM89500_A0_RXBROADCASTPKTS_P7r_SET
#define RXBROADCASTPKTS_P7r_GET BCM89500_A0_RXBROADCASTPKTS_P7r_GET
#define READ_RXBROADCASTPKTS_P7r BCM89500_A0_READ_RXBROADCASTPKTS_P7r
#define WRITE_RXBROADCASTPKTS_P7r BCM89500_A0_WRITE_RXBROADCASTPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXBROADCASTPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXDROPPKTSr 0x00002090

#define BCM89500_A0_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts.
 *
 */
typedef union BCM89500_A0_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t rxdroppkts[1];
	uint32_t _rxdroppkts;
} BCM89500_A0_RXDROPPKTSr_t;

#define BCM89500_A0_RXDROPPKTSr_CLR(r) (r).rxdroppkts[0] = 0
#define BCM89500_A0_RXDROPPKTSr_SET(r,d) (r).rxdroppkts[0] = d
#define BCM89500_A0_RXDROPPKTSr_GET(r) (r).rxdroppkts[0]


/*
 * These macros can be used to access RxDropPkts.
 *
 */
#define BCM89500_A0_READ_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXDROPPKTSr,(r._rxdroppkts),4)
#define BCM89500_A0_WRITE_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXDROPPKTSr,&(r._rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTSr BCM89500_A0_RXDROPPKTSr
#define RXDROPPKTSr_SIZE BCM89500_A0_RXDROPPKTSr_SIZE
typedef BCM89500_A0_RXDROPPKTSr_t RXDROPPKTSr_t;
#define RXDROPPKTSr_CLR BCM89500_A0_RXDROPPKTSr_CLR
#define RXDROPPKTSr_SET BCM89500_A0_RXDROPPKTSr_SET
#define RXDROPPKTSr_GET BCM89500_A0_RXDROPPKTSr_GET
#define READ_RXDROPPKTSr BCM89500_A0_READ_RXDROPPKTSr
#define WRITE_RXDROPPKTSr BCM89500_A0_WRITE_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxDropPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXDROPPKTS_IMPr 0x00002890

#define BCM89500_A0_RXDROPPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts_IMP.
 *
 */
typedef union BCM89500_A0_RXDROPPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxdroppkts_imp[1];
	uint32_t _rxdroppkts_imp;
} BCM89500_A0_RXDROPPKTS_IMPr_t;

#define BCM89500_A0_RXDROPPKTS_IMPr_CLR(r) (r).rxdroppkts_imp[0] = 0
#define BCM89500_A0_RXDROPPKTS_IMPr_SET(r,d) (r).rxdroppkts_imp[0] = d
#define BCM89500_A0_RXDROPPKTS_IMPr_GET(r) (r).rxdroppkts_imp[0]


/*
 * These macros can be used to access RxDropPkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXDROPPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXDROPPKTS_IMPr,(r._rxdroppkts_imp),4)
#define BCM89500_A0_WRITE_RXDROPPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXDROPPKTS_IMPr,&(r._rxdroppkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTS_IMPr BCM89500_A0_RXDROPPKTS_IMPr
#define RXDROPPKTS_IMPr_SIZE BCM89500_A0_RXDROPPKTS_IMPr_SIZE
typedef BCM89500_A0_RXDROPPKTS_IMPr_t RXDROPPKTS_IMPr_t;
#define RXDROPPKTS_IMPr_CLR BCM89500_A0_RXDROPPKTS_IMPr_CLR
#define RXDROPPKTS_IMPr_SET BCM89500_A0_RXDROPPKTS_IMPr_SET
#define RXDROPPKTS_IMPr_GET BCM89500_A0_RXDROPPKTS_IMPr_GET
#define READ_RXDROPPKTS_IMPr BCM89500_A0_READ_RXDROPPKTS_IMPr
#define WRITE_RXDROPPKTS_IMPr BCM89500_A0_WRITE_RXDROPPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXDROPPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxDropPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXDROPPKTS_P7r 0x00002790

#define BCM89500_A0_RXDROPPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts_P7.
 *
 */
typedef union BCM89500_A0_RXDROPPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxdroppkts_p7[1];
	uint32_t _rxdroppkts_p7;
} BCM89500_A0_RXDROPPKTS_P7r_t;

#define BCM89500_A0_RXDROPPKTS_P7r_CLR(r) (r).rxdroppkts_p7[0] = 0
#define BCM89500_A0_RXDROPPKTS_P7r_SET(r,d) (r).rxdroppkts_p7[0] = d
#define BCM89500_A0_RXDROPPKTS_P7r_GET(r) (r).rxdroppkts_p7[0]


/*
 * These macros can be used to access RxDropPkts_P7.
 *
 */
#define BCM89500_A0_READ_RXDROPPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXDROPPKTS_P7r,(r._rxdroppkts_p7),4)
#define BCM89500_A0_WRITE_RXDROPPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXDROPPKTS_P7r,&(r._rxdroppkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTS_P7r BCM89500_A0_RXDROPPKTS_P7r
#define RXDROPPKTS_P7r_SIZE BCM89500_A0_RXDROPPKTS_P7r_SIZE
typedef BCM89500_A0_RXDROPPKTS_P7r_t RXDROPPKTS_P7r_t;
#define RXDROPPKTS_P7r_CLR BCM89500_A0_RXDROPPKTS_P7r_CLR
#define RXDROPPKTS_P7r_SET BCM89500_A0_RXDROPPKTS_P7r_SET
#define RXDROPPKTS_P7r_GET BCM89500_A0_RXDROPPKTS_P7r_GET
#define READ_RXDROPPKTS_P7r BCM89500_A0_READ_RXDROPPKTS_P7r
#define WRITE_RXDROPPKTS_P7r BCM89500_A0_WRITE_RXDROPPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXDROPPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXFCSERRORSr 0x00002084

#define BCM89500_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 *
 */
typedef union BCM89500_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM89500_A0_RXFCSERRORSr_t;

#define BCM89500_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM89500_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM89500_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 *
 */
#define BCM89500_A0_READ_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM89500_A0_WRITE_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM89500_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM89500_A0_RXFCSERRORSr_SIZE
typedef BCM89500_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM89500_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM89500_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM89500_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM89500_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM89500_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxFCSErrors_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXFCSERRORS_IMPr 0x00002884

#define BCM89500_A0_RXFCSERRORS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors_IMP.
 *
 */
typedef union BCM89500_A0_RXFCSERRORS_IMPr_s {
	uint32_t v[1];
	uint32_t rxfcserrors_imp[1];
	uint32_t _rxfcserrors_imp;
} BCM89500_A0_RXFCSERRORS_IMPr_t;

#define BCM89500_A0_RXFCSERRORS_IMPr_CLR(r) (r).rxfcserrors_imp[0] = 0
#define BCM89500_A0_RXFCSERRORS_IMPr_SET(r,d) (r).rxfcserrors_imp[0] = d
#define BCM89500_A0_RXFCSERRORS_IMPr_GET(r) (r).rxfcserrors_imp[0]


/*
 * These macros can be used to access RxFCSErrors_IMP.
 *
 */
#define BCM89500_A0_READ_RXFCSERRORS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXFCSERRORS_IMPr,(r._rxfcserrors_imp),4)
#define BCM89500_A0_WRITE_RXFCSERRORS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXFCSERRORS_IMPr,&(r._rxfcserrors_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORS_IMPr BCM89500_A0_RXFCSERRORS_IMPr
#define RXFCSERRORS_IMPr_SIZE BCM89500_A0_RXFCSERRORS_IMPr_SIZE
typedef BCM89500_A0_RXFCSERRORS_IMPr_t RXFCSERRORS_IMPr_t;
#define RXFCSERRORS_IMPr_CLR BCM89500_A0_RXFCSERRORS_IMPr_CLR
#define RXFCSERRORS_IMPr_SET BCM89500_A0_RXFCSERRORS_IMPr_SET
#define RXFCSERRORS_IMPr_GET BCM89500_A0_RXFCSERRORS_IMPr_GET
#define READ_RXFCSERRORS_IMPr BCM89500_A0_READ_RXFCSERRORS_IMPr
#define WRITE_RXFCSERRORS_IMPr BCM89500_A0_WRITE_RXFCSERRORS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXFCSERRORS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxFCSErrors_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXFCSERRORS_P7r 0x00002784

#define BCM89500_A0_RXFCSERRORS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors_P7.
 *
 */
typedef union BCM89500_A0_RXFCSERRORS_P7r_s {
	uint32_t v[1];
	uint32_t rxfcserrors_p7[1];
	uint32_t _rxfcserrors_p7;
} BCM89500_A0_RXFCSERRORS_P7r_t;

#define BCM89500_A0_RXFCSERRORS_P7r_CLR(r) (r).rxfcserrors_p7[0] = 0
#define BCM89500_A0_RXFCSERRORS_P7r_SET(r,d) (r).rxfcserrors_p7[0] = d
#define BCM89500_A0_RXFCSERRORS_P7r_GET(r) (r).rxfcserrors_p7[0]


/*
 * These macros can be used to access RxFCSErrors_P7.
 *
 */
#define BCM89500_A0_READ_RXFCSERRORS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXFCSERRORS_P7r,(r._rxfcserrors_p7),4)
#define BCM89500_A0_WRITE_RXFCSERRORS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXFCSERRORS_P7r,&(r._rxfcserrors_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORS_P7r BCM89500_A0_RXFCSERRORS_P7r
#define RXFCSERRORS_P7r_SIZE BCM89500_A0_RXFCSERRORS_P7r_SIZE
typedef BCM89500_A0_RXFCSERRORS_P7r_t RXFCSERRORS_P7r_t;
#define RXFCSERRORS_P7r_CLR BCM89500_A0_RXFCSERRORS_P7r_CLR
#define RXFCSERRORS_P7r_SET BCM89500_A0_RXFCSERRORS_P7r_SET
#define RXFCSERRORS_P7r_GET BCM89500_A0_RXFCSERRORS_P7r_GET
#define READ_RXFCSERRORS_P7r BCM89500_A0_READ_RXFCSERRORS_P7r
#define WRITE_RXFCSERRORS_P7r BCM89500_A0_WRITE_RXFCSERRORS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXFCSERRORS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxFragments
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXFRAGMENTSr 0x000020a4

#define BCM89500_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 *
 */
typedef union BCM89500_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM89500_A0_RXFRAGMENTSr_t;

#define BCM89500_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM89500_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM89500_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 *
 */
#define BCM89500_A0_READ_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM89500_A0_WRITE_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM89500_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM89500_A0_RXFRAGMENTSr_SIZE
typedef BCM89500_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM89500_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM89500_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM89500_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM89500_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM89500_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxFragments_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXFRAGMENTS_IMPr 0x000028a4

#define BCM89500_A0_RXFRAGMENTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments_IMP.
 *
 */
typedef union BCM89500_A0_RXFRAGMENTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxfragments_imp[1];
	uint32_t _rxfragments_imp;
} BCM89500_A0_RXFRAGMENTS_IMPr_t;

#define BCM89500_A0_RXFRAGMENTS_IMPr_CLR(r) (r).rxfragments_imp[0] = 0
#define BCM89500_A0_RXFRAGMENTS_IMPr_SET(r,d) (r).rxfragments_imp[0] = d
#define BCM89500_A0_RXFRAGMENTS_IMPr_GET(r) (r).rxfragments_imp[0]


/*
 * These macros can be used to access RxFragments_IMP.
 *
 */
#define BCM89500_A0_READ_RXFRAGMENTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXFRAGMENTS_IMPr,(r._rxfragments_imp),4)
#define BCM89500_A0_WRITE_RXFRAGMENTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXFRAGMENTS_IMPr,&(r._rxfragments_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTS_IMPr BCM89500_A0_RXFRAGMENTS_IMPr
#define RXFRAGMENTS_IMPr_SIZE BCM89500_A0_RXFRAGMENTS_IMPr_SIZE
typedef BCM89500_A0_RXFRAGMENTS_IMPr_t RXFRAGMENTS_IMPr_t;
#define RXFRAGMENTS_IMPr_CLR BCM89500_A0_RXFRAGMENTS_IMPr_CLR
#define RXFRAGMENTS_IMPr_SET BCM89500_A0_RXFRAGMENTS_IMPr_SET
#define RXFRAGMENTS_IMPr_GET BCM89500_A0_RXFRAGMENTS_IMPr_GET
#define READ_RXFRAGMENTS_IMPr BCM89500_A0_READ_RXFRAGMENTS_IMPr
#define WRITE_RXFRAGMENTS_IMPr BCM89500_A0_WRITE_RXFRAGMENTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXFRAGMENTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxFragments_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXFRAGMENTS_P7r 0x000027a4

#define BCM89500_A0_RXFRAGMENTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxFragments_P7.
 *
 */
typedef union BCM89500_A0_RXFRAGMENTS_P7r_s {
	uint32_t v[1];
	uint32_t rxfragments_p7[1];
	uint32_t _rxfragments_p7;
} BCM89500_A0_RXFRAGMENTS_P7r_t;

#define BCM89500_A0_RXFRAGMENTS_P7r_CLR(r) (r).rxfragments_p7[0] = 0
#define BCM89500_A0_RXFRAGMENTS_P7r_SET(r,d) (r).rxfragments_p7[0] = d
#define BCM89500_A0_RXFRAGMENTS_P7r_GET(r) (r).rxfragments_p7[0]


/*
 * These macros can be used to access RxFragments_P7.
 *
 */
#define BCM89500_A0_READ_RXFRAGMENTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXFRAGMENTS_P7r,(r._rxfragments_p7),4)
#define BCM89500_A0_WRITE_RXFRAGMENTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXFRAGMENTS_P7r,&(r._rxfragments_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTS_P7r BCM89500_A0_RXFRAGMENTS_P7r
#define RXFRAGMENTS_P7r_SIZE BCM89500_A0_RXFRAGMENTS_P7r_SIZE
typedef BCM89500_A0_RXFRAGMENTS_P7r_t RXFRAGMENTS_P7r_t;
#define RXFRAGMENTS_P7r_CLR BCM89500_A0_RXFRAGMENTS_P7r_CLR
#define RXFRAGMENTS_P7r_SET BCM89500_A0_RXFRAGMENTS_P7r_SET
#define RXFRAGMENTS_P7r_GET BCM89500_A0_RXFRAGMENTS_P7r_GET
#define READ_RXFRAGMENTS_P7r BCM89500_A0_READ_RXFRAGMENTS_P7r
#define WRITE_RXFRAGMENTS_P7r BCM89500_A0_WRITE_RXFRAGMENTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXFRAGMENTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_RXGOODOCTETSr 0x00002088

#define BCM89500_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 *
 */
typedef union BCM89500_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM89500_A0_RXGOODOCTETSr_t;

#define BCM89500_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM89500_A0_RXGOODOCTETSr_t))
#define BCM89500_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM89500_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 *
 */
#define BCM89500_A0_READ_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM89500_A0_WRITE_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM89500_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM89500_A0_RXGOODOCTETSr_SIZE
typedef BCM89500_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM89500_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM89500_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM89500_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM89500_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM89500_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxGoodOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_RXGOODOCTETS_IMPr 0x00002888

#define BCM89500_A0_RXGOODOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets_IMP.
 *
 */
typedef union BCM89500_A0_RXGOODOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets_imp[2];
	uint32_t _rxgoodoctets_imp;
} BCM89500_A0_RXGOODOCTETS_IMPr_t;

#define BCM89500_A0_RXGOODOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets_imp), 0, sizeof(BCM89500_A0_RXGOODOCTETS_IMPr_t))
#define BCM89500_A0_RXGOODOCTETS_IMPr_SET(r,i,d) (r).rxgoodoctets_imp[i] = d
#define BCM89500_A0_RXGOODOCTETS_IMPr_GET(r,i) (r).rxgoodoctets_imp[i]


/*
 * These macros can be used to access RxGoodOctets_IMP.
 *
 */
#define BCM89500_A0_READ_RXGOODOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXGOODOCTETS_IMPr,(r._rxgoodoctets_imp),8)
#define BCM89500_A0_WRITE_RXGOODOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXGOODOCTETS_IMPr,&(r._rxgoodoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETS_IMPr BCM89500_A0_RXGOODOCTETS_IMPr
#define RXGOODOCTETS_IMPr_SIZE BCM89500_A0_RXGOODOCTETS_IMPr_SIZE
typedef BCM89500_A0_RXGOODOCTETS_IMPr_t RXGOODOCTETS_IMPr_t;
#define RXGOODOCTETS_IMPr_CLR BCM89500_A0_RXGOODOCTETS_IMPr_CLR
#define RXGOODOCTETS_IMPr_SET BCM89500_A0_RXGOODOCTETS_IMPr_SET
#define RXGOODOCTETS_IMPr_GET BCM89500_A0_RXGOODOCTETS_IMPr_GET
#define READ_RXGOODOCTETS_IMPr BCM89500_A0_READ_RXGOODOCTETS_IMPr
#define WRITE_RXGOODOCTETS_IMPr BCM89500_A0_WRITE_RXGOODOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXGOODOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxGoodOctets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_RXGOODOCTETS_P7r 0x00002788

#define BCM89500_A0_RXGOODOCTETS_P7r_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets_P7.
 *
 */
typedef union BCM89500_A0_RXGOODOCTETS_P7r_s {
	uint32_t v[2];
	uint32_t rxgoodoctets_p7[2];
	uint32_t _rxgoodoctets_p7;
} BCM89500_A0_RXGOODOCTETS_P7r_t;

#define BCM89500_A0_RXGOODOCTETS_P7r_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets_p7), 0, sizeof(BCM89500_A0_RXGOODOCTETS_P7r_t))
#define BCM89500_A0_RXGOODOCTETS_P7r_SET(r,i,d) (r).rxgoodoctets_p7[i] = d
#define BCM89500_A0_RXGOODOCTETS_P7r_GET(r,i) (r).rxgoodoctets_p7[i]


/*
 * These macros can be used to access RxGoodOctets_P7.
 *
 */
#define BCM89500_A0_READ_RXGOODOCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXGOODOCTETS_P7r,(r._rxgoodoctets_p7),8)
#define BCM89500_A0_WRITE_RXGOODOCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXGOODOCTETS_P7r,&(r._rxgoodoctets_p7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETS_P7r BCM89500_A0_RXGOODOCTETS_P7r
#define RXGOODOCTETS_P7r_SIZE BCM89500_A0_RXGOODOCTETS_P7r_SIZE
typedef BCM89500_A0_RXGOODOCTETS_P7r_t RXGOODOCTETS_P7r_t;
#define RXGOODOCTETS_P7r_CLR BCM89500_A0_RXGOODOCTETS_P7r_CLR
#define RXGOODOCTETS_P7r_SET BCM89500_A0_RXGOODOCTETS_P7r_SET
#define RXGOODOCTETS_P7r_GET BCM89500_A0_RXGOODOCTETS_P7r_GET
#define READ_RXGOODOCTETS_P7r BCM89500_A0_READ_RXGOODOCTETS_P7r
#define WRITE_RXGOODOCTETS_P7r BCM89500_A0_WRITE_RXGOODOCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXGOODOCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxJabbers
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXJABBERSr 0x0000207c

#define BCM89500_A0_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers.
 *
 */
typedef union BCM89500_A0_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t rxjabbers[1];
	uint32_t _rxjabbers;
} BCM89500_A0_RXJABBERSr_t;

#define BCM89500_A0_RXJABBERSr_CLR(r) (r).rxjabbers[0] = 0
#define BCM89500_A0_RXJABBERSr_SET(r,d) (r).rxjabbers[0] = d
#define BCM89500_A0_RXJABBERSr_GET(r) (r).rxjabbers[0]


/*
 * These macros can be used to access RxJabbers.
 *
 */
#define BCM89500_A0_READ_RXJABBERSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXJABBERSr,(r._rxjabbers),4)
#define BCM89500_A0_WRITE_RXJABBERSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXJABBERSr,&(r._rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERSr BCM89500_A0_RXJABBERSr
#define RXJABBERSr_SIZE BCM89500_A0_RXJABBERSr_SIZE
typedef BCM89500_A0_RXJABBERSr_t RXJABBERSr_t;
#define RXJABBERSr_CLR BCM89500_A0_RXJABBERSr_CLR
#define RXJABBERSr_SET BCM89500_A0_RXJABBERSr_SET
#define RXJABBERSr_GET BCM89500_A0_RXJABBERSr_GET
#define READ_RXJABBERSr BCM89500_A0_READ_RXJABBERSr
#define WRITE_RXJABBERSr BCM89500_A0_WRITE_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxJabbers_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXJABBERS_IMPr 0x0000287c

#define BCM89500_A0_RXJABBERS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers_IMP.
 *
 */
typedef union BCM89500_A0_RXJABBERS_IMPr_s {
	uint32_t v[1];
	uint32_t rxjabbers_imp[1];
	uint32_t _rxjabbers_imp;
} BCM89500_A0_RXJABBERS_IMPr_t;

#define BCM89500_A0_RXJABBERS_IMPr_CLR(r) (r).rxjabbers_imp[0] = 0
#define BCM89500_A0_RXJABBERS_IMPr_SET(r,d) (r).rxjabbers_imp[0] = d
#define BCM89500_A0_RXJABBERS_IMPr_GET(r) (r).rxjabbers_imp[0]


/*
 * These macros can be used to access RxJabbers_IMP.
 *
 */
#define BCM89500_A0_READ_RXJABBERS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXJABBERS_IMPr,(r._rxjabbers_imp),4)
#define BCM89500_A0_WRITE_RXJABBERS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXJABBERS_IMPr,&(r._rxjabbers_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERS_IMPr BCM89500_A0_RXJABBERS_IMPr
#define RXJABBERS_IMPr_SIZE BCM89500_A0_RXJABBERS_IMPr_SIZE
typedef BCM89500_A0_RXJABBERS_IMPr_t RXJABBERS_IMPr_t;
#define RXJABBERS_IMPr_CLR BCM89500_A0_RXJABBERS_IMPr_CLR
#define RXJABBERS_IMPr_SET BCM89500_A0_RXJABBERS_IMPr_SET
#define RXJABBERS_IMPr_GET BCM89500_A0_RXJABBERS_IMPr_GET
#define READ_RXJABBERS_IMPr BCM89500_A0_READ_RXJABBERS_IMPr
#define WRITE_RXJABBERS_IMPr BCM89500_A0_WRITE_RXJABBERS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXJABBERS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxJabbers_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXJABBERS_P7r 0x0000277c

#define BCM89500_A0_RXJABBERS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers_P7.
 *
 */
typedef union BCM89500_A0_RXJABBERS_P7r_s {
	uint32_t v[1];
	uint32_t rxjabbers_p7[1];
	uint32_t _rxjabbers_p7;
} BCM89500_A0_RXJABBERS_P7r_t;

#define BCM89500_A0_RXJABBERS_P7r_CLR(r) (r).rxjabbers_p7[0] = 0
#define BCM89500_A0_RXJABBERS_P7r_SET(r,d) (r).rxjabbers_p7[0] = d
#define BCM89500_A0_RXJABBERS_P7r_GET(r) (r).rxjabbers_p7[0]


/*
 * These macros can be used to access RxJabbers_P7.
 *
 */
#define BCM89500_A0_READ_RXJABBERS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXJABBERS_P7r,(r._rxjabbers_p7),4)
#define BCM89500_A0_WRITE_RXJABBERS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXJABBERS_P7r,&(r._rxjabbers_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERS_P7r BCM89500_A0_RXJABBERS_P7r
#define RXJABBERS_P7r_SIZE BCM89500_A0_RXJABBERS_P7r_SIZE
typedef BCM89500_A0_RXJABBERS_P7r_t RXJABBERS_P7r_t;
#define RXJABBERS_P7r_CLR BCM89500_A0_RXJABBERS_P7r_CLR
#define RXJABBERS_P7r_SET BCM89500_A0_RXJABBERS_P7r_SET
#define RXJABBERS_P7r_GET BCM89500_A0_RXJABBERS_P7r_GET
#define READ_RXJABBERS_P7r BCM89500_A0_READ_RXJABBERS_P7r
#define WRITE_RXJABBERS_P7r BCM89500_A0_WRITE_RXJABBERS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXJABBERS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXMULTICASTPKTSr 0x00002098

#define BCM89500_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 *
 */
typedef union BCM89500_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM89500_A0_RXMULTICASTPKTSr_t;

#define BCM89500_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM89500_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM89500_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 *
 */
#define BCM89500_A0_READ_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM89500_A0_WRITE_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM89500_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM89500_A0_RXMULTICASTPKTSr_SIZE
typedef BCM89500_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM89500_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM89500_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM89500_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM89500_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM89500_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxMulticastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXMULTICASTPKTS_IMPr 0x00002898

#define BCM89500_A0_RXMULTICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts_IMP.
 *
 */
typedef union BCM89500_A0_RXMULTICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts_imp[1];
	uint32_t _rxmulticastpkts_imp;
} BCM89500_A0_RXMULTICASTPKTS_IMPr_t;

#define BCM89500_A0_RXMULTICASTPKTS_IMPr_CLR(r) (r).rxmulticastpkts_imp[0] = 0
#define BCM89500_A0_RXMULTICASTPKTS_IMPr_SET(r,d) (r).rxmulticastpkts_imp[0] = d
#define BCM89500_A0_RXMULTICASTPKTS_IMPr_GET(r) (r).rxmulticastpkts_imp[0]


/*
 * These macros can be used to access RxMulticastPkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXMULTICASTPKTS_IMPr,(r._rxmulticastpkts_imp),4)
#define BCM89500_A0_WRITE_RXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXMULTICASTPKTS_IMPr,&(r._rxmulticastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTS_IMPr BCM89500_A0_RXMULTICASTPKTS_IMPr
#define RXMULTICASTPKTS_IMPr_SIZE BCM89500_A0_RXMULTICASTPKTS_IMPr_SIZE
typedef BCM89500_A0_RXMULTICASTPKTS_IMPr_t RXMULTICASTPKTS_IMPr_t;
#define RXMULTICASTPKTS_IMPr_CLR BCM89500_A0_RXMULTICASTPKTS_IMPr_CLR
#define RXMULTICASTPKTS_IMPr_SET BCM89500_A0_RXMULTICASTPKTS_IMPr_SET
#define RXMULTICASTPKTS_IMPr_GET BCM89500_A0_RXMULTICASTPKTS_IMPr_GET
#define READ_RXMULTICASTPKTS_IMPr BCM89500_A0_READ_RXMULTICASTPKTS_IMPr
#define WRITE_RXMULTICASTPKTS_IMPr BCM89500_A0_WRITE_RXMULTICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXMULTICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxMulticastPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXMULTICASTPKTS_P7r 0x00002798

#define BCM89500_A0_RXMULTICASTPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts_P7.
 *
 */
typedef union BCM89500_A0_RXMULTICASTPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts_p7[1];
	uint32_t _rxmulticastpkts_p7;
} BCM89500_A0_RXMULTICASTPKTS_P7r_t;

#define BCM89500_A0_RXMULTICASTPKTS_P7r_CLR(r) (r).rxmulticastpkts_p7[0] = 0
#define BCM89500_A0_RXMULTICASTPKTS_P7r_SET(r,d) (r).rxmulticastpkts_p7[0] = d
#define BCM89500_A0_RXMULTICASTPKTS_P7r_GET(r) (r).rxmulticastpkts_p7[0]


/*
 * These macros can be used to access RxMulticastPkts_P7.
 *
 */
#define BCM89500_A0_READ_RXMULTICASTPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXMULTICASTPKTS_P7r,(r._rxmulticastpkts_p7),4)
#define BCM89500_A0_WRITE_RXMULTICASTPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXMULTICASTPKTS_P7r,&(r._rxmulticastpkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTS_P7r BCM89500_A0_RXMULTICASTPKTS_P7r
#define RXMULTICASTPKTS_P7r_SIZE BCM89500_A0_RXMULTICASTPKTS_P7r_SIZE
typedef BCM89500_A0_RXMULTICASTPKTS_P7r_t RXMULTICASTPKTS_P7r_t;
#define RXMULTICASTPKTS_P7r_CLR BCM89500_A0_RXMULTICASTPKTS_P7r_CLR
#define RXMULTICASTPKTS_P7r_SET BCM89500_A0_RXMULTICASTPKTS_P7r_SET
#define RXMULTICASTPKTS_P7r_GET BCM89500_A0_RXMULTICASTPKTS_P7r_GET
#define READ_RXMULTICASTPKTS_P7r BCM89500_A0_READ_RXMULTICASTPKTS_P7r
#define WRITE_RXMULTICASTPKTS_P7r BCM89500_A0_WRITE_RXMULTICASTPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXMULTICASTPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_RXOCTETSr 0x00002050

#define BCM89500_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 *
 */
typedef union BCM89500_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM89500_A0_RXOCTETSr_t;

#define BCM89500_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM89500_A0_RXOCTETSr_t))
#define BCM89500_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM89500_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 *
 */
#define BCM89500_A0_READ_RXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM89500_A0_WRITE_RXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM89500_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM89500_A0_RXOCTETSr_SIZE
typedef BCM89500_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM89500_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM89500_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM89500_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM89500_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM89500_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_RXOCTETS_IMPr 0x00002850

#define BCM89500_A0_RXOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets_IMP.
 *
 */
typedef union BCM89500_A0_RXOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t rxoctets_imp[2];
	uint32_t _rxoctets_imp;
} BCM89500_A0_RXOCTETS_IMPr_t;

#define BCM89500_A0_RXOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._rxoctets_imp), 0, sizeof(BCM89500_A0_RXOCTETS_IMPr_t))
#define BCM89500_A0_RXOCTETS_IMPr_SET(r,i,d) (r).rxoctets_imp[i] = d
#define BCM89500_A0_RXOCTETS_IMPr_GET(r,i) (r).rxoctets_imp[i]


/*
 * These macros can be used to access RxOctets_IMP.
 *
 */
#define BCM89500_A0_READ_RXOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXOCTETS_IMPr,(r._rxoctets_imp),8)
#define BCM89500_A0_WRITE_RXOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXOCTETS_IMPr,&(r._rxoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETS_IMPr BCM89500_A0_RXOCTETS_IMPr
#define RXOCTETS_IMPr_SIZE BCM89500_A0_RXOCTETS_IMPr_SIZE
typedef BCM89500_A0_RXOCTETS_IMPr_t RXOCTETS_IMPr_t;
#define RXOCTETS_IMPr_CLR BCM89500_A0_RXOCTETS_IMPr_CLR
#define RXOCTETS_IMPr_SET BCM89500_A0_RXOCTETS_IMPr_SET
#define RXOCTETS_IMPr_GET BCM89500_A0_RXOCTETS_IMPr_GET
#define READ_RXOCTETS_IMPr BCM89500_A0_READ_RXOCTETS_IMPr
#define WRITE_RXOCTETS_IMPr BCM89500_A0_WRITE_RXOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxOctets_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_RXOCTETS_P7r 0x00002750

#define BCM89500_A0_RXOCTETS_P7r_SIZE 8

/*
 * This structure should be used to declare and program RxOctets_P7.
 *
 */
typedef union BCM89500_A0_RXOCTETS_P7r_s {
	uint32_t v[2];
	uint32_t rxoctets_p7[2];
	uint32_t _rxoctets_p7;
} BCM89500_A0_RXOCTETS_P7r_t;

#define BCM89500_A0_RXOCTETS_P7r_CLR(r) CDK_MEMSET(&((r)._rxoctets_p7), 0, sizeof(BCM89500_A0_RXOCTETS_P7r_t))
#define BCM89500_A0_RXOCTETS_P7r_SET(r,i,d) (r).rxoctets_p7[i] = d
#define BCM89500_A0_RXOCTETS_P7r_GET(r,i) (r).rxoctets_p7[i]


/*
 * These macros can be used to access RxOctets_P7.
 *
 */
#define BCM89500_A0_READ_RXOCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXOCTETS_P7r,(r._rxoctets_p7),8)
#define BCM89500_A0_WRITE_RXOCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXOCTETS_P7r,&(r._rxoctets_p7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETS_P7r BCM89500_A0_RXOCTETS_P7r
#define RXOCTETS_P7r_SIZE BCM89500_A0_RXOCTETS_P7r_SIZE
typedef BCM89500_A0_RXOCTETS_P7r_t RXOCTETS_P7r_t;
#define RXOCTETS_P7r_CLR BCM89500_A0_RXOCTETS_P7r_CLR
#define RXOCTETS_P7r_SET BCM89500_A0_RXOCTETS_P7r_SET
#define RXOCTETS_P7r_GET BCM89500_A0_RXOCTETS_P7r_GET
#define READ_RXOCTETS_P7r BCM89500_A0_READ_RXOCTETS_P7r
#define WRITE_RXOCTETS_P7r BCM89500_A0_WRITE_RXOCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXOCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXOVERSIZEPKTSr 0x00002078

#define BCM89500_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 *
 */
typedef union BCM89500_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM89500_A0_RXOVERSIZEPKTSr_t;

#define BCM89500_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM89500_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM89500_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 *
 */
#define BCM89500_A0_READ_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM89500_A0_WRITE_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM89500_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM89500_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM89500_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM89500_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM89500_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM89500_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM89500_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM89500_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxOversizePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXOVERSIZEPKTS_IMPr 0x00002878

#define BCM89500_A0_RXOVERSIZEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts_IMP.
 *
 */
typedef union BCM89500_A0_RXOVERSIZEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts_imp[1];
	uint32_t _rxoversizepkts_imp;
} BCM89500_A0_RXOVERSIZEPKTS_IMPr_t;

#define BCM89500_A0_RXOVERSIZEPKTS_IMPr_CLR(r) (r).rxoversizepkts_imp[0] = 0
#define BCM89500_A0_RXOVERSIZEPKTS_IMPr_SET(r,d) (r).rxoversizepkts_imp[0] = d
#define BCM89500_A0_RXOVERSIZEPKTS_IMPr_GET(r) (r).rxoversizepkts_imp[0]


/*
 * These macros can be used to access RxOversizePkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXOVERSIZEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXOVERSIZEPKTS_IMPr,(r._rxoversizepkts_imp),4)
#define BCM89500_A0_WRITE_RXOVERSIZEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXOVERSIZEPKTS_IMPr,&(r._rxoversizepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTS_IMPr BCM89500_A0_RXOVERSIZEPKTS_IMPr
#define RXOVERSIZEPKTS_IMPr_SIZE BCM89500_A0_RXOVERSIZEPKTS_IMPr_SIZE
typedef BCM89500_A0_RXOVERSIZEPKTS_IMPr_t RXOVERSIZEPKTS_IMPr_t;
#define RXOVERSIZEPKTS_IMPr_CLR BCM89500_A0_RXOVERSIZEPKTS_IMPr_CLR
#define RXOVERSIZEPKTS_IMPr_SET BCM89500_A0_RXOVERSIZEPKTS_IMPr_SET
#define RXOVERSIZEPKTS_IMPr_GET BCM89500_A0_RXOVERSIZEPKTS_IMPr_GET
#define READ_RXOVERSIZEPKTS_IMPr BCM89500_A0_READ_RXOVERSIZEPKTS_IMPr
#define WRITE_RXOVERSIZEPKTS_IMPr BCM89500_A0_WRITE_RXOVERSIZEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXOVERSIZEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxOversizePkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXOVERSIZEPKTS_P7r 0x00002778

#define BCM89500_A0_RXOVERSIZEPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts_P7.
 *
 */
typedef union BCM89500_A0_RXOVERSIZEPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxoversizepkts_p7[1];
	uint32_t _rxoversizepkts_p7;
} BCM89500_A0_RXOVERSIZEPKTS_P7r_t;

#define BCM89500_A0_RXOVERSIZEPKTS_P7r_CLR(r) (r).rxoversizepkts_p7[0] = 0
#define BCM89500_A0_RXOVERSIZEPKTS_P7r_SET(r,d) (r).rxoversizepkts_p7[0] = d
#define BCM89500_A0_RXOVERSIZEPKTS_P7r_GET(r) (r).rxoversizepkts_p7[0]


/*
 * These macros can be used to access RxOversizePkts_P7.
 *
 */
#define BCM89500_A0_READ_RXOVERSIZEPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXOVERSIZEPKTS_P7r,(r._rxoversizepkts_p7),4)
#define BCM89500_A0_WRITE_RXOVERSIZEPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXOVERSIZEPKTS_P7r,&(r._rxoversizepkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTS_P7r BCM89500_A0_RXOVERSIZEPKTS_P7r
#define RXOVERSIZEPKTS_P7r_SIZE BCM89500_A0_RXOVERSIZEPKTS_P7r_SIZE
typedef BCM89500_A0_RXOVERSIZEPKTS_P7r_t RXOVERSIZEPKTS_P7r_t;
#define RXOVERSIZEPKTS_P7r_CLR BCM89500_A0_RXOVERSIZEPKTS_P7r_CLR
#define RXOVERSIZEPKTS_P7r_SET BCM89500_A0_RXOVERSIZEPKTS_P7r_SET
#define RXOVERSIZEPKTS_P7r_GET BCM89500_A0_RXOVERSIZEPKTS_P7r_GET
#define READ_RXOVERSIZEPKTS_P7r BCM89500_A0_READ_RXOVERSIZEPKTS_P7r
#define WRITE_RXOVERSIZEPKTS_P7r BCM89500_A0_WRITE_RXOVERSIZEPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXOVERSIZEPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXPAUSEPKTSr 0x0000205c

#define BCM89500_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 *
 */
typedef union BCM89500_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM89500_A0_RXPAUSEPKTSr_t;

#define BCM89500_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM89500_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM89500_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 *
 */
#define BCM89500_A0_READ_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM89500_A0_WRITE_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM89500_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM89500_A0_RXPAUSEPKTSr_SIZE
typedef BCM89500_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM89500_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM89500_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM89500_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM89500_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM89500_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxPausePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXPAUSEPKTS_IMPr 0x0000285c

#define BCM89500_A0_RXPAUSEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts_IMP.
 *
 */
typedef union BCM89500_A0_RXPAUSEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxpausepkts_imp[1];
	uint32_t _rxpausepkts_imp;
} BCM89500_A0_RXPAUSEPKTS_IMPr_t;

#define BCM89500_A0_RXPAUSEPKTS_IMPr_CLR(r) (r).rxpausepkts_imp[0] = 0
#define BCM89500_A0_RXPAUSEPKTS_IMPr_SET(r,d) (r).rxpausepkts_imp[0] = d
#define BCM89500_A0_RXPAUSEPKTS_IMPr_GET(r) (r).rxpausepkts_imp[0]


/*
 * These macros can be used to access RxPausePkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXPAUSEPKTS_IMPr,(r._rxpausepkts_imp),4)
#define BCM89500_A0_WRITE_RXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXPAUSEPKTS_IMPr,&(r._rxpausepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTS_IMPr BCM89500_A0_RXPAUSEPKTS_IMPr
#define RXPAUSEPKTS_IMPr_SIZE BCM89500_A0_RXPAUSEPKTS_IMPr_SIZE
typedef BCM89500_A0_RXPAUSEPKTS_IMPr_t RXPAUSEPKTS_IMPr_t;
#define RXPAUSEPKTS_IMPr_CLR BCM89500_A0_RXPAUSEPKTS_IMPr_CLR
#define RXPAUSEPKTS_IMPr_SET BCM89500_A0_RXPAUSEPKTS_IMPr_SET
#define RXPAUSEPKTS_IMPr_GET BCM89500_A0_RXPAUSEPKTS_IMPr_GET
#define READ_RXPAUSEPKTS_IMPr BCM89500_A0_READ_RXPAUSEPKTS_IMPr
#define WRITE_RXPAUSEPKTS_IMPr BCM89500_A0_WRITE_RXPAUSEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXPAUSEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxPausePkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXPAUSEPKTS_P7r 0x0000275c

#define BCM89500_A0_RXPAUSEPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts_P7.
 *
 */
typedef union BCM89500_A0_RXPAUSEPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxpausepkts_p7[1];
	uint32_t _rxpausepkts_p7;
} BCM89500_A0_RXPAUSEPKTS_P7r_t;

#define BCM89500_A0_RXPAUSEPKTS_P7r_CLR(r) (r).rxpausepkts_p7[0] = 0
#define BCM89500_A0_RXPAUSEPKTS_P7r_SET(r,d) (r).rxpausepkts_p7[0] = d
#define BCM89500_A0_RXPAUSEPKTS_P7r_GET(r) (r).rxpausepkts_p7[0]


/*
 * These macros can be used to access RxPausePkts_P7.
 *
 */
#define BCM89500_A0_READ_RXPAUSEPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXPAUSEPKTS_P7r,(r._rxpausepkts_p7),4)
#define BCM89500_A0_WRITE_RXPAUSEPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXPAUSEPKTS_P7r,&(r._rxpausepkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTS_P7r BCM89500_A0_RXPAUSEPKTS_P7r
#define RXPAUSEPKTS_P7r_SIZE BCM89500_A0_RXPAUSEPKTS_P7r_SIZE
typedef BCM89500_A0_RXPAUSEPKTS_P7r_t RXPAUSEPKTS_P7r_t;
#define RXPAUSEPKTS_P7r_CLR BCM89500_A0_RXPAUSEPKTS_P7r_CLR
#define RXPAUSEPKTS_P7r_SET BCM89500_A0_RXPAUSEPKTS_P7r_SET
#define RXPAUSEPKTS_P7r_GET BCM89500_A0_RXPAUSEPKTS_P7r_GET
#define READ_RXPAUSEPKTS_P7r BCM89500_A0_READ_RXPAUSEPKTS_P7r
#define WRITE_RXPAUSEPKTS_P7r BCM89500_A0_WRITE_RXPAUSEPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXPAUSEPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxSAChanges
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXSACHANGESr 0x000020a0

#define BCM89500_A0_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges.
 *
 */
typedef union BCM89500_A0_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t rxsachanges[1];
	uint32_t _rxsachanges;
} BCM89500_A0_RXSACHANGESr_t;

#define BCM89500_A0_RXSACHANGESr_CLR(r) (r).rxsachanges[0] = 0
#define BCM89500_A0_RXSACHANGESr_SET(r,d) (r).rxsachanges[0] = d
#define BCM89500_A0_RXSACHANGESr_GET(r) (r).rxsachanges[0]


/*
 * These macros can be used to access RxSAChanges.
 *
 */
#define BCM89500_A0_READ_RXSACHANGESr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXSACHANGESr,(r._rxsachanges),4)
#define BCM89500_A0_WRITE_RXSACHANGESr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXSACHANGESr,&(r._rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGESr BCM89500_A0_RXSACHANGESr
#define RXSACHANGESr_SIZE BCM89500_A0_RXSACHANGESr_SIZE
typedef BCM89500_A0_RXSACHANGESr_t RXSACHANGESr_t;
#define RXSACHANGESr_CLR BCM89500_A0_RXSACHANGESr_CLR
#define RXSACHANGESr_SET BCM89500_A0_RXSACHANGESr_SET
#define RXSACHANGESr_GET BCM89500_A0_RXSACHANGESr_GET
#define READ_RXSACHANGESr BCM89500_A0_READ_RXSACHANGESr
#define WRITE_RXSACHANGESr BCM89500_A0_WRITE_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxSAChanges_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXSACHANGES_IMPr 0x000028a0

#define BCM89500_A0_RXSACHANGES_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges_IMP.
 *
 */
typedef union BCM89500_A0_RXSACHANGES_IMPr_s {
	uint32_t v[1];
	uint32_t rxsachanges_imp[1];
	uint32_t _rxsachanges_imp;
} BCM89500_A0_RXSACHANGES_IMPr_t;

#define BCM89500_A0_RXSACHANGES_IMPr_CLR(r) (r).rxsachanges_imp[0] = 0
#define BCM89500_A0_RXSACHANGES_IMPr_SET(r,d) (r).rxsachanges_imp[0] = d
#define BCM89500_A0_RXSACHANGES_IMPr_GET(r) (r).rxsachanges_imp[0]


/*
 * These macros can be used to access RxSAChanges_IMP.
 *
 */
#define BCM89500_A0_READ_RXSACHANGES_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXSACHANGES_IMPr,(r._rxsachanges_imp),4)
#define BCM89500_A0_WRITE_RXSACHANGES_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXSACHANGES_IMPr,&(r._rxsachanges_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGES_IMPr BCM89500_A0_RXSACHANGES_IMPr
#define RXSACHANGES_IMPr_SIZE BCM89500_A0_RXSACHANGES_IMPr_SIZE
typedef BCM89500_A0_RXSACHANGES_IMPr_t RXSACHANGES_IMPr_t;
#define RXSACHANGES_IMPr_CLR BCM89500_A0_RXSACHANGES_IMPr_CLR
#define RXSACHANGES_IMPr_SET BCM89500_A0_RXSACHANGES_IMPr_SET
#define RXSACHANGES_IMPr_GET BCM89500_A0_RXSACHANGES_IMPr_GET
#define READ_RXSACHANGES_IMPr BCM89500_A0_READ_RXSACHANGES_IMPr
#define WRITE_RXSACHANGES_IMPr BCM89500_A0_WRITE_RXSACHANGES_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXSACHANGES_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxSAChanges_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXSACHANGES_P7r 0x000027a0

#define BCM89500_A0_RXSACHANGES_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges_P7.
 *
 */
typedef union BCM89500_A0_RXSACHANGES_P7r_s {
	uint32_t v[1];
	uint32_t rxsachanges_p7[1];
	uint32_t _rxsachanges_p7;
} BCM89500_A0_RXSACHANGES_P7r_t;

#define BCM89500_A0_RXSACHANGES_P7r_CLR(r) (r).rxsachanges_p7[0] = 0
#define BCM89500_A0_RXSACHANGES_P7r_SET(r,d) (r).rxsachanges_p7[0] = d
#define BCM89500_A0_RXSACHANGES_P7r_GET(r) (r).rxsachanges_p7[0]


/*
 * These macros can be used to access RxSAChanges_P7.
 *
 */
#define BCM89500_A0_READ_RXSACHANGES_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXSACHANGES_P7r,(r._rxsachanges_p7),4)
#define BCM89500_A0_WRITE_RXSACHANGES_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXSACHANGES_P7r,&(r._rxsachanges_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGES_P7r BCM89500_A0_RXSACHANGES_P7r
#define RXSACHANGES_P7r_SIZE BCM89500_A0_RXSACHANGES_P7r_SIZE
typedef BCM89500_A0_RXSACHANGES_P7r_t RXSACHANGES_P7r_t;
#define RXSACHANGES_P7r_CLR BCM89500_A0_RXSACHANGES_P7r_CLR
#define RXSACHANGES_P7r_SET BCM89500_A0_RXSACHANGES_P7r_SET
#define RXSACHANGES_P7r_GET BCM89500_A0_RXSACHANGES_P7r_GET
#define READ_RXSACHANGES_P7r BCM89500_A0_READ_RXSACHANGES_P7r
#define WRITE_RXSACHANGES_P7r BCM89500_A0_WRITE_RXSACHANGES_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXSACHANGES_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXUNDERSIZEPKTSr 0x00002058

#define BCM89500_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 *
 */
typedef union BCM89500_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM89500_A0_RXUNDERSIZEPKTSr_t;

#define BCM89500_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM89500_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM89500_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 *
 */
#define BCM89500_A0_READ_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM89500_A0_WRITE_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM89500_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM89500_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM89500_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM89500_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM89500_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM89500_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM89500_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM89500_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxUndersizePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXUNDERSIZEPKTS_IMPr 0x00002858

#define BCM89500_A0_RXUNDERSIZEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts_IMP.
 *
 */
typedef union BCM89500_A0_RXUNDERSIZEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts_imp[1];
	uint32_t _rxundersizepkts_imp;
} BCM89500_A0_RXUNDERSIZEPKTS_IMPr_t;

#define BCM89500_A0_RXUNDERSIZEPKTS_IMPr_CLR(r) (r).rxundersizepkts_imp[0] = 0
#define BCM89500_A0_RXUNDERSIZEPKTS_IMPr_SET(r,d) (r).rxundersizepkts_imp[0] = d
#define BCM89500_A0_RXUNDERSIZEPKTS_IMPr_GET(r) (r).rxundersizepkts_imp[0]


/*
 * These macros can be used to access RxUndersizePkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXUNDERSIZEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXUNDERSIZEPKTS_IMPr,(r._rxundersizepkts_imp),4)
#define BCM89500_A0_WRITE_RXUNDERSIZEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXUNDERSIZEPKTS_IMPr,&(r._rxundersizepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTS_IMPr BCM89500_A0_RXUNDERSIZEPKTS_IMPr
#define RXUNDERSIZEPKTS_IMPr_SIZE BCM89500_A0_RXUNDERSIZEPKTS_IMPr_SIZE
typedef BCM89500_A0_RXUNDERSIZEPKTS_IMPr_t RXUNDERSIZEPKTS_IMPr_t;
#define RXUNDERSIZEPKTS_IMPr_CLR BCM89500_A0_RXUNDERSIZEPKTS_IMPr_CLR
#define RXUNDERSIZEPKTS_IMPr_SET BCM89500_A0_RXUNDERSIZEPKTS_IMPr_SET
#define RXUNDERSIZEPKTS_IMPr_GET BCM89500_A0_RXUNDERSIZEPKTS_IMPr_GET
#define READ_RXUNDERSIZEPKTS_IMPr BCM89500_A0_READ_RXUNDERSIZEPKTS_IMPr
#define WRITE_RXUNDERSIZEPKTS_IMPr BCM89500_A0_WRITE_RXUNDERSIZEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXUNDERSIZEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxUndersizePkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXUNDERSIZEPKTS_P7r 0x00002758

#define BCM89500_A0_RXUNDERSIZEPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts_P7.
 *
 */
typedef union BCM89500_A0_RXUNDERSIZEPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxundersizepkts_p7[1];
	uint32_t _rxundersizepkts_p7;
} BCM89500_A0_RXUNDERSIZEPKTS_P7r_t;

#define BCM89500_A0_RXUNDERSIZEPKTS_P7r_CLR(r) (r).rxundersizepkts_p7[0] = 0
#define BCM89500_A0_RXUNDERSIZEPKTS_P7r_SET(r,d) (r).rxundersizepkts_p7[0] = d
#define BCM89500_A0_RXUNDERSIZEPKTS_P7r_GET(r) (r).rxundersizepkts_p7[0]


/*
 * These macros can be used to access RxUndersizePkts_P7.
 *
 */
#define BCM89500_A0_READ_RXUNDERSIZEPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXUNDERSIZEPKTS_P7r,(r._rxundersizepkts_p7),4)
#define BCM89500_A0_WRITE_RXUNDERSIZEPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXUNDERSIZEPKTS_P7r,&(r._rxundersizepkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTS_P7r BCM89500_A0_RXUNDERSIZEPKTS_P7r
#define RXUNDERSIZEPKTS_P7r_SIZE BCM89500_A0_RXUNDERSIZEPKTS_P7r_SIZE
typedef BCM89500_A0_RXUNDERSIZEPKTS_P7r_t RXUNDERSIZEPKTS_P7r_t;
#define RXUNDERSIZEPKTS_P7r_CLR BCM89500_A0_RXUNDERSIZEPKTS_P7r_CLR
#define RXUNDERSIZEPKTS_P7r_SET BCM89500_A0_RXUNDERSIZEPKTS_P7r_SET
#define RXUNDERSIZEPKTS_P7r_GET BCM89500_A0_RXUNDERSIZEPKTS_P7r_GET
#define READ_RXUNDERSIZEPKTS_P7r BCM89500_A0_READ_RXUNDERSIZEPKTS_P7r
#define WRITE_RXUNDERSIZEPKTS_P7r BCM89500_A0_WRITE_RXUNDERSIZEPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXUNDERSIZEPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXUNICASTPKTSr 0x00002094

#define BCM89500_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 *
 */
typedef union BCM89500_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM89500_A0_RXUNICASTPKTSr_t;

#define BCM89500_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM89500_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM89500_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 *
 */
#define BCM89500_A0_READ_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM89500_A0_WRITE_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM89500_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM89500_A0_RXUNICASTPKTSr_SIZE
typedef BCM89500_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM89500_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM89500_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM89500_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM89500_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM89500_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxUnicastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXUNICASTPKTS_IMPr 0x00002894

#define BCM89500_A0_RXUNICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts_IMP.
 *
 */
typedef union BCM89500_A0_RXUNICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts_imp[1];
	uint32_t _rxunicastpkts_imp;
} BCM89500_A0_RXUNICASTPKTS_IMPr_t;

#define BCM89500_A0_RXUNICASTPKTS_IMPr_CLR(r) (r).rxunicastpkts_imp[0] = 0
#define BCM89500_A0_RXUNICASTPKTS_IMPr_SET(r,d) (r).rxunicastpkts_imp[0] = d
#define BCM89500_A0_RXUNICASTPKTS_IMPr_GET(r) (r).rxunicastpkts_imp[0]


/*
 * These macros can be used to access RxUnicastPkts_IMP.
 *
 */
#define BCM89500_A0_READ_RXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXUNICASTPKTS_IMPr,(r._rxunicastpkts_imp),4)
#define BCM89500_A0_WRITE_RXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXUNICASTPKTS_IMPr,&(r._rxunicastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTS_IMPr BCM89500_A0_RXUNICASTPKTS_IMPr
#define RXUNICASTPKTS_IMPr_SIZE BCM89500_A0_RXUNICASTPKTS_IMPr_SIZE
typedef BCM89500_A0_RXUNICASTPKTS_IMPr_t RXUNICASTPKTS_IMPr_t;
#define RXUNICASTPKTS_IMPr_CLR BCM89500_A0_RXUNICASTPKTS_IMPr_CLR
#define RXUNICASTPKTS_IMPr_SET BCM89500_A0_RXUNICASTPKTS_IMPr_SET
#define RXUNICASTPKTS_IMPr_GET BCM89500_A0_RXUNICASTPKTS_IMPr_GET
#define READ_RXUNICASTPKTS_IMPr BCM89500_A0_READ_RXUNICASTPKTS_IMPr
#define WRITE_RXUNICASTPKTS_IMPr BCM89500_A0_WRITE_RXUNICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXUNICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  RxUnicastPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_RXUNICASTPKTS_P7r 0x00002794

#define BCM89500_A0_RXUNICASTPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts_P7.
 *
 */
typedef union BCM89500_A0_RXUNICASTPKTS_P7r_s {
	uint32_t v[1];
	uint32_t rxunicastpkts_p7[1];
	uint32_t _rxunicastpkts_p7;
} BCM89500_A0_RXUNICASTPKTS_P7r_t;

#define BCM89500_A0_RXUNICASTPKTS_P7r_CLR(r) (r).rxunicastpkts_p7[0] = 0
#define BCM89500_A0_RXUNICASTPKTS_P7r_SET(r,d) (r).rxunicastpkts_p7[0] = d
#define BCM89500_A0_RXUNICASTPKTS_P7r_GET(r) (r).rxunicastpkts_p7[0]


/*
 * These macros can be used to access RxUnicastPkts_P7.
 *
 */
#define BCM89500_A0_READ_RXUNICASTPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_RXUNICASTPKTS_P7r,(r._rxunicastpkts_p7),4)
#define BCM89500_A0_WRITE_RXUNICASTPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_RXUNICASTPKTS_P7r,&(r._rxunicastpkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTS_P7r BCM89500_A0_RXUNICASTPKTS_P7r
#define RXUNICASTPKTS_P7r_SIZE BCM89500_A0_RXUNICASTPKTS_P7r_SIZE
typedef BCM89500_A0_RXUNICASTPKTS_P7r_t RXUNICASTPKTS_P7r_t;
#define RXUNICASTPKTS_P7r_CLR BCM89500_A0_RXUNICASTPKTS_P7r_CLR
#define RXUNICASTPKTS_P7r_SET BCM89500_A0_RXUNICASTPKTS_P7r_SET
#define RXUNICASTPKTS_P7r_GET BCM89500_A0_RXUNICASTPKTS_P7r_GET
#define READ_RXUNICASTPKTS_P7r BCM89500_A0_READ_RXUNICASTPKTS_P7r
#define WRITE_RXUNICASTPKTS_P7r BCM89500_A0_WRITE_RXUNICASTPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_RXUNICASTPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_ANADV
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       write as 0, ignore on read.
 *     FULL_DUPLEX      1 = advertise full-duplex0 = do not advertise full-duplex
 *     HALF_DUPLEX      1 = advertise half-duplex0 = do not advertise half-duplex
 *     PAUSE            2'b00: no pause2'b01: symmetric pause2'b10: asymmetric pause toward link partner2'b11: both symmetric pause and asymmetric pause toward local device
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     2'b00: no_remote_fault2'b01: link_failure2'b10: offline2'b11: autoneg_error
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        write as 0, ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_ANADVr 0x00001508

#define BCM89500_A0_SD_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program SD_ANADV.
 *
 */
typedef union BCM89500_A0_SD_ANADVr_s {
	uint32_t v[1];
	uint32_t sd_anadv[1];
	uint32_t _sd_anadv;
} BCM89500_A0_SD_ANADVr_t;

#define BCM89500_A0_SD_ANADVr_CLR(r) (r).sd_anadv[0] = 0
#define BCM89500_A0_SD_ANADVr_SET(r,d) (r).sd_anadv[0] = d
#define BCM89500_A0_SD_ANADVr_GET(r) (r).sd_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_ANADVr_RESERVED_0f_GET(r) (((r).sd_anadv[0]) & 0x1f)
#define BCM89500_A0_SD_ANADVr_RESERVED_0f_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM89500_A0_SD_ANADVr_FULL_DUPLEXf_GET(r) ((((r).sd_anadv[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_ANADVr_FULL_DUPLEXf_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_ANADVr_HALF_DUPLEXf_GET(r) ((((r).sd_anadv[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_ANADVr_HALF_DUPLEXf_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_ANADVr_PAUSEf_GET(r) ((((r).sd_anadv[0]) >> 7) & 0x3)
#define BCM89500_A0_SD_ANADVr_PAUSEf_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM89500_A0_SD_ANADVr_RESERVED_1f_GET(r) ((((r).sd_anadv[0]) >> 9) & 0x7)
#define BCM89500_A0_SD_ANADVr_RESERVED_1f_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_SD_ANADVr_REMOTE_FAULTf_GET(r) ((((r).sd_anadv[0]) >> 12) & 0x3)
#define BCM89500_A0_SD_ANADVr_REMOTE_FAULTf_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_SD_ANADVr_RESERVED_2f_GET(r) ((((r).sd_anadv[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_ANADVr_RESERVED_2f_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_ANADVr_NEXT_PAGEf_GET(r) ((((r).sd_anadv[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_ANADVr_NEXT_PAGEf_SET(r,f) (r).sd_anadv[0]=(((r).sd_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_ANADV.
 *
 */
#define BCM89500_A0_READ_SD_ANADVr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_ANADVr,(r._sd_anadv),2)
#define BCM89500_A0_WRITE_SD_ANADVr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_ANADVr,&(r._sd_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_ANADVr BCM89500_A0_SD_ANADVr
#define SD_ANADVr_SIZE BCM89500_A0_SD_ANADVr_SIZE
typedef BCM89500_A0_SD_ANADVr_t SD_ANADVr_t;
#define SD_ANADVr_CLR BCM89500_A0_SD_ANADVr_CLR
#define SD_ANADVr_SET BCM89500_A0_SD_ANADVr_SET
#define SD_ANADVr_GET BCM89500_A0_SD_ANADVr_GET
#define SD_ANADVr_RESERVED_0f_GET BCM89500_A0_SD_ANADVr_RESERVED_0f_GET
#define SD_ANADVr_RESERVED_0f_SET BCM89500_A0_SD_ANADVr_RESERVED_0f_SET
#define SD_ANADVr_FULL_DUPLEXf_GET BCM89500_A0_SD_ANADVr_FULL_DUPLEXf_GET
#define SD_ANADVr_FULL_DUPLEXf_SET BCM89500_A0_SD_ANADVr_FULL_DUPLEXf_SET
#define SD_ANADVr_HALF_DUPLEXf_GET BCM89500_A0_SD_ANADVr_HALF_DUPLEXf_GET
#define SD_ANADVr_HALF_DUPLEXf_SET BCM89500_A0_SD_ANADVr_HALF_DUPLEXf_SET
#define SD_ANADVr_PAUSEf_GET BCM89500_A0_SD_ANADVr_PAUSEf_GET
#define SD_ANADVr_PAUSEf_SET BCM89500_A0_SD_ANADVr_PAUSEf_SET
#define SD_ANADVr_RESERVED_1f_GET BCM89500_A0_SD_ANADVr_RESERVED_1f_GET
#define SD_ANADVr_RESERVED_1f_SET BCM89500_A0_SD_ANADVr_RESERVED_1f_SET
#define SD_ANADVr_REMOTE_FAULTf_GET BCM89500_A0_SD_ANADVr_REMOTE_FAULTf_GET
#define SD_ANADVr_REMOTE_FAULTf_SET BCM89500_A0_SD_ANADVr_REMOTE_FAULTf_SET
#define SD_ANADVr_RESERVED_2f_GET BCM89500_A0_SD_ANADVr_RESERVED_2f_GET
#define SD_ANADVr_RESERVED_2f_SET BCM89500_A0_SD_ANADVr_RESERVED_2f_SET
#define SD_ANADVr_NEXT_PAGEf_GET BCM89500_A0_SD_ANADVr_NEXT_PAGEf_GET
#define SD_ANADVr_NEXT_PAGEf_SET BCM89500_A0_SD_ANADVr_NEXT_PAGEf_SET
#define READ_SD_ANADVr BCM89500_A0_READ_SD_ANADVr
#define WRITE_SD_ANADVr BCM89500_A0_WRITE_SD_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_ANEXP
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       ignore on read.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_ANEXPr 0x0000150c

#define BCM89500_A0_SD_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program SD_ANEXP.
 *
 */
typedef union BCM89500_A0_SD_ANEXPr_s {
	uint32_t v[1];
	uint32_t sd_anexp[1];
	uint32_t _sd_anexp;
} BCM89500_A0_SD_ANEXPr_t;

#define BCM89500_A0_SD_ANEXPr_CLR(r) (r).sd_anexp[0] = 0
#define BCM89500_A0_SD_ANEXPr_SET(r,d) (r).sd_anexp[0] = d
#define BCM89500_A0_SD_ANEXPr_GET(r) (r).sd_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_ANEXPr_RESERVED_0f_GET(r) (((r).sd_anexp[0]) & 0x1)
#define BCM89500_A0_SD_ANEXPr_RESERVED_0f_SET(r,f) (r).sd_anexp[0]=(((r).sd_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_ANEXPr_PAGE_RECf_GET(r) ((((r).sd_anexp[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_ANEXPr_PAGE_RECf_SET(r,f) (r).sd_anexp[0]=(((r).sd_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).sd_anexp[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).sd_anexp[0]=(((r).sd_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_ANEXPr_RESERVED_1f_GET(r) ((((r).sd_anexp[0]) >> 3) & 0x1fff)
#define BCM89500_A0_SD_ANEXPr_RESERVED_1f_SET(r,f) (r).sd_anexp[0]=(((r).sd_anexp[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access SD_ANEXP.
 *
 */
#define BCM89500_A0_READ_SD_ANEXPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_ANEXPr,(r._sd_anexp),2)
#define BCM89500_A0_WRITE_SD_ANEXPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_ANEXPr,&(r._sd_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_ANEXPr BCM89500_A0_SD_ANEXPr
#define SD_ANEXPr_SIZE BCM89500_A0_SD_ANEXPr_SIZE
typedef BCM89500_A0_SD_ANEXPr_t SD_ANEXPr_t;
#define SD_ANEXPr_CLR BCM89500_A0_SD_ANEXPr_CLR
#define SD_ANEXPr_SET BCM89500_A0_SD_ANEXPr_SET
#define SD_ANEXPr_GET BCM89500_A0_SD_ANEXPr_GET
#define SD_ANEXPr_RESERVED_0f_GET BCM89500_A0_SD_ANEXPr_RESERVED_0f_GET
#define SD_ANEXPr_RESERVED_0f_SET BCM89500_A0_SD_ANEXPr_RESERVED_0f_SET
#define SD_ANEXPr_PAGE_RECf_GET BCM89500_A0_SD_ANEXPr_PAGE_RECf_GET
#define SD_ANEXPr_PAGE_RECf_SET BCM89500_A0_SD_ANEXPr_PAGE_RECf_SET
#define SD_ANEXPr_NEXT_PAGE_ABIf_GET BCM89500_A0_SD_ANEXPr_NEXT_PAGE_ABIf_GET
#define SD_ANEXPr_NEXT_PAGE_ABIf_SET BCM89500_A0_SD_ANEXPr_NEXT_PAGE_ABIf_SET
#define SD_ANEXPr_RESERVED_1f_GET BCM89500_A0_SD_ANEXPr_RESERVED_1f_GET
#define SD_ANEXPr_RESERVED_1f_SET BCM89500_A0_SD_ANEXPr_RESERVED_1f_SET
#define READ_SD_ANEXPr BCM89500_A0_READ_SD_ANEXPr
#define WRITE_SD_ANEXPr BCM89500_A0_WRITE_SD_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_ANLPA
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Link Partner Ability Register
 * SIZE:     16
 * FIELDS:
 *     SGMII_MODE       1 = SGMII mode0 = fiber modenote: When the link partner is in SGMII mode (bit 0 = 1), then bit 15 = link, bit 12 = duplex, bits 11:10 = speed, bit 14 = acknowledge. The other bits are reserved and should be zero.
 *     RESERVED_0       write as 0, ignore on read.
 *     FULL_DUPLEX      1 = advertise full-duplex0 = do not advertise full-duplex
 *     HALF_DUPLEX      1 = advertise half-duplex0 = do not advertise half-duplex
 *     PAUSE            2'b00: no pause2'b01: symmetric pause2'b10: asymmetric pause toward link partner2'b11: both symmetric pause and asymmetric pause toward local device
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     2'b00: no_remote_fault2'b01: link_failure2'b10: offline2'b11: autoneg_error
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_ANLPAr 0x0000150a

#define BCM89500_A0_SD_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program SD_ANLPA.
 *
 */
typedef union BCM89500_A0_SD_ANLPAr_s {
	uint32_t v[1];
	uint32_t sd_anlpa[1];
	uint32_t _sd_anlpa;
} BCM89500_A0_SD_ANLPAr_t;

#define BCM89500_A0_SD_ANLPAr_CLR(r) (r).sd_anlpa[0] = 0
#define BCM89500_A0_SD_ANLPAr_SET(r,d) (r).sd_anlpa[0] = d
#define BCM89500_A0_SD_ANLPAr_GET(r) (r).sd_anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_ANLPAr_SGMII_MODEf_GET(r) (((r).sd_anlpa[0]) & 0x1)
#define BCM89500_A0_SD_ANLPAr_SGMII_MODEf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_ANLPAr_RESERVED_0f_GET(r) ((((r).sd_anlpa[0]) >> 1) & 0xf)
#define BCM89500_A0_SD_ANLPAr_RESERVED_0f_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM89500_A0_SD_ANLPAr_FULL_DUPLEXf_GET(r) ((((r).sd_anlpa[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_ANLPAr_FULL_DUPLEXf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_ANLPAr_HALF_DUPLEXf_GET(r) ((((r).sd_anlpa[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_ANLPAr_HALF_DUPLEXf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_ANLPAr_PAUSEf_GET(r) ((((r).sd_anlpa[0]) >> 7) & 0x3)
#define BCM89500_A0_SD_ANLPAr_PAUSEf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM89500_A0_SD_ANLPAr_RESERVED_1f_GET(r) ((((r).sd_anlpa[0]) >> 9) & 0x7)
#define BCM89500_A0_SD_ANLPAr_RESERVED_1f_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_SD_ANLPAr_REMOTE_FAULTf_GET(r) ((((r).sd_anlpa[0]) >> 12) & 0x3)
#define BCM89500_A0_SD_ANLPAr_REMOTE_FAULTf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_SD_ANLPAr_ACKNOWLEDGEf_GET(r) ((((r).sd_anlpa[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_ANLPAr_ACKNOWLEDGEf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_ANLPAr_NEXT_PAGEf_GET(r) ((((r).sd_anlpa[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_ANLPAr_NEXT_PAGEf_SET(r,f) (r).sd_anlpa[0]=(((r).sd_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_ANLPA.
 *
 */
#define BCM89500_A0_READ_SD_ANLPAr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_ANLPAr,(r._sd_anlpa),2)
#define BCM89500_A0_WRITE_SD_ANLPAr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_ANLPAr,&(r._sd_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_ANLPAr BCM89500_A0_SD_ANLPAr
#define SD_ANLPAr_SIZE BCM89500_A0_SD_ANLPAr_SIZE
typedef BCM89500_A0_SD_ANLPAr_t SD_ANLPAr_t;
#define SD_ANLPAr_CLR BCM89500_A0_SD_ANLPAr_CLR
#define SD_ANLPAr_SET BCM89500_A0_SD_ANLPAr_SET
#define SD_ANLPAr_GET BCM89500_A0_SD_ANLPAr_GET
#define SD_ANLPAr_SGMII_MODEf_GET BCM89500_A0_SD_ANLPAr_SGMII_MODEf_GET
#define SD_ANLPAr_SGMII_MODEf_SET BCM89500_A0_SD_ANLPAr_SGMII_MODEf_SET
#define SD_ANLPAr_RESERVED_0f_GET BCM89500_A0_SD_ANLPAr_RESERVED_0f_GET
#define SD_ANLPAr_RESERVED_0f_SET BCM89500_A0_SD_ANLPAr_RESERVED_0f_SET
#define SD_ANLPAr_FULL_DUPLEXf_GET BCM89500_A0_SD_ANLPAr_FULL_DUPLEXf_GET
#define SD_ANLPAr_FULL_DUPLEXf_SET BCM89500_A0_SD_ANLPAr_FULL_DUPLEXf_SET
#define SD_ANLPAr_HALF_DUPLEXf_GET BCM89500_A0_SD_ANLPAr_HALF_DUPLEXf_GET
#define SD_ANLPAr_HALF_DUPLEXf_SET BCM89500_A0_SD_ANLPAr_HALF_DUPLEXf_SET
#define SD_ANLPAr_PAUSEf_GET BCM89500_A0_SD_ANLPAr_PAUSEf_GET
#define SD_ANLPAr_PAUSEf_SET BCM89500_A0_SD_ANLPAr_PAUSEf_SET
#define SD_ANLPAr_RESERVED_1f_GET BCM89500_A0_SD_ANLPAr_RESERVED_1f_GET
#define SD_ANLPAr_RESERVED_1f_SET BCM89500_A0_SD_ANLPAr_RESERVED_1f_SET
#define SD_ANLPAr_REMOTE_FAULTf_GET BCM89500_A0_SD_ANLPAr_REMOTE_FAULTf_GET
#define SD_ANLPAr_REMOTE_FAULTf_SET BCM89500_A0_SD_ANLPAr_REMOTE_FAULTf_SET
#define SD_ANLPAr_ACKNOWLEDGEf_GET BCM89500_A0_SD_ANLPAr_ACKNOWLEDGEf_GET
#define SD_ANLPAr_ACKNOWLEDGEf_SET BCM89500_A0_SD_ANLPAr_ACKNOWLEDGEf_SET
#define SD_ANLPAr_NEXT_PAGEf_GET BCM89500_A0_SD_ANLPAr_NEXT_PAGEf_GET
#define SD_ANLPAr_NEXT_PAGEf_SET BCM89500_A0_SD_ANLPAr_NEXT_PAGEf_SET
#define READ_SD_ANLPAr BCM89500_A0_READ_SD_ANLPAr
#define WRITE_SD_ANLPAr BCM89500_A0_WRITE_SD_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_ANNXP
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_ANNXPr 0x0000150e

#define BCM89500_A0_SD_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program SD_ANNXP.
 *
 */
typedef union BCM89500_A0_SD_ANNXPr_s {
	uint32_t v[1];
	uint32_t sd_annxp[1];
	uint32_t _sd_annxp;
} BCM89500_A0_SD_ANNXPr_t;

#define BCM89500_A0_SD_ANNXPr_CLR(r) (r).sd_annxp[0] = 0
#define BCM89500_A0_SD_ANNXPr_SET(r,d) (r).sd_annxp[0] = d
#define BCM89500_A0_SD_ANNXPr_GET(r) (r).sd_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_ANNXPr_RESERVEDf_GET(r) (((r).sd_annxp[0]) & 0xffff)
#define BCM89500_A0_SD_ANNXPr_RESERVEDf_SET(r,f) (r).sd_annxp[0]=(((r).sd_annxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SD_ANNXP.
 *
 */
#define BCM89500_A0_READ_SD_ANNXPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_ANNXPr,(r._sd_annxp),2)
#define BCM89500_A0_WRITE_SD_ANNXPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_ANNXPr,&(r._sd_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_ANNXPr BCM89500_A0_SD_ANNXPr
#define SD_ANNXPr_SIZE BCM89500_A0_SD_ANNXPr_SIZE
typedef BCM89500_A0_SD_ANNXPr_t SD_ANNXPr_t;
#define SD_ANNXPr_CLR BCM89500_A0_SD_ANNXPr_CLR
#define SD_ANNXPr_SET BCM89500_A0_SD_ANNXPr_SET
#define SD_ANNXPr_GET BCM89500_A0_SD_ANNXPr_GET
#define SD_ANNXPr_RESERVEDf_GET BCM89500_A0_SD_ANNXPr_RESERVEDf_GET
#define SD_ANNXPr_RESERVEDf_SET BCM89500_A0_SD_ANNXPr_RESERVEDf_SET
#define READ_SD_ANNXPr BCM89500_A0_READ_SD_ANNXPr
#define WRITE_SD_ANNXPr BCM89500_A0_WRITE_SD_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_CTL1
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Control 1 Register
 * SIZE:     16
 * FIELDS:
 *     FIBER_MODE_1000X 1 = Fiber mode (1000X)0 = SGMII mode
 *     TBI_INTERFACE    1 = ten bit interface0 = gmii interface
 *     SIGNAL_DETECT_EN 1 = signal detect from pin must be set in order to achieve synchronization. In SGMII the signal detect is always ignored regardless of the settting of this bit.0 = ignore signal detect from pin
 *     INVERT_SIGNAL_DETECT 1 = invert signal detect from pin0 = use signal detect from pin
 *     AUTODET_EN       1 = enable auto-detection (fiber and sgmii mode will switch each time a auto-negotiation page is received with the wrong selector field in bit 0.)0 = disable auto-detection (fiber or sgmii mode is set according to bit 0 of this register)
 *     SGMII_MASTER_MODE 1 = sgmii mode operates in phy mode. If autonegotiation is enabled then the local device will send out the following auto-negotiation code word:[15] = 1[14] = ack[13] = 0[12] = register 0.8[11] = register 0.6[10] = register 0.13[9:0] = "0000000001"In order to disable the link set regiser 0.11 = 1In order to enable the link set regiser 0.11 = 00 = normal operation
 *     DISABLE_PLL_PWRDWN 1 = pll will never be powered down. (use this when the mac/switch uses the pll_clk125 output)0 = pll will be powered down when register 0.11 (offset 0x0, bit 11) is set
 *     CRC_CHECKER_DISABLE 1 = disable crc checker by gating the clock to save power0 = enable crc checker
 *     COMMA_DET_EN     1 = enable comma detection0 = disable comma detection
 *     ZERO_COMMA_DETECTOR_PHASE 1 = force comma detector phase to zero0 = normal operation
 *     REMOTE_LOOPBACK  1 = enable remote loopback (operates in 10/100/1000 speed)0 = normal operation
 *     SEL_RX_PKTS_FOR_CNTR 1 = select received packets for 0x2e counter0 = select crc errors for 0x2e counter
 *     SERDES_TX_AMP_OVERRIDE 1 = use analog txCntrl Reg.0 = if sgmii mode, use analog txCntrl Reg. if fiber mode, use analog txAmp Reg.
 *     MASTER_MDIO_PHY_SEL 1 = all mdio write accesses to phy address "00000" will write this phy in addition to its own phy address.0 = normal operation
 *     DISABLE_SIGNAL_DETECT_FILTER 1 = disable filter for signal detect0 = filter signal detect from pin before using for synchronization
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_CTL1r 0x00001520

#define BCM89500_A0_SD_B1000X_CTL1r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_CTL1.
 *
 */
typedef union BCM89500_A0_SD_B1000X_CTL1r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_ctl1[1];
	uint32_t _sd_b1000x_ctl1;
} BCM89500_A0_SD_B1000X_CTL1r_t;

#define BCM89500_A0_SD_B1000X_CTL1r_CLR(r) (r).sd_b1000x_ctl1[0] = 0
#define BCM89500_A0_SD_B1000X_CTL1r_SET(r,d) (r).sd_b1000x_ctl1[0] = d
#define BCM89500_A0_SD_B1000X_CTL1r_GET(r) (r).sd_b1000x_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_CTL1r_FIBER_MODE_1000Xf_GET(r) (((r).sd_b1000x_ctl1[0]) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_FIBER_MODE_1000Xf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_B1000X_CTL1r_TBI_INTERFACEf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_TBI_INTERFACEf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_B1000X_CTL1r_SIGNAL_DETECT_ENf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_SIGNAL_DETECT_ENf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_B1000X_CTL1r_INVERT_SIGNAL_DETECTf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_INVERT_SIGNAL_DETECTf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_B1000X_CTL1r_AUTODET_ENf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_AUTODET_ENf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_B1000X_CTL1r_SGMII_MASTER_MODEf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_SGMII_MASTER_MODEf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_CTL1r_DISABLE_PLL_PWRDWNf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_DISABLE_PLL_PWRDWNf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_CTL1r_CRC_CHECKER_DISABLEf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_CRC_CHECKER_DISABLEf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_CTL1r_COMMA_DET_ENf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_COMMA_DET_ENf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_CTL1r_ZERO_COMMA_DETECTOR_PHASEf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_ZERO_COMMA_DETECTOR_PHASEf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_CTL1r_REMOTE_LOOPBACKf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_REMOTE_LOOPBACKf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_CTL1r_SEL_RX_PKTS_FOR_CNTRf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_SEL_RX_PKTS_FOR_CNTRf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_B1000X_CTL1r_SERDES_TX_AMP_OVERRIDEf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_SERDES_TX_AMP_OVERRIDEf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_B1000X_CTL1r_MASTER_MDIO_PHY_SELf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_MASTER_MDIO_PHY_SELf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_B1000X_CTL1r_DISABLE_SIGNAL_DETECT_FILTERf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_DISABLE_SIGNAL_DETECT_FILTERf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_B1000X_CTL1r_RESERVEDf_GET(r) ((((r).sd_b1000x_ctl1[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL1r_RESERVEDf_SET(r,f) (r).sd_b1000x_ctl1[0]=(((r).sd_b1000x_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_B1000X_CTL1.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_CTL1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_CTL1r,(r._sd_b1000x_ctl1),2)
#define BCM89500_A0_WRITE_SD_B1000X_CTL1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_CTL1r,&(r._sd_b1000x_ctl1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_CTL1r BCM89500_A0_SD_B1000X_CTL1r
#define SD_B1000X_CTL1r_SIZE BCM89500_A0_SD_B1000X_CTL1r_SIZE
typedef BCM89500_A0_SD_B1000X_CTL1r_t SD_B1000X_CTL1r_t;
#define SD_B1000X_CTL1r_CLR BCM89500_A0_SD_B1000X_CTL1r_CLR
#define SD_B1000X_CTL1r_SET BCM89500_A0_SD_B1000X_CTL1r_SET
#define SD_B1000X_CTL1r_GET BCM89500_A0_SD_B1000X_CTL1r_GET
#define SD_B1000X_CTL1r_FIBER_MODE_1000Xf_GET BCM89500_A0_SD_B1000X_CTL1r_FIBER_MODE_1000Xf_GET
#define SD_B1000X_CTL1r_FIBER_MODE_1000Xf_SET BCM89500_A0_SD_B1000X_CTL1r_FIBER_MODE_1000Xf_SET
#define SD_B1000X_CTL1r_TBI_INTERFACEf_GET BCM89500_A0_SD_B1000X_CTL1r_TBI_INTERFACEf_GET
#define SD_B1000X_CTL1r_TBI_INTERFACEf_SET BCM89500_A0_SD_B1000X_CTL1r_TBI_INTERFACEf_SET
#define SD_B1000X_CTL1r_SIGNAL_DETECT_ENf_GET BCM89500_A0_SD_B1000X_CTL1r_SIGNAL_DETECT_ENf_GET
#define SD_B1000X_CTL1r_SIGNAL_DETECT_ENf_SET BCM89500_A0_SD_B1000X_CTL1r_SIGNAL_DETECT_ENf_SET
#define SD_B1000X_CTL1r_INVERT_SIGNAL_DETECTf_GET BCM89500_A0_SD_B1000X_CTL1r_INVERT_SIGNAL_DETECTf_GET
#define SD_B1000X_CTL1r_INVERT_SIGNAL_DETECTf_SET BCM89500_A0_SD_B1000X_CTL1r_INVERT_SIGNAL_DETECTf_SET
#define SD_B1000X_CTL1r_AUTODET_ENf_GET BCM89500_A0_SD_B1000X_CTL1r_AUTODET_ENf_GET
#define SD_B1000X_CTL1r_AUTODET_ENf_SET BCM89500_A0_SD_B1000X_CTL1r_AUTODET_ENf_SET
#define SD_B1000X_CTL1r_SGMII_MASTER_MODEf_GET BCM89500_A0_SD_B1000X_CTL1r_SGMII_MASTER_MODEf_GET
#define SD_B1000X_CTL1r_SGMII_MASTER_MODEf_SET BCM89500_A0_SD_B1000X_CTL1r_SGMII_MASTER_MODEf_SET
#define SD_B1000X_CTL1r_DISABLE_PLL_PWRDWNf_GET BCM89500_A0_SD_B1000X_CTL1r_DISABLE_PLL_PWRDWNf_GET
#define SD_B1000X_CTL1r_DISABLE_PLL_PWRDWNf_SET BCM89500_A0_SD_B1000X_CTL1r_DISABLE_PLL_PWRDWNf_SET
#define SD_B1000X_CTL1r_CRC_CHECKER_DISABLEf_GET BCM89500_A0_SD_B1000X_CTL1r_CRC_CHECKER_DISABLEf_GET
#define SD_B1000X_CTL1r_CRC_CHECKER_DISABLEf_SET BCM89500_A0_SD_B1000X_CTL1r_CRC_CHECKER_DISABLEf_SET
#define SD_B1000X_CTL1r_COMMA_DET_ENf_GET BCM89500_A0_SD_B1000X_CTL1r_COMMA_DET_ENf_GET
#define SD_B1000X_CTL1r_COMMA_DET_ENf_SET BCM89500_A0_SD_B1000X_CTL1r_COMMA_DET_ENf_SET
#define SD_B1000X_CTL1r_ZERO_COMMA_DETECTOR_PHASEf_GET BCM89500_A0_SD_B1000X_CTL1r_ZERO_COMMA_DETECTOR_PHASEf_GET
#define SD_B1000X_CTL1r_ZERO_COMMA_DETECTOR_PHASEf_SET BCM89500_A0_SD_B1000X_CTL1r_ZERO_COMMA_DETECTOR_PHASEf_SET
#define SD_B1000X_CTL1r_REMOTE_LOOPBACKf_GET BCM89500_A0_SD_B1000X_CTL1r_REMOTE_LOOPBACKf_GET
#define SD_B1000X_CTL1r_REMOTE_LOOPBACKf_SET BCM89500_A0_SD_B1000X_CTL1r_REMOTE_LOOPBACKf_SET
#define SD_B1000X_CTL1r_SEL_RX_PKTS_FOR_CNTRf_GET BCM89500_A0_SD_B1000X_CTL1r_SEL_RX_PKTS_FOR_CNTRf_GET
#define SD_B1000X_CTL1r_SEL_RX_PKTS_FOR_CNTRf_SET BCM89500_A0_SD_B1000X_CTL1r_SEL_RX_PKTS_FOR_CNTRf_SET
#define SD_B1000X_CTL1r_SERDES_TX_AMP_OVERRIDEf_GET BCM89500_A0_SD_B1000X_CTL1r_SERDES_TX_AMP_OVERRIDEf_GET
#define SD_B1000X_CTL1r_SERDES_TX_AMP_OVERRIDEf_SET BCM89500_A0_SD_B1000X_CTL1r_SERDES_TX_AMP_OVERRIDEf_SET
#define SD_B1000X_CTL1r_MASTER_MDIO_PHY_SELf_GET BCM89500_A0_SD_B1000X_CTL1r_MASTER_MDIO_PHY_SELf_GET
#define SD_B1000X_CTL1r_MASTER_MDIO_PHY_SELf_SET BCM89500_A0_SD_B1000X_CTL1r_MASTER_MDIO_PHY_SELf_SET
#define SD_B1000X_CTL1r_DISABLE_SIGNAL_DETECT_FILTERf_GET BCM89500_A0_SD_B1000X_CTL1r_DISABLE_SIGNAL_DETECT_FILTERf_GET
#define SD_B1000X_CTL1r_DISABLE_SIGNAL_DETECT_FILTERf_SET BCM89500_A0_SD_B1000X_CTL1r_DISABLE_SIGNAL_DETECT_FILTERf_SET
#define SD_B1000X_CTL1r_RESERVEDf_GET BCM89500_A0_SD_B1000X_CTL1r_RESERVEDf_GET
#define SD_B1000X_CTL1r_RESERVEDf_SET BCM89500_A0_SD_B1000X_CTL1r_RESERVEDf_SET
#define READ_SD_B1000X_CTL1r BCM89500_A0_READ_SD_B1000X_CTL1r
#define WRITE_SD_B1000X_CTL1r BCM89500_A0_WRITE_SD_B1000X_CTL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_CTL2
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Control 2 Register
 * SIZE:     16
 * FIELDS:
 *     ENABLE_PARALLEL_DETECTION 1 = enable parallel detection. (This will turn autonegotiation on and off as needed to properly link up with the link partner. The idles and auto-negotiation code words received from the link partner are used to make this decision)0 = disable parallel detection
 *     DISABLE_FALSE_LINK 1 = do not allow link to be established when autonegotiation is disabled and receiving auto-negotiation code words. The link will only be established in this case after idles are received. (This bit does not need to be set, if bit 0 below is set.)0 = normal operation
 *     FILTER_FORCE_LINK 1 = sync-status must be set for a solid 10ms before a valid link will be established when auto-negotiation is disabled. (This is useful in fiber applications where the user does not have the signal detect pin connected to the fiber module and auto-negotiation is turned off.)0 = normal operation
 *     ENABLE_AUTONEG_ERR_TIMER 1 = enable auto-negotiation error timer. Error occurs when timer expires in ability-detect, ack-detect, or idle-detect. When the error occurs, config words of all zeros are sent until an ability match occurs, then the autoneg-enable state is entered.0 = normal operation
 *     DISABLE_REMOTE_FAULT_SENSING 1 = disable automatic sensing of remote faults, such as auto-negotiation error0 = automatically detect remote faults and send remote fault status to link partner via auto-negotiation when fiber mode is selected.(SGMII does not support remote faults)
 *     FORCE_XMIT_DATA_ON_TXSIDE 1 = allow packets to be transmitted regardless of the condition of the link or synchronization0 = normal operation
 *     AUTONEG_FAST_TIMERS 1 = speed up timers during auto-negotiation for testing0 = normal operation
 *     DISABLE_CARRIER_EXTEND 1 = disable carrier extension in pcs receive0 = normal operation
 *     DISABLE_TRRR_GENERATION 1 = disable TRRR generation in pcs transmit0 = normal operation
 *     BYPASS_PCS_RX    1 = bypass pcs receive operation0 = normal operation
 *     BYPASS_PCS_TX    1 = bypass pcs transmit operation0 = normal operation
 *     TEST_CNTR        1 = increment register offset 0x2e bits [7:0] counter each clock cycle for testing0 = normal operation
 *     TX_PKT_SEQ_TEST  1 = enable 16-stage 10-bit transmit test sequence directly to serdes transmitterStage 1-4, 13-16 = idleStage 5-12 = data packet0 = normal operation
 *     TX_IDLE_JAM_SEQ_TEST 1 = enable 16-stage 10-bit idle transmit test sequence to serdes transmitter Register offset 0x3a bits [9:0] will override k28.5 for stage 5 (17Ch) Register offset 0x3c bits [9:0] will override D16.2 for stage 6 (289h)0 = normal operation
 *     CLEAR_BER_CNTR   1 = clear bit-error-rate counter (register offset 0x2e, bits [15:8])0 = normal operationSelf-clearing
 *     DISABLE_EXTEND_FDX 1 = in full duplex mode, disable carrier extension in pcs receive when register bit [7] of this register is set and disable TRRR generation in pcs transmit when register bit [8] of this register is set0 = normal operation
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_CTL2r 0x00001522

#define BCM89500_A0_SD_B1000X_CTL2r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_CTL2.
 *
 */
typedef union BCM89500_A0_SD_B1000X_CTL2r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_ctl2[1];
	uint32_t _sd_b1000x_ctl2;
} BCM89500_A0_SD_B1000X_CTL2r_t;

#define BCM89500_A0_SD_B1000X_CTL2r_CLR(r) (r).sd_b1000x_ctl2[0] = 0
#define BCM89500_A0_SD_B1000X_CTL2r_SET(r,d) (r).sd_b1000x_ctl2[0] = d
#define BCM89500_A0_SD_B1000X_CTL2r_GET(r) (r).sd_b1000x_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_CTL2r_ENABLE_PARALLEL_DETECTIONf_GET(r) (((r).sd_b1000x_ctl2[0]) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_ENABLE_PARALLEL_DETECTIONf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_FALSE_LINKf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_FALSE_LINKf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_B1000X_CTL2r_FILTER_FORCE_LINKf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_FILTER_FORCE_LINKf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_B1000X_CTL2r_ENABLE_AUTONEG_ERR_TIMERf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_ENABLE_AUTONEG_ERR_TIMERf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_REMOTE_FAULT_SENSINGf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_REMOTE_FAULT_SENSINGf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_B1000X_CTL2r_FORCE_XMIT_DATA_ON_TXSIDEf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_FORCE_XMIT_DATA_ON_TXSIDEf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_CTL2r_AUTONEG_FAST_TIMERSf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_AUTONEG_FAST_TIMERSf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_CARRIER_EXTENDf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_CARRIER_EXTENDf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_TRRR_GENERATIONf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_TRRR_GENERATIONf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_RXf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_RXf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_TXf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_TXf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_CTL2r_TEST_CNTRf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_TEST_CNTRf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_B1000X_CTL2r_TX_PKT_SEQ_TESTf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_TX_PKT_SEQ_TESTf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_B1000X_CTL2r_TX_IDLE_JAM_SEQ_TESTf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_TX_IDLE_JAM_SEQ_TESTf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_B1000X_CTL2r_CLEAR_BER_CNTRf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_CLEAR_BER_CNTRf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_EXTEND_FDXf_GET(r) ((((r).sd_b1000x_ctl2[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL2r_DISABLE_EXTEND_FDXf_SET(r,f) (r).sd_b1000x_ctl2[0]=(((r).sd_b1000x_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_B1000X_CTL2.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_CTL2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_CTL2r,(r._sd_b1000x_ctl2),2)
#define BCM89500_A0_WRITE_SD_B1000X_CTL2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_CTL2r,&(r._sd_b1000x_ctl2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_CTL2r BCM89500_A0_SD_B1000X_CTL2r
#define SD_B1000X_CTL2r_SIZE BCM89500_A0_SD_B1000X_CTL2r_SIZE
typedef BCM89500_A0_SD_B1000X_CTL2r_t SD_B1000X_CTL2r_t;
#define SD_B1000X_CTL2r_CLR BCM89500_A0_SD_B1000X_CTL2r_CLR
#define SD_B1000X_CTL2r_SET BCM89500_A0_SD_B1000X_CTL2r_SET
#define SD_B1000X_CTL2r_GET BCM89500_A0_SD_B1000X_CTL2r_GET
#define SD_B1000X_CTL2r_ENABLE_PARALLEL_DETECTIONf_GET BCM89500_A0_SD_B1000X_CTL2r_ENABLE_PARALLEL_DETECTIONf_GET
#define SD_B1000X_CTL2r_ENABLE_PARALLEL_DETECTIONf_SET BCM89500_A0_SD_B1000X_CTL2r_ENABLE_PARALLEL_DETECTIONf_SET
#define SD_B1000X_CTL2r_DISABLE_FALSE_LINKf_GET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_FALSE_LINKf_GET
#define SD_B1000X_CTL2r_DISABLE_FALSE_LINKf_SET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_FALSE_LINKf_SET
#define SD_B1000X_CTL2r_FILTER_FORCE_LINKf_GET BCM89500_A0_SD_B1000X_CTL2r_FILTER_FORCE_LINKf_GET
#define SD_B1000X_CTL2r_FILTER_FORCE_LINKf_SET BCM89500_A0_SD_B1000X_CTL2r_FILTER_FORCE_LINKf_SET
#define SD_B1000X_CTL2r_ENABLE_AUTONEG_ERR_TIMERf_GET BCM89500_A0_SD_B1000X_CTL2r_ENABLE_AUTONEG_ERR_TIMERf_GET
#define SD_B1000X_CTL2r_ENABLE_AUTONEG_ERR_TIMERf_SET BCM89500_A0_SD_B1000X_CTL2r_ENABLE_AUTONEG_ERR_TIMERf_SET
#define SD_B1000X_CTL2r_DISABLE_REMOTE_FAULT_SENSINGf_GET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_REMOTE_FAULT_SENSINGf_GET
#define SD_B1000X_CTL2r_DISABLE_REMOTE_FAULT_SENSINGf_SET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_REMOTE_FAULT_SENSINGf_SET
#define SD_B1000X_CTL2r_FORCE_XMIT_DATA_ON_TXSIDEf_GET BCM89500_A0_SD_B1000X_CTL2r_FORCE_XMIT_DATA_ON_TXSIDEf_GET
#define SD_B1000X_CTL2r_FORCE_XMIT_DATA_ON_TXSIDEf_SET BCM89500_A0_SD_B1000X_CTL2r_FORCE_XMIT_DATA_ON_TXSIDEf_SET
#define SD_B1000X_CTL2r_AUTONEG_FAST_TIMERSf_GET BCM89500_A0_SD_B1000X_CTL2r_AUTONEG_FAST_TIMERSf_GET
#define SD_B1000X_CTL2r_AUTONEG_FAST_TIMERSf_SET BCM89500_A0_SD_B1000X_CTL2r_AUTONEG_FAST_TIMERSf_SET
#define SD_B1000X_CTL2r_DISABLE_CARRIER_EXTENDf_GET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_CARRIER_EXTENDf_GET
#define SD_B1000X_CTL2r_DISABLE_CARRIER_EXTENDf_SET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_CARRIER_EXTENDf_SET
#define SD_B1000X_CTL2r_DISABLE_TRRR_GENERATIONf_GET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_TRRR_GENERATIONf_GET
#define SD_B1000X_CTL2r_DISABLE_TRRR_GENERATIONf_SET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_TRRR_GENERATIONf_SET
#define SD_B1000X_CTL2r_BYPASS_PCS_RXf_GET BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_RXf_GET
#define SD_B1000X_CTL2r_BYPASS_PCS_RXf_SET BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_RXf_SET
#define SD_B1000X_CTL2r_BYPASS_PCS_TXf_GET BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_TXf_GET
#define SD_B1000X_CTL2r_BYPASS_PCS_TXf_SET BCM89500_A0_SD_B1000X_CTL2r_BYPASS_PCS_TXf_SET
#define SD_B1000X_CTL2r_TEST_CNTRf_GET BCM89500_A0_SD_B1000X_CTL2r_TEST_CNTRf_GET
#define SD_B1000X_CTL2r_TEST_CNTRf_SET BCM89500_A0_SD_B1000X_CTL2r_TEST_CNTRf_SET
#define SD_B1000X_CTL2r_TX_PKT_SEQ_TESTf_GET BCM89500_A0_SD_B1000X_CTL2r_TX_PKT_SEQ_TESTf_GET
#define SD_B1000X_CTL2r_TX_PKT_SEQ_TESTf_SET BCM89500_A0_SD_B1000X_CTL2r_TX_PKT_SEQ_TESTf_SET
#define SD_B1000X_CTL2r_TX_IDLE_JAM_SEQ_TESTf_GET BCM89500_A0_SD_B1000X_CTL2r_TX_IDLE_JAM_SEQ_TESTf_GET
#define SD_B1000X_CTL2r_TX_IDLE_JAM_SEQ_TESTf_SET BCM89500_A0_SD_B1000X_CTL2r_TX_IDLE_JAM_SEQ_TESTf_SET
#define SD_B1000X_CTL2r_CLEAR_BER_CNTRf_GET BCM89500_A0_SD_B1000X_CTL2r_CLEAR_BER_CNTRf_GET
#define SD_B1000X_CTL2r_CLEAR_BER_CNTRf_SET BCM89500_A0_SD_B1000X_CTL2r_CLEAR_BER_CNTRf_SET
#define SD_B1000X_CTL2r_DISABLE_EXTEND_FDXf_GET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_EXTEND_FDXf_GET
#define SD_B1000X_CTL2r_DISABLE_EXTEND_FDXf_SET BCM89500_A0_SD_B1000X_CTL2r_DISABLE_EXTEND_FDXf_SET
#define READ_SD_B1000X_CTL2r BCM89500_A0_READ_SD_B1000X_CTL2r
#define WRITE_SD_B1000X_CTL2r BCM89500_A0_WRITE_SD_B1000X_CTL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_CTL3
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Control 3 Register
 * SIZE:     16
 * FIELDS:
 *     TX_FIFO_RST      1 = reset transmit fifo. Fifo will remain in reset until this bit is cleared with a software write.0 = normal operation
 *     FIFO_ELASICITY_TX_RX 00 = supports packets up to 5k bytes01 = supports packets up to 10k bytes1X = supports packets up to 13.5k bytes
 *     EARLY_PREAMBLE_TX 1 = send extra bytes of preamble to avoid fifo latency. (Used in half-duplex applications to reduce collision domain latency. MAC must send 5 bytes of preamble or less to avoid non-compliant behavior.)0 = normal operation
 *     EARLY_PREAMBLE_RX 1 = send extra bytes of preamble to avoid fifo latency. (Not necessary if MAC uses crs to determine collision)0 = normal operation
 *     FREQ_LOCK_ELASTICITY_RX 1 = minimum fifo latency to properly handle a clock which is frequency lockeSD_B1000X_CTL4d, but out of phase. (Not necessary if MAC uses crs to determine collision; overrides bits [2:1] of this register)NOTE: MAC and phy must be using the same crystal for this mode to be enabled.0 = normal operation
 *     FREQ_LOCK_ELASTICITY_TX 1 = minimum fifo latency to properly handle a clock which is frequency locked, but out of phase. (overrides bits [2:1] of this register)NOTE: pll_clk125 and clk_in must be using the same crystal.0 = normal operation
 *     BYPASS_TXFIFO1000 1 = bypass transmit fifo in gigabit mode. (Useful for fiber or gigabit only applications where the MAC is using the pll_clk125 as the clk_in port. User must meet timing to the pll_clk125 domain)0 = normal operation
 *     FORCE_TXFIFO_ON  1 = force transmit fifo to free-run in gigabit mode (Requires clk_in and pll_clk125 to be frequency locked.)0 = normal operation
 *     BLOCK_TXEN_MODE  1 = block txen when necessary to guarantee an ipg of at least 6.5 bytes in 10/100 mode, 7 bytes in 1000 mode.0 = normal operation
 *     JAM_FALSE_CARRIER_MODE 1 = change false carriers received into packets with preamble only. (Not necessary if MAC uses crs to determine collision)0 = normal operation
 *     EXT_PHY_CRS_MODE 1 = use external pin for the phy's "receive only" crs output. (Useful in sgmii 10/100 half-duplex applications in order to reduce the collision domain latency. Requires a phy which generates a "receive only" crs output to a pin.)0 = normal operation
 *     INVERT_EXT_PHY_CRS 1 = invert "receive crs from phy" pin0 = use "receive crs from phy" pin
 *     DISABLE_TX_CRS   1 = disable generating crs from transmitting in halfduplex mode. Only receiving will generate crs.0 = normal operation
 *     RXFIFO_GMII_RST  1 = reset receive fifo and data_out_1000. Fifo will remain in reset until this bit is cleared with a software write.0 = normal operation
 *     DISABLE_PKT_MISALIGN 1 = disable packet misalignment by carrier extend and removing preamble0 = normal operation
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_CTL3r 0x00001524

#define BCM89500_A0_SD_B1000X_CTL3r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_CTL3.
 *
 */
typedef union BCM89500_A0_SD_B1000X_CTL3r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_ctl3[1];
	uint32_t _sd_b1000x_ctl3;
} BCM89500_A0_SD_B1000X_CTL3r_t;

#define BCM89500_A0_SD_B1000X_CTL3r_CLR(r) (r).sd_b1000x_ctl3[0] = 0
#define BCM89500_A0_SD_B1000X_CTL3r_SET(r,d) (r).sd_b1000x_ctl3[0] = d
#define BCM89500_A0_SD_B1000X_CTL3r_GET(r) (r).sd_b1000x_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_CTL3r_TX_FIFO_RSTf_GET(r) (((r).sd_b1000x_ctl3[0]) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_TX_FIFO_RSTf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_B1000X_CTL3r_FIFO_ELASICITY_TX_RXf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 1) & 0x3)
#define BCM89500_A0_SD_B1000X_CTL3r_FIFO_ELASICITY_TX_RXf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_TXf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_TXf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_RXf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_RXf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_RXf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_RXf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_TXf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_TXf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_CTL3r_BYPASS_TXFIFO1000f_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_BYPASS_TXFIFO1000f_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_CTL3r_FORCE_TXFIFO_ONf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_FORCE_TXFIFO_ONf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_CTL3r_BLOCK_TXEN_MODEf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_BLOCK_TXEN_MODEf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_CTL3r_JAM_FALSE_CARRIER_MODEf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_JAM_FALSE_CARRIER_MODEf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_CTL3r_EXT_PHY_CRS_MODEf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_EXT_PHY_CRS_MODEf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_B1000X_CTL3r_INVERT_EXT_PHY_CRSf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_INVERT_EXT_PHY_CRSf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_B1000X_CTL3r_DISABLE_TX_CRSf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_DISABLE_TX_CRSf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_B1000X_CTL3r_RXFIFO_GMII_RSTf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_RXFIFO_GMII_RSTf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_B1000X_CTL3r_DISABLE_PKT_MISALIGNf_GET(r) ((((r).sd_b1000x_ctl3[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL3r_DISABLE_PKT_MISALIGNf_SET(r,f) (r).sd_b1000x_ctl3[0]=(((r).sd_b1000x_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_B1000X_CTL3.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_CTL3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_CTL3r,(r._sd_b1000x_ctl3),2)
#define BCM89500_A0_WRITE_SD_B1000X_CTL3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_CTL3r,&(r._sd_b1000x_ctl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_CTL3r BCM89500_A0_SD_B1000X_CTL3r
#define SD_B1000X_CTL3r_SIZE BCM89500_A0_SD_B1000X_CTL3r_SIZE
typedef BCM89500_A0_SD_B1000X_CTL3r_t SD_B1000X_CTL3r_t;
#define SD_B1000X_CTL3r_CLR BCM89500_A0_SD_B1000X_CTL3r_CLR
#define SD_B1000X_CTL3r_SET BCM89500_A0_SD_B1000X_CTL3r_SET
#define SD_B1000X_CTL3r_GET BCM89500_A0_SD_B1000X_CTL3r_GET
#define SD_B1000X_CTL3r_TX_FIFO_RSTf_GET BCM89500_A0_SD_B1000X_CTL3r_TX_FIFO_RSTf_GET
#define SD_B1000X_CTL3r_TX_FIFO_RSTf_SET BCM89500_A0_SD_B1000X_CTL3r_TX_FIFO_RSTf_SET
#define SD_B1000X_CTL3r_FIFO_ELASICITY_TX_RXf_GET BCM89500_A0_SD_B1000X_CTL3r_FIFO_ELASICITY_TX_RXf_GET
#define SD_B1000X_CTL3r_FIFO_ELASICITY_TX_RXf_SET BCM89500_A0_SD_B1000X_CTL3r_FIFO_ELASICITY_TX_RXf_SET
#define SD_B1000X_CTL3r_EARLY_PREAMBLE_TXf_GET BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_TXf_GET
#define SD_B1000X_CTL3r_EARLY_PREAMBLE_TXf_SET BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_TXf_SET
#define SD_B1000X_CTL3r_EARLY_PREAMBLE_RXf_GET BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_RXf_GET
#define SD_B1000X_CTL3r_EARLY_PREAMBLE_RXf_SET BCM89500_A0_SD_B1000X_CTL3r_EARLY_PREAMBLE_RXf_SET
#define SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_RXf_GET BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_RXf_GET
#define SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_RXf_SET BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_RXf_SET
#define SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_TXf_GET BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_TXf_GET
#define SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_TXf_SET BCM89500_A0_SD_B1000X_CTL3r_FREQ_LOCK_ELASTICITY_TXf_SET
#define SD_B1000X_CTL3r_BYPASS_TXFIFO1000f_GET BCM89500_A0_SD_B1000X_CTL3r_BYPASS_TXFIFO1000f_GET
#define SD_B1000X_CTL3r_BYPASS_TXFIFO1000f_SET BCM89500_A0_SD_B1000X_CTL3r_BYPASS_TXFIFO1000f_SET
#define SD_B1000X_CTL3r_FORCE_TXFIFO_ONf_GET BCM89500_A0_SD_B1000X_CTL3r_FORCE_TXFIFO_ONf_GET
#define SD_B1000X_CTL3r_FORCE_TXFIFO_ONf_SET BCM89500_A0_SD_B1000X_CTL3r_FORCE_TXFIFO_ONf_SET
#define SD_B1000X_CTL3r_BLOCK_TXEN_MODEf_GET BCM89500_A0_SD_B1000X_CTL3r_BLOCK_TXEN_MODEf_GET
#define SD_B1000X_CTL3r_BLOCK_TXEN_MODEf_SET BCM89500_A0_SD_B1000X_CTL3r_BLOCK_TXEN_MODEf_SET
#define SD_B1000X_CTL3r_JAM_FALSE_CARRIER_MODEf_GET BCM89500_A0_SD_B1000X_CTL3r_JAM_FALSE_CARRIER_MODEf_GET
#define SD_B1000X_CTL3r_JAM_FALSE_CARRIER_MODEf_SET BCM89500_A0_SD_B1000X_CTL3r_JAM_FALSE_CARRIER_MODEf_SET
#define SD_B1000X_CTL3r_EXT_PHY_CRS_MODEf_GET BCM89500_A0_SD_B1000X_CTL3r_EXT_PHY_CRS_MODEf_GET
#define SD_B1000X_CTL3r_EXT_PHY_CRS_MODEf_SET BCM89500_A0_SD_B1000X_CTL3r_EXT_PHY_CRS_MODEf_SET
#define SD_B1000X_CTL3r_INVERT_EXT_PHY_CRSf_GET BCM89500_A0_SD_B1000X_CTL3r_INVERT_EXT_PHY_CRSf_GET
#define SD_B1000X_CTL3r_INVERT_EXT_PHY_CRSf_SET BCM89500_A0_SD_B1000X_CTL3r_INVERT_EXT_PHY_CRSf_SET
#define SD_B1000X_CTL3r_DISABLE_TX_CRSf_GET BCM89500_A0_SD_B1000X_CTL3r_DISABLE_TX_CRSf_GET
#define SD_B1000X_CTL3r_DISABLE_TX_CRSf_SET BCM89500_A0_SD_B1000X_CTL3r_DISABLE_TX_CRSf_SET
#define SD_B1000X_CTL3r_RXFIFO_GMII_RSTf_GET BCM89500_A0_SD_B1000X_CTL3r_RXFIFO_GMII_RSTf_GET
#define SD_B1000X_CTL3r_RXFIFO_GMII_RSTf_SET BCM89500_A0_SD_B1000X_CTL3r_RXFIFO_GMII_RSTf_SET
#define SD_B1000X_CTL3r_DISABLE_PKT_MISALIGNf_GET BCM89500_A0_SD_B1000X_CTL3r_DISABLE_PKT_MISALIGNf_GET
#define SD_B1000X_CTL3r_DISABLE_PKT_MISALIGNf_SET BCM89500_A0_SD_B1000X_CTL3r_DISABLE_PKT_MISALIGNf_SET
#define READ_SD_B1000X_CTL3r BCM89500_A0_READ_SD_B1000X_CTL3r
#define WRITE_SD_B1000X_CTL3r BCM89500_A0_WRITE_SD_B1000X_CTL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_CTL4
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Control 4 Register
 * SIZE:     16
 * FIELDS:
 *     ENABLE_ANA_SIGNAL_DETECT 1 = Use analog signal detect0 = Override analog signal detect status with bit [1] of this register
 *     ANA_SIGDET_OVERRIDE Analog signal detect status bit override value
 *     ENABLE_DIG_PLL_LOCK_OVERRIDE 1 = Use pll lock status bit from analog directly in digital logic0 = Override pll lock status bit with bit [3] of this register
 *     DIG_PLL_LOCK_OVERRIDE pll lock status bit override value; used in digital logic only
 *     ENABLE_ANA_PLL_LOCK_OVERRIDE 1 = Use pll lock status bit from analog directly in analog reset logic0 = Override pll lock status bit with bit [5] of this register
 *     ANA_PLL_LOCK_OVERRIDE pll lock status bit override value; used in analog reset logic only
 *     DIG_RESET        1 = resets digital logic datapath, MII registers are not in reset state0 = normal operation
 *     LINK_FORCE       1 = force link on0 = normal operation
 *     ENABLE_LATCH_LINKDOWN 1 = enable latching of link when link is down. Transmit fifo, receive fifo and data_out_1000 to remain in reset state until bit[9] of this register is 10 = normal operation
 *     CLEAR_LINKDOWN   1 = clear latching of link down. latch_linkdown status bit is register offset 0x2c bit[10] enable_latch_linkdown control bit is bit[8] of this register0 = normal operationSelf-clearing
 *     ZERO_DATA_OUT_1000 1 = zero data_out_1000 when speed is not 1000 Mb/s0 = normal operation
 *     MII_RXC_IN_ENABLE 1 = use mii_rxc_in as the read clock SGMII 10/100 rxfifo0 = use internal generated clock (mii_rxc_out) as the read clock for SGMII 10/100 rxfifo
 *     MII_RXC_SPD_FIXED_LATCH_LINKDOWN 1 = mii_rxc_out clock speed is fixed during latch_linkdown. mii_rxc_out clock speed is allowed to change when latch_linkdown is inactive or when pwrdwn is asserted. latch_linkdown status bit is register 0*16h bit[10] pwrdwn bit si register 0 bit[11] enable_latch_linkdown control bit is bit[8] of this register0 = mii_rxc_out clock speed changes with the speed of Serdes
 *     MII_RXC_SPEED_CHG_PWRDWN 1 = mii_rxc_out clock speed is allowed to change when pwrdwn is asserted. pwrdwn bit is register 0 bit[11]0 = mii_rxc_out clock speed changes with the speed of Serdes when bit[11] of this register is unset or when bit[11] of this register is set and Serdes is in fxmode
 *     SERDES_TX_DIS    1 = force all serdes transmit data to 00 = normal operation
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_CTL4r 0x00001526

#define BCM89500_A0_SD_B1000X_CTL4r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_CTL4.
 *
 */
typedef union BCM89500_A0_SD_B1000X_CTL4r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_ctl4[1];
	uint32_t _sd_b1000x_ctl4;
} BCM89500_A0_SD_B1000X_CTL4r_t;

#define BCM89500_A0_SD_B1000X_CTL4r_CLR(r) (r).sd_b1000x_ctl4[0] = 0
#define BCM89500_A0_SD_B1000X_CTL4r_SET(r,d) (r).sd_b1000x_ctl4[0] = d
#define BCM89500_A0_SD_B1000X_CTL4r_GET(r) (r).sd_b1000x_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_SIGNAL_DETECTf_GET(r) (((r).sd_b1000x_ctl4[0]) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_SIGNAL_DETECTf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_B1000X_CTL4r_ANA_SIGDET_OVERRIDEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ANA_SIGDET_OVERRIDEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_DIG_PLL_LOCK_OVERRIDEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_DIG_PLL_LOCK_OVERRIDEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_B1000X_CTL4r_DIG_PLL_LOCK_OVERRIDEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_DIG_PLL_LOCK_OVERRIDEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_PLL_LOCK_OVERRIDEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_PLL_LOCK_OVERRIDEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_B1000X_CTL4r_ANA_PLL_LOCK_OVERRIDEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ANA_PLL_LOCK_OVERRIDEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_CTL4r_DIG_RESETf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_DIG_RESETf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_CTL4r_LINK_FORCEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_LINK_FORCEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_LATCH_LINKDOWNf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ENABLE_LATCH_LINKDOWNf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_CTL4r_CLEAR_LINKDOWNf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_CLEAR_LINKDOWNf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_CTL4r_ZERO_DATA_OUT_1000f_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_ZERO_DATA_OUT_1000f_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_IN_ENABLEf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_IN_ENABLEf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPD_FIXED_LATCH_LINKDOWNf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPD_FIXED_LATCH_LINKDOWNf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPEED_CHG_PWRDWNf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPEED_CHG_PWRDWNf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_B1000X_CTL4r_SERDES_TX_DISf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_SERDES_TX_DISf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_B1000X_CTL4r_RESERVEDf_GET(r) ((((r).sd_b1000x_ctl4[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_B1000X_CTL4r_RESERVEDf_SET(r,f) (r).sd_b1000x_ctl4[0]=(((r).sd_b1000x_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_B1000X_CTL4.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_CTL4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_CTL4r,(r._sd_b1000x_ctl4),2)
#define BCM89500_A0_WRITE_SD_B1000X_CTL4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_CTL4r,&(r._sd_b1000x_ctl4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_CTL4r BCM89500_A0_SD_B1000X_CTL4r
#define SD_B1000X_CTL4r_SIZE BCM89500_A0_SD_B1000X_CTL4r_SIZE
typedef BCM89500_A0_SD_B1000X_CTL4r_t SD_B1000X_CTL4r_t;
#define SD_B1000X_CTL4r_CLR BCM89500_A0_SD_B1000X_CTL4r_CLR
#define SD_B1000X_CTL4r_SET BCM89500_A0_SD_B1000X_CTL4r_SET
#define SD_B1000X_CTL4r_GET BCM89500_A0_SD_B1000X_CTL4r_GET
#define SD_B1000X_CTL4r_ENABLE_ANA_SIGNAL_DETECTf_GET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_SIGNAL_DETECTf_GET
#define SD_B1000X_CTL4r_ENABLE_ANA_SIGNAL_DETECTf_SET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_SIGNAL_DETECTf_SET
#define SD_B1000X_CTL4r_ANA_SIGDET_OVERRIDEf_GET BCM89500_A0_SD_B1000X_CTL4r_ANA_SIGDET_OVERRIDEf_GET
#define SD_B1000X_CTL4r_ANA_SIGDET_OVERRIDEf_SET BCM89500_A0_SD_B1000X_CTL4r_ANA_SIGDET_OVERRIDEf_SET
#define SD_B1000X_CTL4r_ENABLE_DIG_PLL_LOCK_OVERRIDEf_GET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_DIG_PLL_LOCK_OVERRIDEf_GET
#define SD_B1000X_CTL4r_ENABLE_DIG_PLL_LOCK_OVERRIDEf_SET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_DIG_PLL_LOCK_OVERRIDEf_SET
#define SD_B1000X_CTL4r_DIG_PLL_LOCK_OVERRIDEf_GET BCM89500_A0_SD_B1000X_CTL4r_DIG_PLL_LOCK_OVERRIDEf_GET
#define SD_B1000X_CTL4r_DIG_PLL_LOCK_OVERRIDEf_SET BCM89500_A0_SD_B1000X_CTL4r_DIG_PLL_LOCK_OVERRIDEf_SET
#define SD_B1000X_CTL4r_ENABLE_ANA_PLL_LOCK_OVERRIDEf_GET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_PLL_LOCK_OVERRIDEf_GET
#define SD_B1000X_CTL4r_ENABLE_ANA_PLL_LOCK_OVERRIDEf_SET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_ANA_PLL_LOCK_OVERRIDEf_SET
#define SD_B1000X_CTL4r_ANA_PLL_LOCK_OVERRIDEf_GET BCM89500_A0_SD_B1000X_CTL4r_ANA_PLL_LOCK_OVERRIDEf_GET
#define SD_B1000X_CTL4r_ANA_PLL_LOCK_OVERRIDEf_SET BCM89500_A0_SD_B1000X_CTL4r_ANA_PLL_LOCK_OVERRIDEf_SET
#define SD_B1000X_CTL4r_DIG_RESETf_GET BCM89500_A0_SD_B1000X_CTL4r_DIG_RESETf_GET
#define SD_B1000X_CTL4r_DIG_RESETf_SET BCM89500_A0_SD_B1000X_CTL4r_DIG_RESETf_SET
#define SD_B1000X_CTL4r_LINK_FORCEf_GET BCM89500_A0_SD_B1000X_CTL4r_LINK_FORCEf_GET
#define SD_B1000X_CTL4r_LINK_FORCEf_SET BCM89500_A0_SD_B1000X_CTL4r_LINK_FORCEf_SET
#define SD_B1000X_CTL4r_ENABLE_LATCH_LINKDOWNf_GET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_LATCH_LINKDOWNf_GET
#define SD_B1000X_CTL4r_ENABLE_LATCH_LINKDOWNf_SET BCM89500_A0_SD_B1000X_CTL4r_ENABLE_LATCH_LINKDOWNf_SET
#define SD_B1000X_CTL4r_CLEAR_LINKDOWNf_GET BCM89500_A0_SD_B1000X_CTL4r_CLEAR_LINKDOWNf_GET
#define SD_B1000X_CTL4r_CLEAR_LINKDOWNf_SET BCM89500_A0_SD_B1000X_CTL4r_CLEAR_LINKDOWNf_SET
#define SD_B1000X_CTL4r_ZERO_DATA_OUT_1000f_GET BCM89500_A0_SD_B1000X_CTL4r_ZERO_DATA_OUT_1000f_GET
#define SD_B1000X_CTL4r_ZERO_DATA_OUT_1000f_SET BCM89500_A0_SD_B1000X_CTL4r_ZERO_DATA_OUT_1000f_SET
#define SD_B1000X_CTL4r_MII_RXC_IN_ENABLEf_GET BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_IN_ENABLEf_GET
#define SD_B1000X_CTL4r_MII_RXC_IN_ENABLEf_SET BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_IN_ENABLEf_SET
#define SD_B1000X_CTL4r_MII_RXC_SPD_FIXED_LATCH_LINKDOWNf_GET BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPD_FIXED_LATCH_LINKDOWNf_GET
#define SD_B1000X_CTL4r_MII_RXC_SPD_FIXED_LATCH_LINKDOWNf_SET BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPD_FIXED_LATCH_LINKDOWNf_SET
#define SD_B1000X_CTL4r_MII_RXC_SPEED_CHG_PWRDWNf_GET BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPEED_CHG_PWRDWNf_GET
#define SD_B1000X_CTL4r_MII_RXC_SPEED_CHG_PWRDWNf_SET BCM89500_A0_SD_B1000X_CTL4r_MII_RXC_SPEED_CHG_PWRDWNf_SET
#define SD_B1000X_CTL4r_SERDES_TX_DISf_GET BCM89500_A0_SD_B1000X_CTL4r_SERDES_TX_DISf_GET
#define SD_B1000X_CTL4r_SERDES_TX_DISf_SET BCM89500_A0_SD_B1000X_CTL4r_SERDES_TX_DISf_SET
#define SD_B1000X_CTL4r_RESERVEDf_GET BCM89500_A0_SD_B1000X_CTL4r_RESERVEDf_GET
#define SD_B1000X_CTL4r_RESERVEDf_SET BCM89500_A0_SD_B1000X_CTL4r_RESERVEDf_SET
#define READ_SD_B1000X_CTL4r BCM89500_A0_READ_SD_B1000X_CTL4r
#define WRITE_SD_B1000X_CTL4r BCM89500_A0_WRITE_SD_B1000X_CTL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_STS1
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Status 1 Register
 * SIZE:     16
 * FIELDS:
 *     SGMII_MODE       1 = sgmii mode0 = fiber mode (1000-X)
 *     LINK_STATUS      1 = link is up0 = link is downNote: When the ten bit interface is selected with fiber mode (1000-X), then link will always be down reported.
 *     DUPLEX_STATUS    1 = full-duplex0 = half-duplexNote: When the ten bit interface is selected with fiber mode (1000-X), then half-duplex will always be reported.
 *     SPEED_STATUS     1X = gigabit01 = 100 mbps00 = 10 mbps
 *     PAUSE_RESOLUTION_TXSIDE 1 = enable pause transmit0 = disable pause transmit
 *     PAUSE_RESOLUTION_RXSIDE 1 = enable pause receive0 = disable pause receive
 *     LINK_STATUS_CHG  1 = link status has changed since last read0 = link status has not changed since last read
 *     EARLY_END_EXTENSION_DETECTED 1 = early end extension since last read (early_end_ext in pcs receive fsm)0 = no early end extension since last read
 *     CARRIER_EXTEND_ERR_DETECTED 1 = carrier extend error since last read (extend_err in pcs receive fsm)0 = no carrier extend error since last read
 *     RX_ERR_DETECTED  1 = receive error since last read (early_end state in pcs receive fsm)0 = no receive error since last read
 *     TX_ERR_DETECTED  1 = transmit error code detected since last read (rx_data_error state in pcs receive fsm)0 = no transmit error code detected since last read
 *     CRC_ERR_DETECTED 1 = crc error detected since last read0 = no crc error detected since last read or detection is disabled via register offset 0x20 bit [7]
 *     FALSE_CARRIER_DETECTED 1 = false carrier detected since last read0 = no false carrier detected since last read
 *     RXFIFO_ERR_DETECTED 1 = receive fifo error detected since last read0 = no receive fifo error detected since last read
 *     TXFIFO_ERR_DETECTED 1 = transmit fifo error detected since last read0 = no transmit fifo error detected since last read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_STS1r 0x00001528

#define BCM89500_A0_SD_B1000X_STS1r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_STS1.
 *
 */
typedef union BCM89500_A0_SD_B1000X_STS1r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_sts1[1];
	uint32_t _sd_b1000x_sts1;
} BCM89500_A0_SD_B1000X_STS1r_t;

#define BCM89500_A0_SD_B1000X_STS1r_CLR(r) (r).sd_b1000x_sts1[0] = 0
#define BCM89500_A0_SD_B1000X_STS1r_SET(r,d) (r).sd_b1000x_sts1[0] = d
#define BCM89500_A0_SD_B1000X_STS1r_GET(r) (r).sd_b1000x_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_STS1r_SGMII_MODEf_GET(r) (((r).sd_b1000x_sts1[0]) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_SGMII_MODEf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_B1000X_STS1r_LINK_STATUSf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_LINK_STATUSf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_B1000X_STS1r_DUPLEX_STATUSf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_DUPLEX_STATUSf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_B1000X_STS1r_SPEED_STATUSf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 3) & 0x3)
#define BCM89500_A0_SD_B1000X_STS1r_SPEED_STATUSf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_TXSIDEf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_TXSIDEf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_RXSIDEf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_RXSIDEf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_STS1r_LINK_STATUS_CHGf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_LINK_STATUS_CHGf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_STS1r_EARLY_END_EXTENSION_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_EARLY_END_EXTENSION_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_STS1r_CARRIER_EXTEND_ERR_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_CARRIER_EXTEND_ERR_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_STS1r_RX_ERR_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_RX_ERR_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_STS1r_TX_ERR_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_TX_ERR_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_B1000X_STS1r_CRC_ERR_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_CRC_ERR_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_B1000X_STS1r_FALSE_CARRIER_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_FALSE_CARRIER_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_B1000X_STS1r_RXFIFO_ERR_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_RXFIFO_ERR_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_B1000X_STS1r_TXFIFO_ERR_DETECTEDf_GET(r) ((((r).sd_b1000x_sts1[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_B1000X_STS1r_TXFIFO_ERR_DETECTEDf_SET(r,f) (r).sd_b1000x_sts1[0]=(((r).sd_b1000x_sts1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_B1000X_STS1.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_STS1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_STS1r,(r._sd_b1000x_sts1),2)
#define BCM89500_A0_WRITE_SD_B1000X_STS1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_STS1r,&(r._sd_b1000x_sts1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_STS1r BCM89500_A0_SD_B1000X_STS1r
#define SD_B1000X_STS1r_SIZE BCM89500_A0_SD_B1000X_STS1r_SIZE
typedef BCM89500_A0_SD_B1000X_STS1r_t SD_B1000X_STS1r_t;
#define SD_B1000X_STS1r_CLR BCM89500_A0_SD_B1000X_STS1r_CLR
#define SD_B1000X_STS1r_SET BCM89500_A0_SD_B1000X_STS1r_SET
#define SD_B1000X_STS1r_GET BCM89500_A0_SD_B1000X_STS1r_GET
#define SD_B1000X_STS1r_SGMII_MODEf_GET BCM89500_A0_SD_B1000X_STS1r_SGMII_MODEf_GET
#define SD_B1000X_STS1r_SGMII_MODEf_SET BCM89500_A0_SD_B1000X_STS1r_SGMII_MODEf_SET
#define SD_B1000X_STS1r_LINK_STATUSf_GET BCM89500_A0_SD_B1000X_STS1r_LINK_STATUSf_GET
#define SD_B1000X_STS1r_LINK_STATUSf_SET BCM89500_A0_SD_B1000X_STS1r_LINK_STATUSf_SET
#define SD_B1000X_STS1r_DUPLEX_STATUSf_GET BCM89500_A0_SD_B1000X_STS1r_DUPLEX_STATUSf_GET
#define SD_B1000X_STS1r_DUPLEX_STATUSf_SET BCM89500_A0_SD_B1000X_STS1r_DUPLEX_STATUSf_SET
#define SD_B1000X_STS1r_SPEED_STATUSf_GET BCM89500_A0_SD_B1000X_STS1r_SPEED_STATUSf_GET
#define SD_B1000X_STS1r_SPEED_STATUSf_SET BCM89500_A0_SD_B1000X_STS1r_SPEED_STATUSf_SET
#define SD_B1000X_STS1r_PAUSE_RESOLUTION_TXSIDEf_GET BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_TXSIDEf_GET
#define SD_B1000X_STS1r_PAUSE_RESOLUTION_TXSIDEf_SET BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_TXSIDEf_SET
#define SD_B1000X_STS1r_PAUSE_RESOLUTION_RXSIDEf_GET BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_RXSIDEf_GET
#define SD_B1000X_STS1r_PAUSE_RESOLUTION_RXSIDEf_SET BCM89500_A0_SD_B1000X_STS1r_PAUSE_RESOLUTION_RXSIDEf_SET
#define SD_B1000X_STS1r_LINK_STATUS_CHGf_GET BCM89500_A0_SD_B1000X_STS1r_LINK_STATUS_CHGf_GET
#define SD_B1000X_STS1r_LINK_STATUS_CHGf_SET BCM89500_A0_SD_B1000X_STS1r_LINK_STATUS_CHGf_SET
#define SD_B1000X_STS1r_EARLY_END_EXTENSION_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_EARLY_END_EXTENSION_DETECTEDf_GET
#define SD_B1000X_STS1r_EARLY_END_EXTENSION_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_EARLY_END_EXTENSION_DETECTEDf_SET
#define SD_B1000X_STS1r_CARRIER_EXTEND_ERR_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_CARRIER_EXTEND_ERR_DETECTEDf_GET
#define SD_B1000X_STS1r_CARRIER_EXTEND_ERR_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_CARRIER_EXTEND_ERR_DETECTEDf_SET
#define SD_B1000X_STS1r_RX_ERR_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_RX_ERR_DETECTEDf_GET
#define SD_B1000X_STS1r_RX_ERR_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_RX_ERR_DETECTEDf_SET
#define SD_B1000X_STS1r_TX_ERR_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_TX_ERR_DETECTEDf_GET
#define SD_B1000X_STS1r_TX_ERR_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_TX_ERR_DETECTEDf_SET
#define SD_B1000X_STS1r_CRC_ERR_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_CRC_ERR_DETECTEDf_GET
#define SD_B1000X_STS1r_CRC_ERR_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_CRC_ERR_DETECTEDf_SET
#define SD_B1000X_STS1r_FALSE_CARRIER_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_FALSE_CARRIER_DETECTEDf_GET
#define SD_B1000X_STS1r_FALSE_CARRIER_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_FALSE_CARRIER_DETECTEDf_SET
#define SD_B1000X_STS1r_RXFIFO_ERR_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_RXFIFO_ERR_DETECTEDf_GET
#define SD_B1000X_STS1r_RXFIFO_ERR_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_RXFIFO_ERR_DETECTEDf_SET
#define SD_B1000X_STS1r_TXFIFO_ERR_DETECTEDf_GET BCM89500_A0_SD_B1000X_STS1r_TXFIFO_ERR_DETECTEDf_GET
#define SD_B1000X_STS1r_TXFIFO_ERR_DETECTEDf_SET BCM89500_A0_SD_B1000X_STS1r_TXFIFO_ERR_DETECTEDf_SET
#define READ_SD_B1000X_STS1r BCM89500_A0_READ_SD_B1000X_STS1r
#define WRITE_SD_B1000X_STS1r BCM89500_A0_WRITE_SD_B1000X_STS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_STS2
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Status 2 Register
 * SIZE:     16
 * FIELDS:
 *     AN_ENABLE_STATE  1 = an_enable state in auto-negotiation fsm entered since last read0 = an_enable state has not been entered since last read
 *     AN_ERR_DIS_LINK_OK_STATE If register offset 0x22 bit[3] is set:1 = an_error state entered since last read0 = an_error state not entered since last readIf register offset 0x22 bit [3] is cleared:1 = an_disable_link_ok state in auto-negotiation fsm entered since last read0 = an_disable_link_ok not entered since last read
 *     ABILITY_DETECT_STATE 1 = ability detect state in auto-negotiation fsm entered since last read0 = ability detect state not entered since last read
 *     ACK_DETECT_STATE 1 = acknowledge detect state in auto-negotiation fsm entered since last read0 = acknowledge detect state not entered since last read
 *     COMPLETE_ACK_STATE 1 = complete acknowledge state in auto-negotiation fsm entered since last read0 = complete acknowledge state not entered since last read
 *     IDLE_DETECT_STATE 1 = idle detect state in auto-negotiation fsm entered since last read0 = idle detect state not entered since last read
 *     LINK_DOWN_SYNC_LOSS 1 = a valid link went down due to a loss of synchronization for over 10 ms0 = failure conidtion has not been detected since last read
 *     RUDI_INVALID     1 = rudi_invalid detected since last read0 = rudi_invalid has not been detected since last read
 *     RUDI_I           1 = rudi_i detected since last read0 = rudi_i has not been detected since last read
 *     RUDI_C           1 = rudi_c detected since last read0 = rudi_c has not been detected since last read
 *     SYNC_STATUS_OK   1 = sync_status ok detected since last read (synchronization has been achieved)0 = sync_status ok has not been detected since last read
 *     SYNC_STATUS_FAIL 1 = sync_status has failed since last read (synchronization has been lost)0 = sync_status has not failed since last read
 *     SGMII_SELECTOR_MISMATCH 1 = sgmii selector mismatch detected since last read (auto-negotiation page received from link partner with bit [0] = 0 while local device is in sgmii mode)0 = sgmii selector mismatch not detected since last read
 *     AUTONEG_RESOLUTION_ERR 1 = auto-negotiation hcd error detected since last read (hcd is none in fiber mode)0 = auto-negotiation hcd error has not been detected since last read
 *     CONSISTENCY_MISMATCH 1 = consistency mismatch detected since last read0 = consistency mismatch has not been detected since last read
 *     SGMII_MODE_CHANGE 1 = sgmii mode has changed since last read (sgmii mode enabled or disabled)NOTE: This bit is useful when the auto-detection is enabled in register 0*10h bit [4].0 = sgmii mode has not changed since last read (fixed in sgmii or fiber mode)
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_STS2r 0x0000152a

#define BCM89500_A0_SD_B1000X_STS2r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_STS2.
 *
 */
typedef union BCM89500_A0_SD_B1000X_STS2r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_sts2[1];
	uint32_t _sd_b1000x_sts2;
} BCM89500_A0_SD_B1000X_STS2r_t;

#define BCM89500_A0_SD_B1000X_STS2r_CLR(r) (r).sd_b1000x_sts2[0] = 0
#define BCM89500_A0_SD_B1000X_STS2r_SET(r,d) (r).sd_b1000x_sts2[0] = d
#define BCM89500_A0_SD_B1000X_STS2r_GET(r) (r).sd_b1000x_sts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_STS2r_AN_ENABLE_STATEf_GET(r) (((r).sd_b1000x_sts2[0]) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_AN_ENABLE_STATEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_B1000X_STS2r_AN_ERR_DIS_LINK_OK_STATEf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_AN_ERR_DIS_LINK_OK_STATEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_B1000X_STS2r_ABILITY_DETECT_STATEf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_ABILITY_DETECT_STATEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_B1000X_STS2r_ACK_DETECT_STATEf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_ACK_DETECT_STATEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_B1000X_STS2r_COMPLETE_ACK_STATEf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_COMPLETE_ACK_STATEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_B1000X_STS2r_IDLE_DETECT_STATEf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_IDLE_DETECT_STATEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_STS2r_LINK_DOWN_SYNC_LOSSf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_LINK_DOWN_SYNC_LOSSf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_STS2r_RUDI_INVALIDf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_RUDI_INVALIDf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_STS2r_RUDI_If_GET(r) ((((r).sd_b1000x_sts2[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_RUDI_If_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_STS2r_RUDI_Cf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_RUDI_Cf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_OKf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_OKf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_FAILf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_FAILf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_B1000X_STS2r_SGMII_SELECTOR_MISMATCHf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_SGMII_SELECTOR_MISMATCHf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_B1000X_STS2r_AUTONEG_RESOLUTION_ERRf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_AUTONEG_RESOLUTION_ERRf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_B1000X_STS2r_CONSISTENCY_MISMATCHf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_CONSISTENCY_MISMATCHf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_B1000X_STS2r_SGMII_MODE_CHANGEf_GET(r) ((((r).sd_b1000x_sts2[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_B1000X_STS2r_SGMII_MODE_CHANGEf_SET(r,f) (r).sd_b1000x_sts2[0]=(((r).sd_b1000x_sts2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_B1000X_STS2.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_STS2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_STS2r,(r._sd_b1000x_sts2),2)
#define BCM89500_A0_WRITE_SD_B1000X_STS2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_STS2r,&(r._sd_b1000x_sts2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_STS2r BCM89500_A0_SD_B1000X_STS2r
#define SD_B1000X_STS2r_SIZE BCM89500_A0_SD_B1000X_STS2r_SIZE
typedef BCM89500_A0_SD_B1000X_STS2r_t SD_B1000X_STS2r_t;
#define SD_B1000X_STS2r_CLR BCM89500_A0_SD_B1000X_STS2r_CLR
#define SD_B1000X_STS2r_SET BCM89500_A0_SD_B1000X_STS2r_SET
#define SD_B1000X_STS2r_GET BCM89500_A0_SD_B1000X_STS2r_GET
#define SD_B1000X_STS2r_AN_ENABLE_STATEf_GET BCM89500_A0_SD_B1000X_STS2r_AN_ENABLE_STATEf_GET
#define SD_B1000X_STS2r_AN_ENABLE_STATEf_SET BCM89500_A0_SD_B1000X_STS2r_AN_ENABLE_STATEf_SET
#define SD_B1000X_STS2r_AN_ERR_DIS_LINK_OK_STATEf_GET BCM89500_A0_SD_B1000X_STS2r_AN_ERR_DIS_LINK_OK_STATEf_GET
#define SD_B1000X_STS2r_AN_ERR_DIS_LINK_OK_STATEf_SET BCM89500_A0_SD_B1000X_STS2r_AN_ERR_DIS_LINK_OK_STATEf_SET
#define SD_B1000X_STS2r_ABILITY_DETECT_STATEf_GET BCM89500_A0_SD_B1000X_STS2r_ABILITY_DETECT_STATEf_GET
#define SD_B1000X_STS2r_ABILITY_DETECT_STATEf_SET BCM89500_A0_SD_B1000X_STS2r_ABILITY_DETECT_STATEf_SET
#define SD_B1000X_STS2r_ACK_DETECT_STATEf_GET BCM89500_A0_SD_B1000X_STS2r_ACK_DETECT_STATEf_GET
#define SD_B1000X_STS2r_ACK_DETECT_STATEf_SET BCM89500_A0_SD_B1000X_STS2r_ACK_DETECT_STATEf_SET
#define SD_B1000X_STS2r_COMPLETE_ACK_STATEf_GET BCM89500_A0_SD_B1000X_STS2r_COMPLETE_ACK_STATEf_GET
#define SD_B1000X_STS2r_COMPLETE_ACK_STATEf_SET BCM89500_A0_SD_B1000X_STS2r_COMPLETE_ACK_STATEf_SET
#define SD_B1000X_STS2r_IDLE_DETECT_STATEf_GET BCM89500_A0_SD_B1000X_STS2r_IDLE_DETECT_STATEf_GET
#define SD_B1000X_STS2r_IDLE_DETECT_STATEf_SET BCM89500_A0_SD_B1000X_STS2r_IDLE_DETECT_STATEf_SET
#define SD_B1000X_STS2r_LINK_DOWN_SYNC_LOSSf_GET BCM89500_A0_SD_B1000X_STS2r_LINK_DOWN_SYNC_LOSSf_GET
#define SD_B1000X_STS2r_LINK_DOWN_SYNC_LOSSf_SET BCM89500_A0_SD_B1000X_STS2r_LINK_DOWN_SYNC_LOSSf_SET
#define SD_B1000X_STS2r_RUDI_INVALIDf_GET BCM89500_A0_SD_B1000X_STS2r_RUDI_INVALIDf_GET
#define SD_B1000X_STS2r_RUDI_INVALIDf_SET BCM89500_A0_SD_B1000X_STS2r_RUDI_INVALIDf_SET
#define SD_B1000X_STS2r_RUDI_If_GET BCM89500_A0_SD_B1000X_STS2r_RUDI_If_GET
#define SD_B1000X_STS2r_RUDI_If_SET BCM89500_A0_SD_B1000X_STS2r_RUDI_If_SET
#define SD_B1000X_STS2r_RUDI_Cf_GET BCM89500_A0_SD_B1000X_STS2r_RUDI_Cf_GET
#define SD_B1000X_STS2r_RUDI_Cf_SET BCM89500_A0_SD_B1000X_STS2r_RUDI_Cf_SET
#define SD_B1000X_STS2r_SYNC_STATUS_OKf_GET BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_OKf_GET
#define SD_B1000X_STS2r_SYNC_STATUS_OKf_SET BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_OKf_SET
#define SD_B1000X_STS2r_SYNC_STATUS_FAILf_GET BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_FAILf_GET
#define SD_B1000X_STS2r_SYNC_STATUS_FAILf_SET BCM89500_A0_SD_B1000X_STS2r_SYNC_STATUS_FAILf_SET
#define SD_B1000X_STS2r_SGMII_SELECTOR_MISMATCHf_GET BCM89500_A0_SD_B1000X_STS2r_SGMII_SELECTOR_MISMATCHf_GET
#define SD_B1000X_STS2r_SGMII_SELECTOR_MISMATCHf_SET BCM89500_A0_SD_B1000X_STS2r_SGMII_SELECTOR_MISMATCHf_SET
#define SD_B1000X_STS2r_AUTONEG_RESOLUTION_ERRf_GET BCM89500_A0_SD_B1000X_STS2r_AUTONEG_RESOLUTION_ERRf_GET
#define SD_B1000X_STS2r_AUTONEG_RESOLUTION_ERRf_SET BCM89500_A0_SD_B1000X_STS2r_AUTONEG_RESOLUTION_ERRf_SET
#define SD_B1000X_STS2r_CONSISTENCY_MISMATCHf_GET BCM89500_A0_SD_B1000X_STS2r_CONSISTENCY_MISMATCHf_GET
#define SD_B1000X_STS2r_CONSISTENCY_MISMATCHf_SET BCM89500_A0_SD_B1000X_STS2r_CONSISTENCY_MISMATCHf_SET
#define SD_B1000X_STS2r_SGMII_MODE_CHANGEf_GET BCM89500_A0_SD_B1000X_STS2r_SGMII_MODE_CHANGEf_GET
#define SD_B1000X_STS2r_SGMII_MODE_CHANGEf_SET BCM89500_A0_SD_B1000X_STS2r_SGMII_MODE_CHANGEf_SET
#define READ_SD_B1000X_STS2r BCM89500_A0_READ_SD_B1000X_STS2r
#define WRITE_SD_B1000X_STS2r BCM89500_A0_WRITE_SD_B1000X_STS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_STS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_B1000X_STS3
 * BLOCKS:   SYS
 * DESC:     PHY 1000 Base X Status 3 Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       write as 0, ignore on read
 *     ANA_SIGDET_CHG   1 = analog signal detect has changed since last read0 = analog signal detect has not changed since last readNote: The analog signal detect change is based on a change in bit [5] of this register
 *     ANA_SIGNAL_DETECT Analog signal detect status bit.This status signal is the analog signal detect status if register offset 0x26 bit [0] is set, otherwise it is the value based on register offset 0x26 bit [1].
 *     SIGNAL_DETECT    signal detect direct from pin
 *     SD_FILTER_CHG    1 = signal detect has changed since last read0 = signal detect has not changed since last readNote: The signal detect change is based on a change in bit [9] of this register
 *     SD_MUX           1 = output of signal detect filter is set0 = output of signal detect is not setNote: This is the only SD stuats bit that will be valid when the serdes is powered down from register offset 0x22. This status signal is the "signal detect" input port when register offset 0x20 bit [3] is 0, otherwise it is the "signal detect" input port inverted.
 *     SD_FILTER        1 = output of signal detect filter is set0 = output of signal detect is not setNote: This signal is used for the PCS synchronization. When register offset 0x20 bit [2] is 0, then the output of the filter will be forced high. This status signal is still valid when register offset 0x20 bit [14] is 1. Noise pulses less than 16 ns wide are still removed when even the filter is disabled.
 *     LATCH_LINKDOWN   1 = link has been down since register offset 0x26 bit [9] has been written a "1"0 = link has not been down since register offset 0x26 bit [9] has been written a "1"
 *     RESERVED_1       write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_B1000X_STS3r 0x0000152c

#define BCM89500_A0_SD_B1000X_STS3r_SIZE 2

/*
 * This structure should be used to declare and program SD_B1000X_STS3.
 *
 */
typedef union BCM89500_A0_SD_B1000X_STS3r_s {
	uint32_t v[1];
	uint32_t sd_b1000x_sts3[1];
	uint32_t _sd_b1000x_sts3;
} BCM89500_A0_SD_B1000X_STS3r_t;

#define BCM89500_A0_SD_B1000X_STS3r_CLR(r) (r).sd_b1000x_sts3[0] = 0
#define BCM89500_A0_SD_B1000X_STS3r_SET(r,d) (r).sd_b1000x_sts3[0] = d
#define BCM89500_A0_SD_B1000X_STS3r_GET(r) (r).sd_b1000x_sts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_B1000X_STS3r_RESERVED_0f_GET(r) (((r).sd_b1000x_sts3[0]) & 0xf)
#define BCM89500_A0_SD_B1000X_STS3r_RESERVED_0f_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_SD_B1000X_STS3r_ANA_SIGDET_CHGf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_ANA_SIGDET_CHGf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_B1000X_STS3r_ANA_SIGNAL_DETECTf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_ANA_SIGNAL_DETECTf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_B1000X_STS3r_SIGNAL_DETECTf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_SIGNAL_DETECTf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_B1000X_STS3r_SD_FILTER_CHGf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_SD_FILTER_CHGf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_B1000X_STS3r_SD_MUXf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_SD_MUXf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_B1000X_STS3r_SD_FILTERf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_SD_FILTERf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_B1000X_STS3r_LATCH_LINKDOWNf_GET(r) ((((r).sd_b1000x_sts3[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_B1000X_STS3r_LATCH_LINKDOWNf_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_B1000X_STS3r_RESERVED_1f_GET(r) ((((r).sd_b1000x_sts3[0]) >> 11) & 0x1f)
#define BCM89500_A0_SD_B1000X_STS3r_RESERVED_1f_SET(r,f) (r).sd_b1000x_sts3[0]=(((r).sd_b1000x_sts3[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access SD_B1000X_STS3.
 *
 */
#define BCM89500_A0_READ_SD_B1000X_STS3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_B1000X_STS3r,(r._sd_b1000x_sts3),2)
#define BCM89500_A0_WRITE_SD_B1000X_STS3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_B1000X_STS3r,&(r._sd_b1000x_sts3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_B1000X_STS3r BCM89500_A0_SD_B1000X_STS3r
#define SD_B1000X_STS3r_SIZE BCM89500_A0_SD_B1000X_STS3r_SIZE
typedef BCM89500_A0_SD_B1000X_STS3r_t SD_B1000X_STS3r_t;
#define SD_B1000X_STS3r_CLR BCM89500_A0_SD_B1000X_STS3r_CLR
#define SD_B1000X_STS3r_SET BCM89500_A0_SD_B1000X_STS3r_SET
#define SD_B1000X_STS3r_GET BCM89500_A0_SD_B1000X_STS3r_GET
#define SD_B1000X_STS3r_RESERVED_0f_GET BCM89500_A0_SD_B1000X_STS3r_RESERVED_0f_GET
#define SD_B1000X_STS3r_RESERVED_0f_SET BCM89500_A0_SD_B1000X_STS3r_RESERVED_0f_SET
#define SD_B1000X_STS3r_ANA_SIGDET_CHGf_GET BCM89500_A0_SD_B1000X_STS3r_ANA_SIGDET_CHGf_GET
#define SD_B1000X_STS3r_ANA_SIGDET_CHGf_SET BCM89500_A0_SD_B1000X_STS3r_ANA_SIGDET_CHGf_SET
#define SD_B1000X_STS3r_ANA_SIGNAL_DETECTf_GET BCM89500_A0_SD_B1000X_STS3r_ANA_SIGNAL_DETECTf_GET
#define SD_B1000X_STS3r_ANA_SIGNAL_DETECTf_SET BCM89500_A0_SD_B1000X_STS3r_ANA_SIGNAL_DETECTf_SET
#define SD_B1000X_STS3r_SIGNAL_DETECTf_GET BCM89500_A0_SD_B1000X_STS3r_SIGNAL_DETECTf_GET
#define SD_B1000X_STS3r_SIGNAL_DETECTf_SET BCM89500_A0_SD_B1000X_STS3r_SIGNAL_DETECTf_SET
#define SD_B1000X_STS3r_SD_FILTER_CHGf_GET BCM89500_A0_SD_B1000X_STS3r_SD_FILTER_CHGf_GET
#define SD_B1000X_STS3r_SD_FILTER_CHGf_SET BCM89500_A0_SD_B1000X_STS3r_SD_FILTER_CHGf_SET
#define SD_B1000X_STS3r_SD_MUXf_GET BCM89500_A0_SD_B1000X_STS3r_SD_MUXf_GET
#define SD_B1000X_STS3r_SD_MUXf_SET BCM89500_A0_SD_B1000X_STS3r_SD_MUXf_SET
#define SD_B1000X_STS3r_SD_FILTERf_GET BCM89500_A0_SD_B1000X_STS3r_SD_FILTERf_GET
#define SD_B1000X_STS3r_SD_FILTERf_SET BCM89500_A0_SD_B1000X_STS3r_SD_FILTERf_SET
#define SD_B1000X_STS3r_LATCH_LINKDOWNf_GET BCM89500_A0_SD_B1000X_STS3r_LATCH_LINKDOWNf_GET
#define SD_B1000X_STS3r_LATCH_LINKDOWNf_SET BCM89500_A0_SD_B1000X_STS3r_LATCH_LINKDOWNf_SET
#define SD_B1000X_STS3r_RESERVED_1f_GET BCM89500_A0_SD_B1000X_STS3r_RESERVED_1f_GET
#define SD_B1000X_STS3r_RESERVED_1f_SET BCM89500_A0_SD_B1000X_STS3r_RESERVED_1f_SET
#define READ_SD_B1000X_STS3r BCM89500_A0_READ_SD_B1000X_STS3r
#define WRITE_SD_B1000X_STS3r BCM89500_A0_WRITE_SD_B1000X_STS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_B1000X_STS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_BER_CRCERR_RXPKTCNTR
 * BLOCKS:   SYS
 * DESC:     BER and CRC Error RX Packet Counter Register
 * SIZE:     16
 * FIELDS:
 *     CRC_ERR_RXPKT_CNTR Number of crc errors detected since last read. Freezes at FFh. When register offset 0x20 bit 11 is set, then the counter detects the number of received packets instead of crc errors.Clear on read.
 *     BER_CNTR         Number of invalid code groups detected while sync_status = 1. Freezes at FFh. Write register offset 0x22 bit [14] = 1 in order to clear bits [15:8] of this register
 *
 ******************************************************************************/
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr 0x0000152e

#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_SIZE 2

/*
 * This structure should be used to declare and program SD_BER_CRCERR_RXPKTCNTR.
 *
 */
typedef union BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_s {
	uint32_t v[1];
	uint32_t sd_ber_crcerr_rxpktcntr[1];
	uint32_t _sd_ber_crcerr_rxpktcntr;
} BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_t;

#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_CLR(r) (r).sd_ber_crcerr_rxpktcntr[0] = 0
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_SET(r,d) (r).sd_ber_crcerr_rxpktcntr[0] = d
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_GET(r) (r).sd_ber_crcerr_rxpktcntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_CRC_ERR_RXPKT_CNTRf_GET(r) (((r).sd_ber_crcerr_rxpktcntr[0]) & 0xff)
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_CRC_ERR_RXPKT_CNTRf_SET(r,f) (r).sd_ber_crcerr_rxpktcntr[0]=(((r).sd_ber_crcerr_rxpktcntr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_BER_CNTRf_GET(r) ((((r).sd_ber_crcerr_rxpktcntr[0]) >> 8) & 0xff)
#define BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_BER_CNTRf_SET(r,f) (r).sd_ber_crcerr_rxpktcntr[0]=(((r).sd_ber_crcerr_rxpktcntr[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access SD_BER_CRCERR_RXPKTCNTR.
 *
 */
#define BCM89500_A0_READ_SD_BER_CRCERR_RXPKTCNTRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr,(r._sd_ber_crcerr_rxpktcntr),2)
#define BCM89500_A0_WRITE_SD_BER_CRCERR_RXPKTCNTRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr,&(r._sd_ber_crcerr_rxpktcntr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_BER_CRCERR_RXPKTCNTRr BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr
#define SD_BER_CRCERR_RXPKTCNTRr_SIZE BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_SIZE
typedef BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_t SD_BER_CRCERR_RXPKTCNTRr_t;
#define SD_BER_CRCERR_RXPKTCNTRr_CLR BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_CLR
#define SD_BER_CRCERR_RXPKTCNTRr_SET BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_SET
#define SD_BER_CRCERR_RXPKTCNTRr_GET BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_GET
#define SD_BER_CRCERR_RXPKTCNTRr_CRC_ERR_RXPKT_CNTRf_GET BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_CRC_ERR_RXPKT_CNTRf_GET
#define SD_BER_CRCERR_RXPKTCNTRr_CRC_ERR_RXPKT_CNTRf_SET BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_CRC_ERR_RXPKT_CNTRf_SET
#define SD_BER_CRCERR_RXPKTCNTRr_BER_CNTRf_GET BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_BER_CNTRf_GET
#define SD_BER_CRCERR_RXPKTCNTRr_BER_CNTRf_SET BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr_BER_CNTRf_SET
#define READ_SD_BER_CRCERR_RXPKTCNTRr BCM89500_A0_READ_SD_BER_CRCERR_RXPKTCNTRr
#define WRITE_SD_BER_CRCERR_RXPKTCNTRr BCM89500_A0_WRITE_SD_BER_CRCERR_RXPKTCNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_BER_CRCERR_RXPKTCNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_BLOCK_ADDR
 * BLOCKS:   SYS
 * DESC:     Block Address Register
 * SIZE:     16
 * FIELDS:
 *     BLOCK_ADDR       (offset bit[4], BLOCK_ADDR[3:0])(1, 3): Analog Registers(1, 2): FX100 Digital Registers(1, 1): SerDes ID Registers(1, 0): Digital Registers(0, 0): IEEE Registers
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_BLOCK_ADDRr 0x0000153e

#define BCM89500_A0_SD_BLOCK_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program SD_BLOCK_ADDR.
 *
 */
typedef union BCM89500_A0_SD_BLOCK_ADDRr_s {
	uint32_t v[1];
	uint32_t sd_block_addr[1];
	uint32_t _sd_block_addr;
} BCM89500_A0_SD_BLOCK_ADDRr_t;

#define BCM89500_A0_SD_BLOCK_ADDRr_CLR(r) (r).sd_block_addr[0] = 0
#define BCM89500_A0_SD_BLOCK_ADDRr_SET(r,d) (r).sd_block_addr[0] = d
#define BCM89500_A0_SD_BLOCK_ADDRr_GET(r) (r).sd_block_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_BLOCK_ADDRr_BLOCK_ADDRf_GET(r) (((r).sd_block_addr[0]) & 0xf)
#define BCM89500_A0_SD_BLOCK_ADDRr_BLOCK_ADDRf_SET(r,f) (r).sd_block_addr[0]=(((r).sd_block_addr[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_SD_BLOCK_ADDRr_RESERVEDf_GET(r) ((((r).sd_block_addr[0]) >> 4) & 0xfff)
#define BCM89500_A0_SD_BLOCK_ADDRr_RESERVEDf_SET(r,f) (r).sd_block_addr[0]=(((r).sd_block_addr[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access SD_BLOCK_ADDR.
 *
 */
#define BCM89500_A0_READ_SD_BLOCK_ADDRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_BLOCK_ADDRr,(r._sd_block_addr),2)
#define BCM89500_A0_WRITE_SD_BLOCK_ADDRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_BLOCK_ADDRr,&(r._sd_block_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_BLOCK_ADDRr BCM89500_A0_SD_BLOCK_ADDRr
#define SD_BLOCK_ADDRr_SIZE BCM89500_A0_SD_BLOCK_ADDRr_SIZE
typedef BCM89500_A0_SD_BLOCK_ADDRr_t SD_BLOCK_ADDRr_t;
#define SD_BLOCK_ADDRr_CLR BCM89500_A0_SD_BLOCK_ADDRr_CLR
#define SD_BLOCK_ADDRr_SET BCM89500_A0_SD_BLOCK_ADDRr_SET
#define SD_BLOCK_ADDRr_GET BCM89500_A0_SD_BLOCK_ADDRr_GET
#define SD_BLOCK_ADDRr_BLOCK_ADDRf_GET BCM89500_A0_SD_BLOCK_ADDRr_BLOCK_ADDRf_GET
#define SD_BLOCK_ADDRr_BLOCK_ADDRf_SET BCM89500_A0_SD_BLOCK_ADDRr_BLOCK_ADDRf_SET
#define SD_BLOCK_ADDRr_RESERVEDf_GET BCM89500_A0_SD_BLOCK_ADDRr_RESERVEDf_GET
#define SD_BLOCK_ADDRr_RESERVEDf_SET BCM89500_A0_SD_BLOCK_ADDRr_RESERVEDf_SET
#define READ_SD_BLOCK_ADDRr BCM89500_A0_READ_SD_BLOCK_ADDRr
#define WRITE_SD_BLOCK_ADDRr BCM89500_A0_WRITE_SD_BLOCK_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_BLOCK_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_EXT_STS
 * BLOCKS:   SYS
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_EXT_STSr 0x0000151e

#define BCM89500_A0_SD_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program SD_EXT_STS.
 *
 */
typedef union BCM89500_A0_SD_EXT_STSr_s {
	uint32_t v[1];
	uint32_t sd_ext_sts[1];
	uint32_t _sd_ext_sts;
} BCM89500_A0_SD_EXT_STSr_t;

#define BCM89500_A0_SD_EXT_STSr_CLR(r) (r).sd_ext_sts[0] = 0
#define BCM89500_A0_SD_EXT_STSr_SET(r,d) (r).sd_ext_sts[0] = d
#define BCM89500_A0_SD_EXT_STSr_GET(r) (r).sd_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_EXT_STSr_RESERVEDf_GET(r) (((r).sd_ext_sts[0]) & 0xfff)
#define BCM89500_A0_SD_EXT_STSr_RESERVEDf_SET(r,f) (r).sd_ext_sts[0]=(((r).sd_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_SD_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).sd_ext_sts[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).sd_ext_sts[0]=(((r).sd_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).sd_ext_sts[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).sd_ext_sts[0]=(((r).sd_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).sd_ext_sts[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).sd_ext_sts[0]=(((r).sd_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).sd_ext_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).sd_ext_sts[0]=(((r).sd_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_EXT_STS.
 *
 */
#define BCM89500_A0_READ_SD_EXT_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_EXT_STSr,(r._sd_ext_sts),2)
#define BCM89500_A0_WRITE_SD_EXT_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_EXT_STSr,&(r._sd_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_EXT_STSr BCM89500_A0_SD_EXT_STSr
#define SD_EXT_STSr_SIZE BCM89500_A0_SD_EXT_STSr_SIZE
typedef BCM89500_A0_SD_EXT_STSr_t SD_EXT_STSr_t;
#define SD_EXT_STSr_CLR BCM89500_A0_SD_EXT_STSr_CLR
#define SD_EXT_STSr_SET BCM89500_A0_SD_EXT_STSr_SET
#define SD_EXT_STSr_GET BCM89500_A0_SD_EXT_STSr_GET
#define SD_EXT_STSr_RESERVEDf_GET BCM89500_A0_SD_EXT_STSr_RESERVEDf_GET
#define SD_EXT_STSr_RESERVEDf_SET BCM89500_A0_SD_EXT_STSr_RESERVEDf_SET
#define SD_EXT_STSr_B1000T_HD_CAPf_GET BCM89500_A0_SD_EXT_STSr_B1000T_HD_CAPf_GET
#define SD_EXT_STSr_B1000T_HD_CAPf_SET BCM89500_A0_SD_EXT_STSr_B1000T_HD_CAPf_SET
#define SD_EXT_STSr_B1000T_FD_CAPf_GET BCM89500_A0_SD_EXT_STSr_B1000T_FD_CAPf_GET
#define SD_EXT_STSr_B1000T_FD_CAPf_SET BCM89500_A0_SD_EXT_STSr_B1000T_FD_CAPf_SET
#define SD_EXT_STSr_B1000X_HD_CAPf_GET BCM89500_A0_SD_EXT_STSr_B1000X_HD_CAPf_GET
#define SD_EXT_STSr_B1000X_HD_CAPf_SET BCM89500_A0_SD_EXT_STSr_B1000X_HD_CAPf_SET
#define SD_EXT_STSr_B1000X_FD_CAPf_GET BCM89500_A0_SD_EXT_STSr_B1000X_FD_CAPf_GET
#define SD_EXT_STSr_B1000X_FD_CAPf_SET BCM89500_A0_SD_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_SD_EXT_STSr BCM89500_A0_READ_SD_EXT_STSr
#define WRITE_SD_EXT_STSr BCM89500_A0_WRITE_SD_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_FORCE_TX_DATA1
 * BLOCKS:   SYS
 * DESC:     Force TX Data 1 Register
 * SIZE:     16
 * FIELDS:
 *     FORCE_TX_DATA1   Value in this register will be provided to serdes analog transmitter every other clock cycle when bit 10 is set.
 *     FORCE_DATA_TO_ANA_TX_EN 1 = provide alternating 10 bits from this register and register offset 0x3c to serdes analog transmitter0 = normal operation
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_FORCE_TX_DATA1r 0x0000153a

#define BCM89500_A0_SD_FORCE_TX_DATA1r_SIZE 2

/*
 * This structure should be used to declare and program SD_FORCE_TX_DATA1.
 *
 */
typedef union BCM89500_A0_SD_FORCE_TX_DATA1r_s {
	uint32_t v[1];
	uint32_t sd_force_tx_data1[1];
	uint32_t _sd_force_tx_data1;
} BCM89500_A0_SD_FORCE_TX_DATA1r_t;

#define BCM89500_A0_SD_FORCE_TX_DATA1r_CLR(r) (r).sd_force_tx_data1[0] = 0
#define BCM89500_A0_SD_FORCE_TX_DATA1r_SET(r,d) (r).sd_force_tx_data1[0] = d
#define BCM89500_A0_SD_FORCE_TX_DATA1r_GET(r) (r).sd_force_tx_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_TX_DATA1f_GET(r) (((r).sd_force_tx_data1[0]) & 0x3ff)
#define BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_TX_DATA1f_SET(r,f) (r).sd_force_tx_data1[0]=(((r).sd_force_tx_data1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_DATA_TO_ANA_TX_ENf_GET(r) ((((r).sd_force_tx_data1[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_DATA_TO_ANA_TX_ENf_SET(r,f) (r).sd_force_tx_data1[0]=(((r).sd_force_tx_data1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_FORCE_TX_DATA1r_RESERVEDf_GET(r) ((((r).sd_force_tx_data1[0]) >> 11) & 0x1f)
#define BCM89500_A0_SD_FORCE_TX_DATA1r_RESERVEDf_SET(r,f) (r).sd_force_tx_data1[0]=(((r).sd_force_tx_data1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access SD_FORCE_TX_DATA1.
 *
 */
#define BCM89500_A0_READ_SD_FORCE_TX_DATA1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_FORCE_TX_DATA1r,(r._sd_force_tx_data1),2)
#define BCM89500_A0_WRITE_SD_FORCE_TX_DATA1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_FORCE_TX_DATA1r,&(r._sd_force_tx_data1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_FORCE_TX_DATA1r BCM89500_A0_SD_FORCE_TX_DATA1r
#define SD_FORCE_TX_DATA1r_SIZE BCM89500_A0_SD_FORCE_TX_DATA1r_SIZE
typedef BCM89500_A0_SD_FORCE_TX_DATA1r_t SD_FORCE_TX_DATA1r_t;
#define SD_FORCE_TX_DATA1r_CLR BCM89500_A0_SD_FORCE_TX_DATA1r_CLR
#define SD_FORCE_TX_DATA1r_SET BCM89500_A0_SD_FORCE_TX_DATA1r_SET
#define SD_FORCE_TX_DATA1r_GET BCM89500_A0_SD_FORCE_TX_DATA1r_GET
#define SD_FORCE_TX_DATA1r_FORCE_TX_DATA1f_GET BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_TX_DATA1f_GET
#define SD_FORCE_TX_DATA1r_FORCE_TX_DATA1f_SET BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_TX_DATA1f_SET
#define SD_FORCE_TX_DATA1r_FORCE_DATA_TO_ANA_TX_ENf_GET BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_DATA_TO_ANA_TX_ENf_GET
#define SD_FORCE_TX_DATA1r_FORCE_DATA_TO_ANA_TX_ENf_SET BCM89500_A0_SD_FORCE_TX_DATA1r_FORCE_DATA_TO_ANA_TX_ENf_SET
#define SD_FORCE_TX_DATA1r_RESERVEDf_GET BCM89500_A0_SD_FORCE_TX_DATA1r_RESERVEDf_GET
#define SD_FORCE_TX_DATA1r_RESERVEDf_SET BCM89500_A0_SD_FORCE_TX_DATA1r_RESERVEDf_SET
#define READ_SD_FORCE_TX_DATA1r BCM89500_A0_READ_SD_FORCE_TX_DATA1r
#define WRITE_SD_FORCE_TX_DATA1r BCM89500_A0_WRITE_SD_FORCE_TX_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_FORCE_TX_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_FORCE_TX_DATA2
 * BLOCKS:   SYS
 * DESC:     Force TX Data 2 Register
 * SIZE:     16
 * FIELDS:
 *     FORCE_TX_DATA2   Value in this register will be provided to serdes analog transmitter every other clock cycle when register offset 0x3a bit 10 is set.
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_FORCE_TX_DATA2r 0x0000153c

#define BCM89500_A0_SD_FORCE_TX_DATA2r_SIZE 2

/*
 * This structure should be used to declare and program SD_FORCE_TX_DATA2.
 *
 */
typedef union BCM89500_A0_SD_FORCE_TX_DATA2r_s {
	uint32_t v[1];
	uint32_t sd_force_tx_data2[1];
	uint32_t _sd_force_tx_data2;
} BCM89500_A0_SD_FORCE_TX_DATA2r_t;

#define BCM89500_A0_SD_FORCE_TX_DATA2r_CLR(r) (r).sd_force_tx_data2[0] = 0
#define BCM89500_A0_SD_FORCE_TX_DATA2r_SET(r,d) (r).sd_force_tx_data2[0] = d
#define BCM89500_A0_SD_FORCE_TX_DATA2r_GET(r) (r).sd_force_tx_data2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_FORCE_TX_DATA2r_FORCE_TX_DATA2f_GET(r) (((r).sd_force_tx_data2[0]) & 0x3ff)
#define BCM89500_A0_SD_FORCE_TX_DATA2r_FORCE_TX_DATA2f_SET(r,f) (r).sd_force_tx_data2[0]=(((r).sd_force_tx_data2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM89500_A0_SD_FORCE_TX_DATA2r_RESERVEDf_GET(r) ((((r).sd_force_tx_data2[0]) >> 10) & 0x3f)
#define BCM89500_A0_SD_FORCE_TX_DATA2r_RESERVEDf_SET(r,f) (r).sd_force_tx_data2[0]=(((r).sd_force_tx_data2[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access SD_FORCE_TX_DATA2.
 *
 */
#define BCM89500_A0_READ_SD_FORCE_TX_DATA2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_FORCE_TX_DATA2r,(r._sd_force_tx_data2),2)
#define BCM89500_A0_WRITE_SD_FORCE_TX_DATA2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_FORCE_TX_DATA2r,&(r._sd_force_tx_data2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_FORCE_TX_DATA2r BCM89500_A0_SD_FORCE_TX_DATA2r
#define SD_FORCE_TX_DATA2r_SIZE BCM89500_A0_SD_FORCE_TX_DATA2r_SIZE
typedef BCM89500_A0_SD_FORCE_TX_DATA2r_t SD_FORCE_TX_DATA2r_t;
#define SD_FORCE_TX_DATA2r_CLR BCM89500_A0_SD_FORCE_TX_DATA2r_CLR
#define SD_FORCE_TX_DATA2r_SET BCM89500_A0_SD_FORCE_TX_DATA2r_SET
#define SD_FORCE_TX_DATA2r_GET BCM89500_A0_SD_FORCE_TX_DATA2r_GET
#define SD_FORCE_TX_DATA2r_FORCE_TX_DATA2f_GET BCM89500_A0_SD_FORCE_TX_DATA2r_FORCE_TX_DATA2f_GET
#define SD_FORCE_TX_DATA2r_FORCE_TX_DATA2f_SET BCM89500_A0_SD_FORCE_TX_DATA2r_FORCE_TX_DATA2f_SET
#define SD_FORCE_TX_DATA2r_RESERVEDf_GET BCM89500_A0_SD_FORCE_TX_DATA2r_RESERVEDf_GET
#define SD_FORCE_TX_DATA2r_RESERVEDf_SET BCM89500_A0_SD_FORCE_TX_DATA2r_RESERVEDf_SET
#define READ_SD_FORCE_TX_DATA2r BCM89500_A0_READ_SD_FORCE_TX_DATA2r
#define WRITE_SD_FORCE_TX_DATA2r BCM89500_A0_WRITE_SD_FORCE_TX_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_FORCE_TX_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_LPNXP
 * BLOCKS:   SYS
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_LPNXPr 0x00001510

#define BCM89500_A0_SD_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program SD_LPNXP.
 *
 */
typedef union BCM89500_A0_SD_LPNXPr_s {
	uint32_t v[1];
	uint32_t sd_lpnxp[1];
	uint32_t _sd_lpnxp;
} BCM89500_A0_SD_LPNXPr_t;

#define BCM89500_A0_SD_LPNXPr_CLR(r) (r).sd_lpnxp[0] = 0
#define BCM89500_A0_SD_LPNXPr_SET(r,d) (r).sd_lpnxp[0] = d
#define BCM89500_A0_SD_LPNXPr_GET(r) (r).sd_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_LPNXPr_RESERVEDf_GET(r) (((r).sd_lpnxp[0]) & 0xffff)
#define BCM89500_A0_SD_LPNXPr_RESERVEDf_SET(r,f) (r).sd_lpnxp[0]=(((r).sd_lpnxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SD_LPNXP.
 *
 */
#define BCM89500_A0_READ_SD_LPNXPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_LPNXPr,(r._sd_lpnxp),2)
#define BCM89500_A0_WRITE_SD_LPNXPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_LPNXPr,&(r._sd_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_LPNXPr BCM89500_A0_SD_LPNXPr
#define SD_LPNXPr_SIZE BCM89500_A0_SD_LPNXPr_SIZE
typedef BCM89500_A0_SD_LPNXPr_t SD_LPNXPr_t;
#define SD_LPNXPr_CLR BCM89500_A0_SD_LPNXPr_CLR
#define SD_LPNXPr_SET BCM89500_A0_SD_LPNXPr_SET
#define SD_LPNXPr_GET BCM89500_A0_SD_LPNXPr_GET
#define SD_LPNXPr_RESERVEDf_GET BCM89500_A0_SD_LPNXPr_RESERVEDf_GET
#define SD_LPNXPr_RESERVEDf_SET BCM89500_A0_SD_LPNXPr_RESERVEDf_SET
#define READ_SD_LPNXPr BCM89500_A0_READ_SD_LPNXPr
#define WRITE_SD_LPNXPr BCM89500_A0_WRITE_SD_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_MIICTL
 * BLOCKS:   SYS
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       write as 0, ignore on read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}1X = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.Self-clearing
 *     RESERVED_1       write as 0, ignore on read.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enabled.0: Auto-Negotiation disabled.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}1X = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.Self-clearing
 *
 ******************************************************************************/
#define BCM89500_A0_SD_MIICTLr 0x00001500

#define BCM89500_A0_SD_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program SD_MIICTL.
 *
 */
typedef union BCM89500_A0_SD_MIICTLr_s {
	uint32_t v[1];
	uint32_t sd_miictl[1];
	uint32_t _sd_miictl;
} BCM89500_A0_SD_MIICTLr_t;

#define BCM89500_A0_SD_MIICTLr_CLR(r) (r).sd_miictl[0] = 0
#define BCM89500_A0_SD_MIICTLr_SET(r,d) (r).sd_miictl[0] = d
#define BCM89500_A0_SD_MIICTLr_GET(r) (r).sd_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_MIICTLr_RESERVED_0f_GET(r) (((r).sd_miictl[0]) & 0x3f)
#define BCM89500_A0_SD_MIICTLr_RESERVED_0f_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_SD_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).sd_miictl[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_MIICTLr_COL_TESTf_GET(r) ((((r).sd_miictl[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_MIICTLr_COL_TESTf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_MIICTLr_DUPLEX_MODf_GET(r) ((((r).sd_miictl[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_MIICTLr_DUPLEX_MODf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_MIICTLr_RE_ANf_GET(r) ((((r).sd_miictl[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_MIICTLr_RE_ANf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_MIICTLr_RESERVED_1f_GET(r) ((((r).sd_miictl[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_MIICTLr_RESERVED_1f_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_MIICTLr_PWR_DOWNf_GET(r) ((((r).sd_miictl[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_MIICTLr_PWR_DOWNf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_MIICTLr_AN_ENf_GET(r) ((((r).sd_miictl[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_MIICTLr_AN_ENf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).sd_miictl[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_MIICTLr_LOOPBACKf_GET(r) ((((r).sd_miictl[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_MIICTLr_LOOPBACKf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_MIICTLr_RESETf_GET(r) ((((r).sd_miictl[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_MIICTLr_RESETf_SET(r,f) (r).sd_miictl[0]=(((r).sd_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_MIICTL.
 *
 */
#define BCM89500_A0_READ_SD_MIICTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_MIICTLr,(r._sd_miictl),2)
#define BCM89500_A0_WRITE_SD_MIICTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_MIICTLr,&(r._sd_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_MIICTLr BCM89500_A0_SD_MIICTLr
#define SD_MIICTLr_SIZE BCM89500_A0_SD_MIICTLr_SIZE
typedef BCM89500_A0_SD_MIICTLr_t SD_MIICTLr_t;
#define SD_MIICTLr_CLR BCM89500_A0_SD_MIICTLr_CLR
#define SD_MIICTLr_SET BCM89500_A0_SD_MIICTLr_SET
#define SD_MIICTLr_GET BCM89500_A0_SD_MIICTLr_GET
#define SD_MIICTLr_RESERVED_0f_GET BCM89500_A0_SD_MIICTLr_RESERVED_0f_GET
#define SD_MIICTLr_RESERVED_0f_SET BCM89500_A0_SD_MIICTLr_RESERVED_0f_SET
#define SD_MIICTLr_SPD_SEL_MSBf_GET BCM89500_A0_SD_MIICTLr_SPD_SEL_MSBf_GET
#define SD_MIICTLr_SPD_SEL_MSBf_SET BCM89500_A0_SD_MIICTLr_SPD_SEL_MSBf_SET
#define SD_MIICTLr_COL_TESTf_GET BCM89500_A0_SD_MIICTLr_COL_TESTf_GET
#define SD_MIICTLr_COL_TESTf_SET BCM89500_A0_SD_MIICTLr_COL_TESTf_SET
#define SD_MIICTLr_DUPLEX_MODf_GET BCM89500_A0_SD_MIICTLr_DUPLEX_MODf_GET
#define SD_MIICTLr_DUPLEX_MODf_SET BCM89500_A0_SD_MIICTLr_DUPLEX_MODf_SET
#define SD_MIICTLr_RE_ANf_GET BCM89500_A0_SD_MIICTLr_RE_ANf_GET
#define SD_MIICTLr_RE_ANf_SET BCM89500_A0_SD_MIICTLr_RE_ANf_SET
#define SD_MIICTLr_RESERVED_1f_GET BCM89500_A0_SD_MIICTLr_RESERVED_1f_GET
#define SD_MIICTLr_RESERVED_1f_SET BCM89500_A0_SD_MIICTLr_RESERVED_1f_SET
#define SD_MIICTLr_PWR_DOWNf_GET BCM89500_A0_SD_MIICTLr_PWR_DOWNf_GET
#define SD_MIICTLr_PWR_DOWNf_SET BCM89500_A0_SD_MIICTLr_PWR_DOWNf_SET
#define SD_MIICTLr_AN_ENf_GET BCM89500_A0_SD_MIICTLr_AN_ENf_GET
#define SD_MIICTLr_AN_ENf_SET BCM89500_A0_SD_MIICTLr_AN_ENf_SET
#define SD_MIICTLr_SPD_SEL_LSBf_GET BCM89500_A0_SD_MIICTLr_SPD_SEL_LSBf_GET
#define SD_MIICTLr_SPD_SEL_LSBf_SET BCM89500_A0_SD_MIICTLr_SPD_SEL_LSBf_SET
#define SD_MIICTLr_LOOPBACKf_GET BCM89500_A0_SD_MIICTLr_LOOPBACKf_GET
#define SD_MIICTLr_LOOPBACKf_SET BCM89500_A0_SD_MIICTLr_LOOPBACKf_SET
#define SD_MIICTLr_RESETf_GET BCM89500_A0_SD_MIICTLr_RESETf_GET
#define SD_MIICTLr_RESETf_SET BCM89500_A0_SD_MIICTLr_RESETf_SET
#define READ_SD_MIICTLr BCM89500_A0_READ_SD_MIICTLr
#define WRITE_SD_MIICTLr BCM89500_A0_WRITE_SD_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_MIISTS
 * BLOCKS:   SYS
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HDX_CAP   1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FDX_CAP   1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_HDX_CAP     1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100X_HDX_CAP    1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100X_FDX_CAP    1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM89500_A0_SD_MIISTSr 0x00001502

#define BCM89500_A0_SD_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program SD_MIISTS.
 *
 */
typedef union BCM89500_A0_SD_MIISTSr_s {
	uint32_t v[1];
	uint32_t sd_miists[1];
	uint32_t _sd_miists;
} BCM89500_A0_SD_MIISTSr_t;

#define BCM89500_A0_SD_MIISTSr_CLR(r) (r).sd_miists[0] = 0
#define BCM89500_A0_SD_MIISTSr_SET(r,d) (r).sd_miists[0] = d
#define BCM89500_A0_SD_MIISTSr_GET(r) (r).sd_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_MIISTSr_EXT_CAPf_GET(r) (((r).sd_miists[0]) & 0x1)
#define BCM89500_A0_SD_MIISTSr_EXT_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_MIISTSr_JABBER_DETf_GET(r) ((((r).sd_miists[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_MIISTSr_JABBER_DETf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_MIISTSr_LINK_STAf_GET(r) ((((r).sd_miists[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_MIISTSr_LINK_STAf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).sd_miists[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_MIISTSr_REMOTE_FAULTf_GET(r) ((((r).sd_miists[0]) >> 4) & 0x1)
#define BCM89500_A0_SD_MIISTSr_REMOTE_FAULTf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SD_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).sd_miists[0]) >> 5) & 0x1)
#define BCM89500_A0_SD_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SD_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).sd_miists[0]) >> 6) & 0x1)
#define BCM89500_A0_SD_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SD_MIISTSr_RESERVEDf_GET(r) ((((r).sd_miists[0]) >> 7) & 0x1)
#define BCM89500_A0_SD_MIISTSr_RESERVEDf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SD_MIISTSr_EXT_STSf_GET(r) ((((r).sd_miists[0]) >> 8) & 0x1)
#define BCM89500_A0_SD_MIISTSr_EXT_STSf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SD_MIISTSr_B100T2_HDX_CAPf_GET(r) ((((r).sd_miists[0]) >> 9) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B100T2_HDX_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SD_MIISTSr_B100T2_FDX_CAPf_GET(r) ((((r).sd_miists[0]) >> 10) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B100T2_FDX_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SD_MIISTSr_B10T_HDX_CAPf_GET(r) ((((r).sd_miists[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B10T_HDX_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).sd_miists[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_MIISTSr_B100X_HDX_CAPf_GET(r) ((((r).sd_miists[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B100X_HDX_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_MIISTSr_B100X_FDX_CAPf_GET(r) ((((r).sd_miists[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B100X_FDX_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_MIISTSr_B100T4_CAPf_GET(r) ((((r).sd_miists[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_MIISTSr_B100T4_CAPf_SET(r,f) (r).sd_miists[0]=(((r).sd_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_MIISTS.
 *
 */
#define BCM89500_A0_READ_SD_MIISTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_MIISTSr,(r._sd_miists),2)
#define BCM89500_A0_WRITE_SD_MIISTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_MIISTSr,&(r._sd_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_MIISTSr BCM89500_A0_SD_MIISTSr
#define SD_MIISTSr_SIZE BCM89500_A0_SD_MIISTSr_SIZE
typedef BCM89500_A0_SD_MIISTSr_t SD_MIISTSr_t;
#define SD_MIISTSr_CLR BCM89500_A0_SD_MIISTSr_CLR
#define SD_MIISTSr_SET BCM89500_A0_SD_MIISTSr_SET
#define SD_MIISTSr_GET BCM89500_A0_SD_MIISTSr_GET
#define SD_MIISTSr_EXT_CAPf_GET BCM89500_A0_SD_MIISTSr_EXT_CAPf_GET
#define SD_MIISTSr_EXT_CAPf_SET BCM89500_A0_SD_MIISTSr_EXT_CAPf_SET
#define SD_MIISTSr_JABBER_DETf_GET BCM89500_A0_SD_MIISTSr_JABBER_DETf_GET
#define SD_MIISTSr_JABBER_DETf_SET BCM89500_A0_SD_MIISTSr_JABBER_DETf_SET
#define SD_MIISTSr_LINK_STAf_GET BCM89500_A0_SD_MIISTSr_LINK_STAf_GET
#define SD_MIISTSr_LINK_STAf_SET BCM89500_A0_SD_MIISTSr_LINK_STAf_SET
#define SD_MIISTSr_AUTO_NEGO_CAPf_GET BCM89500_A0_SD_MIISTSr_AUTO_NEGO_CAPf_GET
#define SD_MIISTSr_AUTO_NEGO_CAPf_SET BCM89500_A0_SD_MIISTSr_AUTO_NEGO_CAPf_SET
#define SD_MIISTSr_REMOTE_FAULTf_GET BCM89500_A0_SD_MIISTSr_REMOTE_FAULTf_GET
#define SD_MIISTSr_REMOTE_FAULTf_SET BCM89500_A0_SD_MIISTSr_REMOTE_FAULTf_SET
#define SD_MIISTSr_AUTO_NEGO_COMPf_GET BCM89500_A0_SD_MIISTSr_AUTO_NEGO_COMPf_GET
#define SD_MIISTSr_AUTO_NEGO_COMPf_SET BCM89500_A0_SD_MIISTSr_AUTO_NEGO_COMPf_SET
#define SD_MIISTSr_MF_PRE_SUPf_GET BCM89500_A0_SD_MIISTSr_MF_PRE_SUPf_GET
#define SD_MIISTSr_MF_PRE_SUPf_SET BCM89500_A0_SD_MIISTSr_MF_PRE_SUPf_SET
#define SD_MIISTSr_RESERVEDf_GET BCM89500_A0_SD_MIISTSr_RESERVEDf_GET
#define SD_MIISTSr_RESERVEDf_SET BCM89500_A0_SD_MIISTSr_RESERVEDf_SET
#define SD_MIISTSr_EXT_STSf_GET BCM89500_A0_SD_MIISTSr_EXT_STSf_GET
#define SD_MIISTSr_EXT_STSf_SET BCM89500_A0_SD_MIISTSr_EXT_STSf_SET
#define SD_MIISTSr_B100T2_HDX_CAPf_GET BCM89500_A0_SD_MIISTSr_B100T2_HDX_CAPf_GET
#define SD_MIISTSr_B100T2_HDX_CAPf_SET BCM89500_A0_SD_MIISTSr_B100T2_HDX_CAPf_SET
#define SD_MIISTSr_B100T2_FDX_CAPf_GET BCM89500_A0_SD_MIISTSr_B100T2_FDX_CAPf_GET
#define SD_MIISTSr_B100T2_FDX_CAPf_SET BCM89500_A0_SD_MIISTSr_B100T2_FDX_CAPf_SET
#define SD_MIISTSr_B10T_HDX_CAPf_GET BCM89500_A0_SD_MIISTSr_B10T_HDX_CAPf_GET
#define SD_MIISTSr_B10T_HDX_CAPf_SET BCM89500_A0_SD_MIISTSr_B10T_HDX_CAPf_SET
#define SD_MIISTSr_B10T_FDX_CAPf_GET BCM89500_A0_SD_MIISTSr_B10T_FDX_CAPf_GET
#define SD_MIISTSr_B10T_FDX_CAPf_SET BCM89500_A0_SD_MIISTSr_B10T_FDX_CAPf_SET
#define SD_MIISTSr_B100X_HDX_CAPf_GET BCM89500_A0_SD_MIISTSr_B100X_HDX_CAPf_GET
#define SD_MIISTSr_B100X_HDX_CAPf_SET BCM89500_A0_SD_MIISTSr_B100X_HDX_CAPf_SET
#define SD_MIISTSr_B100X_FDX_CAPf_GET BCM89500_A0_SD_MIISTSr_B100X_FDX_CAPf_GET
#define SD_MIISTSr_B100X_FDX_CAPf_SET BCM89500_A0_SD_MIISTSr_B100X_FDX_CAPf_SET
#define SD_MIISTSr_B100T4_CAPf_GET BCM89500_A0_SD_MIISTSr_B100T4_CAPf_GET
#define SD_MIISTSr_B100T4_CAPf_SET BCM89500_A0_SD_MIISTSr_B100T4_CAPf_SET
#define READ_SD_MIISTSr BCM89500_A0_READ_SD_MIISTSr
#define WRITE_SD_MIISTSr BCM89500_A0_WRITE_SD_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_PATGEN_CONTROL
 * BLOCKS:   SYS
 * DESC:     Pattern Generation Control Register
 * SIZE:     16
 * FIELDS:
 *     SEL_PATTERN_GEN_DATA 1 = send idles or pattern generator data into transmit fifo (ignore MAC transmit data)0 = normal operation
 *     RUN_PATTERN_GEN  1 = A rising edge on this bit while the pattern generator is in the idle state will start sending packets. If the single pass mode is set, then a single packet will be sent and the idle state will be entered. If the single pass mode is not set, then packets will be sent until this bit is cleared. At this point the current packet will finish transmitting and then enter the idle state.NOTE: A valid link must be established prior to sending packets.0 = do not send packets
 *     SINGLE_PASS_MODE 1 = only send 1 packet and stop0 = send packets while bit 1 of this register is set
 *     PKT_SIZE         000000 = invalid000001 = 256 bytes000010 = 512 bytes000011 = 768 bytes000100 = 1024 bytes...111111 = 16,128 bytes
 *     IPG_SELECT       000 = invalid001 = ipg of 6 bytes010 = ipg of 10 bytes011 = ipg of 14 bytes100 = ipg of 18 bytes101 = ipg of 22 bytes110 = ipg of 26 bytes111 = ipg of 30 bytes
 *     EN_CRC_CHECKER_FRAGMENT_ERR_DET 1 = enable crc checker to detect crc errors on packets of any size (1 byte or more)0 = normal operation (crc checker only detects crc errors on packets of at least 72 bytes)
 *     SKIP_CRC         1 = do not append 32 bit crc to end of packet0 = normal operation
 *     TX_ERR           1 = set txer=1 during crc portion of packet0 = normal operation
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_PATGEN_CONTROLr 0x00001534

#define BCM89500_A0_SD_PATGEN_CONTROLr_SIZE 2

/*
 * This structure should be used to declare and program SD_PATGEN_CONTROL.
 *
 */
typedef union BCM89500_A0_SD_PATGEN_CONTROLr_s {
	uint32_t v[1];
	uint32_t sd_patgen_control[1];
	uint32_t _sd_patgen_control;
} BCM89500_A0_SD_PATGEN_CONTROLr_t;

#define BCM89500_A0_SD_PATGEN_CONTROLr_CLR(r) (r).sd_patgen_control[0] = 0
#define BCM89500_A0_SD_PATGEN_CONTROLr_SET(r,d) (r).sd_patgen_control[0] = d
#define BCM89500_A0_SD_PATGEN_CONTROLr_GET(r) (r).sd_patgen_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_PATGEN_CONTROLr_SEL_PATTERN_GEN_DATAf_GET(r) (((r).sd_patgen_control[0]) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_SEL_PATTERN_GEN_DATAf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_PATGEN_CONTROLr_RUN_PATTERN_GENf_GET(r) ((((r).sd_patgen_control[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_RUN_PATTERN_GENf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_PATGEN_CONTROLr_SINGLE_PASS_MODEf_GET(r) ((((r).sd_patgen_control[0]) >> 2) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_SINGLE_PASS_MODEf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SD_PATGEN_CONTROLr_PKT_SIZEf_GET(r) ((((r).sd_patgen_control[0]) >> 3) & 0x3f)
#define BCM89500_A0_SD_PATGEN_CONTROLr_PKT_SIZEf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM89500_A0_SD_PATGEN_CONTROLr_IPG_SELECTf_GET(r) ((((r).sd_patgen_control[0]) >> 9) & 0x7)
#define BCM89500_A0_SD_PATGEN_CONTROLr_IPG_SELECTf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM89500_A0_SD_PATGEN_CONTROLr_EN_CRC_CHECKER_FRAGMENT_ERR_DETf_GET(r) ((((r).sd_patgen_control[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_EN_CRC_CHECKER_FRAGMENT_ERR_DETf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_PATGEN_CONTROLr_SKIP_CRCf_GET(r) ((((r).sd_patgen_control[0]) >> 13) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_SKIP_CRCf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SD_PATGEN_CONTROLr_TX_ERRf_GET(r) ((((r).sd_patgen_control[0]) >> 14) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_TX_ERRf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SD_PATGEN_CONTROLr_RESERVEDf_GET(r) ((((r).sd_patgen_control[0]) >> 15) & 0x1)
#define BCM89500_A0_SD_PATGEN_CONTROLr_RESERVEDf_SET(r,f) (r).sd_patgen_control[0]=(((r).sd_patgen_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SD_PATGEN_CONTROL.
 *
 */
#define BCM89500_A0_READ_SD_PATGEN_CONTROLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_PATGEN_CONTROLr,(r._sd_patgen_control),2)
#define BCM89500_A0_WRITE_SD_PATGEN_CONTROLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_PATGEN_CONTROLr,&(r._sd_patgen_control),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_PATGEN_CONTROLr BCM89500_A0_SD_PATGEN_CONTROLr
#define SD_PATGEN_CONTROLr_SIZE BCM89500_A0_SD_PATGEN_CONTROLr_SIZE
typedef BCM89500_A0_SD_PATGEN_CONTROLr_t SD_PATGEN_CONTROLr_t;
#define SD_PATGEN_CONTROLr_CLR BCM89500_A0_SD_PATGEN_CONTROLr_CLR
#define SD_PATGEN_CONTROLr_SET BCM89500_A0_SD_PATGEN_CONTROLr_SET
#define SD_PATGEN_CONTROLr_GET BCM89500_A0_SD_PATGEN_CONTROLr_GET
#define SD_PATGEN_CONTROLr_SEL_PATTERN_GEN_DATAf_GET BCM89500_A0_SD_PATGEN_CONTROLr_SEL_PATTERN_GEN_DATAf_GET
#define SD_PATGEN_CONTROLr_SEL_PATTERN_GEN_DATAf_SET BCM89500_A0_SD_PATGEN_CONTROLr_SEL_PATTERN_GEN_DATAf_SET
#define SD_PATGEN_CONTROLr_RUN_PATTERN_GENf_GET BCM89500_A0_SD_PATGEN_CONTROLr_RUN_PATTERN_GENf_GET
#define SD_PATGEN_CONTROLr_RUN_PATTERN_GENf_SET BCM89500_A0_SD_PATGEN_CONTROLr_RUN_PATTERN_GENf_SET
#define SD_PATGEN_CONTROLr_SINGLE_PASS_MODEf_GET BCM89500_A0_SD_PATGEN_CONTROLr_SINGLE_PASS_MODEf_GET
#define SD_PATGEN_CONTROLr_SINGLE_PASS_MODEf_SET BCM89500_A0_SD_PATGEN_CONTROLr_SINGLE_PASS_MODEf_SET
#define SD_PATGEN_CONTROLr_PKT_SIZEf_GET BCM89500_A0_SD_PATGEN_CONTROLr_PKT_SIZEf_GET
#define SD_PATGEN_CONTROLr_PKT_SIZEf_SET BCM89500_A0_SD_PATGEN_CONTROLr_PKT_SIZEf_SET
#define SD_PATGEN_CONTROLr_IPG_SELECTf_GET BCM89500_A0_SD_PATGEN_CONTROLr_IPG_SELECTf_GET
#define SD_PATGEN_CONTROLr_IPG_SELECTf_SET BCM89500_A0_SD_PATGEN_CONTROLr_IPG_SELECTf_SET
#define SD_PATGEN_CONTROLr_EN_CRC_CHECKER_FRAGMENT_ERR_DETf_GET BCM89500_A0_SD_PATGEN_CONTROLr_EN_CRC_CHECKER_FRAGMENT_ERR_DETf_GET
#define SD_PATGEN_CONTROLr_EN_CRC_CHECKER_FRAGMENT_ERR_DETf_SET BCM89500_A0_SD_PATGEN_CONTROLr_EN_CRC_CHECKER_FRAGMENT_ERR_DETf_SET
#define SD_PATGEN_CONTROLr_SKIP_CRCf_GET BCM89500_A0_SD_PATGEN_CONTROLr_SKIP_CRCf_GET
#define SD_PATGEN_CONTROLr_SKIP_CRCf_SET BCM89500_A0_SD_PATGEN_CONTROLr_SKIP_CRCf_SET
#define SD_PATGEN_CONTROLr_TX_ERRf_GET BCM89500_A0_SD_PATGEN_CONTROLr_TX_ERRf_GET
#define SD_PATGEN_CONTROLr_TX_ERRf_SET BCM89500_A0_SD_PATGEN_CONTROLr_TX_ERRf_SET
#define SD_PATGEN_CONTROLr_RESERVEDf_GET BCM89500_A0_SD_PATGEN_CONTROLr_RESERVEDf_GET
#define SD_PATGEN_CONTROLr_RESERVEDf_SET BCM89500_A0_SD_PATGEN_CONTROLr_RESERVEDf_SET
#define READ_SD_PATGEN_CONTROLr BCM89500_A0_READ_SD_PATGEN_CONTROLr
#define WRITE_SD_PATGEN_CONTROLr BCM89500_A0_WRITE_SD_PATGEN_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_PATGEN_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_PATGEN_STATUS
 * BLOCKS:   SYS
 * DESC:     Pattern Generation Status Register
 * SIZE:     16
 * FIELDS:
 *     PATTERN_GEN_FSM  000 = idle001 = transmit preamble011 = transmit sfd010 = transmit data110 = transmit crc100 = ipg101 = ipg 2 (allows fsm to be grey-coded)
 *     PATTERN_GEN_ACTIVE 1 = pattern generator is still sending packets0 = pattern generator is idle
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_PATGEN_STATUSr 0x00001536

#define BCM89500_A0_SD_PATGEN_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program SD_PATGEN_STATUS.
 *
 */
typedef union BCM89500_A0_SD_PATGEN_STATUSr_s {
	uint32_t v[1];
	uint32_t sd_patgen_status[1];
	uint32_t _sd_patgen_status;
} BCM89500_A0_SD_PATGEN_STATUSr_t;

#define BCM89500_A0_SD_PATGEN_STATUSr_CLR(r) (r).sd_patgen_status[0] = 0
#define BCM89500_A0_SD_PATGEN_STATUSr_SET(r,d) (r).sd_patgen_status[0] = d
#define BCM89500_A0_SD_PATGEN_STATUSr_GET(r) (r).sd_patgen_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_FSMf_GET(r) (((r).sd_patgen_status[0]) & 0x7)
#define BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_FSMf_SET(r,f) (r).sd_patgen_status[0]=(((r).sd_patgen_status[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_ACTIVEf_GET(r) ((((r).sd_patgen_status[0]) >> 3) & 0x1)
#define BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_ACTIVEf_SET(r,f) (r).sd_patgen_status[0]=(((r).sd_patgen_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SD_PATGEN_STATUSr_RESERVEDf_GET(r) ((((r).sd_patgen_status[0]) >> 4) & 0xfff)
#define BCM89500_A0_SD_PATGEN_STATUSr_RESERVEDf_SET(r,f) (r).sd_patgen_status[0]=(((r).sd_patgen_status[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access SD_PATGEN_STATUS.
 *
 */
#define BCM89500_A0_READ_SD_PATGEN_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_PATGEN_STATUSr,(r._sd_patgen_status),2)
#define BCM89500_A0_WRITE_SD_PATGEN_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_PATGEN_STATUSr,&(r._sd_patgen_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_PATGEN_STATUSr BCM89500_A0_SD_PATGEN_STATUSr
#define SD_PATGEN_STATUSr_SIZE BCM89500_A0_SD_PATGEN_STATUSr_SIZE
typedef BCM89500_A0_SD_PATGEN_STATUSr_t SD_PATGEN_STATUSr_t;
#define SD_PATGEN_STATUSr_CLR BCM89500_A0_SD_PATGEN_STATUSr_CLR
#define SD_PATGEN_STATUSr_SET BCM89500_A0_SD_PATGEN_STATUSr_SET
#define SD_PATGEN_STATUSr_GET BCM89500_A0_SD_PATGEN_STATUSr_GET
#define SD_PATGEN_STATUSr_PATTERN_GEN_FSMf_GET BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_FSMf_GET
#define SD_PATGEN_STATUSr_PATTERN_GEN_FSMf_SET BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_FSMf_SET
#define SD_PATGEN_STATUSr_PATTERN_GEN_ACTIVEf_GET BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_ACTIVEf_GET
#define SD_PATGEN_STATUSr_PATTERN_GEN_ACTIVEf_SET BCM89500_A0_SD_PATGEN_STATUSr_PATTERN_GEN_ACTIVEf_SET
#define SD_PATGEN_STATUSr_RESERVEDf_GET BCM89500_A0_SD_PATGEN_STATUSr_RESERVEDf_GET
#define SD_PATGEN_STATUSr_RESERVEDf_SET BCM89500_A0_SD_PATGEN_STATUSr_RESERVEDf_SET
#define READ_SD_PATGEN_STATUSr BCM89500_A0_READ_SD_PATGEN_STATUSr
#define WRITE_SD_PATGEN_STATUSr BCM89500_A0_WRITE_SD_PATGEN_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_PATGEN_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_PHYIDH
 * BLOCKS:   SYS
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_PHYIDHr 0x00001504

#define BCM89500_A0_SD_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program SD_PHYIDH.
 *
 */
typedef union BCM89500_A0_SD_PHYIDHr_s {
	uint32_t v[1];
	uint32_t sd_phyidh[1];
	uint32_t _sd_phyidh;
} BCM89500_A0_SD_PHYIDHr_t;

#define BCM89500_A0_SD_PHYIDHr_CLR(r) (r).sd_phyidh[0] = 0
#define BCM89500_A0_SD_PHYIDHr_SET(r,d) (r).sd_phyidh[0] = d
#define BCM89500_A0_SD_PHYIDHr_GET(r) (r).sd_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_PHYIDHr_OUIf_GET(r) (((r).sd_phyidh[0]) & 0xffff)
#define BCM89500_A0_SD_PHYIDHr_OUIf_SET(r,f) (r).sd_phyidh[0]=(((r).sd_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SD_PHYIDH.
 *
 */
#define BCM89500_A0_READ_SD_PHYIDHr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_PHYIDHr,(r._sd_phyidh),2)
#define BCM89500_A0_WRITE_SD_PHYIDHr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_PHYIDHr,&(r._sd_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_PHYIDHr BCM89500_A0_SD_PHYIDHr
#define SD_PHYIDHr_SIZE BCM89500_A0_SD_PHYIDHr_SIZE
typedef BCM89500_A0_SD_PHYIDHr_t SD_PHYIDHr_t;
#define SD_PHYIDHr_CLR BCM89500_A0_SD_PHYIDHr_CLR
#define SD_PHYIDHr_SET BCM89500_A0_SD_PHYIDHr_SET
#define SD_PHYIDHr_GET BCM89500_A0_SD_PHYIDHr_GET
#define SD_PHYIDHr_OUIf_GET BCM89500_A0_SD_PHYIDHr_OUIf_GET
#define SD_PHYIDHr_OUIf_SET BCM89500_A0_SD_PHYIDHr_OUIf_SET
#define READ_SD_PHYIDHr BCM89500_A0_READ_SD_PHYIDHr
#define WRITE_SD_PHYIDHr BCM89500_A0_WRITE_SD_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_PHYIDL
 * BLOCKS:   SYS
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Chip Version ID.Bit 3:2 - Revision ID-00 = A-01 = B-10 = C-11 = DBit 1:0 - Revision number
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_PHYIDLr 0x00001506

#define BCM89500_A0_SD_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program SD_PHYIDL.
 *
 */
typedef union BCM89500_A0_SD_PHYIDLr_s {
	uint32_t v[1];
	uint32_t sd_phyidl[1];
	uint32_t _sd_phyidl;
} BCM89500_A0_SD_PHYIDLr_t;

#define BCM89500_A0_SD_PHYIDLr_CLR(r) (r).sd_phyidl[0] = 0
#define BCM89500_A0_SD_PHYIDLr_SET(r,d) (r).sd_phyidl[0] = d
#define BCM89500_A0_SD_PHYIDLr_GET(r) (r).sd_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_PHYIDLr_REVISIONf_GET(r) (((r).sd_phyidl[0]) & 0xf)
#define BCM89500_A0_SD_PHYIDLr_REVISIONf_SET(r,f) (r).sd_phyidl[0]=(((r).sd_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_SD_PHYIDLr_MODELf_GET(r) ((((r).sd_phyidl[0]) >> 4) & 0x3f)
#define BCM89500_A0_SD_PHYIDLr_MODELf_SET(r,f) (r).sd_phyidl[0]=(((r).sd_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM89500_A0_SD_PHYIDLr_OUIf_GET(r) ((((r).sd_phyidl[0]) >> 10) & 0x3f)
#define BCM89500_A0_SD_PHYIDLr_OUIf_SET(r,f) (r).sd_phyidl[0]=(((r).sd_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access SD_PHYIDL.
 *
 */
#define BCM89500_A0_READ_SD_PHYIDLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_PHYIDLr,(r._sd_phyidl),2)
#define BCM89500_A0_WRITE_SD_PHYIDLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_PHYIDLr,&(r._sd_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_PHYIDLr BCM89500_A0_SD_PHYIDLr
#define SD_PHYIDLr_SIZE BCM89500_A0_SD_PHYIDLr_SIZE
typedef BCM89500_A0_SD_PHYIDLr_t SD_PHYIDLr_t;
#define SD_PHYIDLr_CLR BCM89500_A0_SD_PHYIDLr_CLR
#define SD_PHYIDLr_SET BCM89500_A0_SD_PHYIDLr_SET
#define SD_PHYIDLr_GET BCM89500_A0_SD_PHYIDLr_GET
#define SD_PHYIDLr_REVISIONf_GET BCM89500_A0_SD_PHYIDLr_REVISIONf_GET
#define SD_PHYIDLr_REVISIONf_SET BCM89500_A0_SD_PHYIDLr_REVISIONf_SET
#define SD_PHYIDLr_MODELf_GET BCM89500_A0_SD_PHYIDLr_MODELf_GET
#define SD_PHYIDLr_MODELf_SET BCM89500_A0_SD_PHYIDLr_MODELf_SET
#define SD_PHYIDLr_OUIf_GET BCM89500_A0_SD_PHYIDLr_OUIf_GET
#define SD_PHYIDLr_OUIf_SET BCM89500_A0_SD_PHYIDLr_OUIf_SET
#define READ_SD_PHYIDLr BCM89500_A0_READ_SD_PHYIDLr
#define WRITE_SD_PHYIDLr BCM89500_A0_WRITE_SD_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_PRBS_CONTROL
 * BLOCKS:   SYS
 * DESC:     PRBS Control Register
 * SIZE:     16
 * FIELDS:
 *     PRBS_EN          1 = enable PRBS0 = disable PRBS
 *     INVERT_PRBS_ORDER 1 = invert polynomial sequence0 = normal operation
 *     PRBS_ORDER       11 = x(n) = 1 + x(28) + x(31)10 = x(n) = 1 + x(18) + x(23)01 = x(n) = 1 + x(14) + x(15)00 = x(n) = 1 + x(6) + x(7)
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_PRBS_CONTROLr 0x00001530

#define BCM89500_A0_SD_PRBS_CONTROLr_SIZE 2

/*
 * This structure should be used to declare and program SD_PRBS_CONTROL.
 *
 */
typedef union BCM89500_A0_SD_PRBS_CONTROLr_s {
	uint32_t v[1];
	uint32_t sd_prbs_control[1];
	uint32_t _sd_prbs_control;
} BCM89500_A0_SD_PRBS_CONTROLr_t;

#define BCM89500_A0_SD_PRBS_CONTROLr_CLR(r) (r).sd_prbs_control[0] = 0
#define BCM89500_A0_SD_PRBS_CONTROLr_SET(r,d) (r).sd_prbs_control[0] = d
#define BCM89500_A0_SD_PRBS_CONTROLr_GET(r) (r).sd_prbs_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ENf_GET(r) (((r).sd_prbs_control[0]) & 0x1)
#define BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ENf_SET(r,f) (r).sd_prbs_control[0]=(((r).sd_prbs_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SD_PRBS_CONTROLr_INVERT_PRBS_ORDERf_GET(r) ((((r).sd_prbs_control[0]) >> 1) & 0x1)
#define BCM89500_A0_SD_PRBS_CONTROLr_INVERT_PRBS_ORDERf_SET(r,f) (r).sd_prbs_control[0]=(((r).sd_prbs_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ORDERf_GET(r) ((((r).sd_prbs_control[0]) >> 2) & 0x3)
#define BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ORDERf_SET(r,f) (r).sd_prbs_control[0]=(((r).sd_prbs_control[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_SD_PRBS_CONTROLr_RESERVEDf_GET(r) ((((r).sd_prbs_control[0]) >> 4) & 0xfff)
#define BCM89500_A0_SD_PRBS_CONTROLr_RESERVEDf_SET(r,f) (r).sd_prbs_control[0]=(((r).sd_prbs_control[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access SD_PRBS_CONTROL.
 *
 */
#define BCM89500_A0_READ_SD_PRBS_CONTROLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_PRBS_CONTROLr,(r._sd_prbs_control),2)
#define BCM89500_A0_WRITE_SD_PRBS_CONTROLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_PRBS_CONTROLr,&(r._sd_prbs_control),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_PRBS_CONTROLr BCM89500_A0_SD_PRBS_CONTROLr
#define SD_PRBS_CONTROLr_SIZE BCM89500_A0_SD_PRBS_CONTROLr_SIZE
typedef BCM89500_A0_SD_PRBS_CONTROLr_t SD_PRBS_CONTROLr_t;
#define SD_PRBS_CONTROLr_CLR BCM89500_A0_SD_PRBS_CONTROLr_CLR
#define SD_PRBS_CONTROLr_SET BCM89500_A0_SD_PRBS_CONTROLr_SET
#define SD_PRBS_CONTROLr_GET BCM89500_A0_SD_PRBS_CONTROLr_GET
#define SD_PRBS_CONTROLr_PRBS_ENf_GET BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ENf_GET
#define SD_PRBS_CONTROLr_PRBS_ENf_SET BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ENf_SET
#define SD_PRBS_CONTROLr_INVERT_PRBS_ORDERf_GET BCM89500_A0_SD_PRBS_CONTROLr_INVERT_PRBS_ORDERf_GET
#define SD_PRBS_CONTROLr_INVERT_PRBS_ORDERf_SET BCM89500_A0_SD_PRBS_CONTROLr_INVERT_PRBS_ORDERf_SET
#define SD_PRBS_CONTROLr_PRBS_ORDERf_GET BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ORDERf_GET
#define SD_PRBS_CONTROLr_PRBS_ORDERf_SET BCM89500_A0_SD_PRBS_CONTROLr_PRBS_ORDERf_SET
#define SD_PRBS_CONTROLr_RESERVEDf_GET BCM89500_A0_SD_PRBS_CONTROLr_RESERVEDf_GET
#define SD_PRBS_CONTROLr_RESERVEDf_SET BCM89500_A0_SD_PRBS_CONTROLr_RESERVEDf_SET
#define READ_SD_PRBS_CONTROLr BCM89500_A0_READ_SD_PRBS_CONTROLr
#define WRITE_SD_PRBS_CONTROLr BCM89500_A0_WRITE_SD_PRBS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_PRBS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_PRBS_STATUS
 * BLOCKS:   SYS
 * DESC:     PRBS Status Register
 * SIZE:     16
 * FIELDS:
 *     PRBS_ERRORS      Number of PRBS errors detected while locked. Freezes at 7ffh.NOTE: counter is not synchronized to read status clock. The counter might increment while reading, causing inaccurate results. The PRBS should be disabled before reading the 11 bit error counter.
 *     PRBS_LOCKED      1 = PRBS monitor is locked0 = PRBS monitor is not locked
 *     PRBS_LOST_LOCK   1 = PRBS has lost lock since last read0 = PRBS has not lost lock since last read
 *     PRBS_ERR_STATE   Grey coded FSM:100 = 1024 or more errors101 = 512-1023 errors111 = 256-511 errors110 = 128-255 errors010 = 64-127 errors011 = 32-63 errors001 = 1-31 errors000 = no errorsClear on read.
 *
 ******************************************************************************/
#define BCM89500_A0_SD_PRBS_STATUSr 0x00001532

#define BCM89500_A0_SD_PRBS_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program SD_PRBS_STATUS.
 *
 */
typedef union BCM89500_A0_SD_PRBS_STATUSr_s {
	uint32_t v[1];
	uint32_t sd_prbs_status[1];
	uint32_t _sd_prbs_status;
} BCM89500_A0_SD_PRBS_STATUSr_t;

#define BCM89500_A0_SD_PRBS_STATUSr_CLR(r) (r).sd_prbs_status[0] = 0
#define BCM89500_A0_SD_PRBS_STATUSr_SET(r,d) (r).sd_prbs_status[0] = d
#define BCM89500_A0_SD_PRBS_STATUSr_GET(r) (r).sd_prbs_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERRORSf_GET(r) (((r).sd_prbs_status[0]) & 0x7ff)
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERRORSf_SET(r,f) (r).sd_prbs_status[0]=(((r).sd_prbs_status[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOCKEDf_GET(r) ((((r).sd_prbs_status[0]) >> 11) & 0x1)
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOCKEDf_SET(r,f) (r).sd_prbs_status[0]=(((r).sd_prbs_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOST_LOCKf_GET(r) ((((r).sd_prbs_status[0]) >> 12) & 0x1)
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOST_LOCKf_SET(r,f) (r).sd_prbs_status[0]=(((r).sd_prbs_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERR_STATEf_GET(r) ((((r).sd_prbs_status[0]) >> 13) & 0x7)
#define BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERR_STATEf_SET(r,f) (r).sd_prbs_status[0]=(((r).sd_prbs_status[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access SD_PRBS_STATUS.
 *
 */
#define BCM89500_A0_READ_SD_PRBS_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_PRBS_STATUSr,(r._sd_prbs_status),2)
#define BCM89500_A0_WRITE_SD_PRBS_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_PRBS_STATUSr,&(r._sd_prbs_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_PRBS_STATUSr BCM89500_A0_SD_PRBS_STATUSr
#define SD_PRBS_STATUSr_SIZE BCM89500_A0_SD_PRBS_STATUSr_SIZE
typedef BCM89500_A0_SD_PRBS_STATUSr_t SD_PRBS_STATUSr_t;
#define SD_PRBS_STATUSr_CLR BCM89500_A0_SD_PRBS_STATUSr_CLR
#define SD_PRBS_STATUSr_SET BCM89500_A0_SD_PRBS_STATUSr_SET
#define SD_PRBS_STATUSr_GET BCM89500_A0_SD_PRBS_STATUSr_GET
#define SD_PRBS_STATUSr_PRBS_ERRORSf_GET BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERRORSf_GET
#define SD_PRBS_STATUSr_PRBS_ERRORSf_SET BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERRORSf_SET
#define SD_PRBS_STATUSr_PRBS_LOCKEDf_GET BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOCKEDf_GET
#define SD_PRBS_STATUSr_PRBS_LOCKEDf_SET BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOCKEDf_SET
#define SD_PRBS_STATUSr_PRBS_LOST_LOCKf_GET BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOST_LOCKf_GET
#define SD_PRBS_STATUSr_PRBS_LOST_LOCKf_SET BCM89500_A0_SD_PRBS_STATUSr_PRBS_LOST_LOCKf_SET
#define SD_PRBS_STATUSr_PRBS_ERR_STATEf_GET BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERR_STATEf_GET
#define SD_PRBS_STATUSr_PRBS_ERR_STATEf_SET BCM89500_A0_SD_PRBS_STATUSr_PRBS_ERR_STATEf_SET
#define READ_SD_PRBS_STATUSr BCM89500_A0_READ_SD_PRBS_STATUSr
#define WRITE_SD_PRBS_STATUSr BCM89500_A0_WRITE_SD_PRBS_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_PRBS_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SD_TEST_MODE
 * BLOCKS:   SYS
 * DESC:     Test Mode Registers
 * SIZE:     16
 * FIELDS:
 *     TEST_MONITOR_MODE1 select test mode for tpout[11:0]; see testability document for details.
 *     TEST_MONITOR_MODE2 select test mode for tpout[23:12]; see testability document for details.
 *     RESERVED         write as 0, ignore on read
 *
 ******************************************************************************/
#define BCM89500_A0_SD_TEST_MODEr 0x00001538

#define BCM89500_A0_SD_TEST_MODEr_SIZE 2

/*
 * This structure should be used to declare and program SD_TEST_MODE.
 *
 */
typedef union BCM89500_A0_SD_TEST_MODEr_s {
	uint32_t v[1];
	uint32_t sd_test_mode[1];
	uint32_t _sd_test_mode;
} BCM89500_A0_SD_TEST_MODEr_t;

#define BCM89500_A0_SD_TEST_MODEr_CLR(r) (r).sd_test_mode[0] = 0
#define BCM89500_A0_SD_TEST_MODEr_SET(r,d) (r).sd_test_mode[0] = d
#define BCM89500_A0_SD_TEST_MODEr_GET(r) (r).sd_test_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE1f_GET(r) (((r).sd_test_mode[0]) & 0x3f)
#define BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE1f_SET(r,f) (r).sd_test_mode[0]=(((r).sd_test_mode[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE2f_GET(r) ((((r).sd_test_mode[0]) >> 6) & 0x3f)
#define BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE2f_SET(r,f) (r).sd_test_mode[0]=(((r).sd_test_mode[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM89500_A0_SD_TEST_MODEr_RESERVEDf_GET(r) ((((r).sd_test_mode[0]) >> 12) & 0xf)
#define BCM89500_A0_SD_TEST_MODEr_RESERVEDf_SET(r,f) (r).sd_test_mode[0]=(((r).sd_test_mode[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access SD_TEST_MODE.
 *
 */
#define BCM89500_A0_READ_SD_TEST_MODEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SD_TEST_MODEr,(r._sd_test_mode),2)
#define BCM89500_A0_WRITE_SD_TEST_MODEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SD_TEST_MODEr,&(r._sd_test_mode),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SD_TEST_MODEr BCM89500_A0_SD_TEST_MODEr
#define SD_TEST_MODEr_SIZE BCM89500_A0_SD_TEST_MODEr_SIZE
typedef BCM89500_A0_SD_TEST_MODEr_t SD_TEST_MODEr_t;
#define SD_TEST_MODEr_CLR BCM89500_A0_SD_TEST_MODEr_CLR
#define SD_TEST_MODEr_SET BCM89500_A0_SD_TEST_MODEr_SET
#define SD_TEST_MODEr_GET BCM89500_A0_SD_TEST_MODEr_GET
#define SD_TEST_MODEr_TEST_MONITOR_MODE1f_GET BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE1f_GET
#define SD_TEST_MODEr_TEST_MONITOR_MODE1f_SET BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE1f_SET
#define SD_TEST_MODEr_TEST_MONITOR_MODE2f_GET BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE2f_GET
#define SD_TEST_MODEr_TEST_MONITOR_MODE2f_SET BCM89500_A0_SD_TEST_MODEr_TEST_MONITOR_MODE2f_SET
#define SD_TEST_MODEr_RESERVEDf_GET BCM89500_A0_SD_TEST_MODEr_RESERVEDf_GET
#define SD_TEST_MODEr_RESERVEDf_SET BCM89500_A0_SD_TEST_MODEr_RESERVEDf_SET
#define READ_SD_TEST_MODEr BCM89500_A0_READ_SD_TEST_MODEr
#define WRITE_SD_TEST_MODEr BCM89500_A0_WRITE_SD_TEST_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SD_TEST_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SFT_LRN_CTL
 * BLOCKS:   SYS
 * DESC:     Software Learning Control
 * SIZE:     16
 * FIELDS:
 *     SW_LEARN_CNTL    bit[8] : Port 8.bit[7] : Port 7.bit[5:0] : Port 5-0.1: Software learning control enabled.The behaviors are as follows. a. Forwarding behavior: Incoming packet with unknown SA will be copied to CPU port. b. Learning behavior: Alow S/W to decide whether incoming packet learn or not. In S/W learning mode, the H/W learning mechnism will be disabled automatically. c. Refreshed behavior: Allow refreshed mechnism to operate properly even through the H/W learning had been disabled.This field makes no effect if the disable learning is enable(page 00h, addr 3Ch)It is not allowed to enable software learning for WAN port, since all frames from WAN port are already sent to IMP port.0: Software learning control disabled.Forwarding/Learning/Refreshed behavior to keep hardware operation.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SFT_LRN_CTLr 0x0000003e

#define BCM89500_A0_SFT_LRN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program SFT_LRN_CTL.
 *
 */
typedef union BCM89500_A0_SFT_LRN_CTLr_s {
	uint32_t v[1];
	uint32_t sft_lrn_ctl[1];
	uint32_t _sft_lrn_ctl;
} BCM89500_A0_SFT_LRN_CTLr_t;

#define BCM89500_A0_SFT_LRN_CTLr_CLR(r) (r).sft_lrn_ctl[0] = 0
#define BCM89500_A0_SFT_LRN_CTLr_SET(r,d) (r).sft_lrn_ctl[0] = d
#define BCM89500_A0_SFT_LRN_CTLr_GET(r) (r).sft_lrn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET(r) (((r).sft_lrn_ctl[0]) & 0x1ff)
#define BCM89500_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_SFT_LRN_CTLr_RESERVEDf_GET(r) ((((r).sft_lrn_ctl[0]) >> 9) & 0x7f)
#define BCM89500_A0_SFT_LRN_CTLr_RESERVEDf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SFT_LRN_CTL.
 *
 */
#define BCM89500_A0_READ_SFT_LRN_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SFT_LRN_CTLr,(r._sft_lrn_ctl),2)
#define BCM89500_A0_WRITE_SFT_LRN_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SFT_LRN_CTLr,&(r._sft_lrn_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFT_LRN_CTLr BCM89500_A0_SFT_LRN_CTLr
#define SFT_LRN_CTLr_SIZE BCM89500_A0_SFT_LRN_CTLr_SIZE
typedef BCM89500_A0_SFT_LRN_CTLr_t SFT_LRN_CTLr_t;
#define SFT_LRN_CTLr_CLR BCM89500_A0_SFT_LRN_CTLr_CLR
#define SFT_LRN_CTLr_SET BCM89500_A0_SFT_LRN_CTLr_SET
#define SFT_LRN_CTLr_GET BCM89500_A0_SFT_LRN_CTLr_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_GET BCM89500_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_SET BCM89500_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET
#define SFT_LRN_CTLr_RESERVEDf_GET BCM89500_A0_SFT_LRN_CTLr_RESERVEDf_GET
#define SFT_LRN_CTLr_RESERVEDf_SET BCM89500_A0_SFT_LRN_CTLr_RESERVEDf_SET
#define READ_SFT_LRN_CTLr BCM89500_A0_READ_SFT_LRN_CTLr
#define WRITE_SFT_LRN_CTLr BCM89500_A0_WRITE_SFT_LRN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SFT_LRN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SHD_CTL
 * BLOCKS:   SYS
 * DESC:     Shadow Register Control Registers
 * SIZE:     16
 * FIELDS:
 *     DPLL_K1_CTRL     Field DPLL K1 control bit0 - reset load bit after load complete1 - don' reset load bit
 *     DPLL_K2_CTRL     Field DPLL K2 control bit0 - reset load bit after load complete1 - don' reset load bit
 *     DPLL_K3_CTRL     Field DPLL K3 control bit0 - reset load bit after load complete1 - don' reset load bit
 *     DPLL_REF_PHASE_DELTA_CTRL Field DPLL reference phase delta control bit0 - reset load bit after load complete1 - don' reset load bit
 *     DPLL_REF_PHASE_CTRL Field DPLL reference phase control bit0 - reset load bit after load complete1 - don' reset load bit
 *     DPLL_LOOP_FILTER_CTRL Field DPLL loop filter control bit0 - reset load bit after load complete1 - don' reset load bit
 *     FREQ_CTRL        Field frequency control bit0 - reset load bit after load complete1 - don' reset load bit
 *     LOCAL_TIME_CTRL  Field local time control bit0 - reset load bit after load complete1 - don' reset load bit
 *     NCO_DIVIDER_CTRL Field NCO divider control bit0 - reset load bit after load complete1 - don' reset load bit
 *     SYNCOUT_CTRL     Field sync out control bit0 - reset load bit after load complete1 - don' reset load bit
 *     TIME_CODE_CTRL   Field time code control bit0 - reset load bit after load complete1 - don' reset load bit
 *     IEEE1588_TIME_CODE_CTRL Field IEEE1588 time code control bit0 - reset load bit after load complete1 - don' reset load bit
 *     F13_C            Field 13 control bit0 - reset load bit after load complete1 - don' reset load bit
 *     F14_C            Field 14 control bit0 - reset load bit after load complete1 - don' reset load bit
 *     F15_C            Field 15 control bit0 - reset load bit after load complete1 - don' reset load bit
 *     F16_C            Field 16 control bit0 - reset load bit after load complete1 - don' reset load bit
 *
 ******************************************************************************/
#define BCM89500_A0_SHD_CTLr 0x00009398

#define BCM89500_A0_SHD_CTLr_SIZE 2

/*
 * This structure should be used to declare and program SHD_CTL.
 *
 */
typedef union BCM89500_A0_SHD_CTLr_s {
	uint32_t v[1];
	uint32_t shd_ctl[1];
	uint32_t _shd_ctl;
} BCM89500_A0_SHD_CTLr_t;

#define BCM89500_A0_SHD_CTLr_CLR(r) (r).shd_ctl[0] = 0
#define BCM89500_A0_SHD_CTLr_SET(r,d) (r).shd_ctl[0] = d
#define BCM89500_A0_SHD_CTLr_GET(r) (r).shd_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SHD_CTLr_DPLL_K1_CTRLf_GET(r) (((r).shd_ctl[0]) & 0x1)
#define BCM89500_A0_SHD_CTLr_DPLL_K1_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SHD_CTLr_DPLL_K2_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_SHD_CTLr_DPLL_K2_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SHD_CTLr_DPLL_K3_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_SHD_CTLr_DPLL_K3_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_DELTA_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_DELTA_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SHD_CTLr_DPLL_LOOP_FILTER_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_SHD_CTLr_DPLL_LOOP_FILTER_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SHD_CTLr_FREQ_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_SHD_CTLr_FREQ_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SHD_CTLr_LOCAL_TIME_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_SHD_CTLr_LOCAL_TIME_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SHD_CTLr_NCO_DIVIDER_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 8) & 0x1)
#define BCM89500_A0_SHD_CTLr_NCO_DIVIDER_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SHD_CTLr_SYNCOUT_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 9) & 0x1)
#define BCM89500_A0_SHD_CTLr_SYNCOUT_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SHD_CTLr_TIME_CODE_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 10) & 0x1)
#define BCM89500_A0_SHD_CTLr_TIME_CODE_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SHD_CTLr_IEEE1588_TIME_CODE_CTRLf_GET(r) ((((r).shd_ctl[0]) >> 11) & 0x1)
#define BCM89500_A0_SHD_CTLr_IEEE1588_TIME_CODE_CTRLf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SHD_CTLr_F13_Cf_GET(r) ((((r).shd_ctl[0]) >> 12) & 0x1)
#define BCM89500_A0_SHD_CTLr_F13_Cf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SHD_CTLr_F14_Cf_GET(r) ((((r).shd_ctl[0]) >> 13) & 0x1)
#define BCM89500_A0_SHD_CTLr_F14_Cf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SHD_CTLr_F15_Cf_GET(r) ((((r).shd_ctl[0]) >> 14) & 0x1)
#define BCM89500_A0_SHD_CTLr_F15_Cf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SHD_CTLr_F16_Cf_GET(r) ((((r).shd_ctl[0]) >> 15) & 0x1)
#define BCM89500_A0_SHD_CTLr_F16_Cf_SET(r,f) (r).shd_ctl[0]=(((r).shd_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SHD_CTL.
 *
 */
#define BCM89500_A0_READ_SHD_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SHD_CTLr,(r._shd_ctl),2)
#define BCM89500_A0_WRITE_SHD_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SHD_CTLr,&(r._shd_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SHD_CTLr BCM89500_A0_SHD_CTLr
#define SHD_CTLr_SIZE BCM89500_A0_SHD_CTLr_SIZE
typedef BCM89500_A0_SHD_CTLr_t SHD_CTLr_t;
#define SHD_CTLr_CLR BCM89500_A0_SHD_CTLr_CLR
#define SHD_CTLr_SET BCM89500_A0_SHD_CTLr_SET
#define SHD_CTLr_GET BCM89500_A0_SHD_CTLr_GET
#define SHD_CTLr_DPLL_K1_CTRLf_GET BCM89500_A0_SHD_CTLr_DPLL_K1_CTRLf_GET
#define SHD_CTLr_DPLL_K1_CTRLf_SET BCM89500_A0_SHD_CTLr_DPLL_K1_CTRLf_SET
#define SHD_CTLr_DPLL_K2_CTRLf_GET BCM89500_A0_SHD_CTLr_DPLL_K2_CTRLf_GET
#define SHD_CTLr_DPLL_K2_CTRLf_SET BCM89500_A0_SHD_CTLr_DPLL_K2_CTRLf_SET
#define SHD_CTLr_DPLL_K3_CTRLf_GET BCM89500_A0_SHD_CTLr_DPLL_K3_CTRLf_GET
#define SHD_CTLr_DPLL_K3_CTRLf_SET BCM89500_A0_SHD_CTLr_DPLL_K3_CTRLf_SET
#define SHD_CTLr_DPLL_REF_PHASE_DELTA_CTRLf_GET BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_DELTA_CTRLf_GET
#define SHD_CTLr_DPLL_REF_PHASE_DELTA_CTRLf_SET BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_DELTA_CTRLf_SET
#define SHD_CTLr_DPLL_REF_PHASE_CTRLf_GET BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_CTRLf_GET
#define SHD_CTLr_DPLL_REF_PHASE_CTRLf_SET BCM89500_A0_SHD_CTLr_DPLL_REF_PHASE_CTRLf_SET
#define SHD_CTLr_DPLL_LOOP_FILTER_CTRLf_GET BCM89500_A0_SHD_CTLr_DPLL_LOOP_FILTER_CTRLf_GET
#define SHD_CTLr_DPLL_LOOP_FILTER_CTRLf_SET BCM89500_A0_SHD_CTLr_DPLL_LOOP_FILTER_CTRLf_SET
#define SHD_CTLr_FREQ_CTRLf_GET BCM89500_A0_SHD_CTLr_FREQ_CTRLf_GET
#define SHD_CTLr_FREQ_CTRLf_SET BCM89500_A0_SHD_CTLr_FREQ_CTRLf_SET
#define SHD_CTLr_LOCAL_TIME_CTRLf_GET BCM89500_A0_SHD_CTLr_LOCAL_TIME_CTRLf_GET
#define SHD_CTLr_LOCAL_TIME_CTRLf_SET BCM89500_A0_SHD_CTLr_LOCAL_TIME_CTRLf_SET
#define SHD_CTLr_NCO_DIVIDER_CTRLf_GET BCM89500_A0_SHD_CTLr_NCO_DIVIDER_CTRLf_GET
#define SHD_CTLr_NCO_DIVIDER_CTRLf_SET BCM89500_A0_SHD_CTLr_NCO_DIVIDER_CTRLf_SET
#define SHD_CTLr_SYNCOUT_CTRLf_GET BCM89500_A0_SHD_CTLr_SYNCOUT_CTRLf_GET
#define SHD_CTLr_SYNCOUT_CTRLf_SET BCM89500_A0_SHD_CTLr_SYNCOUT_CTRLf_SET
#define SHD_CTLr_TIME_CODE_CTRLf_GET BCM89500_A0_SHD_CTLr_TIME_CODE_CTRLf_GET
#define SHD_CTLr_TIME_CODE_CTRLf_SET BCM89500_A0_SHD_CTLr_TIME_CODE_CTRLf_SET
#define SHD_CTLr_IEEE1588_TIME_CODE_CTRLf_GET BCM89500_A0_SHD_CTLr_IEEE1588_TIME_CODE_CTRLf_GET
#define SHD_CTLr_IEEE1588_TIME_CODE_CTRLf_SET BCM89500_A0_SHD_CTLr_IEEE1588_TIME_CODE_CTRLf_SET
#define SHD_CTLr_F13_Cf_GET BCM89500_A0_SHD_CTLr_F13_Cf_GET
#define SHD_CTLr_F13_Cf_SET BCM89500_A0_SHD_CTLr_F13_Cf_SET
#define SHD_CTLr_F14_Cf_GET BCM89500_A0_SHD_CTLr_F14_Cf_GET
#define SHD_CTLr_F14_Cf_SET BCM89500_A0_SHD_CTLr_F14_Cf_SET
#define SHD_CTLr_F15_Cf_GET BCM89500_A0_SHD_CTLr_F15_Cf_GET
#define SHD_CTLr_F15_Cf_SET BCM89500_A0_SHD_CTLr_F15_Cf_SET
#define SHD_CTLr_F16_Cf_GET BCM89500_A0_SHD_CTLr_F16_Cf_GET
#define SHD_CTLr_F16_Cf_SET BCM89500_A0_SHD_CTLr_F16_Cf_SET
#define READ_SHD_CTLr BCM89500_A0_READ_SHD_CTLr
#define WRITE_SHD_CTLr BCM89500_A0_WRITE_SHD_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SHD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SHD_LD
 * BLOCKS:   SYS
 * DESC:     Shadow Register Load Registers
 * SIZE:     16
 * FIELDS:
 *     DPLL_K1_LOAD     Field DPLL K1 load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     DPLL_K2_LOAD     Field DPLL K2 load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     DPLL_K3_LOAD     Field DPLL K3 load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     DPLL_REF_PHASE_DELTA_LOAD Field DPLL reference phase delta load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     DPLL_REF_PHASE_LOAD Field DPLL reference phase load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     DPLL_LOOP_FILTER_LOAD Field DPLL loop filter load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     FREQ_LOAD        Field frequency load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     LOCAL_TIME_LOAD  Field local time load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     NCO_DIVIDER_LOAD Field NCO divider load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     SYNCOUT_LOAD     Field sync out load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     TIME_CODE_LOAD   Field time code load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     IEEE1588_TIME_CODE_LOAD Field IEEE1588 time code load bit1'b1: keep trigger every time event occurs.1'b0: reset trigger. only do event once on trigger.
 *     F13_L            Field 13 load bit
 *     F14_L            Field 14 load bit
 *     F15_L            Field 15 load bit
 *     F16_L            Field 16 load bit
 *
 ******************************************************************************/
#define BCM89500_A0_SHD_LDr 0x0000939a

#define BCM89500_A0_SHD_LDr_SIZE 2

/*
 * This structure should be used to declare and program SHD_LD.
 *
 */
typedef union BCM89500_A0_SHD_LDr_s {
	uint32_t v[1];
	uint32_t shd_ld[1];
	uint32_t _shd_ld;
} BCM89500_A0_SHD_LDr_t;

#define BCM89500_A0_SHD_LDr_CLR(r) (r).shd_ld[0] = 0
#define BCM89500_A0_SHD_LDr_SET(r,d) (r).shd_ld[0] = d
#define BCM89500_A0_SHD_LDr_GET(r) (r).shd_ld[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SHD_LDr_DPLL_K1_LOADf_GET(r) (((r).shd_ld[0]) & 0x1)
#define BCM89500_A0_SHD_LDr_DPLL_K1_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SHD_LDr_DPLL_K2_LOADf_GET(r) ((((r).shd_ld[0]) >> 1) & 0x1)
#define BCM89500_A0_SHD_LDr_DPLL_K2_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SHD_LDr_DPLL_K3_LOADf_GET(r) ((((r).shd_ld[0]) >> 2) & 0x1)
#define BCM89500_A0_SHD_LDr_DPLL_K3_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_DELTA_LOADf_GET(r) ((((r).shd_ld[0]) >> 3) & 0x1)
#define BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_DELTA_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_LOADf_GET(r) ((((r).shd_ld[0]) >> 4) & 0x1)
#define BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SHD_LDr_DPLL_LOOP_FILTER_LOADf_GET(r) ((((r).shd_ld[0]) >> 5) & 0x1)
#define BCM89500_A0_SHD_LDr_DPLL_LOOP_FILTER_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SHD_LDr_FREQ_LOADf_GET(r) ((((r).shd_ld[0]) >> 6) & 0x1)
#define BCM89500_A0_SHD_LDr_FREQ_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SHD_LDr_LOCAL_TIME_LOADf_GET(r) ((((r).shd_ld[0]) >> 7) & 0x1)
#define BCM89500_A0_SHD_LDr_LOCAL_TIME_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_SHD_LDr_NCO_DIVIDER_LOADf_GET(r) ((((r).shd_ld[0]) >> 8) & 0x1)
#define BCM89500_A0_SHD_LDr_NCO_DIVIDER_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_SHD_LDr_SYNCOUT_LOADf_GET(r) ((((r).shd_ld[0]) >> 9) & 0x1)
#define BCM89500_A0_SHD_LDr_SYNCOUT_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_SHD_LDr_TIME_CODE_LOADf_GET(r) ((((r).shd_ld[0]) >> 10) & 0x1)
#define BCM89500_A0_SHD_LDr_TIME_CODE_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_SHD_LDr_IEEE1588_TIME_CODE_LOADf_GET(r) ((((r).shd_ld[0]) >> 11) & 0x1)
#define BCM89500_A0_SHD_LDr_IEEE1588_TIME_CODE_LOADf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_SHD_LDr_F13_Lf_GET(r) ((((r).shd_ld[0]) >> 12) & 0x1)
#define BCM89500_A0_SHD_LDr_F13_Lf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_SHD_LDr_F14_Lf_GET(r) ((((r).shd_ld[0]) >> 13) & 0x1)
#define BCM89500_A0_SHD_LDr_F14_Lf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_SHD_LDr_F15_Lf_GET(r) ((((r).shd_ld[0]) >> 14) & 0x1)
#define BCM89500_A0_SHD_LDr_F15_Lf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_SHD_LDr_F16_Lf_GET(r) ((((r).shd_ld[0]) >> 15) & 0x1)
#define BCM89500_A0_SHD_LDr_F16_Lf_SET(r,f) (r).shd_ld[0]=(((r).shd_ld[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SHD_LD.
 *
 */
#define BCM89500_A0_READ_SHD_LDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SHD_LDr,(r._shd_ld),2)
#define BCM89500_A0_WRITE_SHD_LDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SHD_LDr,&(r._shd_ld),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SHD_LDr BCM89500_A0_SHD_LDr
#define SHD_LDr_SIZE BCM89500_A0_SHD_LDr_SIZE
typedef BCM89500_A0_SHD_LDr_t SHD_LDr_t;
#define SHD_LDr_CLR BCM89500_A0_SHD_LDr_CLR
#define SHD_LDr_SET BCM89500_A0_SHD_LDr_SET
#define SHD_LDr_GET BCM89500_A0_SHD_LDr_GET
#define SHD_LDr_DPLL_K1_LOADf_GET BCM89500_A0_SHD_LDr_DPLL_K1_LOADf_GET
#define SHD_LDr_DPLL_K1_LOADf_SET BCM89500_A0_SHD_LDr_DPLL_K1_LOADf_SET
#define SHD_LDr_DPLL_K2_LOADf_GET BCM89500_A0_SHD_LDr_DPLL_K2_LOADf_GET
#define SHD_LDr_DPLL_K2_LOADf_SET BCM89500_A0_SHD_LDr_DPLL_K2_LOADf_SET
#define SHD_LDr_DPLL_K3_LOADf_GET BCM89500_A0_SHD_LDr_DPLL_K3_LOADf_GET
#define SHD_LDr_DPLL_K3_LOADf_SET BCM89500_A0_SHD_LDr_DPLL_K3_LOADf_SET
#define SHD_LDr_DPLL_REF_PHASE_DELTA_LOADf_GET BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_DELTA_LOADf_GET
#define SHD_LDr_DPLL_REF_PHASE_DELTA_LOADf_SET BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_DELTA_LOADf_SET
#define SHD_LDr_DPLL_REF_PHASE_LOADf_GET BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_LOADf_GET
#define SHD_LDr_DPLL_REF_PHASE_LOADf_SET BCM89500_A0_SHD_LDr_DPLL_REF_PHASE_LOADf_SET
#define SHD_LDr_DPLL_LOOP_FILTER_LOADf_GET BCM89500_A0_SHD_LDr_DPLL_LOOP_FILTER_LOADf_GET
#define SHD_LDr_DPLL_LOOP_FILTER_LOADf_SET BCM89500_A0_SHD_LDr_DPLL_LOOP_FILTER_LOADf_SET
#define SHD_LDr_FREQ_LOADf_GET BCM89500_A0_SHD_LDr_FREQ_LOADf_GET
#define SHD_LDr_FREQ_LOADf_SET BCM89500_A0_SHD_LDr_FREQ_LOADf_SET
#define SHD_LDr_LOCAL_TIME_LOADf_GET BCM89500_A0_SHD_LDr_LOCAL_TIME_LOADf_GET
#define SHD_LDr_LOCAL_TIME_LOADf_SET BCM89500_A0_SHD_LDr_LOCAL_TIME_LOADf_SET
#define SHD_LDr_NCO_DIVIDER_LOADf_GET BCM89500_A0_SHD_LDr_NCO_DIVIDER_LOADf_GET
#define SHD_LDr_NCO_DIVIDER_LOADf_SET BCM89500_A0_SHD_LDr_NCO_DIVIDER_LOADf_SET
#define SHD_LDr_SYNCOUT_LOADf_GET BCM89500_A0_SHD_LDr_SYNCOUT_LOADf_GET
#define SHD_LDr_SYNCOUT_LOADf_SET BCM89500_A0_SHD_LDr_SYNCOUT_LOADf_SET
#define SHD_LDr_TIME_CODE_LOADf_GET BCM89500_A0_SHD_LDr_TIME_CODE_LOADf_GET
#define SHD_LDr_TIME_CODE_LOADf_SET BCM89500_A0_SHD_LDr_TIME_CODE_LOADf_SET
#define SHD_LDr_IEEE1588_TIME_CODE_LOADf_GET BCM89500_A0_SHD_LDr_IEEE1588_TIME_CODE_LOADf_GET
#define SHD_LDr_IEEE1588_TIME_CODE_LOADf_SET BCM89500_A0_SHD_LDr_IEEE1588_TIME_CODE_LOADf_SET
#define SHD_LDr_F13_Lf_GET BCM89500_A0_SHD_LDr_F13_Lf_GET
#define SHD_LDr_F13_Lf_SET BCM89500_A0_SHD_LDr_F13_Lf_SET
#define SHD_LDr_F14_Lf_GET BCM89500_A0_SHD_LDr_F14_Lf_GET
#define SHD_LDr_F14_Lf_SET BCM89500_A0_SHD_LDr_F14_Lf_SET
#define SHD_LDr_F15_Lf_GET BCM89500_A0_SHD_LDr_F15_Lf_GET
#define SHD_LDr_F15_Lf_SET BCM89500_A0_SHD_LDr_F15_Lf_SET
#define SHD_LDr_F16_Lf_GET BCM89500_A0_SHD_LDr_F16_Lf_GET
#define SHD_LDr_F16_Lf_SET BCM89500_A0_SHD_LDr_F16_Lf_SET
#define READ_SHD_LDr BCM89500_A0_READ_SHD_LDr
#define WRITE_SHD_LDr BCM89500_A0_WRITE_SHD_LDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SHD_LDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     5
 * FIELDS:
 *     CPIC             Software Block Flag for CPIC
 *     EXP              Software Block Flag for EXP
 *     GPIC             Software Block Flag for GPIC
 *     SPI              Software Block Flag for SPI
 *     SYS              Software Block Flag for SYS
 *
 ******************************************************************************/
#define BCM89500_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM89500_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM89500_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM89500_A0_SOFTWARE_BLOCKMAP_t;

#define BCM89500_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM89500_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM89500_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM89500_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM89500_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SOFTWARE_BLOCKMAP_GPICf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM89500_A0_SOFTWARE_BLOCKMAP_GPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM89500_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM89500_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM89500_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM89500_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM89500_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM89500_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM89500_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM89500_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM89500_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM89500_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM89500_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM89500_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_GPICf_GET BCM89500_A0_SOFTWARE_BLOCKMAP_GPICf_GET
#define SOFTWARE_BLOCKMAP_GPICf_SET BCM89500_A0_SOFTWARE_BLOCKMAP_GPICf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM89500_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM89500_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM89500_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM89500_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define READ_SOFTWARE_BLOCKMAP BCM89500_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM89500_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPARE_1C
 * BLOCKS:   GPIC0
 * DESC:     Spare 1C Register
 * SIZE:     16
 * FIELDS:
 *     SPARE_1C         
 *
 ******************************************************************************/
#define BCM89500_A0_SPARE_1Cr 0x0000801c

#define BCM89500_A0_SPARE_1Cr_SIZE 2

/*
 * This structure should be used to declare and program SPARE_1C.
 *
 */
typedef union BCM89500_A0_SPARE_1Cr_s {
	uint32_t v[1];
	uint32_t spare_1c[1];
	uint32_t _spare_1c;
} BCM89500_A0_SPARE_1Cr_t;

#define BCM89500_A0_SPARE_1Cr_CLR(r) (r).spare_1c[0] = 0
#define BCM89500_A0_SPARE_1Cr_SET(r,d) (r).spare_1c[0] = d
#define BCM89500_A0_SPARE_1Cr_GET(r) (r).spare_1c[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPARE_1Cr_SPARE_1Cf_GET(r) (((r).spare_1c[0]) & 0xffff)
#define BCM89500_A0_SPARE_1Cr_SPARE_1Cf_SET(r,f) (r).spare_1c[0]=(((r).spare_1c[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_1C.
 *
 */
#define BCM89500_A0_READ_SPARE_1Cr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_SPARE_1Cr,(r._spare_1c),2)
#define BCM89500_A0_WRITE_SPARE_1Cr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_SPARE_1Cr,&(r._spare_1c),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPARE_1Cr BCM89500_A0_SPARE_1Cr
#define SPARE_1Cr_SIZE BCM89500_A0_SPARE_1Cr_SIZE
typedef BCM89500_A0_SPARE_1Cr_t SPARE_1Cr_t;
#define SPARE_1Cr_CLR BCM89500_A0_SPARE_1Cr_CLR
#define SPARE_1Cr_SET BCM89500_A0_SPARE_1Cr_SET
#define SPARE_1Cr_GET BCM89500_A0_SPARE_1Cr_GET
#define SPARE_1Cr_SPARE_1Cf_GET BCM89500_A0_SPARE_1Cr_SPARE_1Cf_GET
#define SPARE_1Cr_SPARE_1Cf_SET BCM89500_A0_SPARE_1Cr_SPARE_1Cf_SET
#define READ_SPARE_1Cr BCM89500_A0_READ_SPARE_1Cr
#define WRITE_SPARE_1Cr BCM89500_A0_WRITE_SPARE_1Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPARE_1Cr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPARE_REG_0
 * BLOCKS:   SYS
 * DESC:     Spare Register 0
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SPARE_REG_0r 0x00000a58

#define BCM89500_A0_SPARE_REG_0r_SIZE 2

/*
 * This structure should be used to declare and program SPARE_REG_0.
 *
 */
typedef union BCM89500_A0_SPARE_REG_0r_s {
	uint32_t v[1];
	uint32_t spare_reg_0[1];
	uint32_t _spare_reg_0;
} BCM89500_A0_SPARE_REG_0r_t;

#define BCM89500_A0_SPARE_REG_0r_CLR(r) (r).spare_reg_0[0] = 0
#define BCM89500_A0_SPARE_REG_0r_SET(r,d) (r).spare_reg_0[0] = d
#define BCM89500_A0_SPARE_REG_0r_GET(r) (r).spare_reg_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPARE_REG_0r_RESERVEDf_GET(r) (((r).spare_reg_0[0]) & 0xffff)
#define BCM89500_A0_SPARE_REG_0r_RESERVEDf_SET(r,f) (r).spare_reg_0[0]=(((r).spare_reg_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_REG_0.
 *
 */
#define BCM89500_A0_READ_SPARE_REG_0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPARE_REG_0r,(r._spare_reg_0),2)
#define BCM89500_A0_WRITE_SPARE_REG_0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPARE_REG_0r,&(r._spare_reg_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPARE_REG_0r BCM89500_A0_SPARE_REG_0r
#define SPARE_REG_0r_SIZE BCM89500_A0_SPARE_REG_0r_SIZE
typedef BCM89500_A0_SPARE_REG_0r_t SPARE_REG_0r_t;
#define SPARE_REG_0r_CLR BCM89500_A0_SPARE_REG_0r_CLR
#define SPARE_REG_0r_SET BCM89500_A0_SPARE_REG_0r_SET
#define SPARE_REG_0r_GET BCM89500_A0_SPARE_REG_0r_GET
#define SPARE_REG_0r_RESERVEDf_GET BCM89500_A0_SPARE_REG_0r_RESERVEDf_GET
#define SPARE_REG_0r_RESERVEDf_SET BCM89500_A0_SPARE_REG_0r_RESERVEDf_SET
#define READ_SPARE_REG_0r BCM89500_A0_READ_SPARE_REG_0r
#define WRITE_SPARE_REG_0r BCM89500_A0_WRITE_SPARE_REG_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPARE_REG_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     32
 * FIELDS:
 *     PORT_SPD         Port Speed.18 bit field indicating the operating speed for each 10/100/1000BASE-T port.Bit 17:16 = Port 8 (IMP Port)Bit 15:14 = Port 7Bit 11:0 = Port 5 - Port 0(Bit[1:0] for Port 0, and Bit[11:10] for Port 5)00 = 10 Mb/s01 = 100 Mb/s10 = 1000 Mb/s11 = 200Mb/s(for Port 5/Port 8 TMII mode only)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SPDSTSr 0x00000104

#define BCM89500_A0_SPDSTSr_SIZE 4

/*
 * This structure should be used to declare and program SPDSTS.
 *
 */
typedef union BCM89500_A0_SPDSTSr_s {
	uint32_t v[1];
	uint32_t spdsts[1];
	uint32_t _spdsts;
} BCM89500_A0_SPDSTSr_t;

#define BCM89500_A0_SPDSTSr_CLR(r) (r).spdsts[0] = 0
#define BCM89500_A0_SPDSTSr_SET(r,d) (r).spdsts[0] = d
#define BCM89500_A0_SPDSTSr_GET(r) (r).spdsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPDSTSr_PORT_SPDf_GET(r) (((r).spdsts[0]) & 0x3ffff)
#define BCM89500_A0_SPDSTSr_PORT_SPDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM89500_A0_SPDSTSr_RESERVEDf_GET(r) ((((r).spdsts[0]) >> 18) & 0x3fff)
#define BCM89500_A0_SPDSTSr_RESERVEDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access SPDSTS.
 *
 */
#define BCM89500_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPDSTSr,(r._spdsts),4)
#define BCM89500_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPDSTSr,&(r._spdsts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM89500_A0_SPDSTSr
#define SPDSTSr_SIZE BCM89500_A0_SPDSTSr_SIZE
typedef BCM89500_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM89500_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM89500_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM89500_A0_SPDSTSr_GET
#define SPDSTSr_PORT_SPDf_GET BCM89500_A0_SPDSTSr_PORT_SPDf_GET
#define SPDSTSr_PORT_SPDf_SET BCM89500_A0_SPDSTSr_PORT_SPDf_SET
#define SPDSTSr_RESERVEDf_GET BCM89500_A0_SPDSTSr_RESERVEDf_GET
#define SPDSTSr_RESERVEDf_SET BCM89500_A0_SPDSTSr_RESERVEDf_SET
#define READ_SPDSTSr BCM89500_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM89500_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPDSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO0
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 0
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 0
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO0r 0x0000fff0

#define BCM89500_A0_SPIDIO0r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO0.
 *
 */
typedef union BCM89500_A0_SPIDIO0r_s {
	uint32_t v[1];
	uint32_t spidio0[1];
	uint32_t _spidio0;
} BCM89500_A0_SPIDIO0r_t;

#define BCM89500_A0_SPIDIO0r_CLR(r) (r).spidio0[0] = 0
#define BCM89500_A0_SPIDIO0r_SET(r,d) (r).spidio0[0] = d
#define BCM89500_A0_SPIDIO0r_GET(r) (r).spidio0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO0r_RESERVEDf_GET(r) (((r).spidio0[0]) & 0xff)
#define BCM89500_A0_SPIDIO0r_RESERVEDf_SET(r,f) (r).spidio0[0]=(((r).spidio0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO0.
 *
 */
#define BCM89500_A0_READ_SPIDIO0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO0r,(r._spidio0),1)
#define BCM89500_A0_WRITE_SPIDIO0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO0r,&(r._spidio0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO0r BCM89500_A0_SPIDIO0r
#define SPIDIO0r_SIZE BCM89500_A0_SPIDIO0r_SIZE
typedef BCM89500_A0_SPIDIO0r_t SPIDIO0r_t;
#define SPIDIO0r_CLR BCM89500_A0_SPIDIO0r_CLR
#define SPIDIO0r_SET BCM89500_A0_SPIDIO0r_SET
#define SPIDIO0r_GET BCM89500_A0_SPIDIO0r_GET
#define SPIDIO0r_RESERVEDf_GET BCM89500_A0_SPIDIO0r_RESERVEDf_GET
#define SPIDIO0r_RESERVEDf_SET BCM89500_A0_SPIDIO0r_RESERVEDf_SET
#define READ_SPIDIO0r BCM89500_A0_READ_SPIDIO0r
#define WRITE_SPIDIO0r BCM89500_A0_WRITE_SPIDIO0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO1
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 1
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 1
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO1r 0x0000fff1

#define BCM89500_A0_SPIDIO1r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO1.
 *
 */
typedef union BCM89500_A0_SPIDIO1r_s {
	uint32_t v[1];
	uint32_t spidio1[1];
	uint32_t _spidio1;
} BCM89500_A0_SPIDIO1r_t;

#define BCM89500_A0_SPIDIO1r_CLR(r) (r).spidio1[0] = 0
#define BCM89500_A0_SPIDIO1r_SET(r,d) (r).spidio1[0] = d
#define BCM89500_A0_SPIDIO1r_GET(r) (r).spidio1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO1r_RESERVEDf_GET(r) (((r).spidio1[0]) & 0xff)
#define BCM89500_A0_SPIDIO1r_RESERVEDf_SET(r,f) (r).spidio1[0]=(((r).spidio1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO1.
 *
 */
#define BCM89500_A0_READ_SPIDIO1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO1r,(r._spidio1),1)
#define BCM89500_A0_WRITE_SPIDIO1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO1r,&(r._spidio1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO1r BCM89500_A0_SPIDIO1r
#define SPIDIO1r_SIZE BCM89500_A0_SPIDIO1r_SIZE
typedef BCM89500_A0_SPIDIO1r_t SPIDIO1r_t;
#define SPIDIO1r_CLR BCM89500_A0_SPIDIO1r_CLR
#define SPIDIO1r_SET BCM89500_A0_SPIDIO1r_SET
#define SPIDIO1r_GET BCM89500_A0_SPIDIO1r_GET
#define SPIDIO1r_RESERVEDf_GET BCM89500_A0_SPIDIO1r_RESERVEDf_GET
#define SPIDIO1r_RESERVEDf_SET BCM89500_A0_SPIDIO1r_RESERVEDf_SET
#define READ_SPIDIO1r BCM89500_A0_READ_SPIDIO1r
#define WRITE_SPIDIO1r BCM89500_A0_WRITE_SPIDIO1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO2
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 2
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 2
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO2r 0x0000fff2

#define BCM89500_A0_SPIDIO2r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO2.
 *
 */
typedef union BCM89500_A0_SPIDIO2r_s {
	uint32_t v[1];
	uint32_t spidio2[1];
	uint32_t _spidio2;
} BCM89500_A0_SPIDIO2r_t;

#define BCM89500_A0_SPIDIO2r_CLR(r) (r).spidio2[0] = 0
#define BCM89500_A0_SPIDIO2r_SET(r,d) (r).spidio2[0] = d
#define BCM89500_A0_SPIDIO2r_GET(r) (r).spidio2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO2r_RESERVEDf_GET(r) (((r).spidio2[0]) & 0xff)
#define BCM89500_A0_SPIDIO2r_RESERVEDf_SET(r,f) (r).spidio2[0]=(((r).spidio2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO2.
 *
 */
#define BCM89500_A0_READ_SPIDIO2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO2r,(r._spidio2),1)
#define BCM89500_A0_WRITE_SPIDIO2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO2r,&(r._spidio2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO2r BCM89500_A0_SPIDIO2r
#define SPIDIO2r_SIZE BCM89500_A0_SPIDIO2r_SIZE
typedef BCM89500_A0_SPIDIO2r_t SPIDIO2r_t;
#define SPIDIO2r_CLR BCM89500_A0_SPIDIO2r_CLR
#define SPIDIO2r_SET BCM89500_A0_SPIDIO2r_SET
#define SPIDIO2r_GET BCM89500_A0_SPIDIO2r_GET
#define SPIDIO2r_RESERVEDf_GET BCM89500_A0_SPIDIO2r_RESERVEDf_GET
#define SPIDIO2r_RESERVEDf_SET BCM89500_A0_SPIDIO2r_RESERVEDf_SET
#define READ_SPIDIO2r BCM89500_A0_READ_SPIDIO2r
#define WRITE_SPIDIO2r BCM89500_A0_WRITE_SPIDIO2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO3
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 3
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 3
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO3r 0x0000fff3

#define BCM89500_A0_SPIDIO3r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO3.
 *
 */
typedef union BCM89500_A0_SPIDIO3r_s {
	uint32_t v[1];
	uint32_t spidio3[1];
	uint32_t _spidio3;
} BCM89500_A0_SPIDIO3r_t;

#define BCM89500_A0_SPIDIO3r_CLR(r) (r).spidio3[0] = 0
#define BCM89500_A0_SPIDIO3r_SET(r,d) (r).spidio3[0] = d
#define BCM89500_A0_SPIDIO3r_GET(r) (r).spidio3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO3r_RESERVEDf_GET(r) (((r).spidio3[0]) & 0xff)
#define BCM89500_A0_SPIDIO3r_RESERVEDf_SET(r,f) (r).spidio3[0]=(((r).spidio3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO3.
 *
 */
#define BCM89500_A0_READ_SPIDIO3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO3r,(r._spidio3),1)
#define BCM89500_A0_WRITE_SPIDIO3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO3r,&(r._spidio3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO3r BCM89500_A0_SPIDIO3r
#define SPIDIO3r_SIZE BCM89500_A0_SPIDIO3r_SIZE
typedef BCM89500_A0_SPIDIO3r_t SPIDIO3r_t;
#define SPIDIO3r_CLR BCM89500_A0_SPIDIO3r_CLR
#define SPIDIO3r_SET BCM89500_A0_SPIDIO3r_SET
#define SPIDIO3r_GET BCM89500_A0_SPIDIO3r_GET
#define SPIDIO3r_RESERVEDf_GET BCM89500_A0_SPIDIO3r_RESERVEDf_GET
#define SPIDIO3r_RESERVEDf_SET BCM89500_A0_SPIDIO3r_RESERVEDf_SET
#define READ_SPIDIO3r BCM89500_A0_READ_SPIDIO3r
#define WRITE_SPIDIO3r BCM89500_A0_WRITE_SPIDIO3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO4
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 4
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 4
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO4r 0x0000fff4

#define BCM89500_A0_SPIDIO4r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO4.
 *
 */
typedef union BCM89500_A0_SPIDIO4r_s {
	uint32_t v[1];
	uint32_t spidio4[1];
	uint32_t _spidio4;
} BCM89500_A0_SPIDIO4r_t;

#define BCM89500_A0_SPIDIO4r_CLR(r) (r).spidio4[0] = 0
#define BCM89500_A0_SPIDIO4r_SET(r,d) (r).spidio4[0] = d
#define BCM89500_A0_SPIDIO4r_GET(r) (r).spidio4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO4r_RESERVEDf_GET(r) (((r).spidio4[0]) & 0xff)
#define BCM89500_A0_SPIDIO4r_RESERVEDf_SET(r,f) (r).spidio4[0]=(((r).spidio4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO4.
 *
 */
#define BCM89500_A0_READ_SPIDIO4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO4r,(r._spidio4),1)
#define BCM89500_A0_WRITE_SPIDIO4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO4r,&(r._spidio4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO4r BCM89500_A0_SPIDIO4r
#define SPIDIO4r_SIZE BCM89500_A0_SPIDIO4r_SIZE
typedef BCM89500_A0_SPIDIO4r_t SPIDIO4r_t;
#define SPIDIO4r_CLR BCM89500_A0_SPIDIO4r_CLR
#define SPIDIO4r_SET BCM89500_A0_SPIDIO4r_SET
#define SPIDIO4r_GET BCM89500_A0_SPIDIO4r_GET
#define SPIDIO4r_RESERVEDf_GET BCM89500_A0_SPIDIO4r_RESERVEDf_GET
#define SPIDIO4r_RESERVEDf_SET BCM89500_A0_SPIDIO4r_RESERVEDf_SET
#define READ_SPIDIO4r BCM89500_A0_READ_SPIDIO4r
#define WRITE_SPIDIO4r BCM89500_A0_WRITE_SPIDIO4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO5
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 5
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 5
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO5r 0x0000fff5

#define BCM89500_A0_SPIDIO5r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO5.
 *
 */
typedef union BCM89500_A0_SPIDIO5r_s {
	uint32_t v[1];
	uint32_t spidio5[1];
	uint32_t _spidio5;
} BCM89500_A0_SPIDIO5r_t;

#define BCM89500_A0_SPIDIO5r_CLR(r) (r).spidio5[0] = 0
#define BCM89500_A0_SPIDIO5r_SET(r,d) (r).spidio5[0] = d
#define BCM89500_A0_SPIDIO5r_GET(r) (r).spidio5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO5r_RESERVEDf_GET(r) (((r).spidio5[0]) & 0xff)
#define BCM89500_A0_SPIDIO5r_RESERVEDf_SET(r,f) (r).spidio5[0]=(((r).spidio5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO5.
 *
 */
#define BCM89500_A0_READ_SPIDIO5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO5r,(r._spidio5),1)
#define BCM89500_A0_WRITE_SPIDIO5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO5r,&(r._spidio5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO5r BCM89500_A0_SPIDIO5r
#define SPIDIO5r_SIZE BCM89500_A0_SPIDIO5r_SIZE
typedef BCM89500_A0_SPIDIO5r_t SPIDIO5r_t;
#define SPIDIO5r_CLR BCM89500_A0_SPIDIO5r_CLR
#define SPIDIO5r_SET BCM89500_A0_SPIDIO5r_SET
#define SPIDIO5r_GET BCM89500_A0_SPIDIO5r_GET
#define SPIDIO5r_RESERVEDf_GET BCM89500_A0_SPIDIO5r_RESERVEDf_GET
#define SPIDIO5r_RESERVEDf_SET BCM89500_A0_SPIDIO5r_RESERVEDf_SET
#define READ_SPIDIO5r BCM89500_A0_READ_SPIDIO5r
#define WRITE_SPIDIO5r BCM89500_A0_WRITE_SPIDIO5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO6
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 6
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 6
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO6r 0x0000fff6

#define BCM89500_A0_SPIDIO6r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO6.
 *
 */
typedef union BCM89500_A0_SPIDIO6r_s {
	uint32_t v[1];
	uint32_t spidio6[1];
	uint32_t _spidio6;
} BCM89500_A0_SPIDIO6r_t;

#define BCM89500_A0_SPIDIO6r_CLR(r) (r).spidio6[0] = 0
#define BCM89500_A0_SPIDIO6r_SET(r,d) (r).spidio6[0] = d
#define BCM89500_A0_SPIDIO6r_GET(r) (r).spidio6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO6r_RESERVEDf_GET(r) (((r).spidio6[0]) & 0xff)
#define BCM89500_A0_SPIDIO6r_RESERVEDf_SET(r,f) (r).spidio6[0]=(((r).spidio6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO6.
 *
 */
#define BCM89500_A0_READ_SPIDIO6r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO6r,(r._spidio6),1)
#define BCM89500_A0_WRITE_SPIDIO6r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO6r,&(r._spidio6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO6r BCM89500_A0_SPIDIO6r
#define SPIDIO6r_SIZE BCM89500_A0_SPIDIO6r_SIZE
typedef BCM89500_A0_SPIDIO6r_t SPIDIO6r_t;
#define SPIDIO6r_CLR BCM89500_A0_SPIDIO6r_CLR
#define SPIDIO6r_SET BCM89500_A0_SPIDIO6r_SET
#define SPIDIO6r_GET BCM89500_A0_SPIDIO6r_GET
#define SPIDIO6r_RESERVEDf_GET BCM89500_A0_SPIDIO6r_RESERVEDf_GET
#define SPIDIO6r_RESERVEDf_SET BCM89500_A0_SPIDIO6r_RESERVEDf_SET
#define READ_SPIDIO6r BCM89500_A0_READ_SPIDIO6r
#define WRITE_SPIDIO6r BCM89500_A0_WRITE_SPIDIO6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPIDIO7
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 7
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 7
 *
 ******************************************************************************/
#define BCM89500_A0_SPIDIO7r 0x0000fff7

#define BCM89500_A0_SPIDIO7r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO7.
 *
 */
typedef union BCM89500_A0_SPIDIO7r_s {
	uint32_t v[1];
	uint32_t spidio7[1];
	uint32_t _spidio7;
} BCM89500_A0_SPIDIO7r_t;

#define BCM89500_A0_SPIDIO7r_CLR(r) (r).spidio7[0] = 0
#define BCM89500_A0_SPIDIO7r_SET(r,d) (r).spidio7[0] = d
#define BCM89500_A0_SPIDIO7r_GET(r) (r).spidio7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPIDIO7r_RESERVEDf_GET(r) (((r).spidio7[0]) & 0xff)
#define BCM89500_A0_SPIDIO7r_RESERVEDf_SET(r,f) (r).spidio7[0]=(((r).spidio7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO7.
 *
 */
#define BCM89500_A0_READ_SPIDIO7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPIDIO7r,(r._spidio7),1)
#define BCM89500_A0_WRITE_SPIDIO7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPIDIO7r,&(r._spidio7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO7r BCM89500_A0_SPIDIO7r
#define SPIDIO7r_SIZE BCM89500_A0_SPIDIO7r_SIZE
typedef BCM89500_A0_SPIDIO7r_t SPIDIO7r_t;
#define SPIDIO7r_CLR BCM89500_A0_SPIDIO7r_CLR
#define SPIDIO7r_SET BCM89500_A0_SPIDIO7r_SET
#define SPIDIO7r_GET BCM89500_A0_SPIDIO7r_GET
#define SPIDIO7r_RESERVEDf_GET BCM89500_A0_SPIDIO7r_RESERVEDf_GET
#define SPIDIO7r_RESERVEDf_SET BCM89500_A0_SPIDIO7r_RESERVEDf_SET
#define READ_SPIDIO7r BCM89500_A0_READ_SPIDIO7r
#define WRITE_SPIDIO7r BCM89500_A0_WRITE_SPIDIO7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPIDIO7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPISTS
 * BLOCKS:   SPI
 * DESC:     SPI Status Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         bit[7](SPIF) : SPI Read/Write Complete Flagbit[6](RESERVED_1) : Reservedbit[5](RACK) : SPI Read Data Ready Acknowledgement(self-Cleaing)bit[4:0](RESERVED_0) : Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SPISTSr 0x0000fffe

#define BCM89500_A0_SPISTSr_SIZE 1

/*
 * This structure should be used to declare and program SPISTS.
 *
 */
typedef union BCM89500_A0_SPISTSr_s {
	uint32_t v[1];
	uint32_t spists[1];
	uint32_t _spists;
} BCM89500_A0_SPISTSr_t;

#define BCM89500_A0_SPISTSr_CLR(r) (r).spists[0] = 0
#define BCM89500_A0_SPISTSr_SET(r,d) (r).spists[0] = d
#define BCM89500_A0_SPISTSr_GET(r) (r).spists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPISTSr_RESERVEDf_GET(r) (((r).spists[0]) & 0xff)
#define BCM89500_A0_SPISTSr_RESERVEDf_SET(r,f) (r).spists[0]=(((r).spists[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPISTS.
 *
 */
#define BCM89500_A0_READ_SPISTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPISTSr,(r._spists),1)
#define BCM89500_A0_WRITE_SPISTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPISTSr,&(r._spists),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPISTSr BCM89500_A0_SPISTSr
#define SPISTSr_SIZE BCM89500_A0_SPISTSr_SIZE
typedef BCM89500_A0_SPISTSr_t SPISTSr_t;
#define SPISTSr_CLR BCM89500_A0_SPISTSr_CLR
#define SPISTSr_SET BCM89500_A0_SPISTSr_SET
#define SPISTSr_GET BCM89500_A0_SPISTSr_GET
#define SPISTSr_RESERVEDf_GET BCM89500_A0_SPISTSr_RESERVEDf_GET
#define SPISTSr_RESERVEDf_SET BCM89500_A0_SPISTSr_RESERVEDf_SET
#define READ_SPISTSr BCM89500_A0_READ_SPISTSr
#define WRITE_SPISTSr BCM89500_A0_WRITE_SPISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in seconds for dynamicallylearned address. Maximum age time is 1,048,575s. Note that while 802.1D specifies a range of values of 10 - 1,000,000 s, this register does not enforce this range. Setting the AGE_TIME to zero disables the aging process.
 *     AGE_CHANGE_EN    Set 1 to Change Aging Timer by AGE_TIME[19:0].
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SPTAGTr 0x00000206

#define BCM89500_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 *
 */
typedef union BCM89500_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM89500_A0_SPTAGTr_t;

#define BCM89500_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM89500_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM89500_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM89500_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM89500_A0_SPTAGTr_AGE_CHANGE_ENf_GET(r) ((((r).sptagt[0]) >> 20) & 0x1)
#define BCM89500_A0_SPTAGTr_AGE_CHANGE_ENf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM89500_A0_SPTAGTr_RESERVEDf_GET(r) ((((r).sptagt[0]) >> 21) & 0x7ff)
#define BCM89500_A0_SPTAGTr_RESERVEDf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access SPTAGT.
 *
 */
#define BCM89500_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPTAGTr,(r._sptagt),4)
#define BCM89500_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM89500_A0_SPTAGTr
#define SPTAGTr_SIZE BCM89500_A0_SPTAGTr_SIZE
typedef BCM89500_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM89500_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM89500_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM89500_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM89500_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM89500_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_AGE_CHANGE_ENf_GET BCM89500_A0_SPTAGTr_AGE_CHANGE_ENf_GET
#define SPTAGTr_AGE_CHANGE_ENf_SET BCM89500_A0_SPTAGTr_AGE_CHANGE_ENf_SET
#define SPTAGTr_RESERVEDf_GET BCM89500_A0_SPTAGTr_RESERVEDf_GET
#define SPTAGTr_RESERVEDf_SET BCM89500_A0_SPTAGTr_RESERVEDf_SET
#define READ_SPTAGTr BCM89500_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM89500_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPTAGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SPT_MULTI_ADDR_BPS_CTRL
 * BLOCKS:   SYS
 * DESC:     STP Multiport Address Bypass Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_BYPASS_SPT 1'b0: The MPORT_ADD0 will not be checked by SPT Status1'b1: The MPORT_ADD0 will  be checked by SPT Status
 *     EN_MPORT1_BYPASS_SPT 1'b0: The MPORT_ADD1 will not be checked by SPT Status1'b1: The MPORT_ADD1 will  be checked by SPT Status
 *     EN_MPORT2_BYPASS_SPT 1'b0: The MPORT_ADD2 will not be checked by SPT Status1'b1: The MPORT_ADD2 will  be checked by SPT Status
 *     EN_MPORT3_BYPASS_SPT 1'b0: The MPORT_ADD3 will not be checked by SPT Status1'b1: The MPORT_ADD3 will  be checked by SPT Status
 *     EN_MPORT4_BYPASS_SPT 1'b0: The MPORT_ADD4 will not be checked by SPT Status1'b1: The MPORT_ADD4 will  be checked by SPT Status
 *     EN_MPORT5_BYPASS_SPT 1'b0: The MPORT_ADD5 will not be checked by SPT Status1'b1: The MPORT_ADD5 will  be checked by SPT Status
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr 0x00004350

#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
typedef union BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_s {
	uint32_t v[1];
	uint32_t spt_multi_addr_bps_ctrl[1];
	uint32_t _spt_multi_addr_bps_ctrl;
} BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_t;

#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR(r) (r).spt_multi_addr_bps_ctrl[0] = 0
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET(r,d) (r).spt_multi_addr_bps_ctrl[0] = d
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET(r) (r).spt_multi_addr_bps_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET(r) (((r).spt_multi_addr_bps_ctrl[0]) & 0x1)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 6) & 0x3ff)
#define BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
#define BCM89500_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr,(r._spt_multi_addr_bps_ctrl),2)
#define BCM89500_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr,&(r._spt_multi_addr_bps_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPT_MULTI_ADDR_BPS_CTRLr BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr
#define SPT_MULTI_ADDR_BPS_CTRLr_SIZE BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE
typedef BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_t SPT_MULTI_ADDR_BPS_CTRLr_t;
#define SPT_MULTI_ADDR_BPS_CTRLr_CLR BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR
#define SPT_MULTI_ADDR_BPS_CTRLr_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET
#define READ_SPT_MULTI_ADDR_BPS_CTRLr BCM89500_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr
#define WRITE_SPT_MULTI_ADDR_BPS_CTRLr BCM89500_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SPT_MULTI_ADDR_BPS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SRCADRCHG
 * BLOCKS:   SYS
 * DESC:     Source Address Change Register
 * SIZE:     16
 * FIELDS:
 *     SRC_ADDR_CHANGE  Source Address Change.9 bit field indicating that the value loaded into the Last Source Address register was not the same 48-bit value as the previous value. A 1 value indicates a dedicated link degment, a value greater than 1 generally indicates a mixing (repeatered) segment. Upon change of SA, a bit remains set until cleared by a read operation.0 = Source Address Constant1 = Source Address Changed
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SRCADRCHGr 0x0000010e

#define BCM89500_A0_SRCADRCHGr_SIZE 2

/*
 * This structure should be used to declare and program SRCADRCHG.
 *
 */
typedef union BCM89500_A0_SRCADRCHGr_s {
	uint32_t v[1];
	uint32_t srcadrchg[1];
	uint32_t _srcadrchg;
} BCM89500_A0_SRCADRCHGr_t;

#define BCM89500_A0_SRCADRCHGr_CLR(r) (r).srcadrchg[0] = 0
#define BCM89500_A0_SRCADRCHGr_SET(r,d) (r).srcadrchg[0] = d
#define BCM89500_A0_SRCADRCHGr_GET(r) (r).srcadrchg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET(r) (((r).srcadrchg[0]) & 0x1ff)
#define BCM89500_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_SRCADRCHGr_RESERVEDf_GET(r) ((((r).srcadrchg[0]) >> 9) & 0x7f)
#define BCM89500_A0_SRCADRCHGr_RESERVEDf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SRCADRCHG.
 *
 */
#define BCM89500_A0_READ_SRCADRCHGr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SRCADRCHGr,(r._srcadrchg),2)
#define BCM89500_A0_WRITE_SRCADRCHGr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SRCADRCHGr,&(r._srcadrchg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRCADRCHGr BCM89500_A0_SRCADRCHGr
#define SRCADRCHGr_SIZE BCM89500_A0_SRCADRCHGr_SIZE
typedef BCM89500_A0_SRCADRCHGr_t SRCADRCHGr_t;
#define SRCADRCHGr_CLR BCM89500_A0_SRCADRCHGr_CLR
#define SRCADRCHGr_SET BCM89500_A0_SRCADRCHGr_SET
#define SRCADRCHGr_GET BCM89500_A0_SRCADRCHGr_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_GET BCM89500_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_SET BCM89500_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET
#define SRCADRCHGr_RESERVEDf_GET BCM89500_A0_SRCADRCHGr_RESERVEDf_GET
#define SRCADRCHGr_RESERVEDf_SET BCM89500_A0_SRCADRCHGr_RESERVEDf_SET
#define READ_SRCADRCHGr BCM89500_A0_READ_SRCADRCHGr
#define WRITE_SRCADRCHGr BCM89500_A0_WRITE_SRCADRCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SRCADRCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  STRAP_PIN_STATUS
 * BLOCKS:   SYS
 * DESC:     Strap Pin Status Register
 * SIZE:     32
 * FIELDS:
 *     STRAP_VALUE_VECTOR Display Strap Pin ValueBit 11 = phya_4Bit 10 = ejtag_enBit 9 = en_cpuBit 8:7 = mii2_mode[1:0]Bit 6:5 = mii3_mode[1:0]Bit 4:3 = mii1_mode[1:0]Bit 2 = hw_fwdg_enBit 1 = enextclkBit 0 = cpu_eeprom_sel
 *     CPU_EEPROM_SEL   
 *     ENEXTCLK         
 *     HW_FWDG_EN       
 *     IMP0_MII_MODE    
 *     IMP2_MII_MODE    
 *     IMP1_MII_MODE    
 *     EN_CPU           
 *     EJTAG_EN         
 *     PHYA_4           
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_STRAP_PIN_STATUSr 0x00000170

#define BCM89500_A0_STRAP_PIN_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program STRAP_PIN_STATUS.
 *
 */
typedef union BCM89500_A0_STRAP_PIN_STATUSr_s {
	uint32_t v[1];
	uint32_t strap_pin_status[1];
	uint32_t _strap_pin_status;
} BCM89500_A0_STRAP_PIN_STATUSr_t;

#define BCM89500_A0_STRAP_PIN_STATUSr_CLR(r) (r).strap_pin_status[0] = 0
#define BCM89500_A0_STRAP_PIN_STATUSr_SET(r,d) (r).strap_pin_status[0] = d
#define BCM89500_A0_STRAP_PIN_STATUSr_GET(r) (r).strap_pin_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_STRAP_PIN_STATUSr_STRAP_VALUE_VECTORf_GET(r) (((r).strap_pin_status[0]) & 0xfff)
#define BCM89500_A0_STRAP_PIN_STATUSr_STRAP_VALUE_VECTORf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM89500_A0_STRAP_PIN_STATUSr_CPU_EEPROM_SELf_GET(r) (((r).strap_pin_status[0]) & 0x1)
#define BCM89500_A0_STRAP_PIN_STATUSr_CPU_EEPROM_SELf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_STRAP_PIN_STATUSr_ENEXTCLKf_GET(r) ((((r).strap_pin_status[0]) >> 1) & 0x1)
#define BCM89500_A0_STRAP_PIN_STATUSr_ENEXTCLKf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_GET(r) ((((r).strap_pin_status[0]) >> 2) & 0x1)
#define BCM89500_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_STRAP_PIN_STATUSr_IMP0_MII_MODEf_GET(r) ((((r).strap_pin_status[0]) >> 3) & 0x3)
#define BCM89500_A0_STRAP_PIN_STATUSr_IMP0_MII_MODEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_STRAP_PIN_STATUSr_IMP2_MII_MODEf_GET(r) ((((r).strap_pin_status[0]) >> 5) & 0x3)
#define BCM89500_A0_STRAP_PIN_STATUSr_IMP2_MII_MODEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM89500_A0_STRAP_PIN_STATUSr_IMP1_MII_MODEf_GET(r) ((((r).strap_pin_status[0]) >> 7) & 0x3)
#define BCM89500_A0_STRAP_PIN_STATUSr_IMP1_MII_MODEf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM89500_A0_STRAP_PIN_STATUSr_EN_CPUf_GET(r) ((((r).strap_pin_status[0]) >> 9) & 0x1)
#define BCM89500_A0_STRAP_PIN_STATUSr_EN_CPUf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_STRAP_PIN_STATUSr_EJTAG_ENf_GET(r) ((((r).strap_pin_status[0]) >> 10) & 0x1)
#define BCM89500_A0_STRAP_PIN_STATUSr_EJTAG_ENf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_STRAP_PIN_STATUSr_PHYA_4f_GET(r) ((((r).strap_pin_status[0]) >> 11) & 0x1)
#define BCM89500_A0_STRAP_PIN_STATUSr_PHYA_4f_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_STRAP_PIN_STATUSr_RESERVEDf_GET(r) ((((r).strap_pin_status[0]) >> 12) & 0xfffff)
#define BCM89500_A0_STRAP_PIN_STATUSr_RESERVEDf_SET(r,f) (r).strap_pin_status[0]=(((r).strap_pin_status[0] & ~((uint32_t)0xfffff << 12)) | ((((uint32_t)f) & 0xfffff) << 12))

/*
 * These macros can be used to access STRAP_PIN_STATUS.
 *
 */
#define BCM89500_A0_READ_STRAP_PIN_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_STRAP_PIN_STATUSr,(r._strap_pin_status),4)
#define BCM89500_A0_WRITE_STRAP_PIN_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_STRAP_PIN_STATUSr,&(r._strap_pin_status),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_PIN_STATUSr BCM89500_A0_STRAP_PIN_STATUSr
#define STRAP_PIN_STATUSr_SIZE BCM89500_A0_STRAP_PIN_STATUSr_SIZE
typedef BCM89500_A0_STRAP_PIN_STATUSr_t STRAP_PIN_STATUSr_t;
#define STRAP_PIN_STATUSr_CLR BCM89500_A0_STRAP_PIN_STATUSr_CLR
#define STRAP_PIN_STATUSr_SET BCM89500_A0_STRAP_PIN_STATUSr_SET
#define STRAP_PIN_STATUSr_GET BCM89500_A0_STRAP_PIN_STATUSr_GET
#define STRAP_PIN_STATUSr_STRAP_VALUE_VECTORf_GET BCM89500_A0_STRAP_PIN_STATUSr_STRAP_VALUE_VECTORf_GET
#define STRAP_PIN_STATUSr_STRAP_VALUE_VECTORf_SET BCM89500_A0_STRAP_PIN_STATUSr_STRAP_VALUE_VECTORf_SET
#define STRAP_PIN_STATUSr_CPU_EEPROM_SELf_GET BCM89500_A0_STRAP_PIN_STATUSr_CPU_EEPROM_SELf_GET
#define STRAP_PIN_STATUSr_CPU_EEPROM_SELf_SET BCM89500_A0_STRAP_PIN_STATUSr_CPU_EEPROM_SELf_SET
#define STRAP_PIN_STATUSr_ENEXTCLKf_GET BCM89500_A0_STRAP_PIN_STATUSr_ENEXTCLKf_GET
#define STRAP_PIN_STATUSr_ENEXTCLKf_SET BCM89500_A0_STRAP_PIN_STATUSr_ENEXTCLKf_SET
#define STRAP_PIN_STATUSr_HW_FWDG_ENf_GET BCM89500_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_GET
#define STRAP_PIN_STATUSr_HW_FWDG_ENf_SET BCM89500_A0_STRAP_PIN_STATUSr_HW_FWDG_ENf_SET
#define STRAP_PIN_STATUSr_IMP0_MII_MODEf_GET BCM89500_A0_STRAP_PIN_STATUSr_IMP0_MII_MODEf_GET
#define STRAP_PIN_STATUSr_IMP0_MII_MODEf_SET BCM89500_A0_STRAP_PIN_STATUSr_IMP0_MII_MODEf_SET
#define STRAP_PIN_STATUSr_IMP2_MII_MODEf_GET BCM89500_A0_STRAP_PIN_STATUSr_IMP2_MII_MODEf_GET
#define STRAP_PIN_STATUSr_IMP2_MII_MODEf_SET BCM89500_A0_STRAP_PIN_STATUSr_IMP2_MII_MODEf_SET
#define STRAP_PIN_STATUSr_IMP1_MII_MODEf_GET BCM89500_A0_STRAP_PIN_STATUSr_IMP1_MII_MODEf_GET
#define STRAP_PIN_STATUSr_IMP1_MII_MODEf_SET BCM89500_A0_STRAP_PIN_STATUSr_IMP1_MII_MODEf_SET
#define STRAP_PIN_STATUSr_EN_CPUf_GET BCM89500_A0_STRAP_PIN_STATUSr_EN_CPUf_GET
#define STRAP_PIN_STATUSr_EN_CPUf_SET BCM89500_A0_STRAP_PIN_STATUSr_EN_CPUf_SET
#define STRAP_PIN_STATUSr_EJTAG_ENf_GET BCM89500_A0_STRAP_PIN_STATUSr_EJTAG_ENf_GET
#define STRAP_PIN_STATUSr_EJTAG_ENf_SET BCM89500_A0_STRAP_PIN_STATUSr_EJTAG_ENf_SET
#define STRAP_PIN_STATUSr_PHYA_4f_GET BCM89500_A0_STRAP_PIN_STATUSr_PHYA_4f_GET
#define STRAP_PIN_STATUSr_PHYA_4f_SET BCM89500_A0_STRAP_PIN_STATUSr_PHYA_4f_SET
#define STRAP_PIN_STATUSr_RESERVEDf_GET BCM89500_A0_STRAP_PIN_STATUSr_RESERVEDf_GET
#define STRAP_PIN_STATUSr_RESERVEDf_SET BCM89500_A0_STRAP_PIN_STATUSr_RESERVEDf_SET
#define READ_STRAP_PIN_STATUSr BCM89500_A0_READ_STRAP_PIN_STATUSr
#define WRITE_STRAP_PIN_STATUSr BCM89500_A0_WRITE_STRAP_PIN_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_STRAP_PIN_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  STS_OVERRIDE_GMIIP
 * BLOCKS:   GPIC0
 * DESC:     Port N GMII Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Software Port Speed setting2'b00 : 10Mbps2'b01 : 100Mbps2'b10 : 1000Mbps (if applicable)2'b11 : 200Mbps (if applicable)
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_OVERRIDE      CPU set software Override bit to 1 to make bit [5:0] affected.PHY scan register will be override.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_STS_OVERRIDE_GMIIPr 0x00000058

#define BCM89500_A0_STS_OVERRIDE_GMIIPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GMIIP.
 *
 */
typedef union BCM89500_A0_STS_OVERRIDE_GMIIPr_s {
	uint32_t v[1];
	uint32_t sts_override_gmiip[1];
	uint32_t _sts_override_gmiip;
} BCM89500_A0_STS_OVERRIDE_GMIIPr_t;

#define BCM89500_A0_STS_OVERRIDE_GMIIPr_CLR(r) (r).sts_override_gmiip[0] = 0
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_SET(r,d) (r).sts_override_gmiip[0] = d
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_GET(r) (r).sts_override_gmiip[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET(r) (((r).sts_override_gmiip[0]) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gmiip[0]) >> 1) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_SPEEDf_GET(r) ((((r).sts_override_gmiip[0]) >> 2) & 0x3)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_SPEEDf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 4) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 5) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET(r) ((((r).sts_override_gmiip[0]) >> 6) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_GET(r) ((((r).sts_override_gmiip[0]) >> 7) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GMIIP.
 *
 */
#define BCM89500_A0_READ_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_STS_OVERRIDE_GMIIPr,(r._sts_override_gmiip),1)
#define BCM89500_A0_WRITE_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_STS_OVERRIDE_GMIIPr,&(r._sts_override_gmiip),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GMIIPr BCM89500_A0_STS_OVERRIDE_GMIIPr
#define STS_OVERRIDE_GMIIPr_SIZE BCM89500_A0_STS_OVERRIDE_GMIIPr_SIZE
typedef BCM89500_A0_STS_OVERRIDE_GMIIPr_t STS_OVERRIDE_GMIIPr_t;
#define STS_OVERRIDE_GMIIPr_CLR BCM89500_A0_STS_OVERRIDE_GMIIPr_CLR
#define STS_OVERRIDE_GMIIPr_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_SET
#define STS_OVERRIDE_GMIIPr_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GMIIPr_SPEEDf_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_SPEEDf_GET
#define STS_OVERRIDE_GMIIPr_SPEEDf_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_SPEEDf_SET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET
#define STS_OVERRIDE_GMIIPr_RESERVED_1f_GET BCM89500_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_GET
#define STS_OVERRIDE_GMIIPr_RESERVED_1f_SET BCM89500_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_SET
#define READ_STS_OVERRIDE_GMIIPr BCM89500_A0_READ_STS_OVERRIDE_GMIIPr
#define WRITE_STS_OVERRIDE_GMIIPr BCM89500_A0_WRITE_STS_OVERRIDE_GMIIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_STS_OVERRIDE_GMIIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status0: Link fail1: Link pass
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Speed00: 10Mbps01: 100Mbps10: 1000Mbps (if applicable)11: 200Mbps (if applicable)
 *     RXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     TXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     RESERVED_1       Reserved
 *     MII_SW_OR        MII Software Override0: Use MII hardware pin status1: Use contents of this register
 *
 ******************************************************************************/
#define BCM89500_A0_STS_OVERRIDE_IMPr 0x0000000e

#define BCM89500_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 *
 */
typedef union BCM89500_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM89500_A0_STS_OVERRIDE_IMPr_t;

#define BCM89500_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM89500_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM89500_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_STS_OVERRIDE_IMPr_SPEEDf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM89500_A0_STS_OVERRIDE_IMPr_SPEEDf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_STS_OVERRIDE_IMPr_RESERVED_1f_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_IMPr_RESERVED_1f_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 *
 */
#define BCM89500_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM89500_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM89500_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM89500_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM89500_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM89500_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM89500_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM89500_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM89500_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM89500_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM89500_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM89500_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_SPEEDf_GET BCM89500_A0_STS_OVERRIDE_IMPr_SPEEDf_GET
#define STS_OVERRIDE_IMPr_SPEEDf_SET BCM89500_A0_STS_OVERRIDE_IMPr_SPEEDf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM89500_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM89500_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET BCM89500_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET BCM89500_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_RESERVED_1f_GET BCM89500_A0_STS_OVERRIDE_IMPr_RESERVED_1f_GET
#define STS_OVERRIDE_IMPr_RESERVED_1f_SET BCM89500_A0_STS_OVERRIDE_IMPr_RESERVED_1f_SET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_GET BCM89500_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_SET BCM89500_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET
#define READ_STS_OVERRIDE_IMPr BCM89500_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM89500_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_STS_OVERRIDE_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  STS_OVERRIDE_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 GMII Port States Override Register (polar feature)
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Software Port Speed setting2'b00 : 10Mbps2'b01 : 100Mbps2'b10 : 1000Mbps (if applicable)2'b11 : 200Mbps (if applicable)
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_OVERRIDE      CPU set software Override bit to 1 to make bit [5:0] affected.PHY scan register will be override.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_STS_OVERRIDE_P7r 0x0000005f

#define BCM89500_A0_STS_OVERRIDE_P7r_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_P7.
 *
 */
typedef union BCM89500_A0_STS_OVERRIDE_P7r_s {
	uint32_t v[1];
	uint32_t sts_override_p7[1];
	uint32_t _sts_override_p7;
} BCM89500_A0_STS_OVERRIDE_P7r_t;

#define BCM89500_A0_STS_OVERRIDE_P7r_CLR(r) (r).sts_override_p7[0] = 0
#define BCM89500_A0_STS_OVERRIDE_P7r_SET(r,d) (r).sts_override_p7[0] = d
#define BCM89500_A0_STS_OVERRIDE_P7r_GET(r) (r).sts_override_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_STS_OVERRIDE_P7r_LINK_STSf_GET(r) (((r).sts_override_p7[0]) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_P7r_LINK_STSf_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_STS_OVERRIDE_P7r_DUPLX_MODEf_GET(r) ((((r).sts_override_p7[0]) >> 1) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_P7r_DUPLX_MODEf_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_STS_OVERRIDE_P7r_SPEEDf_GET(r) ((((r).sts_override_p7[0]) >> 2) & 0x3)
#define BCM89500_A0_STS_OVERRIDE_P7r_SPEEDf_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_STS_OVERRIDE_P7r_RXFLOW_CNTLf_GET(r) ((((r).sts_override_p7[0]) >> 4) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_P7r_RXFLOW_CNTLf_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_STS_OVERRIDE_P7r_TXFLOW_CNTLf_GET(r) ((((r).sts_override_p7[0]) >> 5) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_P7r_TXFLOW_CNTLf_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_STS_OVERRIDE_P7r_SW_OVERRIDEf_GET(r) ((((r).sts_override_p7[0]) >> 6) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_P7r_SW_OVERRIDEf_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_STS_OVERRIDE_P7r_RESERVED_1f_GET(r) ((((r).sts_override_p7[0]) >> 7) & 0x1)
#define BCM89500_A0_STS_OVERRIDE_P7r_RESERVED_1f_SET(r,f) (r).sts_override_p7[0]=(((r).sts_override_p7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_P7.
 *
 */
#define BCM89500_A0_READ_STS_OVERRIDE_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_STS_OVERRIDE_P7r,(r._sts_override_p7),1)
#define BCM89500_A0_WRITE_STS_OVERRIDE_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_STS_OVERRIDE_P7r,&(r._sts_override_p7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_P7r BCM89500_A0_STS_OVERRIDE_P7r
#define STS_OVERRIDE_P7r_SIZE BCM89500_A0_STS_OVERRIDE_P7r_SIZE
typedef BCM89500_A0_STS_OVERRIDE_P7r_t STS_OVERRIDE_P7r_t;
#define STS_OVERRIDE_P7r_CLR BCM89500_A0_STS_OVERRIDE_P7r_CLR
#define STS_OVERRIDE_P7r_SET BCM89500_A0_STS_OVERRIDE_P7r_SET
#define STS_OVERRIDE_P7r_GET BCM89500_A0_STS_OVERRIDE_P7r_GET
#define STS_OVERRIDE_P7r_LINK_STSf_GET BCM89500_A0_STS_OVERRIDE_P7r_LINK_STSf_GET
#define STS_OVERRIDE_P7r_LINK_STSf_SET BCM89500_A0_STS_OVERRIDE_P7r_LINK_STSf_SET
#define STS_OVERRIDE_P7r_DUPLX_MODEf_GET BCM89500_A0_STS_OVERRIDE_P7r_DUPLX_MODEf_GET
#define STS_OVERRIDE_P7r_DUPLX_MODEf_SET BCM89500_A0_STS_OVERRIDE_P7r_DUPLX_MODEf_SET
#define STS_OVERRIDE_P7r_SPEEDf_GET BCM89500_A0_STS_OVERRIDE_P7r_SPEEDf_GET
#define STS_OVERRIDE_P7r_SPEEDf_SET BCM89500_A0_STS_OVERRIDE_P7r_SPEEDf_SET
#define STS_OVERRIDE_P7r_RXFLOW_CNTLf_GET BCM89500_A0_STS_OVERRIDE_P7r_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_P7r_RXFLOW_CNTLf_SET BCM89500_A0_STS_OVERRIDE_P7r_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_P7r_TXFLOW_CNTLf_GET BCM89500_A0_STS_OVERRIDE_P7r_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_P7r_TXFLOW_CNTLf_SET BCM89500_A0_STS_OVERRIDE_P7r_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_P7r_SW_OVERRIDEf_GET BCM89500_A0_STS_OVERRIDE_P7r_SW_OVERRIDEf_GET
#define STS_OVERRIDE_P7r_SW_OVERRIDEf_SET BCM89500_A0_STS_OVERRIDE_P7r_SW_OVERRIDEf_SET
#define STS_OVERRIDE_P7r_RESERVED_1f_GET BCM89500_A0_STS_OVERRIDE_P7r_RESERVED_1f_GET
#define STS_OVERRIDE_P7r_RESERVED_1f_SET BCM89500_A0_STS_OVERRIDE_P7r_RESERVED_1f_SET
#define READ_STS_OVERRIDE_P7r BCM89500_A0_READ_STS_OVERRIDE_P7r
#define WRITE_STS_OVERRIDE_P7r BCM89500_A0_WRITE_STS_OVERRIDE_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_STS_OVERRIDE_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SWITCH_CTRL
 * BLOCKS:   SYS
 * DESC:     Switch Control Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     MII1_VOL_SEL     To select various voltages for port 8.
 *     MII2_VOL_SEL     To select various voltages for port 5.
 *     MII3_VOL_SEL     To select various voltages for port 4.mii*_vol_sel register default value :when mii_mode = (RGMII_MODE),  mii*_vol_sel = 1 (2.5V),else mii*_vol_sel = 0 (3.3V)
 *     GPHY_PLLBYPASS   gphy PLL bypass (test pin).
 *     RESERVED_0       Reserved
 *     MII_DUMB_FWDG_EN To include port8 (IMP) for forwarding in dumb mode.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SWITCH_CTRLr 0x00000022

#define BCM89500_A0_SWITCH_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program SWITCH_CTRL.
 *
 */
typedef union BCM89500_A0_SWITCH_CTRLr_s {
	uint32_t v[1];
	uint32_t switch_ctrl[1];
	uint32_t _switch_ctrl;
} BCM89500_A0_SWITCH_CTRLr_t;

#define BCM89500_A0_SWITCH_CTRLr_CLR(r) (r).switch_ctrl[0] = 0
#define BCM89500_A0_SWITCH_CTRLr_SET(r,d) (r).switch_ctrl[0] = d
#define BCM89500_A0_SWITCH_CTRLr_GET(r) (r).switch_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SWITCH_CTRLr_MII1_VOL_SELf_GET(r) (((r).switch_ctrl[0]) & 0x1)
#define BCM89500_A0_SWITCH_CTRLr_MII1_VOL_SELf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SWITCH_CTRLr_MII2_VOL_SELf_GET(r) ((((r).switch_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_SWITCH_CTRLr_MII2_VOL_SELf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SWITCH_CTRLr_MII3_VOL_SELf_GET(r) ((((r).switch_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_SWITCH_CTRLr_MII3_VOL_SELf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SWITCH_CTRLr_GPHY_PLLBYPASSf_GET(r) ((((r).switch_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_SWITCH_CTRLr_GPHY_PLLBYPASSf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SWITCH_CTRLr_RESERVED_0f_GET(r) ((((r).switch_ctrl[0]) >> 4) & 0x3)
#define BCM89500_A0_SWITCH_CTRLr_RESERVED_0f_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_SWITCH_CTRLr_MII_DUMB_FWDG_ENf_GET(r) ((((r).switch_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_SWITCH_CTRLr_MII_DUMB_FWDG_ENf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_SWITCH_CTRLr_RESERVED_1f_GET(r) ((((r).switch_ctrl[0]) >> 7) & 0x1ff)
#define BCM89500_A0_SWITCH_CTRLr_RESERVED_1f_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access SWITCH_CTRL.
 *
 */
#define BCM89500_A0_READ_SWITCH_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SWITCH_CTRLr,(r._switch_ctrl),2)
#define BCM89500_A0_WRITE_SWITCH_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SWITCH_CTRLr,&(r._switch_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWITCH_CTRLr BCM89500_A0_SWITCH_CTRLr
#define SWITCH_CTRLr_SIZE BCM89500_A0_SWITCH_CTRLr_SIZE
typedef BCM89500_A0_SWITCH_CTRLr_t SWITCH_CTRLr_t;
#define SWITCH_CTRLr_CLR BCM89500_A0_SWITCH_CTRLr_CLR
#define SWITCH_CTRLr_SET BCM89500_A0_SWITCH_CTRLr_SET
#define SWITCH_CTRLr_GET BCM89500_A0_SWITCH_CTRLr_GET
#define SWITCH_CTRLr_MII1_VOL_SELf_GET BCM89500_A0_SWITCH_CTRLr_MII1_VOL_SELf_GET
#define SWITCH_CTRLr_MII1_VOL_SELf_SET BCM89500_A0_SWITCH_CTRLr_MII1_VOL_SELf_SET
#define SWITCH_CTRLr_MII2_VOL_SELf_GET BCM89500_A0_SWITCH_CTRLr_MII2_VOL_SELf_GET
#define SWITCH_CTRLr_MII2_VOL_SELf_SET BCM89500_A0_SWITCH_CTRLr_MII2_VOL_SELf_SET
#define SWITCH_CTRLr_MII3_VOL_SELf_GET BCM89500_A0_SWITCH_CTRLr_MII3_VOL_SELf_GET
#define SWITCH_CTRLr_MII3_VOL_SELf_SET BCM89500_A0_SWITCH_CTRLr_MII3_VOL_SELf_SET
#define SWITCH_CTRLr_GPHY_PLLBYPASSf_GET BCM89500_A0_SWITCH_CTRLr_GPHY_PLLBYPASSf_GET
#define SWITCH_CTRLr_GPHY_PLLBYPASSf_SET BCM89500_A0_SWITCH_CTRLr_GPHY_PLLBYPASSf_SET
#define SWITCH_CTRLr_RESERVED_0f_GET BCM89500_A0_SWITCH_CTRLr_RESERVED_0f_GET
#define SWITCH_CTRLr_RESERVED_0f_SET BCM89500_A0_SWITCH_CTRLr_RESERVED_0f_SET
#define SWITCH_CTRLr_MII_DUMB_FWDG_ENf_GET BCM89500_A0_SWITCH_CTRLr_MII_DUMB_FWDG_ENf_GET
#define SWITCH_CTRLr_MII_DUMB_FWDG_ENf_SET BCM89500_A0_SWITCH_CTRLr_MII_DUMB_FWDG_ENf_SET
#define SWITCH_CTRLr_RESERVED_1f_GET BCM89500_A0_SWITCH_CTRLr_RESERVED_1f_GET
#define SWITCH_CTRLr_RESERVED_1f_SET BCM89500_A0_SWITCH_CTRLr_RESERVED_1f_SET
#define READ_SWITCH_CTRLr BCM89500_A0_READ_SWITCH_CTRLr
#define WRITE_SWITCH_CTRLr BCM89500_A0_WRITE_SWITCH_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SWITCH_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.Strapped from the inverse of the HW_FWDG_EN pin at power-on. Can be overwritten subsequently.0 = Unmanaged Mode.1 = Managed ModeThe ARL treats Reserved Multicast addresses differently dependent on this selection. See Table 3 for a precise definition.
 *     SW_FWDG_EN       Software Forwarding EnableSW_FWDG_EN=1: Frame forwarding is enabled.SW_FWDG_EN=0: Frame forwarding is disabled.Read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently. For managed switch implementations (polar 5388 mode), the switch should be configured to disable forwarding on power-on, to allow the processor to configure the internal address table and other parameters, before frame forwarding is enabled.
 *     RTRY_LMT_DIS     (Not2Release)SwitchGeneralMode.RetryLimitDisable.When set, disables the Retry limit on all MAC ports (10/100BASE-T and MII ports). Causes a MAC port in half duplex operation, to continue to retry the same packet regardless of the number of collision attempts.
 *     FAST_TXDESC_RERURN (Not2Release)Controls which algorithm is used to release packets when a link goes down.
 *     NOBLKCD          (Not2Release)Always not to block carrier detected signal.1'b1: Not to block. txport will always defer to CRS.1'b0: Block CD(compatiable with BCM5328).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_SWMODEr 0x0000000b

#define BCM89500_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 *
 */
typedef union BCM89500_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM89500_A0_SWMODEr_t;

#define BCM89500_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM89500_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM89500_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM89500_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM89500_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_SWMODEr_RTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM89500_A0_SWMODEr_RTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_SWMODEr_FAST_TXDESC_RERURNf_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM89500_A0_SWMODEr_FAST_TXDESC_RERURNf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_SWMODEr_NOBLKCDf_GET(r) ((((r).swmode[0]) >> 4) & 0x1)
#define BCM89500_A0_SWMODEr_NOBLKCDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_SWMODEr_RESERVEDf_GET(r) ((((r).swmode[0]) >> 5) & 0x7)
#define BCM89500_A0_SWMODEr_RESERVEDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SWMODE.
 *
 */
#define BCM89500_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_SWMODEr,(r._swmode),1)
#define BCM89500_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM89500_A0_SWMODEr
#define SWMODEr_SIZE BCM89500_A0_SWMODEr_SIZE
typedef BCM89500_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM89500_A0_SWMODEr_CLR
#define SWMODEr_SET BCM89500_A0_SWMODEr_SET
#define SWMODEr_GET BCM89500_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM89500_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM89500_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM89500_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM89500_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_RTRY_LMT_DISf_GET BCM89500_A0_SWMODEr_RTRY_LMT_DISf_GET
#define SWMODEr_RTRY_LMT_DISf_SET BCM89500_A0_SWMODEr_RTRY_LMT_DISf_SET
#define SWMODEr_FAST_TXDESC_RERURNf_GET BCM89500_A0_SWMODEr_FAST_TXDESC_RERURNf_GET
#define SWMODEr_FAST_TXDESC_RERURNf_SET BCM89500_A0_SWMODEr_FAST_TXDESC_RERURNf_SET
#define SWMODEr_NOBLKCDf_GET BCM89500_A0_SWMODEr_NOBLKCDf_GET
#define SWMODEr_NOBLKCDf_SET BCM89500_A0_SWMODEr_NOBLKCDf_SET
#define SWMODEr_RESERVEDf_GET BCM89500_A0_SWMODEr_RESERVEDf_GET
#define SWMODEr_RESERVEDf_SET BCM89500_A0_SWMODEr_RESERVEDf_SET
#define READ_SWMODEr BCM89500_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM89500_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_SWMODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_EEE_LPI_DURATION
 * BLOCKS:   SYS
 * DESC:     EEE Low-Power Idle Duration Registers
 * SIZE:     32
 * FIELDS:
 *     COUNT            EEE low-power idle duration.This counter accumulates the number of microseconds that the associated MAC/PHY is in the low-power idle state.The unit is 1 usec
 *
 ******************************************************************************/
#define BCM89500_A0_S_EEE_LPI_DURATIONr 0x000071bc

#define BCM89500_A0_S_EEE_LPI_DURATIONr_SIZE 4

/*
 * This structure should be used to declare and program S_EEE_LPI_DURATION.
 *
 */
typedef union BCM89500_A0_S_EEE_LPI_DURATIONr_s {
	uint32_t v[1];
	uint32_t s_eee_lpi_duration[1];
	uint32_t _s_eee_lpi_duration;
} BCM89500_A0_S_EEE_LPI_DURATIONr_t;

#define BCM89500_A0_S_EEE_LPI_DURATIONr_CLR(r) (r).s_eee_lpi_duration[0] = 0
#define BCM89500_A0_S_EEE_LPI_DURATIONr_SET(r,d) (r).s_eee_lpi_duration[0] = d
#define BCM89500_A0_S_EEE_LPI_DURATIONr_GET(r) (r).s_eee_lpi_duration[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_EEE_LPI_DURATIONr_COUNTf_GET(r) ((r).s_eee_lpi_duration[0])
#define BCM89500_A0_S_EEE_LPI_DURATIONr_COUNTf_SET(r,f) (r).s_eee_lpi_duration[0]=((uint32_t)f)

/*
 * These macros can be used to access S_EEE_LPI_DURATION.
 *
 */
#define BCM89500_A0_READ_S_EEE_LPI_DURATIONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_EEE_LPI_DURATIONr,(r._s_eee_lpi_duration),4)
#define BCM89500_A0_WRITE_S_EEE_LPI_DURATIONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_EEE_LPI_DURATIONr,&(r._s_eee_lpi_duration),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_EEE_LPI_DURATIONr BCM89500_A0_S_EEE_LPI_DURATIONr
#define S_EEE_LPI_DURATIONr_SIZE BCM89500_A0_S_EEE_LPI_DURATIONr_SIZE
typedef BCM89500_A0_S_EEE_LPI_DURATIONr_t S_EEE_LPI_DURATIONr_t;
#define S_EEE_LPI_DURATIONr_CLR BCM89500_A0_S_EEE_LPI_DURATIONr_CLR
#define S_EEE_LPI_DURATIONr_SET BCM89500_A0_S_EEE_LPI_DURATIONr_SET
#define S_EEE_LPI_DURATIONr_GET BCM89500_A0_S_EEE_LPI_DURATIONr_GET
#define S_EEE_LPI_DURATIONr_COUNTf_GET BCM89500_A0_S_EEE_LPI_DURATIONr_COUNTf_GET
#define S_EEE_LPI_DURATIONr_COUNTf_SET BCM89500_A0_S_EEE_LPI_DURATIONr_COUNTf_SET
#define READ_S_EEE_LPI_DURATIONr BCM89500_A0_READ_S_EEE_LPI_DURATIONr
#define WRITE_S_EEE_LPI_DURATIONr BCM89500_A0_WRITE_S_EEE_LPI_DURATIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_EEE_LPI_DURATIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_EEE_LPI_EVENT
 * BLOCKS:   SYS
 * DESC:     EEE Low-Power Idle Event Registers
 * SIZE:     32
 * FIELDS:
 *     COUNT            EEE low-power idle eventIn asymmetric mode, this is simply a count of the number of times that the lowPowerAssert control signal has been asserted for each MAC. In symmetric mode, this is the count of the number of times both lowPowerAssert and the lowPowerIndicate(from the receive path) are asserted simultaneously.
 *
 ******************************************************************************/
#define BCM89500_A0_S_EEE_LPI_EVENTr 0x000071b8

#define BCM89500_A0_S_EEE_LPI_EVENTr_SIZE 4

/*
 * This structure should be used to declare and program S_EEE_LPI_EVENT.
 *
 */
typedef union BCM89500_A0_S_EEE_LPI_EVENTr_s {
	uint32_t v[1];
	uint32_t s_eee_lpi_event[1];
	uint32_t _s_eee_lpi_event;
} BCM89500_A0_S_EEE_LPI_EVENTr_t;

#define BCM89500_A0_S_EEE_LPI_EVENTr_CLR(r) (r).s_eee_lpi_event[0] = 0
#define BCM89500_A0_S_EEE_LPI_EVENTr_SET(r,d) (r).s_eee_lpi_event[0] = d
#define BCM89500_A0_S_EEE_LPI_EVENTr_GET(r) (r).s_eee_lpi_event[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_EEE_LPI_EVENTr_COUNTf_GET(r) ((r).s_eee_lpi_event[0])
#define BCM89500_A0_S_EEE_LPI_EVENTr_COUNTf_SET(r,f) (r).s_eee_lpi_event[0]=((uint32_t)f)

/*
 * These macros can be used to access S_EEE_LPI_EVENT.
 *
 */
#define BCM89500_A0_READ_S_EEE_LPI_EVENTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_EEE_LPI_EVENTr,(r._s_eee_lpi_event),4)
#define BCM89500_A0_WRITE_S_EEE_LPI_EVENTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_EEE_LPI_EVENTr,&(r._s_eee_lpi_event),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_EEE_LPI_EVENTr BCM89500_A0_S_EEE_LPI_EVENTr
#define S_EEE_LPI_EVENTr_SIZE BCM89500_A0_S_EEE_LPI_EVENTr_SIZE
typedef BCM89500_A0_S_EEE_LPI_EVENTr_t S_EEE_LPI_EVENTr_t;
#define S_EEE_LPI_EVENTr_CLR BCM89500_A0_S_EEE_LPI_EVENTr_CLR
#define S_EEE_LPI_EVENTr_SET BCM89500_A0_S_EEE_LPI_EVENTr_SET
#define S_EEE_LPI_EVENTr_GET BCM89500_A0_S_EEE_LPI_EVENTr_GET
#define S_EEE_LPI_EVENTr_COUNTf_GET BCM89500_A0_S_EEE_LPI_EVENTr_COUNTf_GET
#define S_EEE_LPI_EVENTr_COUNTf_SET BCM89500_A0_S_EEE_LPI_EVENTr_COUNTf_SET
#define READ_S_EEE_LPI_EVENTr BCM89500_A0_READ_S_EEE_LPI_EVENTr
#define WRITE_S_EEE_LPI_EVENTr BCM89500_A0_WRITE_S_EEE_LPI_EVENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_EEE_LPI_EVENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_InRangeErrCount
 * BLOCKS:   SYS
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_INRANGEERRCOUNTr 0x000071b0

#define BCM89500_A0_S_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_InRangeErrCount.
 *
 */
typedef union BCM89500_A0_S_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_inrangeerrcount[1];
	uint32_t _s_inrangeerrcount;
} BCM89500_A0_S_INRANGEERRCOUNTr_t;

#define BCM89500_A0_S_INRANGEERRCOUNTr_CLR(r) (r).s_inrangeerrcount[0] = 0
#define BCM89500_A0_S_INRANGEERRCOUNTr_SET(r,d) (r).s_inrangeerrcount[0] = d
#define BCM89500_A0_S_INRANGEERRCOUNTr_GET(r) (r).s_inrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_INRANGEERRCOUNTr_COUNTf_GET(r) ((r).s_inrangeerrcount[0])
#define BCM89500_A0_S_INRANGEERRCOUNTr_COUNTf_SET(r,f) (r).s_inrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_InRangeErrCount.
 *
 */
#define BCM89500_A0_READ_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_INRANGEERRCOUNTr,(r._s_inrangeerrcount),4)
#define BCM89500_A0_WRITE_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_INRANGEERRCOUNTr,&(r._s_inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_INRANGEERRCOUNTr BCM89500_A0_S_INRANGEERRCOUNTr
#define S_INRANGEERRCOUNTr_SIZE BCM89500_A0_S_INRANGEERRCOUNTr_SIZE
typedef BCM89500_A0_S_INRANGEERRCOUNTr_t S_INRANGEERRCOUNTr_t;
#define S_INRANGEERRCOUNTr_CLR BCM89500_A0_S_INRANGEERRCOUNTr_CLR
#define S_INRANGEERRCOUNTr_SET BCM89500_A0_S_INRANGEERRCOUNTr_SET
#define S_INRANGEERRCOUNTr_GET BCM89500_A0_S_INRANGEERRCOUNTr_GET
#define S_INRANGEERRCOUNTr_COUNTf_GET BCM89500_A0_S_INRANGEERRCOUNTr_COUNTf_GET
#define S_INRANGEERRCOUNTr_COUNTf_SET BCM89500_A0_S_INRANGEERRCOUNTr_COUNTf_SET
#define READ_S_INRANGEERRCOUNTr BCM89500_A0_READ_S_INRANGEERRCOUNTr
#define WRITE_S_INRANGEERRCOUNTr BCM89500_A0_WRITE_S_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_JumboPkt
 * BLOCKS:   SYS
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_JUMBOPKTr 0x000071a8

#define BCM89500_A0_S_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_JumboPkt.
 *
 */
typedef union BCM89500_A0_S_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t s_jumbopkt[1];
	uint32_t _s_jumbopkt;
} BCM89500_A0_S_JUMBOPKTr_t;

#define BCM89500_A0_S_JUMBOPKTr_CLR(r) (r).s_jumbopkt[0] = 0
#define BCM89500_A0_S_JUMBOPKTr_SET(r,d) (r).s_jumbopkt[0] = d
#define BCM89500_A0_S_JUMBOPKTr_GET(r) (r).s_jumbopkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_JUMBOPKTr_COUNTf_GET(r) ((r).s_jumbopkt[0])
#define BCM89500_A0_S_JUMBOPKTr_COUNTf_SET(r,f) (r).s_jumbopkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_JumboPkt.
 *
 */
#define BCM89500_A0_READ_S_JUMBOPKTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_JUMBOPKTr,(r._s_jumbopkt),4)
#define BCM89500_A0_WRITE_S_JUMBOPKTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_JUMBOPKTr,&(r._s_jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_JUMBOPKTr BCM89500_A0_S_JUMBOPKTr
#define S_JUMBOPKTr_SIZE BCM89500_A0_S_JUMBOPKTr_SIZE
typedef BCM89500_A0_S_JUMBOPKTr_t S_JUMBOPKTr_t;
#define S_JUMBOPKTr_CLR BCM89500_A0_S_JUMBOPKTr_CLR
#define S_JUMBOPKTr_SET BCM89500_A0_S_JUMBOPKTr_SET
#define S_JUMBOPKTr_GET BCM89500_A0_S_JUMBOPKTr_GET
#define S_JUMBOPKTr_COUNTf_GET BCM89500_A0_S_JUMBOPKTr_COUNTf_GET
#define S_JUMBOPKTr_COUNTf_SET BCM89500_A0_S_JUMBOPKTr_COUNTf_SET
#define READ_S_JUMBOPKTr BCM89500_A0_READ_S_JUMBOPKTr
#define WRITE_S_JUMBOPKTr BCM89500_A0_WRITE_S_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_OutRangeErrCount
 * BLOCKS:   SYS
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_OUTRANGEERRCOUNTr 0x000071b4

#define BCM89500_A0_S_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_OutRangeErrCount.
 *
 */
typedef union BCM89500_A0_S_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_outrangeerrcount[1];
	uint32_t _s_outrangeerrcount;
} BCM89500_A0_S_OUTRANGEERRCOUNTr_t;

#define BCM89500_A0_S_OUTRANGEERRCOUNTr_CLR(r) (r).s_outrangeerrcount[0] = 0
#define BCM89500_A0_S_OUTRANGEERRCOUNTr_SET(r,d) (r).s_outrangeerrcount[0] = d
#define BCM89500_A0_S_OUTRANGEERRCOUNTr_GET(r) (r).s_outrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_OUTRANGEERRCOUNTr_COUNTf_GET(r) ((r).s_outrangeerrcount[0])
#define BCM89500_A0_S_OUTRANGEERRCOUNTr_COUNTf_SET(r,f) (r).s_outrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_OutRangeErrCount.
 *
 */
#define BCM89500_A0_READ_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_OUTRANGEERRCOUNTr,(r._s_outrangeerrcount),4)
#define BCM89500_A0_WRITE_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_OUTRANGEERRCOUNTr,&(r._s_outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_OUTRANGEERRCOUNTr BCM89500_A0_S_OUTRANGEERRCOUNTr
#define S_OUTRANGEERRCOUNTr_SIZE BCM89500_A0_S_OUTRANGEERRCOUNTr_SIZE
typedef BCM89500_A0_S_OUTRANGEERRCOUNTr_t S_OUTRANGEERRCOUNTr_t;
#define S_OUTRANGEERRCOUNTr_CLR BCM89500_A0_S_OUTRANGEERRCOUNTr_CLR
#define S_OUTRANGEERRCOUNTr_SET BCM89500_A0_S_OUTRANGEERRCOUNTr_SET
#define S_OUTRANGEERRCOUNTr_GET BCM89500_A0_S_OUTRANGEERRCOUNTr_GET
#define S_OUTRANGEERRCOUNTr_COUNTf_GET BCM89500_A0_S_OUTRANGEERRCOUNTr_COUNTf_GET
#define S_OUTRANGEERRCOUNTr_COUNTf_SET BCM89500_A0_S_OUTRANGEERRCOUNTr_COUNTf_SET
#define READ_S_OUTRANGEERRCOUNTr BCM89500_A0_READ_S_OUTRANGEERRCOUNTr
#define WRITE_S_OUTRANGEERRCOUNTr BCM89500_A0_WRITE_S_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_Pkts1024toMaxPktOctets
 * BLOCKS:   SYS
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr 0x00007174

#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts1024tomaxpktoctets[1];
	uint32_t _s_pkts1024tomaxpktoctets;
} BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).s_pkts1024tomaxpktoctets[0] = 0
#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).s_pkts1024tomaxpktoctets[0] = d
#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).s_pkts1024tomaxpktoctets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET(r) ((r).s_pkts1024tomaxpktoctets[0])
#define BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET(r,f) (r).s_pkts1024tomaxpktoctets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1024toMaxPktOctets.
 *
 */
#define BCM89500_A0_READ_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr,(r._s_pkts1024tomaxpktoctets),4)
#define BCM89500_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr,&(r._s_pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1024TOMAXPKTOCTETSr BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr
#define S_PKTS1024TOMAXPKTOCTETSr_SIZE BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_t S_PKTS1024TOMAXPKTOCTETSr_t;
#define S_PKTS1024TOMAXPKTOCTETSr_CLR BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR
#define S_PKTS1024TOMAXPKTOCTETSr_SET BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_SET
#define S_PKTS1024TOMAXPKTOCTETSr_GET BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET
#define READ_S_PKTS1024TOMAXPKTOCTETSr BCM89500_A0_READ_S_PKTS1024TOMAXPKTOCTETSr
#define WRITE_S_PKTS1024TOMAXPKTOCTETSr BCM89500_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_Pkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_PKTS128TO255OCTETSr 0x00007168

#define BCM89500_A0_S_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts128to255Octets.
 *
 */
typedef union BCM89500_A0_S_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts128to255octets[1];
	uint32_t _s_pkts128to255octets;
} BCM89500_A0_S_PKTS128TO255OCTETSr_t;

#define BCM89500_A0_S_PKTS128TO255OCTETSr_CLR(r) (r).s_pkts128to255octets[0] = 0
#define BCM89500_A0_S_PKTS128TO255OCTETSr_SET(r,d) (r).s_pkts128to255octets[0] = d
#define BCM89500_A0_S_PKTS128TO255OCTETSr_GET(r) (r).s_pkts128to255octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_PKTS128TO255OCTETSr_COUNTf_GET(r) ((r).s_pkts128to255octets[0])
#define BCM89500_A0_S_PKTS128TO255OCTETSr_COUNTf_SET(r,f) (r).s_pkts128to255octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts128to255Octets.
 *
 */
#define BCM89500_A0_READ_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_PKTS128TO255OCTETSr,(r._s_pkts128to255octets),4)
#define BCM89500_A0_WRITE_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_PKTS128TO255OCTETSr,&(r._s_pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS128TO255OCTETSr BCM89500_A0_S_PKTS128TO255OCTETSr
#define S_PKTS128TO255OCTETSr_SIZE BCM89500_A0_S_PKTS128TO255OCTETSr_SIZE
typedef BCM89500_A0_S_PKTS128TO255OCTETSr_t S_PKTS128TO255OCTETSr_t;
#define S_PKTS128TO255OCTETSr_CLR BCM89500_A0_S_PKTS128TO255OCTETSr_CLR
#define S_PKTS128TO255OCTETSr_SET BCM89500_A0_S_PKTS128TO255OCTETSr_SET
#define S_PKTS128TO255OCTETSr_GET BCM89500_A0_S_PKTS128TO255OCTETSr_GET
#define S_PKTS128TO255OCTETSr_COUNTf_GET BCM89500_A0_S_PKTS128TO255OCTETSr_COUNTf_GET
#define S_PKTS128TO255OCTETSr_COUNTf_SET BCM89500_A0_S_PKTS128TO255OCTETSr_COUNTf_SET
#define READ_S_PKTS128TO255OCTETSr BCM89500_A0_READ_S_PKTS128TO255OCTETSr
#define WRITE_S_PKTS128TO255OCTETSr BCM89500_A0_WRITE_S_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_Pkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_PKTS256TO511OCTETSr 0x0000716c

#define BCM89500_A0_S_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts256to511Octets.
 *
 */
typedef union BCM89500_A0_S_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts256to511octets[1];
	uint32_t _s_pkts256to511octets;
} BCM89500_A0_S_PKTS256TO511OCTETSr_t;

#define BCM89500_A0_S_PKTS256TO511OCTETSr_CLR(r) (r).s_pkts256to511octets[0] = 0
#define BCM89500_A0_S_PKTS256TO511OCTETSr_SET(r,d) (r).s_pkts256to511octets[0] = d
#define BCM89500_A0_S_PKTS256TO511OCTETSr_GET(r) (r).s_pkts256to511octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_PKTS256TO511OCTETSr_COUNTf_GET(r) ((r).s_pkts256to511octets[0])
#define BCM89500_A0_S_PKTS256TO511OCTETSr_COUNTf_SET(r,f) (r).s_pkts256to511octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts256to511Octets.
 *
 */
#define BCM89500_A0_READ_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_PKTS256TO511OCTETSr,(r._s_pkts256to511octets),4)
#define BCM89500_A0_WRITE_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_PKTS256TO511OCTETSr,&(r._s_pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS256TO511OCTETSr BCM89500_A0_S_PKTS256TO511OCTETSr
#define S_PKTS256TO511OCTETSr_SIZE BCM89500_A0_S_PKTS256TO511OCTETSr_SIZE
typedef BCM89500_A0_S_PKTS256TO511OCTETSr_t S_PKTS256TO511OCTETSr_t;
#define S_PKTS256TO511OCTETSr_CLR BCM89500_A0_S_PKTS256TO511OCTETSr_CLR
#define S_PKTS256TO511OCTETSr_SET BCM89500_A0_S_PKTS256TO511OCTETSr_SET
#define S_PKTS256TO511OCTETSr_GET BCM89500_A0_S_PKTS256TO511OCTETSr_GET
#define S_PKTS256TO511OCTETSr_COUNTf_GET BCM89500_A0_S_PKTS256TO511OCTETSr_COUNTf_GET
#define S_PKTS256TO511OCTETSr_COUNTf_SET BCM89500_A0_S_PKTS256TO511OCTETSr_COUNTf_SET
#define READ_S_PKTS256TO511OCTETSr BCM89500_A0_READ_S_PKTS256TO511OCTETSr
#define WRITE_S_PKTS256TO511OCTETSr BCM89500_A0_WRITE_S_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_Pkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_PKTS512TO1023OCTETSr 0x00007170

#define BCM89500_A0_S_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts512to1023Octets.
 *
 */
typedef union BCM89500_A0_S_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts512to1023octets[1];
	uint32_t _s_pkts512to1023octets;
} BCM89500_A0_S_PKTS512TO1023OCTETSr_t;

#define BCM89500_A0_S_PKTS512TO1023OCTETSr_CLR(r) (r).s_pkts512to1023octets[0] = 0
#define BCM89500_A0_S_PKTS512TO1023OCTETSr_SET(r,d) (r).s_pkts512to1023octets[0] = d
#define BCM89500_A0_S_PKTS512TO1023OCTETSr_GET(r) (r).s_pkts512to1023octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_PKTS512TO1023OCTETSr_COUNTf_GET(r) ((r).s_pkts512to1023octets[0])
#define BCM89500_A0_S_PKTS512TO1023OCTETSr_COUNTf_SET(r,f) (r).s_pkts512to1023octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts512to1023Octets.
 *
 */
#define BCM89500_A0_READ_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_PKTS512TO1023OCTETSr,(r._s_pkts512to1023octets),4)
#define BCM89500_A0_WRITE_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_PKTS512TO1023OCTETSr,&(r._s_pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS512TO1023OCTETSr BCM89500_A0_S_PKTS512TO1023OCTETSr
#define S_PKTS512TO1023OCTETSr_SIZE BCM89500_A0_S_PKTS512TO1023OCTETSr_SIZE
typedef BCM89500_A0_S_PKTS512TO1023OCTETSr_t S_PKTS512TO1023OCTETSr_t;
#define S_PKTS512TO1023OCTETSr_CLR BCM89500_A0_S_PKTS512TO1023OCTETSr_CLR
#define S_PKTS512TO1023OCTETSr_SET BCM89500_A0_S_PKTS512TO1023OCTETSr_SET
#define S_PKTS512TO1023OCTETSr_GET BCM89500_A0_S_PKTS512TO1023OCTETSr_GET
#define S_PKTS512TO1023OCTETSr_COUNTf_GET BCM89500_A0_S_PKTS512TO1023OCTETSr_COUNTf_GET
#define S_PKTS512TO1023OCTETSr_COUNTf_SET BCM89500_A0_S_PKTS512TO1023OCTETSr_COUNTf_SET
#define READ_S_PKTS512TO1023OCTETSr BCM89500_A0_READ_S_PKTS512TO1023OCTETSr
#define WRITE_S_PKTS512TO1023OCTETSr BCM89500_A0_WRITE_S_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_Pkts64Octets
 * BLOCKS:   SYS
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_PKTS64OCTETSr 0x00007160

#define BCM89500_A0_S_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts64Octets.
 *
 */
typedef union BCM89500_A0_S_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts64octets[1];
	uint32_t _s_pkts64octets;
} BCM89500_A0_S_PKTS64OCTETSr_t;

#define BCM89500_A0_S_PKTS64OCTETSr_CLR(r) (r).s_pkts64octets[0] = 0
#define BCM89500_A0_S_PKTS64OCTETSr_SET(r,d) (r).s_pkts64octets[0] = d
#define BCM89500_A0_S_PKTS64OCTETSr_GET(r) (r).s_pkts64octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_PKTS64OCTETSr_COUNTf_GET(r) ((r).s_pkts64octets[0])
#define BCM89500_A0_S_PKTS64OCTETSr_COUNTf_SET(r,f) (r).s_pkts64octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts64Octets.
 *
 */
#define BCM89500_A0_READ_S_PKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_PKTS64OCTETSr,(r._s_pkts64octets),4)
#define BCM89500_A0_WRITE_S_PKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_PKTS64OCTETSr,&(r._s_pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS64OCTETSr BCM89500_A0_S_PKTS64OCTETSr
#define S_PKTS64OCTETSr_SIZE BCM89500_A0_S_PKTS64OCTETSr_SIZE
typedef BCM89500_A0_S_PKTS64OCTETSr_t S_PKTS64OCTETSr_t;
#define S_PKTS64OCTETSr_CLR BCM89500_A0_S_PKTS64OCTETSr_CLR
#define S_PKTS64OCTETSr_SET BCM89500_A0_S_PKTS64OCTETSr_SET
#define S_PKTS64OCTETSr_GET BCM89500_A0_S_PKTS64OCTETSr_GET
#define S_PKTS64OCTETSr_COUNTf_GET BCM89500_A0_S_PKTS64OCTETSr_COUNTf_GET
#define S_PKTS64OCTETSr_COUNTf_SET BCM89500_A0_S_PKTS64OCTETSr_COUNTf_SET
#define READ_S_PKTS64OCTETSr BCM89500_A0_READ_S_PKTS64OCTETSr
#define WRITE_S_PKTS64OCTETSr BCM89500_A0_WRITE_S_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_Pkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_PKTS65TO127OCTETSr 0x00007164

#define BCM89500_A0_S_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts65to127Octets.
 *
 */
typedef union BCM89500_A0_S_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts65to127octets[1];
	uint32_t _s_pkts65to127octets;
} BCM89500_A0_S_PKTS65TO127OCTETSr_t;

#define BCM89500_A0_S_PKTS65TO127OCTETSr_CLR(r) (r).s_pkts65to127octets[0] = 0
#define BCM89500_A0_S_PKTS65TO127OCTETSr_SET(r,d) (r).s_pkts65to127octets[0] = d
#define BCM89500_A0_S_PKTS65TO127OCTETSr_GET(r) (r).s_pkts65to127octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_PKTS65TO127OCTETSr_COUNTf_GET(r) ((r).s_pkts65to127octets[0])
#define BCM89500_A0_S_PKTS65TO127OCTETSr_COUNTf_SET(r,f) (r).s_pkts65to127octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts65to127Octets.
 *
 */
#define BCM89500_A0_READ_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_PKTS65TO127OCTETSr,(r._s_pkts65to127octets),4)
#define BCM89500_A0_WRITE_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_PKTS65TO127OCTETSr,&(r._s_pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS65TO127OCTETSr BCM89500_A0_S_PKTS65TO127OCTETSr
#define S_PKTS65TO127OCTETSr_SIZE BCM89500_A0_S_PKTS65TO127OCTETSr_SIZE
typedef BCM89500_A0_S_PKTS65TO127OCTETSr_t S_PKTS65TO127OCTETSr_t;
#define S_PKTS65TO127OCTETSr_CLR BCM89500_A0_S_PKTS65TO127OCTETSr_CLR
#define S_PKTS65TO127OCTETSr_SET BCM89500_A0_S_PKTS65TO127OCTETSr_SET
#define S_PKTS65TO127OCTETSr_GET BCM89500_A0_S_PKTS65TO127OCTETSr_GET
#define S_PKTS65TO127OCTETSr_COUNTf_GET BCM89500_A0_S_PKTS65TO127OCTETSr_COUNTf_GET
#define S_PKTS65TO127OCTETSr_COUNTf_SET BCM89500_A0_S_PKTS65TO127OCTETSr_COUNTf_SET
#define READ_S_PKTS65TO127OCTETSr BCM89500_A0_READ_S_PKTS65TO127OCTETSr
#define WRITE_S_PKTS65TO127OCTETSr BCM89500_A0_WRITE_S_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RXDISCARD
 * BLOCKS:   SYS
 * DESC:     Rx Discard Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXDISCARDr 0x000071c0

#define BCM89500_A0_S_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program S_RXDISCARD.
 *
 */
typedef union BCM89500_A0_S_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t s_rxdiscard[1];
	uint32_t _s_rxdiscard;
} BCM89500_A0_S_RXDISCARDr_t;

#define BCM89500_A0_S_RXDISCARDr_CLR(r) (r).s_rxdiscard[0] = 0
#define BCM89500_A0_S_RXDISCARDr_SET(r,d) (r).s_rxdiscard[0] = d
#define BCM89500_A0_S_RXDISCARDr_GET(r) (r).s_rxdiscard[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXDISCARDr_COUNTf_GET(r) ((r).s_rxdiscard[0])
#define BCM89500_A0_S_RXDISCARDr_COUNTf_SET(r,f) (r).s_rxdiscard[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXDISCARD.
 *
 */
#define BCM89500_A0_READ_S_RXDISCARDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXDISCARDr,(r._s_rxdiscard),4)
#define BCM89500_A0_WRITE_S_RXDISCARDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXDISCARDr,&(r._s_rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDISCARDr BCM89500_A0_S_RXDISCARDr
#define S_RXDISCARDr_SIZE BCM89500_A0_S_RXDISCARDr_SIZE
typedef BCM89500_A0_S_RXDISCARDr_t S_RXDISCARDr_t;
#define S_RXDISCARDr_CLR BCM89500_A0_S_RXDISCARDr_CLR
#define S_RXDISCARDr_SET BCM89500_A0_S_RXDISCARDr_SET
#define S_RXDISCARDr_GET BCM89500_A0_S_RXDISCARDr_GET
#define S_RXDISCARDr_COUNTf_GET BCM89500_A0_S_RXDISCARDr_COUNTf_GET
#define S_RXDISCARDr_COUNTf_SET BCM89500_A0_S_RXDISCARDr_COUNTf_SET
#define READ_S_RXDISCARDr BCM89500_A0_READ_S_RXDISCARDr
#define WRITE_S_RXDISCARDr BCM89500_A0_WRITE_S_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RXSymblErr
 * BLOCKS:   SYS
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXSYMBLERRr 0x000071ac

#define BCM89500_A0_S_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RXSymblErr.
 *
 */
typedef union BCM89500_A0_S_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymblerr[1];
	uint32_t _s_rxsymblerr;
} BCM89500_A0_S_RXSYMBLERRr_t;

#define BCM89500_A0_S_RXSYMBLERRr_CLR(r) (r).s_rxsymblerr[0] = 0
#define BCM89500_A0_S_RXSYMBLERRr_SET(r,d) (r).s_rxsymblerr[0] = d
#define BCM89500_A0_S_RXSYMBLERRr_GET(r) (r).s_rxsymblerr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXSYMBLERRr_COUNTf_GET(r) ((r).s_rxsymblerr[0])
#define BCM89500_A0_S_RXSYMBLERRr_COUNTf_SET(r,f) (r).s_rxsymblerr[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXSymblErr.
 *
 */
#define BCM89500_A0_READ_S_RXSYMBLERRr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXSYMBLERRr,(r._s_rxsymblerr),4)
#define BCM89500_A0_WRITE_S_RXSYMBLERRr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXSYMBLERRr,&(r._s_rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBLERRr BCM89500_A0_S_RXSYMBLERRr
#define S_RXSYMBLERRr_SIZE BCM89500_A0_S_RXSYMBLERRr_SIZE
typedef BCM89500_A0_S_RXSYMBLERRr_t S_RXSYMBLERRr_t;
#define S_RXSYMBLERRr_CLR BCM89500_A0_S_RXSYMBLERRr_CLR
#define S_RXSYMBLERRr_SET BCM89500_A0_S_RXSYMBLERRr_SET
#define S_RXSYMBLERRr_GET BCM89500_A0_S_RXSYMBLERRr_GET
#define S_RXSYMBLERRr_COUNTf_GET BCM89500_A0_S_RXSYMBLERRr_COUNTf_GET
#define S_RXSYMBLERRr_COUNTf_SET BCM89500_A0_S_RXSYMBLERRr_COUNTf_SET
#define READ_S_RXSYMBLERRr BCM89500_A0_READ_S_RXSYMBLERRr
#define WRITE_S_RXSYMBLERRr BCM89500_A0_WRITE_S_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXALIGNMENTERRORSr 0x00007180

#define BCM89500_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 *
 */
typedef union BCM89500_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM89500_A0_S_RXALIGNMENTERRORSr_t;

#define BCM89500_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM89500_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM89500_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXALIGNMENTERRORSr_COUNTf_GET(r) ((r).s_rxalignmenterrors[0])
#define BCM89500_A0_S_RXALIGNMENTERRORSr_COUNTf_SET(r,f) (r).s_rxalignmenterrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxAlignmentErrors.
 *
 */
#define BCM89500_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM89500_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM89500_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM89500_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM89500_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM89500_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM89500_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM89500_A0_S_RXALIGNMENTERRORSr_GET
#define S_RXALIGNMENTERRORSr_COUNTf_GET BCM89500_A0_S_RXALIGNMENTERRORSr_COUNTf_GET
#define S_RXALIGNMENTERRORSr_COUNTf_SET BCM89500_A0_S_RXALIGNMENTERRORSr_COUNTf_SET
#define READ_S_RXALIGNMENTERRORSr BCM89500_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM89500_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXBROADCASTPKTSr 0x0000719c

#define BCM89500_A0_S_RXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkts.
 *
 */
typedef union BCM89500_A0_S_RXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkts[1];
	uint32_t _s_rxbroadcastpkts;
} BCM89500_A0_S_RXBROADCASTPKTSr_t;

#define BCM89500_A0_S_RXBROADCASTPKTSr_CLR(r) (r).s_rxbroadcastpkts[0] = 0
#define BCM89500_A0_S_RXBROADCASTPKTSr_SET(r,d) (r).s_rxbroadcastpkts[0] = d
#define BCM89500_A0_S_RXBROADCASTPKTSr_GET(r) (r).s_rxbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXBROADCASTPKTSr_COUNTf_GET(r) ((r).s_rxbroadcastpkts[0])
#define BCM89500_A0_S_RXBROADCASTPKTSr_COUNTf_SET(r,f) (r).s_rxbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxBroadcastPkts.
 *
 */
#define BCM89500_A0_READ_S_RXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXBROADCASTPKTSr,(r._s_rxbroadcastpkts),4)
#define BCM89500_A0_WRITE_S_RXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXBROADCASTPKTSr,&(r._s_rxbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTSr BCM89500_A0_S_RXBROADCASTPKTSr
#define S_RXBROADCASTPKTSr_SIZE BCM89500_A0_S_RXBROADCASTPKTSr_SIZE
typedef BCM89500_A0_S_RXBROADCASTPKTSr_t S_RXBROADCASTPKTSr_t;
#define S_RXBROADCASTPKTSr_CLR BCM89500_A0_S_RXBROADCASTPKTSr_CLR
#define S_RXBROADCASTPKTSr_SET BCM89500_A0_S_RXBROADCASTPKTSr_SET
#define S_RXBROADCASTPKTSr_GET BCM89500_A0_S_RXBROADCASTPKTSr_GET
#define S_RXBROADCASTPKTSr_COUNTf_GET BCM89500_A0_S_RXBROADCASTPKTSr_COUNTf_GET
#define S_RXBROADCASTPKTSr_COUNTf_SET BCM89500_A0_S_RXBROADCASTPKTSr_COUNTf_SET
#define READ_S_RXBROADCASTPKTSr BCM89500_A0_READ_S_RXBROADCASTPKTSr
#define WRITE_S_RXBROADCASTPKTSr BCM89500_A0_WRITE_S_RXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxDropPkts
 * BLOCKS:   SYS
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXDROPPKTSr 0x00007190

#define BCM89500_A0_S_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxDropPkts.
 *
 */
typedef union BCM89500_A0_S_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxdroppkts[1];
	uint32_t _s_rxdroppkts;
} BCM89500_A0_S_RXDROPPKTSr_t;

#define BCM89500_A0_S_RXDROPPKTSr_CLR(r) (r).s_rxdroppkts[0] = 0
#define BCM89500_A0_S_RXDROPPKTSr_SET(r,d) (r).s_rxdroppkts[0] = d
#define BCM89500_A0_S_RXDROPPKTSr_GET(r) (r).s_rxdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXDROPPKTSr_COUNTf_GET(r) ((r).s_rxdroppkts[0])
#define BCM89500_A0_S_RXDROPPKTSr_COUNTf_SET(r,f) (r).s_rxdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxDropPkts.
 *
 */
#define BCM89500_A0_READ_S_RXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXDROPPKTSr,(r._s_rxdroppkts),4)
#define BCM89500_A0_WRITE_S_RXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXDROPPKTSr,&(r._s_rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDROPPKTSr BCM89500_A0_S_RXDROPPKTSr
#define S_RXDROPPKTSr_SIZE BCM89500_A0_S_RXDROPPKTSr_SIZE
typedef BCM89500_A0_S_RXDROPPKTSr_t S_RXDROPPKTSr_t;
#define S_RXDROPPKTSr_CLR BCM89500_A0_S_RXDROPPKTSr_CLR
#define S_RXDROPPKTSr_SET BCM89500_A0_S_RXDROPPKTSr_SET
#define S_RXDROPPKTSr_GET BCM89500_A0_S_RXDROPPKTSr_GET
#define S_RXDROPPKTSr_COUNTf_GET BCM89500_A0_S_RXDROPPKTSr_COUNTf_GET
#define S_RXDROPPKTSr_COUNTf_SET BCM89500_A0_S_RXDROPPKTSr_COUNTf_SET
#define READ_S_RXDROPPKTSr BCM89500_A0_READ_S_RXDROPPKTSr
#define WRITE_S_RXDROPPKTSr BCM89500_A0_WRITE_S_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXFCSERRORSr 0x00007184

#define BCM89500_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 *
 */
typedef union BCM89500_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM89500_A0_S_RXFCSERRORSr_t;

#define BCM89500_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM89500_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM89500_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXFCSERRORSr_COUNTf_GET(r) ((r).s_rxfcserrors[0])
#define BCM89500_A0_S_RXFCSERRORSr_COUNTf_SET(r,f) (r).s_rxfcserrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFCSErrors.
 *
 */
#define BCM89500_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM89500_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM89500_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM89500_A0_S_RXFCSERRORSr_SIZE
typedef BCM89500_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM89500_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM89500_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM89500_A0_S_RXFCSERRORSr_GET
#define S_RXFCSERRORSr_COUNTf_GET BCM89500_A0_S_RXFCSERRORSr_COUNTf_GET
#define S_RXFCSERRORSr_COUNTf_SET BCM89500_A0_S_RXFCSERRORSr_COUNTf_SET
#define READ_S_RXFCSERRORSr BCM89500_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM89500_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXFRAGMENTSr 0x000071a4

#define BCM89500_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 *
 */
typedef union BCM89500_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM89500_A0_S_RXFRAGMENTSr_t;

#define BCM89500_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM89500_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM89500_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXFRAGMENTSr_COUNTf_GET(r) ((r).s_rxfragments[0])
#define BCM89500_A0_S_RXFRAGMENTSr_COUNTf_SET(r,f) (r).s_rxfragments[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFragments.
 *
 */
#define BCM89500_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM89500_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM89500_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM89500_A0_S_RXFRAGMENTSr_SIZE
typedef BCM89500_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM89500_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM89500_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM89500_A0_S_RXFRAGMENTSr_GET
#define S_RXFRAGMENTSr_COUNTf_GET BCM89500_A0_S_RXFRAGMENTSr_COUNTf_GET
#define S_RXFRAGMENTSr_COUNTf_SET BCM89500_A0_S_RXFRAGMENTSr_COUNTf_SET
#define READ_S_RXFRAGMENTSr BCM89500_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM89500_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXGOODOCTETSr 0x00007188

#define BCM89500_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 *
 */
typedef union BCM89500_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM89500_A0_S_RXGOODOCTETSr_t;

#define BCM89500_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM89500_A0_S_RXGOODOCTETSr_t))
#define BCM89500_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM89500_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXGOODOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_rxgoodoctets,0,63,a)
#define BCM89500_A0_S_RXGOODOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_rxgoodoctets,0,63,a)

/*
 * These macros can be used to access S_RxGoodOctets.
 *
 */
#define BCM89500_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM89500_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM89500_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM89500_A0_S_RXGOODOCTETSr_SIZE
typedef BCM89500_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM89500_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM89500_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM89500_A0_S_RXGOODOCTETSr_GET
#define S_RXGOODOCTETSr_COUNTf_GET BCM89500_A0_S_RXGOODOCTETSr_COUNTf_GET
#define S_RXGOODOCTETSr_COUNTf_SET BCM89500_A0_S_RXGOODOCTETSr_COUNTf_SET
#define READ_S_RXGOODOCTETSr BCM89500_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM89500_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxJabbers
 * BLOCKS:   SYS
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXJABBERSr 0x0000717c

#define BCM89500_A0_S_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabbers.
 *
 */
typedef union BCM89500_A0_S_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t s_rxjabbers[1];
	uint32_t _s_rxjabbers;
} BCM89500_A0_S_RXJABBERSr_t;

#define BCM89500_A0_S_RXJABBERSr_CLR(r) (r).s_rxjabbers[0] = 0
#define BCM89500_A0_S_RXJABBERSr_SET(r,d) (r).s_rxjabbers[0] = d
#define BCM89500_A0_S_RXJABBERSr_GET(r) (r).s_rxjabbers[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXJABBERSr_COUNTf_GET(r) ((r).s_rxjabbers[0])
#define BCM89500_A0_S_RXJABBERSr_COUNTf_SET(r,f) (r).s_rxjabbers[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxJabbers.
 *
 */
#define BCM89500_A0_READ_S_RXJABBERSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXJABBERSr,(r._s_rxjabbers),4)
#define BCM89500_A0_WRITE_S_RXJABBERSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXJABBERSr,&(r._s_rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERSr BCM89500_A0_S_RXJABBERSr
#define S_RXJABBERSr_SIZE BCM89500_A0_S_RXJABBERSr_SIZE
typedef BCM89500_A0_S_RXJABBERSr_t S_RXJABBERSr_t;
#define S_RXJABBERSr_CLR BCM89500_A0_S_RXJABBERSr_CLR
#define S_RXJABBERSr_SET BCM89500_A0_S_RXJABBERSr_SET
#define S_RXJABBERSr_GET BCM89500_A0_S_RXJABBERSr_GET
#define S_RXJABBERSr_COUNTf_GET BCM89500_A0_S_RXJABBERSr_COUNTf_GET
#define S_RXJABBERSr_COUNTf_SET BCM89500_A0_S_RXJABBERSr_COUNTf_SET
#define READ_S_RXJABBERSr BCM89500_A0_READ_S_RXJABBERSr
#define WRITE_S_RXJABBERSr BCM89500_A0_WRITE_S_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXMULTICASTPKTSr 0x00007198

#define BCM89500_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 *
 */
typedef union BCM89500_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM89500_A0_S_RXMULTICASTPKTSr_t;

#define BCM89500_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM89500_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM89500_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXMULTICASTPKTSr_COUNTf_GET(r) ((r).s_rxmulticastpkts[0])
#define BCM89500_A0_S_RXMULTICASTPKTSr_COUNTf_SET(r,f) (r).s_rxmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxMulticastPkts.
 *
 */
#define BCM89500_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM89500_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM89500_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM89500_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM89500_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM89500_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM89500_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM89500_A0_S_RXMULTICASTPKTSr_GET
#define S_RXMULTICASTPKTSr_COUNTf_GET BCM89500_A0_S_RXMULTICASTPKTSr_COUNTf_GET
#define S_RXMULTICASTPKTSr_COUNTf_SET BCM89500_A0_S_RXMULTICASTPKTSr_COUNTf_SET
#define READ_S_RXMULTICASTPKTSr BCM89500_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM89500_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXOCTETSr 0x00007150

#define BCM89500_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 *
 */
typedef union BCM89500_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM89500_A0_S_RXOCTETSr_t;

#define BCM89500_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM89500_A0_S_RXOCTETSr_t))
#define BCM89500_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM89500_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_rxoctets,0,63,a)
#define BCM89500_A0_S_RXOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_rxoctets,0,63,a)

/*
 * These macros can be used to access S_RxOctets.
 *
 */
#define BCM89500_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM89500_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM89500_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM89500_A0_S_RXOCTETSr_SIZE
typedef BCM89500_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM89500_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM89500_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM89500_A0_S_RXOCTETSr_GET
#define S_RXOCTETSr_COUNTf_GET BCM89500_A0_S_RXOCTETSr_COUNTf_GET
#define S_RXOCTETSr_COUNTf_SET BCM89500_A0_S_RXOCTETSr_COUNTf_SET
#define READ_S_RXOCTETSr BCM89500_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM89500_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXOVERSIZEPKTSr 0x00007178

#define BCM89500_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 *
 */
typedef union BCM89500_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM89500_A0_S_RXOVERSIZEPKTSr_t;

#define BCM89500_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM89500_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM89500_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXOVERSIZEPKTSr_COUNTf_GET(r) ((r).s_rxoversizepkts[0])
#define BCM89500_A0_S_RXOVERSIZEPKTSr_COUNTf_SET(r,f) (r).s_rxoversizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxOversizePkts.
 *
 */
#define BCM89500_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM89500_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM89500_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM89500_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM89500_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM89500_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM89500_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM89500_A0_S_RXOVERSIZEPKTSr_GET
#define S_RXOVERSIZEPKTSr_COUNTf_GET BCM89500_A0_S_RXOVERSIZEPKTSr_COUNTf_GET
#define S_RXOVERSIZEPKTSr_COUNTf_SET BCM89500_A0_S_RXOVERSIZEPKTSr_COUNTf_SET
#define READ_S_RXOVERSIZEPKTSr BCM89500_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM89500_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXPAUSEPKTSr 0x0000715c

#define BCM89500_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 *
 */
typedef union BCM89500_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM89500_A0_S_RXPAUSEPKTSr_t;

#define BCM89500_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM89500_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM89500_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXPAUSEPKTSr_COUNTf_GET(r) ((r).s_rxpausepkts[0])
#define BCM89500_A0_S_RXPAUSEPKTSr_COUNTf_SET(r,f) (r).s_rxpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxPausePkts.
 *
 */
#define BCM89500_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM89500_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM89500_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM89500_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM89500_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM89500_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM89500_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM89500_A0_S_RXPAUSEPKTSr_GET
#define S_RXPAUSEPKTSr_COUNTf_GET BCM89500_A0_S_RXPAUSEPKTSr_COUNTf_GET
#define S_RXPAUSEPKTSr_COUNTf_SET BCM89500_A0_S_RXPAUSEPKTSr_COUNTf_SET
#define READ_S_RXPAUSEPKTSr BCM89500_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM89500_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxSAChanges
 * BLOCKS:   SYS
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXSACHANGESr 0x000071a0

#define BCM89500_A0_S_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSAChanges.
 *
 */
typedef union BCM89500_A0_S_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t s_rxsachanges[1];
	uint32_t _s_rxsachanges;
} BCM89500_A0_S_RXSACHANGESr_t;

#define BCM89500_A0_S_RXSACHANGESr_CLR(r) (r).s_rxsachanges[0] = 0
#define BCM89500_A0_S_RXSACHANGESr_SET(r,d) (r).s_rxsachanges[0] = d
#define BCM89500_A0_S_RXSACHANGESr_GET(r) (r).s_rxsachanges[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXSACHANGESr_COUNTf_GET(r) ((r).s_rxsachanges[0])
#define BCM89500_A0_S_RXSACHANGESr_COUNTf_SET(r,f) (r).s_rxsachanges[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxSAChanges.
 *
 */
#define BCM89500_A0_READ_S_RXSACHANGESr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXSACHANGESr,(r._s_rxsachanges),4)
#define BCM89500_A0_WRITE_S_RXSACHANGESr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXSACHANGESr,&(r._s_rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSACHANGESr BCM89500_A0_S_RXSACHANGESr
#define S_RXSACHANGESr_SIZE BCM89500_A0_S_RXSACHANGESr_SIZE
typedef BCM89500_A0_S_RXSACHANGESr_t S_RXSACHANGESr_t;
#define S_RXSACHANGESr_CLR BCM89500_A0_S_RXSACHANGESr_CLR
#define S_RXSACHANGESr_SET BCM89500_A0_S_RXSACHANGESr_SET
#define S_RXSACHANGESr_GET BCM89500_A0_S_RXSACHANGESr_GET
#define S_RXSACHANGESr_COUNTf_GET BCM89500_A0_S_RXSACHANGESr_COUNTf_GET
#define S_RXSACHANGESr_COUNTf_SET BCM89500_A0_S_RXSACHANGESr_COUNTf_SET
#define READ_S_RXSACHANGESr BCM89500_A0_READ_S_RXSACHANGESr
#define WRITE_S_RXSACHANGESr BCM89500_A0_WRITE_S_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXUNDERSIZEPKTSr 0x00007158

#define BCM89500_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 *
 */
typedef union BCM89500_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM89500_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM89500_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM89500_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM89500_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXUNDERSIZEPKTSr_COUNTf_GET(r) ((r).s_rxundersizepkts[0])
#define BCM89500_A0_S_RXUNDERSIZEPKTSr_COUNTf_SET(r,f) (r).s_rxundersizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUndersizePkts.
 *
 */
#define BCM89500_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM89500_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM89500_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM89500_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM89500_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM89500_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM89500_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM89500_A0_S_RXUNDERSIZEPKTSr_GET
#define S_RXUNDERSIZEPKTSr_COUNTf_GET BCM89500_A0_S_RXUNDERSIZEPKTSr_COUNTf_GET
#define S_RXUNDERSIZEPKTSr_COUNTf_SET BCM89500_A0_S_RXUNDERSIZEPKTSr_COUNTf_SET
#define READ_S_RXUNDERSIZEPKTSr BCM89500_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM89500_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_RXUNICASTPKTSr 0x00007194

#define BCM89500_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 *
 */
typedef union BCM89500_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM89500_A0_S_RXUNICASTPKTSr_t;

#define BCM89500_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM89500_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM89500_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_RXUNICASTPKTSr_COUNTf_GET(r) ((r).s_rxunicastpkts[0])
#define BCM89500_A0_S_RXUNICASTPKTSr_COUNTf_SET(r,f) (r).s_rxunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUnicastPkts.
 *
 */
#define BCM89500_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM89500_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM89500_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM89500_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM89500_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM89500_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM89500_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM89500_A0_S_RXUNICASTPKTSr_GET
#define S_RXUNICASTPKTSr_COUNTf_GET BCM89500_A0_S_RXUNICASTPKTSr_COUNTf_GET
#define S_RXUNICASTPKTSr_COUNTf_SET BCM89500_A0_S_RXUNICASTPKTSr_COUNTf_SET
#define READ_S_RXUNICASTPKTSr BCM89500_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM89500_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXBROADCASTPKTSr 0x00007110

#define BCM89500_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 *
 */
typedef union BCM89500_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM89500_A0_S_TXBROADCASTPKTSr_t;

#define BCM89500_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM89500_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM89500_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXBROADCASTPKTSr_COUNTf_GET(r) ((r).s_txbroadcastpkts[0])
#define BCM89500_A0_S_TXBROADCASTPKTSr_COUNTf_SET(r,f) (r).s_txbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxBroadcastPkts.
 *
 */
#define BCM89500_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM89500_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM89500_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM89500_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM89500_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM89500_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM89500_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM89500_A0_S_TXBROADCASTPKTSr_GET
#define S_TXBROADCASTPKTSr_COUNTf_GET BCM89500_A0_S_TXBROADCASTPKTSr_COUNTf_GET
#define S_TXBROADCASTPKTSr_COUNTf_SET BCM89500_A0_S_TXBROADCASTPKTSr_COUNTf_SET
#define READ_S_TXBROADCASTPKTSr BCM89500_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM89500_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     Tx Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXCOLLISIONSr 0x0000711c

#define BCM89500_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 *
 */
typedef union BCM89500_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM89500_A0_S_TXCOLLISIONSr_t;

#define BCM89500_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM89500_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM89500_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXCOLLISIONSr_COUNTf_GET(r) ((r).s_txcollisions[0])
#define BCM89500_A0_S_TXCOLLISIONSr_COUNTf_SET(r,f) (r).s_txcollisions[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxCollisions.
 *
 */
#define BCM89500_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM89500_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM89500_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM89500_A0_S_TXCOLLISIONSr_SIZE
typedef BCM89500_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM89500_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM89500_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM89500_A0_S_TXCOLLISIONSr_GET
#define S_TXCOLLISIONSr_COUNTf_GET BCM89500_A0_S_TXCOLLISIONSr_COUNTf_GET
#define S_TXCOLLISIONSr_COUNTf_SET BCM89500_A0_S_TXCOLLISIONSr_COUNTf_SET
#define READ_S_TXCOLLISIONSr BCM89500_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM89500_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXDEFERREDTRANSMITr 0x00007128

#define BCM89500_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 *
 */
typedef union BCM89500_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM89500_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM89500_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM89500_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM89500_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXDEFERREDTRANSMITr_COUNTf_GET(r) ((r).s_txdeferredtransmit[0])
#define BCM89500_A0_S_TXDEFERREDTRANSMITr_COUNTf_SET(r,f) (r).s_txdeferredtransmit[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDeferredTransmit.
 *
 */
#define BCM89500_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM89500_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM89500_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM89500_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM89500_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM89500_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM89500_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM89500_A0_S_TXDEFERREDTRANSMITr_GET
#define S_TXDEFERREDTRANSMITr_COUNTf_GET BCM89500_A0_S_TXDEFERREDTRANSMITr_COUNTf_GET
#define S_TXDEFERREDTRANSMITr_COUNTf_SET BCM89500_A0_S_TXDEFERREDTRANSMITr_COUNTf_SET
#define READ_S_TXDEFERREDTRANSMITr BCM89500_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM89500_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxDropPkts
 * BLOCKS:   SYS
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXDROPPKTSr 0x00007108

#define BCM89500_A0_S_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDropPkts.
 *
 */
typedef union BCM89500_A0_S_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_txdroppkts[1];
	uint32_t _s_txdroppkts;
} BCM89500_A0_S_TXDROPPKTSr_t;

#define BCM89500_A0_S_TXDROPPKTSr_CLR(r) (r).s_txdroppkts[0] = 0
#define BCM89500_A0_S_TXDROPPKTSr_SET(r,d) (r).s_txdroppkts[0] = d
#define BCM89500_A0_S_TXDROPPKTSr_GET(r) (r).s_txdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXDROPPKTSr_COUNTf_GET(r) ((r).s_txdroppkts[0])
#define BCM89500_A0_S_TXDROPPKTSr_COUNTf_SET(r,f) (r).s_txdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDropPkts.
 *
 */
#define BCM89500_A0_READ_S_TXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXDROPPKTSr,(r._s_txdroppkts),4)
#define BCM89500_A0_WRITE_S_TXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXDROPPKTSr,&(r._s_txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDROPPKTSr BCM89500_A0_S_TXDROPPKTSr
#define S_TXDROPPKTSr_SIZE BCM89500_A0_S_TXDROPPKTSr_SIZE
typedef BCM89500_A0_S_TXDROPPKTSr_t S_TXDROPPKTSr_t;
#define S_TXDROPPKTSr_CLR BCM89500_A0_S_TXDROPPKTSr_CLR
#define S_TXDROPPKTSr_SET BCM89500_A0_S_TXDROPPKTSr_SET
#define S_TXDROPPKTSr_GET BCM89500_A0_S_TXDROPPKTSr_GET
#define S_TXDROPPKTSr_COUNTf_GET BCM89500_A0_S_TXDROPPKTSr_COUNTf_GET
#define S_TXDROPPKTSr_COUNTf_SET BCM89500_A0_S_TXDROPPKTSr_COUNTf_SET
#define READ_S_TXDROPPKTSr BCM89500_A0_READ_S_TXDROPPKTSr
#define WRITE_S_TXDROPPKTSr BCM89500_A0_WRITE_S_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr 0x00007130

#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 *
 */
typedef union BCM89500_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM89500_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_GET(r) ((r).s_txexcessivecollision[0])
#define BCM89500_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_SET(r,f) (r).s_txexcessivecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxExcessiveCollision.
 *
 */
#define BCM89500_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM89500_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM89500_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM89500_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM89500_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM89500_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM89500_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM89500_A0_S_TXEXCESSIVECOLLISIONr_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTf_GET BCM89500_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTf_SET BCM89500_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_SET
#define READ_S_TXEXCESSIVECOLLISIONr BCM89500_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM89500_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxFrameInDisc
 * BLOCKS:   SYS
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXFRAMEINDISCr 0x00007134

#define BCM89500_A0_S_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_TxFrameInDisc.
 *
 */
typedef union BCM89500_A0_S_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t s_txframeindisc[1];
	uint32_t _s_txframeindisc;
} BCM89500_A0_S_TXFRAMEINDISCr_t;

#define BCM89500_A0_S_TXFRAMEINDISCr_CLR(r) (r).s_txframeindisc[0] = 0
#define BCM89500_A0_S_TXFRAMEINDISCr_SET(r,d) (r).s_txframeindisc[0] = d
#define BCM89500_A0_S_TXFRAMEINDISCr_GET(r) (r).s_txframeindisc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXFRAMEINDISCr_COUNTf_GET(r) ((r).s_txframeindisc[0])
#define BCM89500_A0_S_TXFRAMEINDISCr_COUNTf_SET(r,f) (r).s_txframeindisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxFrameInDisc.
 *
 */
#define BCM89500_A0_READ_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXFRAMEINDISCr,(r._s_txframeindisc),4)
#define BCM89500_A0_WRITE_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXFRAMEINDISCr,&(r._s_txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXFRAMEINDISCr BCM89500_A0_S_TXFRAMEINDISCr
#define S_TXFRAMEINDISCr_SIZE BCM89500_A0_S_TXFRAMEINDISCr_SIZE
typedef BCM89500_A0_S_TXFRAMEINDISCr_t S_TXFRAMEINDISCr_t;
#define S_TXFRAMEINDISCr_CLR BCM89500_A0_S_TXFRAMEINDISCr_CLR
#define S_TXFRAMEINDISCr_SET BCM89500_A0_S_TXFRAMEINDISCr_SET
#define S_TXFRAMEINDISCr_GET BCM89500_A0_S_TXFRAMEINDISCr_GET
#define S_TXFRAMEINDISCr_COUNTf_GET BCM89500_A0_S_TXFRAMEINDISCr_COUNTf_GET
#define S_TXFRAMEINDISCr_COUNTf_SET BCM89500_A0_S_TXFRAMEINDISCr_COUNTf_SET
#define READ_S_TXFRAMEINDISCr BCM89500_A0_READ_S_TXFRAMEINDISCr
#define WRITE_S_TXFRAMEINDISCr BCM89500_A0_WRITE_S_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXLATECOLLISIONr 0x0000712c

#define BCM89500_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 *
 */
typedef union BCM89500_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM89500_A0_S_TXLATECOLLISIONr_t;

#define BCM89500_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM89500_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM89500_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXLATECOLLISIONr_COUNTf_GET(r) ((r).s_txlatecollision[0])
#define BCM89500_A0_S_TXLATECOLLISIONr_COUNTf_SET(r,f) (r).s_txlatecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxLateCollision.
 *
 */
#define BCM89500_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM89500_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM89500_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM89500_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM89500_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM89500_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM89500_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM89500_A0_S_TXLATECOLLISIONr_GET
#define S_TXLATECOLLISIONr_COUNTf_GET BCM89500_A0_S_TXLATECOLLISIONr_COUNTf_GET
#define S_TXLATECOLLISIONr_COUNTf_SET BCM89500_A0_S_TXLATECOLLISIONr_COUNTf_SET
#define READ_S_TXLATECOLLISIONr BCM89500_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM89500_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXMULTICASTPKTSr 0x00007114

#define BCM89500_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 *
 */
typedef union BCM89500_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM89500_A0_S_TXMULTICASTPKTSr_t;

#define BCM89500_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM89500_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM89500_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXMULTICASTPKTSr_COUNTf_GET(r) ((r).s_txmulticastpkts[0])
#define BCM89500_A0_S_TXMULTICASTPKTSr_COUNTf_SET(r,f) (r).s_txmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMulticastPkts.
 *
 */
#define BCM89500_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM89500_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM89500_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM89500_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM89500_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM89500_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM89500_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM89500_A0_S_TXMULTICASTPKTSr_GET
#define S_TXMULTICASTPKTSr_COUNTf_GET BCM89500_A0_S_TXMULTICASTPKTSr_COUNTf_GET
#define S_TXMULTICASTPKTSr_COUNTf_SET BCM89500_A0_S_TXMULTICASTPKTSr_COUNTf_SET
#define READ_S_TXMULTICASTPKTSr BCM89500_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM89500_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxMultipleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXMULTIPLECOLLISIONr 0x00007124

#define BCM89500_A0_S_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollision.
 *
 */
typedef union BCM89500_A0_S_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollision[1];
	uint32_t _s_txmultiplecollision;
} BCM89500_A0_S_TXMULTIPLECOLLISIONr_t;

#define BCM89500_A0_S_TXMULTIPLECOLLISIONr_CLR(r) (r).s_txmultiplecollision[0] = 0
#define BCM89500_A0_S_TXMULTIPLECOLLISIONr_SET(r,d) (r).s_txmultiplecollision[0] = d
#define BCM89500_A0_S_TXMULTIPLECOLLISIONr_GET(r) (r).s_txmultiplecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXMULTIPLECOLLISIONr_COUNTf_GET(r) ((r).s_txmultiplecollision[0])
#define BCM89500_A0_S_TXMULTIPLECOLLISIONr_COUNTf_SET(r,f) (r).s_txmultiplecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMultipleCollision.
 *
 */
#define BCM89500_A0_READ_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXMULTIPLECOLLISIONr,(r._s_txmultiplecollision),4)
#define BCM89500_A0_WRITE_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXMULTIPLECOLLISIONr,&(r._s_txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONr BCM89500_A0_S_TXMULTIPLECOLLISIONr
#define S_TXMULTIPLECOLLISIONr_SIZE BCM89500_A0_S_TXMULTIPLECOLLISIONr_SIZE
typedef BCM89500_A0_S_TXMULTIPLECOLLISIONr_t S_TXMULTIPLECOLLISIONr_t;
#define S_TXMULTIPLECOLLISIONr_CLR BCM89500_A0_S_TXMULTIPLECOLLISIONr_CLR
#define S_TXMULTIPLECOLLISIONr_SET BCM89500_A0_S_TXMULTIPLECOLLISIONr_SET
#define S_TXMULTIPLECOLLISIONr_GET BCM89500_A0_S_TXMULTIPLECOLLISIONr_GET
#define S_TXMULTIPLECOLLISIONr_COUNTf_GET BCM89500_A0_S_TXMULTIPLECOLLISIONr_COUNTf_GET
#define S_TXMULTIPLECOLLISIONr_COUNTf_SET BCM89500_A0_S_TXMULTIPLECOLLISIONr_COUNTf_SET
#define READ_S_TXMULTIPLECOLLISIONr BCM89500_A0_READ_S_TXMULTIPLECOLLISIONr
#define WRITE_S_TXMULTIPLECOLLISIONr BCM89500_A0_WRITE_S_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     Tx Octets
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXOCTETSr 0x00007100

#define BCM89500_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 *
 */
typedef union BCM89500_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM89500_A0_S_TXOCTETSr_t;

#define BCM89500_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM89500_A0_S_TXOCTETSr_t))
#define BCM89500_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM89500_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_txoctets,0,63,a)
#define BCM89500_A0_S_TXOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_txoctets,0,63,a)

/*
 * These macros can be used to access S_TxOctets.
 *
 */
#define BCM89500_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM89500_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM89500_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM89500_A0_S_TXOCTETSr_SIZE
typedef BCM89500_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM89500_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM89500_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM89500_A0_S_TXOCTETSr_GET
#define S_TXOCTETSr_COUNTf_GET BCM89500_A0_S_TXOCTETSr_COUNTf_GET
#define S_TXOCTETSr_COUNTf_SET BCM89500_A0_S_TXOCTETSr_COUNTf_SET
#define READ_S_TXOCTETSr BCM89500_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM89500_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXPAUSEPKTSr 0x00007138

#define BCM89500_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 *
 */
typedef union BCM89500_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM89500_A0_S_TXPAUSEPKTSr_t;

#define BCM89500_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM89500_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM89500_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXPAUSEPKTSr_COUNTf_GET(r) ((r).s_txpausepkts[0])
#define BCM89500_A0_S_TXPAUSEPKTSr_COUNTf_SET(r,f) (r).s_txpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxPausePkts.
 *
 */
#define BCM89500_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM89500_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM89500_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM89500_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM89500_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM89500_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM89500_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM89500_A0_S_TXPAUSEPKTSr_GET
#define S_TXPAUSEPKTSr_COUNTf_GET BCM89500_A0_S_TXPAUSEPKTSr_COUNTf_GET
#define S_TXPAUSEPKTSr_COUNTf_SET BCM89500_A0_S_TXPAUSEPKTSr_COUNTf_SET
#define READ_S_TXPAUSEPKTSr BCM89500_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM89500_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxQPKTQ0
 * BLOCKS:   SYS
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXQPKTQ0r 0x0000710c

#define BCM89500_A0_S_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ0.
 *
 */
typedef union BCM89500_A0_S_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t s_txqpktq0[1];
	uint32_t _s_txqpktq0;
} BCM89500_A0_S_TXQPKTQ0r_t;

#define BCM89500_A0_S_TXQPKTQ0r_CLR(r) (r).s_txqpktq0[0] = 0
#define BCM89500_A0_S_TXQPKTQ0r_SET(r,d) (r).s_txqpktq0[0] = d
#define BCM89500_A0_S_TXQPKTQ0r_GET(r) (r).s_txqpktq0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXQPKTQ0r_COUNTf_GET(r) ((r).s_txqpktq0[0])
#define BCM89500_A0_S_TXQPKTQ0r_COUNTf_SET(r,f) (r).s_txqpktq0[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ0.
 *
 */
#define BCM89500_A0_READ_S_TXQPKTQ0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXQPKTQ0r,(r._s_txqpktq0),4)
#define BCM89500_A0_WRITE_S_TXQPKTQ0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXQPKTQ0r,&(r._s_txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ0r BCM89500_A0_S_TXQPKTQ0r
#define S_TXQPKTQ0r_SIZE BCM89500_A0_S_TXQPKTQ0r_SIZE
typedef BCM89500_A0_S_TXQPKTQ0r_t S_TXQPKTQ0r_t;
#define S_TXQPKTQ0r_CLR BCM89500_A0_S_TXQPKTQ0r_CLR
#define S_TXQPKTQ0r_SET BCM89500_A0_S_TXQPKTQ0r_SET
#define S_TXQPKTQ0r_GET BCM89500_A0_S_TXQPKTQ0r_GET
#define S_TXQPKTQ0r_COUNTf_GET BCM89500_A0_S_TXQPKTQ0r_COUNTf_GET
#define S_TXQPKTQ0r_COUNTf_SET BCM89500_A0_S_TXQPKTQ0r_COUNTf_SET
#define READ_S_TXQPKTQ0r BCM89500_A0_READ_S_TXQPKTQ0r
#define WRITE_S_TXQPKTQ0r BCM89500_A0_WRITE_S_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxQPKTQ1
 * BLOCKS:   SYS
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXQPKTQ1r 0x0000713c

#define BCM89500_A0_S_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ1.
 *
 */
typedef union BCM89500_A0_S_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t s_txqpktq1[1];
	uint32_t _s_txqpktq1;
} BCM89500_A0_S_TXQPKTQ1r_t;

#define BCM89500_A0_S_TXQPKTQ1r_CLR(r) (r).s_txqpktq1[0] = 0
#define BCM89500_A0_S_TXQPKTQ1r_SET(r,d) (r).s_txqpktq1[0] = d
#define BCM89500_A0_S_TXQPKTQ1r_GET(r) (r).s_txqpktq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXQPKTQ1r_COUNTf_GET(r) ((r).s_txqpktq1[0])
#define BCM89500_A0_S_TXQPKTQ1r_COUNTf_SET(r,f) (r).s_txqpktq1[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ1.
 *
 */
#define BCM89500_A0_READ_S_TXQPKTQ1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXQPKTQ1r,(r._s_txqpktq1),4)
#define BCM89500_A0_WRITE_S_TXQPKTQ1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXQPKTQ1r,&(r._s_txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ1r BCM89500_A0_S_TXQPKTQ1r
#define S_TXQPKTQ1r_SIZE BCM89500_A0_S_TXQPKTQ1r_SIZE
typedef BCM89500_A0_S_TXQPKTQ1r_t S_TXQPKTQ1r_t;
#define S_TXQPKTQ1r_CLR BCM89500_A0_S_TXQPKTQ1r_CLR
#define S_TXQPKTQ1r_SET BCM89500_A0_S_TXQPKTQ1r_SET
#define S_TXQPKTQ1r_GET BCM89500_A0_S_TXQPKTQ1r_GET
#define S_TXQPKTQ1r_COUNTf_GET BCM89500_A0_S_TXQPKTQ1r_COUNTf_GET
#define S_TXQPKTQ1r_COUNTf_SET BCM89500_A0_S_TXQPKTQ1r_COUNTf_SET
#define READ_S_TXQPKTQ1r BCM89500_A0_READ_S_TXQPKTQ1r
#define WRITE_S_TXQPKTQ1r BCM89500_A0_WRITE_S_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxQPKTQ2
 * BLOCKS:   SYS
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXQPKTQ2r 0x00007140

#define BCM89500_A0_S_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ2.
 *
 */
typedef union BCM89500_A0_S_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t s_txqpktq2[1];
	uint32_t _s_txqpktq2;
} BCM89500_A0_S_TXQPKTQ2r_t;

#define BCM89500_A0_S_TXQPKTQ2r_CLR(r) (r).s_txqpktq2[0] = 0
#define BCM89500_A0_S_TXQPKTQ2r_SET(r,d) (r).s_txqpktq2[0] = d
#define BCM89500_A0_S_TXQPKTQ2r_GET(r) (r).s_txqpktq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXQPKTQ2r_COUNTf_GET(r) ((r).s_txqpktq2[0])
#define BCM89500_A0_S_TXQPKTQ2r_COUNTf_SET(r,f) (r).s_txqpktq2[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ2.
 *
 */
#define BCM89500_A0_READ_S_TXQPKTQ2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXQPKTQ2r,(r._s_txqpktq2),4)
#define BCM89500_A0_WRITE_S_TXQPKTQ2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXQPKTQ2r,&(r._s_txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ2r BCM89500_A0_S_TXQPKTQ2r
#define S_TXQPKTQ2r_SIZE BCM89500_A0_S_TXQPKTQ2r_SIZE
typedef BCM89500_A0_S_TXQPKTQ2r_t S_TXQPKTQ2r_t;
#define S_TXQPKTQ2r_CLR BCM89500_A0_S_TXQPKTQ2r_CLR
#define S_TXQPKTQ2r_SET BCM89500_A0_S_TXQPKTQ2r_SET
#define S_TXQPKTQ2r_GET BCM89500_A0_S_TXQPKTQ2r_GET
#define S_TXQPKTQ2r_COUNTf_GET BCM89500_A0_S_TXQPKTQ2r_COUNTf_GET
#define S_TXQPKTQ2r_COUNTf_SET BCM89500_A0_S_TXQPKTQ2r_COUNTf_SET
#define READ_S_TXQPKTQ2r BCM89500_A0_READ_S_TXQPKTQ2r
#define WRITE_S_TXQPKTQ2r BCM89500_A0_WRITE_S_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxQPKTQ3
 * BLOCKS:   SYS
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXQPKTQ3r 0x00007144

#define BCM89500_A0_S_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ3.
 *
 */
typedef union BCM89500_A0_S_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t s_txqpktq3[1];
	uint32_t _s_txqpktq3;
} BCM89500_A0_S_TXQPKTQ3r_t;

#define BCM89500_A0_S_TXQPKTQ3r_CLR(r) (r).s_txqpktq3[0] = 0
#define BCM89500_A0_S_TXQPKTQ3r_SET(r,d) (r).s_txqpktq3[0] = d
#define BCM89500_A0_S_TXQPKTQ3r_GET(r) (r).s_txqpktq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXQPKTQ3r_COUNTf_GET(r) ((r).s_txqpktq3[0])
#define BCM89500_A0_S_TXQPKTQ3r_COUNTf_SET(r,f) (r).s_txqpktq3[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ3.
 *
 */
#define BCM89500_A0_READ_S_TXQPKTQ3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXQPKTQ3r,(r._s_txqpktq3),4)
#define BCM89500_A0_WRITE_S_TXQPKTQ3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXQPKTQ3r,&(r._s_txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ3r BCM89500_A0_S_TXQPKTQ3r
#define S_TXQPKTQ3r_SIZE BCM89500_A0_S_TXQPKTQ3r_SIZE
typedef BCM89500_A0_S_TXQPKTQ3r_t S_TXQPKTQ3r_t;
#define S_TXQPKTQ3r_CLR BCM89500_A0_S_TXQPKTQ3r_CLR
#define S_TXQPKTQ3r_SET BCM89500_A0_S_TXQPKTQ3r_SET
#define S_TXQPKTQ3r_GET BCM89500_A0_S_TXQPKTQ3r_GET
#define S_TXQPKTQ3r_COUNTf_GET BCM89500_A0_S_TXQPKTQ3r_COUNTf_GET
#define S_TXQPKTQ3r_COUNTf_SET BCM89500_A0_S_TXQPKTQ3r_COUNTf_SET
#define READ_S_TXQPKTQ3r BCM89500_A0_READ_S_TXQPKTQ3r
#define WRITE_S_TXQPKTQ3r BCM89500_A0_WRITE_S_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxQPKTQ4
 * BLOCKS:   SYS
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXQPKTQ4r 0x00007148

#define BCM89500_A0_S_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ4.
 *
 */
typedef union BCM89500_A0_S_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t s_txqpktq4[1];
	uint32_t _s_txqpktq4;
} BCM89500_A0_S_TXQPKTQ4r_t;

#define BCM89500_A0_S_TXQPKTQ4r_CLR(r) (r).s_txqpktq4[0] = 0
#define BCM89500_A0_S_TXQPKTQ4r_SET(r,d) (r).s_txqpktq4[0] = d
#define BCM89500_A0_S_TXQPKTQ4r_GET(r) (r).s_txqpktq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXQPKTQ4r_COUNTf_GET(r) ((r).s_txqpktq4[0])
#define BCM89500_A0_S_TXQPKTQ4r_COUNTf_SET(r,f) (r).s_txqpktq4[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ4.
 *
 */
#define BCM89500_A0_READ_S_TXQPKTQ4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXQPKTQ4r,(r._s_txqpktq4),4)
#define BCM89500_A0_WRITE_S_TXQPKTQ4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXQPKTQ4r,&(r._s_txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ4r BCM89500_A0_S_TXQPKTQ4r
#define S_TXQPKTQ4r_SIZE BCM89500_A0_S_TXQPKTQ4r_SIZE
typedef BCM89500_A0_S_TXQPKTQ4r_t S_TXQPKTQ4r_t;
#define S_TXQPKTQ4r_CLR BCM89500_A0_S_TXQPKTQ4r_CLR
#define S_TXQPKTQ4r_SET BCM89500_A0_S_TXQPKTQ4r_SET
#define S_TXQPKTQ4r_GET BCM89500_A0_S_TXQPKTQ4r_GET
#define S_TXQPKTQ4r_COUNTf_GET BCM89500_A0_S_TXQPKTQ4r_COUNTf_GET
#define S_TXQPKTQ4r_COUNTf_SET BCM89500_A0_S_TXQPKTQ4r_COUNTf_SET
#define READ_S_TXQPKTQ4r BCM89500_A0_READ_S_TXQPKTQ4r
#define WRITE_S_TXQPKTQ4r BCM89500_A0_WRITE_S_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxQPKTQ5
 * BLOCKS:   SYS
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXQPKTQ5r 0x0000714c

#define BCM89500_A0_S_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ5.
 *
 */
typedef union BCM89500_A0_S_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t s_txqpktq5[1];
	uint32_t _s_txqpktq5;
} BCM89500_A0_S_TXQPKTQ5r_t;

#define BCM89500_A0_S_TXQPKTQ5r_CLR(r) (r).s_txqpktq5[0] = 0
#define BCM89500_A0_S_TXQPKTQ5r_SET(r,d) (r).s_txqpktq5[0] = d
#define BCM89500_A0_S_TXQPKTQ5r_GET(r) (r).s_txqpktq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXQPKTQ5r_COUNTf_GET(r) ((r).s_txqpktq5[0])
#define BCM89500_A0_S_TXQPKTQ5r_COUNTf_SET(r,f) (r).s_txqpktq5[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ5.
 *
 */
#define BCM89500_A0_READ_S_TXQPKTQ5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXQPKTQ5r,(r._s_txqpktq5),4)
#define BCM89500_A0_WRITE_S_TXQPKTQ5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXQPKTQ5r,&(r._s_txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ5r BCM89500_A0_S_TXQPKTQ5r
#define S_TXQPKTQ5r_SIZE BCM89500_A0_S_TXQPKTQ5r_SIZE
typedef BCM89500_A0_S_TXQPKTQ5r_t S_TXQPKTQ5r_t;
#define S_TXQPKTQ5r_CLR BCM89500_A0_S_TXQPKTQ5r_CLR
#define S_TXQPKTQ5r_SET BCM89500_A0_S_TXQPKTQ5r_SET
#define S_TXQPKTQ5r_GET BCM89500_A0_S_TXQPKTQ5r_GET
#define S_TXQPKTQ5r_COUNTf_GET BCM89500_A0_S_TXQPKTQ5r_COUNTf_GET
#define S_TXQPKTQ5r_COUNTf_SET BCM89500_A0_S_TXQPKTQ5r_COUNTf_SET
#define READ_S_TXQPKTQ5r BCM89500_A0_READ_S_TXQPKTQ5r
#define WRITE_S_TXQPKTQ5r BCM89500_A0_WRITE_S_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxSingleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXSINGLECOLLISIONr 0x00007120

#define BCM89500_A0_S_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollision.
 *
 */
typedef union BCM89500_A0_S_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollision[1];
	uint32_t _s_txsinglecollision;
} BCM89500_A0_S_TXSINGLECOLLISIONr_t;

#define BCM89500_A0_S_TXSINGLECOLLISIONr_CLR(r) (r).s_txsinglecollision[0] = 0
#define BCM89500_A0_S_TXSINGLECOLLISIONr_SET(r,d) (r).s_txsinglecollision[0] = d
#define BCM89500_A0_S_TXSINGLECOLLISIONr_GET(r) (r).s_txsinglecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXSINGLECOLLISIONr_COUNTf_GET(r) ((r).s_txsinglecollision[0])
#define BCM89500_A0_S_TXSINGLECOLLISIONr_COUNTf_SET(r,f) (r).s_txsinglecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxSingleCollision.
 *
 */
#define BCM89500_A0_READ_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXSINGLECOLLISIONr,(r._s_txsinglecollision),4)
#define BCM89500_A0_WRITE_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXSINGLECOLLISIONr,&(r._s_txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONr BCM89500_A0_S_TXSINGLECOLLISIONr
#define S_TXSINGLECOLLISIONr_SIZE BCM89500_A0_S_TXSINGLECOLLISIONr_SIZE
typedef BCM89500_A0_S_TXSINGLECOLLISIONr_t S_TXSINGLECOLLISIONr_t;
#define S_TXSINGLECOLLISIONr_CLR BCM89500_A0_S_TXSINGLECOLLISIONr_CLR
#define S_TXSINGLECOLLISIONr_SET BCM89500_A0_S_TXSINGLECOLLISIONr_SET
#define S_TXSINGLECOLLISIONr_GET BCM89500_A0_S_TXSINGLECOLLISIONr_GET
#define S_TXSINGLECOLLISIONr_COUNTf_GET BCM89500_A0_S_TXSINGLECOLLISIONr_COUNTf_GET
#define S_TXSINGLECOLLISIONr_COUNTf_SET BCM89500_A0_S_TXSINGLECOLLISIONr_COUNTf_SET
#define READ_S_TXSINGLECOLLISIONr BCM89500_A0_READ_S_TXSINGLECOLLISIONr
#define WRITE_S_TXSINGLECOLLISIONr BCM89500_A0_WRITE_S_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM89500_A0_S_TXUNICASTPKTSr 0x00007118

#define BCM89500_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 *
 */
typedef union BCM89500_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM89500_A0_S_TXUNICASTPKTSr_t;

#define BCM89500_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM89500_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM89500_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_S_TXUNICASTPKTSr_COUNTf_GET(r) ((r).s_txunicastpkts[0])
#define BCM89500_A0_S_TXUNICASTPKTSr_COUNTf_SET(r,f) (r).s_txunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxUnicastPkts.
 *
 */
#define BCM89500_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM89500_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM89500_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM89500_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM89500_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM89500_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM89500_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM89500_A0_S_TXUNICASTPKTSr_GET
#define S_TXUNICASTPKTSr_COUNTf_GET BCM89500_A0_S_TXUNICASTPKTSr_COUNTf_GET
#define S_TXUNICASTPKTSr_COUNTf_SET BCM89500_A0_S_TXUNICASTPKTSr_COUNTf_SET
#define READ_S_TXUNICASTPKTSr BCM89500_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM89500_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_S_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TCAM_BIST_CONTROL
 * BLOCKS:   SYS
 * DESC:     TCAM BIST Control Registers (Not2Release)
 * SIZE:     32
 * FIELDS:
 *     TCAM_BIST_EN     TCAM Bist EnableSoftware write this bit to enable TCAM BIST. When TCAM BIST is done, The TCAM bist done will be assertted. The software need to polling the bist done to know the end of Bist process. When bist is done, software read the TCAM bist status and clear the TCAM bist enable bit.
 *     TCAM_SEL         TCAM Select0: TCAM 01: TCAM 1
 *     RESERVED_0       Reserved
 *     TCAM_BIST_STATUS_SEL TCAM Bist Status Select
 *     TCAM_BIST_SKIP_ERR_CNT TCAM Bist Skip Error Count
 *     TCAM_TEST_COMPARE TCAM Test CompareWhen this bit is '1', the TCAM_DATA7~TCAM_DATA0 will be input to TCAM for comparision.When this bit is write as '1', the harware activates the test compare, the result of the test compare will be stored in TCAM Test Compare Status Register. Software read the Test Compare Status Register and then clear this bit.
 *     RESERVED_1       Reserved
 *     TCAM_BIST_DONE   TCAM BIST DoneWhen TCAM Bist is done, harware will set this bit. This bit will automatically cleared after setting tcam_bist_en to '0'.
 *
 ******************************************************************************/
#define BCM89500_A0_TCAM_BIST_CONTROLr 0x0000a0a0

#define BCM89500_A0_TCAM_BIST_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TCAM_BIST_CONTROL.
 *
 */
typedef union BCM89500_A0_TCAM_BIST_CONTROLr_s {
	uint32_t v[1];
	uint32_t tcam_bist_control[1];
	uint32_t _tcam_bist_control;
} BCM89500_A0_TCAM_BIST_CONTROLr_t;

#define BCM89500_A0_TCAM_BIST_CONTROLr_CLR(r) (r).tcam_bist_control[0] = 0
#define BCM89500_A0_TCAM_BIST_CONTROLr_SET(r,d) (r).tcam_bist_control[0] = d
#define BCM89500_A0_TCAM_BIST_CONTROLr_GET(r) (r).tcam_bist_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_GET(r) (((r).tcam_bist_control[0]) & 0x1)
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_SELf_GET(r) ((((r).tcam_bist_control[0]) >> 1) & 0x1)
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_SELf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_0f_GET(r) ((((r).tcam_bist_control[0]) >> 2) & 0x3)
#define BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_0f_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_GET(r) ((((r).tcam_bist_control[0]) >> 4) & 0xf)
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_GET(r) ((((r).tcam_bist_control[0]) >> 8) & 0xff)
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_GET(r) ((((r).tcam_bist_control[0]) >> 16) & 0x1)
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_1f_GET(r) ((((r).tcam_bist_control[0]) >> 17) & 0x3fff)
#define BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_1f_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_GET(r) ((((r).tcam_bist_control[0]) >> 31) & 0x1)
#define BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCAM_BIST_CONTROL.
 *
 */
#define BCM89500_A0_READ_TCAM_BIST_CONTROLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TCAM_BIST_CONTROLr,(r._tcam_bist_control),4)
#define BCM89500_A0_WRITE_TCAM_BIST_CONTROLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TCAM_BIST_CONTROLr,&(r._tcam_bist_control),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_BIST_CONTROLr BCM89500_A0_TCAM_BIST_CONTROLr
#define TCAM_BIST_CONTROLr_SIZE BCM89500_A0_TCAM_BIST_CONTROLr_SIZE
typedef BCM89500_A0_TCAM_BIST_CONTROLr_t TCAM_BIST_CONTROLr_t;
#define TCAM_BIST_CONTROLr_CLR BCM89500_A0_TCAM_BIST_CONTROLr_CLR
#define TCAM_BIST_CONTROLr_SET BCM89500_A0_TCAM_BIST_CONTROLr_SET
#define TCAM_BIST_CONTROLr_GET BCM89500_A0_TCAM_BIST_CONTROLr_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_ENf_GET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_ENf_SET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_SET
#define TCAM_BIST_CONTROLr_TCAM_SELf_GET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_SELf_GET
#define TCAM_BIST_CONTROLr_TCAM_SELf_SET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_SELf_SET
#define TCAM_BIST_CONTROLr_RESERVED_0f_GET BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_0f_GET
#define TCAM_BIST_CONTROLr_RESERVED_0f_SET BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_0f_SET
#define TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_GET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_SET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_SET
#define TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_GET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_SET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_SET
#define TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_GET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_GET
#define TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_SET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_SET
#define TCAM_BIST_CONTROLr_RESERVED_1f_GET BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_1f_GET
#define TCAM_BIST_CONTROLr_RESERVED_1f_SET BCM89500_A0_TCAM_BIST_CONTROLr_RESERVED_1f_SET
#define TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_GET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_SET BCM89500_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_SET
#define READ_TCAM_BIST_CONTROLr BCM89500_A0_READ_TCAM_BIST_CONTROLr
#define WRITE_TCAM_BIST_CONTROLr BCM89500_A0_WRITE_TCAM_BIST_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TCAM_BIST_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TCAM_BIST_STATUS
 * BLOCKS:   SYS
 * DESC:     TCAM BIST Status Registers (Not2Release)
 * SIZE:     32
 * FIELDS:
 *     TCAM_BIST_STATUS TCAM Bist Status
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TCAM_BIST_STATUSr 0x0000a0a4

#define BCM89500_A0_TCAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TCAM_BIST_STATUS.
 *
 */
typedef union BCM89500_A0_TCAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t tcam_bist_status[1];
	uint32_t _tcam_bist_status;
} BCM89500_A0_TCAM_BIST_STATUSr_t;

#define BCM89500_A0_TCAM_BIST_STATUSr_CLR(r) (r).tcam_bist_status[0] = 0
#define BCM89500_A0_TCAM_BIST_STATUSr_SET(r,d) (r).tcam_bist_status[0] = d
#define BCM89500_A0_TCAM_BIST_STATUSr_GET(r) (r).tcam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_GET(r) (((r).tcam_bist_status[0]) & 0xffff)
#define BCM89500_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_SET(r,f) (r).tcam_bist_status[0]=(((r).tcam_bist_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM89500_A0_TCAM_BIST_STATUSr_RESERVEDf_GET(r) ((((r).tcam_bist_status[0]) >> 16) & 0xffff)
#define BCM89500_A0_TCAM_BIST_STATUSr_RESERVEDf_SET(r,f) (r).tcam_bist_status[0]=(((r).tcam_bist_status[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access TCAM_BIST_STATUS.
 *
 */
#define BCM89500_A0_READ_TCAM_BIST_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TCAM_BIST_STATUSr,(r._tcam_bist_status),4)
#define BCM89500_A0_WRITE_TCAM_BIST_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TCAM_BIST_STATUSr,&(r._tcam_bist_status),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_BIST_STATUSr BCM89500_A0_TCAM_BIST_STATUSr
#define TCAM_BIST_STATUSr_SIZE BCM89500_A0_TCAM_BIST_STATUSr_SIZE
typedef BCM89500_A0_TCAM_BIST_STATUSr_t TCAM_BIST_STATUSr_t;
#define TCAM_BIST_STATUSr_CLR BCM89500_A0_TCAM_BIST_STATUSr_CLR
#define TCAM_BIST_STATUSr_SET BCM89500_A0_TCAM_BIST_STATUSr_SET
#define TCAM_BIST_STATUSr_GET BCM89500_A0_TCAM_BIST_STATUSr_GET
#define TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_GET BCM89500_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_GET
#define TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_SET BCM89500_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_SET
#define TCAM_BIST_STATUSr_RESERVEDf_GET BCM89500_A0_TCAM_BIST_STATUSr_RESERVEDf_GET
#define TCAM_BIST_STATUSr_RESERVEDf_SET BCM89500_A0_TCAM_BIST_STATUSr_RESERVEDf_SET
#define READ_TCAM_BIST_STATUSr BCM89500_A0_READ_TCAM_BIST_STATUSr
#define WRITE_TCAM_BIST_STATUSr BCM89500_A0_WRITE_TCAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TCAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TCAM_CHKSUM_STS
 * BLOCKS:   SYS
 * DESC:     TCAM Checksum Status Register
 * SIZE:     16
 * FIELDS:
 *     CFP_TCAM_CHKSUM_ADDR CFP TCAM checksum address [7:0].
 *     RESERVED         Reserved
 *     CFP_TCAM_CHKSUM_ERR CFP TCAM checksum error.1 = checksum error and the error address is stored in the field "CFP_TCAM_CHKSUM_ADDR". This error can be cleared by writing new values to the error address.0 = no error.
 *
 ******************************************************************************/
#define BCM89500_A0_TCAM_CHKSUM_STSr 0x000000ea

#define BCM89500_A0_TCAM_CHKSUM_STSr_SIZE 2

/*
 * This structure should be used to declare and program TCAM_CHKSUM_STS.
 *
 */
typedef union BCM89500_A0_TCAM_CHKSUM_STSr_s {
	uint32_t v[1];
	uint32_t tcam_chksum_sts[1];
	uint32_t _tcam_chksum_sts;
} BCM89500_A0_TCAM_CHKSUM_STSr_t;

#define BCM89500_A0_TCAM_CHKSUM_STSr_CLR(r) (r).tcam_chksum_sts[0] = 0
#define BCM89500_A0_TCAM_CHKSUM_STSr_SET(r,d) (r).tcam_chksum_sts[0] = d
#define BCM89500_A0_TCAM_CHKSUM_STSr_GET(r) (r).tcam_chksum_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_GET(r) (((r).tcam_chksum_sts[0]) & 0xff)
#define BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_TCAM_CHKSUM_STSr_RESERVEDf_GET(r) ((((r).tcam_chksum_sts[0]) >> 8) & 0x7f)
#define BCM89500_A0_TCAM_CHKSUM_STSr_RESERVEDf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_GET(r) ((((r).tcam_chksum_sts[0]) >> 15) & 0x1)
#define BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access TCAM_CHKSUM_STS.
 *
 */
#define BCM89500_A0_READ_TCAM_CHKSUM_STSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TCAM_CHKSUM_STSr,(r._tcam_chksum_sts),2)
#define BCM89500_A0_WRITE_TCAM_CHKSUM_STSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TCAM_CHKSUM_STSr,&(r._tcam_chksum_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_CHKSUM_STSr BCM89500_A0_TCAM_CHKSUM_STSr
#define TCAM_CHKSUM_STSr_SIZE BCM89500_A0_TCAM_CHKSUM_STSr_SIZE
typedef BCM89500_A0_TCAM_CHKSUM_STSr_t TCAM_CHKSUM_STSr_t;
#define TCAM_CHKSUM_STSr_CLR BCM89500_A0_TCAM_CHKSUM_STSr_CLR
#define TCAM_CHKSUM_STSr_SET BCM89500_A0_TCAM_CHKSUM_STSr_SET
#define TCAM_CHKSUM_STSr_GET BCM89500_A0_TCAM_CHKSUM_STSr_GET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_GET BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_GET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_SET BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_SET
#define TCAM_CHKSUM_STSr_RESERVEDf_GET BCM89500_A0_TCAM_CHKSUM_STSr_RESERVEDf_GET
#define TCAM_CHKSUM_STSr_RESERVEDf_SET BCM89500_A0_TCAM_CHKSUM_STSr_RESERVEDf_SET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_GET BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_GET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_SET BCM89500_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_SET
#define READ_TCAM_CHKSUM_STSr BCM89500_A0_READ_TCAM_CHKSUM_STSr
#define WRITE_TCAM_CHKSUM_STSr BCM89500_A0_WRITE_TCAM_CHKSUM_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TCAM_CHKSUM_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TCAM_CTRL
 * BLOCKS:   SYS
 * DESC:     TCAM Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *     EN_TCAM_CHKSUM   1 = To enable TCAM checksum.
 *
 ******************************************************************************/
#define BCM89500_A0_TCAM_CTRLr 0x000000e8

#define BCM89500_A0_TCAM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program TCAM_CTRL.
 *
 */
typedef union BCM89500_A0_TCAM_CTRLr_s {
	uint32_t v[1];
	uint32_t tcam_ctrl[1];
	uint32_t _tcam_ctrl;
} BCM89500_A0_TCAM_CTRLr_t;

#define BCM89500_A0_TCAM_CTRLr_CLR(r) (r).tcam_ctrl[0] = 0
#define BCM89500_A0_TCAM_CTRLr_SET(r,d) (r).tcam_ctrl[0] = d
#define BCM89500_A0_TCAM_CTRLr_GET(r) (r).tcam_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TCAM_CTRLr_RESERVEDf_GET(r) (((r).tcam_ctrl[0]) & 0x7f)
#define BCM89500_A0_TCAM_CTRLr_RESERVEDf_SET(r,f) (r).tcam_ctrl[0]=(((r).tcam_ctrl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM89500_A0_TCAM_CTRLr_EN_TCAM_CHKSUMf_GET(r) ((((r).tcam_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_TCAM_CTRLr_EN_TCAM_CHKSUMf_SET(r,f) (r).tcam_ctrl[0]=(((r).tcam_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TCAM_CTRL.
 *
 */
#define BCM89500_A0_READ_TCAM_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TCAM_CTRLr,(r._tcam_ctrl),1)
#define BCM89500_A0_WRITE_TCAM_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TCAM_CTRLr,&(r._tcam_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_CTRLr BCM89500_A0_TCAM_CTRLr
#define TCAM_CTRLr_SIZE BCM89500_A0_TCAM_CTRLr_SIZE
typedef BCM89500_A0_TCAM_CTRLr_t TCAM_CTRLr_t;
#define TCAM_CTRLr_CLR BCM89500_A0_TCAM_CTRLr_CLR
#define TCAM_CTRLr_SET BCM89500_A0_TCAM_CTRLr_SET
#define TCAM_CTRLr_GET BCM89500_A0_TCAM_CTRLr_GET
#define TCAM_CTRLr_RESERVEDf_GET BCM89500_A0_TCAM_CTRLr_RESERVEDf_GET
#define TCAM_CTRLr_RESERVEDf_SET BCM89500_A0_TCAM_CTRLr_RESERVEDf_SET
#define TCAM_CTRLr_EN_TCAM_CHKSUMf_GET BCM89500_A0_TCAM_CTRLr_EN_TCAM_CHKSUMf_GET
#define TCAM_CTRLr_EN_TCAM_CHKSUMf_SET BCM89500_A0_TCAM_CTRLr_EN_TCAM_CHKSUMf_SET
#define READ_TCAM_CTRLr BCM89500_A0_READ_TCAM_CTRLr
#define WRITE_TCAM_CTRLr BCM89500_A0_WRITE_TCAM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TCAM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TCAM_TEST_COMPARE_STATUS
 * BLOCKS:   SYS
 * DESC:     TCAM Test Compare Status Registers (Not2Release)
 * SIZE:     32
 * FIELDS:
 *     TCAM_HIT_ADDR    TCAM Hit Address for test compareThis field contains the address of the entry which hit in the test compare.
 *     RESERVED_0       Reserved
 *     TCAM_HIT         TCAM Hit for test compareThis field indicates if the test compare hit any entries of the TCAM.
 *     RESERVED_1       
 *
 ******************************************************************************/
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr 0x0000a0a8

#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TCAM_TEST_COMPARE_STATUS.
 *
 */
typedef union BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_s {
	uint32_t v[1];
	uint32_t tcam_test_compare_status[1];
	uint32_t _tcam_test_compare_status;
} BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_t;

#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_CLR(r) (r).tcam_test_compare_status[0] = 0
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_SET(r,d) (r).tcam_test_compare_status[0] = d
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_GET(r) (r).tcam_test_compare_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_GET(r) (((r).tcam_test_compare_status[0]) & 0x7f)
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_0f_GET(r) ((((r).tcam_test_compare_status[0]) >> 7) & 0xff)
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_0f_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7))
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_GET(r) ((((r).tcam_test_compare_status[0]) >> 15) & 0x1)
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1f_GET(r) ((((r).tcam_test_compare_status[0]) >> 16) & 0xffff)
#define BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1f_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access TCAM_TEST_COMPARE_STATUS.
 *
 */
#define BCM89500_A0_READ_TCAM_TEST_COMPARE_STATUSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TCAM_TEST_COMPARE_STATUSr,(r._tcam_test_compare_status),4)
#define BCM89500_A0_WRITE_TCAM_TEST_COMPARE_STATUSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TCAM_TEST_COMPARE_STATUSr,&(r._tcam_test_compare_status),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_TEST_COMPARE_STATUSr BCM89500_A0_TCAM_TEST_COMPARE_STATUSr
#define TCAM_TEST_COMPARE_STATUSr_SIZE BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_SIZE
typedef BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_t TCAM_TEST_COMPARE_STATUSr_t;
#define TCAM_TEST_COMPARE_STATUSr_CLR BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_CLR
#define TCAM_TEST_COMPARE_STATUSr_SET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_SET
#define TCAM_TEST_COMPARE_STATUSr_GET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_GET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_GET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_GET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_SET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_SET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_0f_GET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_0f_GET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_0f_SET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_0f_SET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_GET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_GET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_SET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_SET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_1f_GET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1f_GET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_1f_SET BCM89500_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1f_SET
#define READ_TCAM_TEST_COMPARE_STATUSr BCM89500_A0_READ_TCAM_TEST_COMPARE_STATUSr
#define WRITE_TCAM_TEST_COMPARE_STATUSr BCM89500_A0_WRITE_TCAM_TEST_COMPARE_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TCAM_TEST_COMPARE_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TC_SEL_TABLE
 * BLOCKS:   SYS
 * DESC:     Port N TC Select Table Register (polar feature)
 * SIZE:     16
 * FIELDS:
 *     TC_SEL_0         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_1         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_2         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_3         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_4         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_5         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_6         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *     TC_SEL_7         A lookup table is indexed by the internal flags, including IP packet, trusted tagged packaet, and static MAC destination to select the TC decision source.2'b11: PID2TC.2'b10: DA2TC.2'b01: PCP2TC.2'b00: DSCP2TC.
 *
 ******************************************************************************/
#define BCM89500_A0_TC_SEL_TABLEr 0x00003050

#define BCM89500_A0_TC_SEL_TABLEr_SIZE 2

/*
 * This structure should be used to declare and program TC_SEL_TABLE.
 *
 */
typedef union BCM89500_A0_TC_SEL_TABLEr_s {
	uint32_t v[1];
	uint32_t tc_sel_table[1];
	uint32_t _tc_sel_table;
} BCM89500_A0_TC_SEL_TABLEr_t;

#define BCM89500_A0_TC_SEL_TABLEr_CLR(r) (r).tc_sel_table[0] = 0
#define BCM89500_A0_TC_SEL_TABLEr_SET(r,d) (r).tc_sel_table[0] = d
#define BCM89500_A0_TC_SEL_TABLEr_GET(r) (r).tc_sel_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_0f_GET(r) (((r).tc_sel_table[0]) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_0f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_1f_GET(r) ((((r).tc_sel_table[0]) >> 2) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_1f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_2f_GET(r) ((((r).tc_sel_table[0]) >> 4) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_2f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_3f_GET(r) ((((r).tc_sel_table[0]) >> 6) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_3f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_4f_GET(r) ((((r).tc_sel_table[0]) >> 8) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_4f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_5f_GET(r) ((((r).tc_sel_table[0]) >> 10) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_5f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_6f_GET(r) ((((r).tc_sel_table[0]) >> 12) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_6f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_7f_GET(r) ((((r).tc_sel_table[0]) >> 14) & 0x3)
#define BCM89500_A0_TC_SEL_TABLEr_TC_SEL_7f_SET(r,f) (r).tc_sel_table[0]=(((r).tc_sel_table[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access TC_SEL_TABLE.
 *
 */
#define BCM89500_A0_READ_TC_SEL_TABLEr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_TC_SEL_TABLEr+(2*(i)),(r._tc_sel_table),2)
#define BCM89500_A0_WRITE_TC_SEL_TABLEr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_TC_SEL_TABLEr+(2*(i)),&(r._tc_sel_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TC_SEL_TABLEr BCM89500_A0_TC_SEL_TABLEr
#define TC_SEL_TABLEr_SIZE BCM89500_A0_TC_SEL_TABLEr_SIZE
typedef BCM89500_A0_TC_SEL_TABLEr_t TC_SEL_TABLEr_t;
#define TC_SEL_TABLEr_CLR BCM89500_A0_TC_SEL_TABLEr_CLR
#define TC_SEL_TABLEr_SET BCM89500_A0_TC_SEL_TABLEr_SET
#define TC_SEL_TABLEr_GET BCM89500_A0_TC_SEL_TABLEr_GET
#define TC_SEL_TABLEr_TC_SEL_0f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_0f_GET
#define TC_SEL_TABLEr_TC_SEL_0f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_0f_SET
#define TC_SEL_TABLEr_TC_SEL_1f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_1f_GET
#define TC_SEL_TABLEr_TC_SEL_1f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_1f_SET
#define TC_SEL_TABLEr_TC_SEL_2f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_2f_GET
#define TC_SEL_TABLEr_TC_SEL_2f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_2f_SET
#define TC_SEL_TABLEr_TC_SEL_3f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_3f_GET
#define TC_SEL_TABLEr_TC_SEL_3f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_3f_SET
#define TC_SEL_TABLEr_TC_SEL_4f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_4f_GET
#define TC_SEL_TABLEr_TC_SEL_4f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_4f_SET
#define TC_SEL_TABLEr_TC_SEL_5f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_5f_GET
#define TC_SEL_TABLEr_TC_SEL_5f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_5f_SET
#define TC_SEL_TABLEr_TC_SEL_6f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_6f_GET
#define TC_SEL_TABLEr_TC_SEL_6f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_6f_SET
#define TC_SEL_TABLEr_TC_SEL_7f_GET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_7f_GET
#define TC_SEL_TABLEr_TC_SEL_7f_SET BCM89500_A0_TC_SEL_TABLEr_TC_SEL_7f_SET
#define READ_TC_SEL_TABLEr BCM89500_A0_READ_TC_SEL_TABLEr
#define WRITE_TC_SEL_TABLEr BCM89500_A0_WRITE_TC_SEL_TABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TC_SEL_TABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TEMP_MON_CAL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Calibration Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA_25C    Temperature measure code at 25oC. The default value is loaded from OTPmemory and the value is changeable if required.Note: Temperature(oC) = (measure code - TEMP_DATA_25)*(-0.69)+25oC.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_TEMP_MON_CALr 0x00000f06

#define BCM89500_A0_TEMP_MON_CALr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_CAL.
 *
 */
typedef union BCM89500_A0_TEMP_MON_CALr_s {
	uint32_t v[1];
	uint32_t temp_mon_cal[1];
	uint32_t _temp_mon_cal;
} BCM89500_A0_TEMP_MON_CALr_t;

#define BCM89500_A0_TEMP_MON_CALr_CLR(r) (r).temp_mon_cal[0] = 0
#define BCM89500_A0_TEMP_MON_CALr_SET(r,d) (r).temp_mon_cal[0] = d
#define BCM89500_A0_TEMP_MON_CALr_GET(r) (r).temp_mon_cal[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET(r) (((r).temp_mon_cal[0]) & 0x1ff)
#define BCM89500_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_TEMP_MON_CALr_RESERVEDf_GET(r) ((((r).temp_mon_cal[0]) >> 9) & 0x7f)
#define BCM89500_A0_TEMP_MON_CALr_RESERVEDf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_CAL.
 *
 */
#define BCM89500_A0_READ_TEMP_MON_CALr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TEMP_MON_CALr,(r._temp_mon_cal),2)
#define BCM89500_A0_WRITE_TEMP_MON_CALr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TEMP_MON_CALr,&(r._temp_mon_cal),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CALr BCM89500_A0_TEMP_MON_CALr
#define TEMP_MON_CALr_SIZE BCM89500_A0_TEMP_MON_CALr_SIZE
typedef BCM89500_A0_TEMP_MON_CALr_t TEMP_MON_CALr_t;
#define TEMP_MON_CALr_CLR BCM89500_A0_TEMP_MON_CALr_CLR
#define TEMP_MON_CALr_SET BCM89500_A0_TEMP_MON_CALr_SET
#define TEMP_MON_CALr_GET BCM89500_A0_TEMP_MON_CALr_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_GET BCM89500_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_SET BCM89500_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET
#define TEMP_MON_CALr_RESERVEDf_GET BCM89500_A0_TEMP_MON_CALr_RESERVEDf_GET
#define TEMP_MON_CALr_RESERVEDf_SET BCM89500_A0_TEMP_MON_CALr_RESERVEDf_SET
#define READ_TEMP_MON_CALr BCM89500_A0_READ_TEMP_MON_CALr
#define WRITE_TEMP_MON_CALr BCM89500_A0_WRITE_TEMP_MON_CALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TEMP_MON_CALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TEMP_MON_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     ADC_TEST_EN      1 = Temp monitor normal mode.0 = SAR ADC test mode.(Not2Release)
 *     BIAS_ADJUST      Analog bias adjustments.(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_TEMP_MON_CTLr 0x00000f00

#define BCM89500_A0_TEMP_MON_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_CTL.
 *
 */
typedef union BCM89500_A0_TEMP_MON_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_ctl[1];
	uint32_t _temp_mon_ctl;
} BCM89500_A0_TEMP_MON_CTLr_t;

#define BCM89500_A0_TEMP_MON_CTLr_CLR(r) (r).temp_mon_ctl[0] = 0
#define BCM89500_A0_TEMP_MON_CTLr_SET(r,d) (r).temp_mon_ctl[0] = d
#define BCM89500_A0_TEMP_MON_CTLr_GET(r) (r).temp_mon_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET(r) (((r).temp_mon_ctl[0]) & 0x1)
#define BCM89500_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET(r) ((((r).temp_mon_ctl[0]) >> 1) & 0x7f)
#define BCM89500_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_CTL.
 *
 */
#define BCM89500_A0_READ_TEMP_MON_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TEMP_MON_CTLr,(r._temp_mon_ctl),1)
#define BCM89500_A0_WRITE_TEMP_MON_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TEMP_MON_CTLr,&(r._temp_mon_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CTLr BCM89500_A0_TEMP_MON_CTLr
#define TEMP_MON_CTLr_SIZE BCM89500_A0_TEMP_MON_CTLr_SIZE
typedef BCM89500_A0_TEMP_MON_CTLr_t TEMP_MON_CTLr_t;
#define TEMP_MON_CTLr_CLR BCM89500_A0_TEMP_MON_CTLr_CLR
#define TEMP_MON_CTLr_SET BCM89500_A0_TEMP_MON_CTLr_SET
#define TEMP_MON_CTLr_GET BCM89500_A0_TEMP_MON_CTLr_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_GET BCM89500_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_SET BCM89500_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_GET BCM89500_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_SET BCM89500_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET
#define READ_TEMP_MON_CTLr BCM89500_A0_READ_TEMP_MON_CTLr
#define WRITE_TEMP_MON_CTLr BCM89500_A0_WRITE_TEMP_MON_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TEMP_MON_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA        Temperature monitor result. When the temperature is higher, the measure code is lower.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_TEMP_MON_RESUr 0x00000f02

#define BCM89500_A0_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_RESU.
 *
 */
typedef union BCM89500_A0_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t temp_mon_resu[1];
	uint32_t _temp_mon_resu;
} BCM89500_A0_TEMP_MON_RESUr_t;

#define BCM89500_A0_TEMP_MON_RESUr_CLR(r) (r).temp_mon_resu[0] = 0
#define BCM89500_A0_TEMP_MON_RESUr_SET(r,d) (r).temp_mon_resu[0] = d
#define BCM89500_A0_TEMP_MON_RESUr_GET(r) (r).temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TEMP_MON_RESUr_TEMP_DATAf_GET(r) (((r).temp_mon_resu[0]) & 0x1ff)
#define BCM89500_A0_TEMP_MON_RESUr_TEMP_DATAf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM89500_A0_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_RESU.
 *
 */
#define BCM89500_A0_READ_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TEMP_MON_RESUr,(r._temp_mon_resu),2)
#define BCM89500_A0_WRITE_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TEMP_MON_RESUr,&(r._temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_RESUr BCM89500_A0_TEMP_MON_RESUr
#define TEMP_MON_RESUr_SIZE BCM89500_A0_TEMP_MON_RESUr_SIZE
typedef BCM89500_A0_TEMP_MON_RESUr_t TEMP_MON_RESUr_t;
#define TEMP_MON_RESUr_CLR BCM89500_A0_TEMP_MON_RESUr_CLR
#define TEMP_MON_RESUr_SET BCM89500_A0_TEMP_MON_RESUr_SET
#define TEMP_MON_RESUr_GET BCM89500_A0_TEMP_MON_RESUr_GET
#define TEMP_MON_RESUr_TEMP_DATAf_GET BCM89500_A0_TEMP_MON_RESUr_TEMP_DATAf_GET
#define TEMP_MON_RESUr_TEMP_DATAf_SET BCM89500_A0_TEMP_MON_RESUr_TEMP_DATAf_SET
#define TEMP_MON_RESUr_RESERVEDf_GET BCM89500_A0_TEMP_MON_RESUr_RESERVEDf_GET
#define TEMP_MON_RESUr_RESERVEDf_SET BCM89500_A0_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_TEMP_MON_RESUr BCM89500_A0_READ_TEMP_MON_RESUr
#define WRITE_TEMP_MON_RESUr BCM89500_A0_WRITE_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TEMP_MON_SPEC_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Special Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     TEMP_PWRDN       1=Set temperature monitor in power down condition.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_TEMP_MON_SPEC_CTLr 0x00000f08

#define BCM89500_A0_TEMP_MON_SPEC_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_SPEC_CTL.
 *
 */
typedef union BCM89500_A0_TEMP_MON_SPEC_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_spec_ctl[1];
	uint32_t _temp_mon_spec_ctl;
} BCM89500_A0_TEMP_MON_SPEC_CTLr_t;

#define BCM89500_A0_TEMP_MON_SPEC_CTLr_CLR(r) (r).temp_mon_spec_ctl[0] = 0
#define BCM89500_A0_TEMP_MON_SPEC_CTLr_SET(r,d) (r).temp_mon_spec_ctl[0] = d
#define BCM89500_A0_TEMP_MON_SPEC_CTLr_GET(r) (r).temp_mon_spec_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET(r) (((r).temp_mon_spec_ctl[0]) & 0x1)
#define BCM89500_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET(r) ((((r).temp_mon_spec_ctl[0]) >> 1) & 0x7f)
#define BCM89500_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_SPEC_CTL.
 *
 */
#define BCM89500_A0_READ_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TEMP_MON_SPEC_CTLr,(r._temp_mon_spec_ctl),1)
#define BCM89500_A0_WRITE_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TEMP_MON_SPEC_CTLr,&(r._temp_mon_spec_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_SPEC_CTLr BCM89500_A0_TEMP_MON_SPEC_CTLr
#define TEMP_MON_SPEC_CTLr_SIZE BCM89500_A0_TEMP_MON_SPEC_CTLr_SIZE
typedef BCM89500_A0_TEMP_MON_SPEC_CTLr_t TEMP_MON_SPEC_CTLr_t;
#define TEMP_MON_SPEC_CTLr_CLR BCM89500_A0_TEMP_MON_SPEC_CTLr_CLR
#define TEMP_MON_SPEC_CTLr_SET BCM89500_A0_TEMP_MON_SPEC_CTLr_SET
#define TEMP_MON_SPEC_CTLr_GET BCM89500_A0_TEMP_MON_SPEC_CTLr_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET BCM89500_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET BCM89500_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_GET BCM89500_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_SET BCM89500_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET
#define READ_TEMP_MON_SPEC_CTLr BCM89500_A0_READ_TEMP_MON_SPEC_CTLr
#define WRITE_TEMP_MON_SPEC_CTLr BCM89500_A0_WRITE_TEMP_MON_SPEC_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TEMP_MON_SPEC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TIMECODE_SEL
 * BLOCKS:   SYS
 * DESC:     TX RX Time Code Select Registers
 * SIZE:     16
 * FIELDS:
 *     TX_TIMECODE_SEL  TX time code selectbit[7:6]: port8-port7bit[5:0]: port5-port01'b1: internal IEEE time code[63:0] is stored at time stamp register 0~3.1'b0: time stamp[47:0] is stored at time stamp register 0~2.
 *     RX_TIMECODE_SEL  RX time code selectbit[7:6]: port8-port7bit[5:0]: port5-port01'b1: internal IEEE time code[63:0] is stored at time stamp register 0~3.1'b0: time stamp[47:0] is stored at time stamp register 0~2.
 *
 ******************************************************************************/
#define BCM89500_A0_TIMECODE_SELr 0x0000947c

#define BCM89500_A0_TIMECODE_SELr_SIZE 2

/*
 * This structure should be used to declare and program TIMECODE_SEL.
 *
 */
typedef union BCM89500_A0_TIMECODE_SELr_s {
	uint32_t v[1];
	uint32_t timecode_sel[1];
	uint32_t _timecode_sel;
} BCM89500_A0_TIMECODE_SELr_t;

#define BCM89500_A0_TIMECODE_SELr_CLR(r) (r).timecode_sel[0] = 0
#define BCM89500_A0_TIMECODE_SELr_SET(r,d) (r).timecode_sel[0] = d
#define BCM89500_A0_TIMECODE_SELr_GET(r) (r).timecode_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TIMECODE_SELr_TX_TIMECODE_SELf_GET(r) (((r).timecode_sel[0]) & 0xff)
#define BCM89500_A0_TIMECODE_SELr_TX_TIMECODE_SELf_SET(r,f) (r).timecode_sel[0]=(((r).timecode_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_TIMECODE_SELr_RX_TIMECODE_SELf_GET(r) ((((r).timecode_sel[0]) >> 8) & 0xff)
#define BCM89500_A0_TIMECODE_SELr_RX_TIMECODE_SELf_SET(r,f) (r).timecode_sel[0]=(((r).timecode_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TIMECODE_SEL.
 *
 */
#define BCM89500_A0_READ_TIMECODE_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TIMECODE_SELr,(r._timecode_sel),2)
#define BCM89500_A0_WRITE_TIMECODE_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TIMECODE_SELr,&(r._timecode_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TIMECODE_SELr BCM89500_A0_TIMECODE_SELr
#define TIMECODE_SELr_SIZE BCM89500_A0_TIMECODE_SELr_SIZE
typedef BCM89500_A0_TIMECODE_SELr_t TIMECODE_SELr_t;
#define TIMECODE_SELr_CLR BCM89500_A0_TIMECODE_SELr_CLR
#define TIMECODE_SELr_SET BCM89500_A0_TIMECODE_SELr_SET
#define TIMECODE_SELr_GET BCM89500_A0_TIMECODE_SELr_GET
#define TIMECODE_SELr_TX_TIMECODE_SELf_GET BCM89500_A0_TIMECODE_SELr_TX_TIMECODE_SELf_GET
#define TIMECODE_SELr_TX_TIMECODE_SELf_SET BCM89500_A0_TIMECODE_SELr_TX_TIMECODE_SELf_SET
#define TIMECODE_SELr_RX_TIMECODE_SELf_GET BCM89500_A0_TIMECODE_SELr_RX_TIMECODE_SELf_GET
#define TIMECODE_SELr_RX_TIMECODE_SELf_SET BCM89500_A0_TIMECODE_SELr_RX_TIMECODE_SELf_SET
#define READ_TIMECODE_SELr BCM89500_A0_READ_TIMECODE_SELr
#define WRITE_TIMECODE_SELr BCM89500_A0_WRITE_TIMECODE_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TIMECODE_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TIME_CODE_N
 * BLOCKS:   SYS
 * DESC:     Original Time Code N Registers
 * SIZE:     16
 * FIELDS:
 *     TIME_CODE_N      Original time code value that will be used in egress port for sync, delay_req andPdelay_req message.TIME_CODE={TIME_CODE_4, TIME_CODE_3, TIME_CODE_2, TIME_CODE_1, TIME_CODE_0}
 *
 ******************************************************************************/
#define BCM89500_A0_TIME_CODE_Nr 0x00009388

#define BCM89500_A0_TIME_CODE_Nr_SIZE 2

/*
 * This structure should be used to declare and program TIME_CODE_N.
 *
 */
typedef union BCM89500_A0_TIME_CODE_Nr_s {
	uint32_t v[1];
	uint32_t time_code_n[1];
	uint32_t _time_code_n;
} BCM89500_A0_TIME_CODE_Nr_t;

#define BCM89500_A0_TIME_CODE_Nr_CLR(r) (r).time_code_n[0] = 0
#define BCM89500_A0_TIME_CODE_Nr_SET(r,d) (r).time_code_n[0] = d
#define BCM89500_A0_TIME_CODE_Nr_GET(r) (r).time_code_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TIME_CODE_Nr_TIME_CODE_Nf_GET(r) (((r).time_code_n[0]) & 0xffff)
#define BCM89500_A0_TIME_CODE_Nr_TIME_CODE_Nf_SET(r,f) (r).time_code_n[0]=(((r).time_code_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIME_CODE_N.
 *
 */
#define BCM89500_A0_READ_TIME_CODE_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_TIME_CODE_Nr+(2*(i)),(r._time_code_n),2)
#define BCM89500_A0_WRITE_TIME_CODE_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_TIME_CODE_Nr+(2*(i)),&(r._time_code_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TIME_CODE_Nr BCM89500_A0_TIME_CODE_Nr
#define TIME_CODE_Nr_SIZE BCM89500_A0_TIME_CODE_Nr_SIZE
typedef BCM89500_A0_TIME_CODE_Nr_t TIME_CODE_Nr_t;
#define TIME_CODE_Nr_CLR BCM89500_A0_TIME_CODE_Nr_CLR
#define TIME_CODE_Nr_SET BCM89500_A0_TIME_CODE_Nr_SET
#define TIME_CODE_Nr_GET BCM89500_A0_TIME_CODE_Nr_GET
#define TIME_CODE_Nr_TIME_CODE_Nf_GET BCM89500_A0_TIME_CODE_Nr_TIME_CODE_Nf_GET
#define TIME_CODE_Nr_TIME_CODE_Nf_SET BCM89500_A0_TIME_CODE_Nr_TIME_CODE_Nf_SET
#define READ_TIME_CODE_Nr BCM89500_A0_READ_TIME_CODE_Nr
#define WRITE_TIME_CODE_Nr BCM89500_A0_WRITE_TIME_CODE_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TIME_CODE_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TIME_STAMP_3
 * BLOCKS:   SYS
 * DESC:     Time Stamp Register 3
 * SIZE:     16
 * FIELDS:
 *     TIME_STAMP_3     When RX_TIMECODE_SEL or TX_TIMECODE_SEL is set, TIME_STAMP_3 represents internal IEEE time code[63:48]. Otherwise, don't care this register.
 *
 ******************************************************************************/
#define BCM89500_A0_TIME_STAMP_3r 0x0000947e

#define BCM89500_A0_TIME_STAMP_3r_SIZE 2

/*
 * This structure should be used to declare and program TIME_STAMP_3.
 *
 */
typedef union BCM89500_A0_TIME_STAMP_3r_s {
	uint32_t v[1];
	uint32_t time_stamp_3[1];
	uint32_t _time_stamp_3;
} BCM89500_A0_TIME_STAMP_3r_t;

#define BCM89500_A0_TIME_STAMP_3r_CLR(r) (r).time_stamp_3[0] = 0
#define BCM89500_A0_TIME_STAMP_3r_SET(r,d) (r).time_stamp_3[0] = d
#define BCM89500_A0_TIME_STAMP_3r_GET(r) (r).time_stamp_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TIME_STAMP_3r_TIME_STAMP_3f_GET(r) (((r).time_stamp_3[0]) & 0xffff)
#define BCM89500_A0_TIME_STAMP_3r_TIME_STAMP_3f_SET(r,f) (r).time_stamp_3[0]=(((r).time_stamp_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIME_STAMP_3.
 *
 */
#define BCM89500_A0_READ_TIME_STAMP_3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TIME_STAMP_3r,(r._time_stamp_3),2)
#define BCM89500_A0_WRITE_TIME_STAMP_3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TIME_STAMP_3r,&(r._time_stamp_3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TIME_STAMP_3r BCM89500_A0_TIME_STAMP_3r
#define TIME_STAMP_3r_SIZE BCM89500_A0_TIME_STAMP_3r_SIZE
typedef BCM89500_A0_TIME_STAMP_3r_t TIME_STAMP_3r_t;
#define TIME_STAMP_3r_CLR BCM89500_A0_TIME_STAMP_3r_CLR
#define TIME_STAMP_3r_SET BCM89500_A0_TIME_STAMP_3r_SET
#define TIME_STAMP_3r_GET BCM89500_A0_TIME_STAMP_3r_GET
#define TIME_STAMP_3r_TIME_STAMP_3f_GET BCM89500_A0_TIME_STAMP_3r_TIME_STAMP_3f_GET
#define TIME_STAMP_3r_TIME_STAMP_3f_SET BCM89500_A0_TIME_STAMP_3r_TIME_STAMP_3f_SET
#define READ_TIME_STAMP_3r BCM89500_A0_READ_TIME_STAMP_3r
#define WRITE_TIME_STAMP_3r BCM89500_A0_WRITE_TIME_STAMP_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TIME_STAMP_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TIME_STAMP_INFO_N
 * BLOCKS:   SYS
 * DESC:     Time Stamp Register Info N
 * SIZE:     16
 * FIELDS:
 *     TIME_STAMP_INFO_N Output SOP Time Stamp InfoINFO_0 = 1588 packet sequence IDINFO_1 = {message type[3:0], TX(1'b1)/RX(1'b0), port number[2:0], sequence ID[15:8]}
 *
 ******************************************************************************/
#define BCM89500_A0_TIME_STAMP_INFO_Nr 0x0000940e

#define BCM89500_A0_TIME_STAMP_INFO_Nr_SIZE 2

/*
 * This structure should be used to declare and program TIME_STAMP_INFO_N.
 *
 */
typedef union BCM89500_A0_TIME_STAMP_INFO_Nr_s {
	uint32_t v[1];
	uint32_t time_stamp_info_n[1];
	uint32_t _time_stamp_info_n;
} BCM89500_A0_TIME_STAMP_INFO_Nr_t;

#define BCM89500_A0_TIME_STAMP_INFO_Nr_CLR(r) (r).time_stamp_info_n[0] = 0
#define BCM89500_A0_TIME_STAMP_INFO_Nr_SET(r,d) (r).time_stamp_info_n[0] = d
#define BCM89500_A0_TIME_STAMP_INFO_Nr_GET(r) (r).time_stamp_info_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TIME_STAMP_INFO_Nr_TIME_STAMP_INFO_Nf_GET(r) (((r).time_stamp_info_n[0]) & 0xffff)
#define BCM89500_A0_TIME_STAMP_INFO_Nr_TIME_STAMP_INFO_Nf_SET(r,f) (r).time_stamp_info_n[0]=(((r).time_stamp_info_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIME_STAMP_INFO_N.
 *
 */
#define BCM89500_A0_READ_TIME_STAMP_INFO_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_TIME_STAMP_INFO_Nr+(2*(i)),(r._time_stamp_info_n),2)
#define BCM89500_A0_WRITE_TIME_STAMP_INFO_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_TIME_STAMP_INFO_Nr+(2*(i)),&(r._time_stamp_info_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TIME_STAMP_INFO_Nr BCM89500_A0_TIME_STAMP_INFO_Nr
#define TIME_STAMP_INFO_Nr_SIZE BCM89500_A0_TIME_STAMP_INFO_Nr_SIZE
typedef BCM89500_A0_TIME_STAMP_INFO_Nr_t TIME_STAMP_INFO_Nr_t;
#define TIME_STAMP_INFO_Nr_CLR BCM89500_A0_TIME_STAMP_INFO_Nr_CLR
#define TIME_STAMP_INFO_Nr_SET BCM89500_A0_TIME_STAMP_INFO_Nr_SET
#define TIME_STAMP_INFO_Nr_GET BCM89500_A0_TIME_STAMP_INFO_Nr_GET
#define TIME_STAMP_INFO_Nr_TIME_STAMP_INFO_Nf_GET BCM89500_A0_TIME_STAMP_INFO_Nr_TIME_STAMP_INFO_Nf_GET
#define TIME_STAMP_INFO_Nr_TIME_STAMP_INFO_Nf_SET BCM89500_A0_TIME_STAMP_INFO_Nr_TIME_STAMP_INFO_Nf_SET
#define READ_TIME_STAMP_INFO_Nr BCM89500_A0_READ_TIME_STAMP_INFO_Nr
#define WRITE_TIME_STAMP_INFO_Nr BCM89500_A0_WRITE_TIME_STAMP_INFO_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TIME_STAMP_INFO_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TIME_STAMP_N
 * BLOCKS:   SYS
 * DESC:     Time Stamp Register N
 * SIZE:     16
 * FIELDS:
 *     TIME_STAMP_N     Output of the timestamp of 1588 rx/tx packet. Each port has 16-entry FIFO to store the time stamp.TIME_STAMP = {TIME_STAMP_2, TIME_STAMP_1, TIME_STAMP_0}
 *
 ******************************************************************************/
#define BCM89500_A0_TIME_STAMP_Nr 0x00009408

#define BCM89500_A0_TIME_STAMP_Nr_SIZE 2

/*
 * This structure should be used to declare and program TIME_STAMP_N.
 *
 */
typedef union BCM89500_A0_TIME_STAMP_Nr_s {
	uint32_t v[1];
	uint32_t time_stamp_n[1];
	uint32_t _time_stamp_n;
} BCM89500_A0_TIME_STAMP_Nr_t;

#define BCM89500_A0_TIME_STAMP_Nr_CLR(r) (r).time_stamp_n[0] = 0
#define BCM89500_A0_TIME_STAMP_Nr_SET(r,d) (r).time_stamp_n[0] = d
#define BCM89500_A0_TIME_STAMP_Nr_GET(r) (r).time_stamp_n[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TIME_STAMP_Nr_TIME_STAMP_Nf_GET(r) (((r).time_stamp_n[0]) & 0xffff)
#define BCM89500_A0_TIME_STAMP_Nr_TIME_STAMP_Nf_SET(r,f) (r).time_stamp_n[0]=(((r).time_stamp_n[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIME_STAMP_N.
 *
 */
#define BCM89500_A0_READ_TIME_STAMP_Nr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_TIME_STAMP_Nr+(2*(i)),(r._time_stamp_n),2)
#define BCM89500_A0_WRITE_TIME_STAMP_Nr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_TIME_STAMP_Nr+(2*(i)),&(r._time_stamp_n),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TIME_STAMP_Nr BCM89500_A0_TIME_STAMP_Nr
#define TIME_STAMP_Nr_SIZE BCM89500_A0_TIME_STAMP_Nr_SIZE
typedef BCM89500_A0_TIME_STAMP_Nr_t TIME_STAMP_Nr_t;
#define TIME_STAMP_Nr_CLR BCM89500_A0_TIME_STAMP_Nr_CLR
#define TIME_STAMP_Nr_SET BCM89500_A0_TIME_STAMP_Nr_SET
#define TIME_STAMP_Nr_GET BCM89500_A0_TIME_STAMP_Nr_GET
#define TIME_STAMP_Nr_TIME_STAMP_Nf_GET BCM89500_A0_TIME_STAMP_Nr_TIME_STAMP_Nf_GET
#define TIME_STAMP_Nr_TIME_STAMP_Nf_SET BCM89500_A0_TIME_STAMP_Nr_TIME_STAMP_Nf_SET
#define READ_TIME_STAMP_Nr BCM89500_A0_READ_TIME_STAMP_Nr
#define WRITE_TIME_STAMP_Nr BCM89500_A0_WRITE_TIME_STAMP_Nr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TIME_STAMP_Nr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TRREG_CTRL
 * BLOCKS:   SYS
 * DESC:     Traffic Remarking Control Register
 * SIZE:     32
 * FIELDS:
 *     CFI_RMK_EN       CFI Remarking EnableThis signal enables the CFI remarking functionBit[8]: P8(IMP)Bit[7]: P7Bit[5:0]: P5-P0
 *     PCP_RMK_EN       PCP Remarking EnableThis signal enable the PCP remarking function.Bit[24]: P8(IMP port)Bit[23]: P7Bit[21:16]: P5-P0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TRREG_CTRLr 0x00009100

#define BCM89500_A0_TRREG_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program TRREG_CTRL.
 *
 */
typedef union BCM89500_A0_TRREG_CTRLr_s {
	uint32_t v[1];
	uint32_t trreg_ctrl[1];
	uint32_t _trreg_ctrl;
} BCM89500_A0_TRREG_CTRLr_t;

#define BCM89500_A0_TRREG_CTRLr_CLR(r) (r).trreg_ctrl[0] = 0
#define BCM89500_A0_TRREG_CTRLr_SET(r,d) (r).trreg_ctrl[0] = d
#define BCM89500_A0_TRREG_CTRLr_GET(r) (r).trreg_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TRREG_CTRLr_CFI_RMK_ENf_GET(r) (((r).trreg_ctrl[0]) & 0x1ff)
#define BCM89500_A0_TRREG_CTRLr_CFI_RMK_ENf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_TRREG_CTRLr_PCP_RMK_ENf_GET(r) ((((r).trreg_ctrl[0]) >> 16) & 0x1ff)
#define BCM89500_A0_TRREG_CTRLr_PCP_RMK_ENf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff << 16)) | ((((uint32_t)f) & 0x1ff) << 16))
#define BCM89500_A0_TRREG_CTRLr_RESERVED_1f_GET(r) ((((r).trreg_ctrl[0]) >> 25) & 0x7f)
#define BCM89500_A0_TRREG_CTRLr_RESERVED_1f_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access TRREG_CTRL.
 *
 */
#define BCM89500_A0_READ_TRREG_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TRREG_CTRLr,(r._trreg_ctrl),4)
#define BCM89500_A0_WRITE_TRREG_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TRREG_CTRLr,&(r._trreg_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRREG_CTRLr BCM89500_A0_TRREG_CTRLr
#define TRREG_CTRLr_SIZE BCM89500_A0_TRREG_CTRLr_SIZE
typedef BCM89500_A0_TRREG_CTRLr_t TRREG_CTRLr_t;
#define TRREG_CTRLr_CLR BCM89500_A0_TRREG_CTRLr_CLR
#define TRREG_CTRLr_SET BCM89500_A0_TRREG_CTRLr_SET
#define TRREG_CTRLr_GET BCM89500_A0_TRREG_CTRLr_GET
#define TRREG_CTRLr_CFI_RMK_ENf_GET BCM89500_A0_TRREG_CTRLr_CFI_RMK_ENf_GET
#define TRREG_CTRLr_CFI_RMK_ENf_SET BCM89500_A0_TRREG_CTRLr_CFI_RMK_ENf_SET
#define TRREG_CTRLr_PCP_RMK_ENf_GET BCM89500_A0_TRREG_CTRLr_PCP_RMK_ENf_GET
#define TRREG_CTRLr_PCP_RMK_ENf_SET BCM89500_A0_TRREG_CTRLr_PCP_RMK_ENf_SET
#define TRREG_CTRLr_RESERVED_1f_GET BCM89500_A0_TRREG_CTRLr_RESERVED_1f_GET
#define TRREG_CTRLr_RESERVED_1f_SET BCM89500_A0_TRREG_CTRLr_RESERVED_1f_SET
#define READ_TRREG_CTRLr BCM89500_A0_READ_TRREG_CTRLr
#define WRITE_TRREG_CTRLr BCM89500_A0_WRITE_TRREG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TRREG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TRUNK_GRP_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk N Group Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TRUNK_GRP     Trunk Group Enable1 = Enable trunk group.0 = Disable trunk_groupBit 8: IMP port.Bit 7: port 7.Bits[5:0]: port 5-0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TRUNK_GRP_CTLr 0x00003210

#define BCM89500_A0_TRUNK_GRP_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP_CTL.
 *
 */
typedef union BCM89500_A0_TRUNK_GRP_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_ctl[1];
	uint32_t _trunk_grp_ctl;
} BCM89500_A0_TRUNK_GRP_CTLr_t;

#define BCM89500_A0_TRUNK_GRP_CTLr_CLR(r) (r).trunk_grp_ctl[0] = 0
#define BCM89500_A0_TRUNK_GRP_CTLr_SET(r,d) (r).trunk_grp_ctl[0] = d
#define BCM89500_A0_TRUNK_GRP_CTLr_GET(r) (r).trunk_grp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET(r) (((r).trunk_grp_ctl[0]) & 0x1ff)
#define BCM89500_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_TRUNK_GRP_CTLr_RESERVEDf_GET(r) ((((r).trunk_grp_ctl[0]) >> 9) & 0x7f)
#define BCM89500_A0_TRUNK_GRP_CTLr_RESERVEDf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP_CTL.
 *
 */
#define BCM89500_A0_READ_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_TRUNK_GRP_CTLr+(2*(i)),(r._trunk_grp_ctl),2)
#define BCM89500_A0_WRITE_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_TRUNK_GRP_CTLr+(2*(i)),&(r._trunk_grp_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_CTLr BCM89500_A0_TRUNK_GRP_CTLr
#define TRUNK_GRP_CTLr_SIZE BCM89500_A0_TRUNK_GRP_CTLr_SIZE
typedef BCM89500_A0_TRUNK_GRP_CTLr_t TRUNK_GRP_CTLr_t;
#define TRUNK_GRP_CTLr_CLR BCM89500_A0_TRUNK_GRP_CTLr_CLR
#define TRUNK_GRP_CTLr_SET BCM89500_A0_TRUNK_GRP_CTLr_SET
#define TRUNK_GRP_CTLr_GET BCM89500_A0_TRUNK_GRP_CTLr_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET BCM89500_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET BCM89500_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET
#define TRUNK_GRP_CTLr_RESERVEDf_GET BCM89500_A0_TRUNK_GRP_CTLr_RESERVEDf_GET
#define TRUNK_GRP_CTLr_RESERVEDf_SET BCM89500_A0_TRUNK_GRP_CTLr_RESERVEDf_SET
#define READ_TRUNK_GRP_CTLr BCM89500_A0_READ_TRUNK_GRP_CTLr
#define WRITE_TRUNK_GRP_CTLr BCM89500_A0_WRITE_TRUNK_GRP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TRUNK_GRP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TS_READ_START_END
 * BLOCKS:   SYS
 * DESC:     Timestamp READ START and END Register
 * SIZE:     16
 * FIELDS:
 *     PORT0_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT0_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT1_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT1_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT2_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT2_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT3_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT3_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT4_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT4_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT5_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT5_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT7_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT7_TS_READ_END Write 1 to end the time stamp reading.
 *     PORT8_TS_READ_START Write 1 to start the time stamp reading.
 *     PORT8_TS_READ_END Write 1 to end the time stamp reading.
 *
 ******************************************************************************/
#define BCM89500_A0_TS_READ_START_ENDr 0x00009400

#define BCM89500_A0_TS_READ_START_ENDr_SIZE 2

/*
 * This structure should be used to declare and program TS_READ_START_END.
 *
 */
typedef union BCM89500_A0_TS_READ_START_ENDr_s {
	uint32_t v[1];
	uint32_t ts_read_start_end[1];
	uint32_t _ts_read_start_end;
} BCM89500_A0_TS_READ_START_ENDr_t;

#define BCM89500_A0_TS_READ_START_ENDr_CLR(r) (r).ts_read_start_end[0] = 0
#define BCM89500_A0_TS_READ_START_ENDr_SET(r,d) (r).ts_read_start_end[0] = d
#define BCM89500_A0_TS_READ_START_ENDr_GET(r) (r).ts_read_start_end[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_STARTf_GET(r) (((r).ts_read_start_end[0]) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 1) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 2) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 3) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 4) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 5) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 6) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 7) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 8) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 9) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 10) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 11) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 12) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 13) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_STARTf_GET(r) ((((r).ts_read_start_end[0]) >> 14) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_STARTf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_ENDf_GET(r) ((((r).ts_read_start_end[0]) >> 15) & 0x1)
#define BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_ENDf_SET(r,f) (r).ts_read_start_end[0]=(((r).ts_read_start_end[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access TS_READ_START_END.
 *
 */
#define BCM89500_A0_READ_TS_READ_START_ENDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TS_READ_START_ENDr,(r._ts_read_start_end),2)
#define BCM89500_A0_WRITE_TS_READ_START_ENDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TS_READ_START_ENDr,&(r._ts_read_start_end),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TS_READ_START_ENDr BCM89500_A0_TS_READ_START_ENDr
#define TS_READ_START_ENDr_SIZE BCM89500_A0_TS_READ_START_ENDr_SIZE
typedef BCM89500_A0_TS_READ_START_ENDr_t TS_READ_START_ENDr_t;
#define TS_READ_START_ENDr_CLR BCM89500_A0_TS_READ_START_ENDr_CLR
#define TS_READ_START_ENDr_SET BCM89500_A0_TS_READ_START_ENDr_SET
#define TS_READ_START_ENDr_GET BCM89500_A0_TS_READ_START_ENDr_GET
#define TS_READ_START_ENDr_PORT0_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT0_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT0_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT0_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT0_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT1_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT1_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT1_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT1_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT1_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT2_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT2_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT2_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT2_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT2_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT3_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT3_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT3_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT3_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT3_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT4_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT4_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT4_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT4_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT4_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT5_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT5_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT5_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT5_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT5_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT7_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT7_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT7_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT7_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT7_TS_READ_ENDf_SET
#define TS_READ_START_ENDr_PORT8_TS_READ_STARTf_GET BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_STARTf_GET
#define TS_READ_START_ENDr_PORT8_TS_READ_STARTf_SET BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_STARTf_SET
#define TS_READ_START_ENDr_PORT8_TS_READ_ENDf_GET BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_ENDf_GET
#define TS_READ_START_ENDr_PORT8_TS_READ_ENDf_SET BCM89500_A0_TS_READ_START_ENDr_PORT8_TS_READ_ENDf_SET
#define READ_TS_READ_START_ENDr BCM89500_A0_READ_TS_READ_START_ENDr
#define WRITE_TS_READ_START_ENDr BCM89500_A0_WRITE_TS_READ_START_ENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TS_READ_START_ENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TXQ_FLUSH_MODE
 * BLOCKS:   SYS
 * DESC:     TxQ Flush Mode Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     BYPASS_FASTTXDSC_PATH Bypass Fast Txdsc Path.
 *     DIS_NEW_TXDIS    Disable new tx disable.
 *     EN_LCOL_FLUSH    Enable Lcol Flush.
 *     EN_RELOAD_ERR_PATH Enable Reload Error Path.
 *     EN_LCOL_TXFM_MASK bit[4] = enable_lcol_txfm_mask (default = 0)Description:- When enabled, polar drops the TX frame upon a latecollision.  (collisions detected beyond 64th byte including the preamble)- When disabled, polar transmits TX frames regardless of late-collision occurrence.
 *     EN_ECOL_TXFM_MASK PortCollisionModeCollisionTransmitMaskEnablebit[5] = enable_ecol_txfm_mask (default = 1)This bit affect the behavior of the register Retry_Lmt_Dis (Switch Mode reg 00:0Bh bit2) as follows:- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 1,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and stay at 15 until the next normal frame transmission.- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 0,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and loops back to 0and repeats this until the next normal frame transmission.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 1,TX frame is retried up to 15 times, and the frame gets dropped upon the 16th consecutive early collision.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 0,This mode is only engineering purpose, and prohibited for customers (ENGINEERING NOTE: This mode sets polar to the old mode, where we observed the tx ports hang. Don't show this in the customer datasheet).(Not2Release)
 *     EN_LATECOL65_DROP enable_latecol65_drop.Enable old frame drop when a late collision occurs at 65th byte from start of preamble. When enabled, polar goes back to old mode by turning off the fix for Cisco TX Hang.Default is 0(Not2Release)
 *     EN_NEW_BOFF_SEED 1'b1:backoff seed refer to port mumber.1'b0:backoff seed used default fix mumber.
 *
 ******************************************************************************/
#define BCM89500_A0_TXQ_FLUSH_MODEr 0x00000031

#define BCM89500_A0_TXQ_FLUSH_MODEr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_FLUSH_MODE.
 *
 */
typedef union BCM89500_A0_TXQ_FLUSH_MODEr_s {
	uint32_t v[1];
	uint32_t txq_flush_mode[1];
	uint32_t _txq_flush_mode;
} BCM89500_A0_TXQ_FLUSH_MODEr_t;

#define BCM89500_A0_TXQ_FLUSH_MODEr_CLR(r) (r).txq_flush_mode[0] = 0
#define BCM89500_A0_TXQ_FLUSH_MODEr_SET(r,d) (r).txq_flush_mode[0] = d
#define BCM89500_A0_TXQ_FLUSH_MODEr_GET(r) (r).txq_flush_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET(r) (((r).txq_flush_mode[0]) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET(r) ((((r).txq_flush_mode[0]) >> 1) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET(r) ((((r).txq_flush_mode[0]) >> 2) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET(r) ((((r).txq_flush_mode[0]) >> 3) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 4) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 5) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET(r) ((((r).txq_flush_mode[0]) >> 6) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET(r) ((((r).txq_flush_mode[0]) >> 7) & 0x1)
#define BCM89500_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_FLUSH_MODE.
 *
 */
#define BCM89500_A0_READ_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQ_FLUSH_MODEr,(r._txq_flush_mode),1)
#define BCM89500_A0_WRITE_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQ_FLUSH_MODEr,&(r._txq_flush_mode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_FLUSH_MODEr BCM89500_A0_TXQ_FLUSH_MODEr
#define TXQ_FLUSH_MODEr_SIZE BCM89500_A0_TXQ_FLUSH_MODEr_SIZE
typedef BCM89500_A0_TXQ_FLUSH_MODEr_t TXQ_FLUSH_MODEr_t;
#define TXQ_FLUSH_MODEr_CLR BCM89500_A0_TXQ_FLUSH_MODEr_CLR
#define TXQ_FLUSH_MODEr_SET BCM89500_A0_TXQ_FLUSH_MODEr_SET
#define TXQ_FLUSH_MODEr_GET BCM89500_A0_TXQ_FLUSH_MODEr_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET BCM89500_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET BCM89500_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET BCM89500_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET BCM89500_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET BCM89500_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET BCM89500_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET BCM89500_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET BCM89500_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET BCM89500_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET BCM89500_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET BCM89500_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET BCM89500_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET BCM89500_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET
#define READ_TXQ_FLUSH_MODEr BCM89500_A0_READ_TXQ_FLUSH_MODEr
#define WRITE_TXQ_FLUSH_MODEr BCM89500_A0_WRITE_TXQ_FLUSH_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQ_FLUSH_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_COUNTER
 * BLOCKS:   SYS
 * DESC:     TX Counter Register
 * SIZE:     16
 * FIELDS:
 *     TX_COUNTER       The number of packets into TX side.
 *
 ******************************************************************************/
#define BCM89500_A0_TX_COUNTERr 0x000093e4

#define BCM89500_A0_TX_COUNTERr_SIZE 2

/*
 * This structure should be used to declare and program TX_COUNTER.
 *
 */
typedef union BCM89500_A0_TX_COUNTERr_s {
	uint32_t v[1];
	uint32_t tx_counter[1];
	uint32_t _tx_counter;
} BCM89500_A0_TX_COUNTERr_t;

#define BCM89500_A0_TX_COUNTERr_CLR(r) (r).tx_counter[0] = 0
#define BCM89500_A0_TX_COUNTERr_SET(r,d) (r).tx_counter[0] = d
#define BCM89500_A0_TX_COUNTERr_GET(r) (r).tx_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_COUNTERr_TX_COUNTERf_GET(r) (((r).tx_counter[0]) & 0xffff)
#define BCM89500_A0_TX_COUNTERr_TX_COUNTERf_SET(r,f) (r).tx_counter[0]=(((r).tx_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_COUNTER.
 *
 */
#define BCM89500_A0_READ_TX_COUNTERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_COUNTERr,(r._tx_counter),2)
#define BCM89500_A0_WRITE_TX_COUNTERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_COUNTERr,&(r._tx_counter),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_COUNTERr BCM89500_A0_TX_COUNTERr
#define TX_COUNTERr_SIZE BCM89500_A0_TX_COUNTERr_SIZE
typedef BCM89500_A0_TX_COUNTERr_t TX_COUNTERr_t;
#define TX_COUNTERr_CLR BCM89500_A0_TX_COUNTERr_CLR
#define TX_COUNTERr_SET BCM89500_A0_TX_COUNTERr_SET
#define TX_COUNTERr_GET BCM89500_A0_TX_COUNTERr_GET
#define TX_COUNTERr_TX_COUNTERf_GET BCM89500_A0_TX_COUNTERr_TX_COUNTERf_GET
#define TX_COUNTERr_TX_COUNTERf_SET BCM89500_A0_TX_COUNTERr_TX_COUNTERf_SET
#define READ_TX_COUNTERr BCM89500_A0_READ_TX_COUNTERr
#define WRITE_TX_COUNTERr BCM89500_A0_WRITE_TX_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_CTL
 * BLOCKS:   SYS
 * DESC:     Transmit Control Registers
 * SIZE:     16
 * FIELDS:
 *     TX_IPV6_UDP_EN   Enables the 1588 L4/UDP IPV6 packet detection in transmission side.
 *     TX_IPV4_UDP_EN   Enables the 1588 L4/UDP IPV4 packet detection in tramsission side.
 *     TX_L2_EN         Enables the 1588 L2 packet detection in transmission side.
 *     TX_AS_EN         Enables the 802.1as packet detection in transmission side.
 *     TX_L4_IPV6_ADDRESS_EN Enables the Layer4 IP address check when 1588 detection in transmission side.
 *     TX_L4_IP_ADDRESS_EN Enables the Layer4 IP address check when 1588 detection in transmission side.
 *     TX_L2_SA_EN      Enables the Layer2 MAC DA check when 1588 detection in transmission side. 48'h011b_1900_0000 or 48'h0180_c200_000e
 *     TX_AS_SA_EN      Enables the 802.1as MAC DA check when 1588 detection in transmission side.  48'h0180_c200_000e
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_CTLr 0x000093a0

#define BCM89500_A0_TX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TX_CTL.
 *
 */
typedef union BCM89500_A0_TX_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ctl[1];
	uint32_t _tx_ctl;
} BCM89500_A0_TX_CTLr_t;

#define BCM89500_A0_TX_CTLr_CLR(r) (r).tx_ctl[0] = 0
#define BCM89500_A0_TX_CTLr_SET(r,d) (r).tx_ctl[0] = d
#define BCM89500_A0_TX_CTLr_GET(r) (r).tx_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_CTLr_TX_IPV6_UDP_ENf_GET(r) (((r).tx_ctl[0]) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_IPV6_UDP_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_TX_CTLr_TX_IPV4_UDP_ENf_GET(r) ((((r).tx_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_IPV4_UDP_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_TX_CTLr_TX_L2_ENf_GET(r) ((((r).tx_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_L2_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_TX_CTLr_TX_AS_ENf_GET(r) ((((r).tx_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_AS_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_TX_CTLr_TX_L4_IPV6_ADDRESS_ENf_GET(r) ((((r).tx_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_L4_IPV6_ADDRESS_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_TX_CTLr_TX_L4_IP_ADDRESS_ENf_GET(r) ((((r).tx_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_L4_IP_ADDRESS_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_TX_CTLr_TX_L2_SA_ENf_GET(r) ((((r).tx_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_L2_SA_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_TX_CTLr_TX_AS_SA_ENf_GET(r) ((((r).tx_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_TX_CTLr_TX_AS_SA_ENf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_TX_CTLr_RESERVEDf_GET(r) ((((r).tx_ctl[0]) >> 8) & 0xff)
#define BCM89500_A0_TX_CTLr_RESERVEDf_SET(r,f) (r).tx_ctl[0]=(((r).tx_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TX_CTL.
 *
 */
#define BCM89500_A0_READ_TX_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_CTLr,(r._tx_ctl),2)
#define BCM89500_A0_WRITE_TX_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_CTLr,&(r._tx_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_CTLr BCM89500_A0_TX_CTLr
#define TX_CTLr_SIZE BCM89500_A0_TX_CTLr_SIZE
typedef BCM89500_A0_TX_CTLr_t TX_CTLr_t;
#define TX_CTLr_CLR BCM89500_A0_TX_CTLr_CLR
#define TX_CTLr_SET BCM89500_A0_TX_CTLr_SET
#define TX_CTLr_GET BCM89500_A0_TX_CTLr_GET
#define TX_CTLr_TX_IPV6_UDP_ENf_GET BCM89500_A0_TX_CTLr_TX_IPV6_UDP_ENf_GET
#define TX_CTLr_TX_IPV6_UDP_ENf_SET BCM89500_A0_TX_CTLr_TX_IPV6_UDP_ENf_SET
#define TX_CTLr_TX_IPV4_UDP_ENf_GET BCM89500_A0_TX_CTLr_TX_IPV4_UDP_ENf_GET
#define TX_CTLr_TX_IPV4_UDP_ENf_SET BCM89500_A0_TX_CTLr_TX_IPV4_UDP_ENf_SET
#define TX_CTLr_TX_L2_ENf_GET BCM89500_A0_TX_CTLr_TX_L2_ENf_GET
#define TX_CTLr_TX_L2_ENf_SET BCM89500_A0_TX_CTLr_TX_L2_ENf_SET
#define TX_CTLr_TX_AS_ENf_GET BCM89500_A0_TX_CTLr_TX_AS_ENf_GET
#define TX_CTLr_TX_AS_ENf_SET BCM89500_A0_TX_CTLr_TX_AS_ENf_SET
#define TX_CTLr_TX_L4_IPV6_ADDRESS_ENf_GET BCM89500_A0_TX_CTLr_TX_L4_IPV6_ADDRESS_ENf_GET
#define TX_CTLr_TX_L4_IPV6_ADDRESS_ENf_SET BCM89500_A0_TX_CTLr_TX_L4_IPV6_ADDRESS_ENf_SET
#define TX_CTLr_TX_L4_IP_ADDRESS_ENf_GET BCM89500_A0_TX_CTLr_TX_L4_IP_ADDRESS_ENf_GET
#define TX_CTLr_TX_L4_IP_ADDRESS_ENf_SET BCM89500_A0_TX_CTLr_TX_L4_IP_ADDRESS_ENf_SET
#define TX_CTLr_TX_L2_SA_ENf_GET BCM89500_A0_TX_CTLr_TX_L2_SA_ENf_GET
#define TX_CTLr_TX_L2_SA_ENf_SET BCM89500_A0_TX_CTLr_TX_L2_SA_ENf_SET
#define TX_CTLr_TX_AS_SA_ENf_GET BCM89500_A0_TX_CTLr_TX_AS_SA_ENf_GET
#define TX_CTLr_TX_AS_SA_ENf_SET BCM89500_A0_TX_CTLr_TX_AS_SA_ENf_SET
#define TX_CTLr_RESERVEDf_GET BCM89500_A0_TX_CTLr_RESERVEDf_GET
#define TX_CTLr_RESERVEDf_SET BCM89500_A0_TX_CTLr_RESERVEDf_SET
#define READ_TX_CTLr BCM89500_A0_READ_TX_CTLr
#define WRITE_TX_CTLr BCM89500_A0_WRITE_TX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_MODE_PORT
 * BLOCKS:   SYS
 * DESC:     Port N TX Event Message Mode1 Selection Registers
 * SIZE:     16
 * FIELDS:
 *     TX_MODE1_M0      TX Port mode selection -- event message 0Example:{bit1, bit0}2'b00: event 0 message - NA2'b01: event 0 message - update correction field2'b10: event 0 message - replace correction field and origin timestamp field, original timestamp would be replaced by 80bits original time code registers at page 0x93, offset 0x88-0x91.2'b11: event 0 message - replace origin timestamp field by 80bits local updated time code.
 *     TX_MODE1_M1      TX Port mode selection -- event message 1
 *     TX_MODE1_M2      TX Port mode selection -- event message 2
 *     TX_MODE1_M3      TX Port mode selection -- event message 3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_MODE_PORTr 0x00009302

#define BCM89500_A0_TX_MODE_PORTr_SIZE 2

/*
 * This structure should be used to declare and program TX_MODE_PORT.
 *
 */
typedef union BCM89500_A0_TX_MODE_PORTr_s {
	uint32_t v[1];
	uint32_t tx_mode_port[1];
	uint32_t _tx_mode_port;
} BCM89500_A0_TX_MODE_PORTr_t;

#define BCM89500_A0_TX_MODE_PORTr_CLR(r) (r).tx_mode_port[0] = 0
#define BCM89500_A0_TX_MODE_PORTr_SET(r,d) (r).tx_mode_port[0] = d
#define BCM89500_A0_TX_MODE_PORTr_GET(r) (r).tx_mode_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M0f_GET(r) (((r).tx_mode_port[0]) & 0x3)
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M0f_SET(r,f) (r).tx_mode_port[0]=(((r).tx_mode_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M1f_GET(r) ((((r).tx_mode_port[0]) >> 2) & 0x3)
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M1f_SET(r,f) (r).tx_mode_port[0]=(((r).tx_mode_port[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M2f_GET(r) ((((r).tx_mode_port[0]) >> 4) & 0x3)
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M2f_SET(r,f) (r).tx_mode_port[0]=(((r).tx_mode_port[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M3f_GET(r) ((((r).tx_mode_port[0]) >> 6) & 0x3)
#define BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M3f_SET(r,f) (r).tx_mode_port[0]=(((r).tx_mode_port[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_TX_MODE_PORTr_RESERVEDf_GET(r) ((((r).tx_mode_port[0]) >> 8) & 0xff)
#define BCM89500_A0_TX_MODE_PORTr_RESERVEDf_SET(r,f) (r).tx_mode_port[0]=(((r).tx_mode_port[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TX_MODE_PORT.
 *
 */
#define BCM89500_A0_READ_TX_MODE_PORTr(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_TX_MODE_PORTr+(2*(i)),(r._tx_mode_port),2)
#define BCM89500_A0_WRITE_TX_MODE_PORTr(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_TX_MODE_PORTr+(2*(i)),&(r._tx_mode_port),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_MODE_PORTr BCM89500_A0_TX_MODE_PORTr
#define TX_MODE_PORTr_SIZE BCM89500_A0_TX_MODE_PORTr_SIZE
typedef BCM89500_A0_TX_MODE_PORTr_t TX_MODE_PORTr_t;
#define TX_MODE_PORTr_CLR BCM89500_A0_TX_MODE_PORTr_CLR
#define TX_MODE_PORTr_SET BCM89500_A0_TX_MODE_PORTr_SET
#define TX_MODE_PORTr_GET BCM89500_A0_TX_MODE_PORTr_GET
#define TX_MODE_PORTr_TX_MODE1_M0f_GET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M0f_GET
#define TX_MODE_PORTr_TX_MODE1_M0f_SET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M0f_SET
#define TX_MODE_PORTr_TX_MODE1_M1f_GET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M1f_GET
#define TX_MODE_PORTr_TX_MODE1_M1f_SET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M1f_SET
#define TX_MODE_PORTr_TX_MODE1_M2f_GET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M2f_GET
#define TX_MODE_PORTr_TX_MODE1_M2f_SET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M2f_SET
#define TX_MODE_PORTr_TX_MODE1_M3f_GET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M3f_GET
#define TX_MODE_PORTr_TX_MODE1_M3f_SET BCM89500_A0_TX_MODE_PORTr_TX_MODE1_M3f_SET
#define TX_MODE_PORTr_RESERVEDf_GET BCM89500_A0_TX_MODE_PORTr_RESERVEDf_GET
#define TX_MODE_PORTr_RESERVEDf_SET BCM89500_A0_TX_MODE_PORTr_RESERVEDf_SET
#define READ_TX_MODE_PORTr BCM89500_A0_READ_TX_MODE_PORTr
#define WRITE_TX_MODE_PORTr BCM89500_A0_WRITE_TX_MODE_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_MODE_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_MODE_PORT_IMP
 * BLOCKS:   SYS
 * DESC:     Port 8 TX Event Message Mode1 Selection Registers
 * SIZE:     16
 * FIELDS:
 *     TX_MODE1_M0      TX Port mode selection -- event message 0Example:{bit1, bit0}2'b00: event 0 message - NA2'b01: event 0 message - update correction field2'b10: event 0 message - replace correction field and origin timestamp field, original timestamp would be replaced by 80bits original time code registers at page 0x93, offset 0x88-0x91.2'b11: event 0 message - replace origin timestamp field by 80bits local updated time code.
 *     TX_MODE1_M1      TX Port mode selection -- event message 1
 *     TX_MODE1_M2      TX Port mode selection -- event message 2
 *     TX_MODE1_M3      TX Port mode selection -- event message 3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_MODE_PORT_IMPr 0x00009310

#define BCM89500_A0_TX_MODE_PORT_IMPr_SIZE 2

/*
 * This structure should be used to declare and program TX_MODE_PORT_IMP.
 *
 */
typedef union BCM89500_A0_TX_MODE_PORT_IMPr_s {
	uint32_t v[1];
	uint32_t tx_mode_port_imp[1];
	uint32_t _tx_mode_port_imp;
} BCM89500_A0_TX_MODE_PORT_IMPr_t;

#define BCM89500_A0_TX_MODE_PORT_IMPr_CLR(r) (r).tx_mode_port_imp[0] = 0
#define BCM89500_A0_TX_MODE_PORT_IMPr_SET(r,d) (r).tx_mode_port_imp[0] = d
#define BCM89500_A0_TX_MODE_PORT_IMPr_GET(r) (r).tx_mode_port_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M0f_GET(r) (((r).tx_mode_port_imp[0]) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M0f_SET(r,f) (r).tx_mode_port_imp[0]=(((r).tx_mode_port_imp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M1f_GET(r) ((((r).tx_mode_port_imp[0]) >> 2) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M1f_SET(r,f) (r).tx_mode_port_imp[0]=(((r).tx_mode_port_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M2f_GET(r) ((((r).tx_mode_port_imp[0]) >> 4) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M2f_SET(r,f) (r).tx_mode_port_imp[0]=(((r).tx_mode_port_imp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M3f_GET(r) ((((r).tx_mode_port_imp[0]) >> 6) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M3f_SET(r,f) (r).tx_mode_port_imp[0]=(((r).tx_mode_port_imp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_TX_MODE_PORT_IMPr_RESERVEDf_GET(r) ((((r).tx_mode_port_imp[0]) >> 8) & 0xff)
#define BCM89500_A0_TX_MODE_PORT_IMPr_RESERVEDf_SET(r,f) (r).tx_mode_port_imp[0]=(((r).tx_mode_port_imp[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TX_MODE_PORT_IMP.
 *
 */
#define BCM89500_A0_READ_TX_MODE_PORT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_MODE_PORT_IMPr,(r._tx_mode_port_imp),2)
#define BCM89500_A0_WRITE_TX_MODE_PORT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_MODE_PORT_IMPr,&(r._tx_mode_port_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_MODE_PORT_IMPr BCM89500_A0_TX_MODE_PORT_IMPr
#define TX_MODE_PORT_IMPr_SIZE BCM89500_A0_TX_MODE_PORT_IMPr_SIZE
typedef BCM89500_A0_TX_MODE_PORT_IMPr_t TX_MODE_PORT_IMPr_t;
#define TX_MODE_PORT_IMPr_CLR BCM89500_A0_TX_MODE_PORT_IMPr_CLR
#define TX_MODE_PORT_IMPr_SET BCM89500_A0_TX_MODE_PORT_IMPr_SET
#define TX_MODE_PORT_IMPr_GET BCM89500_A0_TX_MODE_PORT_IMPr_GET
#define TX_MODE_PORT_IMPr_TX_MODE1_M0f_GET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M0f_GET
#define TX_MODE_PORT_IMPr_TX_MODE1_M0f_SET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M0f_SET
#define TX_MODE_PORT_IMPr_TX_MODE1_M1f_GET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M1f_GET
#define TX_MODE_PORT_IMPr_TX_MODE1_M1f_SET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M1f_SET
#define TX_MODE_PORT_IMPr_TX_MODE1_M2f_GET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M2f_GET
#define TX_MODE_PORT_IMPr_TX_MODE1_M2f_SET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M2f_SET
#define TX_MODE_PORT_IMPr_TX_MODE1_M3f_GET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M3f_GET
#define TX_MODE_PORT_IMPr_TX_MODE1_M3f_SET BCM89500_A0_TX_MODE_PORT_IMPr_TX_MODE1_M3f_SET
#define TX_MODE_PORT_IMPr_RESERVEDf_GET BCM89500_A0_TX_MODE_PORT_IMPr_RESERVEDf_GET
#define TX_MODE_PORT_IMPr_RESERVEDf_SET BCM89500_A0_TX_MODE_PORT_IMPr_RESERVEDf_SET
#define READ_TX_MODE_PORT_IMPr BCM89500_A0_READ_TX_MODE_PORT_IMPr
#define WRITE_TX_MODE_PORT_IMPr BCM89500_A0_WRITE_TX_MODE_PORT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_MODE_PORT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_MODE_PORT_P7
 * BLOCKS:   SYS
 * DESC:     Port 7 TX Event Message Mode1 Selection Registers
 * SIZE:     16
 * FIELDS:
 *     TX_MODE1_M0      TX Port mode selection -- event message 0Example:{bit1, bit0}2'b00: event 0 message - NA2'b01: event 0 message - update correction field2'b10: event 0 message - replace correction field and origin timestamp field, original timestamp would be replaced by 80bits original time code registers at page 0x93, offset 0x88-0x91.2'b11: event 0 message - replace origin timestamp field by 80bits local updated time code.
 *     TX_MODE1_M1      TX Port mode selection -- event message 1
 *     TX_MODE1_M2      TX Port mode selection -- event message 2
 *     TX_MODE1_M3      TX Port mode selection -- event message 3
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_MODE_PORT_P7r 0x0000930e

#define BCM89500_A0_TX_MODE_PORT_P7r_SIZE 2

/*
 * This structure should be used to declare and program TX_MODE_PORT_P7.
 *
 */
typedef union BCM89500_A0_TX_MODE_PORT_P7r_s {
	uint32_t v[1];
	uint32_t tx_mode_port_p7[1];
	uint32_t _tx_mode_port_p7;
} BCM89500_A0_TX_MODE_PORT_P7r_t;

#define BCM89500_A0_TX_MODE_PORT_P7r_CLR(r) (r).tx_mode_port_p7[0] = 0
#define BCM89500_A0_TX_MODE_PORT_P7r_SET(r,d) (r).tx_mode_port_p7[0] = d
#define BCM89500_A0_TX_MODE_PORT_P7r_GET(r) (r).tx_mode_port_p7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M0f_GET(r) (((r).tx_mode_port_p7[0]) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M0f_SET(r,f) (r).tx_mode_port_p7[0]=(((r).tx_mode_port_p7[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M1f_GET(r) ((((r).tx_mode_port_p7[0]) >> 2) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M1f_SET(r,f) (r).tx_mode_port_p7[0]=(((r).tx_mode_port_p7[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M2f_GET(r) ((((r).tx_mode_port_p7[0]) >> 4) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M2f_SET(r,f) (r).tx_mode_port_p7[0]=(((r).tx_mode_port_p7[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M3f_GET(r) ((((r).tx_mode_port_p7[0]) >> 6) & 0x3)
#define BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M3f_SET(r,f) (r).tx_mode_port_p7[0]=(((r).tx_mode_port_p7[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM89500_A0_TX_MODE_PORT_P7r_RESERVEDf_GET(r) ((((r).tx_mode_port_p7[0]) >> 8) & 0xff)
#define BCM89500_A0_TX_MODE_PORT_P7r_RESERVEDf_SET(r,f) (r).tx_mode_port_p7[0]=(((r).tx_mode_port_p7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TX_MODE_PORT_P7.
 *
 */
#define BCM89500_A0_READ_TX_MODE_PORT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_MODE_PORT_P7r,(r._tx_mode_port_p7),2)
#define BCM89500_A0_WRITE_TX_MODE_PORT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_MODE_PORT_P7r,&(r._tx_mode_port_p7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_MODE_PORT_P7r BCM89500_A0_TX_MODE_PORT_P7r
#define TX_MODE_PORT_P7r_SIZE BCM89500_A0_TX_MODE_PORT_P7r_SIZE
typedef BCM89500_A0_TX_MODE_PORT_P7r_t TX_MODE_PORT_P7r_t;
#define TX_MODE_PORT_P7r_CLR BCM89500_A0_TX_MODE_PORT_P7r_CLR
#define TX_MODE_PORT_P7r_SET BCM89500_A0_TX_MODE_PORT_P7r_SET
#define TX_MODE_PORT_P7r_GET BCM89500_A0_TX_MODE_PORT_P7r_GET
#define TX_MODE_PORT_P7r_TX_MODE1_M0f_GET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M0f_GET
#define TX_MODE_PORT_P7r_TX_MODE1_M0f_SET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M0f_SET
#define TX_MODE_PORT_P7r_TX_MODE1_M1f_GET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M1f_GET
#define TX_MODE_PORT_P7r_TX_MODE1_M1f_SET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M1f_SET
#define TX_MODE_PORT_P7r_TX_MODE1_M2f_GET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M2f_GET
#define TX_MODE_PORT_P7r_TX_MODE1_M2f_SET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M2f_SET
#define TX_MODE_PORT_P7r_TX_MODE1_M3f_GET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M3f_GET
#define TX_MODE_PORT_P7r_TX_MODE1_M3f_SET BCM89500_A0_TX_MODE_PORT_P7r_TX_MODE1_M3f_SET
#define TX_MODE_PORT_P7r_RESERVEDf_GET BCM89500_A0_TX_MODE_PORT_P7r_RESERVEDf_GET
#define TX_MODE_PORT_P7r_RESERVEDf_SET BCM89500_A0_TX_MODE_PORT_P7r_RESERVEDf_SET
#define READ_TX_MODE_PORT_P7r BCM89500_A0_READ_TX_MODE_PORT_P7r
#define WRITE_TX_MODE_PORT_P7r BCM89500_A0_WRITE_TX_MODE_PORT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_MODE_PORT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for TX Register
 * SIZE:     16
 * FIELDS:
 *     TX_PAUSE_PASS    TX pause pass through map.bit[8] : Port 8.bit[7] : Port 7.bit[5:0] : Port 5-01 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PAUSE_PASSr 0x0000003a

#define BCM89500_A0_TX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program TX_PAUSE_PASS.
 *
 */
typedef union BCM89500_A0_TX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t tx_pause_pass[1];
	uint32_t _tx_pause_pass;
} BCM89500_A0_TX_PAUSE_PASSr_t;

#define BCM89500_A0_TX_PAUSE_PASSr_CLR(r) (r).tx_pause_pass[0] = 0
#define BCM89500_A0_TX_PAUSE_PASSr_SET(r,d) (r).tx_pause_pass[0] = d
#define BCM89500_A0_TX_PAUSE_PASSr_GET(r) (r).tx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET(r) (((r).tx_pause_pass[0]) & 0x1ff)
#define BCM89500_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_TX_PAUSE_PASSr_RESERVEDf_GET(r) ((((r).tx_pause_pass[0]) >> 9) & 0x7f)
#define BCM89500_A0_TX_PAUSE_PASSr_RESERVEDf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TX_PAUSE_PASS.
 *
 */
#define BCM89500_A0_READ_TX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PAUSE_PASSr,(r._tx_pause_pass),2)
#define BCM89500_A0_WRITE_TX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PAUSE_PASSr,&(r._tx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PAUSE_PASSr BCM89500_A0_TX_PAUSE_PASSr
#define TX_PAUSE_PASSr_SIZE BCM89500_A0_TX_PAUSE_PASSr_SIZE
typedef BCM89500_A0_TX_PAUSE_PASSr_t TX_PAUSE_PASSr_t;
#define TX_PAUSE_PASSr_CLR BCM89500_A0_TX_PAUSE_PASSr_CLR
#define TX_PAUSE_PASSr_SET BCM89500_A0_TX_PAUSE_PASSr_SET
#define TX_PAUSE_PASSr_GET BCM89500_A0_TX_PAUSE_PASSr_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET BCM89500_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET BCM89500_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET
#define TX_PAUSE_PASSr_RESERVEDf_GET BCM89500_A0_TX_PAUSE_PASSr_RESERVEDf_GET
#define TX_PAUSE_PASSr_RESERVEDf_SET BCM89500_A0_TX_PAUSE_PASSr_RESERVEDf_SET
#define READ_TX_PAUSE_PASSr BCM89500_A0_READ_TX_PAUSE_PASSr
#define WRITE_TX_PAUSE_PASSr BCM89500_A0_WRITE_TX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_0_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 0 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr 0x00009368

#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_0_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_0_ts_offset_lsb[1];
	uint32_t _tx_port_0_ts_offset_lsb;
} BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_CLR(r) (r).tx_port_0_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_0_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_GET(r) (r).tx_port_0_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_0_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_0_ts_offset_lsb[0]=(((r).tx_port_0_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_0_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_0_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr,(r._tx_port_0_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_0_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr,&(r._tx_port_0_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_0_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr
#define TX_PORT_0_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_t TX_PORT_0_TS_OFFSET_LSBr_t;
#define TX_PORT_0_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_CLR
#define TX_PORT_0_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_SET
#define TX_PORT_0_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_GET
#define TX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_0_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_0_TS_OFFSET_LSBr
#define WRITE_TX_PORT_0_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_0_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_0_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_0_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 0 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr 0x0000936a

#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_0_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_0_ts_offset_msb[1];
	uint32_t _tx_port_0_ts_offset_msb;
} BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_CLR(r) (r).tx_port_0_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_0_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_GET(r) (r).tx_port_0_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_0_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_0_ts_offset_msb[0]=(((r).tx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_0_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_0_ts_offset_msb[0]=(((r).tx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_0_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_0_ts_offset_msb[0]=(((r).tx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_0_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_0_ts_offset_msb[0]=(((r).tx_port_0_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_0_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_0_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr,(r._tx_port_0_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_0_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr,&(r._tx_port_0_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_0_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr
#define TX_PORT_0_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_t TX_PORT_0_TS_OFFSET_MSBr_t;
#define TX_PORT_0_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_CLR
#define TX_PORT_0_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_SET
#define TX_PORT_0_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_GET
#define TX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_0_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_0_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_0_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_0_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_0_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_0_TS_OFFSET_MSBr
#define WRITE_TX_PORT_0_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_0_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_0_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_1_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 1 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr 0x0000936c

#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_1_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_1_ts_offset_lsb[1];
	uint32_t _tx_port_1_ts_offset_lsb;
} BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_CLR(r) (r).tx_port_1_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_1_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_GET(r) (r).tx_port_1_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_1_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_1_ts_offset_lsb[0]=(((r).tx_port_1_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_1_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_1_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr,(r._tx_port_1_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_1_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr,&(r._tx_port_1_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_1_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr
#define TX_PORT_1_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_t TX_PORT_1_TS_OFFSET_LSBr_t;
#define TX_PORT_1_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_CLR
#define TX_PORT_1_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_SET
#define TX_PORT_1_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_GET
#define TX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_1_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_1_TS_OFFSET_LSBr
#define WRITE_TX_PORT_1_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_1_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_1_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_1_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 1 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr 0x0000936e

#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_1_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_1_ts_offset_msb[1];
	uint32_t _tx_port_1_ts_offset_msb;
} BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_CLR(r) (r).tx_port_1_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_1_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_GET(r) (r).tx_port_1_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_1_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_1_ts_offset_msb[0]=(((r).tx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_1_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_1_ts_offset_msb[0]=(((r).tx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_1_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_1_ts_offset_msb[0]=(((r).tx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_1_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_1_ts_offset_msb[0]=(((r).tx_port_1_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_1_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_1_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr,(r._tx_port_1_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_1_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr,&(r._tx_port_1_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_1_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr
#define TX_PORT_1_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_t TX_PORT_1_TS_OFFSET_MSBr_t;
#define TX_PORT_1_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_CLR
#define TX_PORT_1_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_SET
#define TX_PORT_1_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_GET
#define TX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_1_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_1_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_1_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_1_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_1_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_1_TS_OFFSET_MSBr
#define WRITE_TX_PORT_1_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_1_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_1_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_2_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 2 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr 0x00009370

#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_2_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_2_ts_offset_lsb[1];
	uint32_t _tx_port_2_ts_offset_lsb;
} BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_CLR(r) (r).tx_port_2_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_2_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_GET(r) (r).tx_port_2_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_2_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_2_ts_offset_lsb[0]=(((r).tx_port_2_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_2_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_2_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr,(r._tx_port_2_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_2_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr,&(r._tx_port_2_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_2_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr
#define TX_PORT_2_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_t TX_PORT_2_TS_OFFSET_LSBr_t;
#define TX_PORT_2_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_CLR
#define TX_PORT_2_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_SET
#define TX_PORT_2_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_GET
#define TX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_2_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_2_TS_OFFSET_LSBr
#define WRITE_TX_PORT_2_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_2_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_2_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_2_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 2 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr 0x00009372

#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_2_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_2_ts_offset_msb[1];
	uint32_t _tx_port_2_ts_offset_msb;
} BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_CLR(r) (r).tx_port_2_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_2_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_GET(r) (r).tx_port_2_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_2_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_2_ts_offset_msb[0]=(((r).tx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_2_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_2_ts_offset_msb[0]=(((r).tx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_2_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_2_ts_offset_msb[0]=(((r).tx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_2_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_2_ts_offset_msb[0]=(((r).tx_port_2_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_2_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_2_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr,(r._tx_port_2_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_2_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr,&(r._tx_port_2_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_2_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr
#define TX_PORT_2_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_t TX_PORT_2_TS_OFFSET_MSBr_t;
#define TX_PORT_2_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_CLR
#define TX_PORT_2_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_SET
#define TX_PORT_2_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_GET
#define TX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_2_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_2_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_2_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_2_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_2_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_2_TS_OFFSET_MSBr
#define WRITE_TX_PORT_2_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_2_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_2_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_3_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 3 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr 0x00009374

#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_3_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_3_ts_offset_lsb[1];
	uint32_t _tx_port_3_ts_offset_lsb;
} BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_CLR(r) (r).tx_port_3_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_3_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_GET(r) (r).tx_port_3_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_3_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_3_ts_offset_lsb[0]=(((r).tx_port_3_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_3_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_3_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr,(r._tx_port_3_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_3_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr,&(r._tx_port_3_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_3_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr
#define TX_PORT_3_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_t TX_PORT_3_TS_OFFSET_LSBr_t;
#define TX_PORT_3_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_CLR
#define TX_PORT_3_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_SET
#define TX_PORT_3_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_GET
#define TX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_3_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_3_TS_OFFSET_LSBr
#define WRITE_TX_PORT_3_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_3_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_3_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_3_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 3 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr 0x00009376

#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_3_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_3_ts_offset_msb[1];
	uint32_t _tx_port_3_ts_offset_msb;
} BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_CLR(r) (r).tx_port_3_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_3_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_GET(r) (r).tx_port_3_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_3_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_3_ts_offset_msb[0]=(((r).tx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_3_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_3_ts_offset_msb[0]=(((r).tx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_3_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_3_ts_offset_msb[0]=(((r).tx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_3_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_3_ts_offset_msb[0]=(((r).tx_port_3_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_3_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_3_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr,(r._tx_port_3_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_3_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr,&(r._tx_port_3_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_3_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr
#define TX_PORT_3_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_t TX_PORT_3_TS_OFFSET_MSBr_t;
#define TX_PORT_3_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_CLR
#define TX_PORT_3_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_SET
#define TX_PORT_3_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_GET
#define TX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_3_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_3_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_3_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_3_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_3_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_3_TS_OFFSET_MSBr
#define WRITE_TX_PORT_3_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_3_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_3_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_4_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 4 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr 0x00009378

#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_4_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_4_ts_offset_lsb[1];
	uint32_t _tx_port_4_ts_offset_lsb;
} BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_CLR(r) (r).tx_port_4_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_4_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_GET(r) (r).tx_port_4_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_4_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_4_ts_offset_lsb[0]=(((r).tx_port_4_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_4_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_4_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr,(r._tx_port_4_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_4_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr,&(r._tx_port_4_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_4_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr
#define TX_PORT_4_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_t TX_PORT_4_TS_OFFSET_LSBr_t;
#define TX_PORT_4_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_CLR
#define TX_PORT_4_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_SET
#define TX_PORT_4_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_GET
#define TX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_4_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_4_TS_OFFSET_LSBr
#define WRITE_TX_PORT_4_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_4_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_4_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_4_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 4 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr 0x0000937a

#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_4_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_4_ts_offset_msb[1];
	uint32_t _tx_port_4_ts_offset_msb;
} BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_CLR(r) (r).tx_port_4_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_4_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_GET(r) (r).tx_port_4_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_4_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_4_ts_offset_msb[0]=(((r).tx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_4_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_4_ts_offset_msb[0]=(((r).tx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_4_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_4_ts_offset_msb[0]=(((r).tx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_4_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_4_ts_offset_msb[0]=(((r).tx_port_4_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_4_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_4_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr,(r._tx_port_4_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_4_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr,&(r._tx_port_4_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_4_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr
#define TX_PORT_4_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_t TX_PORT_4_TS_OFFSET_MSBr_t;
#define TX_PORT_4_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_CLR
#define TX_PORT_4_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_SET
#define TX_PORT_4_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_GET
#define TX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_4_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_4_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_4_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_4_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_4_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_4_TS_OFFSET_MSBr
#define WRITE_TX_PORT_4_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_4_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_4_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_5_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 5 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr 0x0000937c

#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_5_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_5_ts_offset_lsb[1];
	uint32_t _tx_port_5_ts_offset_lsb;
} BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_CLR(r) (r).tx_port_5_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_5_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_GET(r) (r).tx_port_5_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_5_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_5_ts_offset_lsb[0]=(((r).tx_port_5_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_5_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_5_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr,(r._tx_port_5_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_5_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr,&(r._tx_port_5_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_5_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr
#define TX_PORT_5_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_t TX_PORT_5_TS_OFFSET_LSBr_t;
#define TX_PORT_5_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_CLR
#define TX_PORT_5_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_SET
#define TX_PORT_5_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_GET
#define TX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_5_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_5_TS_OFFSET_LSBr
#define WRITE_TX_PORT_5_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_5_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_5_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_5_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 5 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr 0x0000937e

#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_5_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_5_ts_offset_msb[1];
	uint32_t _tx_port_5_ts_offset_msb;
} BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_CLR(r) (r).tx_port_5_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_5_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_GET(r) (r).tx_port_5_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_5_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_5_ts_offset_msb[0]=(((r).tx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_5_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_5_ts_offset_msb[0]=(((r).tx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_5_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_5_ts_offset_msb[0]=(((r).tx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_5_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_5_ts_offset_msb[0]=(((r).tx_port_5_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_5_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_5_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr,(r._tx_port_5_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_5_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr,&(r._tx_port_5_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_5_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr
#define TX_PORT_5_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_t TX_PORT_5_TS_OFFSET_MSBr_t;
#define TX_PORT_5_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_CLR
#define TX_PORT_5_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_SET
#define TX_PORT_5_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_GET
#define TX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_5_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_5_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_5_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_5_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_5_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_5_TS_OFFSET_MSBr
#define WRITE_TX_PORT_5_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_5_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_5_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_7_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 7 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr 0x00009380

#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_7_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_7_ts_offset_lsb[1];
	uint32_t _tx_port_7_ts_offset_lsb;
} BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_CLR(r) (r).tx_port_7_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_7_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_GET(r) (r).tx_port_7_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_7_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_7_ts_offset_lsb[0]=(((r).tx_port_7_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_7_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_7_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr,(r._tx_port_7_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_7_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr,&(r._tx_port_7_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_7_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr
#define TX_PORT_7_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_t TX_PORT_7_TS_OFFSET_LSBr_t;
#define TX_PORT_7_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_CLR
#define TX_PORT_7_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_SET
#define TX_PORT_7_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_GET
#define TX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_7_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_7_TS_OFFSET_LSBr
#define WRITE_TX_PORT_7_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_7_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_7_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_7_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 7 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr 0x00009382

#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_7_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_7_ts_offset_msb[1];
	uint32_t _tx_port_7_ts_offset_msb;
} BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_CLR(r) (r).tx_port_7_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_7_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_GET(r) (r).tx_port_7_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_7_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_7_ts_offset_msb[0]=(((r).tx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_7_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_7_ts_offset_msb[0]=(((r).tx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_7_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_7_ts_offset_msb[0]=(((r).tx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_7_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_7_ts_offset_msb[0]=(((r).tx_port_7_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_7_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_7_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr,(r._tx_port_7_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_7_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr,&(r._tx_port_7_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_7_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr
#define TX_PORT_7_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_t TX_PORT_7_TS_OFFSET_MSBr_t;
#define TX_PORT_7_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_CLR
#define TX_PORT_7_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_SET
#define TX_PORT_7_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_GET
#define TX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_7_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_7_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_7_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_7_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_7_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_7_TS_OFFSET_MSBr
#define WRITE_TX_PORT_7_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_7_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_7_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_8_TS_OFFSET_LSB
 * BLOCKS:   SYS
 * DESC:     Port 8 TX Timestamp Offset LSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_LSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr 0x00009384

#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_8_TS_OFFSET_LSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_s {
	uint32_t v[1];
	uint32_t tx_port_8_ts_offset_lsb[1];
	uint32_t _tx_port_8_ts_offset_lsb;
} BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_t;

#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_CLR(r) (r).tx_port_8_ts_offset_lsb[0] = 0
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_SET(r,d) (r).tx_port_8_ts_offset_lsb[0] = d
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_GET(r) (r).tx_port_8_ts_offset_lsb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET(r) (((r).tx_port_8_ts_offset_lsb[0]) & 0xffff)
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET(r,f) (r).tx_port_8_ts_offset_lsb[0]=(((r).tx_port_8_ts_offset_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_PORT_8_TS_OFFSET_LSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_8_TS_OFFSET_LSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr,(r._tx_port_8_ts_offset_lsb),2)
#define BCM89500_A0_WRITE_TX_PORT_8_TS_OFFSET_LSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr,&(r._tx_port_8_ts_offset_lsb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_8_TS_OFFSET_LSBr BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr
#define TX_PORT_8_TS_OFFSET_LSBr_SIZE BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_SIZE
typedef BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_t TX_PORT_8_TS_OFFSET_LSBr_t;
#define TX_PORT_8_TS_OFFSET_LSBr_CLR BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_CLR
#define TX_PORT_8_TS_OFFSET_LSBr_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_SET
#define TX_PORT_8_TS_OFFSET_LSBr_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_GET
#define TX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_GET
#define TX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr_TS_OFFSET_TX_LSBf_SET
#define READ_TX_PORT_8_TS_OFFSET_LSBr BCM89500_A0_READ_TX_PORT_8_TS_OFFSET_LSBr
#define WRITE_TX_PORT_8_TS_OFFSET_LSBr BCM89500_A0_WRITE_TX_PORT_8_TS_OFFSET_LSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_8_TS_OFFSET_LSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_PORT_8_TS_OFFSET_MSB
 * BLOCKS:   SYS
 * DESC:     Port 8 TX Timestamp Offset MSB Registers
 * SIZE:     16
 * FIELDS:
 *     TS_OFFSET_TX_MSB Port TX timestamp offset register, the unit is signed ns.This register compensates the delay of analog front end orMACSEC and EEE buffer delay.The final port TX timestamp =NCO timestamp + {TS_OFFSET_TX_MSB, TS_OFFSET_TX_LSB}
 *     TS_LD            TS_LD Port RX timestamp event message link delay.bit[7] Normal mode event message 3 Link Delay enablebit[6] Normal mode event message 2 Link Delay enablebit[5] Normal mode event message 1 Link Delay enablebit[4] Normal mode event message 0 Link Delay enable
 *     TS_CAP           TS_CAP Port RX timestamp event message capture.bit[11] Normal mode event message 3 capture TS enablebit[10] Normal mode event message 2 capture TS enablebit[9]  Normal mode event message 1 capture TS enablebit[8]  Normal mode event message 0 capture TS enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr 0x00009386

#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_SIZE 2

/*
 * This structure should be used to declare and program TX_PORT_8_TS_OFFSET_MSB.
 *
 */
typedef union BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_s {
	uint32_t v[1];
	uint32_t tx_port_8_ts_offset_msb[1];
	uint32_t _tx_port_8_ts_offset_msb;
} BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_t;

#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_CLR(r) (r).tx_port_8_ts_offset_msb[0] = 0
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_SET(r,d) (r).tx_port_8_ts_offset_msb[0] = d
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_GET(r) (r).tx_port_8_ts_offset_msb[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET(r) (((r).tx_port_8_ts_offset_msb[0]) & 0xf)
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET(r,f) (r).tx_port_8_ts_offset_msb[0]=(((r).tx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_LDf_GET(r) ((((r).tx_port_8_ts_offset_msb[0]) >> 4) & 0xf)
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_LDf_SET(r,f) (r).tx_port_8_ts_offset_msb[0]=(((r).tx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_GET(r) ((((r).tx_port_8_ts_offset_msb[0]) >> 8) & 0xf)
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_SET(r,f) (r).tx_port_8_ts_offset_msb[0]=(((r).tx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_RESERVEDf_GET(r) ((((r).tx_port_8_ts_offset_msb[0]) >> 12) & 0xf)
#define BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_RESERVEDf_SET(r,f) (r).tx_port_8_ts_offset_msb[0]=(((r).tx_port_8_ts_offset_msb[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access TX_PORT_8_TS_OFFSET_MSB.
 *
 */
#define BCM89500_A0_READ_TX_PORT_8_TS_OFFSET_MSBr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr,(r._tx_port_8_ts_offset_msb),2)
#define BCM89500_A0_WRITE_TX_PORT_8_TS_OFFSET_MSBr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr,&(r._tx_port_8_ts_offset_msb),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PORT_8_TS_OFFSET_MSBr BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr
#define TX_PORT_8_TS_OFFSET_MSBr_SIZE BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_SIZE
typedef BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_t TX_PORT_8_TS_OFFSET_MSBr_t;
#define TX_PORT_8_TS_OFFSET_MSBr_CLR BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_CLR
#define TX_PORT_8_TS_OFFSET_MSBr_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_SET
#define TX_PORT_8_TS_OFFSET_MSBr_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_GET
#define TX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_GET
#define TX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_OFFSET_TX_MSBf_SET
#define TX_PORT_8_TS_OFFSET_MSBr_TS_LDf_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_LDf_GET
#define TX_PORT_8_TS_OFFSET_MSBr_TS_LDf_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_LDf_SET
#define TX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_GET
#define TX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_TS_CAPf_SET
#define TX_PORT_8_TS_OFFSET_MSBr_RESERVEDf_GET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_RESERVEDf_GET
#define TX_PORT_8_TS_OFFSET_MSBr_RESERVEDf_SET BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr_RESERVEDf_SET
#define READ_TX_PORT_8_TS_OFFSET_MSBr BCM89500_A0_READ_TX_PORT_8_TS_OFFSET_MSBr
#define WRITE_TX_PORT_8_TS_OFFSET_MSBr BCM89500_A0_WRITE_TX_PORT_8_TS_OFFSET_MSBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_PORT_8_TS_OFFSET_MSBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TX_TS_CAP
 * BLOCKS:   SYS
 * DESC:     TX SOP Timestamp Capture Enable Registers
 * SIZE:     16
 * FIELDS:
 *     TX_TS_CAP        Individual bits enable the timestamp capture of the appopriate TX portbit 7 -- enable TX port 8bit 6 -- enable TX port 7bit 5 -- enable TX port 5bit 4 -- enable TX port 4bit 3 -- enable TX port 3bit 2 -- enable TX port 2bit 1 -- enable TX port 1bit 0 -- enable TX port 0
 *     TX_CS_DIS        Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_TX_TS_CAPr 0x00009322

#define BCM89500_A0_TX_TS_CAPr_SIZE 2

/*
 * This structure should be used to declare and program TX_TS_CAP.
 *
 */
typedef union BCM89500_A0_TX_TS_CAPr_s {
	uint32_t v[1];
	uint32_t tx_ts_cap[1];
	uint32_t _tx_ts_cap;
} BCM89500_A0_TX_TS_CAPr_t;

#define BCM89500_A0_TX_TS_CAPr_CLR(r) (r).tx_ts_cap[0] = 0
#define BCM89500_A0_TX_TS_CAPr_SET(r,d) (r).tx_ts_cap[0] = d
#define BCM89500_A0_TX_TS_CAPr_GET(r) (r).tx_ts_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_TX_TS_CAPr_TX_TS_CAPf_GET(r) (((r).tx_ts_cap[0]) & 0xff)
#define BCM89500_A0_TX_TS_CAPr_TX_TS_CAPf_SET(r,f) (r).tx_ts_cap[0]=(((r).tx_ts_cap[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_TX_TS_CAPr_TX_CS_DISf_GET(r) ((((r).tx_ts_cap[0]) >> 8) & 0xff)
#define BCM89500_A0_TX_TS_CAPr_TX_CS_DISf_SET(r,f) (r).tx_ts_cap[0]=(((r).tx_ts_cap[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TX_TS_CAP.
 *
 */
#define BCM89500_A0_READ_TX_TS_CAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TX_TS_CAPr,(r._tx_ts_cap),2)
#define BCM89500_A0_WRITE_TX_TS_CAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TX_TS_CAPr,&(r._tx_ts_cap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_TS_CAPr BCM89500_A0_TX_TS_CAPr
#define TX_TS_CAPr_SIZE BCM89500_A0_TX_TS_CAPr_SIZE
typedef BCM89500_A0_TX_TS_CAPr_t TX_TS_CAPr_t;
#define TX_TS_CAPr_CLR BCM89500_A0_TX_TS_CAPr_CLR
#define TX_TS_CAPr_SET BCM89500_A0_TX_TS_CAPr_SET
#define TX_TS_CAPr_GET BCM89500_A0_TX_TS_CAPr_GET
#define TX_TS_CAPr_TX_TS_CAPf_GET BCM89500_A0_TX_TS_CAPr_TX_TS_CAPf_GET
#define TX_TS_CAPr_TX_TS_CAPf_SET BCM89500_A0_TX_TS_CAPr_TX_TS_CAPf_SET
#define TX_TS_CAPr_TX_CS_DISf_GET BCM89500_A0_TX_TS_CAPr_TX_CS_DISf_GET
#define TX_TS_CAPr_TX_CS_DISf_SET BCM89500_A0_TX_TS_CAPr_TX_CS_DISf_SET
#define READ_TX_TS_CAPr BCM89500_A0_READ_TX_TS_CAPr
#define WRITE_TX_TS_CAPr BCM89500_A0_WRITE_TX_TS_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TX_TS_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXBROADCASTPKTSr 0x00002010

#define BCM89500_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 *
 */
typedef union BCM89500_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM89500_A0_TXBROADCASTPKTSr_t;

#define BCM89500_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM89500_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM89500_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 *
 */
#define BCM89500_A0_READ_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM89500_A0_WRITE_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM89500_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM89500_A0_TXBROADCASTPKTSr_SIZE
typedef BCM89500_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM89500_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM89500_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM89500_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM89500_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM89500_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxBroadcastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXBROADCASTPKTS_IMPr 0x00002810

#define BCM89500_A0_TXBROADCASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts_IMP.
 *
 */
typedef union BCM89500_A0_TXBROADCASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts_imp[1];
	uint32_t _txbroadcastpkts_imp;
} BCM89500_A0_TXBROADCASTPKTS_IMPr_t;

#define BCM89500_A0_TXBROADCASTPKTS_IMPr_CLR(r) (r).txbroadcastpkts_imp[0] = 0
#define BCM89500_A0_TXBROADCASTPKTS_IMPr_SET(r,d) (r).txbroadcastpkts_imp[0] = d
#define BCM89500_A0_TXBROADCASTPKTS_IMPr_GET(r) (r).txbroadcastpkts_imp[0]


/*
 * These macros can be used to access TxBroadcastPkts_IMP.
 *
 */
#define BCM89500_A0_READ_TXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXBROADCASTPKTS_IMPr,(r._txbroadcastpkts_imp),4)
#define BCM89500_A0_WRITE_TXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXBROADCASTPKTS_IMPr,&(r._txbroadcastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTS_IMPr BCM89500_A0_TXBROADCASTPKTS_IMPr
#define TXBROADCASTPKTS_IMPr_SIZE BCM89500_A0_TXBROADCASTPKTS_IMPr_SIZE
typedef BCM89500_A0_TXBROADCASTPKTS_IMPr_t TXBROADCASTPKTS_IMPr_t;
#define TXBROADCASTPKTS_IMPr_CLR BCM89500_A0_TXBROADCASTPKTS_IMPr_CLR
#define TXBROADCASTPKTS_IMPr_SET BCM89500_A0_TXBROADCASTPKTS_IMPr_SET
#define TXBROADCASTPKTS_IMPr_GET BCM89500_A0_TXBROADCASTPKTS_IMPr_GET
#define READ_TXBROADCASTPKTS_IMPr BCM89500_A0_READ_TXBROADCASTPKTS_IMPr
#define WRITE_TXBROADCASTPKTS_IMPr BCM89500_A0_WRITE_TXBROADCASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXBROADCASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxBroadcastPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXBROADCASTPKTS_P7r 0x00002710

#define BCM89500_A0_TXBROADCASTPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts_P7.
 *
 */
typedef union BCM89500_A0_TXBROADCASTPKTS_P7r_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts_p7[1];
	uint32_t _txbroadcastpkts_p7;
} BCM89500_A0_TXBROADCASTPKTS_P7r_t;

#define BCM89500_A0_TXBROADCASTPKTS_P7r_CLR(r) (r).txbroadcastpkts_p7[0] = 0
#define BCM89500_A0_TXBROADCASTPKTS_P7r_SET(r,d) (r).txbroadcastpkts_p7[0] = d
#define BCM89500_A0_TXBROADCASTPKTS_P7r_GET(r) (r).txbroadcastpkts_p7[0]


/*
 * These macros can be used to access TxBroadcastPkts_P7.
 *
 */
#define BCM89500_A0_READ_TXBROADCASTPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXBROADCASTPKTS_P7r,(r._txbroadcastpkts_p7),4)
#define BCM89500_A0_WRITE_TXBROADCASTPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXBROADCASTPKTS_P7r,&(r._txbroadcastpkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTS_P7r BCM89500_A0_TXBROADCASTPKTS_P7r
#define TXBROADCASTPKTS_P7r_SIZE BCM89500_A0_TXBROADCASTPKTS_P7r_SIZE
typedef BCM89500_A0_TXBROADCASTPKTS_P7r_t TXBROADCASTPKTS_P7r_t;
#define TXBROADCASTPKTS_P7r_CLR BCM89500_A0_TXBROADCASTPKTS_P7r_CLR
#define TXBROADCASTPKTS_P7r_SET BCM89500_A0_TXBROADCASTPKTS_P7r_SET
#define TXBROADCASTPKTS_P7r_GET BCM89500_A0_TXBROADCASTPKTS_P7r_GET
#define READ_TXBROADCASTPKTS_P7r BCM89500_A0_READ_TXBROADCASTPKTS_P7r
#define WRITE_TXBROADCASTPKTS_P7r BCM89500_A0_WRITE_TXBROADCASTPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXBROADCASTPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXCOLLISIONSr 0x0000201c

#define BCM89500_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 *
 */
typedef union BCM89500_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM89500_A0_TXCOLLISIONSr_t;

#define BCM89500_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM89500_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM89500_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 *
 */
#define BCM89500_A0_READ_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM89500_A0_WRITE_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM89500_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM89500_A0_TXCOLLISIONSr_SIZE
typedef BCM89500_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM89500_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM89500_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM89500_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM89500_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM89500_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxCollisions_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXCOLLISIONS_IMPr 0x0000281c

#define BCM89500_A0_TXCOLLISIONS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions_IMP.
 *
 */
typedef union BCM89500_A0_TXCOLLISIONS_IMPr_s {
	uint32_t v[1];
	uint32_t txcollisions_imp[1];
	uint32_t _txcollisions_imp;
} BCM89500_A0_TXCOLLISIONS_IMPr_t;

#define BCM89500_A0_TXCOLLISIONS_IMPr_CLR(r) (r).txcollisions_imp[0] = 0
#define BCM89500_A0_TXCOLLISIONS_IMPr_SET(r,d) (r).txcollisions_imp[0] = d
#define BCM89500_A0_TXCOLLISIONS_IMPr_GET(r) (r).txcollisions_imp[0]


/*
 * These macros can be used to access TxCollisions_IMP.
 *
 */
#define BCM89500_A0_READ_TXCOLLISIONS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXCOLLISIONS_IMPr,(r._txcollisions_imp),4)
#define BCM89500_A0_WRITE_TXCOLLISIONS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXCOLLISIONS_IMPr,&(r._txcollisions_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONS_IMPr BCM89500_A0_TXCOLLISIONS_IMPr
#define TXCOLLISIONS_IMPr_SIZE BCM89500_A0_TXCOLLISIONS_IMPr_SIZE
typedef BCM89500_A0_TXCOLLISIONS_IMPr_t TXCOLLISIONS_IMPr_t;
#define TXCOLLISIONS_IMPr_CLR BCM89500_A0_TXCOLLISIONS_IMPr_CLR
#define TXCOLLISIONS_IMPr_SET BCM89500_A0_TXCOLLISIONS_IMPr_SET
#define TXCOLLISIONS_IMPr_GET BCM89500_A0_TXCOLLISIONS_IMPr_GET
#define READ_TXCOLLISIONS_IMPr BCM89500_A0_READ_TXCOLLISIONS_IMPr
#define WRITE_TXCOLLISIONS_IMPr BCM89500_A0_WRITE_TXCOLLISIONS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXCOLLISIONS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxCollisions_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXCOLLISIONS_P7r 0x0000271c

#define BCM89500_A0_TXCOLLISIONS_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions_P7.
 *
 */
typedef union BCM89500_A0_TXCOLLISIONS_P7r_s {
	uint32_t v[1];
	uint32_t txcollisions_p7[1];
	uint32_t _txcollisions_p7;
} BCM89500_A0_TXCOLLISIONS_P7r_t;

#define BCM89500_A0_TXCOLLISIONS_P7r_CLR(r) (r).txcollisions_p7[0] = 0
#define BCM89500_A0_TXCOLLISIONS_P7r_SET(r,d) (r).txcollisions_p7[0] = d
#define BCM89500_A0_TXCOLLISIONS_P7r_GET(r) (r).txcollisions_p7[0]


/*
 * These macros can be used to access TxCollisions_P7.
 *
 */
#define BCM89500_A0_READ_TXCOLLISIONS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXCOLLISIONS_P7r,(r._txcollisions_p7),4)
#define BCM89500_A0_WRITE_TXCOLLISIONS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXCOLLISIONS_P7r,&(r._txcollisions_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONS_P7r BCM89500_A0_TXCOLLISIONS_P7r
#define TXCOLLISIONS_P7r_SIZE BCM89500_A0_TXCOLLISIONS_P7r_SIZE
typedef BCM89500_A0_TXCOLLISIONS_P7r_t TXCOLLISIONS_P7r_t;
#define TXCOLLISIONS_P7r_CLR BCM89500_A0_TXCOLLISIONS_P7r_CLR
#define TXCOLLISIONS_P7r_SET BCM89500_A0_TXCOLLISIONS_P7r_SET
#define TXCOLLISIONS_P7r_GET BCM89500_A0_TXCOLLISIONS_P7r_GET
#define READ_TXCOLLISIONS_P7r BCM89500_A0_READ_TXCOLLISIONS_P7r
#define WRITE_TXCOLLISIONS_P7r BCM89500_A0_WRITE_TXCOLLISIONS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXCOLLISIONS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXDEFERREDTRANSMITr 0x00002028

#define BCM89500_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 *
 */
typedef union BCM89500_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM89500_A0_TXDEFERREDTRANSMITr_t;

#define BCM89500_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM89500_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM89500_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 *
 */
#define BCM89500_A0_READ_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM89500_A0_WRITE_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM89500_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM89500_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM89500_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM89500_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM89500_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM89500_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM89500_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM89500_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxDeferredTransmit_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXDEFERREDTRANSMIT_IMPr 0x00002828

#define BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit_IMP.
 *
 */
typedef union BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit_imp[1];
	uint32_t _txdeferredtransmit_imp;
} BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_t;

#define BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_CLR(r) (r).txdeferredtransmit_imp[0] = 0
#define BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_SET(r,d) (r).txdeferredtransmit_imp[0] = d
#define BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_GET(r) (r).txdeferredtransmit_imp[0]


/*
 * These macros can be used to access TxDeferredTransmit_IMP.
 *
 */
#define BCM89500_A0_READ_TXDEFERREDTRANSMIT_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXDEFERREDTRANSMIT_IMPr,(r._txdeferredtransmit_imp),4)
#define BCM89500_A0_WRITE_TXDEFERREDTRANSMIT_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXDEFERREDTRANSMIT_IMPr,&(r._txdeferredtransmit_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMIT_IMPr BCM89500_A0_TXDEFERREDTRANSMIT_IMPr
#define TXDEFERREDTRANSMIT_IMPr_SIZE BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_SIZE
typedef BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_t TXDEFERREDTRANSMIT_IMPr_t;
#define TXDEFERREDTRANSMIT_IMPr_CLR BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_CLR
#define TXDEFERREDTRANSMIT_IMPr_SET BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_SET
#define TXDEFERREDTRANSMIT_IMPr_GET BCM89500_A0_TXDEFERREDTRANSMIT_IMPr_GET
#define READ_TXDEFERREDTRANSMIT_IMPr BCM89500_A0_READ_TXDEFERREDTRANSMIT_IMPr
#define WRITE_TXDEFERREDTRANSMIT_IMPr BCM89500_A0_WRITE_TXDEFERREDTRANSMIT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXDEFERREDTRANSMIT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxDeferredTransmit_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXDEFERREDTRANSMIT_P7r 0x00002728

#define BCM89500_A0_TXDEFERREDTRANSMIT_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit_P7.
 *
 */
typedef union BCM89500_A0_TXDEFERREDTRANSMIT_P7r_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit_p7[1];
	uint32_t _txdeferredtransmit_p7;
} BCM89500_A0_TXDEFERREDTRANSMIT_P7r_t;

#define BCM89500_A0_TXDEFERREDTRANSMIT_P7r_CLR(r) (r).txdeferredtransmit_p7[0] = 0
#define BCM89500_A0_TXDEFERREDTRANSMIT_P7r_SET(r,d) (r).txdeferredtransmit_p7[0] = d
#define BCM89500_A0_TXDEFERREDTRANSMIT_P7r_GET(r) (r).txdeferredtransmit_p7[0]


/*
 * These macros can be used to access TxDeferredTransmit_P7.
 *
 */
#define BCM89500_A0_READ_TXDEFERREDTRANSMIT_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXDEFERREDTRANSMIT_P7r,(r._txdeferredtransmit_p7),4)
#define BCM89500_A0_WRITE_TXDEFERREDTRANSMIT_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXDEFERREDTRANSMIT_P7r,&(r._txdeferredtransmit_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMIT_P7r BCM89500_A0_TXDEFERREDTRANSMIT_P7r
#define TXDEFERREDTRANSMIT_P7r_SIZE BCM89500_A0_TXDEFERREDTRANSMIT_P7r_SIZE
typedef BCM89500_A0_TXDEFERREDTRANSMIT_P7r_t TXDEFERREDTRANSMIT_P7r_t;
#define TXDEFERREDTRANSMIT_P7r_CLR BCM89500_A0_TXDEFERREDTRANSMIT_P7r_CLR
#define TXDEFERREDTRANSMIT_P7r_SET BCM89500_A0_TXDEFERREDTRANSMIT_P7r_SET
#define TXDEFERREDTRANSMIT_P7r_GET BCM89500_A0_TXDEFERREDTRANSMIT_P7r_GET
#define READ_TXDEFERREDTRANSMIT_P7r BCM89500_A0_READ_TXDEFERREDTRANSMIT_P7r
#define WRITE_TXDEFERREDTRANSMIT_P7r BCM89500_A0_WRITE_TXDEFERREDTRANSMIT_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXDEFERREDTRANSMIT_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXDROPPKTSr 0x00002008

#define BCM89500_A0_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts.
 *
 */
typedef union BCM89500_A0_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t txdroppkts[1];
	uint32_t _txdroppkts;
} BCM89500_A0_TXDROPPKTSr_t;

#define BCM89500_A0_TXDROPPKTSr_CLR(r) (r).txdroppkts[0] = 0
#define BCM89500_A0_TXDROPPKTSr_SET(r,d) (r).txdroppkts[0] = d
#define BCM89500_A0_TXDROPPKTSr_GET(r) (r).txdroppkts[0]


/*
 * These macros can be used to access TxDropPkts.
 *
 */
#define BCM89500_A0_READ_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXDROPPKTSr,(r._txdroppkts),4)
#define BCM89500_A0_WRITE_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXDROPPKTSr,&(r._txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTSr BCM89500_A0_TXDROPPKTSr
#define TXDROPPKTSr_SIZE BCM89500_A0_TXDROPPKTSr_SIZE
typedef BCM89500_A0_TXDROPPKTSr_t TXDROPPKTSr_t;
#define TXDROPPKTSr_CLR BCM89500_A0_TXDROPPKTSr_CLR
#define TXDROPPKTSr_SET BCM89500_A0_TXDROPPKTSr_SET
#define TXDROPPKTSr_GET BCM89500_A0_TXDROPPKTSr_GET
#define READ_TXDROPPKTSr BCM89500_A0_READ_TXDROPPKTSr
#define WRITE_TXDROPPKTSr BCM89500_A0_WRITE_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxDropPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXDROPPKTS_IMPr 0x00002808

#define BCM89500_A0_TXDROPPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts_IMP.
 *
 */
typedef union BCM89500_A0_TXDROPPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txdroppkts_imp[1];
	uint32_t _txdroppkts_imp;
} BCM89500_A0_TXDROPPKTS_IMPr_t;

#define BCM89500_A0_TXDROPPKTS_IMPr_CLR(r) (r).txdroppkts_imp[0] = 0
#define BCM89500_A0_TXDROPPKTS_IMPr_SET(r,d) (r).txdroppkts_imp[0] = d
#define BCM89500_A0_TXDROPPKTS_IMPr_GET(r) (r).txdroppkts_imp[0]


/*
 * These macros can be used to access TxDropPkts_IMP.
 *
 */
#define BCM89500_A0_READ_TXDROPPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXDROPPKTS_IMPr,(r._txdroppkts_imp),4)
#define BCM89500_A0_WRITE_TXDROPPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXDROPPKTS_IMPr,&(r._txdroppkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTS_IMPr BCM89500_A0_TXDROPPKTS_IMPr
#define TXDROPPKTS_IMPr_SIZE BCM89500_A0_TXDROPPKTS_IMPr_SIZE
typedef BCM89500_A0_TXDROPPKTS_IMPr_t TXDROPPKTS_IMPr_t;
#define TXDROPPKTS_IMPr_CLR BCM89500_A0_TXDROPPKTS_IMPr_CLR
#define TXDROPPKTS_IMPr_SET BCM89500_A0_TXDROPPKTS_IMPr_SET
#define TXDROPPKTS_IMPr_GET BCM89500_A0_TXDROPPKTS_IMPr_GET
#define READ_TXDROPPKTS_IMPr BCM89500_A0_READ_TXDROPPKTS_IMPr
#define WRITE_TXDROPPKTS_IMPr BCM89500_A0_WRITE_TXDROPPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXDROPPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxDropPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXDROPPKTS_P7r 0x00002708

#define BCM89500_A0_TXDROPPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts_P7.
 *
 */
typedef union BCM89500_A0_TXDROPPKTS_P7r_s {
	uint32_t v[1];
	uint32_t txdroppkts_p7[1];
	uint32_t _txdroppkts_p7;
} BCM89500_A0_TXDROPPKTS_P7r_t;

#define BCM89500_A0_TXDROPPKTS_P7r_CLR(r) (r).txdroppkts_p7[0] = 0
#define BCM89500_A0_TXDROPPKTS_P7r_SET(r,d) (r).txdroppkts_p7[0] = d
#define BCM89500_A0_TXDROPPKTS_P7r_GET(r) (r).txdroppkts_p7[0]


/*
 * These macros can be used to access TxDropPkts_P7.
 *
 */
#define BCM89500_A0_READ_TXDROPPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXDROPPKTS_P7r,(r._txdroppkts_p7),4)
#define BCM89500_A0_WRITE_TXDROPPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXDROPPKTS_P7r,&(r._txdroppkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTS_P7r BCM89500_A0_TXDROPPKTS_P7r
#define TXDROPPKTS_P7r_SIZE BCM89500_A0_TXDROPPKTS_P7r_SIZE
typedef BCM89500_A0_TXDROPPKTS_P7r_t TXDROPPKTS_P7r_t;
#define TXDROPPKTS_P7r_CLR BCM89500_A0_TXDROPPKTS_P7r_CLR
#define TXDROPPKTS_P7r_SET BCM89500_A0_TXDROPPKTS_P7r_SET
#define TXDROPPKTS_P7r_GET BCM89500_A0_TXDROPPKTS_P7r_GET
#define READ_TXDROPPKTS_P7r BCM89500_A0_READ_TXDROPPKTS_P7r
#define WRITE_TXDROPPKTS_P7r BCM89500_A0_WRITE_TXDROPPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXDROPPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXEXCESSIVECOLLISIONr 0x00002030

#define BCM89500_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 *
 */
typedef union BCM89500_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM89500_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM89500_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM89500_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM89500_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 *
 */
#define BCM89500_A0_READ_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM89500_A0_WRITE_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM89500_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM89500_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM89500_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM89500_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM89500_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM89500_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM89500_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM89500_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxExcessiveCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXEXCESSIVECOLLISION_IMPr 0x00002830

#define BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision_IMP.
 *
 */
typedef union BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision_imp[1];
	uint32_t _txexcessivecollision_imp;
} BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_t;

#define BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_CLR(r) (r).txexcessivecollision_imp[0] = 0
#define BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_SET(r,d) (r).txexcessivecollision_imp[0] = d
#define BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_GET(r) (r).txexcessivecollision_imp[0]


/*
 * These macros can be used to access TxExcessiveCollision_IMP.
 *
 */
#define BCM89500_A0_READ_TXEXCESSIVECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXEXCESSIVECOLLISION_IMPr,(r._txexcessivecollision_imp),4)
#define BCM89500_A0_WRITE_TXEXCESSIVECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXEXCESSIVECOLLISION_IMPr,&(r._txexcessivecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISION_IMPr BCM89500_A0_TXEXCESSIVECOLLISION_IMPr
#define TXEXCESSIVECOLLISION_IMPr_SIZE BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_SIZE
typedef BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_t TXEXCESSIVECOLLISION_IMPr_t;
#define TXEXCESSIVECOLLISION_IMPr_CLR BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_CLR
#define TXEXCESSIVECOLLISION_IMPr_SET BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_SET
#define TXEXCESSIVECOLLISION_IMPr_GET BCM89500_A0_TXEXCESSIVECOLLISION_IMPr_GET
#define READ_TXEXCESSIVECOLLISION_IMPr BCM89500_A0_READ_TXEXCESSIVECOLLISION_IMPr
#define WRITE_TXEXCESSIVECOLLISION_IMPr BCM89500_A0_WRITE_TXEXCESSIVECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXEXCESSIVECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxExcessiveCollision_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXEXCESSIVECOLLISION_P7r 0x00002730

#define BCM89500_A0_TXEXCESSIVECOLLISION_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision_P7.
 *
 */
typedef union BCM89500_A0_TXEXCESSIVECOLLISION_P7r_s {
	uint32_t v[1];
	uint32_t txexcessivecollision_p7[1];
	uint32_t _txexcessivecollision_p7;
} BCM89500_A0_TXEXCESSIVECOLLISION_P7r_t;

#define BCM89500_A0_TXEXCESSIVECOLLISION_P7r_CLR(r) (r).txexcessivecollision_p7[0] = 0
#define BCM89500_A0_TXEXCESSIVECOLLISION_P7r_SET(r,d) (r).txexcessivecollision_p7[0] = d
#define BCM89500_A0_TXEXCESSIVECOLLISION_P7r_GET(r) (r).txexcessivecollision_p7[0]


/*
 * These macros can be used to access TxExcessiveCollision_P7.
 *
 */
#define BCM89500_A0_READ_TXEXCESSIVECOLLISION_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXEXCESSIVECOLLISION_P7r,(r._txexcessivecollision_p7),4)
#define BCM89500_A0_WRITE_TXEXCESSIVECOLLISION_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXEXCESSIVECOLLISION_P7r,&(r._txexcessivecollision_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISION_P7r BCM89500_A0_TXEXCESSIVECOLLISION_P7r
#define TXEXCESSIVECOLLISION_P7r_SIZE BCM89500_A0_TXEXCESSIVECOLLISION_P7r_SIZE
typedef BCM89500_A0_TXEXCESSIVECOLLISION_P7r_t TXEXCESSIVECOLLISION_P7r_t;
#define TXEXCESSIVECOLLISION_P7r_CLR BCM89500_A0_TXEXCESSIVECOLLISION_P7r_CLR
#define TXEXCESSIVECOLLISION_P7r_SET BCM89500_A0_TXEXCESSIVECOLLISION_P7r_SET
#define TXEXCESSIVECOLLISION_P7r_GET BCM89500_A0_TXEXCESSIVECOLLISION_P7r_GET
#define READ_TXEXCESSIVECOLLISION_P7r BCM89500_A0_READ_TXEXCESSIVECOLLISION_P7r
#define WRITE_TXEXCESSIVECOLLISION_P7r BCM89500_A0_WRITE_TXEXCESSIVECOLLISION_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXEXCESSIVECOLLISION_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxFrameInDisc
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXFRAMEINDISCr 0x00002034

#define BCM89500_A0_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc.
 *
 */
typedef union BCM89500_A0_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t txframeindisc[1];
	uint32_t _txframeindisc;
} BCM89500_A0_TXFRAMEINDISCr_t;

#define BCM89500_A0_TXFRAMEINDISCr_CLR(r) (r).txframeindisc[0] = 0
#define BCM89500_A0_TXFRAMEINDISCr_SET(r,d) (r).txframeindisc[0] = d
#define BCM89500_A0_TXFRAMEINDISCr_GET(r) (r).txframeindisc[0]


/*
 * These macros can be used to access TxFrameInDisc.
 *
 */
#define BCM89500_A0_READ_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXFRAMEINDISCr,(r._txframeindisc),4)
#define BCM89500_A0_WRITE_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXFRAMEINDISCr,&(r._txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISCr BCM89500_A0_TXFRAMEINDISCr
#define TXFRAMEINDISCr_SIZE BCM89500_A0_TXFRAMEINDISCr_SIZE
typedef BCM89500_A0_TXFRAMEINDISCr_t TXFRAMEINDISCr_t;
#define TXFRAMEINDISCr_CLR BCM89500_A0_TXFRAMEINDISCr_CLR
#define TXFRAMEINDISCr_SET BCM89500_A0_TXFRAMEINDISCr_SET
#define TXFRAMEINDISCr_GET BCM89500_A0_TXFRAMEINDISCr_GET
#define READ_TXFRAMEINDISCr BCM89500_A0_READ_TXFRAMEINDISCr
#define WRITE_TXFRAMEINDISCr BCM89500_A0_WRITE_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxFrameInDisc_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXFRAMEINDISC_IMPr 0x00002834

#define BCM89500_A0_TXFRAMEINDISC_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc_IMP.
 *
 */
typedef union BCM89500_A0_TXFRAMEINDISC_IMPr_s {
	uint32_t v[1];
	uint32_t txframeindisc_imp[1];
	uint32_t _txframeindisc_imp;
} BCM89500_A0_TXFRAMEINDISC_IMPr_t;

#define BCM89500_A0_TXFRAMEINDISC_IMPr_CLR(r) (r).txframeindisc_imp[0] = 0
#define BCM89500_A0_TXFRAMEINDISC_IMPr_SET(r,d) (r).txframeindisc_imp[0] = d
#define BCM89500_A0_TXFRAMEINDISC_IMPr_GET(r) (r).txframeindisc_imp[0]


/*
 * These macros can be used to access TxFrameInDisc_IMP.
 *
 */
#define BCM89500_A0_READ_TXFRAMEINDISC_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXFRAMEINDISC_IMPr,(r._txframeindisc_imp),4)
#define BCM89500_A0_WRITE_TXFRAMEINDISC_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXFRAMEINDISC_IMPr,&(r._txframeindisc_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISC_IMPr BCM89500_A0_TXFRAMEINDISC_IMPr
#define TXFRAMEINDISC_IMPr_SIZE BCM89500_A0_TXFRAMEINDISC_IMPr_SIZE
typedef BCM89500_A0_TXFRAMEINDISC_IMPr_t TXFRAMEINDISC_IMPr_t;
#define TXFRAMEINDISC_IMPr_CLR BCM89500_A0_TXFRAMEINDISC_IMPr_CLR
#define TXFRAMEINDISC_IMPr_SET BCM89500_A0_TXFRAMEINDISC_IMPr_SET
#define TXFRAMEINDISC_IMPr_GET BCM89500_A0_TXFRAMEINDISC_IMPr_GET
#define READ_TXFRAMEINDISC_IMPr BCM89500_A0_READ_TXFRAMEINDISC_IMPr
#define WRITE_TXFRAMEINDISC_IMPr BCM89500_A0_WRITE_TXFRAMEINDISC_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXFRAMEINDISC_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxFrameInDisc_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXFRAMEINDISC_P7r 0x00002734

#define BCM89500_A0_TXFRAMEINDISC_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc_P7.
 *
 */
typedef union BCM89500_A0_TXFRAMEINDISC_P7r_s {
	uint32_t v[1];
	uint32_t txframeindisc_p7[1];
	uint32_t _txframeindisc_p7;
} BCM89500_A0_TXFRAMEINDISC_P7r_t;

#define BCM89500_A0_TXFRAMEINDISC_P7r_CLR(r) (r).txframeindisc_p7[0] = 0
#define BCM89500_A0_TXFRAMEINDISC_P7r_SET(r,d) (r).txframeindisc_p7[0] = d
#define BCM89500_A0_TXFRAMEINDISC_P7r_GET(r) (r).txframeindisc_p7[0]


/*
 * These macros can be used to access TxFrameInDisc_P7.
 *
 */
#define BCM89500_A0_READ_TXFRAMEINDISC_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXFRAMEINDISC_P7r,(r._txframeindisc_p7),4)
#define BCM89500_A0_WRITE_TXFRAMEINDISC_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXFRAMEINDISC_P7r,&(r._txframeindisc_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISC_P7r BCM89500_A0_TXFRAMEINDISC_P7r
#define TXFRAMEINDISC_P7r_SIZE BCM89500_A0_TXFRAMEINDISC_P7r_SIZE
typedef BCM89500_A0_TXFRAMEINDISC_P7r_t TXFRAMEINDISC_P7r_t;
#define TXFRAMEINDISC_P7r_CLR BCM89500_A0_TXFRAMEINDISC_P7r_CLR
#define TXFRAMEINDISC_P7r_SET BCM89500_A0_TXFRAMEINDISC_P7r_SET
#define TXFRAMEINDISC_P7r_GET BCM89500_A0_TXFRAMEINDISC_P7r_GET
#define READ_TXFRAMEINDISC_P7r BCM89500_A0_READ_TXFRAMEINDISC_P7r
#define WRITE_TXFRAMEINDISC_P7r BCM89500_A0_WRITE_TXFRAMEINDISC_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXFRAMEINDISC_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXLATECOLLISIONr 0x0000202c

#define BCM89500_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 *
 */
typedef union BCM89500_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM89500_A0_TXLATECOLLISIONr_t;

#define BCM89500_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM89500_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM89500_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 *
 */
#define BCM89500_A0_READ_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM89500_A0_WRITE_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM89500_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM89500_A0_TXLATECOLLISIONr_SIZE
typedef BCM89500_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM89500_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM89500_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM89500_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM89500_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM89500_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxLateCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXLATECOLLISION_IMPr 0x0000282c

#define BCM89500_A0_TXLATECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision_IMP.
 *
 */
typedef union BCM89500_A0_TXLATECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txlatecollision_imp[1];
	uint32_t _txlatecollision_imp;
} BCM89500_A0_TXLATECOLLISION_IMPr_t;

#define BCM89500_A0_TXLATECOLLISION_IMPr_CLR(r) (r).txlatecollision_imp[0] = 0
#define BCM89500_A0_TXLATECOLLISION_IMPr_SET(r,d) (r).txlatecollision_imp[0] = d
#define BCM89500_A0_TXLATECOLLISION_IMPr_GET(r) (r).txlatecollision_imp[0]


/*
 * These macros can be used to access TxLateCollision_IMP.
 *
 */
#define BCM89500_A0_READ_TXLATECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXLATECOLLISION_IMPr,(r._txlatecollision_imp),4)
#define BCM89500_A0_WRITE_TXLATECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXLATECOLLISION_IMPr,&(r._txlatecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISION_IMPr BCM89500_A0_TXLATECOLLISION_IMPr
#define TXLATECOLLISION_IMPr_SIZE BCM89500_A0_TXLATECOLLISION_IMPr_SIZE
typedef BCM89500_A0_TXLATECOLLISION_IMPr_t TXLATECOLLISION_IMPr_t;
#define TXLATECOLLISION_IMPr_CLR BCM89500_A0_TXLATECOLLISION_IMPr_CLR
#define TXLATECOLLISION_IMPr_SET BCM89500_A0_TXLATECOLLISION_IMPr_SET
#define TXLATECOLLISION_IMPr_GET BCM89500_A0_TXLATECOLLISION_IMPr_GET
#define READ_TXLATECOLLISION_IMPr BCM89500_A0_READ_TXLATECOLLISION_IMPr
#define WRITE_TXLATECOLLISION_IMPr BCM89500_A0_WRITE_TXLATECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXLATECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxLateCollision_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXLATECOLLISION_P7r 0x0000272c

#define BCM89500_A0_TXLATECOLLISION_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision_P7.
 *
 */
typedef union BCM89500_A0_TXLATECOLLISION_P7r_s {
	uint32_t v[1];
	uint32_t txlatecollision_p7[1];
	uint32_t _txlatecollision_p7;
} BCM89500_A0_TXLATECOLLISION_P7r_t;

#define BCM89500_A0_TXLATECOLLISION_P7r_CLR(r) (r).txlatecollision_p7[0] = 0
#define BCM89500_A0_TXLATECOLLISION_P7r_SET(r,d) (r).txlatecollision_p7[0] = d
#define BCM89500_A0_TXLATECOLLISION_P7r_GET(r) (r).txlatecollision_p7[0]


/*
 * These macros can be used to access TxLateCollision_P7.
 *
 */
#define BCM89500_A0_READ_TXLATECOLLISION_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXLATECOLLISION_P7r,(r._txlatecollision_p7),4)
#define BCM89500_A0_WRITE_TXLATECOLLISION_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXLATECOLLISION_P7r,&(r._txlatecollision_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISION_P7r BCM89500_A0_TXLATECOLLISION_P7r
#define TXLATECOLLISION_P7r_SIZE BCM89500_A0_TXLATECOLLISION_P7r_SIZE
typedef BCM89500_A0_TXLATECOLLISION_P7r_t TXLATECOLLISION_P7r_t;
#define TXLATECOLLISION_P7r_CLR BCM89500_A0_TXLATECOLLISION_P7r_CLR
#define TXLATECOLLISION_P7r_SET BCM89500_A0_TXLATECOLLISION_P7r_SET
#define TXLATECOLLISION_P7r_GET BCM89500_A0_TXLATECOLLISION_P7r_GET
#define READ_TXLATECOLLISION_P7r BCM89500_A0_READ_TXLATECOLLISION_P7r
#define WRITE_TXLATECOLLISION_P7r BCM89500_A0_WRITE_TXLATECOLLISION_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXLATECOLLISION_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXMULTICASTPKTSr 0x00002014

#define BCM89500_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 *
 */
typedef union BCM89500_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM89500_A0_TXMULTICASTPKTSr_t;

#define BCM89500_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM89500_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM89500_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 *
 */
#define BCM89500_A0_READ_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM89500_A0_WRITE_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM89500_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM89500_A0_TXMULTICASTPKTSr_SIZE
typedef BCM89500_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM89500_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM89500_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM89500_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM89500_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM89500_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxMulticastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXMULTICASTPKTS_IMPr 0x00002814

#define BCM89500_A0_TXMULTICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts_IMP.
 *
 */
typedef union BCM89500_A0_TXMULTICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts_imp[1];
	uint32_t _txmulticastpkts_imp;
} BCM89500_A0_TXMULTICASTPKTS_IMPr_t;

#define BCM89500_A0_TXMULTICASTPKTS_IMPr_CLR(r) (r).txmulticastpkts_imp[0] = 0
#define BCM89500_A0_TXMULTICASTPKTS_IMPr_SET(r,d) (r).txmulticastpkts_imp[0] = d
#define BCM89500_A0_TXMULTICASTPKTS_IMPr_GET(r) (r).txmulticastpkts_imp[0]


/*
 * These macros can be used to access TxMulticastPkts_IMP.
 *
 */
#define BCM89500_A0_READ_TXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXMULTICASTPKTS_IMPr,(r._txmulticastpkts_imp),4)
#define BCM89500_A0_WRITE_TXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXMULTICASTPKTS_IMPr,&(r._txmulticastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTS_IMPr BCM89500_A0_TXMULTICASTPKTS_IMPr
#define TXMULTICASTPKTS_IMPr_SIZE BCM89500_A0_TXMULTICASTPKTS_IMPr_SIZE
typedef BCM89500_A0_TXMULTICASTPKTS_IMPr_t TXMULTICASTPKTS_IMPr_t;
#define TXMULTICASTPKTS_IMPr_CLR BCM89500_A0_TXMULTICASTPKTS_IMPr_CLR
#define TXMULTICASTPKTS_IMPr_SET BCM89500_A0_TXMULTICASTPKTS_IMPr_SET
#define TXMULTICASTPKTS_IMPr_GET BCM89500_A0_TXMULTICASTPKTS_IMPr_GET
#define READ_TXMULTICASTPKTS_IMPr BCM89500_A0_READ_TXMULTICASTPKTS_IMPr
#define WRITE_TXMULTICASTPKTS_IMPr BCM89500_A0_WRITE_TXMULTICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXMULTICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxMulticastPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXMULTICASTPKTS_P7r 0x00002714

#define BCM89500_A0_TXMULTICASTPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts_P7.
 *
 */
typedef union BCM89500_A0_TXMULTICASTPKTS_P7r_s {
	uint32_t v[1];
	uint32_t txmulticastpkts_p7[1];
	uint32_t _txmulticastpkts_p7;
} BCM89500_A0_TXMULTICASTPKTS_P7r_t;

#define BCM89500_A0_TXMULTICASTPKTS_P7r_CLR(r) (r).txmulticastpkts_p7[0] = 0
#define BCM89500_A0_TXMULTICASTPKTS_P7r_SET(r,d) (r).txmulticastpkts_p7[0] = d
#define BCM89500_A0_TXMULTICASTPKTS_P7r_GET(r) (r).txmulticastpkts_p7[0]


/*
 * These macros can be used to access TxMulticastPkts_P7.
 *
 */
#define BCM89500_A0_READ_TXMULTICASTPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXMULTICASTPKTS_P7r,(r._txmulticastpkts_p7),4)
#define BCM89500_A0_WRITE_TXMULTICASTPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXMULTICASTPKTS_P7r,&(r._txmulticastpkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTS_P7r BCM89500_A0_TXMULTICASTPKTS_P7r
#define TXMULTICASTPKTS_P7r_SIZE BCM89500_A0_TXMULTICASTPKTS_P7r_SIZE
typedef BCM89500_A0_TXMULTICASTPKTS_P7r_t TXMULTICASTPKTS_P7r_t;
#define TXMULTICASTPKTS_P7r_CLR BCM89500_A0_TXMULTICASTPKTS_P7r_CLR
#define TXMULTICASTPKTS_P7r_SET BCM89500_A0_TXMULTICASTPKTS_P7r_SET
#define TXMULTICASTPKTS_P7r_GET BCM89500_A0_TXMULTICASTPKTS_P7r_GET
#define READ_TXMULTICASTPKTS_P7r BCM89500_A0_READ_TXMULTICASTPKTS_P7r
#define WRITE_TXMULTICASTPKTS_P7r BCM89500_A0_WRITE_TXMULTICASTPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXMULTICASTPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxMultipleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXMULTIPLECOLLISIONr 0x00002024

#define BCM89500_A0_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision.
 *
 */
typedef union BCM89500_A0_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision[1];
	uint32_t _txmultiplecollision;
} BCM89500_A0_TXMULTIPLECOLLISIONr_t;

#define BCM89500_A0_TXMULTIPLECOLLISIONr_CLR(r) (r).txmultiplecollision[0] = 0
#define BCM89500_A0_TXMULTIPLECOLLISIONr_SET(r,d) (r).txmultiplecollision[0] = d
#define BCM89500_A0_TXMULTIPLECOLLISIONr_GET(r) (r).txmultiplecollision[0]


/*
 * These macros can be used to access TxMultipleCollision.
 *
 */
#define BCM89500_A0_READ_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXMULTIPLECOLLISIONr,(r._txmultiplecollision),4)
#define BCM89500_A0_WRITE_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXMULTIPLECOLLISIONr,&(r._txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONr BCM89500_A0_TXMULTIPLECOLLISIONr
#define TXMULTIPLECOLLISIONr_SIZE BCM89500_A0_TXMULTIPLECOLLISIONr_SIZE
typedef BCM89500_A0_TXMULTIPLECOLLISIONr_t TXMULTIPLECOLLISIONr_t;
#define TXMULTIPLECOLLISIONr_CLR BCM89500_A0_TXMULTIPLECOLLISIONr_CLR
#define TXMULTIPLECOLLISIONr_SET BCM89500_A0_TXMULTIPLECOLLISIONr_SET
#define TXMULTIPLECOLLISIONr_GET BCM89500_A0_TXMULTIPLECOLLISIONr_GET
#define READ_TXMULTIPLECOLLISIONr BCM89500_A0_READ_TXMULTIPLECOLLISIONr
#define WRITE_TXMULTIPLECOLLISIONr BCM89500_A0_WRITE_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxMultipleCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXMULTIPLECOLLISION_IMPr 0x00002824

#define BCM89500_A0_TXMULTIPLECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision_IMP.
 *
 */
typedef union BCM89500_A0_TXMULTIPLECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision_imp[1];
	uint32_t _txmultiplecollision_imp;
} BCM89500_A0_TXMULTIPLECOLLISION_IMPr_t;

#define BCM89500_A0_TXMULTIPLECOLLISION_IMPr_CLR(r) (r).txmultiplecollision_imp[0] = 0
#define BCM89500_A0_TXMULTIPLECOLLISION_IMPr_SET(r,d) (r).txmultiplecollision_imp[0] = d
#define BCM89500_A0_TXMULTIPLECOLLISION_IMPr_GET(r) (r).txmultiplecollision_imp[0]


/*
 * These macros can be used to access TxMultipleCollision_IMP.
 *
 */
#define BCM89500_A0_READ_TXMULTIPLECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXMULTIPLECOLLISION_IMPr,(r._txmultiplecollision_imp),4)
#define BCM89500_A0_WRITE_TXMULTIPLECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXMULTIPLECOLLISION_IMPr,&(r._txmultiplecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISION_IMPr BCM89500_A0_TXMULTIPLECOLLISION_IMPr
#define TXMULTIPLECOLLISION_IMPr_SIZE BCM89500_A0_TXMULTIPLECOLLISION_IMPr_SIZE
typedef BCM89500_A0_TXMULTIPLECOLLISION_IMPr_t TXMULTIPLECOLLISION_IMPr_t;
#define TXMULTIPLECOLLISION_IMPr_CLR BCM89500_A0_TXMULTIPLECOLLISION_IMPr_CLR
#define TXMULTIPLECOLLISION_IMPr_SET BCM89500_A0_TXMULTIPLECOLLISION_IMPr_SET
#define TXMULTIPLECOLLISION_IMPr_GET BCM89500_A0_TXMULTIPLECOLLISION_IMPr_GET
#define READ_TXMULTIPLECOLLISION_IMPr BCM89500_A0_READ_TXMULTIPLECOLLISION_IMPr
#define WRITE_TXMULTIPLECOLLISION_IMPr BCM89500_A0_WRITE_TXMULTIPLECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXMULTIPLECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxMultipleCollision_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXMULTIPLECOLLISION_P7r 0x00002724

#define BCM89500_A0_TXMULTIPLECOLLISION_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision_P7.
 *
 */
typedef union BCM89500_A0_TXMULTIPLECOLLISION_P7r_s {
	uint32_t v[1];
	uint32_t txmultiplecollision_p7[1];
	uint32_t _txmultiplecollision_p7;
} BCM89500_A0_TXMULTIPLECOLLISION_P7r_t;

#define BCM89500_A0_TXMULTIPLECOLLISION_P7r_CLR(r) (r).txmultiplecollision_p7[0] = 0
#define BCM89500_A0_TXMULTIPLECOLLISION_P7r_SET(r,d) (r).txmultiplecollision_p7[0] = d
#define BCM89500_A0_TXMULTIPLECOLLISION_P7r_GET(r) (r).txmultiplecollision_p7[0]


/*
 * These macros can be used to access TxMultipleCollision_P7.
 *
 */
#define BCM89500_A0_READ_TXMULTIPLECOLLISION_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXMULTIPLECOLLISION_P7r,(r._txmultiplecollision_p7),4)
#define BCM89500_A0_WRITE_TXMULTIPLECOLLISION_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXMULTIPLECOLLISION_P7r,&(r._txmultiplecollision_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISION_P7r BCM89500_A0_TXMULTIPLECOLLISION_P7r
#define TXMULTIPLECOLLISION_P7r_SIZE BCM89500_A0_TXMULTIPLECOLLISION_P7r_SIZE
typedef BCM89500_A0_TXMULTIPLECOLLISION_P7r_t TXMULTIPLECOLLISION_P7r_t;
#define TXMULTIPLECOLLISION_P7r_CLR BCM89500_A0_TXMULTIPLECOLLISION_P7r_CLR
#define TXMULTIPLECOLLISION_P7r_SET BCM89500_A0_TXMULTIPLECOLLISION_P7r_SET
#define TXMULTIPLECOLLISION_P7r_GET BCM89500_A0_TXMULTIPLECOLLISION_P7r_GET
#define READ_TXMULTIPLECOLLISION_P7r BCM89500_A0_READ_TXMULTIPLECOLLISION_P7r
#define WRITE_TXMULTIPLECOLLISION_P7r BCM89500_A0_WRITE_TXMULTIPLECOLLISION_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXMULTIPLECOLLISION_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_TXOCTETSr 0x00002000

#define BCM89500_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 *
 */
typedef union BCM89500_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM89500_A0_TXOCTETSr_t;

#define BCM89500_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM89500_A0_TXOCTETSr_t))
#define BCM89500_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM89500_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 *
 */
#define BCM89500_A0_READ_TXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXOCTETSr,(r._txoctets),8)
#define BCM89500_A0_WRITE_TXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM89500_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM89500_A0_TXOCTETSr_SIZE
typedef BCM89500_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM89500_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM89500_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM89500_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM89500_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM89500_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_TXOCTETS_IMPr 0x00002800

#define BCM89500_A0_TXOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets_IMP.
 *
 */
typedef union BCM89500_A0_TXOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t txoctets_imp[2];
	uint32_t _txoctets_imp;
} BCM89500_A0_TXOCTETS_IMPr_t;

#define BCM89500_A0_TXOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._txoctets_imp), 0, sizeof(BCM89500_A0_TXOCTETS_IMPr_t))
#define BCM89500_A0_TXOCTETS_IMPr_SET(r,i,d) (r).txoctets_imp[i] = d
#define BCM89500_A0_TXOCTETS_IMPr_GET(r,i) (r).txoctets_imp[i]


/*
 * These macros can be used to access TxOctets_IMP.
 *
 */
#define BCM89500_A0_READ_TXOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXOCTETS_IMPr,(r._txoctets_imp),8)
#define BCM89500_A0_WRITE_TXOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXOCTETS_IMPr,&(r._txoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETS_IMPr BCM89500_A0_TXOCTETS_IMPr
#define TXOCTETS_IMPr_SIZE BCM89500_A0_TXOCTETS_IMPr_SIZE
typedef BCM89500_A0_TXOCTETS_IMPr_t TXOCTETS_IMPr_t;
#define TXOCTETS_IMPr_CLR BCM89500_A0_TXOCTETS_IMPr_CLR
#define TXOCTETS_IMPr_SET BCM89500_A0_TXOCTETS_IMPr_SET
#define TXOCTETS_IMPr_GET BCM89500_A0_TXOCTETS_IMPr_GET
#define READ_TXOCTETS_IMPr BCM89500_A0_READ_TXOCTETS_IMPr
#define WRITE_TXOCTETS_IMPr BCM89500_A0_WRITE_TXOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxOctets_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM89500_A0_TXOCTETS_P7r 0x00002700

#define BCM89500_A0_TXOCTETS_P7r_SIZE 8

/*
 * This structure should be used to declare and program TxOctets_P7.
 *
 */
typedef union BCM89500_A0_TXOCTETS_P7r_s {
	uint32_t v[2];
	uint32_t txoctets_p7[2];
	uint32_t _txoctets_p7;
} BCM89500_A0_TXOCTETS_P7r_t;

#define BCM89500_A0_TXOCTETS_P7r_CLR(r) CDK_MEMSET(&((r)._txoctets_p7), 0, sizeof(BCM89500_A0_TXOCTETS_P7r_t))
#define BCM89500_A0_TXOCTETS_P7r_SET(r,i,d) (r).txoctets_p7[i] = d
#define BCM89500_A0_TXOCTETS_P7r_GET(r,i) (r).txoctets_p7[i]


/*
 * These macros can be used to access TxOctets_P7.
 *
 */
#define BCM89500_A0_READ_TXOCTETS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXOCTETS_P7r,(r._txoctets_p7),8)
#define BCM89500_A0_WRITE_TXOCTETS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXOCTETS_P7r,&(r._txoctets_p7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETS_P7r BCM89500_A0_TXOCTETS_P7r
#define TXOCTETS_P7r_SIZE BCM89500_A0_TXOCTETS_P7r_SIZE
typedef BCM89500_A0_TXOCTETS_P7r_t TXOCTETS_P7r_t;
#define TXOCTETS_P7r_CLR BCM89500_A0_TXOCTETS_P7r_CLR
#define TXOCTETS_P7r_SET BCM89500_A0_TXOCTETS_P7r_SET
#define TXOCTETS_P7r_GET BCM89500_A0_TXOCTETS_P7r_GET
#define READ_TXOCTETS_P7r BCM89500_A0_READ_TXOCTETS_P7r
#define WRITE_TXOCTETS_P7r BCM89500_A0_WRITE_TXOCTETS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXOCTETS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXPAUSEPKTSr 0x00002038

#define BCM89500_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 *
 */
typedef union BCM89500_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM89500_A0_TXPAUSEPKTSr_t;

#define BCM89500_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM89500_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM89500_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 *
 */
#define BCM89500_A0_READ_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM89500_A0_WRITE_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM89500_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM89500_A0_TXPAUSEPKTSr_SIZE
typedef BCM89500_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM89500_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM89500_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM89500_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM89500_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM89500_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxPausePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXPAUSEPKTS_IMPr 0x00002838

#define BCM89500_A0_TXPAUSEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts_IMP.
 *
 */
typedef union BCM89500_A0_TXPAUSEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txpausepkts_imp[1];
	uint32_t _txpausepkts_imp;
} BCM89500_A0_TXPAUSEPKTS_IMPr_t;

#define BCM89500_A0_TXPAUSEPKTS_IMPr_CLR(r) (r).txpausepkts_imp[0] = 0
#define BCM89500_A0_TXPAUSEPKTS_IMPr_SET(r,d) (r).txpausepkts_imp[0] = d
#define BCM89500_A0_TXPAUSEPKTS_IMPr_GET(r) (r).txpausepkts_imp[0]


/*
 * These macros can be used to access TxPausePkts_IMP.
 *
 */
#define BCM89500_A0_READ_TXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXPAUSEPKTS_IMPr,(r._txpausepkts_imp),4)
#define BCM89500_A0_WRITE_TXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXPAUSEPKTS_IMPr,&(r._txpausepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTS_IMPr BCM89500_A0_TXPAUSEPKTS_IMPr
#define TXPAUSEPKTS_IMPr_SIZE BCM89500_A0_TXPAUSEPKTS_IMPr_SIZE
typedef BCM89500_A0_TXPAUSEPKTS_IMPr_t TXPAUSEPKTS_IMPr_t;
#define TXPAUSEPKTS_IMPr_CLR BCM89500_A0_TXPAUSEPKTS_IMPr_CLR
#define TXPAUSEPKTS_IMPr_SET BCM89500_A0_TXPAUSEPKTS_IMPr_SET
#define TXPAUSEPKTS_IMPr_GET BCM89500_A0_TXPAUSEPKTS_IMPr_GET
#define READ_TXPAUSEPKTS_IMPr BCM89500_A0_READ_TXPAUSEPKTS_IMPr
#define WRITE_TXPAUSEPKTS_IMPr BCM89500_A0_WRITE_TXPAUSEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXPAUSEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxPausePkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXPAUSEPKTS_P7r 0x00002738

#define BCM89500_A0_TXPAUSEPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts_P7.
 *
 */
typedef union BCM89500_A0_TXPAUSEPKTS_P7r_s {
	uint32_t v[1];
	uint32_t txpausepkts_p7[1];
	uint32_t _txpausepkts_p7;
} BCM89500_A0_TXPAUSEPKTS_P7r_t;

#define BCM89500_A0_TXPAUSEPKTS_P7r_CLR(r) (r).txpausepkts_p7[0] = 0
#define BCM89500_A0_TXPAUSEPKTS_P7r_SET(r,d) (r).txpausepkts_p7[0] = d
#define BCM89500_A0_TXPAUSEPKTS_P7r_GET(r) (r).txpausepkts_p7[0]


/*
 * These macros can be used to access TxPausePkts_P7.
 *
 */
#define BCM89500_A0_READ_TXPAUSEPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXPAUSEPKTS_P7r,(r._txpausepkts_p7),4)
#define BCM89500_A0_WRITE_TXPAUSEPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXPAUSEPKTS_P7r,&(r._txpausepkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTS_P7r BCM89500_A0_TXPAUSEPKTS_P7r
#define TXPAUSEPKTS_P7r_SIZE BCM89500_A0_TXPAUSEPKTS_P7r_SIZE
typedef BCM89500_A0_TXPAUSEPKTS_P7r_t TXPAUSEPKTS_P7r_t;
#define TXPAUSEPKTS_P7r_CLR BCM89500_A0_TXPAUSEPKTS_P7r_CLR
#define TXPAUSEPKTS_P7r_SET BCM89500_A0_TXPAUSEPKTS_P7r_SET
#define TXPAUSEPKTS_P7r_GET BCM89500_A0_TXPAUSEPKTS_P7r_GET
#define READ_TXPAUSEPKTS_P7r BCM89500_A0_READ_TXPAUSEPKTS_P7r
#define WRITE_TXPAUSEPKTS_P7r BCM89500_A0_WRITE_TXPAUSEPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXPAUSEPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ0
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ0r 0x0000200c

#define BCM89500_A0_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0.
 *
 */
typedef union BCM89500_A0_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t txqpktq0[1];
	uint32_t _txqpktq0;
} BCM89500_A0_TXQPKTQ0r_t;

#define BCM89500_A0_TXQPKTQ0r_CLR(r) (r).txqpktq0[0] = 0
#define BCM89500_A0_TXQPKTQ0r_SET(r,d) (r).txqpktq0[0] = d
#define BCM89500_A0_TXQPKTQ0r_GET(r) (r).txqpktq0[0]


/*
 * These macros can be used to access TxQPKTQ0.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXQPKTQ0r,(r._txqpktq0),4)
#define BCM89500_A0_WRITE_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXQPKTQ0r,&(r._txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0r BCM89500_A0_TXQPKTQ0r
#define TXQPKTQ0r_SIZE BCM89500_A0_TXQPKTQ0r_SIZE
typedef BCM89500_A0_TXQPKTQ0r_t TXQPKTQ0r_t;
#define TXQPKTQ0r_CLR BCM89500_A0_TXQPKTQ0r_CLR
#define TXQPKTQ0r_SET BCM89500_A0_TXQPKTQ0r_SET
#define TXQPKTQ0r_GET BCM89500_A0_TXQPKTQ0r_GET
#define READ_TXQPKTQ0r BCM89500_A0_READ_TXQPKTQ0r
#define WRITE_TXQPKTQ0r BCM89500_A0_WRITE_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ0_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ0_IMPr 0x0000280c

#define BCM89500_A0_TXQPKTQ0_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0_IMP.
 *
 */
typedef union BCM89500_A0_TXQPKTQ0_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq0_imp[1];
	uint32_t _txqpktq0_imp;
} BCM89500_A0_TXQPKTQ0_IMPr_t;

#define BCM89500_A0_TXQPKTQ0_IMPr_CLR(r) (r).txqpktq0_imp[0] = 0
#define BCM89500_A0_TXQPKTQ0_IMPr_SET(r,d) (r).txqpktq0_imp[0] = d
#define BCM89500_A0_TXQPKTQ0_IMPr_GET(r) (r).txqpktq0_imp[0]


/*
 * These macros can be used to access TxQPKTQ0_IMP.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ0_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ0_IMPr,(r._txqpktq0_imp),4)
#define BCM89500_A0_WRITE_TXQPKTQ0_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ0_IMPr,&(r._txqpktq0_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0_IMPr BCM89500_A0_TXQPKTQ0_IMPr
#define TXQPKTQ0_IMPr_SIZE BCM89500_A0_TXQPKTQ0_IMPr_SIZE
typedef BCM89500_A0_TXQPKTQ0_IMPr_t TXQPKTQ0_IMPr_t;
#define TXQPKTQ0_IMPr_CLR BCM89500_A0_TXQPKTQ0_IMPr_CLR
#define TXQPKTQ0_IMPr_SET BCM89500_A0_TXQPKTQ0_IMPr_SET
#define TXQPKTQ0_IMPr_GET BCM89500_A0_TXQPKTQ0_IMPr_GET
#define READ_TXQPKTQ0_IMPr BCM89500_A0_READ_TXQPKTQ0_IMPr
#define WRITE_TXQPKTQ0_IMPr BCM89500_A0_WRITE_TXQPKTQ0_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ0_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ0_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ0_P7r 0x0000270c

#define BCM89500_A0_TXQPKTQ0_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0_P7.
 *
 */
typedef union BCM89500_A0_TXQPKTQ0_P7r_s {
	uint32_t v[1];
	uint32_t txqpktq0_p7[1];
	uint32_t _txqpktq0_p7;
} BCM89500_A0_TXQPKTQ0_P7r_t;

#define BCM89500_A0_TXQPKTQ0_P7r_CLR(r) (r).txqpktq0_p7[0] = 0
#define BCM89500_A0_TXQPKTQ0_P7r_SET(r,d) (r).txqpktq0_p7[0] = d
#define BCM89500_A0_TXQPKTQ0_P7r_GET(r) (r).txqpktq0_p7[0]


/*
 * These macros can be used to access TxQPKTQ0_P7.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ0_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ0_P7r,(r._txqpktq0_p7),4)
#define BCM89500_A0_WRITE_TXQPKTQ0_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ0_P7r,&(r._txqpktq0_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0_P7r BCM89500_A0_TXQPKTQ0_P7r
#define TXQPKTQ0_P7r_SIZE BCM89500_A0_TXQPKTQ0_P7r_SIZE
typedef BCM89500_A0_TXQPKTQ0_P7r_t TXQPKTQ0_P7r_t;
#define TXQPKTQ0_P7r_CLR BCM89500_A0_TXQPKTQ0_P7r_CLR
#define TXQPKTQ0_P7r_SET BCM89500_A0_TXQPKTQ0_P7r_SET
#define TXQPKTQ0_P7r_GET BCM89500_A0_TXQPKTQ0_P7r_GET
#define READ_TXQPKTQ0_P7r BCM89500_A0_READ_TXQPKTQ0_P7r
#define WRITE_TXQPKTQ0_P7r BCM89500_A0_WRITE_TXQPKTQ0_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ0_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ1
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ1r 0x0000203c

#define BCM89500_A0_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1.
 *
 */
typedef union BCM89500_A0_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t txqpktq1[1];
	uint32_t _txqpktq1;
} BCM89500_A0_TXQPKTQ1r_t;

#define BCM89500_A0_TXQPKTQ1r_CLR(r) (r).txqpktq1[0] = 0
#define BCM89500_A0_TXQPKTQ1r_SET(r,d) (r).txqpktq1[0] = d
#define BCM89500_A0_TXQPKTQ1r_GET(r) (r).txqpktq1[0]


/*
 * These macros can be used to access TxQPKTQ1.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXQPKTQ1r,(r._txqpktq1),4)
#define BCM89500_A0_WRITE_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXQPKTQ1r,&(r._txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1r BCM89500_A0_TXQPKTQ1r
#define TXQPKTQ1r_SIZE BCM89500_A0_TXQPKTQ1r_SIZE
typedef BCM89500_A0_TXQPKTQ1r_t TXQPKTQ1r_t;
#define TXQPKTQ1r_CLR BCM89500_A0_TXQPKTQ1r_CLR
#define TXQPKTQ1r_SET BCM89500_A0_TXQPKTQ1r_SET
#define TXQPKTQ1r_GET BCM89500_A0_TXQPKTQ1r_GET
#define READ_TXQPKTQ1r BCM89500_A0_READ_TXQPKTQ1r
#define WRITE_TXQPKTQ1r BCM89500_A0_WRITE_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ1_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ1_IMPr 0x0000283c

#define BCM89500_A0_TXQPKTQ1_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1_IMP.
 *
 */
typedef union BCM89500_A0_TXQPKTQ1_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq1_imp[1];
	uint32_t _txqpktq1_imp;
} BCM89500_A0_TXQPKTQ1_IMPr_t;

#define BCM89500_A0_TXQPKTQ1_IMPr_CLR(r) (r).txqpktq1_imp[0] = 0
#define BCM89500_A0_TXQPKTQ1_IMPr_SET(r,d) (r).txqpktq1_imp[0] = d
#define BCM89500_A0_TXQPKTQ1_IMPr_GET(r) (r).txqpktq1_imp[0]


/*
 * These macros can be used to access TxQPKTQ1_IMP.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ1_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ1_IMPr,(r._txqpktq1_imp),4)
#define BCM89500_A0_WRITE_TXQPKTQ1_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ1_IMPr,&(r._txqpktq1_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1_IMPr BCM89500_A0_TXQPKTQ1_IMPr
#define TXQPKTQ1_IMPr_SIZE BCM89500_A0_TXQPKTQ1_IMPr_SIZE
typedef BCM89500_A0_TXQPKTQ1_IMPr_t TXQPKTQ1_IMPr_t;
#define TXQPKTQ1_IMPr_CLR BCM89500_A0_TXQPKTQ1_IMPr_CLR
#define TXQPKTQ1_IMPr_SET BCM89500_A0_TXQPKTQ1_IMPr_SET
#define TXQPKTQ1_IMPr_GET BCM89500_A0_TXQPKTQ1_IMPr_GET
#define READ_TXQPKTQ1_IMPr BCM89500_A0_READ_TXQPKTQ1_IMPr
#define WRITE_TXQPKTQ1_IMPr BCM89500_A0_WRITE_TXQPKTQ1_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ1_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ1_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ1_P7r 0x0000273c

#define BCM89500_A0_TXQPKTQ1_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1_P7.
 *
 */
typedef union BCM89500_A0_TXQPKTQ1_P7r_s {
	uint32_t v[1];
	uint32_t txqpktq1_p7[1];
	uint32_t _txqpktq1_p7;
} BCM89500_A0_TXQPKTQ1_P7r_t;

#define BCM89500_A0_TXQPKTQ1_P7r_CLR(r) (r).txqpktq1_p7[0] = 0
#define BCM89500_A0_TXQPKTQ1_P7r_SET(r,d) (r).txqpktq1_p7[0] = d
#define BCM89500_A0_TXQPKTQ1_P7r_GET(r) (r).txqpktq1_p7[0]


/*
 * These macros can be used to access TxQPKTQ1_P7.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ1_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ1_P7r,(r._txqpktq1_p7),4)
#define BCM89500_A0_WRITE_TXQPKTQ1_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ1_P7r,&(r._txqpktq1_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1_P7r BCM89500_A0_TXQPKTQ1_P7r
#define TXQPKTQ1_P7r_SIZE BCM89500_A0_TXQPKTQ1_P7r_SIZE
typedef BCM89500_A0_TXQPKTQ1_P7r_t TXQPKTQ1_P7r_t;
#define TXQPKTQ1_P7r_CLR BCM89500_A0_TXQPKTQ1_P7r_CLR
#define TXQPKTQ1_P7r_SET BCM89500_A0_TXQPKTQ1_P7r_SET
#define TXQPKTQ1_P7r_GET BCM89500_A0_TXQPKTQ1_P7r_GET
#define READ_TXQPKTQ1_P7r BCM89500_A0_READ_TXQPKTQ1_P7r
#define WRITE_TXQPKTQ1_P7r BCM89500_A0_WRITE_TXQPKTQ1_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ1_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ2
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ2r 0x00002040

#define BCM89500_A0_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2.
 *
 */
typedef union BCM89500_A0_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t txqpktq2[1];
	uint32_t _txqpktq2;
} BCM89500_A0_TXQPKTQ2r_t;

#define BCM89500_A0_TXQPKTQ2r_CLR(r) (r).txqpktq2[0] = 0
#define BCM89500_A0_TXQPKTQ2r_SET(r,d) (r).txqpktq2[0] = d
#define BCM89500_A0_TXQPKTQ2r_GET(r) (r).txqpktq2[0]


/*
 * These macros can be used to access TxQPKTQ2.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXQPKTQ2r,(r._txqpktq2),4)
#define BCM89500_A0_WRITE_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXQPKTQ2r,&(r._txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2r BCM89500_A0_TXQPKTQ2r
#define TXQPKTQ2r_SIZE BCM89500_A0_TXQPKTQ2r_SIZE
typedef BCM89500_A0_TXQPKTQ2r_t TXQPKTQ2r_t;
#define TXQPKTQ2r_CLR BCM89500_A0_TXQPKTQ2r_CLR
#define TXQPKTQ2r_SET BCM89500_A0_TXQPKTQ2r_SET
#define TXQPKTQ2r_GET BCM89500_A0_TXQPKTQ2r_GET
#define READ_TXQPKTQ2r BCM89500_A0_READ_TXQPKTQ2r
#define WRITE_TXQPKTQ2r BCM89500_A0_WRITE_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ2_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ2_IMPr 0x00002840

#define BCM89500_A0_TXQPKTQ2_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2_IMP.
 *
 */
typedef union BCM89500_A0_TXQPKTQ2_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq2_imp[1];
	uint32_t _txqpktq2_imp;
} BCM89500_A0_TXQPKTQ2_IMPr_t;

#define BCM89500_A0_TXQPKTQ2_IMPr_CLR(r) (r).txqpktq2_imp[0] = 0
#define BCM89500_A0_TXQPKTQ2_IMPr_SET(r,d) (r).txqpktq2_imp[0] = d
#define BCM89500_A0_TXQPKTQ2_IMPr_GET(r) (r).txqpktq2_imp[0]


/*
 * These macros can be used to access TxQPKTQ2_IMP.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ2_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ2_IMPr,(r._txqpktq2_imp),4)
#define BCM89500_A0_WRITE_TXQPKTQ2_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ2_IMPr,&(r._txqpktq2_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2_IMPr BCM89500_A0_TXQPKTQ2_IMPr
#define TXQPKTQ2_IMPr_SIZE BCM89500_A0_TXQPKTQ2_IMPr_SIZE
typedef BCM89500_A0_TXQPKTQ2_IMPr_t TXQPKTQ2_IMPr_t;
#define TXQPKTQ2_IMPr_CLR BCM89500_A0_TXQPKTQ2_IMPr_CLR
#define TXQPKTQ2_IMPr_SET BCM89500_A0_TXQPKTQ2_IMPr_SET
#define TXQPKTQ2_IMPr_GET BCM89500_A0_TXQPKTQ2_IMPr_GET
#define READ_TXQPKTQ2_IMPr BCM89500_A0_READ_TXQPKTQ2_IMPr
#define WRITE_TXQPKTQ2_IMPr BCM89500_A0_WRITE_TXQPKTQ2_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ2_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ2_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ2_P7r 0x00002740

#define BCM89500_A0_TXQPKTQ2_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2_P7.
 *
 */
typedef union BCM89500_A0_TXQPKTQ2_P7r_s {
	uint32_t v[1];
	uint32_t txqpktq2_p7[1];
	uint32_t _txqpktq2_p7;
} BCM89500_A0_TXQPKTQ2_P7r_t;

#define BCM89500_A0_TXQPKTQ2_P7r_CLR(r) (r).txqpktq2_p7[0] = 0
#define BCM89500_A0_TXQPKTQ2_P7r_SET(r,d) (r).txqpktq2_p7[0] = d
#define BCM89500_A0_TXQPKTQ2_P7r_GET(r) (r).txqpktq2_p7[0]


/*
 * These macros can be used to access TxQPKTQ2_P7.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ2_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ2_P7r,(r._txqpktq2_p7),4)
#define BCM89500_A0_WRITE_TXQPKTQ2_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ2_P7r,&(r._txqpktq2_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2_P7r BCM89500_A0_TXQPKTQ2_P7r
#define TXQPKTQ2_P7r_SIZE BCM89500_A0_TXQPKTQ2_P7r_SIZE
typedef BCM89500_A0_TXQPKTQ2_P7r_t TXQPKTQ2_P7r_t;
#define TXQPKTQ2_P7r_CLR BCM89500_A0_TXQPKTQ2_P7r_CLR
#define TXQPKTQ2_P7r_SET BCM89500_A0_TXQPKTQ2_P7r_SET
#define TXQPKTQ2_P7r_GET BCM89500_A0_TXQPKTQ2_P7r_GET
#define READ_TXQPKTQ2_P7r BCM89500_A0_READ_TXQPKTQ2_P7r
#define WRITE_TXQPKTQ2_P7r BCM89500_A0_WRITE_TXQPKTQ2_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ2_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ3
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ3r 0x00002044

#define BCM89500_A0_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3.
 *
 */
typedef union BCM89500_A0_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t txqpktq3[1];
	uint32_t _txqpktq3;
} BCM89500_A0_TXQPKTQ3r_t;

#define BCM89500_A0_TXQPKTQ3r_CLR(r) (r).txqpktq3[0] = 0
#define BCM89500_A0_TXQPKTQ3r_SET(r,d) (r).txqpktq3[0] = d
#define BCM89500_A0_TXQPKTQ3r_GET(r) (r).txqpktq3[0]


/*
 * These macros can be used to access TxQPKTQ3.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXQPKTQ3r,(r._txqpktq3),4)
#define BCM89500_A0_WRITE_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXQPKTQ3r,&(r._txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3r BCM89500_A0_TXQPKTQ3r
#define TXQPKTQ3r_SIZE BCM89500_A0_TXQPKTQ3r_SIZE
typedef BCM89500_A0_TXQPKTQ3r_t TXQPKTQ3r_t;
#define TXQPKTQ3r_CLR BCM89500_A0_TXQPKTQ3r_CLR
#define TXQPKTQ3r_SET BCM89500_A0_TXQPKTQ3r_SET
#define TXQPKTQ3r_GET BCM89500_A0_TXQPKTQ3r_GET
#define READ_TXQPKTQ3r BCM89500_A0_READ_TXQPKTQ3r
#define WRITE_TXQPKTQ3r BCM89500_A0_WRITE_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ3_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ3_IMPr 0x00002844

#define BCM89500_A0_TXQPKTQ3_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3_IMP.
 *
 */
typedef union BCM89500_A0_TXQPKTQ3_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq3_imp[1];
	uint32_t _txqpktq3_imp;
} BCM89500_A0_TXQPKTQ3_IMPr_t;

#define BCM89500_A0_TXQPKTQ3_IMPr_CLR(r) (r).txqpktq3_imp[0] = 0
#define BCM89500_A0_TXQPKTQ3_IMPr_SET(r,d) (r).txqpktq3_imp[0] = d
#define BCM89500_A0_TXQPKTQ3_IMPr_GET(r) (r).txqpktq3_imp[0]


/*
 * These macros can be used to access TxQPKTQ3_IMP.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ3_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ3_IMPr,(r._txqpktq3_imp),4)
#define BCM89500_A0_WRITE_TXQPKTQ3_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ3_IMPr,&(r._txqpktq3_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3_IMPr BCM89500_A0_TXQPKTQ3_IMPr
#define TXQPKTQ3_IMPr_SIZE BCM89500_A0_TXQPKTQ3_IMPr_SIZE
typedef BCM89500_A0_TXQPKTQ3_IMPr_t TXQPKTQ3_IMPr_t;
#define TXQPKTQ3_IMPr_CLR BCM89500_A0_TXQPKTQ3_IMPr_CLR
#define TXQPKTQ3_IMPr_SET BCM89500_A0_TXQPKTQ3_IMPr_SET
#define TXQPKTQ3_IMPr_GET BCM89500_A0_TXQPKTQ3_IMPr_GET
#define READ_TXQPKTQ3_IMPr BCM89500_A0_READ_TXQPKTQ3_IMPr
#define WRITE_TXQPKTQ3_IMPr BCM89500_A0_WRITE_TXQPKTQ3_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ3_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ3_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ3_P7r 0x00002744

#define BCM89500_A0_TXQPKTQ3_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3_P7.
 *
 */
typedef union BCM89500_A0_TXQPKTQ3_P7r_s {
	uint32_t v[1];
	uint32_t txqpktq3_p7[1];
	uint32_t _txqpktq3_p7;
} BCM89500_A0_TXQPKTQ3_P7r_t;

#define BCM89500_A0_TXQPKTQ3_P7r_CLR(r) (r).txqpktq3_p7[0] = 0
#define BCM89500_A0_TXQPKTQ3_P7r_SET(r,d) (r).txqpktq3_p7[0] = d
#define BCM89500_A0_TXQPKTQ3_P7r_GET(r) (r).txqpktq3_p7[0]


/*
 * These macros can be used to access TxQPKTQ3_P7.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ3_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ3_P7r,(r._txqpktq3_p7),4)
#define BCM89500_A0_WRITE_TXQPKTQ3_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ3_P7r,&(r._txqpktq3_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3_P7r BCM89500_A0_TXQPKTQ3_P7r
#define TXQPKTQ3_P7r_SIZE BCM89500_A0_TXQPKTQ3_P7r_SIZE
typedef BCM89500_A0_TXQPKTQ3_P7r_t TXQPKTQ3_P7r_t;
#define TXQPKTQ3_P7r_CLR BCM89500_A0_TXQPKTQ3_P7r_CLR
#define TXQPKTQ3_P7r_SET BCM89500_A0_TXQPKTQ3_P7r_SET
#define TXQPKTQ3_P7r_GET BCM89500_A0_TXQPKTQ3_P7r_GET
#define READ_TXQPKTQ3_P7r BCM89500_A0_READ_TXQPKTQ3_P7r
#define WRITE_TXQPKTQ3_P7r BCM89500_A0_WRITE_TXQPKTQ3_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ3_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ4
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ4r 0x00002048

#define BCM89500_A0_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4.
 *
 */
typedef union BCM89500_A0_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t txqpktq4[1];
	uint32_t _txqpktq4;
} BCM89500_A0_TXQPKTQ4r_t;

#define BCM89500_A0_TXQPKTQ4r_CLR(r) (r).txqpktq4[0] = 0
#define BCM89500_A0_TXQPKTQ4r_SET(r,d) (r).txqpktq4[0] = d
#define BCM89500_A0_TXQPKTQ4r_GET(r) (r).txqpktq4[0]


/*
 * These macros can be used to access TxQPKTQ4.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXQPKTQ4r,(r._txqpktq4),4)
#define BCM89500_A0_WRITE_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXQPKTQ4r,&(r._txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4r BCM89500_A0_TXQPKTQ4r
#define TXQPKTQ4r_SIZE BCM89500_A0_TXQPKTQ4r_SIZE
typedef BCM89500_A0_TXQPKTQ4r_t TXQPKTQ4r_t;
#define TXQPKTQ4r_CLR BCM89500_A0_TXQPKTQ4r_CLR
#define TXQPKTQ4r_SET BCM89500_A0_TXQPKTQ4r_SET
#define TXQPKTQ4r_GET BCM89500_A0_TXQPKTQ4r_GET
#define READ_TXQPKTQ4r BCM89500_A0_READ_TXQPKTQ4r
#define WRITE_TXQPKTQ4r BCM89500_A0_WRITE_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ4_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ4_IMPr 0x00002848

#define BCM89500_A0_TXQPKTQ4_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4_IMP.
 *
 */
typedef union BCM89500_A0_TXQPKTQ4_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq4_imp[1];
	uint32_t _txqpktq4_imp;
} BCM89500_A0_TXQPKTQ4_IMPr_t;

#define BCM89500_A0_TXQPKTQ4_IMPr_CLR(r) (r).txqpktq4_imp[0] = 0
#define BCM89500_A0_TXQPKTQ4_IMPr_SET(r,d) (r).txqpktq4_imp[0] = d
#define BCM89500_A0_TXQPKTQ4_IMPr_GET(r) (r).txqpktq4_imp[0]


/*
 * These macros can be used to access TxQPKTQ4_IMP.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ4_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ4_IMPr,(r._txqpktq4_imp),4)
#define BCM89500_A0_WRITE_TXQPKTQ4_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ4_IMPr,&(r._txqpktq4_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4_IMPr BCM89500_A0_TXQPKTQ4_IMPr
#define TXQPKTQ4_IMPr_SIZE BCM89500_A0_TXQPKTQ4_IMPr_SIZE
typedef BCM89500_A0_TXQPKTQ4_IMPr_t TXQPKTQ4_IMPr_t;
#define TXQPKTQ4_IMPr_CLR BCM89500_A0_TXQPKTQ4_IMPr_CLR
#define TXQPKTQ4_IMPr_SET BCM89500_A0_TXQPKTQ4_IMPr_SET
#define TXQPKTQ4_IMPr_GET BCM89500_A0_TXQPKTQ4_IMPr_GET
#define READ_TXQPKTQ4_IMPr BCM89500_A0_READ_TXQPKTQ4_IMPr
#define WRITE_TXQPKTQ4_IMPr BCM89500_A0_WRITE_TXQPKTQ4_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ4_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ4_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ4_P7r 0x00002748

#define BCM89500_A0_TXQPKTQ4_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4_P7.
 *
 */
typedef union BCM89500_A0_TXQPKTQ4_P7r_s {
	uint32_t v[1];
	uint32_t txqpktq4_p7[1];
	uint32_t _txqpktq4_p7;
} BCM89500_A0_TXQPKTQ4_P7r_t;

#define BCM89500_A0_TXQPKTQ4_P7r_CLR(r) (r).txqpktq4_p7[0] = 0
#define BCM89500_A0_TXQPKTQ4_P7r_SET(r,d) (r).txqpktq4_p7[0] = d
#define BCM89500_A0_TXQPKTQ4_P7r_GET(r) (r).txqpktq4_p7[0]


/*
 * These macros can be used to access TxQPKTQ4_P7.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ4_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ4_P7r,(r._txqpktq4_p7),4)
#define BCM89500_A0_WRITE_TXQPKTQ4_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ4_P7r,&(r._txqpktq4_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4_P7r BCM89500_A0_TXQPKTQ4_P7r
#define TXQPKTQ4_P7r_SIZE BCM89500_A0_TXQPKTQ4_P7r_SIZE
typedef BCM89500_A0_TXQPKTQ4_P7r_t TXQPKTQ4_P7r_t;
#define TXQPKTQ4_P7r_CLR BCM89500_A0_TXQPKTQ4_P7r_CLR
#define TXQPKTQ4_P7r_SET BCM89500_A0_TXQPKTQ4_P7r_SET
#define TXQPKTQ4_P7r_GET BCM89500_A0_TXQPKTQ4_P7r_GET
#define READ_TXQPKTQ4_P7r BCM89500_A0_READ_TXQPKTQ4_P7r
#define WRITE_TXQPKTQ4_P7r BCM89500_A0_WRITE_TXQPKTQ4_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ4_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ5
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ5r 0x0000204c

#define BCM89500_A0_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5.
 *
 */
typedef union BCM89500_A0_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t txqpktq5[1];
	uint32_t _txqpktq5;
} BCM89500_A0_TXQPKTQ5r_t;

#define BCM89500_A0_TXQPKTQ5r_CLR(r) (r).txqpktq5[0] = 0
#define BCM89500_A0_TXQPKTQ5r_SET(r,d) (r).txqpktq5[0] = d
#define BCM89500_A0_TXQPKTQ5r_GET(r) (r).txqpktq5[0]


/*
 * These macros can be used to access TxQPKTQ5.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXQPKTQ5r,(r._txqpktq5),4)
#define BCM89500_A0_WRITE_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXQPKTQ5r,&(r._txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5r BCM89500_A0_TXQPKTQ5r
#define TXQPKTQ5r_SIZE BCM89500_A0_TXQPKTQ5r_SIZE
typedef BCM89500_A0_TXQPKTQ5r_t TXQPKTQ5r_t;
#define TXQPKTQ5r_CLR BCM89500_A0_TXQPKTQ5r_CLR
#define TXQPKTQ5r_SET BCM89500_A0_TXQPKTQ5r_SET
#define TXQPKTQ5r_GET BCM89500_A0_TXQPKTQ5r_GET
#define READ_TXQPKTQ5r BCM89500_A0_READ_TXQPKTQ5r
#define WRITE_TXQPKTQ5r BCM89500_A0_WRITE_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ5_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ5_IMPr 0x0000284c

#define BCM89500_A0_TXQPKTQ5_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5_IMP.
 *
 */
typedef union BCM89500_A0_TXQPKTQ5_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq5_imp[1];
	uint32_t _txqpktq5_imp;
} BCM89500_A0_TXQPKTQ5_IMPr_t;

#define BCM89500_A0_TXQPKTQ5_IMPr_CLR(r) (r).txqpktq5_imp[0] = 0
#define BCM89500_A0_TXQPKTQ5_IMPr_SET(r,d) (r).txqpktq5_imp[0] = d
#define BCM89500_A0_TXQPKTQ5_IMPr_GET(r) (r).txqpktq5_imp[0]


/*
 * These macros can be used to access TxQPKTQ5_IMP.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ5_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ5_IMPr,(r._txqpktq5_imp),4)
#define BCM89500_A0_WRITE_TXQPKTQ5_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ5_IMPr,&(r._txqpktq5_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5_IMPr BCM89500_A0_TXQPKTQ5_IMPr
#define TXQPKTQ5_IMPr_SIZE BCM89500_A0_TXQPKTQ5_IMPr_SIZE
typedef BCM89500_A0_TXQPKTQ5_IMPr_t TXQPKTQ5_IMPr_t;
#define TXQPKTQ5_IMPr_CLR BCM89500_A0_TXQPKTQ5_IMPr_CLR
#define TXQPKTQ5_IMPr_SET BCM89500_A0_TXQPKTQ5_IMPr_SET
#define TXQPKTQ5_IMPr_GET BCM89500_A0_TXQPKTQ5_IMPr_GET
#define READ_TXQPKTQ5_IMPr BCM89500_A0_READ_TXQPKTQ5_IMPr
#define WRITE_TXQPKTQ5_IMPr BCM89500_A0_WRITE_TXQPKTQ5_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ5_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxQPKTQ5_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXQPKTQ5_P7r 0x0000274c

#define BCM89500_A0_TXQPKTQ5_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5_P7.
 *
 */
typedef union BCM89500_A0_TXQPKTQ5_P7r_s {
	uint32_t v[1];
	uint32_t txqpktq5_p7[1];
	uint32_t _txqpktq5_p7;
} BCM89500_A0_TXQPKTQ5_P7r_t;

#define BCM89500_A0_TXQPKTQ5_P7r_CLR(r) (r).txqpktq5_p7[0] = 0
#define BCM89500_A0_TXQPKTQ5_P7r_SET(r,d) (r).txqpktq5_p7[0] = d
#define BCM89500_A0_TXQPKTQ5_P7r_GET(r) (r).txqpktq5_p7[0]


/*
 * These macros can be used to access TxQPKTQ5_P7.
 *
 */
#define BCM89500_A0_READ_TXQPKTQ5_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXQPKTQ5_P7r,(r._txqpktq5_p7),4)
#define BCM89500_A0_WRITE_TXQPKTQ5_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXQPKTQ5_P7r,&(r._txqpktq5_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5_P7r BCM89500_A0_TXQPKTQ5_P7r
#define TXQPKTQ5_P7r_SIZE BCM89500_A0_TXQPKTQ5_P7r_SIZE
typedef BCM89500_A0_TXQPKTQ5_P7r_t TXQPKTQ5_P7r_t;
#define TXQPKTQ5_P7r_CLR BCM89500_A0_TXQPKTQ5_P7r_CLR
#define TXQPKTQ5_P7r_SET BCM89500_A0_TXQPKTQ5_P7r_SET
#define TXQPKTQ5_P7r_GET BCM89500_A0_TXQPKTQ5_P7r_GET
#define READ_TXQPKTQ5_P7r BCM89500_A0_READ_TXQPKTQ5_P7r
#define WRITE_TXQPKTQ5_P7r BCM89500_A0_WRITE_TXQPKTQ5_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXQPKTQ5_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxSingleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXSINGLECOLLISIONr 0x00002020

#define BCM89500_A0_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision.
 *
 */
typedef union BCM89500_A0_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txsinglecollision[1];
	uint32_t _txsinglecollision;
} BCM89500_A0_TXSINGLECOLLISIONr_t;

#define BCM89500_A0_TXSINGLECOLLISIONr_CLR(r) (r).txsinglecollision[0] = 0
#define BCM89500_A0_TXSINGLECOLLISIONr_SET(r,d) (r).txsinglecollision[0] = d
#define BCM89500_A0_TXSINGLECOLLISIONr_GET(r) (r).txsinglecollision[0]


/*
 * These macros can be used to access TxSingleCollision.
 *
 */
#define BCM89500_A0_READ_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXSINGLECOLLISIONr,(r._txsinglecollision),4)
#define BCM89500_A0_WRITE_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXSINGLECOLLISIONr,&(r._txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONr BCM89500_A0_TXSINGLECOLLISIONr
#define TXSINGLECOLLISIONr_SIZE BCM89500_A0_TXSINGLECOLLISIONr_SIZE
typedef BCM89500_A0_TXSINGLECOLLISIONr_t TXSINGLECOLLISIONr_t;
#define TXSINGLECOLLISIONr_CLR BCM89500_A0_TXSINGLECOLLISIONr_CLR
#define TXSINGLECOLLISIONr_SET BCM89500_A0_TXSINGLECOLLISIONr_SET
#define TXSINGLECOLLISIONr_GET BCM89500_A0_TXSINGLECOLLISIONr_GET
#define READ_TXSINGLECOLLISIONr BCM89500_A0_READ_TXSINGLECOLLISIONr
#define WRITE_TXSINGLECOLLISIONr BCM89500_A0_WRITE_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxSingleCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXSINGLECOLLISION_IMPr 0x00002820

#define BCM89500_A0_TXSINGLECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision_IMP.
 *
 */
typedef union BCM89500_A0_TXSINGLECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txsinglecollision_imp[1];
	uint32_t _txsinglecollision_imp;
} BCM89500_A0_TXSINGLECOLLISION_IMPr_t;

#define BCM89500_A0_TXSINGLECOLLISION_IMPr_CLR(r) (r).txsinglecollision_imp[0] = 0
#define BCM89500_A0_TXSINGLECOLLISION_IMPr_SET(r,d) (r).txsinglecollision_imp[0] = d
#define BCM89500_A0_TXSINGLECOLLISION_IMPr_GET(r) (r).txsinglecollision_imp[0]


/*
 * These macros can be used to access TxSingleCollision_IMP.
 *
 */
#define BCM89500_A0_READ_TXSINGLECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXSINGLECOLLISION_IMPr,(r._txsinglecollision_imp),4)
#define BCM89500_A0_WRITE_TXSINGLECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXSINGLECOLLISION_IMPr,&(r._txsinglecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISION_IMPr BCM89500_A0_TXSINGLECOLLISION_IMPr
#define TXSINGLECOLLISION_IMPr_SIZE BCM89500_A0_TXSINGLECOLLISION_IMPr_SIZE
typedef BCM89500_A0_TXSINGLECOLLISION_IMPr_t TXSINGLECOLLISION_IMPr_t;
#define TXSINGLECOLLISION_IMPr_CLR BCM89500_A0_TXSINGLECOLLISION_IMPr_CLR
#define TXSINGLECOLLISION_IMPr_SET BCM89500_A0_TXSINGLECOLLISION_IMPr_SET
#define TXSINGLECOLLISION_IMPr_GET BCM89500_A0_TXSINGLECOLLISION_IMPr_GET
#define READ_TXSINGLECOLLISION_IMPr BCM89500_A0_READ_TXSINGLECOLLISION_IMPr
#define WRITE_TXSINGLECOLLISION_IMPr BCM89500_A0_WRITE_TXSINGLECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXSINGLECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxSingleCollision_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXSINGLECOLLISION_P7r 0x00002720

#define BCM89500_A0_TXSINGLECOLLISION_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision_P7.
 *
 */
typedef union BCM89500_A0_TXSINGLECOLLISION_P7r_s {
	uint32_t v[1];
	uint32_t txsinglecollision_p7[1];
	uint32_t _txsinglecollision_p7;
} BCM89500_A0_TXSINGLECOLLISION_P7r_t;

#define BCM89500_A0_TXSINGLECOLLISION_P7r_CLR(r) (r).txsinglecollision_p7[0] = 0
#define BCM89500_A0_TXSINGLECOLLISION_P7r_SET(r,d) (r).txsinglecollision_p7[0] = d
#define BCM89500_A0_TXSINGLECOLLISION_P7r_GET(r) (r).txsinglecollision_p7[0]


/*
 * These macros can be used to access TxSingleCollision_P7.
 *
 */
#define BCM89500_A0_READ_TXSINGLECOLLISION_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXSINGLECOLLISION_P7r,(r._txsinglecollision_p7),4)
#define BCM89500_A0_WRITE_TXSINGLECOLLISION_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXSINGLECOLLISION_P7r,&(r._txsinglecollision_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISION_P7r BCM89500_A0_TXSINGLECOLLISION_P7r
#define TXSINGLECOLLISION_P7r_SIZE BCM89500_A0_TXSINGLECOLLISION_P7r_SIZE
typedef BCM89500_A0_TXSINGLECOLLISION_P7r_t TXSINGLECOLLISION_P7r_t;
#define TXSINGLECOLLISION_P7r_CLR BCM89500_A0_TXSINGLECOLLISION_P7r_CLR
#define TXSINGLECOLLISION_P7r_SET BCM89500_A0_TXSINGLECOLLISION_P7r_SET
#define TXSINGLECOLLISION_P7r_GET BCM89500_A0_TXSINGLECOLLISION_P7r_GET
#define READ_TXSINGLECOLLISION_P7r BCM89500_A0_READ_TXSINGLECOLLISION_P7r
#define WRITE_TXSINGLECOLLISION_P7r BCM89500_A0_WRITE_TXSINGLECOLLISION_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXSINGLECOLLISION_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXUNICASTPKTSr 0x00002018

#define BCM89500_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 *
 */
typedef union BCM89500_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM89500_A0_TXUNICASTPKTSr_t;

#define BCM89500_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM89500_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM89500_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 *
 */
#define BCM89500_A0_READ_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM89500_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM89500_A0_WRITE_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM89500_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM89500_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM89500_A0_TXUNICASTPKTSr_SIZE
typedef BCM89500_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM89500_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM89500_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM89500_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM89500_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM89500_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxUnicastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXUNICASTPKTS_IMPr 0x00002818

#define BCM89500_A0_TXUNICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts_IMP.
 *
 */
typedef union BCM89500_A0_TXUNICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txunicastpkts_imp[1];
	uint32_t _txunicastpkts_imp;
} BCM89500_A0_TXUNICASTPKTS_IMPr_t;

#define BCM89500_A0_TXUNICASTPKTS_IMPr_CLR(r) (r).txunicastpkts_imp[0] = 0
#define BCM89500_A0_TXUNICASTPKTS_IMPr_SET(r,d) (r).txunicastpkts_imp[0] = d
#define BCM89500_A0_TXUNICASTPKTS_IMPr_GET(r) (r).txunicastpkts_imp[0]


/*
 * These macros can be used to access TxUnicastPkts_IMP.
 *
 */
#define BCM89500_A0_READ_TXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXUNICASTPKTS_IMPr,(r._txunicastpkts_imp),4)
#define BCM89500_A0_WRITE_TXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXUNICASTPKTS_IMPr,&(r._txunicastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTS_IMPr BCM89500_A0_TXUNICASTPKTS_IMPr
#define TXUNICASTPKTS_IMPr_SIZE BCM89500_A0_TXUNICASTPKTS_IMPr_SIZE
typedef BCM89500_A0_TXUNICASTPKTS_IMPr_t TXUNICASTPKTS_IMPr_t;
#define TXUNICASTPKTS_IMPr_CLR BCM89500_A0_TXUNICASTPKTS_IMPr_CLR
#define TXUNICASTPKTS_IMPr_SET BCM89500_A0_TXUNICASTPKTS_IMPr_SET
#define TXUNICASTPKTS_IMPr_GET BCM89500_A0_TXUNICASTPKTS_IMPr_GET
#define READ_TXUNICASTPKTS_IMPr BCM89500_A0_READ_TXUNICASTPKTS_IMPr
#define WRITE_TXUNICASTPKTS_IMPr BCM89500_A0_WRITE_TXUNICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXUNICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  TxUnicastPkts_P7
 * BLOCKS:   GPIC7
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM89500_A0_TXUNICASTPKTS_P7r 0x00002718

#define BCM89500_A0_TXUNICASTPKTS_P7r_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts_P7.
 *
 */
typedef union BCM89500_A0_TXUNICASTPKTS_P7r_s {
	uint32_t v[1];
	uint32_t txunicastpkts_p7[1];
	uint32_t _txunicastpkts_p7;
} BCM89500_A0_TXUNICASTPKTS_P7r_t;

#define BCM89500_A0_TXUNICASTPKTS_P7r_CLR(r) (r).txunicastpkts_p7[0] = 0
#define BCM89500_A0_TXUNICASTPKTS_P7r_SET(r,d) (r).txunicastpkts_p7[0] = d
#define BCM89500_A0_TXUNICASTPKTS_P7r_GET(r) (r).txunicastpkts_p7[0]


/*
 * These macros can be used to access TxUnicastPkts_P7.
 *
 */
#define BCM89500_A0_READ_TXUNICASTPKTS_P7r(u,r) cdk_robo_reg_read(u,BCM89500_A0_TXUNICASTPKTS_P7r,(r._txunicastpkts_p7),4)
#define BCM89500_A0_WRITE_TXUNICASTPKTS_P7r(u,r) cdk_robo_reg_write(u,BCM89500_A0_TXUNICASTPKTS_P7r,&(r._txunicastpkts_p7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTS_P7r BCM89500_A0_TXUNICASTPKTS_P7r
#define TXUNICASTPKTS_P7r_SIZE BCM89500_A0_TXUNICASTPKTS_P7r_SIZE
typedef BCM89500_A0_TXUNICASTPKTS_P7r_t TXUNICASTPKTS_P7r_t;
#define TXUNICASTPKTS_P7r_CLR BCM89500_A0_TXUNICASTPKTS_P7r_CLR
#define TXUNICASTPKTS_P7r_SET BCM89500_A0_TXUNICASTPKTS_P7r_SET
#define TXUNICASTPKTS_P7r_GET BCM89500_A0_TXUNICASTPKTS_P7r_GET
#define READ_TXUNICASTPKTS_P7r BCM89500_A0_READ_TXUNICASTPKTS_P7r
#define WRITE_TXUNICASTPKTS_P7r BCM89500_A0_WRITE_TXUNICASTPKTS_P7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_TXUNICASTPKTS_P7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_0_A_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 0 for IPv4 packet Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_A_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_0_A_0_8r 0x0000a110

#define BCM89500_A0_UDF_0_A_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_A_0_8.
 *
 */
typedef union BCM89500_A0_UDF_0_A_0_8r_s {
	uint32_t v[1];
	uint32_t udf_0_a_0_8[1];
	uint32_t _udf_0_a_0_8;
} BCM89500_A0_UDF_0_A_0_8r_t;

#define BCM89500_A0_UDF_0_A_0_8r_CLR(r) (r).udf_0_a_0_8[0] = 0
#define BCM89500_A0_UDF_0_A_0_8r_SET(r,d) (r).udf_0_a_0_8[0] = d
#define BCM89500_A0_UDF_0_A_0_8r_GET(r) (r).udf_0_a_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_0_A_0_8r_CFG_UDF_0_A_0_8f_GET(r) (((r).udf_0_a_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_0_A_0_8r_CFG_UDF_0_A_0_8f_SET(r,f) (r).udf_0_a_0_8[0]=(((r).udf_0_a_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_A_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_0_A_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_0_A_0_8r+(1*(i)),(r._udf_0_a_0_8),1)
#define BCM89500_A0_WRITE_UDF_0_A_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_0_A_0_8r+(1*(i)),&(r._udf_0_a_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_A_0_8r BCM89500_A0_UDF_0_A_0_8r
#define UDF_0_A_0_8r_SIZE BCM89500_A0_UDF_0_A_0_8r_SIZE
typedef BCM89500_A0_UDF_0_A_0_8r_t UDF_0_A_0_8r_t;
#define UDF_0_A_0_8r_CLR BCM89500_A0_UDF_0_A_0_8r_CLR
#define UDF_0_A_0_8r_SET BCM89500_A0_UDF_0_A_0_8r_SET
#define UDF_0_A_0_8r_GET BCM89500_A0_UDF_0_A_0_8r_GET
#define UDF_0_A_0_8r_CFG_UDF_0_A_0_8f_GET BCM89500_A0_UDF_0_A_0_8r_CFG_UDF_0_A_0_8f_GET
#define UDF_0_A_0_8r_CFG_UDF_0_A_0_8f_SET BCM89500_A0_UDF_0_A_0_8r_CFG_UDF_0_A_0_8f_SET
#define READ_UDF_0_A_0_8r BCM89500_A0_READ_UDF_0_A_0_8r
#define WRITE_UDF_0_A_0_8r BCM89500_A0_WRITE_UDF_0_A_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_0_A_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_0_B_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 0 for IPv6 packet Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_B_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_0_B_0_8r 0x0000a140

#define BCM89500_A0_UDF_0_B_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_B_0_8.
 *
 */
typedef union BCM89500_A0_UDF_0_B_0_8r_s {
	uint32_t v[1];
	uint32_t udf_0_b_0_8[1];
	uint32_t _udf_0_b_0_8;
} BCM89500_A0_UDF_0_B_0_8r_t;

#define BCM89500_A0_UDF_0_B_0_8r_CLR(r) (r).udf_0_b_0_8[0] = 0
#define BCM89500_A0_UDF_0_B_0_8r_SET(r,d) (r).udf_0_b_0_8[0] = d
#define BCM89500_A0_UDF_0_B_0_8r_GET(r) (r).udf_0_b_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_0_B_0_8r_CFG_UDF_0_B_0_8f_GET(r) (((r).udf_0_b_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_0_B_0_8r_CFG_UDF_0_B_0_8f_SET(r,f) (r).udf_0_b_0_8[0]=(((r).udf_0_b_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_B_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_0_B_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_0_B_0_8r+(1*(i)),(r._udf_0_b_0_8),1)
#define BCM89500_A0_WRITE_UDF_0_B_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_0_B_0_8r+(1*(i)),&(r._udf_0_b_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_B_0_8r BCM89500_A0_UDF_0_B_0_8r
#define UDF_0_B_0_8r_SIZE BCM89500_A0_UDF_0_B_0_8r_SIZE
typedef BCM89500_A0_UDF_0_B_0_8r_t UDF_0_B_0_8r_t;
#define UDF_0_B_0_8r_CLR BCM89500_A0_UDF_0_B_0_8r_CLR
#define UDF_0_B_0_8r_SET BCM89500_A0_UDF_0_B_0_8r_SET
#define UDF_0_B_0_8r_GET BCM89500_A0_UDF_0_B_0_8r_GET
#define UDF_0_B_0_8r_CFG_UDF_0_B_0_8f_GET BCM89500_A0_UDF_0_B_0_8r_CFG_UDF_0_B_0_8f_GET
#define UDF_0_B_0_8r_CFG_UDF_0_B_0_8f_SET BCM89500_A0_UDF_0_B_0_8r_CFG_UDF_0_B_0_8f_SET
#define READ_UDF_0_B_0_8r BCM89500_A0_READ_UDF_0_B_0_8r
#define WRITE_UDF_0_B_0_8r BCM89500_A0_WRITE_UDF_0_B_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_0_B_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_0_C_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 0 for none-IP Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_C_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_0_C_0_8r 0x0000a170

#define BCM89500_A0_UDF_0_C_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_C_0_8.
 *
 */
typedef union BCM89500_A0_UDF_0_C_0_8r_s {
	uint32_t v[1];
	uint32_t udf_0_c_0_8[1];
	uint32_t _udf_0_c_0_8;
} BCM89500_A0_UDF_0_C_0_8r_t;

#define BCM89500_A0_UDF_0_C_0_8r_CLR(r) (r).udf_0_c_0_8[0] = 0
#define BCM89500_A0_UDF_0_C_0_8r_SET(r,d) (r).udf_0_c_0_8[0] = d
#define BCM89500_A0_UDF_0_C_0_8r_GET(r) (r).udf_0_c_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_0_C_0_8r_CFG_UDF_0_C_0_8f_GET(r) (((r).udf_0_c_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_0_C_0_8r_CFG_UDF_0_C_0_8f_SET(r,f) (r).udf_0_c_0_8[0]=(((r).udf_0_c_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_C_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_0_C_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_0_C_0_8r+(1*(i)),(r._udf_0_c_0_8),1)
#define BCM89500_A0_WRITE_UDF_0_C_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_0_C_0_8r+(1*(i)),&(r._udf_0_c_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_C_0_8r BCM89500_A0_UDF_0_C_0_8r
#define UDF_0_C_0_8r_SIZE BCM89500_A0_UDF_0_C_0_8r_SIZE
typedef BCM89500_A0_UDF_0_C_0_8r_t UDF_0_C_0_8r_t;
#define UDF_0_C_0_8r_CLR BCM89500_A0_UDF_0_C_0_8r_CLR
#define UDF_0_C_0_8r_SET BCM89500_A0_UDF_0_C_0_8r_SET
#define UDF_0_C_0_8r_GET BCM89500_A0_UDF_0_C_0_8r_GET
#define UDF_0_C_0_8r_CFG_UDF_0_C_0_8f_GET BCM89500_A0_UDF_0_C_0_8r_CFG_UDF_0_C_0_8f_GET
#define UDF_0_C_0_8r_CFG_UDF_0_C_0_8f_SET BCM89500_A0_UDF_0_C_0_8r_CFG_UDF_0_C_0_8f_SET
#define READ_UDF_0_C_0_8r BCM89500_A0_READ_UDF_0_C_0_8r
#define WRITE_UDF_0_C_0_8r BCM89500_A0_WRITE_UDF_0_C_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_0_C_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_0_D_0_11
 * BLOCKS:   SYS
 * DESC:     UDFs for IPv6 Chain Rule Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_D_0_11 UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_0_D_0_11r 0x0000a1a0

#define BCM89500_A0_UDF_0_D_0_11r_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_D_0_11.
 *
 */
typedef union BCM89500_A0_UDF_0_D_0_11r_s {
	uint32_t v[1];
	uint32_t udf_0_d_0_11[1];
	uint32_t _udf_0_d_0_11;
} BCM89500_A0_UDF_0_D_0_11r_t;

#define BCM89500_A0_UDF_0_D_0_11r_CLR(r) (r).udf_0_d_0_11[0] = 0
#define BCM89500_A0_UDF_0_D_0_11r_SET(r,d) (r).udf_0_d_0_11[0] = d
#define BCM89500_A0_UDF_0_D_0_11r_GET(r) (r).udf_0_d_0_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_0_D_0_11r_CFG_UDF_0_D_0_11f_GET(r) (((r).udf_0_d_0_11[0]) & 0xff)
#define BCM89500_A0_UDF_0_D_0_11r_CFG_UDF_0_D_0_11f_SET(r,f) (r).udf_0_d_0_11[0]=(((r).udf_0_d_0_11[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_D_0_11.
 *
 */
#define BCM89500_A0_READ_UDF_0_D_0_11r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_0_D_0_11r+(1*(i)),(r._udf_0_d_0_11),1)
#define BCM89500_A0_WRITE_UDF_0_D_0_11r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_0_D_0_11r+(1*(i)),&(r._udf_0_d_0_11),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_D_0_11r BCM89500_A0_UDF_0_D_0_11r
#define UDF_0_D_0_11r_SIZE BCM89500_A0_UDF_0_D_0_11r_SIZE
typedef BCM89500_A0_UDF_0_D_0_11r_t UDF_0_D_0_11r_t;
#define UDF_0_D_0_11r_CLR BCM89500_A0_UDF_0_D_0_11r_CLR
#define UDF_0_D_0_11r_SET BCM89500_A0_UDF_0_D_0_11r_SET
#define UDF_0_D_0_11r_GET BCM89500_A0_UDF_0_D_0_11r_GET
#define UDF_0_D_0_11r_CFG_UDF_0_D_0_11f_GET BCM89500_A0_UDF_0_D_0_11r_CFG_UDF_0_D_0_11f_GET
#define UDF_0_D_0_11r_CFG_UDF_0_D_0_11f_SET BCM89500_A0_UDF_0_D_0_11r_CFG_UDF_0_D_0_11f_SET
#define READ_UDF_0_D_0_11r BCM89500_A0_READ_UDF_0_D_0_11r
#define WRITE_UDF_0_D_0_11r BCM89500_A0_WRITE_UDF_0_D_0_11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_0_D_0_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_1_A_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 1 for IPv4 packet Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_A_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_1_A_0_8r 0x0000a120

#define BCM89500_A0_UDF_1_A_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_1_A_0_8.
 *
 */
typedef union BCM89500_A0_UDF_1_A_0_8r_s {
	uint32_t v[1];
	uint32_t udf_1_a_0_8[1];
	uint32_t _udf_1_a_0_8;
} BCM89500_A0_UDF_1_A_0_8r_t;

#define BCM89500_A0_UDF_1_A_0_8r_CLR(r) (r).udf_1_a_0_8[0] = 0
#define BCM89500_A0_UDF_1_A_0_8r_SET(r,d) (r).udf_1_a_0_8[0] = d
#define BCM89500_A0_UDF_1_A_0_8r_GET(r) (r).udf_1_a_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_1_A_0_8r_CFG_UDF_1_A_0_8f_GET(r) (((r).udf_1_a_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_1_A_0_8r_CFG_UDF_1_A_0_8f_SET(r,f) (r).udf_1_a_0_8[0]=(((r).udf_1_a_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_1_A_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_1_A_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_1_A_0_8r+(1*(i)),(r._udf_1_a_0_8),1)
#define BCM89500_A0_WRITE_UDF_1_A_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_1_A_0_8r+(1*(i)),&(r._udf_1_a_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_1_A_0_8r BCM89500_A0_UDF_1_A_0_8r
#define UDF_1_A_0_8r_SIZE BCM89500_A0_UDF_1_A_0_8r_SIZE
typedef BCM89500_A0_UDF_1_A_0_8r_t UDF_1_A_0_8r_t;
#define UDF_1_A_0_8r_CLR BCM89500_A0_UDF_1_A_0_8r_CLR
#define UDF_1_A_0_8r_SET BCM89500_A0_UDF_1_A_0_8r_SET
#define UDF_1_A_0_8r_GET BCM89500_A0_UDF_1_A_0_8r_GET
#define UDF_1_A_0_8r_CFG_UDF_1_A_0_8f_GET BCM89500_A0_UDF_1_A_0_8r_CFG_UDF_1_A_0_8f_GET
#define UDF_1_A_0_8r_CFG_UDF_1_A_0_8f_SET BCM89500_A0_UDF_1_A_0_8r_CFG_UDF_1_A_0_8f_SET
#define READ_UDF_1_A_0_8r BCM89500_A0_READ_UDF_1_A_0_8r
#define WRITE_UDF_1_A_0_8r BCM89500_A0_WRITE_UDF_1_A_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_1_A_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_1_B_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 1 for IPv6 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_B_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_1_B_0_8r 0x0000a150

#define BCM89500_A0_UDF_1_B_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_1_B_0_8.
 *
 */
typedef union BCM89500_A0_UDF_1_B_0_8r_s {
	uint32_t v[1];
	uint32_t udf_1_b_0_8[1];
	uint32_t _udf_1_b_0_8;
} BCM89500_A0_UDF_1_B_0_8r_t;

#define BCM89500_A0_UDF_1_B_0_8r_CLR(r) (r).udf_1_b_0_8[0] = 0
#define BCM89500_A0_UDF_1_B_0_8r_SET(r,d) (r).udf_1_b_0_8[0] = d
#define BCM89500_A0_UDF_1_B_0_8r_GET(r) (r).udf_1_b_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_1_B_0_8r_CFG_UDF_1_B_0_8f_GET(r) (((r).udf_1_b_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_1_B_0_8r_CFG_UDF_1_B_0_8f_SET(r,f) (r).udf_1_b_0_8[0]=(((r).udf_1_b_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_1_B_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_1_B_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_1_B_0_8r+(1*(i)),(r._udf_1_b_0_8),1)
#define BCM89500_A0_WRITE_UDF_1_B_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_1_B_0_8r+(1*(i)),&(r._udf_1_b_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_1_B_0_8r BCM89500_A0_UDF_1_B_0_8r
#define UDF_1_B_0_8r_SIZE BCM89500_A0_UDF_1_B_0_8r_SIZE
typedef BCM89500_A0_UDF_1_B_0_8r_t UDF_1_B_0_8r_t;
#define UDF_1_B_0_8r_CLR BCM89500_A0_UDF_1_B_0_8r_CLR
#define UDF_1_B_0_8r_SET BCM89500_A0_UDF_1_B_0_8r_SET
#define UDF_1_B_0_8r_GET BCM89500_A0_UDF_1_B_0_8r_GET
#define UDF_1_B_0_8r_CFG_UDF_1_B_0_8f_GET BCM89500_A0_UDF_1_B_0_8r_CFG_UDF_1_B_0_8f_GET
#define UDF_1_B_0_8r_CFG_UDF_1_B_0_8f_SET BCM89500_A0_UDF_1_B_0_8r_CFG_UDF_1_B_0_8f_SET
#define READ_UDF_1_B_0_8r BCM89500_A0_READ_UDF_1_B_0_8r
#define WRITE_UDF_1_B_0_8r BCM89500_A0_WRITE_UDF_1_B_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_1_B_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_1_C_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 1 for none-IP Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_C_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_1_C_0_8r 0x0000a180

#define BCM89500_A0_UDF_1_C_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_1_C_0_8.
 *
 */
typedef union BCM89500_A0_UDF_1_C_0_8r_s {
	uint32_t v[1];
	uint32_t udf_1_c_0_8[1];
	uint32_t _udf_1_c_0_8;
} BCM89500_A0_UDF_1_C_0_8r_t;

#define BCM89500_A0_UDF_1_C_0_8r_CLR(r) (r).udf_1_c_0_8[0] = 0
#define BCM89500_A0_UDF_1_C_0_8r_SET(r,d) (r).udf_1_c_0_8[0] = d
#define BCM89500_A0_UDF_1_C_0_8r_GET(r) (r).udf_1_c_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_1_C_0_8r_CFG_UDF_1_C_0_8f_GET(r) (((r).udf_1_c_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_1_C_0_8r_CFG_UDF_1_C_0_8f_SET(r,f) (r).udf_1_c_0_8[0]=(((r).udf_1_c_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_1_C_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_1_C_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_1_C_0_8r+(1*(i)),(r._udf_1_c_0_8),1)
#define BCM89500_A0_WRITE_UDF_1_C_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_1_C_0_8r+(1*(i)),&(r._udf_1_c_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_1_C_0_8r BCM89500_A0_UDF_1_C_0_8r
#define UDF_1_C_0_8r_SIZE BCM89500_A0_UDF_1_C_0_8r_SIZE
typedef BCM89500_A0_UDF_1_C_0_8r_t UDF_1_C_0_8r_t;
#define UDF_1_C_0_8r_CLR BCM89500_A0_UDF_1_C_0_8r_CLR
#define UDF_1_C_0_8r_SET BCM89500_A0_UDF_1_C_0_8r_SET
#define UDF_1_C_0_8r_GET BCM89500_A0_UDF_1_C_0_8r_GET
#define UDF_1_C_0_8r_CFG_UDF_1_C_0_8f_GET BCM89500_A0_UDF_1_C_0_8r_CFG_UDF_1_C_0_8f_GET
#define UDF_1_C_0_8r_CFG_UDF_1_C_0_8f_SET BCM89500_A0_UDF_1_C_0_8r_CFG_UDF_1_C_0_8f_SET
#define READ_UDF_1_C_0_8r BCM89500_A0_READ_UDF_1_C_0_8r
#define WRITE_UDF_1_C_0_8r BCM89500_A0_WRITE_UDF_1_C_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_1_C_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_2_A_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 2 for IPv4 packet Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_2_A_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_2_A_0_8r 0x0000a130

#define BCM89500_A0_UDF_2_A_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_2_A_0_8.
 *
 */
typedef union BCM89500_A0_UDF_2_A_0_8r_s {
	uint32_t v[1];
	uint32_t udf_2_a_0_8[1];
	uint32_t _udf_2_a_0_8;
} BCM89500_A0_UDF_2_A_0_8r_t;

#define BCM89500_A0_UDF_2_A_0_8r_CLR(r) (r).udf_2_a_0_8[0] = 0
#define BCM89500_A0_UDF_2_A_0_8r_SET(r,d) (r).udf_2_a_0_8[0] = d
#define BCM89500_A0_UDF_2_A_0_8r_GET(r) (r).udf_2_a_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_2_A_0_8r_CFG_UDF_2_A_0_8f_GET(r) (((r).udf_2_a_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_2_A_0_8r_CFG_UDF_2_A_0_8f_SET(r,f) (r).udf_2_a_0_8[0]=(((r).udf_2_a_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_2_A_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_2_A_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_2_A_0_8r+(1*(i)),(r._udf_2_a_0_8),1)
#define BCM89500_A0_WRITE_UDF_2_A_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_2_A_0_8r+(1*(i)),&(r._udf_2_a_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_2_A_0_8r BCM89500_A0_UDF_2_A_0_8r
#define UDF_2_A_0_8r_SIZE BCM89500_A0_UDF_2_A_0_8r_SIZE
typedef BCM89500_A0_UDF_2_A_0_8r_t UDF_2_A_0_8r_t;
#define UDF_2_A_0_8r_CLR BCM89500_A0_UDF_2_A_0_8r_CLR
#define UDF_2_A_0_8r_SET BCM89500_A0_UDF_2_A_0_8r_SET
#define UDF_2_A_0_8r_GET BCM89500_A0_UDF_2_A_0_8r_GET
#define UDF_2_A_0_8r_CFG_UDF_2_A_0_8f_GET BCM89500_A0_UDF_2_A_0_8r_CFG_UDF_2_A_0_8f_GET
#define UDF_2_A_0_8r_CFG_UDF_2_A_0_8f_SET BCM89500_A0_UDF_2_A_0_8r_CFG_UDF_2_A_0_8f_SET
#define READ_UDF_2_A_0_8r BCM89500_A0_READ_UDF_2_A_0_8r
#define WRITE_UDF_2_A_0_8r BCM89500_A0_WRITE_UDF_2_A_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_2_A_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_2_B_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 2 for IPv6 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_2_B_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_2_B_0_8r 0x0000a160

#define BCM89500_A0_UDF_2_B_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_2_B_0_8.
 *
 */
typedef union BCM89500_A0_UDF_2_B_0_8r_s {
	uint32_t v[1];
	uint32_t udf_2_b_0_8[1];
	uint32_t _udf_2_b_0_8;
} BCM89500_A0_UDF_2_B_0_8r_t;

#define BCM89500_A0_UDF_2_B_0_8r_CLR(r) (r).udf_2_b_0_8[0] = 0
#define BCM89500_A0_UDF_2_B_0_8r_SET(r,d) (r).udf_2_b_0_8[0] = d
#define BCM89500_A0_UDF_2_B_0_8r_GET(r) (r).udf_2_b_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_2_B_0_8r_CFG_UDF_2_B_0_8f_GET(r) (((r).udf_2_b_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_2_B_0_8r_CFG_UDF_2_B_0_8f_SET(r,f) (r).udf_2_b_0_8[0]=(((r).udf_2_b_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_2_B_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_2_B_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_2_B_0_8r+(1*(i)),(r._udf_2_b_0_8),1)
#define BCM89500_A0_WRITE_UDF_2_B_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_2_B_0_8r+(1*(i)),&(r._udf_2_b_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_2_B_0_8r BCM89500_A0_UDF_2_B_0_8r
#define UDF_2_B_0_8r_SIZE BCM89500_A0_UDF_2_B_0_8r_SIZE
typedef BCM89500_A0_UDF_2_B_0_8r_t UDF_2_B_0_8r_t;
#define UDF_2_B_0_8r_CLR BCM89500_A0_UDF_2_B_0_8r_CLR
#define UDF_2_B_0_8r_SET BCM89500_A0_UDF_2_B_0_8r_SET
#define UDF_2_B_0_8r_GET BCM89500_A0_UDF_2_B_0_8r_GET
#define UDF_2_B_0_8r_CFG_UDF_2_B_0_8f_GET BCM89500_A0_UDF_2_B_0_8r_CFG_UDF_2_B_0_8f_GET
#define UDF_2_B_0_8r_CFG_UDF_2_B_0_8f_SET BCM89500_A0_UDF_2_B_0_8r_CFG_UDF_2_B_0_8f_SET
#define READ_UDF_2_B_0_8r BCM89500_A0_READ_UDF_2_B_0_8r
#define WRITE_UDF_2_B_0_8r BCM89500_A0_WRITE_UDF_2_B_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_2_B_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  UDF_2_C_0_8
 * BLOCKS:   SYS
 * DESC:     UDFs of slice 2 for none-IP Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_C_0_8  UDF ConfigurationEach byte of this field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,B,C,D and [N] = 0-11. The configuratin of UDF_n_X0 is in the lowest byte and the configuration of UDF_n_X1 is in the second lowest byte and so on.Following are the UDF definition..UDF_n_A0,.......,UDF_n_A8: These UDFs are used by IPv4 packets for Slice n.(n = 0,1 or 2).UDF_n_B0,.......,UDF_n_B8: These UDFs are used by IPv6 packets for Slice n.(n = 0,1 or 2).UDF_n_C0,.......,UDF_n_C8: These UDFs are used by Non-IP packets for Slice n.(n = 0,1 or 2).UDF_n_D0,.......,UDF_n_D11: These UDFs are used by IPv6 packet for the Chain Slice.Cfg_UDF_n_X[N][7:5]: the offset base000: Start of frame;010: End of L2;011: End of L3;Others: ReservedCfg_UDF_n_X[N][4:0]: the offset=N indicate the UDF starts from the location 2N bytes after the location implied by the offset base.
 *
 ******************************************************************************/
#define BCM89500_A0_UDF_2_C_0_8r 0x0000a190

#define BCM89500_A0_UDF_2_C_0_8r_SIZE 1

/*
 * This structure should be used to declare and program UDF_2_C_0_8.
 *
 */
typedef union BCM89500_A0_UDF_2_C_0_8r_s {
	uint32_t v[1];
	uint32_t udf_2_c_0_8[1];
	uint32_t _udf_2_c_0_8;
} BCM89500_A0_UDF_2_C_0_8r_t;

#define BCM89500_A0_UDF_2_C_0_8r_CLR(r) (r).udf_2_c_0_8[0] = 0
#define BCM89500_A0_UDF_2_C_0_8r_SET(r,d) (r).udf_2_c_0_8[0] = d
#define BCM89500_A0_UDF_2_C_0_8r_GET(r) (r).udf_2_c_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_UDF_2_C_0_8r_CFG_UDF_1_C_0_8f_GET(r) (((r).udf_2_c_0_8[0]) & 0xff)
#define BCM89500_A0_UDF_2_C_0_8r_CFG_UDF_1_C_0_8f_SET(r,f) (r).udf_2_c_0_8[0]=(((r).udf_2_c_0_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_2_C_0_8.
 *
 */
#define BCM89500_A0_READ_UDF_2_C_0_8r(u,i,r) cdk_robo_reg_read(u,BCM89500_A0_UDF_2_C_0_8r+(1*(i)),(r._udf_2_c_0_8),1)
#define BCM89500_A0_WRITE_UDF_2_C_0_8r(u,i,r) cdk_robo_reg_write(u,BCM89500_A0_UDF_2_C_0_8r+(1*(i)),&(r._udf_2_c_0_8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_2_C_0_8r BCM89500_A0_UDF_2_C_0_8r
#define UDF_2_C_0_8r_SIZE BCM89500_A0_UDF_2_C_0_8r_SIZE
typedef BCM89500_A0_UDF_2_C_0_8r_t UDF_2_C_0_8r_t;
#define UDF_2_C_0_8r_CLR BCM89500_A0_UDF_2_C_0_8r_CLR
#define UDF_2_C_0_8r_SET BCM89500_A0_UDF_2_C_0_8r_SET
#define UDF_2_C_0_8r_GET BCM89500_A0_UDF_2_C_0_8r_GET
#define UDF_2_C_0_8r_CFG_UDF_1_C_0_8f_GET BCM89500_A0_UDF_2_C_0_8r_CFG_UDF_1_C_0_8f_GET
#define UDF_2_C_0_8r_CFG_UDF_1_C_0_8f_SET BCM89500_A0_UDF_2_C_0_8r_CFG_UDF_1_C_0_8f_SET
#define READ_UDF_2_C_0_8r BCM89500_A0_READ_UDF_2_C_0_8r
#define WRITE_UDF_2_C_0_8r BCM89500_A0_WRITE_UDF_2_C_0_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_UDF_2_C_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  ULF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Unicast Lookup Failed Forward Map Register
 * SIZE:     16
 * FIELDS:
 *     UNI_LOOPUP_FAIL_FWD_MAP Unicast Lookup Failed Forward Map.When unicast lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_ULF_DROP_MAPr 0x00000032

#define BCM89500_A0_ULF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program ULF_DROP_MAP.
 *
 */
typedef union BCM89500_A0_ULF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t ulf_drop_map[1];
	uint32_t _ulf_drop_map;
} BCM89500_A0_ULF_DROP_MAPr_t;

#define BCM89500_A0_ULF_DROP_MAPr_CLR(r) (r).ulf_drop_map[0] = 0
#define BCM89500_A0_ULF_DROP_MAPr_SET(r,d) (r).ulf_drop_map[0] = d
#define BCM89500_A0_ULF_DROP_MAPr_GET(r) (r).ulf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET(r) (((r).ulf_drop_map[0]) & 0x1ff)
#define BCM89500_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_ULF_DROP_MAPr_RESERVEDf_GET(r) ((((r).ulf_drop_map[0]) >> 9) & 0x7f)
#define BCM89500_A0_ULF_DROP_MAPr_RESERVEDf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ULF_DROP_MAP.
 *
 */
#define BCM89500_A0_READ_ULF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM89500_A0_ULF_DROP_MAPr,(r._ulf_drop_map),2)
#define BCM89500_A0_WRITE_ULF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM89500_A0_ULF_DROP_MAPr,&(r._ulf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ULF_DROP_MAPr BCM89500_A0_ULF_DROP_MAPr
#define ULF_DROP_MAPr_SIZE BCM89500_A0_ULF_DROP_MAPr_SIZE
typedef BCM89500_A0_ULF_DROP_MAPr_t ULF_DROP_MAPr_t;
#define ULF_DROP_MAPr_CLR BCM89500_A0_ULF_DROP_MAPr_CLR
#define ULF_DROP_MAPr_SET BCM89500_A0_ULF_DROP_MAPr_SET
#define ULF_DROP_MAPr_GET BCM89500_A0_ULF_DROP_MAPr_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET BCM89500_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET BCM89500_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET
#define ULF_DROP_MAPr_RESERVEDf_GET BCM89500_A0_ULF_DROP_MAPr_RESERVEDf_GET
#define ULF_DROP_MAPr_RESERVEDf_SET BCM89500_A0_ULF_DROP_MAPr_RESERVEDf_SET
#define READ_ULF_DROP_MAPr BCM89500_A0_READ_ULF_DROP_MAPr
#define WRITE_ULF_DROP_MAPr BCM89500_A0_WRITE_ULF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_ULF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     32
 * FIELDS:
 *     FORWARD_MAP      Untag port bitmapBits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     UNTAG_MAP        Untag port bitmapBits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     MSPT_ID          MSTP ID
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_1Qm 0x20000580

#define BCM89500_A0_VLAN_1Qm_MIN 0
#define BCM89500_A0_VLAN_1Qm_MAX 4095
#define BCM89500_A0_VLAN_1Qm_CMAX(u) 4095
#define BCM89500_A0_VLAN_1Qm_SIZE 4

/*
 * This structure should be used to declare and program VLAN_1Q.
 *
 */
typedef union BCM89500_A0_VLAN_1Qm_s {
	uint32_t v[1];
	uint32_t vlan_1q[1];
	uint32_t _vlan_1q;
} BCM89500_A0_VLAN_1Qm_t;

#define BCM89500_A0_VLAN_1Qm_CLR(r) (r).vlan_1q[0] = 0
#define BCM89500_A0_VLAN_1Qm_SET(r,d) (r).vlan_1q[0] = d
#define BCM89500_A0_VLAN_1Qm_GET(r) (r).vlan_1q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) (((r).vlan_1q[0]) & 0x1ff)
#define BCM89500_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_VLAN_1Qm_UNTAG_MAPf_GET(r) ((((r).vlan_1q[0]) >> 9) & 0x1ff)
#define BCM89500_A0_VLAN_1Qm_UNTAG_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM89500_A0_VLAN_1Qm_MSPT_IDf_GET(r) ((((r).vlan_1q[0]) >> 18) & 0x7)
#define BCM89500_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM89500_A0_VLAN_1Qm_FWD_MODEf_GET(r) ((((r).vlan_1q[0]) >> 21) & 0x1)
#define BCM89500_A0_VLAN_1Qm_FWD_MODEf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM89500_A0_VLAN_1Qm_RESERVEDf_GET(r) ((((r).vlan_1q[0]) >> 22) & 0x3ff)
#define BCM89500_A0_VLAN_1Qm_RESERVEDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access VLAN_1Q.
 *
 */
#define BCM89500_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM89500_A0_VLAN_1Qm,i,(m),4)
#define BCM89500_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM89500_A0_VLAN_1Qm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM89500_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM89500_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM89500_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_CMAX(u) BCM89500_A0_VLAN_1Qm_CMAX(u)
#define VLAN_1Qm_SIZE BCM89500_A0_VLAN_1Qm_SIZE
typedef BCM89500_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM89500_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM89500_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM89500_A0_VLAN_1Qm_GET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM89500_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM89500_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_UNTAG_MAPf_GET BCM89500_A0_VLAN_1Qm_UNTAG_MAPf_GET
#define VLAN_1Qm_UNTAG_MAPf_SET BCM89500_A0_VLAN_1Qm_UNTAG_MAPf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM89500_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM89500_A0_VLAN_1Qm_MSPT_IDf_SET
#define VLAN_1Qm_FWD_MODEf_GET BCM89500_A0_VLAN_1Qm_FWD_MODEf_GET
#define VLAN_1Qm_FWD_MODEf_SET BCM89500_A0_VLAN_1Qm_FWD_MODEf_SET
#define VLAN_1Qm_RESERVEDf_GET BCM89500_A0_VLAN_1Qm_RESERVEDf_GET
#define VLAN_1Qm_RESERVEDf_SET BCM89500_A0_VLAN_1Qm_RESERVEDf_SET
#define READ_VLAN_1Qm BCM89500_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM89500_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_1Qm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL0
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 0 Registers
 * SIZE:     8
 * FIELDS:
 *     CHANGE_1P_VID_INNER Change Inner 1P VID to PVIDThis bit controls whether to replace Ingress Inner 1P VID.(ingress VID=12'h000) to PVIDFor exampleWhen this bit is zero:(Falcon DT mode compatible)Do not change the Inner tag VIDwhen this bit is one:For a double tag frame with the inner tag VID==0, chnage the innr tag VID to PVID.
 *     CHANGE_1P_VID_OUTER Change Outer 1P VID to PVIDThis bit controls whether to replace Ingress Outer 1P VID.(ingress VID=12'h000) to PVIDFor exampleWhen this bit is zero:Do not change the Outer tag VIDwhen this bit is one:a.For a single tag frame with VID==0, change the VID to PVIDb.For a double tag frame with VID==0, chnage the outer tag VID to PVID.
 *     RESERVED_0       Reserved
 *     CHANGE_1Q_VID    Change 1Q VID to PVIDThis bit controls whether to replace 1Q VID to PVID.(This bit can't to set in iDT_mode)For exampleWhen this bit is zero:No change for 1Q/ISP tag if VID/=0when this bit is one:a.For a single tag frame with VID==0, change the VID to PVIDb.For a double tag frame with VID==0, chnage the outer tag VID to PVID.
 *     RESERVED_1       Reserved
 *     VLAN_LEARN_MODE  00: SVL( Shared VLAN Learning Mode)(MAC used to hash ARL table).11:IVL(Individual VLAN Learning Mode) (MAC and VID used to hash ARL table).10= illegal Setting.01= illegal Setting.This rule applies to 1Q enable mode. dt_mode and idt_mode.
 *     VLAN_EN          When set to 1, the 802.1Q VLAN function will be enabled.This bit must be set if double tagging(dt_mode or idt_mode) is enable.
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL0r 0x00003400

#define BCM89500_A0_VLAN_CTRL0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL0.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL0r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl0[1];
	uint32_t _vlan_ctrl0;
} BCM89500_A0_VLAN_CTRL0r_t;

#define BCM89500_A0_VLAN_CTRL0r_CLR(r) (r).vlan_ctrl0[0] = 0
#define BCM89500_A0_VLAN_CTRL0r_SET(r,d) (r).vlan_ctrl0[0] = d
#define BCM89500_A0_VLAN_CTRL0r_GET(r) (r).vlan_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET(r) (((r).vlan_ctrl0[0]) & 0x1)
#define BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET(r) ((((r).vlan_ctrl0[0]) >> 1) & 0x1)
#define BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_VLAN_CTRL0r_RESERVED_0f_GET(r) ((((r).vlan_ctrl0[0]) >> 2) & 0x1)
#define BCM89500_A0_VLAN_CTRL0r_RESERVED_0f_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET(r) ((((r).vlan_ctrl0[0]) >> 3) & 0x1)
#define BCM89500_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_VLAN_CTRL0r_RESERVED_1f_GET(r) ((((r).vlan_ctrl0[0]) >> 4) & 0x1)
#define BCM89500_A0_VLAN_CTRL0r_RESERVED_1f_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET(r) ((((r).vlan_ctrl0[0]) >> 5) & 0x3)
#define BCM89500_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM89500_A0_VLAN_CTRL0r_VLAN_ENf_GET(r) ((((r).vlan_ctrl0[0]) >> 7) & 0x1)
#define BCM89500_A0_VLAN_CTRL0r_VLAN_ENf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL0.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL0r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL0r,(r._vlan_ctrl0),1)
#define BCM89500_A0_WRITE_VLAN_CTRL0r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL0r,&(r._vlan_ctrl0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL0r BCM89500_A0_VLAN_CTRL0r
#define VLAN_CTRL0r_SIZE BCM89500_A0_VLAN_CTRL0r_SIZE
typedef BCM89500_A0_VLAN_CTRL0r_t VLAN_CTRL0r_t;
#define VLAN_CTRL0r_CLR BCM89500_A0_VLAN_CTRL0r_CLR
#define VLAN_CTRL0r_SET BCM89500_A0_VLAN_CTRL0r_SET
#define VLAN_CTRL0r_GET BCM89500_A0_VLAN_CTRL0r_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET BCM89500_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET
#define VLAN_CTRL0r_RESERVED_0f_GET BCM89500_A0_VLAN_CTRL0r_RESERVED_0f_GET
#define VLAN_CTRL0r_RESERVED_0f_SET BCM89500_A0_VLAN_CTRL0r_RESERVED_0f_SET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_GET BCM89500_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_SET BCM89500_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET
#define VLAN_CTRL0r_RESERVED_1f_GET BCM89500_A0_VLAN_CTRL0r_RESERVED_1f_GET
#define VLAN_CTRL0r_RESERVED_1f_SET BCM89500_A0_VLAN_CTRL0r_RESERVED_1f_SET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_GET BCM89500_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_SET BCM89500_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET
#define VLAN_CTRL0r_VLAN_ENf_GET BCM89500_A0_VLAN_CTRL0r_VLAN_ENf_GET
#define VLAN_CTRL0r_VLAN_ENf_SET BCM89500_A0_VLAN_CTRL0r_VLAN_ENf_SET
#define READ_VLAN_CTRL0r BCM89500_A0_READ_VLAN_CTRL0r
#define WRITE_VLAN_CTRL0r BCM89500_A0_WRITE_VLAN_CTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL1
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 1 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     RESERVED_1       ReservedIt's illegal to set 0.
 *     EN_RSV_MCAST_FWDMAP When asserted, reserved multicast frames (except GMRP and GVRP) will be checked by v_fwdmap.**This rule applies to 1Q enable, dt_mode and idt_mode.
 *     EN_RSV_MCAST_UNTAG When asserted, reserved multicast frames tag/untag will be controlled by v_untagmap.When deasserted, reserved multicast frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage or idt_mode.**Reserved multicast frames except GMRP amd GVRP.
 *     RESERVED_2       ReservedIt's illegal to set 1.
 *     EN_IPMC_BYPASS_FWDMAP When asserted will not check IPMC frame with V_fwdmap.This rule applies to 1Q enable, dt_mode and idt_mode.
 *     EN_IPMC_BYPASS_UNTAG When deasserted, the IPMC frames tag/untag will be controlled by V_untagmap.When asserted, The IPMC frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage or idt_mode.
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL1r 0x00003401

#define BCM89500_A0_VLAN_CTRL1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL1.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL1r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl1[1];
	uint32_t _vlan_ctrl1;
} BCM89500_A0_VLAN_CTRL1r_t;

#define BCM89500_A0_VLAN_CTRL1r_CLR(r) (r).vlan_ctrl1[0] = 0
#define BCM89500_A0_VLAN_CTRL1r_SET(r,d) (r).vlan_ctrl1[0] = d
#define BCM89500_A0_VLAN_CTRL1r_GET(r) (r).vlan_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_0f_GET(r) (((r).vlan_ctrl1[0]) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_0f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_1f_GET(r) ((((r).vlan_ctrl1[0]) >> 1) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_1f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 2) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 3) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_2f_GET(r) ((((r).vlan_ctrl1[0]) >> 4) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_2f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 5) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 6) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_3f_GET(r) ((((r).vlan_ctrl1[0]) >> 7) & 0x1)
#define BCM89500_A0_VLAN_CTRL1r_RESERVED_3f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL1.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL1r,(r._vlan_ctrl1),1)
#define BCM89500_A0_WRITE_VLAN_CTRL1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL1r,&(r._vlan_ctrl1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL1r BCM89500_A0_VLAN_CTRL1r
#define VLAN_CTRL1r_SIZE BCM89500_A0_VLAN_CTRL1r_SIZE
typedef BCM89500_A0_VLAN_CTRL1r_t VLAN_CTRL1r_t;
#define VLAN_CTRL1r_CLR BCM89500_A0_VLAN_CTRL1r_CLR
#define VLAN_CTRL1r_SET BCM89500_A0_VLAN_CTRL1r_SET
#define VLAN_CTRL1r_GET BCM89500_A0_VLAN_CTRL1r_GET
#define VLAN_CTRL1r_RESERVED_0f_GET BCM89500_A0_VLAN_CTRL1r_RESERVED_0f_GET
#define VLAN_CTRL1r_RESERVED_0f_SET BCM89500_A0_VLAN_CTRL1r_RESERVED_0f_SET
#define VLAN_CTRL1r_RESERVED_1f_GET BCM89500_A0_VLAN_CTRL1r_RESERVED_1f_GET
#define VLAN_CTRL1r_RESERVED_1f_SET BCM89500_A0_VLAN_CTRL1r_RESERVED_1f_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET BCM89500_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_2f_GET BCM89500_A0_VLAN_CTRL1r_RESERVED_2f_GET
#define VLAN_CTRL1r_RESERVED_2f_SET BCM89500_A0_VLAN_CTRL1r_RESERVED_2f_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET BCM89500_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_3f_GET BCM89500_A0_VLAN_CTRL1r_RESERVED_3f_GET
#define VLAN_CTRL1r_RESERVED_3f_SET BCM89500_A0_VLAN_CTRL1r_RESERVED_3f_SET
#define READ_VLAN_CTRL1r BCM89500_A0_READ_VLAN_CTRL1r
#define WRITE_VLAN_CTRL1r BCM89500_A0_WRITE_VLAN_CTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL2
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 2 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     EN_MIIM_BYPASS_V_FWDMAP When set to 1, frames reveived by MII_manage port will bypass V_fwdmap checking.**This rule applies to 1Q enable, dt_mode and idt_mode.
 *     RESERVED_2       Reserved
 *     EN_GMRP_GVRP_V_FWDMAP When set to 1, GMRP,GVRP will be checked by v_fwdmap.** this rule do not apply to MII_manage EXP and SPI ports.
 *     EN_GMRP_GVRP_UNTAG_MAP When asserted, GMRP/GVRP frames tag/untag will be controlled by v_untagmap.When deasserted,GMRP/GVRP  frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage or idt_mode.
 *     RESERVED         
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL2r 0x00003402

#define BCM89500_A0_VLAN_CTRL2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL2.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL2r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl2[1];
	uint32_t _vlan_ctrl2;
} BCM89500_A0_VLAN_CTRL2r_t;

#define BCM89500_A0_VLAN_CTRL2r_CLR(r) (r).vlan_ctrl2[0] = 0
#define BCM89500_A0_VLAN_CTRL2r_SET(r,d) (r).vlan_ctrl2[0] = d
#define BCM89500_A0_VLAN_CTRL2r_GET(r) (r).vlan_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL2r_RESERVED_0f_GET(r) (((r).vlan_ctrl2[0]) & 0x3)
#define BCM89500_A0_VLAN_CTRL2r_RESERVED_0f_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM89500_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 2) & 0x1)
#define BCM89500_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_VLAN_CTRL2r_RESERVED_2f_GET(r) ((((r).vlan_ctrl2[0]) >> 3) & 0x3)
#define BCM89500_A0_VLAN_CTRL2r_RESERVED_2f_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 5) & 0x1)
#define BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 6) & 0x1)
#define BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_VLAN_CTRL2r_RESERVEDf_GET(r) ((((r).vlan_ctrl2[0]) >> 7) & 0x1)
#define BCM89500_A0_VLAN_CTRL2r_RESERVEDf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL2.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL2r,(r._vlan_ctrl2),1)
#define BCM89500_A0_WRITE_VLAN_CTRL2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL2r,&(r._vlan_ctrl2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL2r BCM89500_A0_VLAN_CTRL2r
#define VLAN_CTRL2r_SIZE BCM89500_A0_VLAN_CTRL2r_SIZE
typedef BCM89500_A0_VLAN_CTRL2r_t VLAN_CTRL2r_t;
#define VLAN_CTRL2r_CLR BCM89500_A0_VLAN_CTRL2r_CLR
#define VLAN_CTRL2r_SET BCM89500_A0_VLAN_CTRL2r_SET
#define VLAN_CTRL2r_GET BCM89500_A0_VLAN_CTRL2r_GET
#define VLAN_CTRL2r_RESERVED_0f_GET BCM89500_A0_VLAN_CTRL2r_RESERVED_0f_GET
#define VLAN_CTRL2r_RESERVED_0f_SET BCM89500_A0_VLAN_CTRL2r_RESERVED_0f_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET BCM89500_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET BCM89500_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET
#define VLAN_CTRL2r_RESERVED_2f_GET BCM89500_A0_VLAN_CTRL2r_RESERVED_2f_GET
#define VLAN_CTRL2r_RESERVED_2f_SET BCM89500_A0_VLAN_CTRL2r_RESERVED_2f_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET BCM89500_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET
#define VLAN_CTRL2r_RESERVEDf_GET BCM89500_A0_VLAN_CTRL2r_RESERVEDf_GET
#define VLAN_CTRL2r_RESERVEDf_SET BCM89500_A0_VLAN_CTRL2r_RESERVEDf_SET
#define READ_VLAN_CTRL2r BCM89500_A0_READ_VLAN_CTRL2r
#define WRITE_VLAN_CTRL2r BCM89500_A0_WRITE_VLAN_CTRL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL3
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 3 Registers
 * SIZE:     16
 * FIELDS:
 *     EN_DROP_NON1Q    When enabled , any non_1Q frame will be dropped by this port. Ports 8-0 respectively. This field makes no effect under the double tagging modes. This field is ignored by IMP port(s), the IMP port(s) won't drop non 1Q frames even this field is set.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL3r 0x00003403

#define BCM89500_A0_VLAN_CTRL3r_SIZE 2

/*
 * This structure should be used to declare and program VLAN_CTRL3.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL3r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl3[1];
	uint32_t _vlan_ctrl3;
} BCM89500_A0_VLAN_CTRL3r_t;

#define BCM89500_A0_VLAN_CTRL3r_CLR(r) (r).vlan_ctrl3[0] = 0
#define BCM89500_A0_VLAN_CTRL3r_SET(r,d) (r).vlan_ctrl3[0] = d
#define BCM89500_A0_VLAN_CTRL3r_GET(r) (r).vlan_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET(r) (((r).vlan_ctrl3[0]) & 0x1ff)
#define BCM89500_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_VLAN_CTRL3r_RESERVEDf_GET(r) ((((r).vlan_ctrl3[0]) >> 9) & 0x7f)
#define BCM89500_A0_VLAN_CTRL3r_RESERVEDf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_CTRL3.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL3r,(r._vlan_ctrl3),2)
#define BCM89500_A0_WRITE_VLAN_CTRL3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL3r,&(r._vlan_ctrl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL3r BCM89500_A0_VLAN_CTRL3r
#define VLAN_CTRL3r_SIZE BCM89500_A0_VLAN_CTRL3r_SIZE
typedef BCM89500_A0_VLAN_CTRL3r_t VLAN_CTRL3r_t;
#define VLAN_CTRL3r_CLR BCM89500_A0_VLAN_CTRL3r_CLR
#define VLAN_CTRL3r_SET BCM89500_A0_VLAN_CTRL3r_SET
#define VLAN_CTRL3r_GET BCM89500_A0_VLAN_CTRL3r_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_GET BCM89500_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_SET BCM89500_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET
#define VLAN_CTRL3r_RESERVEDf_GET BCM89500_A0_VLAN_CTRL3r_RESERVEDf_GET
#define VLAN_CTRL3r_RESERVEDf_SET BCM89500_A0_VLAN_CTRL3r_RESERVEDf_SET
#define READ_VLAN_CTRL3r BCM89500_A0_READ_VLAN_CTRL3r
#define WRITE_VLAN_CTRL3r BCM89500_A0_WRITE_VLAN_CTRL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL4
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 4 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1       Reserved
 *     RESV_MCAST_FLOOD When chip is programmed as double tag mode(dt_mode and idt_mode) and management mode.1 : flood(include all data port and CPU) reserved mcast based on the VLAN rule.0 : trap reserved mcast to CPU.reserved multicast include 01-80-c2-00-00-(00,02-2f)
 *     EN_DOUBLE_TAG    Enable double taggging mode.0:Disable double tagging mode01:Enable dt_mode(Falcon double tagging mode)10:Enable idt_mode(intelligent double tagging mode in Vulcan)when idt_mode is enable, egress VID remarking is achieved by CFP classification ID.11:Reserved
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame. In multiple chip system, a GMRP frmae received by a chip without CPU will pass it to expansion port, and eventually it will be forward to CPU.
 *     EN_MGE_REV_GVRP  When set to 1. management port ( the port with CPU) will be the destination port of GVRP frame.
 *     INGR_VID_CHK     00: forward ingress VID violation frame( VID is not in v_fwdmap). But do not learn in ARL table.01: Drop frame if frame has VID violation, not Learned.10: Do not check ingress VID violation.(Forward and Learn as no violation case)11:Forward ingress VIO violation frame to IMP, but not learn(default)**This field is ignored by IMP port(s), the IMP port(s) won't check ingress VID violation frames.
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL4r 0x00003405

#define BCM89500_A0_VLAN_CTRL4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL4.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL4r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl4[1];
	uint32_t _vlan_ctrl4;
} BCM89500_A0_VLAN_CTRL4r_t;

#define BCM89500_A0_VLAN_CTRL4r_CLR(r) (r).vlan_ctrl4[0] = 0
#define BCM89500_A0_VLAN_CTRL4r_SET(r,d) (r).vlan_ctrl4[0] = d
#define BCM89500_A0_VLAN_CTRL4r_GET(r) (r).vlan_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL4r_RESERVED_1f_GET(r) (((r).vlan_ctrl4[0]) & 0x1)
#define BCM89500_A0_VLAN_CTRL4r_RESERVED_1f_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET(r) ((((r).vlan_ctrl4[0]) >> 1) & 0x1)
#define BCM89500_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET(r) ((((r).vlan_ctrl4[0]) >> 2) & 0x3)
#define BCM89500_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 4) & 0x1)
#define BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 5) & 0x1)
#define BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET(r) ((((r).vlan_ctrl4[0]) >> 6) & 0x3)
#define BCM89500_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_CTRL4.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL4r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL4r,(r._vlan_ctrl4),1)
#define BCM89500_A0_WRITE_VLAN_CTRL4r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL4r,&(r._vlan_ctrl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL4r BCM89500_A0_VLAN_CTRL4r
#define VLAN_CTRL4r_SIZE BCM89500_A0_VLAN_CTRL4r_SIZE
typedef BCM89500_A0_VLAN_CTRL4r_t VLAN_CTRL4r_t;
#define VLAN_CTRL4r_CLR BCM89500_A0_VLAN_CTRL4r_CLR
#define VLAN_CTRL4r_SET BCM89500_A0_VLAN_CTRL4r_SET
#define VLAN_CTRL4r_GET BCM89500_A0_VLAN_CTRL4r_GET
#define VLAN_CTRL4r_RESERVED_1f_GET BCM89500_A0_VLAN_CTRL4r_RESERVED_1f_GET
#define VLAN_CTRL4r_RESERVED_1f_SET BCM89500_A0_VLAN_CTRL4r_RESERVED_1f_SET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_GET BCM89500_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_SET BCM89500_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_GET BCM89500_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_SET BCM89500_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET BCM89500_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET
#define VLAN_CTRL4r_INGR_VID_CHKf_GET BCM89500_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET
#define VLAN_CTRL4r_INGR_VID_CHKf_SET BCM89500_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET
#define READ_VLAN_CTRL4r BCM89500_A0_READ_VLAN_CTRL4r
#define WRITE_VLAN_CTRL4r BCM89500_A0_WRITE_VLAN_CTRL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL5
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 5 Registers
 * SIZE:     8
 * FIELDS:
 *     EN_CPU_RX_BYP_INNER_CRCCHK 1:The management port(IMP) will ignore CRC check.0:The management port(IMP) with CPU on it will check the CRC.
 *     RESERVED         Reserved
 *     EN_VID_FFF_FWD   0 : comply with standard, drop frame.1: forwaed frame.
 *     DROP_VTABLE_MISS When set to 1, a frame with V_table miss will be dropped.When set to 0, a frame with V_table miss will be fowarded to IMP.
 *     EGRESS_DIR_FRM_BYPASS_TRUNK_EN Egress Directed Frame Bypass Trunking Re-direction EnableSet to 1 : Egress Directed Frame From Management Port will bypass Re-Trunking Re-directed RuleSet to 0: Egress Directed Frame will From Management Port will follow Trunking Re-directed Rule.
 *     RESERVED_0       Reserved
 *     PRESV_NON1Q      - en_preserv_non_1q_frame: (default 0)When set to 1, regardless of untag map in VLAN table, non-1Q frames(including 802.1p frames) will not be changed at TX. This field makes no effect under the double tagged modes(dt_mode and idt_mode).
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL5r 0x00003406

#define BCM89500_A0_VLAN_CTRL5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL5.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL5r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl5[1];
	uint32_t _vlan_ctrl5;
} BCM89500_A0_VLAN_CTRL5r_t;

#define BCM89500_A0_VLAN_CTRL5r_CLR(r) (r).vlan_ctrl5[0] = 0
#define BCM89500_A0_VLAN_CTRL5r_SET(r,d) (r).vlan_ctrl5[0] = d
#define BCM89500_A0_VLAN_CTRL5r_GET(r) (r).vlan_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET(r) (((r).vlan_ctrl5[0]) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_VLAN_CTRL5r_RESERVEDf_GET(r) ((((r).vlan_ctrl5[0]) >> 1) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_RESERVEDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET(r) ((((r).vlan_ctrl5[0]) >> 2) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET(r) ((((r).vlan_ctrl5[0]) >> 3) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET(r) ((((r).vlan_ctrl5[0]) >> 4) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_VLAN_CTRL5r_RESERVED_0f_GET(r) ((((r).vlan_ctrl5[0]) >> 5) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_RESERVED_0f_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET(r) ((((r).vlan_ctrl5[0]) >> 6) & 0x1)
#define BCM89500_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access VLAN_CTRL5.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL5r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL5r,(r._vlan_ctrl5),1)
#define BCM89500_A0_WRITE_VLAN_CTRL5r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL5r,&(r._vlan_ctrl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL5r BCM89500_A0_VLAN_CTRL5r
#define VLAN_CTRL5r_SIZE BCM89500_A0_VLAN_CTRL5r_SIZE
typedef BCM89500_A0_VLAN_CTRL5r_t VLAN_CTRL5r_t;
#define VLAN_CTRL5r_CLR BCM89500_A0_VLAN_CTRL5r_CLR
#define VLAN_CTRL5r_SET BCM89500_A0_VLAN_CTRL5r_SET
#define VLAN_CTRL5r_GET BCM89500_A0_VLAN_CTRL5r_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET BCM89500_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET BCM89500_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET
#define VLAN_CTRL5r_RESERVEDf_GET BCM89500_A0_VLAN_CTRL5r_RESERVEDf_GET
#define VLAN_CTRL5r_RESERVEDf_SET BCM89500_A0_VLAN_CTRL5r_RESERVEDf_SET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_GET BCM89500_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_SET BCM89500_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_GET BCM89500_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_SET BCM89500_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET BCM89500_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET BCM89500_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET
#define VLAN_CTRL5r_RESERVED_0f_GET BCM89500_A0_VLAN_CTRL5r_RESERVED_0f_GET
#define VLAN_CTRL5r_RESERVED_0f_SET BCM89500_A0_VLAN_CTRL5r_RESERVED_0f_SET
#define VLAN_CTRL5r_PRESV_NON1Qf_GET BCM89500_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET
#define VLAN_CTRL5r_PRESV_NON1Qf_SET BCM89500_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET
#define READ_VLAN_CTRL5r BCM89500_A0_READ_VLAN_CTRL5r
#define WRITE_VLAN_CTRL5r BCM89500_A0_WRITE_VLAN_CTRL5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_CTRL6
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 6 Registers
 * SIZE:     8
 * FIELDS:
 *     STRICT_SFD_DETECT use_strict_sfd_detectWhen enabled, polar drops frames with no preamble and start with SFD regardless of the phase rx clk at which nibble data of SFD is received.When disabled (dfault), polar drops such frames only at certain phase of the nibble data of SFD.NOTE: This register turns on a bug fix, so should be hidden in the customer datasheet. We decided to turn it off by default for safety purpose.(Not2Release)
 *     RESERVED         Reserved
 *     DIS_ARL_BUST_LMT dis_arl_burst_lmtDisable ARL arbiter burst limit of 2 cycles.When set to 1, it disables the fix for ARL arbiter problem of not granting the high-priority request immediately. Default is 0.(Not2Release)
 *     ARL_LATE_SEL     arl_latency_selNum of extra states to accommodate ARL latency.When 3'b000, lengthen rxfsm by 2 cycles (Default).When 3'b001, lengthen rxfsm by 3 cycles.When 3'b010, lengthen rxfsm by 4 cycles.When 3'b111, lengthen rxfsm by 1 cycles.When 3'b110, lengthen rxfsm by 0 cycles.When 3'b100, lengthen rxfsm by 2 cycles and turn off pulling in fmstopped effectively by 1 cycle.When other values, behaves the same as the 3'b000 case Default is 3'b000.(Not2Release)
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_CTRL6r 0x00003407

#define BCM89500_A0_VLAN_CTRL6r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL6.
 *
 */
typedef union BCM89500_A0_VLAN_CTRL6r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl6[1];
	uint32_t _vlan_ctrl6;
} BCM89500_A0_VLAN_CTRL6r_t;

#define BCM89500_A0_VLAN_CTRL6r_CLR(r) (r).vlan_ctrl6[0] = 0
#define BCM89500_A0_VLAN_CTRL6r_SET(r,d) (r).vlan_ctrl6[0] = d
#define BCM89500_A0_VLAN_CTRL6r_GET(r) (r).vlan_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET(r) (((r).vlan_ctrl6[0]) & 0x1)
#define BCM89500_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_VLAN_CTRL6r_RESERVEDf_GET(r) ((((r).vlan_ctrl6[0]) >> 1) & 0x7)
#define BCM89500_A0_VLAN_CTRL6r_RESERVEDf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM89500_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET(r) ((((r).vlan_ctrl6[0]) >> 4) & 0x1)
#define BCM89500_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET(r) ((((r).vlan_ctrl6[0]) >> 5) & 0x7)
#define BCM89500_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access VLAN_CTRL6.
 *
 */
#define BCM89500_A0_READ_VLAN_CTRL6r(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_CTRL6r,(r._vlan_ctrl6),1)
#define BCM89500_A0_WRITE_VLAN_CTRL6r(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_CTRL6r,&(r._vlan_ctrl6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL6r BCM89500_A0_VLAN_CTRL6r
#define VLAN_CTRL6r_SIZE BCM89500_A0_VLAN_CTRL6r_SIZE
typedef BCM89500_A0_VLAN_CTRL6r_t VLAN_CTRL6r_t;
#define VLAN_CTRL6r_CLR BCM89500_A0_VLAN_CTRL6r_CLR
#define VLAN_CTRL6r_SET BCM89500_A0_VLAN_CTRL6r_SET
#define VLAN_CTRL6r_GET BCM89500_A0_VLAN_CTRL6r_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_GET BCM89500_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_SET BCM89500_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET
#define VLAN_CTRL6r_RESERVEDf_GET BCM89500_A0_VLAN_CTRL6r_RESERVEDf_GET
#define VLAN_CTRL6r_RESERVEDf_SET BCM89500_A0_VLAN_CTRL6r_RESERVEDf_SET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET BCM89500_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET BCM89500_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET
#define VLAN_CTRL6r_ARL_LATE_SELf_GET BCM89500_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET
#define VLAN_CTRL6r_ARL_LATE_SELf_SET BCM89500_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET
#define READ_VLAN_CTRL6r BCM89500_A0_READ_VLAN_CTRL6r
#define WRITE_VLAN_CTRL6r BCM89500_A0_WRITE_VLAN_CTRL6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_ITPID
 * BLOCKS:   SYS
 * DESC:     VLAN 1tags ITPID Registers
 * SIZE:     16
 * FIELDS:
 *     ITPID            The ITPID of VLAN tags packet.
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_ITPIDr 0x000093a6

#define BCM89500_A0_VLAN_ITPIDr_SIZE 2

/*
 * This structure should be used to declare and program VLAN_ITPID.
 *
 */
typedef union BCM89500_A0_VLAN_ITPIDr_s {
	uint32_t v[1];
	uint32_t vlan_itpid[1];
	uint32_t _vlan_itpid;
} BCM89500_A0_VLAN_ITPIDr_t;

#define BCM89500_A0_VLAN_ITPIDr_CLR(r) (r).vlan_itpid[0] = 0
#define BCM89500_A0_VLAN_ITPIDr_SET(r,d) (r).vlan_itpid[0] = d
#define BCM89500_A0_VLAN_ITPIDr_GET(r) (r).vlan_itpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_ITPIDr_ITPIDf_GET(r) (((r).vlan_itpid[0]) & 0xffff)
#define BCM89500_A0_VLAN_ITPIDr_ITPIDf_SET(r,f) (r).vlan_itpid[0]=(((r).vlan_itpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_ITPID.
 *
 */
#define BCM89500_A0_READ_VLAN_ITPIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_ITPIDr,(r._vlan_itpid),2)
#define BCM89500_A0_WRITE_VLAN_ITPIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_ITPIDr,&(r._vlan_itpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_ITPIDr BCM89500_A0_VLAN_ITPIDr
#define VLAN_ITPIDr_SIZE BCM89500_A0_VLAN_ITPIDr_SIZE
typedef BCM89500_A0_VLAN_ITPIDr_t VLAN_ITPIDr_t;
#define VLAN_ITPIDr_CLR BCM89500_A0_VLAN_ITPIDr_CLR
#define VLAN_ITPIDr_SET BCM89500_A0_VLAN_ITPIDr_SET
#define VLAN_ITPIDr_GET BCM89500_A0_VLAN_ITPIDr_GET
#define VLAN_ITPIDr_ITPIDf_GET BCM89500_A0_VLAN_ITPIDr_ITPIDf_GET
#define VLAN_ITPIDr_ITPIDf_SET BCM89500_A0_VLAN_ITPIDr_ITPIDf_SET
#define READ_VLAN_ITPIDr BCM89500_A0_READ_VLAN_ITPIDr
#define WRITE_VLAN_ITPIDr BCM89500_A0_WRITE_VLAN_ITPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_ITPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_MULTI_PORT_ADDR_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN Multiport Address Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_V_FWD_MAP When set to 1, MPORT_ADD0 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT0_UTG_MAP When set to 1, MPORT_ADD0 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT1_V_FWD_MAP When set to 1, MPORT_ADD1 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT1_UTG_MAP When set to 1, MPORT_ADD1 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT2_V_FWD_MAP When set to 1, MPORT_ADD2 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT2_UTG_MAP When set to 1, MPORT_ADD2 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT3_V_FWD_MAP When set to 1, MPORT_ADD3 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT3_UTG_MAP When set to 1, MPORT_ADD3 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT4_V_FWD_MAP When set to 1, MPORT_ADD4 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT4_UTG_MAP When set to 1, MPORT_ADD4 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT5_V_FWD_MAP When set to 1, MPORT_ADD5 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT5_UTG_MAP When set to 1, MPORT_ADD5 will be checked by v_untagmap** this rule do not apply to MII_manage or idt_mode.** When set to 0, MPORT_ADDx frames will be preserved tagged type of frames as follows,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frames on ingress -> tagges frames on egress.3.1p frame on ingress -> 1Q frame on egress.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr 0x0000340a

#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE 2

/*
 * This structure should be used to declare and program VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
typedef union BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_s {
	uint32_t v[1];
	uint32_t vlan_multi_port_addr_ctl[1];
	uint32_t _vlan_multi_port_addr_ctl;
} BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_t;

#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR(r) (r).vlan_multi_port_addr_ctl[0] = 0
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET(r,d) (r).vlan_multi_port_addr_ctl[0] = d
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET(r) (r).vlan_multi_port_addr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET(r) (((r).vlan_multi_port_addr_ctl[0]) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 1) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 2) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 3) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 4) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 5) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 6) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 7) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 8) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 9) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 10) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 11) & 0x1)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 12) & 0xf)
#define BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
#define BCM89500_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr,(r._vlan_multi_port_addr_ctl),2)
#define BCM89500_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr,&(r._vlan_multi_port_addr_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MULTI_PORT_ADDR_CTLr BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr
#define VLAN_MULTI_PORT_ADDR_CTLr_SIZE BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE
typedef BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_t VLAN_MULTI_PORT_ADDR_CTLr_t;
#define VLAN_MULTI_PORT_ADDR_CTLr_CLR BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR
#define VLAN_MULTI_PORT_ADDR_CTLr_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET
#define READ_VLAN_MULTI_PORT_ADDR_CTLr BCM89500_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr
#define WRITE_VLAN_MULTI_PORT_ADDR_CTLr BCM89500_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_MULTI_PORT_ADDR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  VLAN_OTPID
 * BLOCKS:   SYS
 * DESC:     VLAN 2tags OTPID Registers
 * SIZE:     16
 * FIELDS:
 *     OTPID            The OTPID of VLAN 2 tags packet.
 *
 ******************************************************************************/
#define BCM89500_A0_VLAN_OTPIDr 0x000093a8

#define BCM89500_A0_VLAN_OTPIDr_SIZE 2

/*
 * This structure should be used to declare and program VLAN_OTPID.
 *
 */
typedef union BCM89500_A0_VLAN_OTPIDr_s {
	uint32_t v[1];
	uint32_t vlan_otpid[1];
	uint32_t _vlan_otpid;
} BCM89500_A0_VLAN_OTPIDr_t;

#define BCM89500_A0_VLAN_OTPIDr_CLR(r) (r).vlan_otpid[0] = 0
#define BCM89500_A0_VLAN_OTPIDr_SET(r,d) (r).vlan_otpid[0] = d
#define BCM89500_A0_VLAN_OTPIDr_GET(r) (r).vlan_otpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_VLAN_OTPIDr_OTPIDf_GET(r) (((r).vlan_otpid[0]) & 0xffff)
#define BCM89500_A0_VLAN_OTPIDr_OTPIDf_SET(r,f) (r).vlan_otpid[0]=(((r).vlan_otpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_OTPID.
 *
 */
#define BCM89500_A0_READ_VLAN_OTPIDr(u,r) cdk_robo_reg_read(u,BCM89500_A0_VLAN_OTPIDr,(r._vlan_otpid),2)
#define BCM89500_A0_WRITE_VLAN_OTPIDr(u,r) cdk_robo_reg_write(u,BCM89500_A0_VLAN_OTPIDr,&(r._vlan_otpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_OTPIDr BCM89500_A0_VLAN_OTPIDr
#define VLAN_OTPIDr_SIZE BCM89500_A0_VLAN_OTPIDr_SIZE
typedef BCM89500_A0_VLAN_OTPIDr_t VLAN_OTPIDr_t;
#define VLAN_OTPIDr_CLR BCM89500_A0_VLAN_OTPIDr_CLR
#define VLAN_OTPIDr_SET BCM89500_A0_VLAN_OTPIDr_SET
#define VLAN_OTPIDr_GET BCM89500_A0_VLAN_OTPIDr_GET
#define VLAN_OTPIDr_OTPIDf_GET BCM89500_A0_VLAN_OTPIDr_OTPIDf_GET
#define VLAN_OTPIDr_OTPIDf_SET BCM89500_A0_VLAN_OTPIDr_OTPIDf_SET
#define READ_VLAN_OTPIDr BCM89500_A0_READ_VLAN_OTPIDr
#define WRITE_VLAN_OTPIDr BCM89500_A0_WRITE_VLAN_OTPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_VLAN_OTPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  WAN_PORT_SEL
 * BLOCKS:   SYS
 * DESC:     WAN Port select Register
 * SIZE:     16
 * FIELDS:
 *     WAN_SELECT       WAN Ports SelectionThis field selects the WAN ports. when set to '1', the corresponding port is the WAN port.bit5: Port 5 can be selected as WAN port only when IMP1 is disabled.bit6: reserved.
 *     RESERVED_0       Reserved
 *     EN_MAN2WAN       0: mgmt-port only uses egress direct frame to WAN-port.1: mgmt-port could send non-egress direct frame to WAN-port.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_WAN_PORT_SELr 0x00000026

#define BCM89500_A0_WAN_PORT_SELr_SIZE 2

/*
 * This structure should be used to declare and program WAN_PORT_SEL.
 *
 */
typedef union BCM89500_A0_WAN_PORT_SELr_s {
	uint32_t v[1];
	uint32_t wan_port_sel[1];
	uint32_t _wan_port_sel;
} BCM89500_A0_WAN_PORT_SELr_t;

#define BCM89500_A0_WAN_PORT_SELr_CLR(r) (r).wan_port_sel[0] = 0
#define BCM89500_A0_WAN_PORT_SELr_SET(r,d) (r).wan_port_sel[0] = d
#define BCM89500_A0_WAN_PORT_SELr_GET(r) (r).wan_port_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_WAN_PORT_SELr_WAN_SELECTf_GET(r) (((r).wan_port_sel[0]) & 0xff)
#define BCM89500_A0_WAN_PORT_SELr_WAN_SELECTf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM89500_A0_WAN_PORT_SELr_RESERVED_0f_GET(r) ((((r).wan_port_sel[0]) >> 8) & 0x1)
#define BCM89500_A0_WAN_PORT_SELr_RESERVED_0f_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM89500_A0_WAN_PORT_SELr_EN_MAN2WANf_GET(r) ((((r).wan_port_sel[0]) >> 9) & 0x1)
#define BCM89500_A0_WAN_PORT_SELr_EN_MAN2WANf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM89500_A0_WAN_PORT_SELr_RESERVED_1f_GET(r) ((((r).wan_port_sel[0]) >> 10) & 0x3f)
#define BCM89500_A0_WAN_PORT_SELr_RESERVED_1f_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access WAN_PORT_SEL.
 *
 */
#define BCM89500_A0_READ_WAN_PORT_SELr(u,r) cdk_robo_reg_read(u,BCM89500_A0_WAN_PORT_SELr,(r._wan_port_sel),2)
#define BCM89500_A0_WRITE_WAN_PORT_SELr(u,r) cdk_robo_reg_write(u,BCM89500_A0_WAN_PORT_SELr,&(r._wan_port_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_PORT_SELr BCM89500_A0_WAN_PORT_SELr
#define WAN_PORT_SELr_SIZE BCM89500_A0_WAN_PORT_SELr_SIZE
typedef BCM89500_A0_WAN_PORT_SELr_t WAN_PORT_SELr_t;
#define WAN_PORT_SELr_CLR BCM89500_A0_WAN_PORT_SELr_CLR
#define WAN_PORT_SELr_SET BCM89500_A0_WAN_PORT_SELr_SET
#define WAN_PORT_SELr_GET BCM89500_A0_WAN_PORT_SELr_GET
#define WAN_PORT_SELr_WAN_SELECTf_GET BCM89500_A0_WAN_PORT_SELr_WAN_SELECTf_GET
#define WAN_PORT_SELr_WAN_SELECTf_SET BCM89500_A0_WAN_PORT_SELr_WAN_SELECTf_SET
#define WAN_PORT_SELr_RESERVED_0f_GET BCM89500_A0_WAN_PORT_SELr_RESERVED_0f_GET
#define WAN_PORT_SELr_RESERVED_0f_SET BCM89500_A0_WAN_PORT_SELr_RESERVED_0f_SET
#define WAN_PORT_SELr_EN_MAN2WANf_GET BCM89500_A0_WAN_PORT_SELr_EN_MAN2WANf_GET
#define WAN_PORT_SELr_EN_MAN2WANf_SET BCM89500_A0_WAN_PORT_SELr_EN_MAN2WANf_SET
#define WAN_PORT_SELr_RESERVED_1f_GET BCM89500_A0_WAN_PORT_SELr_RESERVED_1f_GET
#define WAN_PORT_SELr_RESERVED_1f_SET BCM89500_A0_WAN_PORT_SELr_RESERVED_1f_SET
#define READ_WAN_PORT_SELr BCM89500_A0_READ_WAN_PORT_SELr
#define WRITE_WAN_PORT_SELr BCM89500_A0_WRITE_WAN_PORT_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_WAN_PORT_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  WAN_SLEEP_TIMER
 * BLOCKS:   SYS
 * DESC:     WAN Port Sleep Timer Register
 * SIZE:     16
 * FIELDS:
 *     WAN_SLEEP_TIMER  WAN Sleep Timer.The configuration value of WAN port(port 5) sleep timer to indicate the desired sleep recovery time(i.e. wake-up time). When the timer is set by the CPU to a non-zero value. it puts the corresponding WAN port to sleep. The wake-up time is the set value decrease 1.The unit is 1 usec
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_WAN_SLEEP_TIMERr 0x00000314

#define BCM89500_A0_WAN_SLEEP_TIMERr_SIZE 2

/*
 * This structure should be used to declare and program WAN_SLEEP_TIMER.
 *
 */
typedef union BCM89500_A0_WAN_SLEEP_TIMERr_s {
	uint32_t v[1];
	uint32_t wan_sleep_timer[1];
	uint32_t _wan_sleep_timer;
} BCM89500_A0_WAN_SLEEP_TIMERr_t;

#define BCM89500_A0_WAN_SLEEP_TIMERr_CLR(r) (r).wan_sleep_timer[0] = 0
#define BCM89500_A0_WAN_SLEEP_TIMERr_SET(r,d) (r).wan_sleep_timer[0] = d
#define BCM89500_A0_WAN_SLEEP_TIMERr_GET(r) (r).wan_sleep_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_GET(r) (((r).wan_sleep_timer[0]) & 0x1fff)
#define BCM89500_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_SET(r,f) (r).wan_sleep_timer[0]=(((r).wan_sleep_timer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM89500_A0_WAN_SLEEP_TIMERr_RESERVEDf_GET(r) ((((r).wan_sleep_timer[0]) >> 13) & 0x7)
#define BCM89500_A0_WAN_SLEEP_TIMERr_RESERVEDf_SET(r,f) (r).wan_sleep_timer[0]=(((r).wan_sleep_timer[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access WAN_SLEEP_TIMER.
 *
 */
#define BCM89500_A0_READ_WAN_SLEEP_TIMERr(u,r) cdk_robo_reg_read(u,BCM89500_A0_WAN_SLEEP_TIMERr,(r._wan_sleep_timer),2)
#define BCM89500_A0_WRITE_WAN_SLEEP_TIMERr(u,r) cdk_robo_reg_write(u,BCM89500_A0_WAN_SLEEP_TIMERr,&(r._wan_sleep_timer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_SLEEP_TIMERr BCM89500_A0_WAN_SLEEP_TIMERr
#define WAN_SLEEP_TIMERr_SIZE BCM89500_A0_WAN_SLEEP_TIMERr_SIZE
typedef BCM89500_A0_WAN_SLEEP_TIMERr_t WAN_SLEEP_TIMERr_t;
#define WAN_SLEEP_TIMERr_CLR BCM89500_A0_WAN_SLEEP_TIMERr_CLR
#define WAN_SLEEP_TIMERr_SET BCM89500_A0_WAN_SLEEP_TIMERr_SET
#define WAN_SLEEP_TIMERr_GET BCM89500_A0_WAN_SLEEP_TIMERr_GET
#define WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_GET BCM89500_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_GET
#define WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_SET BCM89500_A0_WAN_SLEEP_TIMERr_WAN_SLEEP_TIMERf_SET
#define WAN_SLEEP_TIMERr_RESERVEDf_GET BCM89500_A0_WAN_SLEEP_TIMERr_RESERVEDf_GET
#define WAN_SLEEP_TIMERr_RESERVEDf_SET BCM89500_A0_WAN_SLEEP_TIMERr_RESERVEDf_SET
#define READ_WAN_SLEEP_TIMERr BCM89500_A0_READ_WAN_SLEEP_TIMERr
#define WRITE_WAN_SLEEP_TIMERr BCM89500_A0_WRITE_WAN_SLEEP_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_WAN_SLEEP_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  WATCH_DOG_CTRL
 * BLOCKS:   SYS
 * DESC:     Watch Dog Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_RST_SWITCH    Enable Reset Switch Code(Not2Release).
 *     EN_RST_REGFILE   Enable Reset Register(Not2Release).
 *     EN_RELOAD_EEPROM Enable Reload EEPROM after software Reset(Not2Release).
 *     EN_AUTO_RST      Enable watch dog Auto-Reset(in dumb system)(Not2Release).
 *     EN_SW_RESET      Enable Switch Software Reset.Set 1'b1 to reset switch only. All switch's registers will be reset to their default values, the EEPROM will be reloaded, and memory clear will be performed.
 *     RESERVED         Reserved
 *     EN_CHIP_RST      Enable Chip Software Reset.Set 1'b1 to reset both switch and soc. All registers (including SoC PLL's control registers) in both SoC and switch will be reset to their default values, the EEPROM will be reloaded, memory clear will be performed, and the ARM core will reboot.
 *     SOFTWARE_RESET   Global Software Reset. (EN_SW_RST or EN_CHIP_RST must be enabled as well). Set 1'b1 to trigger reset process. *** Reset Process except Strap value. When reset process is done, this bit is cleared to 1'b0.
 *
 ******************************************************************************/
#define BCM89500_A0_WATCH_DOG_CTRLr 0x00000079

#define BCM89500_A0_WATCH_DOG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program WATCH_DOG_CTRL.
 *
 */
typedef union BCM89500_A0_WATCH_DOG_CTRLr_s {
	uint32_t v[1];
	uint32_t watch_dog_ctrl[1];
	uint32_t _watch_dog_ctrl;
} BCM89500_A0_WATCH_DOG_CTRLr_t;

#define BCM89500_A0_WATCH_DOG_CTRLr_CLR(r) (r).watch_dog_ctrl[0] = 0
#define BCM89500_A0_WATCH_DOG_CTRLr_SET(r,d) (r).watch_dog_ctrl[0] = d
#define BCM89500_A0_WATCH_DOG_CTRLr_GET(r) (r).watch_dog_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_GET(r) (((r).watch_dog_ctrl[0]) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET(r) ((((r).watch_dog_ctrl[0]) >> 1) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET(r) ((((r).watch_dog_ctrl[0]) >> 2) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_GET(r) ((((r).watch_dog_ctrl[0]) >> 3) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 4) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM89500_A0_WATCH_DOG_CTRLr_RESERVEDf_GET(r) ((((r).watch_dog_ctrl[0]) >> 5) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_RESERVEDf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_CHIP_RSTf_GET(r) ((((r).watch_dog_ctrl[0]) >> 6) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_EN_CHIP_RSTf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM89500_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 7) & 0x1)
#define BCM89500_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access WATCH_DOG_CTRL.
 *
 */
#define BCM89500_A0_READ_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_read(u,BCM89500_A0_WATCH_DOG_CTRLr,(r._watch_dog_ctrl),1)
#define BCM89500_A0_WRITE_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_write(u,BCM89500_A0_WATCH_DOG_CTRLr,&(r._watch_dog_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_CTRLr BCM89500_A0_WATCH_DOG_CTRLr
#define WATCH_DOG_CTRLr_SIZE BCM89500_A0_WATCH_DOG_CTRLr_SIZE
typedef BCM89500_A0_WATCH_DOG_CTRLr_t WATCH_DOG_CTRLr_t;
#define WATCH_DOG_CTRLr_CLR BCM89500_A0_WATCH_DOG_CTRLr_CLR
#define WATCH_DOG_CTRLr_SET BCM89500_A0_WATCH_DOG_CTRLr_SET
#define WATCH_DOG_CTRLr_GET BCM89500_A0_WATCH_DOG_CTRLr_GET
#define WATCH_DOG_CTRLr_EN_RST_SWITCHf_GET BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_GET
#define WATCH_DOG_CTRLr_EN_RST_SWITCHf_SET BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_SWITCHf_SET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET BCM89500_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET BCM89500_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET BCM89500_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET
#define WATCH_DOG_CTRLr_EN_AUTO_RSTf_GET BCM89500_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_GET
#define WATCH_DOG_CTRLr_EN_AUTO_RSTf_SET BCM89500_A0_WATCH_DOG_CTRLr_EN_AUTO_RSTf_SET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_GET BCM89500_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_SET BCM89500_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET
#define WATCH_DOG_CTRLr_RESERVEDf_GET BCM89500_A0_WATCH_DOG_CTRLr_RESERVEDf_GET
#define WATCH_DOG_CTRLr_RESERVEDf_SET BCM89500_A0_WATCH_DOG_CTRLr_RESERVEDf_SET
#define WATCH_DOG_CTRLr_EN_CHIP_RSTf_GET BCM89500_A0_WATCH_DOG_CTRLr_EN_CHIP_RSTf_GET
#define WATCH_DOG_CTRLr_EN_CHIP_RSTf_SET BCM89500_A0_WATCH_DOG_CTRLr_EN_CHIP_RSTf_SET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET BCM89500_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET BCM89500_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET
#define READ_WATCH_DOG_CTRLr BCM89500_A0_READ_WATCH_DOG_CTRLr
#define WRITE_WATCH_DOG_CTRLr BCM89500_A0_WRITE_WATCH_DOG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_WATCH_DOG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  WATCH_DOG_RPT1
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 1 Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TX_PORT_HUNG_INDICATOR Tx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_WATCH_DOG_RPT1r 0x0000007a

#define BCM89500_A0_WATCH_DOG_RPT1r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT1.
 *
 */
typedef union BCM89500_A0_WATCH_DOG_RPT1r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt1[1];
	uint32_t _watch_dog_rpt1;
} BCM89500_A0_WATCH_DOG_RPT1r_t;

#define BCM89500_A0_WATCH_DOG_RPT1r_CLR(r) (r).watch_dog_rpt1[0] = 0
#define BCM89500_A0_WATCH_DOG_RPT1r_SET(r,d) (r).watch_dog_rpt1[0] = d
#define BCM89500_A0_WATCH_DOG_RPT1r_GET(r) (r).watch_dog_rpt1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt1[0]) & 0x1ff)
#define BCM89500_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_WATCH_DOG_RPT1r_RESERVEDf_GET(r) ((((r).watch_dog_rpt1[0]) >> 9) & 0x7f)
#define BCM89500_A0_WATCH_DOG_RPT1r_RESERVEDf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT1.
 *
 */
#define BCM89500_A0_READ_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_read(u,BCM89500_A0_WATCH_DOG_RPT1r,(r._watch_dog_rpt1),2)
#define BCM89500_A0_WRITE_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_write(u,BCM89500_A0_WATCH_DOG_RPT1r,&(r._watch_dog_rpt1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT1r BCM89500_A0_WATCH_DOG_RPT1r
#define WATCH_DOG_RPT1r_SIZE BCM89500_A0_WATCH_DOG_RPT1r_SIZE
typedef BCM89500_A0_WATCH_DOG_RPT1r_t WATCH_DOG_RPT1r_t;
#define WATCH_DOG_RPT1r_CLR BCM89500_A0_WATCH_DOG_RPT1r_CLR
#define WATCH_DOG_RPT1r_SET BCM89500_A0_WATCH_DOG_RPT1r_SET
#define WATCH_DOG_RPT1r_GET BCM89500_A0_WATCH_DOG_RPT1r_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET BCM89500_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET BCM89500_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT1r_RESERVEDf_GET BCM89500_A0_WATCH_DOG_RPT1r_RESERVEDf_GET
#define WATCH_DOG_RPT1r_RESERVEDf_SET BCM89500_A0_WATCH_DOG_RPT1r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT1r BCM89500_A0_READ_WATCH_DOG_RPT1r
#define WRITE_WATCH_DOG_RPT1r BCM89500_A0_WRITE_WATCH_DOG_RPT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_WATCH_DOG_RPT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  WATCH_DOG_RPT2
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 2 Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     RX_PORT_HUNG_INDICATOR Rx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_WATCH_DOG_RPT2r 0x0000007c

#define BCM89500_A0_WATCH_DOG_RPT2r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT2.
 *
 */
typedef union BCM89500_A0_WATCH_DOG_RPT2r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt2[1];
	uint32_t _watch_dog_rpt2;
} BCM89500_A0_WATCH_DOG_RPT2r_t;

#define BCM89500_A0_WATCH_DOG_RPT2r_CLR(r) (r).watch_dog_rpt2[0] = 0
#define BCM89500_A0_WATCH_DOG_RPT2r_SET(r,d) (r).watch_dog_rpt2[0] = d
#define BCM89500_A0_WATCH_DOG_RPT2r_GET(r) (r).watch_dog_rpt2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt2[0]) & 0x1ff)
#define BCM89500_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_WATCH_DOG_RPT2r_RESERVEDf_GET(r) ((((r).watch_dog_rpt2[0]) >> 9) & 0x7f)
#define BCM89500_A0_WATCH_DOG_RPT2r_RESERVEDf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT2.
 *
 */
#define BCM89500_A0_READ_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_read(u,BCM89500_A0_WATCH_DOG_RPT2r,(r._watch_dog_rpt2),2)
#define BCM89500_A0_WRITE_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_write(u,BCM89500_A0_WATCH_DOG_RPT2r,&(r._watch_dog_rpt2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT2r BCM89500_A0_WATCH_DOG_RPT2r
#define WATCH_DOG_RPT2r_SIZE BCM89500_A0_WATCH_DOG_RPT2r_SIZE
typedef BCM89500_A0_WATCH_DOG_RPT2r_t WATCH_DOG_RPT2r_t;
#define WATCH_DOG_RPT2r_CLR BCM89500_A0_WATCH_DOG_RPT2r_CLR
#define WATCH_DOG_RPT2r_SET BCM89500_A0_WATCH_DOG_RPT2r_SET
#define WATCH_DOG_RPT2r_GET BCM89500_A0_WATCH_DOG_RPT2r_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET BCM89500_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET BCM89500_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT2r_RESERVEDf_GET BCM89500_A0_WATCH_DOG_RPT2r_RESERVEDf_GET
#define WATCH_DOG_RPT2r_RESERVEDf_SET BCM89500_A0_WATCH_DOG_RPT2r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT2r BCM89500_A0_READ_WATCH_DOG_RPT2r
#define WRITE_WATCH_DOG_RPT2r BCM89500_A0_WRITE_WATCH_DOG_RPT2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_WATCH_DOG_RPT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM89500_A0
 * REGISTER:  WATCH_DOG_RPT3
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 3 Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     ARL_HUNG_INDICATOR ARL Indicator.Bit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM89500_A0_WATCH_DOG_RPT3r 0x0000007e

#define BCM89500_A0_WATCH_DOG_RPT3r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT3.
 *
 */
typedef union BCM89500_A0_WATCH_DOG_RPT3r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt3[1];
	uint32_t _watch_dog_rpt3;
} BCM89500_A0_WATCH_DOG_RPT3r_t;

#define BCM89500_A0_WATCH_DOG_RPT3r_CLR(r) (r).watch_dog_rpt3[0] = 0
#define BCM89500_A0_WATCH_DOG_RPT3r_SET(r,d) (r).watch_dog_rpt3[0] = d
#define BCM89500_A0_WATCH_DOG_RPT3r_GET(r) (r).watch_dog_rpt3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM89500_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt3[0]) & 0x1ff)
#define BCM89500_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM89500_A0_WATCH_DOG_RPT3r_RESERVEDf_GET(r) ((((r).watch_dog_rpt3[0]) >> 9) & 0x7f)
#define BCM89500_A0_WATCH_DOG_RPT3r_RESERVEDf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT3.
 *
 */
#define BCM89500_A0_READ_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_read(u,BCM89500_A0_WATCH_DOG_RPT3r,(r._watch_dog_rpt3),2)
#define BCM89500_A0_WRITE_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_write(u,BCM89500_A0_WATCH_DOG_RPT3r,&(r._watch_dog_rpt3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT3r BCM89500_A0_WATCH_DOG_RPT3r
#define WATCH_DOG_RPT3r_SIZE BCM89500_A0_WATCH_DOG_RPT3r_SIZE
typedef BCM89500_A0_WATCH_DOG_RPT3r_t WATCH_DOG_RPT3r_t;
#define WATCH_DOG_RPT3r_CLR BCM89500_A0_WATCH_DOG_RPT3r_CLR
#define WATCH_DOG_RPT3r_SET BCM89500_A0_WATCH_DOG_RPT3r_SET
#define WATCH_DOG_RPT3r_GET BCM89500_A0_WATCH_DOG_RPT3r_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET BCM89500_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET BCM89500_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT3r_RESERVEDf_GET BCM89500_A0_WATCH_DOG_RPT3r_RESERVEDf_GET
#define WATCH_DOG_RPT3r_RESERVEDf_SET BCM89500_A0_WATCH_DOG_RPT3r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT3r BCM89500_A0_READ_WATCH_DOG_RPT3r
#define WRITE_WATCH_DOG_RPT3r BCM89500_A0_WRITE_WATCH_DOG_RPT3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM89500_A0_WATCH_DOG_RPT3r'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM89500_A0_DEFS_H__ */
