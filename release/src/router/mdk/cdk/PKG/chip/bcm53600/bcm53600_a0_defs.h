#ifndef __BCM53600_A0_DEFS_H__
#define __BCM53600_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM53600_A0.
 * This file provides all basic definitions required to program the BCM53600_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CPIC/IMP port */
#define BCM53600_A0_CPIC_PORT           24

/* Additional block types */
#define BCM53600_A0_BLKTYPE_CPIC        0
#define BCM53600_A0_BLKTYPE_EPIC        1
#define BCM53600_A0_BLKTYPE_EXP         2
#define BCM53600_A0_BLKTYPE_GPIC        3
#define BCM53600_A0_BLKTYPE_SPI         4
#define BCM53600_A0_BLKTYPE_SYS         5


/* Chip-specific flags */
#define BCM53600_A0_CHIP_FLAG_FPGA      0x80000000

#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM53600_A0_CPIC_PORT

#define BLKTYPE_CPIC                    BCM53600_A0_BLKTYPE_CPIC
#define BLKTYPE_EPIC                    BCM53600_A0_BLKTYPE_EPIC
#define BLKTYPE_EXP                     BCM53600_A0_BLKTYPE_EXP
#define BLKTYPE_GPIC                    BCM53600_A0_BLKTYPE_GPIC
#define BLKTYPE_SPI                     BCM53600_A0_BLKTYPE_SPI
#define BLKTYPE_SYS                     BCM53600_A0_BLKTYPE_SYS

#define CHIP_FLAG_FPGA                  BCM53600_A0_CHIP_FLAG_FPGA

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AGEOUT_CTL
 * BLOCKS:   SYS
 * DESC:     Ageout Control Registers
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PORT      Use to select the Port ID we want aged out.
 *     RESERVED_0       Reserved
 *     AGE_EN_VID       Use to select the VLAN ID we want aged out.
 *     SPT_AGE_EN       Use to select the SPT ID we want aged out.
 *     AGE_EN_LAG       Use to select the LAG group ID we want aged out.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_AGEOUT_CTLr 0x0000040c

#define BCM53600_A0_AGEOUT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AGEOUT_CTL.
 *
 */
typedef union BCM53600_A0_AGEOUT_CTLr_s {
	uint32_t v[1];
	uint32_t ageout_ctl[1];
	uint32_t _ageout_ctl;
} BCM53600_A0_AGEOUT_CTLr_t;

#define BCM53600_A0_AGEOUT_CTLr_CLR(r) (r).ageout_ctl[0] = 0
#define BCM53600_A0_AGEOUT_CTLr_SET(r,d) (r).ageout_ctl[0] = d
#define BCM53600_A0_AGEOUT_CTLr_GET(r) (r).ageout_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AGEOUT_CTLr_AGE_EN_PORTf_GET(r) (((r).ageout_ctl[0]) & 0x1f)
#define BCM53600_A0_AGEOUT_CTLr_AGE_EN_PORTf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_AGEOUT_CTLr_RESERVED_0f_GET(r) ((((r).ageout_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_AGEOUT_CTLr_RESERVED_0f_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_AGEOUT_CTLr_AGE_EN_VIDf_GET(r) ((((r).ageout_ctl[0]) >> 6) & 0xfff)
#define BCM53600_A0_AGEOUT_CTLr_AGE_EN_VIDf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53600_A0_AGEOUT_CTLr_SPT_AGE_ENf_GET(r) ((((r).ageout_ctl[0]) >> 18) & 0xff)
#define BCM53600_A0_AGEOUT_CTLr_SPT_AGE_ENf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0xff << 18)) | ((((uint32_t)f) & 0xff) << 18))
#define BCM53600_A0_AGEOUT_CTLr_AGE_EN_LAGf_GET(r) ((((r).ageout_ctl[0]) >> 26) & 0xf)
#define BCM53600_A0_AGEOUT_CTLr_AGE_EN_LAGf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))
#define BCM53600_A0_AGEOUT_CTLr_RESERVED_1f_GET(r) ((((r).ageout_ctl[0]) >> 30) & 0x3)
#define BCM53600_A0_AGEOUT_CTLr_RESERVED_1f_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access AGEOUT_CTL.
 *
 */
#define BCM53600_A0_READ_AGEOUT_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AGEOUT_CTLr,(r._ageout_ctl),4)
#define BCM53600_A0_WRITE_AGEOUT_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AGEOUT_CTLr,&(r._ageout_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGEOUT_CTLr BCM53600_A0_AGEOUT_CTLr
#define AGEOUT_CTLr_SIZE BCM53600_A0_AGEOUT_CTLr_SIZE
typedef BCM53600_A0_AGEOUT_CTLr_t AGEOUT_CTLr_t;
#define AGEOUT_CTLr_CLR BCM53600_A0_AGEOUT_CTLr_CLR
#define AGEOUT_CTLr_SET BCM53600_A0_AGEOUT_CTLr_SET
#define AGEOUT_CTLr_GET BCM53600_A0_AGEOUT_CTLr_GET
#define AGEOUT_CTLr_AGE_EN_PORTf_GET BCM53600_A0_AGEOUT_CTLr_AGE_EN_PORTf_GET
#define AGEOUT_CTLr_AGE_EN_PORTf_SET BCM53600_A0_AGEOUT_CTLr_AGE_EN_PORTf_SET
#define AGEOUT_CTLr_RESERVED_0f_GET BCM53600_A0_AGEOUT_CTLr_RESERVED_0f_GET
#define AGEOUT_CTLr_RESERVED_0f_SET BCM53600_A0_AGEOUT_CTLr_RESERVED_0f_SET
#define AGEOUT_CTLr_AGE_EN_VIDf_GET BCM53600_A0_AGEOUT_CTLr_AGE_EN_VIDf_GET
#define AGEOUT_CTLr_AGE_EN_VIDf_SET BCM53600_A0_AGEOUT_CTLr_AGE_EN_VIDf_SET
#define AGEOUT_CTLr_SPT_AGE_ENf_GET BCM53600_A0_AGEOUT_CTLr_SPT_AGE_ENf_GET
#define AGEOUT_CTLr_SPT_AGE_ENf_SET BCM53600_A0_AGEOUT_CTLr_SPT_AGE_ENf_SET
#define AGEOUT_CTLr_AGE_EN_LAGf_GET BCM53600_A0_AGEOUT_CTLr_AGE_EN_LAGf_GET
#define AGEOUT_CTLr_AGE_EN_LAGf_SET BCM53600_A0_AGEOUT_CTLr_AGE_EN_LAGf_SET
#define AGEOUT_CTLr_RESERVED_1f_GET BCM53600_A0_AGEOUT_CTLr_RESERVED_1f_GET
#define AGEOUT_CTLr_RESERVED_1f_SET BCM53600_A0_AGEOUT_CTLr_RESERVED_1f_SET
#define READ_AGEOUT_CTLr BCM53600_A0_READ_AGEOUT_CTLr
#define WRITE_AGEOUT_CTLr BCM53600_A0_WRITE_AGEOUT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AGEOUT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  ANADV
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     ADV_SEL_FIELD    Indicates 802.3
 *     ADV_B10T         1 = Advertise 10BASE-T.
 *     ADV_B10T_FDX     1 = Advertise 10BASE-T full-duplex full-duplex.0 = Do not advertise 10BASE-T full-duplex.
 *     ADV_B100X        1 = Advertise 100BASE-X.
 *     ADV_B100X_FDX    1 = Advertise 100BASE-X full-duplex full-duplex.0 = Do not advertise 100BASE-X full-duplex.
 *     ADV_B100T4       1 = Advertise T4 capability.0 = Do not advertise T4 capability.
 *     ADV_PAUSE_CAP    1 = pause operation for full-duplex.
 *     RESV_TECH        
 *     REMOTE_FAULT     1 = Transmit remote fault.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = next page ability is enable.0 = next page ability is disable.
 *
 ******************************************************************************/
#define BCM53600_A0_ANADVr 0x0000a008

#define BCM53600_A0_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program ANADV.
 *
 */
typedef union BCM53600_A0_ANADVr_s {
	uint32_t v[1];
	uint32_t anadv[1];
	uint32_t _anadv;
} BCM53600_A0_ANADVr_t;

#define BCM53600_A0_ANADVr_CLR(r) (r).anadv[0] = 0
#define BCM53600_A0_ANADVr_SET(r,d) (r).anadv[0] = d
#define BCM53600_A0_ANADVr_GET(r) (r).anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ANADVr_ADV_SEL_FIELDf_GET(r) (((r).anadv[0]) & 0x1f)
#define BCM53600_A0_ANADVr_ADV_SEL_FIELDf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_ANADVr_ADV_B10Tf_GET(r) ((((r).anadv[0]) >> 5) & 0x1)
#define BCM53600_A0_ANADVr_ADV_B10Tf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).anadv[0]) >> 6) & 0x1)
#define BCM53600_A0_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_ANADVr_ADV_B100Xf_GET(r) ((((r).anadv[0]) >> 7) & 0x1)
#define BCM53600_A0_ANADVr_ADV_B100Xf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).anadv[0]) >> 8) & 0x1)
#define BCM53600_A0_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_ANADVr_ADV_B100T4f_GET(r) ((((r).anadv[0]) >> 9) & 0x1)
#define BCM53600_A0_ANADVr_ADV_B100T4f_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).anadv[0]) >> 10) & 0x1)
#define BCM53600_A0_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_ANADVr_RESV_TECHf_GET(r) ((((r).anadv[0]) >> 11) & 0x3)
#define BCM53600_A0_ANADVr_RESV_TECHf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_ANADVr_REMOTE_FAULTf_GET(r) ((((r).anadv[0]) >> 13) & 0x1)
#define BCM53600_A0_ANADVr_REMOTE_FAULTf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_ANADVr_RESERVEDf_GET(r) ((((r).anadv[0]) >> 14) & 0x1)
#define BCM53600_A0_ANADVr_RESERVEDf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_ANADVr_NEXT_PAGEf_GET(r) ((((r).anadv[0]) >> 15) & 0x1)
#define BCM53600_A0_ANADVr_NEXT_PAGEf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANADV.
 *
 */
#define BCM53600_A0_READ_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_ANADVr,(r._anadv),2)
#define BCM53600_A0_WRITE_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_ANADVr,&(r._anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANADVr BCM53600_A0_ANADVr
#define ANADVr_SIZE BCM53600_A0_ANADVr_SIZE
typedef BCM53600_A0_ANADVr_t ANADVr_t;
#define ANADVr_CLR BCM53600_A0_ANADVr_CLR
#define ANADVr_SET BCM53600_A0_ANADVr_SET
#define ANADVr_GET BCM53600_A0_ANADVr_GET
#define ANADVr_ADV_SEL_FIELDf_GET BCM53600_A0_ANADVr_ADV_SEL_FIELDf_GET
#define ANADVr_ADV_SEL_FIELDf_SET BCM53600_A0_ANADVr_ADV_SEL_FIELDf_SET
#define ANADVr_ADV_B10Tf_GET BCM53600_A0_ANADVr_ADV_B10Tf_GET
#define ANADVr_ADV_B10Tf_SET BCM53600_A0_ANADVr_ADV_B10Tf_SET
#define ANADVr_ADV_B10T_FDXf_GET BCM53600_A0_ANADVr_ADV_B10T_FDXf_GET
#define ANADVr_ADV_B10T_FDXf_SET BCM53600_A0_ANADVr_ADV_B10T_FDXf_SET
#define ANADVr_ADV_B100Xf_GET BCM53600_A0_ANADVr_ADV_B100Xf_GET
#define ANADVr_ADV_B100Xf_SET BCM53600_A0_ANADVr_ADV_B100Xf_SET
#define ANADVr_ADV_B100X_FDXf_GET BCM53600_A0_ANADVr_ADV_B100X_FDXf_GET
#define ANADVr_ADV_B100X_FDXf_SET BCM53600_A0_ANADVr_ADV_B100X_FDXf_SET
#define ANADVr_ADV_B100T4f_GET BCM53600_A0_ANADVr_ADV_B100T4f_GET
#define ANADVr_ADV_B100T4f_SET BCM53600_A0_ANADVr_ADV_B100T4f_SET
#define ANADVr_ADV_PAUSE_CAPf_GET BCM53600_A0_ANADVr_ADV_PAUSE_CAPf_GET
#define ANADVr_ADV_PAUSE_CAPf_SET BCM53600_A0_ANADVr_ADV_PAUSE_CAPf_SET
#define ANADVr_RESV_TECHf_GET BCM53600_A0_ANADVr_RESV_TECHf_GET
#define ANADVr_RESV_TECHf_SET BCM53600_A0_ANADVr_RESV_TECHf_SET
#define ANADVr_REMOTE_FAULTf_GET BCM53600_A0_ANADVr_REMOTE_FAULTf_GET
#define ANADVr_REMOTE_FAULTf_SET BCM53600_A0_ANADVr_REMOTE_FAULTf_SET
#define ANADVr_RESERVEDf_GET BCM53600_A0_ANADVr_RESERVEDf_GET
#define ANADVr_RESERVEDf_SET BCM53600_A0_ANADVr_RESERVEDf_SET
#define ANADVr_NEXT_PAGEf_GET BCM53600_A0_ANADVr_NEXT_PAGEf_GET
#define ANADVr_NEXT_PAGEf_SET BCM53600_A0_ANADVr_NEXT_PAGEf_SET
#define READ_ANADVr BCM53600_A0_READ_ANADVr
#define WRITE_ANADVr BCM53600_A0_WRITE_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  ANEXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABLE       1 = Link partner has auto-negotiation capability.0 = Link partner does not have auto-negotiation capability.
 *     PAGE_RECEIVED    1 = New page has been received.0 = New page has not been received.
 *     NEXT_PAGE_ABLE   1 = Next Page able.
 *     LP_NEXT_PAGE_ABLE 1 = Link partner has Next Page capability.0 = Link partner does not have Next Page capability.
 *     PD_FAULT         1 = Parallel detection fault.0 = No parallel detection fault.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_ANEXPr 0x0000a00c

#define BCM53600_A0_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program ANEXP.
 *
 */
typedef union BCM53600_A0_ANEXPr_s {
	uint32_t v[1];
	uint32_t anexp[1];
	uint32_t _anexp;
} BCM53600_A0_ANEXPr_t;

#define BCM53600_A0_ANEXPr_CLR(r) (r).anexp[0] = 0
#define BCM53600_A0_ANEXPr_SET(r,d) (r).anexp[0] = d
#define BCM53600_A0_ANEXPr_GET(r) (r).anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ANEXPr_LP_AN_ABLEf_GET(r) (((r).anexp[0]) & 0x1)
#define BCM53600_A0_ANEXPr_LP_AN_ABLEf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_ANEXPr_PAGE_RECEIVEDf_GET(r) ((((r).anexp[0]) >> 1) & 0x1)
#define BCM53600_A0_ANEXPr_PAGE_RECEIVEDf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).anexp[0]) >> 2) & 0x1)
#define BCM53600_A0_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_GET(r) ((((r).anexp[0]) >> 3) & 0x1)
#define BCM53600_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_ANEXPr_PD_FAULTf_GET(r) ((((r).anexp[0]) >> 4) & 0x1)
#define BCM53600_A0_ANEXPr_PD_FAULTf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_ANEXPr_RESERVEDf_GET(r) ((((r).anexp[0]) >> 5) & 0x7ff)
#define BCM53600_A0_ANEXPr_RESERVEDf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))

/*
 * These macros can be used to access ANEXP.
 *
 */
#define BCM53600_A0_READ_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_ANEXPr,(r._anexp),2)
#define BCM53600_A0_WRITE_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_ANEXPr,&(r._anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANEXPr BCM53600_A0_ANEXPr
#define ANEXPr_SIZE BCM53600_A0_ANEXPr_SIZE
typedef BCM53600_A0_ANEXPr_t ANEXPr_t;
#define ANEXPr_CLR BCM53600_A0_ANEXPr_CLR
#define ANEXPr_SET BCM53600_A0_ANEXPr_SET
#define ANEXPr_GET BCM53600_A0_ANEXPr_GET
#define ANEXPr_LP_AN_ABLEf_GET BCM53600_A0_ANEXPr_LP_AN_ABLEf_GET
#define ANEXPr_LP_AN_ABLEf_SET BCM53600_A0_ANEXPr_LP_AN_ABLEf_SET
#define ANEXPr_PAGE_RECEIVEDf_GET BCM53600_A0_ANEXPr_PAGE_RECEIVEDf_GET
#define ANEXPr_PAGE_RECEIVEDf_SET BCM53600_A0_ANEXPr_PAGE_RECEIVEDf_SET
#define ANEXPr_NEXT_PAGE_ABLEf_GET BCM53600_A0_ANEXPr_NEXT_PAGE_ABLEf_GET
#define ANEXPr_NEXT_PAGE_ABLEf_SET BCM53600_A0_ANEXPr_NEXT_PAGE_ABLEf_SET
#define ANEXPr_LP_NEXT_PAGE_ABLEf_GET BCM53600_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_GET
#define ANEXPr_LP_NEXT_PAGE_ABLEf_SET BCM53600_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_SET
#define ANEXPr_PD_FAULTf_GET BCM53600_A0_ANEXPr_PD_FAULTf_GET
#define ANEXPr_PD_FAULTf_SET BCM53600_A0_ANEXPr_PD_FAULTf_SET
#define ANEXPr_RESERVEDf_GET BCM53600_A0_ANEXPr_RESERVEDf_GET
#define ANEXPr_RESERVEDf_SET BCM53600_A0_ANEXPr_RESERVEDf_SET
#define READ_ANEXPr BCM53600_A0_READ_ANEXPr
#define WRITE_ANEXPr BCM53600_A0_WRITE_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  ANLPA
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     LP_ADV_SEL_FIELD Link partner selector field.
 *     LP_ADV_B10T      Link partner has 10BASE-T capability.
 *     LP_ADV_B10T_FDX  Link partner has 10BASE-T FDX capability.
 *     LP_ADV_B100X     Link partner has 100BASE-X capability.
 *     LP_ADV_B100X_FDX Link partner has 100BASE-X FDX capability.
 *     LP_ADV_B100T4    Link partner has 100BASE-T4 capability.
 *     LP_ADV_PAUSE     Link partner has pause capability.
 *     RESV_TECH        
 *     LP_REMOTE_FAULT  Link partner remote fault indicator.
 *     LP_ACK           Link partner acknowledge bit.
 *     LP_NEXT_PAGE     Link partner Next Page bit.
 *
 ******************************************************************************/
#define BCM53600_A0_ANLPAr 0x0000a00a

#define BCM53600_A0_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program ANLPA.
 *
 */
typedef union BCM53600_A0_ANLPAr_s {
	uint32_t v[1];
	uint32_t anlpa[1];
	uint32_t _anlpa;
} BCM53600_A0_ANLPAr_t;

#define BCM53600_A0_ANLPAr_CLR(r) (r).anlpa[0] = 0
#define BCM53600_A0_ANLPAr_SET(r,d) (r).anlpa[0] = d
#define BCM53600_A0_ANLPAr_GET(r) (r).anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ANLPAr_LP_ADV_SEL_FIELDf_GET(r) (((r).anlpa[0]) & 0x1f)
#define BCM53600_A0_ANLPAr_LP_ADV_SEL_FIELDf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_ANLPAr_LP_ADV_B10Tf_GET(r) ((((r).anlpa[0]) >> 5) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ADV_B10Tf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_ANLPAr_LP_ADV_B10T_FDXf_GET(r) ((((r).anlpa[0]) >> 6) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ADV_B10T_FDXf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_ANLPAr_LP_ADV_B100Xf_GET(r) ((((r).anlpa[0]) >> 7) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ADV_B100Xf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_ANLPAr_LP_ADV_B100X_FDXf_GET(r) ((((r).anlpa[0]) >> 8) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ADV_B100X_FDXf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_ANLPAr_LP_ADV_B100T4f_GET(r) ((((r).anlpa[0]) >> 9) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ADV_B100T4f_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_ANLPAr_LP_ADV_PAUSEf_GET(r) ((((r).anlpa[0]) >> 10) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ADV_PAUSEf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_ANLPAr_RESV_TECHf_GET(r) ((((r).anlpa[0]) >> 11) & 0x3)
#define BCM53600_A0_ANLPAr_RESV_TECHf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_ANLPAr_LP_REMOTE_FAULTf_GET(r) ((((r).anlpa[0]) >> 13) & 0x1)
#define BCM53600_A0_ANLPAr_LP_REMOTE_FAULTf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_ANLPAr_LP_ACKf_GET(r) ((((r).anlpa[0]) >> 14) & 0x1)
#define BCM53600_A0_ANLPAr_LP_ACKf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_ANLPAr_LP_NEXT_PAGEf_GET(r) ((((r).anlpa[0]) >> 15) & 0x1)
#define BCM53600_A0_ANLPAr_LP_NEXT_PAGEf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANLPA.
 *
 */
#define BCM53600_A0_READ_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_ANLPAr,(r._anlpa),2)
#define BCM53600_A0_WRITE_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_ANLPAr,&(r._anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANLPAr BCM53600_A0_ANLPAr
#define ANLPAr_SIZE BCM53600_A0_ANLPAr_SIZE
typedef BCM53600_A0_ANLPAr_t ANLPAr_t;
#define ANLPAr_CLR BCM53600_A0_ANLPAr_CLR
#define ANLPAr_SET BCM53600_A0_ANLPAr_SET
#define ANLPAr_GET BCM53600_A0_ANLPAr_GET
#define ANLPAr_LP_ADV_SEL_FIELDf_GET BCM53600_A0_ANLPAr_LP_ADV_SEL_FIELDf_GET
#define ANLPAr_LP_ADV_SEL_FIELDf_SET BCM53600_A0_ANLPAr_LP_ADV_SEL_FIELDf_SET
#define ANLPAr_LP_ADV_B10Tf_GET BCM53600_A0_ANLPAr_LP_ADV_B10Tf_GET
#define ANLPAr_LP_ADV_B10Tf_SET BCM53600_A0_ANLPAr_LP_ADV_B10Tf_SET
#define ANLPAr_LP_ADV_B10T_FDXf_GET BCM53600_A0_ANLPAr_LP_ADV_B10T_FDXf_GET
#define ANLPAr_LP_ADV_B10T_FDXf_SET BCM53600_A0_ANLPAr_LP_ADV_B10T_FDXf_SET
#define ANLPAr_LP_ADV_B100Xf_GET BCM53600_A0_ANLPAr_LP_ADV_B100Xf_GET
#define ANLPAr_LP_ADV_B100Xf_SET BCM53600_A0_ANLPAr_LP_ADV_B100Xf_SET
#define ANLPAr_LP_ADV_B100X_FDXf_GET BCM53600_A0_ANLPAr_LP_ADV_B100X_FDXf_GET
#define ANLPAr_LP_ADV_B100X_FDXf_SET BCM53600_A0_ANLPAr_LP_ADV_B100X_FDXf_SET
#define ANLPAr_LP_ADV_B100T4f_GET BCM53600_A0_ANLPAr_LP_ADV_B100T4f_GET
#define ANLPAr_LP_ADV_B100T4f_SET BCM53600_A0_ANLPAr_LP_ADV_B100T4f_SET
#define ANLPAr_LP_ADV_PAUSEf_GET BCM53600_A0_ANLPAr_LP_ADV_PAUSEf_GET
#define ANLPAr_LP_ADV_PAUSEf_SET BCM53600_A0_ANLPAr_LP_ADV_PAUSEf_SET
#define ANLPAr_RESV_TECHf_GET BCM53600_A0_ANLPAr_RESV_TECHf_GET
#define ANLPAr_RESV_TECHf_SET BCM53600_A0_ANLPAr_RESV_TECHf_SET
#define ANLPAr_LP_REMOTE_FAULTf_GET BCM53600_A0_ANLPAr_LP_REMOTE_FAULTf_GET
#define ANLPAr_LP_REMOTE_FAULTf_SET BCM53600_A0_ANLPAr_LP_REMOTE_FAULTf_SET
#define ANLPAr_LP_ACKf_GET BCM53600_A0_ANLPAr_LP_ACKf_GET
#define ANLPAr_LP_ACKf_SET BCM53600_A0_ANLPAr_LP_ACKf_SET
#define ANLPAr_LP_NEXT_PAGEf_GET BCM53600_A0_ANLPAr_LP_NEXT_PAGEf_GET
#define ANLPAr_LP_NEXT_PAGEf_SET BCM53600_A0_ANLPAr_LP_NEXT_PAGEf_SET
#define READ_ANLPAr BCM53600_A0_READ_ANLPAr
#define WRITE_ANLPAr BCM53600_A0_WRITE_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  ANNXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       Message/Unformatted Code Field.
 *     TOGGLE           1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     ACK_2            1 = Will comply with message.0 = Can not comply with message.
 *     MESSAGE_PAGE     1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53600_A0_ANNXPr 0x0000a00e

#define BCM53600_A0_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program ANNXP.
 *
 */
typedef union BCM53600_A0_ANNXPr_s {
	uint32_t v[1];
	uint32_t annxp[1];
	uint32_t _annxp;
} BCM53600_A0_ANNXPr_t;

#define BCM53600_A0_ANNXPr_CLR(r) (r).annxp[0] = 0
#define BCM53600_A0_ANNXPr_SET(r,d) (r).annxp[0] = d
#define BCM53600_A0_ANNXPr_GET(r) (r).annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ANNXPr_CODE_FIELDf_GET(r) (((r).annxp[0]) & 0x7ff)
#define BCM53600_A0_ANNXPr_CODE_FIELDf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53600_A0_ANNXPr_TOGGLEf_GET(r) ((((r).annxp[0]) >> 11) & 0x1)
#define BCM53600_A0_ANNXPr_TOGGLEf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_ANNXPr_ACK_2f_GET(r) ((((r).annxp[0]) >> 12) & 0x1)
#define BCM53600_A0_ANNXPr_ACK_2f_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_ANNXPr_MESSAGE_PAGEf_GET(r) ((((r).annxp[0]) >> 13) & 0x1)
#define BCM53600_A0_ANNXPr_MESSAGE_PAGEf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_ANNXPr_RESERVEDf_GET(r) ((((r).annxp[0]) >> 14) & 0x1)
#define BCM53600_A0_ANNXPr_RESERVEDf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_ANNXPr_NEXT_PAGEf_GET(r) ((((r).annxp[0]) >> 15) & 0x1)
#define BCM53600_A0_ANNXPr_NEXT_PAGEf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANNXP.
 *
 */
#define BCM53600_A0_READ_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_ANNXPr,(r._annxp),2)
#define BCM53600_A0_WRITE_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_ANNXPr,&(r._annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANNXPr BCM53600_A0_ANNXPr
#define ANNXPr_SIZE BCM53600_A0_ANNXPr_SIZE
typedef BCM53600_A0_ANNXPr_t ANNXPr_t;
#define ANNXPr_CLR BCM53600_A0_ANNXPr_CLR
#define ANNXPr_SET BCM53600_A0_ANNXPr_SET
#define ANNXPr_GET BCM53600_A0_ANNXPr_GET
#define ANNXPr_CODE_FIELDf_GET BCM53600_A0_ANNXPr_CODE_FIELDf_GET
#define ANNXPr_CODE_FIELDf_SET BCM53600_A0_ANNXPr_CODE_FIELDf_SET
#define ANNXPr_TOGGLEf_GET BCM53600_A0_ANNXPr_TOGGLEf_GET
#define ANNXPr_TOGGLEf_SET BCM53600_A0_ANNXPr_TOGGLEf_SET
#define ANNXPr_ACK_2f_GET BCM53600_A0_ANNXPr_ACK_2f_GET
#define ANNXPr_ACK_2f_SET BCM53600_A0_ANNXPr_ACK_2f_SET
#define ANNXPr_MESSAGE_PAGEf_GET BCM53600_A0_ANNXPr_MESSAGE_PAGEf_GET
#define ANNXPr_MESSAGE_PAGEf_SET BCM53600_A0_ANNXPr_MESSAGE_PAGEf_SET
#define ANNXPr_RESERVEDf_GET BCM53600_A0_ANNXPr_RESERVEDf_GET
#define ANNXPr_RESERVEDf_SET BCM53600_A0_ANNXPr_RESERVEDf_SET
#define ANNXPr_NEXT_PAGEf_GET BCM53600_A0_ANNXPr_NEXT_PAGEf_GET
#define ANNXPr_NEXT_PAGEf_SET BCM53600_A0_ANNXPr_NEXT_PAGEf_SET
#define READ_ANNXPr BCM53600_A0_READ_ANNXPr
#define WRITE_ANNXPr BCM53600_A0_WRITE_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  ARL_INT
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     284
 * FIELDS:
 *     MAC0_MACADDR     MAC0_MACADDR[47:12]
 *     MAC0_PORTID_R    MAC0_PORTID_R
 *     MAC0_RESERVED0_R MAC0_RESERVED0_R
 *     MAC0_V_PORTID    MAC0_V_PORTID[3:0]
 *     MAC0_RESERVED1_R MAC0_RESERVED1_R[1:0]
 *     MAC0_VID_R       MAC0_VID_R[11:0]
 *     MAC0_STATIC      MAC0_STATIC
 *     MAC0_AGE         MAC0_AGE[2:0]
 *     MAC0_VA          MAC0_VA[1:0]
 *     MAC0_USER        MAC0_USER[2:0]
 *     MAC0_CON         MAC0_CON[1:0]
 *     MAC1_MACADDR     MAC1_MACADDR[47:12]
 *     MAC1_PORTID_R    MAC1_PORTID_R
 *     MAC1_RESERVED0_R MAC1_RESERVED0_R
 *     MAC1_V_PORTID    MAC1_V_PORTID[3:0]
 *     MAC1_RESERVED1_R MAC1_RESERVED1_R[1:0]
 *     MAC1_VID_R       MAC1_VID_R[11:0]
 *     MAC1_STATIC      MAC1_STATIC
 *     MAC1_AGE         MAC1_AGE[2:0]
 *     MAC1_VA          MAC1_VA[1:0]
 *     MAC1_USER        MAC1_USER[2:0]
 *     MAC1_CON         MAC1_CON[1:0]
 *     MAC2_MACADDR     MAC2_MACADDR[47:12]
 *     MAC2_PORTID_R    MAC2_PORTID_R
 *     MAC2_RESERVED0_R MAC2_RESERVED0_R
 *     MAC2_V_PORTID    MAC2_V_PORTID[3:0]
 *     MAC2_RESERVED1_R MAC2_RESERVED1_R[1:0]
 *     MAC2_VID_R       MAC2_VID_R[11:0]
 *     MAC2_STATIC      MAC2_STATIC
 *     MAC2_AGE         MAC2_AGE[2:0]
 *     MAC2_VA          MAC2_VA[1:0]
 *     MAC2_USER        MAC2_USER[2:0]
 *     MAC2_CON         MAC2_CON[1:0]
 *     MAC3_MACADDR     MAC3_MACADDR[47:12]
 *     MAC3_PORTID_R    MAC3_PORTID_R
 *     MAC3_RESERVED0_R MAC3_RESERVED0_R
 *     MAC3_V_PORTID    MAC3_V_PORTID[3:0]
 *     MAC3_RESERVED1_R MAC3_RESERVED1_R[1:0]
 *     MAC3_VID_R       MAC3_VID_R[11:0]
 *     MAC3_STATIC      MAC3_STATIC
 *     MAC3_AGE         MAC3_AGE[2:0]
 *     MAC3_VA          MAC3_VA[1:0]
 *     MAC3_USER        MAC3_USER[2:0]
 *     MAC3_CON         MAC3_CON[1:0]
 *
 ******************************************************************************/
#define BCM53600_A0_ARL_INTm 0x00000000

#define BCM53600_A0_ARL_INTm_MIN 0
#define BCM53600_A0_ARL_INTm_MAX 16383
#define BCM53600_A0_ARL_INTm_CMAX(u) 16383
#define BCM53600_A0_ARL_INTm_SIZE 36

/*
 * This structure should be used to declare and program ARL_INT.
 *
 */
typedef union BCM53600_A0_ARL_INTm_s {
	uint32_t v[9];
	uint32_t arl_int[9];
	uint32_t _arl_int;
} BCM53600_A0_ARL_INTm_t;

#define BCM53600_A0_ARL_INTm_CLR(r) CDK_MEMSET(&((r)._arl_int), 0, sizeof(BCM53600_A0_ARL_INTm_t))
#define BCM53600_A0_ARL_INTm_SET(r,i,d) (r).arl_int[i] = d
#define BCM53600_A0_ARL_INTm_GET(r,i) (r).arl_int[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ARL_INTm_MAC0_MACADDRf_GET(r,a) cdk_field_get((r).arl_int,0,35,a)
#define BCM53600_A0_ARL_INTm_MAC0_MACADDRf_SET(r,a) cdk_field_set((r).arl_int,0,35,a)
#define BCM53600_A0_ARL_INTm_MAC0_PORTID_Rf_GET(r) ((((r).arl_int[1]) >> 4) & 0x1f)
#define BCM53600_A0_ARL_INTm_MAC0_PORTID_Rf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM53600_A0_ARL_INTm_MAC0_RESERVED0_Rf_GET(r) ((((r).arl_int[1]) >> 9) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC0_RESERVED0_Rf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_ARL_INTm_MAC0_V_PORTIDf_GET(r) ((((r).arl_int[1]) >> 10) & 0xf)
#define BCM53600_A0_ARL_INTm_MAC0_V_PORTIDf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM53600_A0_ARL_INTm_MAC0_RESERVED1_Rf_GET(r) ((((r).arl_int[1]) >> 14) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC0_RESERVED1_Rf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53600_A0_ARL_INTm_MAC0_VID_Rf_GET(r) ((((r).arl_int[1]) >> 16) & 0xfff)
#define BCM53600_A0_ARL_INTm_MAC0_VID_Rf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_ARL_INTm_MAC0_STATICf_GET(r) ((((r).arl_int[1]) >> 28) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC0_STATICf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53600_A0_ARL_INTm_MAC0_AGEf_GET(r) ((((r).arl_int[1]) >> 29) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC0_AGEf_SET(r,f) (r).arl_int[1]=(((r).arl_int[1] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM53600_A0_ARL_INTm_MAC0_VAf_GET(r) (((r).arl_int[2]) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC0_VAf_SET(r,f) (r).arl_int[2]=(((r).arl_int[2] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_ARL_INTm_MAC0_USERf_GET(r) ((((r).arl_int[2]) >> 2) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC0_USERf_SET(r,f) (r).arl_int[2]=(((r).arl_int[2] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53600_A0_ARL_INTm_MAC0_CONf_GET(r) ((((r).arl_int[2]) >> 5) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC0_CONf_SET(r,f) (r).arl_int[2]=(((r).arl_int[2] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53600_A0_ARL_INTm_MAC1_MACADDRf_GET(r,a) cdk_field_get((r).arl_int,71,106,a)
#define BCM53600_A0_ARL_INTm_MAC1_MACADDRf_SET(r,a) cdk_field_set((r).arl_int,71,106,a)
#define BCM53600_A0_ARL_INTm_MAC1_PORTID_Rf_GET(r) ((((r).arl_int[3]) >> 11) & 0x1f)
#define BCM53600_A0_ARL_INTm_MAC1_PORTID_Rf_SET(r,f) (r).arl_int[3]=(((r).arl_int[3] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCM53600_A0_ARL_INTm_MAC1_RESERVED0_Rf_GET(r) ((((r).arl_int[3]) >> 16) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC1_RESERVED0_Rf_SET(r,f) (r).arl_int[3]=(((r).arl_int[3] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53600_A0_ARL_INTm_MAC1_V_PORTIDf_GET(r) ((((r).arl_int[3]) >> 17) & 0xf)
#define BCM53600_A0_ARL_INTm_MAC1_V_PORTIDf_SET(r,f) (r).arl_int[3]=(((r).arl_int[3] & ~((uint32_t)0xf << 17)) | ((((uint32_t)f) & 0xf) << 17))
#define BCM53600_A0_ARL_INTm_MAC1_RESERVED1_Rf_GET(r) ((((r).arl_int[3]) >> 21) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC1_RESERVED1_Rf_SET(r,f) (r).arl_int[3]=(((r).arl_int[3] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM53600_A0_ARL_INTm_MAC1_VID_Rf_GET(r) cdk_field32_get((r).arl_int,119,130)
#define BCM53600_A0_ARL_INTm_MAC1_VID_Rf_SET(r,f) cdk_field32_set((r).arl_int,119,130,f)
#define BCM53600_A0_ARL_INTm_MAC1_STATICf_GET(r) ((((r).arl_int[4]) >> 3) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC1_STATICf_SET(r,f) (r).arl_int[4]=(((r).arl_int[4] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_ARL_INTm_MAC1_AGEf_GET(r) ((((r).arl_int[4]) >> 4) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC1_AGEf_SET(r,f) (r).arl_int[4]=(((r).arl_int[4] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53600_A0_ARL_INTm_MAC1_VAf_GET(r) ((((r).arl_int[4]) >> 7) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC1_VAf_SET(r,f) (r).arl_int[4]=(((r).arl_int[4] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_ARL_INTm_MAC1_USERf_GET(r) ((((r).arl_int[4]) >> 9) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC1_USERf_SET(r,f) (r).arl_int[4]=(((r).arl_int[4] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53600_A0_ARL_INTm_MAC1_CONf_GET(r) ((((r).arl_int[4]) >> 12) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC1_CONf_SET(r,f) (r).arl_int[4]=(((r).arl_int[4] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_ARL_INTm_MAC2_MACADDRf_GET(r,a) cdk_field_get((r).arl_int,142,177,a)
#define BCM53600_A0_ARL_INTm_MAC2_MACADDRf_SET(r,a) cdk_field_set((r).arl_int,142,177,a)
#define BCM53600_A0_ARL_INTm_MAC2_PORTID_Rf_GET(r) ((((r).arl_int[5]) >> 18) & 0x1f)
#define BCM53600_A0_ARL_INTm_MAC2_PORTID_Rf_SET(r,f) (r).arl_int[5]=(((r).arl_int[5] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM53600_A0_ARL_INTm_MAC2_RESERVED0_Rf_GET(r) ((((r).arl_int[5]) >> 23) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC2_RESERVED0_Rf_SET(r,f) (r).arl_int[5]=(((r).arl_int[5] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53600_A0_ARL_INTm_MAC2_V_PORTIDf_GET(r) ((((r).arl_int[5]) >> 24) & 0xf)
#define BCM53600_A0_ARL_INTm_MAC2_V_PORTIDf_SET(r,f) (r).arl_int[5]=(((r).arl_int[5] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_ARL_INTm_MAC2_RESERVED1_Rf_GET(r) ((((r).arl_int[5]) >> 28) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC2_RESERVED1_Rf_SET(r,f) (r).arl_int[5]=(((r).arl_int[5] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_ARL_INTm_MAC2_VID_Rf_GET(r) cdk_field32_get((r).arl_int,190,201)
#define BCM53600_A0_ARL_INTm_MAC2_VID_Rf_SET(r,f) cdk_field32_set((r).arl_int,190,201,f)
#define BCM53600_A0_ARL_INTm_MAC2_STATICf_GET(r) ((((r).arl_int[6]) >> 10) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC2_STATICf_SET(r,f) (r).arl_int[6]=(((r).arl_int[6] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_ARL_INTm_MAC2_AGEf_GET(r) ((((r).arl_int[6]) >> 11) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC2_AGEf_SET(r,f) (r).arl_int[6]=(((r).arl_int[6] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53600_A0_ARL_INTm_MAC2_VAf_GET(r) ((((r).arl_int[6]) >> 14) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC2_VAf_SET(r,f) (r).arl_int[6]=(((r).arl_int[6] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53600_A0_ARL_INTm_MAC2_USERf_GET(r) ((((r).arl_int[6]) >> 16) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC2_USERf_SET(r,f) (r).arl_int[6]=(((r).arl_int[6] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53600_A0_ARL_INTm_MAC2_CONf_GET(r) ((((r).arl_int[6]) >> 19) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC2_CONf_SET(r,f) (r).arl_int[6]=(((r).arl_int[6] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53600_A0_ARL_INTm_MAC3_MACADDRf_GET(r,a) cdk_field_get((r).arl_int,213,248,a)
#define BCM53600_A0_ARL_INTm_MAC3_MACADDRf_SET(r,a) cdk_field_set((r).arl_int,213,248,a)
#define BCM53600_A0_ARL_INTm_MAC3_PORTID_Rf_GET(r) ((((r).arl_int[7]) >> 25) & 0x1f)
#define BCM53600_A0_ARL_INTm_MAC3_PORTID_Rf_SET(r,f) (r).arl_int[7]=(((r).arl_int[7] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM53600_A0_ARL_INTm_MAC3_RESERVED0_Rf_GET(r) ((((r).arl_int[7]) >> 30) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC3_RESERVED0_Rf_SET(r,f) (r).arl_int[7]=(((r).arl_int[7] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53600_A0_ARL_INTm_MAC3_V_PORTIDf_GET(r) cdk_field32_get((r).arl_int,255,258)
#define BCM53600_A0_ARL_INTm_MAC3_V_PORTIDf_SET(r,f) cdk_field32_set((r).arl_int,255,258,f)
#define BCM53600_A0_ARL_INTm_MAC3_RESERVED1_Rf_GET(r) ((((r).arl_int[8]) >> 3) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC3_RESERVED1_Rf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53600_A0_ARL_INTm_MAC3_VID_Rf_GET(r) ((((r).arl_int[8]) >> 5) & 0xfff)
#define BCM53600_A0_ARL_INTm_MAC3_VID_Rf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0xfff << 5)) | ((((uint32_t)f) & 0xfff) << 5))
#define BCM53600_A0_ARL_INTm_MAC3_STATICf_GET(r) ((((r).arl_int[8]) >> 17) & 0x1)
#define BCM53600_A0_ARL_INTm_MAC3_STATICf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_ARL_INTm_MAC3_AGEf_GET(r) ((((r).arl_int[8]) >> 18) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC3_AGEf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_ARL_INTm_MAC3_VAf_GET(r) ((((r).arl_int[8]) >> 21) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC3_VAf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM53600_A0_ARL_INTm_MAC3_USERf_GET(r) ((((r).arl_int[8]) >> 23) & 0x7)
#define BCM53600_A0_ARL_INTm_MAC3_USERf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM53600_A0_ARL_INTm_MAC3_CONf_GET(r) ((((r).arl_int[8]) >> 26) & 0x3)
#define BCM53600_A0_ARL_INTm_MAC3_CONf_SET(r,f) (r).arl_int[8]=(((r).arl_int[8] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))

/*
 * These macros can be used to access ARL_INT.
 *
 */
#define BCM53600_A0_READ_ARL_INTm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_ARL_INTm,i,(m),36)
#define BCM53600_A0_WRITE_ARL_INTm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_ARL_INTm,i,&(m),36)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARL_INTm BCM53600_A0_ARL_INTm
#define ARL_INTm_MIN BCM53600_A0_ARL_INTm_MIN
#define ARL_INTm_MAX BCM53600_A0_ARL_INTm_MAX
#define ARL_INTm_CMAX(u) BCM53600_A0_ARL_INTm_CMAX(u)
#define ARL_INTm_SIZE BCM53600_A0_ARL_INTm_SIZE
typedef BCM53600_A0_ARL_INTm_t ARL_INTm_t;
#define ARL_INTm_CLR BCM53600_A0_ARL_INTm_CLR
#define ARL_INTm_SET BCM53600_A0_ARL_INTm_SET
#define ARL_INTm_GET BCM53600_A0_ARL_INTm_GET
#define ARL_INTm_MAC0_MACADDRf_GET BCM53600_A0_ARL_INTm_MAC0_MACADDRf_GET
#define ARL_INTm_MAC0_MACADDRf_SET BCM53600_A0_ARL_INTm_MAC0_MACADDRf_SET
#define ARL_INTm_MAC0_PORTID_Rf_GET BCM53600_A0_ARL_INTm_MAC0_PORTID_Rf_GET
#define ARL_INTm_MAC0_PORTID_Rf_SET BCM53600_A0_ARL_INTm_MAC0_PORTID_Rf_SET
#define ARL_INTm_MAC0_RESERVED0_Rf_GET BCM53600_A0_ARL_INTm_MAC0_RESERVED0_Rf_GET
#define ARL_INTm_MAC0_RESERVED0_Rf_SET BCM53600_A0_ARL_INTm_MAC0_RESERVED0_Rf_SET
#define ARL_INTm_MAC0_V_PORTIDf_GET BCM53600_A0_ARL_INTm_MAC0_V_PORTIDf_GET
#define ARL_INTm_MAC0_V_PORTIDf_SET BCM53600_A0_ARL_INTm_MAC0_V_PORTIDf_SET
#define ARL_INTm_MAC0_RESERVED1_Rf_GET BCM53600_A0_ARL_INTm_MAC0_RESERVED1_Rf_GET
#define ARL_INTm_MAC0_RESERVED1_Rf_SET BCM53600_A0_ARL_INTm_MAC0_RESERVED1_Rf_SET
#define ARL_INTm_MAC0_VID_Rf_GET BCM53600_A0_ARL_INTm_MAC0_VID_Rf_GET
#define ARL_INTm_MAC0_VID_Rf_SET BCM53600_A0_ARL_INTm_MAC0_VID_Rf_SET
#define ARL_INTm_MAC0_STATICf_GET BCM53600_A0_ARL_INTm_MAC0_STATICf_GET
#define ARL_INTm_MAC0_STATICf_SET BCM53600_A0_ARL_INTm_MAC0_STATICf_SET
#define ARL_INTm_MAC0_AGEf_GET BCM53600_A0_ARL_INTm_MAC0_AGEf_GET
#define ARL_INTm_MAC0_AGEf_SET BCM53600_A0_ARL_INTm_MAC0_AGEf_SET
#define ARL_INTm_MAC0_VAf_GET BCM53600_A0_ARL_INTm_MAC0_VAf_GET
#define ARL_INTm_MAC0_VAf_SET BCM53600_A0_ARL_INTm_MAC0_VAf_SET
#define ARL_INTm_MAC0_USERf_GET BCM53600_A0_ARL_INTm_MAC0_USERf_GET
#define ARL_INTm_MAC0_USERf_SET BCM53600_A0_ARL_INTm_MAC0_USERf_SET
#define ARL_INTm_MAC0_CONf_GET BCM53600_A0_ARL_INTm_MAC0_CONf_GET
#define ARL_INTm_MAC0_CONf_SET BCM53600_A0_ARL_INTm_MAC0_CONf_SET
#define ARL_INTm_MAC1_MACADDRf_GET BCM53600_A0_ARL_INTm_MAC1_MACADDRf_GET
#define ARL_INTm_MAC1_MACADDRf_SET BCM53600_A0_ARL_INTm_MAC1_MACADDRf_SET
#define ARL_INTm_MAC1_PORTID_Rf_GET BCM53600_A0_ARL_INTm_MAC1_PORTID_Rf_GET
#define ARL_INTm_MAC1_PORTID_Rf_SET BCM53600_A0_ARL_INTm_MAC1_PORTID_Rf_SET
#define ARL_INTm_MAC1_RESERVED0_Rf_GET BCM53600_A0_ARL_INTm_MAC1_RESERVED0_Rf_GET
#define ARL_INTm_MAC1_RESERVED0_Rf_SET BCM53600_A0_ARL_INTm_MAC1_RESERVED0_Rf_SET
#define ARL_INTm_MAC1_V_PORTIDf_GET BCM53600_A0_ARL_INTm_MAC1_V_PORTIDf_GET
#define ARL_INTm_MAC1_V_PORTIDf_SET BCM53600_A0_ARL_INTm_MAC1_V_PORTIDf_SET
#define ARL_INTm_MAC1_RESERVED1_Rf_GET BCM53600_A0_ARL_INTm_MAC1_RESERVED1_Rf_GET
#define ARL_INTm_MAC1_RESERVED1_Rf_SET BCM53600_A0_ARL_INTm_MAC1_RESERVED1_Rf_SET
#define ARL_INTm_MAC1_VID_Rf_GET BCM53600_A0_ARL_INTm_MAC1_VID_Rf_GET
#define ARL_INTm_MAC1_VID_Rf_SET BCM53600_A0_ARL_INTm_MAC1_VID_Rf_SET
#define ARL_INTm_MAC1_STATICf_GET BCM53600_A0_ARL_INTm_MAC1_STATICf_GET
#define ARL_INTm_MAC1_STATICf_SET BCM53600_A0_ARL_INTm_MAC1_STATICf_SET
#define ARL_INTm_MAC1_AGEf_GET BCM53600_A0_ARL_INTm_MAC1_AGEf_GET
#define ARL_INTm_MAC1_AGEf_SET BCM53600_A0_ARL_INTm_MAC1_AGEf_SET
#define ARL_INTm_MAC1_VAf_GET BCM53600_A0_ARL_INTm_MAC1_VAf_GET
#define ARL_INTm_MAC1_VAf_SET BCM53600_A0_ARL_INTm_MAC1_VAf_SET
#define ARL_INTm_MAC1_USERf_GET BCM53600_A0_ARL_INTm_MAC1_USERf_GET
#define ARL_INTm_MAC1_USERf_SET BCM53600_A0_ARL_INTm_MAC1_USERf_SET
#define ARL_INTm_MAC1_CONf_GET BCM53600_A0_ARL_INTm_MAC1_CONf_GET
#define ARL_INTm_MAC1_CONf_SET BCM53600_A0_ARL_INTm_MAC1_CONf_SET
#define ARL_INTm_MAC2_MACADDRf_GET BCM53600_A0_ARL_INTm_MAC2_MACADDRf_GET
#define ARL_INTm_MAC2_MACADDRf_SET BCM53600_A0_ARL_INTm_MAC2_MACADDRf_SET
#define ARL_INTm_MAC2_PORTID_Rf_GET BCM53600_A0_ARL_INTm_MAC2_PORTID_Rf_GET
#define ARL_INTm_MAC2_PORTID_Rf_SET BCM53600_A0_ARL_INTm_MAC2_PORTID_Rf_SET
#define ARL_INTm_MAC2_RESERVED0_Rf_GET BCM53600_A0_ARL_INTm_MAC2_RESERVED0_Rf_GET
#define ARL_INTm_MAC2_RESERVED0_Rf_SET BCM53600_A0_ARL_INTm_MAC2_RESERVED0_Rf_SET
#define ARL_INTm_MAC2_V_PORTIDf_GET BCM53600_A0_ARL_INTm_MAC2_V_PORTIDf_GET
#define ARL_INTm_MAC2_V_PORTIDf_SET BCM53600_A0_ARL_INTm_MAC2_V_PORTIDf_SET
#define ARL_INTm_MAC2_RESERVED1_Rf_GET BCM53600_A0_ARL_INTm_MAC2_RESERVED1_Rf_GET
#define ARL_INTm_MAC2_RESERVED1_Rf_SET BCM53600_A0_ARL_INTm_MAC2_RESERVED1_Rf_SET
#define ARL_INTm_MAC2_VID_Rf_GET BCM53600_A0_ARL_INTm_MAC2_VID_Rf_GET
#define ARL_INTm_MAC2_VID_Rf_SET BCM53600_A0_ARL_INTm_MAC2_VID_Rf_SET
#define ARL_INTm_MAC2_STATICf_GET BCM53600_A0_ARL_INTm_MAC2_STATICf_GET
#define ARL_INTm_MAC2_STATICf_SET BCM53600_A0_ARL_INTm_MAC2_STATICf_SET
#define ARL_INTm_MAC2_AGEf_GET BCM53600_A0_ARL_INTm_MAC2_AGEf_GET
#define ARL_INTm_MAC2_AGEf_SET BCM53600_A0_ARL_INTm_MAC2_AGEf_SET
#define ARL_INTm_MAC2_VAf_GET BCM53600_A0_ARL_INTm_MAC2_VAf_GET
#define ARL_INTm_MAC2_VAf_SET BCM53600_A0_ARL_INTm_MAC2_VAf_SET
#define ARL_INTm_MAC2_USERf_GET BCM53600_A0_ARL_INTm_MAC2_USERf_GET
#define ARL_INTm_MAC2_USERf_SET BCM53600_A0_ARL_INTm_MAC2_USERf_SET
#define ARL_INTm_MAC2_CONf_GET BCM53600_A0_ARL_INTm_MAC2_CONf_GET
#define ARL_INTm_MAC2_CONf_SET BCM53600_A0_ARL_INTm_MAC2_CONf_SET
#define ARL_INTm_MAC3_MACADDRf_GET BCM53600_A0_ARL_INTm_MAC3_MACADDRf_GET
#define ARL_INTm_MAC3_MACADDRf_SET BCM53600_A0_ARL_INTm_MAC3_MACADDRf_SET
#define ARL_INTm_MAC3_PORTID_Rf_GET BCM53600_A0_ARL_INTm_MAC3_PORTID_Rf_GET
#define ARL_INTm_MAC3_PORTID_Rf_SET BCM53600_A0_ARL_INTm_MAC3_PORTID_Rf_SET
#define ARL_INTm_MAC3_RESERVED0_Rf_GET BCM53600_A0_ARL_INTm_MAC3_RESERVED0_Rf_GET
#define ARL_INTm_MAC3_RESERVED0_Rf_SET BCM53600_A0_ARL_INTm_MAC3_RESERVED0_Rf_SET
#define ARL_INTm_MAC3_V_PORTIDf_GET BCM53600_A0_ARL_INTm_MAC3_V_PORTIDf_GET
#define ARL_INTm_MAC3_V_PORTIDf_SET BCM53600_A0_ARL_INTm_MAC3_V_PORTIDf_SET
#define ARL_INTm_MAC3_RESERVED1_Rf_GET BCM53600_A0_ARL_INTm_MAC3_RESERVED1_Rf_GET
#define ARL_INTm_MAC3_RESERVED1_Rf_SET BCM53600_A0_ARL_INTm_MAC3_RESERVED1_Rf_SET
#define ARL_INTm_MAC3_VID_Rf_GET BCM53600_A0_ARL_INTm_MAC3_VID_Rf_GET
#define ARL_INTm_MAC3_VID_Rf_SET BCM53600_A0_ARL_INTm_MAC3_VID_Rf_SET
#define ARL_INTm_MAC3_STATICf_GET BCM53600_A0_ARL_INTm_MAC3_STATICf_GET
#define ARL_INTm_MAC3_STATICf_SET BCM53600_A0_ARL_INTm_MAC3_STATICf_SET
#define ARL_INTm_MAC3_AGEf_GET BCM53600_A0_ARL_INTm_MAC3_AGEf_GET
#define ARL_INTm_MAC3_AGEf_SET BCM53600_A0_ARL_INTm_MAC3_AGEf_SET
#define ARL_INTm_MAC3_VAf_GET BCM53600_A0_ARL_INTm_MAC3_VAf_GET
#define ARL_INTm_MAC3_VAf_SET BCM53600_A0_ARL_INTm_MAC3_VAf_SET
#define ARL_INTm_MAC3_USERf_GET BCM53600_A0_ARL_INTm_MAC3_USERf_GET
#define ARL_INTm_MAC3_USERf_SET BCM53600_A0_ARL_INTm_MAC3_USERf_SET
#define ARL_INTm_MAC3_CONf_GET BCM53600_A0_ARL_INTm_MAC3_CONf_GET
#define ARL_INTm_MAC3_CONf_SET BCM53600_A0_ARL_INTm_MAC3_CONf_SET
#define READ_ARL_INTm BCM53600_A0_READ_ARL_INTm
#define WRITE_ARL_INTm BCM53600_A0_WRITE_ARL_INTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ARL_INTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_AV_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     AVB AV Enable Control Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     AV_EN            AV enableA 29-bit mask which selectively allow any port with its corresponding bit set.When set to one, the corresponding port AV bridging is enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_AV_EN_CTRLr 0x00004600

#define BCM53600_A0_AVB_AV_EN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program AVB_AV_EN_CTRL.
 *
 */
typedef union BCM53600_A0_AVB_AV_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t avb_av_en_ctrl[1];
	uint32_t _avb_av_en_ctrl;
} BCM53600_A0_AVB_AV_EN_CTRLr_t;

#define BCM53600_A0_AVB_AV_EN_CTRLr_CLR(r) (r).avb_av_en_ctrl[0] = 0
#define BCM53600_A0_AVB_AV_EN_CTRLr_SET(r,d) (r).avb_av_en_ctrl[0] = d
#define BCM53600_A0_AVB_AV_EN_CTRLr_GET(r) (r).avb_av_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_AV_EN_CTRLr_AV_ENf_GET(r) (((r).avb_av_en_ctrl[0]) & 0x1fffffff)
#define BCM53600_A0_AVB_AV_EN_CTRLr_AV_ENf_SET(r,f) (r).avb_av_en_ctrl[0]=(((r).avb_av_en_ctrl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_AVB_AV_EN_CTRLr_RESERVEDf_GET(r) ((((r).avb_av_en_ctrl[0]) >> 29) & 0x7)
#define BCM53600_A0_AVB_AV_EN_CTRLr_RESERVEDf_SET(r,f) (r).avb_av_en_ctrl[0]=(((r).avb_av_en_ctrl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access AVB_AV_EN_CTRL.
 *
 */
#define BCM53600_A0_READ_AVB_AV_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_AV_EN_CTRLr,(r._avb_av_en_ctrl),4)
#define BCM53600_A0_WRITE_AVB_AV_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_AV_EN_CTRLr,&(r._avb_av_en_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_AV_EN_CTRLr BCM53600_A0_AVB_AV_EN_CTRLr
#define AVB_AV_EN_CTRLr_SIZE BCM53600_A0_AVB_AV_EN_CTRLr_SIZE
typedef BCM53600_A0_AVB_AV_EN_CTRLr_t AVB_AV_EN_CTRLr_t;
#define AVB_AV_EN_CTRLr_CLR BCM53600_A0_AVB_AV_EN_CTRLr_CLR
#define AVB_AV_EN_CTRLr_SET BCM53600_A0_AVB_AV_EN_CTRLr_SET
#define AVB_AV_EN_CTRLr_GET BCM53600_A0_AVB_AV_EN_CTRLr_GET
#define AVB_AV_EN_CTRLr_AV_ENf_GET BCM53600_A0_AVB_AV_EN_CTRLr_AV_ENf_GET
#define AVB_AV_EN_CTRLr_AV_ENf_SET BCM53600_A0_AVB_AV_EN_CTRLr_AV_ENf_SET
#define AVB_AV_EN_CTRLr_RESERVEDf_GET BCM53600_A0_AVB_AV_EN_CTRLr_RESERVEDf_GET
#define AVB_AV_EN_CTRLr_RESERVEDf_SET BCM53600_A0_AVB_AV_EN_CTRLr_RESERVEDf_SET
#define READ_AVB_AV_EN_CTRLr BCM53600_A0_READ_AVB_AV_EN_CTRLr
#define WRITE_AVB_AV_EN_CTRLr BCM53600_A0_WRITE_AVB_AV_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_AV_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_EGRESS_TS_PORTMAP
 * BLOCKS:   SYS
 * DESC:     AVB Egress Time Sync. Packet - Portmap Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     EGRESS_TS_PORTMAP Egress Time Sync. Packet PortmapA 29-bit mask which selectively indicates which port's egress time stamp are read from the FIFOs.The time stamp of egress time sync. packet can be read from EGRESS_TS_STAMP register.When the value is 0, it means the FIFO is empty or all of the time stamp information has been read.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr 0x00004620

#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_SIZE 4

/*
 * This structure should be used to declare and program AVB_EGRESS_TS_PORTMAP.
 *
 */
typedef union BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_s {
	uint32_t v[1];
	uint32_t avb_egress_ts_portmap[1];
	uint32_t _avb_egress_ts_portmap;
} BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_t;

#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_CLR(r) (r).avb_egress_ts_portmap[0] = 0
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_SET(r,d) (r).avb_egress_ts_portmap[0] = d
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_GET(r) (r).avb_egress_ts_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_EGRESS_TS_PORTMAPf_GET(r) (((r).avb_egress_ts_portmap[0]) & 0x1fffffff)
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_EGRESS_TS_PORTMAPf_SET(r,f) (r).avb_egress_ts_portmap[0]=(((r).avb_egress_ts_portmap[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_RESERVEDf_GET(r) ((((r).avb_egress_ts_portmap[0]) >> 29) & 0x7)
#define BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_RESERVEDf_SET(r,f) (r).avb_egress_ts_portmap[0]=(((r).avb_egress_ts_portmap[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access AVB_EGRESS_TS_PORTMAP.
 *
 */
#define BCM53600_A0_READ_AVB_EGRESS_TS_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_EGRESS_TS_PORTMAPr,(r._avb_egress_ts_portmap),4)
#define BCM53600_A0_WRITE_AVB_EGRESS_TS_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_EGRESS_TS_PORTMAPr,&(r._avb_egress_ts_portmap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_EGRESS_TS_PORTMAPr BCM53600_A0_AVB_EGRESS_TS_PORTMAPr
#define AVB_EGRESS_TS_PORTMAPr_SIZE BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_SIZE
typedef BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_t AVB_EGRESS_TS_PORTMAPr_t;
#define AVB_EGRESS_TS_PORTMAPr_CLR BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_CLR
#define AVB_EGRESS_TS_PORTMAPr_SET BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_SET
#define AVB_EGRESS_TS_PORTMAPr_GET BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_GET
#define AVB_EGRESS_TS_PORTMAPr_EGRESS_TS_PORTMAPf_GET BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_EGRESS_TS_PORTMAPf_GET
#define AVB_EGRESS_TS_PORTMAPr_EGRESS_TS_PORTMAPf_SET BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_EGRESS_TS_PORTMAPf_SET
#define AVB_EGRESS_TS_PORTMAPr_RESERVEDf_GET BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_RESERVEDf_GET
#define AVB_EGRESS_TS_PORTMAPr_RESERVEDf_SET BCM53600_A0_AVB_EGRESS_TS_PORTMAPr_RESERVEDf_SET
#define READ_AVB_EGRESS_TS_PORTMAPr BCM53600_A0_READ_AVB_EGRESS_TS_PORTMAPr
#define WRITE_AVB_EGRESS_TS_PORTMAPr BCM53600_A0_WRITE_AVB_EGRESS_TS_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_EGRESS_TS_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_EGRESS_TS_TM_STAMP
 * BLOCKS:   SYS
 * DESC:     AVB Egress Time Sync. Packet - Time Stamp Register(Not2Release) 
 * SIZE:     32
 * FIELDS:
 *     EGRESS_TS_TM_STAMP AVB Egress Time Sync. Packet Time Stamp RegisterThis field reports the time stamp of egress time sync. packet. It use 32-bit time base as time stamping. The time between the departure of first byte of MAC DA and the time stamping point should be constant.Note: When host read EGRESS_TS_TM_STAMP register cause the Egress Time Stamp process to continue to latch the next time stamp information stored in FIFOs. Broadcom recommanded to read the EGRESS_TS_PORTMAP register first, then read EGRESS_TS_TM_STAMP register.
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr 0x00004628

#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_SIZE 4

/*
 * This structure should be used to declare and program AVB_EGRESS_TS_TM_STAMP.
 *
 */
typedef union BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_s {
	uint32_t v[1];
	uint32_t avb_egress_ts_tm_stamp[1];
	uint32_t _avb_egress_ts_tm_stamp;
} BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_t;

#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_CLR(r) (r).avb_egress_ts_tm_stamp[0] = 0
#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_SET(r,d) (r).avb_egress_ts_tm_stamp[0] = d
#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_GET(r) (r).avb_egress_ts_tm_stamp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET(r) ((r).avb_egress_ts_tm_stamp[0])
#define BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET(r,f) (r).avb_egress_ts_tm_stamp[0]=((uint32_t)f)

/*
 * These macros can be used to access AVB_EGRESS_TS_TM_STAMP.
 *
 */
#define BCM53600_A0_READ_AVB_EGRESS_TS_TM_STAMPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr,(r._avb_egress_ts_tm_stamp),4)
#define BCM53600_A0_WRITE_AVB_EGRESS_TS_TM_STAMPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr,&(r._avb_egress_ts_tm_stamp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_EGRESS_TS_TM_STAMPr BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr
#define AVB_EGRESS_TS_TM_STAMPr_SIZE BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_SIZE
typedef BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_t AVB_EGRESS_TS_TM_STAMPr_t;
#define AVB_EGRESS_TS_TM_STAMPr_CLR BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_CLR
#define AVB_EGRESS_TS_TM_STAMPr_SET BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_SET
#define AVB_EGRESS_TS_TM_STAMPr_GET BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_GET
#define AVB_EGRESS_TS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET
#define AVB_EGRESS_TS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET
#define READ_AVB_EGRESS_TS_TM_STAMPr BCM53600_A0_READ_AVB_EGRESS_TS_TM_STAMPr
#define WRITE_AVB_EGRESS_TS_TM_STAMPr BCM53600_A0_WRITE_AVB_EGRESS_TS_TM_STAMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_EGRESS_TS_TM_STAMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_LNK_STATUS
 * BLOCKS:   SYS
 * DESC:     AVB Port AVB Link Status Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     PT_AVB_LNK_STATUS Port AVB Link Status.A 29-bit mask which selectively indicates which ports' AVB link status will be displayed in the LED.When software write the port AVB link status and select bit 14 in LED function,The AVB link status is shown on the LED. 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_LNK_STATUSr 0x00004640

#define BCM53600_A0_AVB_LNK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AVB_LNK_STATUS.
 *
 */
typedef union BCM53600_A0_AVB_LNK_STATUSr_s {
	uint32_t v[1];
	uint32_t avb_lnk_status[1];
	uint32_t _avb_lnk_status;
} BCM53600_A0_AVB_LNK_STATUSr_t;

#define BCM53600_A0_AVB_LNK_STATUSr_CLR(r) (r).avb_lnk_status[0] = 0
#define BCM53600_A0_AVB_LNK_STATUSr_SET(r,d) (r).avb_lnk_status[0] = d
#define BCM53600_A0_AVB_LNK_STATUSr_GET(r) (r).avb_lnk_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_LNK_STATUSr_PT_AVB_LNK_STATUSf_GET(r) (((r).avb_lnk_status[0]) & 0x1fffffff)
#define BCM53600_A0_AVB_LNK_STATUSr_PT_AVB_LNK_STATUSf_SET(r,f) (r).avb_lnk_status[0]=(((r).avb_lnk_status[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_AVB_LNK_STATUSr_RESERVEDf_GET(r) ((((r).avb_lnk_status[0]) >> 29) & 0x7)
#define BCM53600_A0_AVB_LNK_STATUSr_RESERVEDf_SET(r,f) (r).avb_lnk_status[0]=(((r).avb_lnk_status[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access AVB_LNK_STATUS.
 *
 */
#define BCM53600_A0_READ_AVB_LNK_STATUSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_LNK_STATUSr,(r._avb_lnk_status),4)
#define BCM53600_A0_WRITE_AVB_LNK_STATUSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_LNK_STATUSr,&(r._avb_lnk_status),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_LNK_STATUSr BCM53600_A0_AVB_LNK_STATUSr
#define AVB_LNK_STATUSr_SIZE BCM53600_A0_AVB_LNK_STATUSr_SIZE
typedef BCM53600_A0_AVB_LNK_STATUSr_t AVB_LNK_STATUSr_t;
#define AVB_LNK_STATUSr_CLR BCM53600_A0_AVB_LNK_STATUSr_CLR
#define AVB_LNK_STATUSr_SET BCM53600_A0_AVB_LNK_STATUSr_SET
#define AVB_LNK_STATUSr_GET BCM53600_A0_AVB_LNK_STATUSr_GET
#define AVB_LNK_STATUSr_PT_AVB_LNK_STATUSf_GET BCM53600_A0_AVB_LNK_STATUSr_PT_AVB_LNK_STATUSf_GET
#define AVB_LNK_STATUSr_PT_AVB_LNK_STATUSf_SET BCM53600_A0_AVB_LNK_STATUSr_PT_AVB_LNK_STATUSf_SET
#define AVB_LNK_STATUSr_RESERVEDf_GET BCM53600_A0_AVB_LNK_STATUSr_RESERVEDf_GET
#define AVB_LNK_STATUSr_RESERVEDf_SET BCM53600_A0_AVB_LNK_STATUSr_RESERVEDf_SET
#define READ_AVB_LNK_STATUSr BCM53600_A0_READ_AVB_LNK_STATUSr
#define WRITE_AVB_LNK_STATUSr BCM53600_A0_WRITE_AVB_LNK_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_LNK_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_MAX_AV_PKT_SZ
 * BLOCKS:   SYS
 * DESC:     AVB MAX AV Packet Size Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MAX_AV_PKT_SZ    Max.AV Packet SizeThis field is to define the max packet size of AV packet (Residential Ethernet).  The ingress port uses it to qualify if the packet is allowed to pass through an AV link. The egress port uses it to perform shaping gate.
 *     RESERVED         RePAGE      0x90served
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr 0x0000460c

#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_SIZE 2

/*
 * This structure should be used to declare and program AVB_MAX_AV_PKT_SZ.
 *
 */
typedef union BCM53600_A0_AVB_MAX_AV_PKT_SZr_s {
	uint32_t v[1];
	uint32_t avb_max_av_pkt_sz[1];
	uint32_t _avb_max_av_pkt_sz;
} BCM53600_A0_AVB_MAX_AV_PKT_SZr_t;

#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_CLR(r) (r).avb_max_av_pkt_sz[0] = 0
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_SET(r,d) (r).avb_max_av_pkt_sz[0] = d
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_GET(r) (r).avb_max_av_pkt_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET(r) (((r).avb_max_av_pkt_sz[0]) & 0xfff)
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET(r,f) (r).avb_max_av_pkt_sz[0]=(((r).avb_max_av_pkt_sz[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_GET(r) ((((r).avb_max_av_pkt_sz[0]) >> 12) & 0xf)
#define BCM53600_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_SET(r,f) (r).avb_max_av_pkt_sz[0]=(((r).avb_max_av_pkt_sz[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access AVB_MAX_AV_PKT_SZ.
 *
 */
#define BCM53600_A0_READ_AVB_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_MAX_AV_PKT_SZr,(r._avb_max_av_pkt_sz),2)
#define BCM53600_A0_WRITE_AVB_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_MAX_AV_PKT_SZr,&(r._avb_max_av_pkt_sz),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_MAX_AV_PKT_SZr BCM53600_A0_AVB_MAX_AV_PKT_SZr
#define AVB_MAX_AV_PKT_SZr_SIZE BCM53600_A0_AVB_MAX_AV_PKT_SZr_SIZE
typedef BCM53600_A0_AVB_MAX_AV_PKT_SZr_t AVB_MAX_AV_PKT_SZr_t;
#define AVB_MAX_AV_PKT_SZr_CLR BCM53600_A0_AVB_MAX_AV_PKT_SZr_CLR
#define AVB_MAX_AV_PKT_SZr_SET BCM53600_A0_AVB_MAX_AV_PKT_SZr_SET
#define AVB_MAX_AV_PKT_SZr_GET BCM53600_A0_AVB_MAX_AV_PKT_SZr_GET
#define AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET BCM53600_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET
#define AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET BCM53600_A0_AVB_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET
#define AVB_MAX_AV_PKT_SZr_RESERVEDf_GET BCM53600_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_GET
#define AVB_MAX_AV_PKT_SZr_RESERVEDf_SET BCM53600_A0_AVB_MAX_AV_PKT_SZr_RESERVEDf_SET
#define READ_AVB_MAX_AV_PKT_SZr BCM53600_A0_READ_AVB_MAX_AV_PKT_SZr
#define WRITE_AVB_MAX_AV_PKT_SZr BCM53600_A0_WRITE_AVB_MAX_AV_PKT_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_MAX_AV_PKT_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_TM_ADJ
 * BLOCKS:   SYS
 * DESC:     AVB Time Base Adjustment Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     TM_INC           Time IncrementThis field defines the value to add into Time Base in each 25Mhz tick. Default is 40.
 *     RESERVED_1       Reserved
 *     TM_ADJ_PRD       Time Adjust PeriodThis field defines the tick numbers to apply the adjusted Time Increment (when Time Increment does not equal to 40). For example, increment the Time Base 41 for 10 ticks. In this case, Time Adjust Period is 10, and Time Increment is 41.
 *     RESERVED_0       RePAGE      0x90served
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_TM_ADJr 0x00004614

#define BCM53600_A0_AVB_TM_ADJr_SIZE 4

/*
 * This structure should be used to declare and program AVB_TM_ADJ.
 *
 */
typedef union BCM53600_A0_AVB_TM_ADJr_s {
	uint32_t v[1];
	uint32_t avb_tm_adj[1];
	uint32_t _avb_tm_adj;
} BCM53600_A0_AVB_TM_ADJr_t;

#define BCM53600_A0_AVB_TM_ADJr_CLR(r) (r).avb_tm_adj[0] = 0
#define BCM53600_A0_AVB_TM_ADJr_SET(r,d) (r).avb_tm_adj[0] = d
#define BCM53600_A0_AVB_TM_ADJr_GET(r) (r).avb_tm_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_TM_ADJr_TM_INCf_GET(r) (((r).avb_tm_adj[0]) & 0x3f)
#define BCM53600_A0_AVB_TM_ADJr_TM_INCf_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_AVB_TM_ADJr_RESERVED_1f_GET(r) ((((r).avb_tm_adj[0]) >> 6) & 0x3)
#define BCM53600_A0_AVB_TM_ADJr_RESERVED_1f_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_AVB_TM_ADJr_TM_ADJ_PRDf_GET(r) ((((r).avb_tm_adj[0]) >> 8) & 0xf)
#define BCM53600_A0_AVB_TM_ADJr_TM_ADJ_PRDf_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53600_A0_AVB_TM_ADJr_RESERVED_0f_GET(r) ((((r).avb_tm_adj[0]) >> 12) & 0xfffff)
#define BCM53600_A0_AVB_TM_ADJr_RESERVED_0f_SET(r,f) (r).avb_tm_adj[0]=(((r).avb_tm_adj[0] & ~((uint32_t)0xfffff << 12)) | ((((uint32_t)f) & 0xfffff) << 12))

/*
 * These macros can be used to access AVB_TM_ADJ.
 *
 */
#define BCM53600_A0_READ_AVB_TM_ADJr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_TM_ADJr,(r._avb_tm_adj),4)
#define BCM53600_A0_WRITE_AVB_TM_ADJr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_TM_ADJr,&(r._avb_tm_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_TM_ADJr BCM53600_A0_AVB_TM_ADJr
#define AVB_TM_ADJr_SIZE BCM53600_A0_AVB_TM_ADJr_SIZE
typedef BCM53600_A0_AVB_TM_ADJr_t AVB_TM_ADJr_t;
#define AVB_TM_ADJr_CLR BCM53600_A0_AVB_TM_ADJr_CLR
#define AVB_TM_ADJr_SET BCM53600_A0_AVB_TM_ADJr_SET
#define AVB_TM_ADJr_GET BCM53600_A0_AVB_TM_ADJr_GET
#define AVB_TM_ADJr_TM_INCf_GET BCM53600_A0_AVB_TM_ADJr_TM_INCf_GET
#define AVB_TM_ADJr_TM_INCf_SET BCM53600_A0_AVB_TM_ADJr_TM_INCf_SET
#define AVB_TM_ADJr_RESERVED_1f_GET BCM53600_A0_AVB_TM_ADJr_RESERVED_1f_GET
#define AVB_TM_ADJr_RESERVED_1f_SET BCM53600_A0_AVB_TM_ADJr_RESERVED_1f_SET
#define AVB_TM_ADJr_TM_ADJ_PRDf_GET BCM53600_A0_AVB_TM_ADJr_TM_ADJ_PRDf_GET
#define AVB_TM_ADJr_TM_ADJ_PRDf_SET BCM53600_A0_AVB_TM_ADJr_TM_ADJ_PRDf_SET
#define AVB_TM_ADJr_RESERVED_0f_GET BCM53600_A0_AVB_TM_ADJr_RESERVED_0f_GET
#define AVB_TM_ADJr_RESERVED_0f_SET BCM53600_A0_AVB_TM_ADJr_RESERVED_0f_SET
#define READ_AVB_TM_ADJr BCM53600_A0_READ_AVB_TM_ADJr
#define WRITE_AVB_TM_ADJr BCM53600_A0_WRITE_AVB_TM_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_TM_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  AVB_TM_BASE
 * BLOCKS:   SYS
 * DESC:     AVB Time Base Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     TM_BASE          Time BaseThis is 32-bit free running clock (running in 25MHz) for AVB time base. Ingress port and Egress port use it for Time Synchronization Packet Time Stamp.The unit is neno-second, The value should be less than 1 second(the maximum value is 32'h3B9ACA00).
 *
 ******************************************************************************/
#define BCM53600_A0_AVB_TM_BASEr 0x00004610

#define BCM53600_A0_AVB_TM_BASEr_SIZE 4

/*
 * This structure should be used to declare and program AVB_TM_BASE.
 *
 */
typedef union BCM53600_A0_AVB_TM_BASEr_s {
	uint32_t v[1];
	uint32_t avb_tm_base[1];
	uint32_t _avb_tm_base;
} BCM53600_A0_AVB_TM_BASEr_t;

#define BCM53600_A0_AVB_TM_BASEr_CLR(r) (r).avb_tm_base[0] = 0
#define BCM53600_A0_AVB_TM_BASEr_SET(r,d) (r).avb_tm_base[0] = d
#define BCM53600_A0_AVB_TM_BASEr_GET(r) (r).avb_tm_base[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_AVB_TM_BASEr_TM_BASEf_GET(r) ((r).avb_tm_base[0])
#define BCM53600_A0_AVB_TM_BASEr_TM_BASEf_SET(r,f) (r).avb_tm_base[0]=((uint32_t)f)

/*
 * These macros can be used to access AVB_TM_BASE.
 *
 */
#define BCM53600_A0_READ_AVB_TM_BASEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_AVB_TM_BASEr,(r._avb_tm_base),4)
#define BCM53600_A0_WRITE_AVB_TM_BASEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_AVB_TM_BASEr,&(r._avb_tm_base),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AVB_TM_BASEr BCM53600_A0_AVB_TM_BASEr
#define AVB_TM_BASEr_SIZE BCM53600_A0_AVB_TM_BASEr_SIZE
typedef BCM53600_A0_AVB_TM_BASEr_t AVB_TM_BASEr_t;
#define AVB_TM_BASEr_CLR BCM53600_A0_AVB_TM_BASEr_CLR
#define AVB_TM_BASEr_SET BCM53600_A0_AVB_TM_BASEr_SET
#define AVB_TM_BASEr_GET BCM53600_A0_AVB_TM_BASEr_GET
#define AVB_TM_BASEr_TM_BASEf_GET BCM53600_A0_AVB_TM_BASEr_TM_BASEf_GET
#define AVB_TM_BASEr_TM_BASEf_SET BCM53600_A0_AVB_TM_BASEr_TM_BASEf_SET
#define READ_AVB_TM_BASEr BCM53600_A0_READ_AVB_TM_BASEr
#define WRITE_AVB_TM_BASEr BCM53600_A0_WRITE_AVB_TM_BASEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_AVB_TM_BASEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  BIST_STS0
 * BLOCKS:   SYS
 * DESC:     BIST Status 0 Register
 * SIZE:     64
 * FIELDS:
 *     EVM_TCAM_MBIST_ERR EVM TCAM Mbist Error.
 *     IVM_TCAM_MBIST_ERR IVM TCAM Mbist Error.
 *     CFP_TCAM_MBIST_ERR CFP TCAM Mbist Error.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_BIST_STS0r 0x00000200

#define BCM53600_A0_BIST_STS0r_SIZE 8

/*
 * This structure should be used to declare and program BIST_STS0.
 *
 */
typedef union BCM53600_A0_BIST_STS0r_s {
	uint32_t v[2];
	uint32_t bist_sts0[2];
	uint32_t _bist_sts0;
} BCM53600_A0_BIST_STS0r_t;

#define BCM53600_A0_BIST_STS0r_CLR(r) CDK_MEMSET(&((r)._bist_sts0), 0, sizeof(BCM53600_A0_BIST_STS0r_t))
#define BCM53600_A0_BIST_STS0r_SET(r,i,d) (r).bist_sts0[i] = d
#define BCM53600_A0_BIST_STS0r_GET(r,i) (r).bist_sts0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_BIST_STS0r_EVM_TCAM_MBIST_ERRf_GET(r) (((r).bist_sts0[0]) & 0x1)
#define BCM53600_A0_BIST_STS0r_EVM_TCAM_MBIST_ERRf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_BIST_STS0r_IVM_TCAM_MBIST_ERRf_GET(r) ((((r).bist_sts0[0]) >> 1) & 0x1)
#define BCM53600_A0_BIST_STS0r_IVM_TCAM_MBIST_ERRf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_GET(r) ((((r).bist_sts0[0]) >> 2) & 0x1)
#define BCM53600_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_BIST_STS0r_RESERVED_1f_GET(r,a) cdk_field_get((r).bist_sts0,3,63,a)
#define BCM53600_A0_BIST_STS0r_RESERVED_1f_SET(r,a) cdk_field_set((r).bist_sts0,3,63,a)

/*
 * These macros can be used to access BIST_STS0.
 *
 */
#define BCM53600_A0_READ_BIST_STS0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_BIST_STS0r,(r._bist_sts0),8)
#define BCM53600_A0_WRITE_BIST_STS0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_BIST_STS0r,&(r._bist_sts0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STS0r BCM53600_A0_BIST_STS0r
#define BIST_STS0r_SIZE BCM53600_A0_BIST_STS0r_SIZE
typedef BCM53600_A0_BIST_STS0r_t BIST_STS0r_t;
#define BIST_STS0r_CLR BCM53600_A0_BIST_STS0r_CLR
#define BIST_STS0r_SET BCM53600_A0_BIST_STS0r_SET
#define BIST_STS0r_GET BCM53600_A0_BIST_STS0r_GET
#define BIST_STS0r_EVM_TCAM_MBIST_ERRf_GET BCM53600_A0_BIST_STS0r_EVM_TCAM_MBIST_ERRf_GET
#define BIST_STS0r_EVM_TCAM_MBIST_ERRf_SET BCM53600_A0_BIST_STS0r_EVM_TCAM_MBIST_ERRf_SET
#define BIST_STS0r_IVM_TCAM_MBIST_ERRf_GET BCM53600_A0_BIST_STS0r_IVM_TCAM_MBIST_ERRf_GET
#define BIST_STS0r_IVM_TCAM_MBIST_ERRf_SET BCM53600_A0_BIST_STS0r_IVM_TCAM_MBIST_ERRf_SET
#define BIST_STS0r_CFP_TCAM_MBIST_ERRf_GET BCM53600_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_GET
#define BIST_STS0r_CFP_TCAM_MBIST_ERRf_SET BCM53600_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_SET
#define BIST_STS0r_RESERVED_1f_GET BCM53600_A0_BIST_STS0r_RESERVED_1f_GET
#define BIST_STS0r_RESERVED_1f_SET BCM53600_A0_BIST_STS0r_RESERVED_1f_SET
#define READ_BIST_STS0r BCM53600_A0_READ_BIST_STS0r
#define WRITE_BIST_STS0r BCM53600_A0_WRITE_BIST_STS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_BIST_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  BIST_STS1
 * BLOCKS:   SYS
 * DESC:     BIST Status 1 Register
 * SIZE:     64
 * FIELDS:
 *     LV_MBIST_ERR     LV Mbist Error(TBD).
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_BIST_STS1r 0x00000208

#define BCM53600_A0_BIST_STS1r_SIZE 8

/*
 * This structure should be used to declare and program BIST_STS1.
 *
 */
typedef union BCM53600_A0_BIST_STS1r_s {
	uint32_t v[2];
	uint32_t bist_sts1[2];
	uint32_t _bist_sts1;
} BCM53600_A0_BIST_STS1r_t;

#define BCM53600_A0_BIST_STS1r_CLR(r) CDK_MEMSET(&((r)._bist_sts1), 0, sizeof(BCM53600_A0_BIST_STS1r_t))
#define BCM53600_A0_BIST_STS1r_SET(r,i,d) (r).bist_sts1[i] = d
#define BCM53600_A0_BIST_STS1r_GET(r,i) (r).bist_sts1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_BIST_STS1r_LV_MBIST_ERRf_GET(r) (((r).bist_sts1[0]) & 0xffff)
#define BCM53600_A0_BIST_STS1r_LV_MBIST_ERRf_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_BIST_STS1r_RESERVED_1f_GET(r,a) cdk_field_get((r).bist_sts1,16,63,a)
#define BCM53600_A0_BIST_STS1r_RESERVED_1f_SET(r,a) cdk_field_set((r).bist_sts1,16,63,a)

/*
 * These macros can be used to access BIST_STS1.
 *
 */
#define BCM53600_A0_READ_BIST_STS1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_BIST_STS1r,(r._bist_sts1),8)
#define BCM53600_A0_WRITE_BIST_STS1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_BIST_STS1r,&(r._bist_sts1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STS1r BCM53600_A0_BIST_STS1r
#define BIST_STS1r_SIZE BCM53600_A0_BIST_STS1r_SIZE
typedef BCM53600_A0_BIST_STS1r_t BIST_STS1r_t;
#define BIST_STS1r_CLR BCM53600_A0_BIST_STS1r_CLR
#define BIST_STS1r_SET BCM53600_A0_BIST_STS1r_SET
#define BIST_STS1r_GET BCM53600_A0_BIST_STS1r_GET
#define BIST_STS1r_LV_MBIST_ERRf_GET BCM53600_A0_BIST_STS1r_LV_MBIST_ERRf_GET
#define BIST_STS1r_LV_MBIST_ERRf_SET BCM53600_A0_BIST_STS1r_LV_MBIST_ERRf_SET
#define BIST_STS1r_RESERVED_1f_GET BCM53600_A0_BIST_STS1r_RESERVED_1f_GET
#define BIST_STS1r_RESERVED_1f_SET BCM53600_A0_BIST_STS1r_RESERVED_1f_SET
#define READ_BIST_STS1r BCM53600_A0_READ_BIST_STS1r
#define WRITE_BIST_STS1r BCM53600_A0_WRITE_BIST_STS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_BIST_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  BONDING_PAD
 * BLOCKS:   SYS
 * DESC:     Bonding_Pad Register, used as CHIP ID
 * SIZE:     64
 * FIELDS:
 *     BONDING_PAD      Bit 3 : MCM Bit 2 : S3MII_EN Bit 1-0 : PORT_CNTBCM53606V: 4'b1111,BCM53604V: 4'b1011,BCM53603V: 4'b1010,BCM53602V: 4'b1001,BCM53606: 4'b0111,BCM53604: 4'b0011,BCM53603: 4'b0010,BCM53602: 4'b0001.
 *     RESERVED         Reserved.
 *     FPGA_XVM_CNT     xvm entry in each TCAM(ivm use 1 TCAM and evm use 1 TCAM in Thunderbolt).(Not2Release)
 *     FPGA_CFP_CNT     CFP entry in each TCAM(there are 6 TCAMs in Thunderbolt).(Not2Release)
 *     FPGA_FE_PORT_CNT FPGA FE port count.(Not2Release)
 *     FPGA_GE_PORT_CNT FPGA Giga port count.(Not2Release)
 *     FPGA_CHKOUT_TIME FPGA code checkout time.(Not2Release)
 *     FPGA_CHKOUT_DATE FPGA code check out date.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_BONDING_PADr 0x000000e8

#define BCM53600_A0_BONDING_PADr_SIZE 8

/*
 * This structure should be used to declare and program BONDING_PAD.
 *
 */
typedef union BCM53600_A0_BONDING_PADr_s {
	uint32_t v[2];
	uint32_t bonding_pad[2];
	uint32_t _bonding_pad;
} BCM53600_A0_BONDING_PADr_t;

#define BCM53600_A0_BONDING_PADr_CLR(r) CDK_MEMSET(&((r)._bonding_pad), 0, sizeof(BCM53600_A0_BONDING_PADr_t))
#define BCM53600_A0_BONDING_PADr_SET(r,i,d) (r).bonding_pad[i] = d
#define BCM53600_A0_BONDING_PADr_GET(r,i) (r).bonding_pad[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_BONDING_PADr_BONDING_PADf_GET(r) (((r).bonding_pad[0]) & 0xf)
#define BCM53600_A0_BONDING_PADr_BONDING_PADf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_BONDING_PADr_RESERVEDf_GET(r) ((((r).bonding_pad[0]) >> 4) & 0xf)
#define BCM53600_A0_BONDING_PADr_RESERVEDf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53600_A0_BONDING_PADr_FPGA_XVM_CNTf_GET(r) ((((r).bonding_pad[0]) >> 8) & 0xff)
#define BCM53600_A0_BONDING_PADr_FPGA_XVM_CNTf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_BONDING_PADr_FPGA_CFP_CNTf_GET(r) ((((r).bonding_pad[0]) >> 16) & 0xff)
#define BCM53600_A0_BONDING_PADr_FPGA_CFP_CNTf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_BONDING_PADr_FPGA_FE_PORT_CNTf_GET(r) ((((r).bonding_pad[0]) >> 24) & 0xf)
#define BCM53600_A0_BONDING_PADr_FPGA_FE_PORT_CNTf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_BONDING_PADr_FPGA_GE_PORT_CNTf_GET(r) ((((r).bonding_pad[0]) >> 28) & 0xf)
#define BCM53600_A0_BONDING_PADr_FPGA_GE_PORT_CNTf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_TIMEf_GET(r) (((r).bonding_pad[1]) & 0xffff)
#define BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_TIMEf_SET(r,f) (r).bonding_pad[1]=(((r).bonding_pad[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_DATEf_GET(r) ((((r).bonding_pad[1]) >> 16) & 0xffff)
#define BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_DATEf_SET(r,f) (r).bonding_pad[1]=(((r).bonding_pad[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access BONDING_PAD.
 *
 */
#define BCM53600_A0_READ_BONDING_PADr(u,r) cdk_robo_reg_read(u,BCM53600_A0_BONDING_PADr,(r._bonding_pad),8)
#define BCM53600_A0_WRITE_BONDING_PADr(u,r) cdk_robo_reg_write(u,BCM53600_A0_BONDING_PADr,&(r._bonding_pad),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BONDING_PADr BCM53600_A0_BONDING_PADr
#define BONDING_PADr_SIZE BCM53600_A0_BONDING_PADr_SIZE
typedef BCM53600_A0_BONDING_PADr_t BONDING_PADr_t;
#define BONDING_PADr_CLR BCM53600_A0_BONDING_PADr_CLR
#define BONDING_PADr_SET BCM53600_A0_BONDING_PADr_SET
#define BONDING_PADr_GET BCM53600_A0_BONDING_PADr_GET
#define BONDING_PADr_BONDING_PADf_GET BCM53600_A0_BONDING_PADr_BONDING_PADf_GET
#define BONDING_PADr_BONDING_PADf_SET BCM53600_A0_BONDING_PADr_BONDING_PADf_SET
#define BONDING_PADr_RESERVEDf_GET BCM53600_A0_BONDING_PADr_RESERVEDf_GET
#define BONDING_PADr_RESERVEDf_SET BCM53600_A0_BONDING_PADr_RESERVEDf_SET
#define BONDING_PADr_FPGA_XVM_CNTf_GET BCM53600_A0_BONDING_PADr_FPGA_XVM_CNTf_GET
#define BONDING_PADr_FPGA_XVM_CNTf_SET BCM53600_A0_BONDING_PADr_FPGA_XVM_CNTf_SET
#define BONDING_PADr_FPGA_CFP_CNTf_GET BCM53600_A0_BONDING_PADr_FPGA_CFP_CNTf_GET
#define BONDING_PADr_FPGA_CFP_CNTf_SET BCM53600_A0_BONDING_PADr_FPGA_CFP_CNTf_SET
#define BONDING_PADr_FPGA_FE_PORT_CNTf_GET BCM53600_A0_BONDING_PADr_FPGA_FE_PORT_CNTf_GET
#define BONDING_PADr_FPGA_FE_PORT_CNTf_SET BCM53600_A0_BONDING_PADr_FPGA_FE_PORT_CNTf_SET
#define BONDING_PADr_FPGA_GE_PORT_CNTf_GET BCM53600_A0_BONDING_PADr_FPGA_GE_PORT_CNTf_GET
#define BONDING_PADr_FPGA_GE_PORT_CNTf_SET BCM53600_A0_BONDING_PADr_FPGA_GE_PORT_CNTf_SET
#define BONDING_PADr_FPGA_CHKOUT_TIMEf_GET BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_TIMEf_GET
#define BONDING_PADr_FPGA_CHKOUT_TIMEf_SET BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_TIMEf_SET
#define BONDING_PADr_FPGA_CHKOUT_DATEf_GET BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_DATEf_GET
#define BONDING_PADr_FPGA_CHKOUT_DATEf_SET BCM53600_A0_BONDING_PADr_FPGA_CHKOUT_DATEf_SET
#define READ_BONDING_PADr BCM53600_A0_READ_BONDING_PADr
#define WRITE_BONDING_PADr BCM53600_A0_WRITE_BONDING_PADr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_BONDING_PADr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register(Not2Release)
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     (not release to customer)BPDU Multicast AddressDefaults to the 802.1 defined reserved multicast address for the Bridge Group Address. Programming to an alternate value allows support of proprietary protocols in place of the normal Spanning Tree Protocol. Frames with a matching DA to this address will be forwarded only to the designated management port (IMP).
 *
 ******************************************************************************/
#define BCM53600_A0_BPDU_MCADDRr 0x00000404

#define BCM53600_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 *
 */
typedef union BCM53600_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM53600_A0_BPDU_MCADDRr_t;

#define BCM53600_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM53600_A0_BPDU_MCADDRr_t))
#define BCM53600_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM53600_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM53600_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 *
 */
#define BCM53600_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM53600_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM53600_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM53600_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM53600_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM53600_A0_BPDU_MCADDRr_SIZE
typedef BCM53600_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM53600_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM53600_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM53600_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM53600_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM53600_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM53600_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM53600_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_BPDU_MCADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  BUFCON
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Control Table
 * SIZE:     102
 * FIELDS:
 *     FM_LEN           Fm_Len[13:0]
 *     INGRESS_PORT     Ingress Port[5:0]
 *     INGRESS_VPORT    Ingress Vport[3:0]
 *     EGRESS_VPORT     Egress Vport[3:0]
 *     FLOW_ID_MGID     FLOW_ID/MGID[11:0]
 *     F_M              F/M. FLOW_ID/MGID
 *     IGR_CTAG         Ingress CTag_Status
 *     IGR_STAG         Ingress STag_Status
 *     TC               TC[3:0]
 *     DP               DP[1:0]
 *     DNM              Do Not Modified. Egress side will not change TAG status
 *     VPORT_CPCP       Vport CPCP[2:0]. Come from IVM results
 *     VPORT_SPCP       Vport SPCP[2:0]. Come from IVM results
 *     CPCP_MARKING     CPCP_Marking[1:0]. Come from IVM action results
 *     SPCP_MARKING     SPCP_Marking[1:0]. Come from IVM action results
 *     TX_TS_EN         Color of Packet
 *     REASON           Reason[15:0]
 *     L_DIS            Learn disable indication
 *     RESV             RESERVED
 *     VID              VID
 *     RX_TS_EN         RESERVED
 *     REF_CNT          REFERENCE Count
 *
 ******************************************************************************/
#define BCM53600_A0_BUFCONm 0x00000000

#define BCM53600_A0_BUFCONm_MIN 0
#define BCM53600_A0_BUFCONm_MAX 6143
#define BCM53600_A0_BUFCONm_CMAX(u) 6143
#define BCM53600_A0_BUFCONm_SIZE 13

/*
 * This structure should be used to declare and program BUFCON.
 *
 */
typedef union BCM53600_A0_BUFCONm_s {
	uint32_t v[4];
	uint32_t bufcon[4];
	uint32_t _bufcon;
} BCM53600_A0_BUFCONm_t;

#define BCM53600_A0_BUFCONm_CLR(r) CDK_MEMSET(&((r)._bufcon), 0, sizeof(BCM53600_A0_BUFCONm_t))
#define BCM53600_A0_BUFCONm_SET(r,i,d) (r).bufcon[i] = d
#define BCM53600_A0_BUFCONm_GET(r,i) (r).bufcon[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_BUFCONm_FM_LENf_GET(r) (((r).bufcon[0]) & 0x3fff)
#define BCM53600_A0_BUFCONm_FM_LENf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53600_A0_BUFCONm_INGRESS_PORTf_GET(r) ((((r).bufcon[0]) >> 14) & 0x3f)
#define BCM53600_A0_BUFCONm_INGRESS_PORTf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM53600_A0_BUFCONm_INGRESS_VPORTf_GET(r) ((((r).bufcon[0]) >> 20) & 0xf)
#define BCM53600_A0_BUFCONm_INGRESS_VPORTf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53600_A0_BUFCONm_EGRESS_VPORTf_GET(r) ((((r).bufcon[0]) >> 24) & 0xf)
#define BCM53600_A0_BUFCONm_EGRESS_VPORTf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_BUFCONm_FLOW_ID_MGIDf_GET(r) cdk_field32_get((r).bufcon,28,39)
#define BCM53600_A0_BUFCONm_FLOW_ID_MGIDf_SET(r,f) cdk_field32_set((r).bufcon,28,39,f)
#define BCM53600_A0_BUFCONm_F_Mf_GET(r) ((((r).bufcon[1]) >> 8) & 0x1)
#define BCM53600_A0_BUFCONm_F_Mf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_BUFCONm_IGR_CTAGf_GET(r) ((((r).bufcon[1]) >> 9) & 0x3)
#define BCM53600_A0_BUFCONm_IGR_CTAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53600_A0_BUFCONm_IGR_STAGf_GET(r) ((((r).bufcon[1]) >> 11) & 0x3)
#define BCM53600_A0_BUFCONm_IGR_STAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_BUFCONm_TCf_GET(r) ((((r).bufcon[1]) >> 13) & 0xf)
#define BCM53600_A0_BUFCONm_TCf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM53600_A0_BUFCONm_DPf_GET(r) ((((r).bufcon[1]) >> 17) & 0x3)
#define BCM53600_A0_BUFCONm_DPf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53600_A0_BUFCONm_DNMf_GET(r) ((((r).bufcon[1]) >> 19) & 0x1)
#define BCM53600_A0_BUFCONm_DNMf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53600_A0_BUFCONm_VPORT_CPCPf_GET(r) ((((r).bufcon[1]) >> 20) & 0x7)
#define BCM53600_A0_BUFCONm_VPORT_CPCPf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM53600_A0_BUFCONm_VPORT_SPCPf_GET(r) ((((r).bufcon[1]) >> 23) & 0x7)
#define BCM53600_A0_BUFCONm_VPORT_SPCPf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM53600_A0_BUFCONm_CPCP_MARKINGf_GET(r) ((((r).bufcon[1]) >> 26) & 0x3)
#define BCM53600_A0_BUFCONm_CPCP_MARKINGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53600_A0_BUFCONm_SPCP_MARKINGf_GET(r) ((((r).bufcon[1]) >> 28) & 0x3)
#define BCM53600_A0_BUFCONm_SPCP_MARKINGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_BUFCONm_TX_TS_ENf_GET(r) ((((r).bufcon[1]) >> 30) & 0x1)
#define BCM53600_A0_BUFCONm_TX_TS_ENf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53600_A0_BUFCONm_REASONf_GET(r) cdk_field32_get((r).bufcon,63,78)
#define BCM53600_A0_BUFCONm_REASONf_SET(r,f) cdk_field32_set((r).bufcon,63,78,f)
#define BCM53600_A0_BUFCONm_L_DISf_GET(r) ((((r).bufcon[2]) >> 15) & 0x1)
#define BCM53600_A0_BUFCONm_L_DISf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_BUFCONm_RESVf_GET(r) ((((r).bufcon[2]) >> 16) & 0x7)
#define BCM53600_A0_BUFCONm_RESVf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53600_A0_BUFCONm_VIDf_GET(r) ((((r).bufcon[2]) >> 19) & 0xfff)
#define BCM53600_A0_BUFCONm_VIDf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0xfff << 19)) | ((((uint32_t)f) & 0xfff) << 19))
#define BCM53600_A0_BUFCONm_RX_TS_ENf_GET(r) ((((r).bufcon[2]) >> 31) & 0x1)
#define BCM53600_A0_BUFCONm_RX_TS_ENf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53600_A0_BUFCONm_REF_CNTf_GET(r) (((r).bufcon[3]) & 0x3f)
#define BCM53600_A0_BUFCONm_REF_CNTf_SET(r,f) (r).bufcon[3]=(((r).bufcon[3] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access BUFCON.
 *
 */
#define BCM53600_A0_READ_BUFCONm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_BUFCONm,i,(m),13)
#define BCM53600_A0_WRITE_BUFCONm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_BUFCONm,i,&(m),13)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCONm BCM53600_A0_BUFCONm
#define BUFCONm_MIN BCM53600_A0_BUFCONm_MIN
#define BUFCONm_MAX BCM53600_A0_BUFCONm_MAX
#define BUFCONm_CMAX(u) BCM53600_A0_BUFCONm_CMAX(u)
#define BUFCONm_SIZE BCM53600_A0_BUFCONm_SIZE
typedef BCM53600_A0_BUFCONm_t BUFCONm_t;
#define BUFCONm_CLR BCM53600_A0_BUFCONm_CLR
#define BUFCONm_SET BCM53600_A0_BUFCONm_SET
#define BUFCONm_GET BCM53600_A0_BUFCONm_GET
#define BUFCONm_FM_LENf_GET BCM53600_A0_BUFCONm_FM_LENf_GET
#define BUFCONm_FM_LENf_SET BCM53600_A0_BUFCONm_FM_LENf_SET
#define BUFCONm_INGRESS_PORTf_GET BCM53600_A0_BUFCONm_INGRESS_PORTf_GET
#define BUFCONm_INGRESS_PORTf_SET BCM53600_A0_BUFCONm_INGRESS_PORTf_SET
#define BUFCONm_INGRESS_VPORTf_GET BCM53600_A0_BUFCONm_INGRESS_VPORTf_GET
#define BUFCONm_INGRESS_VPORTf_SET BCM53600_A0_BUFCONm_INGRESS_VPORTf_SET
#define BUFCONm_EGRESS_VPORTf_GET BCM53600_A0_BUFCONm_EGRESS_VPORTf_GET
#define BUFCONm_EGRESS_VPORTf_SET BCM53600_A0_BUFCONm_EGRESS_VPORTf_SET
#define BUFCONm_FLOW_ID_MGIDf_GET BCM53600_A0_BUFCONm_FLOW_ID_MGIDf_GET
#define BUFCONm_FLOW_ID_MGIDf_SET BCM53600_A0_BUFCONm_FLOW_ID_MGIDf_SET
#define BUFCONm_F_Mf_GET BCM53600_A0_BUFCONm_F_Mf_GET
#define BUFCONm_F_Mf_SET BCM53600_A0_BUFCONm_F_Mf_SET
#define BUFCONm_IGR_CTAGf_GET BCM53600_A0_BUFCONm_IGR_CTAGf_GET
#define BUFCONm_IGR_CTAGf_SET BCM53600_A0_BUFCONm_IGR_CTAGf_SET
#define BUFCONm_IGR_STAGf_GET BCM53600_A0_BUFCONm_IGR_STAGf_GET
#define BUFCONm_IGR_STAGf_SET BCM53600_A0_BUFCONm_IGR_STAGf_SET
#define BUFCONm_TCf_GET BCM53600_A0_BUFCONm_TCf_GET
#define BUFCONm_TCf_SET BCM53600_A0_BUFCONm_TCf_SET
#define BUFCONm_DPf_GET BCM53600_A0_BUFCONm_DPf_GET
#define BUFCONm_DPf_SET BCM53600_A0_BUFCONm_DPf_SET
#define BUFCONm_DNMf_GET BCM53600_A0_BUFCONm_DNMf_GET
#define BUFCONm_DNMf_SET BCM53600_A0_BUFCONm_DNMf_SET
#define BUFCONm_VPORT_CPCPf_GET BCM53600_A0_BUFCONm_VPORT_CPCPf_GET
#define BUFCONm_VPORT_CPCPf_SET BCM53600_A0_BUFCONm_VPORT_CPCPf_SET
#define BUFCONm_VPORT_SPCPf_GET BCM53600_A0_BUFCONm_VPORT_SPCPf_GET
#define BUFCONm_VPORT_SPCPf_SET BCM53600_A0_BUFCONm_VPORT_SPCPf_SET
#define BUFCONm_CPCP_MARKINGf_GET BCM53600_A0_BUFCONm_CPCP_MARKINGf_GET
#define BUFCONm_CPCP_MARKINGf_SET BCM53600_A0_BUFCONm_CPCP_MARKINGf_SET
#define BUFCONm_SPCP_MARKINGf_GET BCM53600_A0_BUFCONm_SPCP_MARKINGf_GET
#define BUFCONm_SPCP_MARKINGf_SET BCM53600_A0_BUFCONm_SPCP_MARKINGf_SET
#define BUFCONm_TX_TS_ENf_GET BCM53600_A0_BUFCONm_TX_TS_ENf_GET
#define BUFCONm_TX_TS_ENf_SET BCM53600_A0_BUFCONm_TX_TS_ENf_SET
#define BUFCONm_REASONf_GET BCM53600_A0_BUFCONm_REASONf_GET
#define BUFCONm_REASONf_SET BCM53600_A0_BUFCONm_REASONf_SET
#define BUFCONm_L_DISf_GET BCM53600_A0_BUFCONm_L_DISf_GET
#define BUFCONm_L_DISf_SET BCM53600_A0_BUFCONm_L_DISf_SET
#define BUFCONm_RESVf_GET BCM53600_A0_BUFCONm_RESVf_GET
#define BUFCONm_RESVf_SET BCM53600_A0_BUFCONm_RESVf_SET
#define BUFCONm_VIDf_GET BCM53600_A0_BUFCONm_VIDf_GET
#define BUFCONm_VIDf_SET BCM53600_A0_BUFCONm_VIDf_SET
#define BUFCONm_RX_TS_ENf_GET BCM53600_A0_BUFCONm_RX_TS_ENf_GET
#define BUFCONm_RX_TS_ENf_SET BCM53600_A0_BUFCONm_RX_TS_ENf_SET
#define BUFCONm_REF_CNTf_GET BCM53600_A0_BUFCONm_REF_CNTf_GET
#define BUFCONm_REF_CNTf_SET BCM53600_A0_BUFCONm_REF_CNTf_SET
#define READ_BUFCONm BCM53600_A0_READ_BUFCONm
#define WRITE_BUFCONm BCM53600_A0_WRITE_BUFCONm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_BUFCONm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_ACT_POL
 * BLOCKS:   SYS
 * DESC:     CFP Action Table
 * SIZE:     72
 * FIELDS:
 *     FLOW_OR_CHAIN_ID FlowID or ChainID
 *     FLOW_OR_CHAIN_SEL FlowID or ChainID
 *     NEW_VID          Vlan id
 *     NEW_TC           Change TC value
 *     CHANGE_TC        Change TC enable
 *     NEW_DP_GREEN     Change DP enable for green color packet
 *     CHANGE_DP_GREEN  Change DP enable for green color packet
 *     NEW_DP_YELLOW    Change DP enable for yellow color packet
 *     CHANGE_DP_YELLOW Change DP enable for yellow color packet
 *     DEST_ID          DEST ID
 *     CHANGE_FWD       Change FWD enable
 *     DROP_ON_YELLOW   Drop on Yellow rate violation
 *     RESVD            reserve
 *     COS2CPU          COS2CPU inducates the COS queue through which the pkt is copied to CPU
 *     CPU_COPY         CPU_COPY enable
 *     MIR_COPY         Mirror copy enable
 *     DA_KNOWN         DA knowm enable
 *     LRN_DIS          Disable Learn
 *     FLT_BYP          Bypass Filter
 *     DNM              Do Not Modified
 *     VPORT_ID         Vport id
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_ACT_POLm 0x00000000

#define BCM53600_A0_CFP_ACT_POLm_MIN 0
#define BCM53600_A0_CFP_ACT_POLm_MAX 1535
#define BCM53600_A0_CFP_ACT_POLm_CMAX(u) 1535
#define BCM53600_A0_CFP_ACT_POLm_SIZE 9

/*
 * This structure should be used to declare and program CFP_ACT_POL.
 *
 */
typedef union BCM53600_A0_CFP_ACT_POLm_s {
	uint32_t v[3];
	uint32_t cfp_act_pol[3];
	uint32_t _cfp_act_pol;
} BCM53600_A0_CFP_ACT_POLm_t;

#define BCM53600_A0_CFP_ACT_POLm_CLR(r) CDK_MEMSET(&((r)._cfp_act_pol), 0, sizeof(BCM53600_A0_CFP_ACT_POLm_t))
#define BCM53600_A0_CFP_ACT_POLm_SET(r,i,d) (r).cfp_act_pol[i] = d
#define BCM53600_A0_CFP_ACT_POLm_GET(r,i) (r).cfp_act_pol[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_IDf_GET(r) (((r).cfp_act_pol[0]) & 0xfff)
#define BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_IDf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_SELf_GET(r) ((((r).cfp_act_pol[0]) >> 12) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_SELf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_CFP_ACT_POLm_NEW_VIDf_GET(r) ((((r).cfp_act_pol[0]) >> 13) & 0xfff)
#define BCM53600_A0_CFP_ACT_POLm_NEW_VIDf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0xfff << 13)) | ((((uint32_t)f) & 0xfff) << 13))
#define BCM53600_A0_CFP_ACT_POLm_NEW_TCf_GET(r) ((((r).cfp_act_pol[0]) >> 25) & 0xf)
#define BCM53600_A0_CFP_ACT_POLm_NEW_TCf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_TCf_GET(r) ((((r).cfp_act_pol[0]) >> 29) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_TCf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53600_A0_CFP_ACT_POLm_NEW_DP_GREENf_GET(r) ((((r).cfp_act_pol[0]) >> 30) & 0x3)
#define BCM53600_A0_CFP_ACT_POLm_NEW_DP_GREENf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_GREENf_GET(r) (((r).cfp_act_pol[1]) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_GREENf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_CFP_ACT_POLm_NEW_DP_YELLOWf_GET(r) ((((r).cfp_act_pol[1]) >> 1) & 0x3)
#define BCM53600_A0_CFP_ACT_POLm_NEW_DP_YELLOWf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_YELLOWf_GET(r) ((((r).cfp_act_pol[1]) >> 3) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_YELLOWf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_CFP_ACT_POLm_DEST_IDf_GET(r) ((((r).cfp_act_pol[1]) >> 4) & 0x1fff)
#define BCM53600_A0_CFP_ACT_POLm_DEST_IDf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1fff << 4)) | ((((uint32_t)f) & 0x1fff) << 4))
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_FWDf_GET(r) ((((r).cfp_act_pol[1]) >> 17) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_CHANGE_FWDf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_CFP_ACT_POLm_DROP_ON_YELLOWf_GET(r) ((((r).cfp_act_pol[1]) >> 18) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_DROP_ON_YELLOWf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53600_A0_CFP_ACT_POLm_RESVDf_GET(r) ((((r).cfp_act_pol[1]) >> 19) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_RESVDf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53600_A0_CFP_ACT_POLm_COS2CPUf_GET(r) ((((r).cfp_act_pol[1]) >> 20) & 0x7)
#define BCM53600_A0_CFP_ACT_POLm_COS2CPUf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM53600_A0_CFP_ACT_POLm_CPU_COPYf_GET(r) ((((r).cfp_act_pol[1]) >> 23) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_CPU_COPYf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53600_A0_CFP_ACT_POLm_MIR_COPYf_GET(r) ((((r).cfp_act_pol[1]) >> 24) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_MIR_COPYf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53600_A0_CFP_ACT_POLm_DA_KNOWNf_GET(r) ((((r).cfp_act_pol[1]) >> 25) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_DA_KNOWNf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53600_A0_CFP_ACT_POLm_LRN_DISf_GET(r) ((((r).cfp_act_pol[1]) >> 26) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_LRN_DISf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53600_A0_CFP_ACT_POLm_FLT_BYPf_GET(r) cdk_field32_get((r).cfp_act_pol,59,66)
#define BCM53600_A0_CFP_ACT_POLm_FLT_BYPf_SET(r,f) cdk_field32_set((r).cfp_act_pol,59,66,f)
#define BCM53600_A0_CFP_ACT_POLm_DNMf_GET(r) ((((r).cfp_act_pol[2]) >> 3) & 0x1)
#define BCM53600_A0_CFP_ACT_POLm_DNMf_SET(r,f) (r).cfp_act_pol[2]=(((r).cfp_act_pol[2] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_CFP_ACT_POLm_VPORT_IDf_GET(r) ((((r).cfp_act_pol[2]) >> 4) & 0xf)
#define BCM53600_A0_CFP_ACT_POLm_VPORT_IDf_SET(r,f) (r).cfp_act_pol[2]=(((r).cfp_act_pol[2] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access CFP_ACT_POL.
 *
 */
#define BCM53600_A0_READ_CFP_ACT_POLm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_ACT_POLm,i,(m),9)
#define BCM53600_A0_WRITE_CFP_ACT_POLm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_ACT_POLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACT_POLm BCM53600_A0_CFP_ACT_POLm
#define CFP_ACT_POLm_MIN BCM53600_A0_CFP_ACT_POLm_MIN
#define CFP_ACT_POLm_MAX BCM53600_A0_CFP_ACT_POLm_MAX
#define CFP_ACT_POLm_CMAX(u) BCM53600_A0_CFP_ACT_POLm_CMAX(u)
#define CFP_ACT_POLm_SIZE BCM53600_A0_CFP_ACT_POLm_SIZE
typedef BCM53600_A0_CFP_ACT_POLm_t CFP_ACT_POLm_t;
#define CFP_ACT_POLm_CLR BCM53600_A0_CFP_ACT_POLm_CLR
#define CFP_ACT_POLm_SET BCM53600_A0_CFP_ACT_POLm_SET
#define CFP_ACT_POLm_GET BCM53600_A0_CFP_ACT_POLm_GET
#define CFP_ACT_POLm_FLOW_OR_CHAIN_IDf_GET BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_IDf_GET
#define CFP_ACT_POLm_FLOW_OR_CHAIN_IDf_SET BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_IDf_SET
#define CFP_ACT_POLm_FLOW_OR_CHAIN_SELf_GET BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_SELf_GET
#define CFP_ACT_POLm_FLOW_OR_CHAIN_SELf_SET BCM53600_A0_CFP_ACT_POLm_FLOW_OR_CHAIN_SELf_SET
#define CFP_ACT_POLm_NEW_VIDf_GET BCM53600_A0_CFP_ACT_POLm_NEW_VIDf_GET
#define CFP_ACT_POLm_NEW_VIDf_SET BCM53600_A0_CFP_ACT_POLm_NEW_VIDf_SET
#define CFP_ACT_POLm_NEW_TCf_GET BCM53600_A0_CFP_ACT_POLm_NEW_TCf_GET
#define CFP_ACT_POLm_NEW_TCf_SET BCM53600_A0_CFP_ACT_POLm_NEW_TCf_SET
#define CFP_ACT_POLm_CHANGE_TCf_GET BCM53600_A0_CFP_ACT_POLm_CHANGE_TCf_GET
#define CFP_ACT_POLm_CHANGE_TCf_SET BCM53600_A0_CFP_ACT_POLm_CHANGE_TCf_SET
#define CFP_ACT_POLm_NEW_DP_GREENf_GET BCM53600_A0_CFP_ACT_POLm_NEW_DP_GREENf_GET
#define CFP_ACT_POLm_NEW_DP_GREENf_SET BCM53600_A0_CFP_ACT_POLm_NEW_DP_GREENf_SET
#define CFP_ACT_POLm_CHANGE_DP_GREENf_GET BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_GREENf_GET
#define CFP_ACT_POLm_CHANGE_DP_GREENf_SET BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_GREENf_SET
#define CFP_ACT_POLm_NEW_DP_YELLOWf_GET BCM53600_A0_CFP_ACT_POLm_NEW_DP_YELLOWf_GET
#define CFP_ACT_POLm_NEW_DP_YELLOWf_SET BCM53600_A0_CFP_ACT_POLm_NEW_DP_YELLOWf_SET
#define CFP_ACT_POLm_CHANGE_DP_YELLOWf_GET BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_YELLOWf_GET
#define CFP_ACT_POLm_CHANGE_DP_YELLOWf_SET BCM53600_A0_CFP_ACT_POLm_CHANGE_DP_YELLOWf_SET
#define CFP_ACT_POLm_DEST_IDf_GET BCM53600_A0_CFP_ACT_POLm_DEST_IDf_GET
#define CFP_ACT_POLm_DEST_IDf_SET BCM53600_A0_CFP_ACT_POLm_DEST_IDf_SET
#define CFP_ACT_POLm_CHANGE_FWDf_GET BCM53600_A0_CFP_ACT_POLm_CHANGE_FWDf_GET
#define CFP_ACT_POLm_CHANGE_FWDf_SET BCM53600_A0_CFP_ACT_POLm_CHANGE_FWDf_SET
#define CFP_ACT_POLm_DROP_ON_YELLOWf_GET BCM53600_A0_CFP_ACT_POLm_DROP_ON_YELLOWf_GET
#define CFP_ACT_POLm_DROP_ON_YELLOWf_SET BCM53600_A0_CFP_ACT_POLm_DROP_ON_YELLOWf_SET
#define CFP_ACT_POLm_RESVDf_GET BCM53600_A0_CFP_ACT_POLm_RESVDf_GET
#define CFP_ACT_POLm_RESVDf_SET BCM53600_A0_CFP_ACT_POLm_RESVDf_SET
#define CFP_ACT_POLm_COS2CPUf_GET BCM53600_A0_CFP_ACT_POLm_COS2CPUf_GET
#define CFP_ACT_POLm_COS2CPUf_SET BCM53600_A0_CFP_ACT_POLm_COS2CPUf_SET
#define CFP_ACT_POLm_CPU_COPYf_GET BCM53600_A0_CFP_ACT_POLm_CPU_COPYf_GET
#define CFP_ACT_POLm_CPU_COPYf_SET BCM53600_A0_CFP_ACT_POLm_CPU_COPYf_SET
#define CFP_ACT_POLm_MIR_COPYf_GET BCM53600_A0_CFP_ACT_POLm_MIR_COPYf_GET
#define CFP_ACT_POLm_MIR_COPYf_SET BCM53600_A0_CFP_ACT_POLm_MIR_COPYf_SET
#define CFP_ACT_POLm_DA_KNOWNf_GET BCM53600_A0_CFP_ACT_POLm_DA_KNOWNf_GET
#define CFP_ACT_POLm_DA_KNOWNf_SET BCM53600_A0_CFP_ACT_POLm_DA_KNOWNf_SET
#define CFP_ACT_POLm_LRN_DISf_GET BCM53600_A0_CFP_ACT_POLm_LRN_DISf_GET
#define CFP_ACT_POLm_LRN_DISf_SET BCM53600_A0_CFP_ACT_POLm_LRN_DISf_SET
#define CFP_ACT_POLm_FLT_BYPf_GET BCM53600_A0_CFP_ACT_POLm_FLT_BYPf_GET
#define CFP_ACT_POLm_FLT_BYPf_SET BCM53600_A0_CFP_ACT_POLm_FLT_BYPf_SET
#define CFP_ACT_POLm_DNMf_GET BCM53600_A0_CFP_ACT_POLm_DNMf_GET
#define CFP_ACT_POLm_DNMf_SET BCM53600_A0_CFP_ACT_POLm_DNMf_SET
#define CFP_ACT_POLm_VPORT_IDf_GET BCM53600_A0_CFP_ACT_POLm_VPORT_IDf_GET
#define CFP_ACT_POLm_VPORT_IDf_SET BCM53600_A0_CFP_ACT_POLm_VPORT_IDf_SET
#define READ_CFP_ACT_POLm BCM53600_A0_READ_CFP_ACT_POLm
#define WRITE_CFP_ACT_POLm BCM53600_A0_WRITE_CFP_ACT_POLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_ACT_POLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_DATA
 * BLOCKS:   SYS
 * DESC:     CFP_DATA Table
 * SIZE:     512
 * FIELDS:
 *     CFP_TCAM_DATA_L  CFP_TCAM_DATA_LOW
 *     CFP_TCAM_DATA_L_VALID valid bits of CFP_TCAM_DATA_LOW
 *     RESERVED_1       reserved
 *     CFP_TCAM_DATA_H  CFP_TCAM_DATA_HIGH
 *     CFP_TCAM_DATA_H_VALID valid bits of CFP_TCAM_DATA_HIGH
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_DATAm 0x00000000

#define BCM53600_A0_CFP_DATAm_MIN 0
#define BCM53600_A0_CFP_DATAm_MAX 1535
#define BCM53600_A0_CFP_DATAm_CMAX(u) 1535
#define BCM53600_A0_CFP_DATAm_SIZE 64

/*
 * This structure should be used to declare and program CFP_DATA.
 *
 */
typedef union BCM53600_A0_CFP_DATAm_s {
	uint32_t v[16];
	uint32_t cfp_data[16];
	uint32_t _cfp_data;
} BCM53600_A0_CFP_DATAm_t;

#define BCM53600_A0_CFP_DATAm_CLR(r) CDK_MEMSET(&((r)._cfp_data), 0, sizeof(BCM53600_A0_CFP_DATAm_t))
#define BCM53600_A0_CFP_DATAm_SET(r,i,d) (r).cfp_data[i] = d
#define BCM53600_A0_CFP_DATAm_GET(r,i) (r).cfp_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Lf_GET(r,a) cdk_field_get((r).cfp_data,0,229,a)
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Lf_SET(r,a) cdk_field_set((r).cfp_data,0,229,a)
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_L_VALIDf_GET(r) ((((r).cfp_data[7]) >> 6) & 0x3)
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_L_VALIDf_SET(r,f) (r).cfp_data[7]=(((r).cfp_data[7] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_DATAm_RESERVED_1f_GET(r) ((((r).cfp_data[7]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_DATAm_RESERVED_1f_SET(r,f) (r).cfp_data[7]=(((r).cfp_data[7] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Hf_GET(r,a) cdk_field_get((r).cfp_data,256,485,a)
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Hf_SET(r,a) cdk_field_set((r).cfp_data,256,485,a)
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_H_VALIDf_GET(r) ((((r).cfp_data[15]) >> 6) & 0x3)
#define BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_H_VALIDf_SET(r,f) (r).cfp_data[15]=(((r).cfp_data[15] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_DATAm_RESERVEDf_GET(r) ((((r).cfp_data[15]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_DATAm_RESERVEDf_SET(r,f) (r).cfp_data[15]=(((r).cfp_data[15] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CFP_DATA.
 *
 */
#define BCM53600_A0_READ_CFP_DATAm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_DATAm,i,(m),64)
#define BCM53600_A0_WRITE_CFP_DATAm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_DATAm,i,&(m),64)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_DATAm BCM53600_A0_CFP_DATAm
#define CFP_DATAm_MIN BCM53600_A0_CFP_DATAm_MIN
#define CFP_DATAm_MAX BCM53600_A0_CFP_DATAm_MAX
#define CFP_DATAm_CMAX(u) BCM53600_A0_CFP_DATAm_CMAX(u)
#define CFP_DATAm_SIZE BCM53600_A0_CFP_DATAm_SIZE
typedef BCM53600_A0_CFP_DATAm_t CFP_DATAm_t;
#define CFP_DATAm_CLR BCM53600_A0_CFP_DATAm_CLR
#define CFP_DATAm_SET BCM53600_A0_CFP_DATAm_SET
#define CFP_DATAm_GET BCM53600_A0_CFP_DATAm_GET
#define CFP_DATAm_CFP_TCAM_DATA_Lf_GET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Lf_GET
#define CFP_DATAm_CFP_TCAM_DATA_Lf_SET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Lf_SET
#define CFP_DATAm_CFP_TCAM_DATA_L_VALIDf_GET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_L_VALIDf_GET
#define CFP_DATAm_CFP_TCAM_DATA_L_VALIDf_SET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_L_VALIDf_SET
#define CFP_DATAm_RESERVED_1f_GET BCM53600_A0_CFP_DATAm_RESERVED_1f_GET
#define CFP_DATAm_RESERVED_1f_SET BCM53600_A0_CFP_DATAm_RESERVED_1f_SET
#define CFP_DATAm_CFP_TCAM_DATA_Hf_GET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Hf_GET
#define CFP_DATAm_CFP_TCAM_DATA_Hf_SET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_Hf_SET
#define CFP_DATAm_CFP_TCAM_DATA_H_VALIDf_GET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_H_VALIDf_GET
#define CFP_DATAm_CFP_TCAM_DATA_H_VALIDf_SET BCM53600_A0_CFP_DATAm_CFP_TCAM_DATA_H_VALIDf_SET
#define CFP_DATAm_RESERVEDf_GET BCM53600_A0_CFP_DATAm_RESERVEDf_GET
#define CFP_DATAm_RESERVEDf_SET BCM53600_A0_CFP_DATAm_RESERVEDf_SET
#define READ_CFP_DATAm BCM53600_A0_READ_CFP_DATAm
#define WRITE_CFP_DATAm BCM53600_A0_WRITE_CFP_DATAm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_DATAm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_DATA_MASK
 * BLOCKS:   SYS
 * DESC:     CFP_DATA_MASK Table
 * SIZE:     1024
 * FIELDS:
 *     CFP_TCAM_DATA_L  CFP_TCAM_DATA_LOW
 *     CFP_TCAM_DATA_L_VALID valid bits of CFP_TCAM_DATA_LOW
 *     RESERVED_3       reserved
 *     CFP_TCAM_DATA_H  CFP_TCAM_DATA_HIGH
 *     CFP_TCAM_DATA_H_VALID valid bits of CFP_TCAM_DATA_HIGH
 *     RESERVED_2       reserved
 *     CFP_TCAM_MASK_L  CFP_TCAM_MASK_LOW
 *     CFP_TCAM_MASK_L_VALID valid bits of CFP_TCAM_MASK_LOW
 *     RESERVED_1       reserved
 *     CFP_TCAM_MASK_H  CFP_TCAM_MASK_HIGH
 *     CFP_TCAM_MASK_H_VALID valid bits of CFP_TCAM_MASK_HIGH
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_DATA_MASKm 0x00000000

#define BCM53600_A0_CFP_DATA_MASKm_MIN 0
#define BCM53600_A0_CFP_DATA_MASKm_MAX 1535
#define BCM53600_A0_CFP_DATA_MASKm_CMAX(u) 1535
#define BCM53600_A0_CFP_DATA_MASKm_SIZE 128

/*
 * This structure should be used to declare and program CFP_DATA_MASK.
 *
 */
typedef union BCM53600_A0_CFP_DATA_MASKm_s {
	uint32_t v[32];
	uint32_t cfp_data_mask[32];
	uint32_t _cfp_data_mask;
} BCM53600_A0_CFP_DATA_MASKm_t;

#define BCM53600_A0_CFP_DATA_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_data_mask), 0, sizeof(BCM53600_A0_CFP_DATA_MASKm_t))
#define BCM53600_A0_CFP_DATA_MASKm_SET(r,i,d) (r).cfp_data_mask[i] = d
#define BCM53600_A0_CFP_DATA_MASKm_GET(r,i) (r).cfp_data_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Lf_GET(r,a) cdk_field_get((r).cfp_data_mask,0,229,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Lf_SET(r,a) cdk_field_set((r).cfp_data_mask,0,229,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_L_VALIDf_GET(r) ((((r).cfp_data_mask[7]) >> 6) & 0x3)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_L_VALIDf_SET(r,f) (r).cfp_data_mask[7]=(((r).cfp_data_mask[7] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_DATA_MASKm_RESERVED_3f_GET(r) ((((r).cfp_data_mask[7]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_DATA_MASKm_RESERVED_3f_SET(r,f) (r).cfp_data_mask[7]=(((r).cfp_data_mask[7] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Hf_GET(r,a) cdk_field_get((r).cfp_data_mask,256,485,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Hf_SET(r,a) cdk_field_set((r).cfp_data_mask,256,485,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_H_VALIDf_GET(r) ((((r).cfp_data_mask[15]) >> 6) & 0x3)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_H_VALIDf_SET(r,f) (r).cfp_data_mask[15]=(((r).cfp_data_mask[15] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_DATA_MASKm_RESERVED_2f_GET(r) ((((r).cfp_data_mask[15]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_DATA_MASKm_RESERVED_2f_SET(r,f) (r).cfp_data_mask[15]=(((r).cfp_data_mask[15] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Lf_GET(r,a) cdk_field_get((r).cfp_data_mask,512,741,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Lf_SET(r,a) cdk_field_set((r).cfp_data_mask,512,741,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_L_VALIDf_GET(r) ((((r).cfp_data_mask[23]) >> 6) & 0x3)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_L_VALIDf_SET(r,f) (r).cfp_data_mask[23]=(((r).cfp_data_mask[23] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_DATA_MASKm_RESERVED_1f_GET(r) ((((r).cfp_data_mask[23]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_DATA_MASKm_RESERVED_1f_SET(r,f) (r).cfp_data_mask[23]=(((r).cfp_data_mask[23] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Hf_GET(r,a) cdk_field_get((r).cfp_data_mask,768,970,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Hf_SET(r,a) cdk_field_set((r).cfp_data_mask,768,970,a)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_H_VALIDf_GET(r) cdk_field32_get((r).cfp_data_mask,971,999)
#define BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_H_VALIDf_SET(r,f) cdk_field32_set((r).cfp_data_mask,971,999,f)
#define BCM53600_A0_CFP_DATA_MASKm_RESERVEDf_GET(r) ((((r).cfp_data_mask[31]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_DATA_MASKm_RESERVEDf_SET(r,f) (r).cfp_data_mask[31]=(((r).cfp_data_mask[31] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CFP_DATA_MASK.
 *
 */
#define BCM53600_A0_READ_CFP_DATA_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_DATA_MASKm,i,(m),128)
#define BCM53600_A0_WRITE_CFP_DATA_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_DATA_MASKm,i,&(m),128)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_DATA_MASKm BCM53600_A0_CFP_DATA_MASKm
#define CFP_DATA_MASKm_MIN BCM53600_A0_CFP_DATA_MASKm_MIN
#define CFP_DATA_MASKm_MAX BCM53600_A0_CFP_DATA_MASKm_MAX
#define CFP_DATA_MASKm_CMAX(u) BCM53600_A0_CFP_DATA_MASKm_CMAX(u)
#define CFP_DATA_MASKm_SIZE BCM53600_A0_CFP_DATA_MASKm_SIZE
typedef BCM53600_A0_CFP_DATA_MASKm_t CFP_DATA_MASKm_t;
#define CFP_DATA_MASKm_CLR BCM53600_A0_CFP_DATA_MASKm_CLR
#define CFP_DATA_MASKm_SET BCM53600_A0_CFP_DATA_MASKm_SET
#define CFP_DATA_MASKm_GET BCM53600_A0_CFP_DATA_MASKm_GET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_Lf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Lf_GET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_Lf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Lf_SET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_L_VALIDf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_L_VALIDf_GET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_L_VALIDf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_L_VALIDf_SET
#define CFP_DATA_MASKm_RESERVED_3f_GET BCM53600_A0_CFP_DATA_MASKm_RESERVED_3f_GET
#define CFP_DATA_MASKm_RESERVED_3f_SET BCM53600_A0_CFP_DATA_MASKm_RESERVED_3f_SET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_Hf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Hf_GET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_Hf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_Hf_SET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_H_VALIDf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_H_VALIDf_GET
#define CFP_DATA_MASKm_CFP_TCAM_DATA_H_VALIDf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_DATA_H_VALIDf_SET
#define CFP_DATA_MASKm_RESERVED_2f_GET BCM53600_A0_CFP_DATA_MASKm_RESERVED_2f_GET
#define CFP_DATA_MASKm_RESERVED_2f_SET BCM53600_A0_CFP_DATA_MASKm_RESERVED_2f_SET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_Lf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Lf_GET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_Lf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Lf_SET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_L_VALIDf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_L_VALIDf_GET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_L_VALIDf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_L_VALIDf_SET
#define CFP_DATA_MASKm_RESERVED_1f_GET BCM53600_A0_CFP_DATA_MASKm_RESERVED_1f_GET
#define CFP_DATA_MASKm_RESERVED_1f_SET BCM53600_A0_CFP_DATA_MASKm_RESERVED_1f_SET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_Hf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Hf_GET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_Hf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_Hf_SET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_H_VALIDf_GET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_H_VALIDf_GET
#define CFP_DATA_MASKm_CFP_TCAM_MASK_H_VALIDf_SET BCM53600_A0_CFP_DATA_MASKm_CFP_TCAM_MASK_H_VALIDf_SET
#define CFP_DATA_MASKm_RESERVEDf_GET BCM53600_A0_CFP_DATA_MASKm_RESERVEDf_GET
#define CFP_DATA_MASKm_RESERVEDf_SET BCM53600_A0_CFP_DATA_MASKm_RESERVEDf_SET
#define READ_CFP_DATA_MASKm BCM53600_A0_READ_CFP_DATA_MASKm
#define WRITE_CFP_DATA_MASKm BCM53600_A0_WRITE_CFP_DATA_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_DATA_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CFP_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     CFP Enable Control Register
 * SIZE:     32
 * FIELDS:
 *     CFP_EN_CTRL      CFP Enable Control Register.A 29-bit mask which selectively allows any port with its corresponding bit set.When set to one, the corresponding port CFP feature is enabled.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_EN_CTRLr 0x00002120

#define BCM53600_A0_CFP_EN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CFP_EN_CTRL.
 *
 */
typedef union BCM53600_A0_CFP_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t cfp_en_ctrl[1];
	uint32_t _cfp_en_ctrl;
} BCM53600_A0_CFP_EN_CTRLr_t;

#define BCM53600_A0_CFP_EN_CTRLr_CLR(r) (r).cfp_en_ctrl[0] = 0
#define BCM53600_A0_CFP_EN_CTRLr_SET(r,d) (r).cfp_en_ctrl[0] = d
#define BCM53600_A0_CFP_EN_CTRLr_GET(r) (r).cfp_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_EN_CTRLr_CFP_EN_CTRLf_GET(r) (((r).cfp_en_ctrl[0]) & 0x1fffffff)
#define BCM53600_A0_CFP_EN_CTRLr_CFP_EN_CTRLf_SET(r,f) (r).cfp_en_ctrl[0]=(((r).cfp_en_ctrl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_CFP_EN_CTRLr_RESERVED_1f_GET(r) ((((r).cfp_en_ctrl[0]) >> 29) & 0x7)
#define BCM53600_A0_CFP_EN_CTRLr_RESERVED_1f_SET(r,f) (r).cfp_en_ctrl[0]=(((r).cfp_en_ctrl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CFP_EN_CTRL.
 *
 */
#define BCM53600_A0_READ_CFP_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CFP_EN_CTRLr,(r._cfp_en_ctrl),4)
#define BCM53600_A0_WRITE_CFP_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CFP_EN_CTRLr,&(r._cfp_en_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_EN_CTRLr BCM53600_A0_CFP_EN_CTRLr
#define CFP_EN_CTRLr_SIZE BCM53600_A0_CFP_EN_CTRLr_SIZE
typedef BCM53600_A0_CFP_EN_CTRLr_t CFP_EN_CTRLr_t;
#define CFP_EN_CTRLr_CLR BCM53600_A0_CFP_EN_CTRLr_CLR
#define CFP_EN_CTRLr_SET BCM53600_A0_CFP_EN_CTRLr_SET
#define CFP_EN_CTRLr_GET BCM53600_A0_CFP_EN_CTRLr_GET
#define CFP_EN_CTRLr_CFP_EN_CTRLf_GET BCM53600_A0_CFP_EN_CTRLr_CFP_EN_CTRLf_GET
#define CFP_EN_CTRLr_CFP_EN_CTRLf_SET BCM53600_A0_CFP_EN_CTRLr_CFP_EN_CTRLf_SET
#define CFP_EN_CTRLr_RESERVED_1f_GET BCM53600_A0_CFP_EN_CTRLr_RESERVED_1f_GET
#define CFP_EN_CTRLr_RESERVED_1f_SET BCM53600_A0_CFP_EN_CTRLr_RESERVED_1f_SET
#define READ_CFP_EN_CTRLr BCM53600_A0_READ_CFP_EN_CTRLr
#define WRITE_CFP_EN_CTRLr BCM53600_A0_WRITE_CFP_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CFP_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     Global CFP Control Registers
 * SIZE:     8
 * FIELDS:
 *     DSCP_CHKSUM_FFF_CTL DSCP Checksum Value "FFFF" Control.If ned DSCP Checksum Value == "FFFF".0 : Not to change.1 : Change new DSCP Checksum == '0000'.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_GLOBAL_CTLr 0x00002100

#define BCM53600_A0_CFP_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program CFP_GLOBAL_CTL.
 *
 */
typedef union BCM53600_A0_CFP_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t cfp_global_ctl[1];
	uint32_t _cfp_global_ctl;
} BCM53600_A0_CFP_GLOBAL_CTLr_t;

#define BCM53600_A0_CFP_GLOBAL_CTLr_CLR(r) (r).cfp_global_ctl[0] = 0
#define BCM53600_A0_CFP_GLOBAL_CTLr_SET(r,d) (r).cfp_global_ctl[0] = d
#define BCM53600_A0_CFP_GLOBAL_CTLr_GET(r) (r).cfp_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_GLOBAL_CTLr_DSCP_CHKSUM_FFF_CTLf_GET(r) (((r).cfp_global_ctl[0]) & 0x1)
#define BCM53600_A0_CFP_GLOBAL_CTLr_DSCP_CHKSUM_FFF_CTLf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_CFP_GLOBAL_CTLr_RESERVEDf_GET(r) ((((r).cfp_global_ctl[0]) >> 1) & 0x7f)
#define BCM53600_A0_CFP_GLOBAL_CTLr_RESERVEDf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access CFP_GLOBAL_CTL.
 *
 */
#define BCM53600_A0_READ_CFP_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CFP_GLOBAL_CTLr,(r._cfp_global_ctl),1)
#define BCM53600_A0_WRITE_CFP_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CFP_GLOBAL_CTLr,&(r._cfp_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_GLOBAL_CTLr BCM53600_A0_CFP_GLOBAL_CTLr
#define CFP_GLOBAL_CTLr_SIZE BCM53600_A0_CFP_GLOBAL_CTLr_SIZE
typedef BCM53600_A0_CFP_GLOBAL_CTLr_t CFP_GLOBAL_CTLr_t;
#define CFP_GLOBAL_CTLr_CLR BCM53600_A0_CFP_GLOBAL_CTLr_CLR
#define CFP_GLOBAL_CTLr_SET BCM53600_A0_CFP_GLOBAL_CTLr_SET
#define CFP_GLOBAL_CTLr_GET BCM53600_A0_CFP_GLOBAL_CTLr_GET
#define CFP_GLOBAL_CTLr_DSCP_CHKSUM_FFF_CTLf_GET BCM53600_A0_CFP_GLOBAL_CTLr_DSCP_CHKSUM_FFF_CTLf_GET
#define CFP_GLOBAL_CTLr_DSCP_CHKSUM_FFF_CTLf_SET BCM53600_A0_CFP_GLOBAL_CTLr_DSCP_CHKSUM_FFF_CTLf_SET
#define CFP_GLOBAL_CTLr_RESERVEDf_GET BCM53600_A0_CFP_GLOBAL_CTLr_RESERVEDf_GET
#define CFP_GLOBAL_CTLr_RESERVEDf_SET BCM53600_A0_CFP_GLOBAL_CTLr_RESERVEDf_SET
#define READ_CFP_GLOBAL_CTLr BCM53600_A0_READ_CFP_GLOBAL_CTLr
#define WRITE_CFP_GLOBAL_CTLr BCM53600_A0_WRITE_CFP_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_MASK
 * BLOCKS:   SYS
 * DESC:     CFP_MASK Table
 * SIZE:     512
 * FIELDS:
 *     CFP_TCAM_MASK_L  CFP_TCAM_MASK_L
 *     RESERVED_1       reserved
 *     CFP_TCAM_MASK_H  CFP_TCAM_MASK_H
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_MASKm 0x00000000

#define BCM53600_A0_CFP_MASKm_MIN 0
#define BCM53600_A0_CFP_MASKm_MAX 1535
#define BCM53600_A0_CFP_MASKm_CMAX(u) 1535
#define BCM53600_A0_CFP_MASKm_SIZE 64

/*
 * This structure should be used to declare and program CFP_MASK.
 *
 */
typedef union BCM53600_A0_CFP_MASKm_s {
	uint32_t v[16];
	uint32_t cfp_mask[16];
	uint32_t _cfp_mask;
} BCM53600_A0_CFP_MASKm_t;

#define BCM53600_A0_CFP_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_mask), 0, sizeof(BCM53600_A0_CFP_MASKm_t))
#define BCM53600_A0_CFP_MASKm_SET(r,i,d) (r).cfp_mask[i] = d
#define BCM53600_A0_CFP_MASKm_GET(r,i) (r).cfp_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Lf_GET(r,a) cdk_field_get((r).cfp_mask,0,231,a)
#define BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Lf_SET(r,a) cdk_field_set((r).cfp_mask,0,231,a)
#define BCM53600_A0_CFP_MASKm_RESERVED_1f_GET(r) ((((r).cfp_mask[7]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_MASKm_RESERVED_1f_SET(r,f) (r).cfp_mask[7]=(((r).cfp_mask[7] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))
#define BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Hf_GET(r,a) cdk_field_get((r).cfp_mask,256,487,a)
#define BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Hf_SET(r,a) cdk_field_set((r).cfp_mask,256,487,a)
#define BCM53600_A0_CFP_MASKm_RESERVEDf_GET(r) ((((r).cfp_mask[15]) >> 8) & 0xffffff)
#define BCM53600_A0_CFP_MASKm_RESERVEDf_SET(r,f) (r).cfp_mask[15]=(((r).cfp_mask[15] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CFP_MASK.
 *
 */
#define BCM53600_A0_READ_CFP_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_MASKm,i,(m),64)
#define BCM53600_A0_WRITE_CFP_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_MASKm,i,&(m),64)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_MASKm BCM53600_A0_CFP_MASKm
#define CFP_MASKm_MIN BCM53600_A0_CFP_MASKm_MIN
#define CFP_MASKm_MAX BCM53600_A0_CFP_MASKm_MAX
#define CFP_MASKm_CMAX(u) BCM53600_A0_CFP_MASKm_CMAX(u)
#define CFP_MASKm_SIZE BCM53600_A0_CFP_MASKm_SIZE
typedef BCM53600_A0_CFP_MASKm_t CFP_MASKm_t;
#define CFP_MASKm_CLR BCM53600_A0_CFP_MASKm_CLR
#define CFP_MASKm_SET BCM53600_A0_CFP_MASKm_SET
#define CFP_MASKm_GET BCM53600_A0_CFP_MASKm_GET
#define CFP_MASKm_CFP_TCAM_MASK_Lf_GET BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Lf_GET
#define CFP_MASKm_CFP_TCAM_MASK_Lf_SET BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Lf_SET
#define CFP_MASKm_RESERVED_1f_GET BCM53600_A0_CFP_MASKm_RESERVED_1f_GET
#define CFP_MASKm_RESERVED_1f_SET BCM53600_A0_CFP_MASKm_RESERVED_1f_SET
#define CFP_MASKm_CFP_TCAM_MASK_Hf_GET BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Hf_GET
#define CFP_MASKm_CFP_TCAM_MASK_Hf_SET BCM53600_A0_CFP_MASKm_CFP_TCAM_MASK_Hf_SET
#define CFP_MASKm_RESERVEDf_GET BCM53600_A0_CFP_MASKm_RESERVEDf_GET
#define CFP_MASKm_RESERVEDf_SET BCM53600_A0_CFP_MASKm_RESERVEDf_SET
#define READ_CFP_MASKm BCM53600_A0_READ_CFP_MASKm
#define WRITE_CFP_MASKm BCM53600_A0_WRITE_CFP_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_RATE_METER
 * BLOCKS:   SYS
 * DESC:     CFP Rate Meter Table
 * SIZE:     78
 * FIELDS:
 *     CIR_REF_CNT      CIR Refresh count
 *     CIR_BKT_SIZE     CIR Bucket size
 *     EN_CIR_RM        Enable CIR Rate Meter
 *     CF               Coupling Flag
 *     CM               Color Mode
 *     EIR_REF_CNT      EIR Refresh Count
 *     EIR_BKT_SIZE     EIR Bucket Size
 *     EN_EIR_RM        Enable EIR Rate Meter
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_RATE_METERm 0x00000000

#define BCM53600_A0_CFP_RATE_METERm_MIN 0
#define BCM53600_A0_CFP_RATE_METERm_MAX 1535
#define BCM53600_A0_CFP_RATE_METERm_CMAX(u) 1535
#define BCM53600_A0_CFP_RATE_METERm_SIZE 10

/*
 * This structure should be used to declare and program CFP_RATE_METER.
 *
 */
typedef union BCM53600_A0_CFP_RATE_METERm_s {
	uint32_t v[3];
	uint32_t cfp_rate_meter[3];
	uint32_t _cfp_rate_meter;
} BCM53600_A0_CFP_RATE_METERm_t;

#define BCM53600_A0_CFP_RATE_METERm_CLR(r) CDK_MEMSET(&((r)._cfp_rate_meter), 0, sizeof(BCM53600_A0_CFP_RATE_METERm_t))
#define BCM53600_A0_CFP_RATE_METERm_SET(r,i,d) (r).cfp_rate_meter[i] = d
#define BCM53600_A0_CFP_RATE_METERm_GET(r,i) (r).cfp_rate_meter[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_RATE_METERm_CIR_REF_CNTf_GET(r) (((r).cfp_rate_meter[0]) & 0x1ffff)
#define BCM53600_A0_CFP_RATE_METERm_CIR_REF_CNTf_SET(r,f) (r).cfp_rate_meter[0]=(((r).cfp_rate_meter[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53600_A0_CFP_RATE_METERm_CIR_BKT_SIZEf_GET(r) cdk_field32_get((r).cfp_rate_meter,17,36)
#define BCM53600_A0_CFP_RATE_METERm_CIR_BKT_SIZEf_SET(r,f) cdk_field32_set((r).cfp_rate_meter,17,36,f)
#define BCM53600_A0_CFP_RATE_METERm_EN_CIR_RMf_GET(r) ((((r).cfp_rate_meter[1]) >> 5) & 0x1)
#define BCM53600_A0_CFP_RATE_METERm_EN_CIR_RMf_SET(r,f) (r).cfp_rate_meter[1]=(((r).cfp_rate_meter[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_CFP_RATE_METERm_CFf_GET(r) ((((r).cfp_rate_meter[1]) >> 6) & 0x1)
#define BCM53600_A0_CFP_RATE_METERm_CFf_SET(r,f) (r).cfp_rate_meter[1]=(((r).cfp_rate_meter[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_CFP_RATE_METERm_CMf_GET(r) ((((r).cfp_rate_meter[1]) >> 7) & 0x1)
#define BCM53600_A0_CFP_RATE_METERm_CMf_SET(r,f) (r).cfp_rate_meter[1]=(((r).cfp_rate_meter[1] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_CFP_RATE_METERm_EIR_REF_CNTf_GET(r) ((((r).cfp_rate_meter[1]) >> 8) & 0x1ffff)
#define BCM53600_A0_CFP_RATE_METERm_EIR_REF_CNTf_SET(r,f) (r).cfp_rate_meter[1]=(((r).cfp_rate_meter[1] & ~((uint32_t)0x1ffff << 8)) | ((((uint32_t)f) & 0x1ffff) << 8))
#define BCM53600_A0_CFP_RATE_METERm_EIR_BKT_SIZEf_GET(r) cdk_field32_get((r).cfp_rate_meter,57,76)
#define BCM53600_A0_CFP_RATE_METERm_EIR_BKT_SIZEf_SET(r,f) cdk_field32_set((r).cfp_rate_meter,57,76,f)
#define BCM53600_A0_CFP_RATE_METERm_EN_EIR_RMf_GET(r) ((((r).cfp_rate_meter[2]) >> 13) & 0x1)
#define BCM53600_A0_CFP_RATE_METERm_EN_EIR_RMf_SET(r,f) (r).cfp_rate_meter[2]=(((r).cfp_rate_meter[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access CFP_RATE_METER.
 *
 */
#define BCM53600_A0_READ_CFP_RATE_METERm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_RATE_METERm,i,(m),10)
#define BCM53600_A0_WRITE_CFP_RATE_METERm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_RATE_METERm,i,&(m),10)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_RATE_METERm BCM53600_A0_CFP_RATE_METERm
#define CFP_RATE_METERm_MIN BCM53600_A0_CFP_RATE_METERm_MIN
#define CFP_RATE_METERm_MAX BCM53600_A0_CFP_RATE_METERm_MAX
#define CFP_RATE_METERm_CMAX(u) BCM53600_A0_CFP_RATE_METERm_CMAX(u)
#define CFP_RATE_METERm_SIZE BCM53600_A0_CFP_RATE_METERm_SIZE
typedef BCM53600_A0_CFP_RATE_METERm_t CFP_RATE_METERm_t;
#define CFP_RATE_METERm_CLR BCM53600_A0_CFP_RATE_METERm_CLR
#define CFP_RATE_METERm_SET BCM53600_A0_CFP_RATE_METERm_SET
#define CFP_RATE_METERm_GET BCM53600_A0_CFP_RATE_METERm_GET
#define CFP_RATE_METERm_CIR_REF_CNTf_GET BCM53600_A0_CFP_RATE_METERm_CIR_REF_CNTf_GET
#define CFP_RATE_METERm_CIR_REF_CNTf_SET BCM53600_A0_CFP_RATE_METERm_CIR_REF_CNTf_SET
#define CFP_RATE_METERm_CIR_BKT_SIZEf_GET BCM53600_A0_CFP_RATE_METERm_CIR_BKT_SIZEf_GET
#define CFP_RATE_METERm_CIR_BKT_SIZEf_SET BCM53600_A0_CFP_RATE_METERm_CIR_BKT_SIZEf_SET
#define CFP_RATE_METERm_EN_CIR_RMf_GET BCM53600_A0_CFP_RATE_METERm_EN_CIR_RMf_GET
#define CFP_RATE_METERm_EN_CIR_RMf_SET BCM53600_A0_CFP_RATE_METERm_EN_CIR_RMf_SET
#define CFP_RATE_METERm_CFf_GET BCM53600_A0_CFP_RATE_METERm_CFf_GET
#define CFP_RATE_METERm_CFf_SET BCM53600_A0_CFP_RATE_METERm_CFf_SET
#define CFP_RATE_METERm_CMf_GET BCM53600_A0_CFP_RATE_METERm_CMf_GET
#define CFP_RATE_METERm_CMf_SET BCM53600_A0_CFP_RATE_METERm_CMf_SET
#define CFP_RATE_METERm_EIR_REF_CNTf_GET BCM53600_A0_CFP_RATE_METERm_EIR_REF_CNTf_GET
#define CFP_RATE_METERm_EIR_REF_CNTf_SET BCM53600_A0_CFP_RATE_METERm_EIR_REF_CNTf_SET
#define CFP_RATE_METERm_EIR_BKT_SIZEf_GET BCM53600_A0_CFP_RATE_METERm_EIR_BKT_SIZEf_GET
#define CFP_RATE_METERm_EIR_BKT_SIZEf_SET BCM53600_A0_CFP_RATE_METERm_EIR_BKT_SIZEf_SET
#define CFP_RATE_METERm_EN_EIR_RMf_GET BCM53600_A0_CFP_RATE_METERm_EN_EIR_RMf_GET
#define CFP_RATE_METERm_EN_EIR_RMf_SET BCM53600_A0_CFP_RATE_METERm_EN_EIR_RMf_SET
#define READ_CFP_RATE_METERm BCM53600_A0_READ_CFP_RATE_METERm
#define WRITE_CFP_RATE_METERm BCM53600_A0_WRITE_CFP_RATE_METERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_RATE_METERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_STAT
 * BLOCKS:   SYS
 * DESC:     CFP Out_Band Statistic Table
 * SIZE:     96
 * FIELDS:
 *     GREEN_CNT        Green Color counter
 *     YELLOW_CNT       Yellow Color counter
 *     RED_CNT          Red Color counter
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_STATm 0x00000000

#define BCM53600_A0_CFP_STATm_MIN 0
#define BCM53600_A0_CFP_STATm_MAX 1535
#define BCM53600_A0_CFP_STATm_CMAX(u) 1535
#define BCM53600_A0_CFP_STATm_SIZE 12

/*
 * This structure should be used to declare and program CFP_STAT.
 *
 */
typedef union BCM53600_A0_CFP_STATm_s {
	uint32_t v[3];
	uint32_t cfp_stat[3];
	uint32_t _cfp_stat;
} BCM53600_A0_CFP_STATm_t;

#define BCM53600_A0_CFP_STATm_CLR(r) CDK_MEMSET(&((r)._cfp_stat), 0, sizeof(BCM53600_A0_CFP_STATm_t))
#define BCM53600_A0_CFP_STATm_SET(r,i,d) (r).cfp_stat[i] = d
#define BCM53600_A0_CFP_STATm_GET(r,i) (r).cfp_stat[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_STATm_GREEN_CNTf_GET(r) ((r).cfp_stat[0])
#define BCM53600_A0_CFP_STATm_GREEN_CNTf_SET(r,f) (r).cfp_stat[0]=((uint32_t)f)
#define BCM53600_A0_CFP_STATm_YELLOW_CNTf_GET(r) ((r).cfp_stat[1])
#define BCM53600_A0_CFP_STATm_YELLOW_CNTf_SET(r,f) (r).cfp_stat[1]=((uint32_t)f)
#define BCM53600_A0_CFP_STATm_RED_CNTf_GET(r) ((r).cfp_stat[2])
#define BCM53600_A0_CFP_STATm_RED_CNTf_SET(r,f) (r).cfp_stat[2]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT.
 *
 */
#define BCM53600_A0_READ_CFP_STATm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_STATm,i,(m),12)
#define BCM53600_A0_WRITE_CFP_STATm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_STATm,i,&(m),12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STATm BCM53600_A0_CFP_STATm
#define CFP_STATm_MIN BCM53600_A0_CFP_STATm_MIN
#define CFP_STATm_MAX BCM53600_A0_CFP_STATm_MAX
#define CFP_STATm_CMAX(u) BCM53600_A0_CFP_STATm_CMAX(u)
#define CFP_STATm_SIZE BCM53600_A0_CFP_STATm_SIZE
typedef BCM53600_A0_CFP_STATm_t CFP_STATm_t;
#define CFP_STATm_CLR BCM53600_A0_CFP_STATm_CLR
#define CFP_STATm_SET BCM53600_A0_CFP_STATm_SET
#define CFP_STATm_GET BCM53600_A0_CFP_STATm_GET
#define CFP_STATm_GREEN_CNTf_GET BCM53600_A0_CFP_STATm_GREEN_CNTf_GET
#define CFP_STATm_GREEN_CNTf_SET BCM53600_A0_CFP_STATm_GREEN_CNTf_SET
#define CFP_STATm_YELLOW_CNTf_GET BCM53600_A0_CFP_STATm_YELLOW_CNTf_GET
#define CFP_STATm_YELLOW_CNTf_SET BCM53600_A0_CFP_STATm_YELLOW_CNTf_SET
#define CFP_STATm_RED_CNTf_GET BCM53600_A0_CFP_STATm_RED_CNTf_GET
#define CFP_STATm_RED_CNTf_SET BCM53600_A0_CFP_STATm_RED_CNTf_SET
#define READ_CFP_STATm BCM53600_A0_READ_CFP_STATm
#define WRITE_CFP_STATm BCM53600_A0_WRITE_CFP_STATm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_STATm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_TCAM_CHAIN_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM SW Table
 * SIZE:     462
 * FIELDS:
 *     SLICEID          slice id
 *     UDF_D0_LO        UDF_3_D0 lo 32-bits
 *     UDF_D0_HI        UDF_3_D0 hi 32-bits
 *     UDF_D1_LO        UDF_3_D1 lo 32-bits
 *     UDF_D1_HI        UDF_3_D1 hi 32-bits
 *     UDF_D2           UDF_3_D2 32-bits
 *     UDF_D3           UDF_3_D3 32-bits
 *     UDF_D4           UDF_3_D4 32-bits
 *     UDF_D5           UDF_3_D5 32-bits
 *     UDF_D6           UDF_3_D6 32-bits
 *     UDF_D7           UDF_3_D7 32-bits
 *     UDF_D8           UDF_3_D8 32-bits
 *     UDF_D9           UDF_3_D9 16-bits
 *     UDF_D10          UDF_3_D10 16-bits
 *     UDF_D11          UDF_3_D11 8-bits
 *     UDFD_VLD         udf valid bits
 *     RESERVED         reserved
 *     CHAIN_ID         chain id
 *     L4_FRAMING       00: TCP01: UDP10: ICMP/IGMP11: L4_Others
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PBMP         Ingress port map
 *     VALID            Valid bits
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm 0x00000000

#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_MIN 0
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_MAX 1535
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CMAX(u) 1535
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SIZE 58

/*
 * This structure should be used to declare and program CFP_TCAM_CHAIN_MASK.
 *
 */
typedef union BCM53600_A0_CFP_TCAM_CHAIN_MASKm_s {
	uint32_t v[15];
	uint32_t cfp_tcam_chain_mask[15];
	uint32_t _cfp_tcam_chain_mask;
} BCM53600_A0_CFP_TCAM_CHAIN_MASKm_t;

#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_chain_mask), 0, sizeof(BCM53600_A0_CFP_TCAM_CHAIN_MASKm_t))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SET(r,i,d) (r).cfp_tcam_chain_mask[i] = d
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_GET(r,i) (r).cfp_tcam_chain_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SLICEIDf_GET(r) (((r).cfp_tcam_chain_mask[0]) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SLICEIDf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_LOf_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,2,33)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,2,33,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_HIf_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,34,65)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_HIf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,34,65,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_LOf_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,66,97)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,66,97,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_HIf_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,98,129)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_HIf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,98,129,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D2f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,130,161)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D2f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,130,161,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D3f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,162,193)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D3f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,162,193,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D4f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,194,225)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D4f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,194,225,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D5f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,226,257)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D5f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,226,257,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D6f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,258,289)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D6f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,258,289,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D7f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,290,321)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D7f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,290,321,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D8f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,322,353)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D8f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,322,353,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D9f_GET(r) ((((r).cfp_tcam_chain_mask[11]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D9f_SET(r,f) (r).cfp_tcam_chain_mask[11]=(((r).cfp_tcam_chain_mask[11] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D10f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,370,385)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D10f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,370,385,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D11f_GET(r) ((((r).cfp_tcam_chain_mask[12]) >> 2) & 0xff)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D11f_SET(r,f) (r).cfp_tcam_chain_mask[12]=(((r).cfp_tcam_chain_mask[12] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDFD_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[12]) >> 10) & 0xfff)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDFD_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[12]=(((r).cfp_tcam_chain_mask[12] & ~((uint32_t)0xfff << 10)) | ((((uint32_t)f) & 0xfff) << 10))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_RESERVEDf_GET(r) ((((r).cfp_tcam_chain_mask[12]) >> 22) & 0x7)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_RESERVEDf_SET(r,f) (r).cfp_tcam_chain_mask[12]=(((r).cfp_tcam_chain_mask[12] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,409,420)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,409,420,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L4_FRAMINGf_GET(r) ((((r).cfp_tcam_chain_mask[13]) >> 5) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L4_FRAMINGf_SET(r,f) (r).cfp_tcam_chain_mask[13]=(((r).cfp_tcam_chain_mask[13] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_chain_mask[13]) >> 7) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_chain_mask[13]=(((r).cfp_tcam_chain_mask[13] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_chain_mask[13]) >> 9) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_chain_mask[13]=(((r).cfp_tcam_chain_mask[13] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_chain_mask[13]) >> 11) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_chain_mask[13]=(((r).cfp_tcam_chain_mask[13] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_chain_mask[13]) >> 13) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_chain_mask[13]=(((r).cfp_tcam_chain_mask[13] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SRC_PBMPf_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,431,459)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SRC_PBMPf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,431,459,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_VALIDf_GET(r) ((((r).cfp_tcam_chain_mask[14]) >> 12) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_MASKm_VALIDf_SET(r,f) (r).cfp_tcam_chain_mask[14]=(((r).cfp_tcam_chain_mask[14] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))

/*
 * These macros can be used to access CFP_TCAM_CHAIN_MASK.
 *
 */
#define BCM53600_A0_READ_CFP_TCAM_CHAIN_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_TCAM_CHAIN_MASKm,i,(m),58)
#define BCM53600_A0_WRITE_CFP_TCAM_CHAIN_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_TCAM_CHAIN_MASKm,i,&(m),58)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_CHAIN_MASKm BCM53600_A0_CFP_TCAM_CHAIN_MASKm
#define CFP_TCAM_CHAIN_MASKm_MIN BCM53600_A0_CFP_TCAM_CHAIN_MASKm_MIN
#define CFP_TCAM_CHAIN_MASKm_MAX BCM53600_A0_CFP_TCAM_CHAIN_MASKm_MAX
#define CFP_TCAM_CHAIN_MASKm_CMAX(u) BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CMAX(u)
#define CFP_TCAM_CHAIN_MASKm_SIZE BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SIZE
typedef BCM53600_A0_CFP_TCAM_CHAIN_MASKm_t CFP_TCAM_CHAIN_MASKm_t;
#define CFP_TCAM_CHAIN_MASKm_CLR BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CLR
#define CFP_TCAM_CHAIN_MASKm_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SET
#define CFP_TCAM_CHAIN_MASKm_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_GET
#define CFP_TCAM_CHAIN_MASKm_SLICEIDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SLICEIDf_GET
#define CFP_TCAM_CHAIN_MASKm_SLICEIDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SLICEIDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D0_LOf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_LOf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D0_LOf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_LOf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D0_HIf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_HIf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D0_HIf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D0_HIf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D1_LOf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_LOf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D1_LOf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_LOf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D1_HIf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_HIf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D1_HIf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D1_HIf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D2f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D2f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D2f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D2f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D3f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D3f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D3f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D3f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D4f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D4f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D4f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D4f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D5f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D5f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D5f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D5f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D6f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D6f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D6f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D6f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D7f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D7f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D7f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D7f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D8f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D8f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D8f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D8f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D9f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D9f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D9f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D9f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D10f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D10f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D10f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D10f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_D11f_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D11f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_D11f_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDF_D11f_SET
#define CFP_TCAM_CHAIN_MASKm_UDFD_VLDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDFD_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDFD_VLDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_UDFD_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVEDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_RESERVEDf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVEDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_RESERVEDf_SET
#define CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET
#define CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET
#define CFP_TCAM_CHAIN_MASKm_L4_FRAMINGf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L4_FRAMINGf_GET
#define CFP_TCAM_CHAIN_MASKm_L4_FRAMINGf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L4_FRAMINGf_SET
#define CFP_TCAM_CHAIN_MASKm_L3_FRAMINGf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_CHAIN_MASKm_L3_FRAMINGf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_CHAIN_MASKm_L2_FRAMINGf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_CHAIN_MASKm_L2_FRAMINGf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_CHAIN_MASKm_C_TAGGEDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_CHAIN_MASKm_C_TAGGEDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_CHAIN_MASKm_S_TAGGEDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_CHAIN_MASKm_S_TAGGEDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_CHAIN_MASKm_SRC_PBMPf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SRC_PBMPf_GET
#define CFP_TCAM_CHAIN_MASKm_SRC_PBMPf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_SRC_PBMPf_SET
#define CFP_TCAM_CHAIN_MASKm_VALIDf_GET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_VALIDf_GET
#define CFP_TCAM_CHAIN_MASKm_VALIDf_SET BCM53600_A0_CFP_TCAM_CHAIN_MASKm_VALIDf_SET
#define READ_CFP_TCAM_CHAIN_MASKm BCM53600_A0_READ_CFP_TCAM_CHAIN_MASKm
#define WRITE_CFP_TCAM_CHAIN_MASKm BCM53600_A0_WRITE_CFP_TCAM_CHAIN_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_TCAM_CHAIN_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_TCAM_CHAIN_SC
 * BLOCKS:   SYS
 * DESC:     TCAM SW Table
 * SIZE:     462
 * FIELDS:
 *     SLICEID          slice id
 *     UDF_D0_LO        UDF_3_D0 lo 32-bits
 *     UDF_D0_HI        UDF_3_D0 hi 32-bits
 *     UDF_D1_LO        UDF_3_D1 lo 32-bits
 *     UDF_D1_HI        UDF_3_D1 hi 32-bits
 *     UDF_D2           UDF_3_D2 32-bits
 *     UDF_D3           UDF_3_D3 32-bits
 *     UDF_D4           UDF_3_D4 32-bits
 *     UDF_D5           UDF_3_D5 32-bits
 *     UDF_D6           UDF_3_D6 32-bits
 *     UDF_D7           UDF_3_D7 32-bits
 *     UDF_D8           UDF_3_D8 32-bits
 *     UDF_D9           UDF_3_D9 16-bits
 *     UDF_D10          UDF_3_D10 16-bits
 *     UDF_D11          UDF_3_D11 8-bits
 *     UDFD_VLD         udf valid bits
 *     RESERVED         reserved
 *     CHAIN_ID         chain id
 *     L4_FRAMING       00: TCP01: UDP10: ICMP/IGMP11: L4_Others
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PBMP         Ingress port map
 *     VALID            Valid bits
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm 0x00000000

#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_MIN 0
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_MAX 1535
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_CMAX(u) 1535
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_SIZE 58

/*
 * This structure should be used to declare and program CFP_TCAM_CHAIN_SC.
 *
 */
typedef union BCM53600_A0_CFP_TCAM_CHAIN_SCm_s {
	uint32_t v[15];
	uint32_t cfp_tcam_chain_sc[15];
	uint32_t _cfp_tcam_chain_sc;
} BCM53600_A0_CFP_TCAM_CHAIN_SCm_t;

#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_chain_sc), 0, sizeof(BCM53600_A0_CFP_TCAM_CHAIN_SCm_t))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_SET(r,i,d) (r).cfp_tcam_chain_sc[i] = d
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_GET(r,i) (r).cfp_tcam_chain_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_SLICEIDf_GET(r) (((r).cfp_tcam_chain_sc[0]) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_SLICEIDf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_LOf_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,2,33)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,2,33,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_HIf_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,34,65)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_HIf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,34,65,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_LOf_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,66,97)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,66,97,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_HIf_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,98,129)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_HIf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,98,129,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D2f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,130,161)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D2f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,130,161,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D3f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,162,193)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D3f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,162,193,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D4f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,194,225)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D4f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,194,225,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D5f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,226,257)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D5f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,226,257,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D6f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,258,289)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D6f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,258,289,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D7f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,290,321)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D7f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,290,321,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D8f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,322,353)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D8f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,322,353,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D9f_GET(r) ((((r).cfp_tcam_chain_sc[11]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D9f_SET(r,f) (r).cfp_tcam_chain_sc[11]=(((r).cfp_tcam_chain_sc[11] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D10f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,370,385)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D10f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,370,385,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D11f_GET(r) ((((r).cfp_tcam_chain_sc[12]) >> 2) & 0xff)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D11f_SET(r,f) (r).cfp_tcam_chain_sc[12]=(((r).cfp_tcam_chain_sc[12] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDFD_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[12]) >> 10) & 0xfff)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDFD_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[12]=(((r).cfp_tcam_chain_sc[12] & ~((uint32_t)0xfff << 10)) | ((((uint32_t)f) & 0xfff) << 10))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_RESERVEDf_GET(r) ((((r).cfp_tcam_chain_sc[12]) >> 22) & 0x7)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_RESERVEDf_SET(r,f) (r).cfp_tcam_chain_sc[12]=(((r).cfp_tcam_chain_sc[12] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,409,420)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,409,420,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_L4_FRAMINGf_GET(r) ((((r).cfp_tcam_chain_sc[13]) >> 5) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_L4_FRAMINGf_SET(r,f) (r).cfp_tcam_chain_sc[13]=(((r).cfp_tcam_chain_sc[13] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_chain_sc[13]) >> 7) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_chain_sc[13]=(((r).cfp_tcam_chain_sc[13] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_chain_sc[13]) >> 9) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_chain_sc[13]=(((r).cfp_tcam_chain_sc[13] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_chain_sc[13]) >> 11) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_chain_sc[13]=(((r).cfp_tcam_chain_sc[13] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_chain_sc[13]) >> 13) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_chain_sc[13]=(((r).cfp_tcam_chain_sc[13] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_SRC_PBMPf_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,431,459)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_SRC_PBMPf_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,431,459,f)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_VALIDf_GET(r) ((((r).cfp_tcam_chain_sc[14]) >> 12) & 0x3)
#define BCM53600_A0_CFP_TCAM_CHAIN_SCm_VALIDf_SET(r,f) (r).cfp_tcam_chain_sc[14]=(((r).cfp_tcam_chain_sc[14] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))

/*
 * These macros can be used to access CFP_TCAM_CHAIN_SC.
 *
 */
#define BCM53600_A0_READ_CFP_TCAM_CHAIN_SCm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_TCAM_CHAIN_SCm,i,(m),58)
#define BCM53600_A0_WRITE_CFP_TCAM_CHAIN_SCm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_TCAM_CHAIN_SCm,i,&(m),58)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_CHAIN_SCm BCM53600_A0_CFP_TCAM_CHAIN_SCm
#define CFP_TCAM_CHAIN_SCm_MIN BCM53600_A0_CFP_TCAM_CHAIN_SCm_MIN
#define CFP_TCAM_CHAIN_SCm_MAX BCM53600_A0_CFP_TCAM_CHAIN_SCm_MAX
#define CFP_TCAM_CHAIN_SCm_CMAX(u) BCM53600_A0_CFP_TCAM_CHAIN_SCm_CMAX(u)
#define CFP_TCAM_CHAIN_SCm_SIZE BCM53600_A0_CFP_TCAM_CHAIN_SCm_SIZE
typedef BCM53600_A0_CFP_TCAM_CHAIN_SCm_t CFP_TCAM_CHAIN_SCm_t;
#define CFP_TCAM_CHAIN_SCm_CLR BCM53600_A0_CFP_TCAM_CHAIN_SCm_CLR
#define CFP_TCAM_CHAIN_SCm_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_SET
#define CFP_TCAM_CHAIN_SCm_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_GET
#define CFP_TCAM_CHAIN_SCm_SLICEIDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_SLICEIDf_GET
#define CFP_TCAM_CHAIN_SCm_SLICEIDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_SLICEIDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D0_LOf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_LOf_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D0_LOf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_LOf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D0_HIf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_HIf_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D0_HIf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D0_HIf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D1_LOf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_LOf_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D1_LOf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_LOf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D1_HIf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_HIf_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D1_HIf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D1_HIf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D2f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D2f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D2f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D2f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D3f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D3f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D3f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D3f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D4f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D4f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D4f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D4f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D5f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D5f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D5f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D5f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D6f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D6f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D6f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D6f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D7f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D7f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D7f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D7f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D8f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D8f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D8f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D8f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D9f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D9f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D9f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D9f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D10f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D10f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D10f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D10f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_D11f_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D11f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_D11f_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDF_D11f_SET
#define CFP_TCAM_CHAIN_SCm_UDFD_VLDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDFD_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDFD_VLDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_UDFD_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVEDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_RESERVEDf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVEDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_RESERVEDf_SET
#define CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET
#define CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET
#define CFP_TCAM_CHAIN_SCm_L4_FRAMINGf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_L4_FRAMINGf_GET
#define CFP_TCAM_CHAIN_SCm_L4_FRAMINGf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_L4_FRAMINGf_SET
#define CFP_TCAM_CHAIN_SCm_L3_FRAMINGf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_CHAIN_SCm_L3_FRAMINGf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_CHAIN_SCm_L2_FRAMINGf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_CHAIN_SCm_L2_FRAMINGf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_CHAIN_SCm_C_TAGGEDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_C_TAGGEDf_GET
#define CFP_TCAM_CHAIN_SCm_C_TAGGEDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_C_TAGGEDf_SET
#define CFP_TCAM_CHAIN_SCm_S_TAGGEDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_S_TAGGEDf_GET
#define CFP_TCAM_CHAIN_SCm_S_TAGGEDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_S_TAGGEDf_SET
#define CFP_TCAM_CHAIN_SCm_SRC_PBMPf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_SRC_PBMPf_GET
#define CFP_TCAM_CHAIN_SCm_SRC_PBMPf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_SRC_PBMPf_SET
#define CFP_TCAM_CHAIN_SCm_VALIDf_GET BCM53600_A0_CFP_TCAM_CHAIN_SCm_VALIDf_GET
#define CFP_TCAM_CHAIN_SCm_VALIDf_SET BCM53600_A0_CFP_TCAM_CHAIN_SCm_VALIDf_SET
#define READ_CFP_TCAM_CHAIN_SCm BCM53600_A0_READ_CFP_TCAM_CHAIN_SCm
#define WRITE_CFP_TCAM_CHAIN_SCm BCM53600_A0_WRITE_CFP_TCAM_CHAIN_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_TCAM_CHAIN_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_TCAM_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM SW Table
 * SIZE:     462
 * FIELDS:
 *     SLICEID          slice id
 *     UDF_A0_LO        UDF_n_A0 lo 32-bits
 *     UDF_A0_HI        UDF_n_A0 hi 16-bits
 *     UDF_A1_LO        UDF_n_A1 lo 32-bits
 *     UDF_A1_HI        UDF_n_A1 hi 16-bits
 *     UDF_A2           UDF_n_A2 32-bits
 *     UDF_A3           UDF_n_A3 32-bits
 *     UDF_A4           UDF_n_A4 32-bits
 *     UDF_A5           UDF_n_A5 32-bits
 *     UDF_A6           UDF_n_A6 16-bits
 *     UDF_A7           UDF_n_A7 16-bits
 *     UDF_A8           UDF_n_A8 16-bits
 *     UDF_A9           UDF_n_A9 16-bits
 *     UDF_A10          UDF_n_A10 16-bits
 *     UDF_A11          UDF_n_A11 8-bits
 *     UDFA_VLD         udf valid bits
 *     L4_SECOND_TWO_BYTES first 2 bytes of l4
 *     L4_FIRST_TWO_BYTES first 2 bytes of l4
 *     TTL_RANGE        b00: TTL=0b01: TTL=1b10: TTL=Othersb11: TTL=255
 *     IP_AUTH          0: Not Authenticated1: Authenticated
 *     NON_FIRST_FRAG   0: Not Fragmented or First Fragment1: NonFirst Fragment
 *     IP_FRAG          0: Not Fragmented1: Fragmented
 *     IP_PROTO         The Protocol field of IPv4 header
 *     IP_TOS           Type Of Service field in IPv4 header
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     RANGE_CHECK      Results of range check
 *     L4_FRAMING       00: TCP01: UDP10: ICMP/IGMP11: L4_Others
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PBMP         Ingress port map
 *     VALID            Valid bits
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_TCAM_MASKm 0x00000000

#define BCM53600_A0_CFP_TCAM_MASKm_MIN 0
#define BCM53600_A0_CFP_TCAM_MASKm_MAX 1535
#define BCM53600_A0_CFP_TCAM_MASKm_CMAX(u) 1535
#define BCM53600_A0_CFP_TCAM_MASKm_SIZE 58

/*
 * This structure should be used to declare and program CFP_TCAM_MASK.
 *
 */
typedef union BCM53600_A0_CFP_TCAM_MASKm_s {
	uint32_t v[15];
	uint32_t cfp_tcam_mask[15];
	uint32_t _cfp_tcam_mask;
} BCM53600_A0_CFP_TCAM_MASKm_t;

#define BCM53600_A0_CFP_TCAM_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_mask), 0, sizeof(BCM53600_A0_CFP_TCAM_MASKm_t))
#define BCM53600_A0_CFP_TCAM_MASKm_SET(r,i,d) (r).cfp_tcam_mask[i] = d
#define BCM53600_A0_CFP_TCAM_MASKm_GET(r,i) (r).cfp_tcam_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_TCAM_MASKm_SLICEIDf_GET(r) (((r).cfp_tcam_mask[0]) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_SLICEIDf_SET(r,f) (r).cfp_tcam_mask[0]=(((r).cfp_tcam_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_LOf_GET(r) cdk_field32_get((r).cfp_tcam_mask,2,33)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,2,33,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_HIf_GET(r) ((((r).cfp_tcam_mask[1]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_HIf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_LOf_GET(r) cdk_field32_get((r).cfp_tcam_mask,50,81)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,50,81,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_HIf_GET(r) cdk_field32_get((r).cfp_tcam_mask,82,97)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_HIf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,82,97,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A2f_GET(r) cdk_field32_get((r).cfp_tcam_mask,98,129)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A2f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,98,129,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A3f_GET(r) cdk_field32_get((r).cfp_tcam_mask,130,161)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A3f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,130,161,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A4f_GET(r) cdk_field32_get((r).cfp_tcam_mask,162,193)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A4f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,162,193,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A5f_GET(r) cdk_field32_get((r).cfp_tcam_mask,194,225)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A5f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,194,225,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A6f_GET(r) ((((r).cfp_tcam_mask[7]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A6f_SET(r,f) (r).cfp_tcam_mask[7]=(((r).cfp_tcam_mask[7] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A7f_GET(r) cdk_field32_get((r).cfp_tcam_mask,242,257)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A7f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,242,257,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A8f_GET(r) ((((r).cfp_tcam_mask[8]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A8f_SET(r,f) (r).cfp_tcam_mask[8]=(((r).cfp_tcam_mask[8] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A9f_GET(r) cdk_field32_get((r).cfp_tcam_mask,274,289)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A9f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,274,289,f)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A10f_GET(r) ((((r).cfp_tcam_mask[9]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A10f_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A11f_GET(r) ((((r).cfp_tcam_mask[9]) >> 18) & 0xff)
#define BCM53600_A0_CFP_TCAM_MASKm_UDF_A11f_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0xff << 18)) | ((((uint32_t)f) & 0xff) << 18))
#define BCM53600_A0_CFP_TCAM_MASKm_UDFA_VLDf_GET(r) cdk_field32_get((r).cfp_tcam_mask,314,325)
#define BCM53600_A0_CFP_TCAM_MASKm_UDFA_VLDf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,314,325,f)
#define BCM53600_A0_CFP_TCAM_MASKm_L4_SECOND_TWO_BYTESf_GET(r) ((((r).cfp_tcam_mask[10]) >> 6) & 0xffff)
#define BCM53600_A0_CFP_TCAM_MASKm_L4_SECOND_TWO_BYTESf_SET(r,f) (r).cfp_tcam_mask[10]=(((r).cfp_tcam_mask[10] & ~((uint32_t)0xffff << 6)) | ((((uint32_t)f) & 0xffff) << 6))
#define BCM53600_A0_CFP_TCAM_MASKm_L4_FIRST_TWO_BYTESf_GET(r) cdk_field32_get((r).cfp_tcam_mask,342,357)
#define BCM53600_A0_CFP_TCAM_MASKm_L4_FIRST_TWO_BYTESf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,342,357,f)
#define BCM53600_A0_CFP_TCAM_MASKm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_mask[11]) >> 6) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_TCAM_MASKm_IP_AUTHf_GET(r) ((((r).cfp_tcam_mask[11]) >> 8) & 0x1)
#define BCM53600_A0_CFP_TCAM_MASKm_IP_AUTHf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_CFP_TCAM_MASKm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_mask[11]) >> 9) & 0x1)
#define BCM53600_A0_CFP_TCAM_MASKm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_CFP_TCAM_MASKm_IP_FRAGf_GET(r) ((((r).cfp_tcam_mask[11]) >> 10) & 0x1)
#define BCM53600_A0_CFP_TCAM_MASKm_IP_FRAGf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_CFP_TCAM_MASKm_IP_PROTOf_GET(r) ((((r).cfp_tcam_mask[11]) >> 11) & 0xff)
#define BCM53600_A0_CFP_TCAM_MASKm_IP_PROTOf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53600_A0_CFP_TCAM_MASKm_IP_TOSf_GET(r) ((((r).cfp_tcam_mask[11]) >> 19) & 0xff)
#define BCM53600_A0_CFP_TCAM_MASKm_IP_TOSf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0xff << 19)) | ((((uint32_t)f) & 0xff) << 19))
#define BCM53600_A0_CFP_TCAM_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_mask,379,390)
#define BCM53600_A0_CFP_TCAM_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,379,390,f)
#define BCM53600_A0_CFP_TCAM_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_mask[12]) >> 7) & 0x1)
#define BCM53600_A0_CFP_TCAM_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_mask[12]=(((r).cfp_tcam_mask[12] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_CFP_TCAM_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_mask[12]) >> 8) & 0x7)
#define BCM53600_A0_CFP_TCAM_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_mask[12]=(((r).cfp_tcam_mask[12] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53600_A0_CFP_TCAM_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_mask[12]) >> 11) & 0xfff)
#define BCM53600_A0_CFP_TCAM_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_mask[12]=(((r).cfp_tcam_mask[12] & ~((uint32_t)0xfff << 11)) | ((((uint32_t)f) & 0xfff) << 11))
#define BCM53600_A0_CFP_TCAM_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_mask[12]) >> 23) & 0x1)
#define BCM53600_A0_CFP_TCAM_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_mask[12]=(((r).cfp_tcam_mask[12] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53600_A0_CFP_TCAM_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_mask[12]) >> 24) & 0x7)
#define BCM53600_A0_CFP_TCAM_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_mask[12]=(((r).cfp_tcam_mask[12] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53600_A0_CFP_TCAM_MASKm_RANGE_CHECKf_GET(r) cdk_field32_get((r).cfp_tcam_mask,411,420)
#define BCM53600_A0_CFP_TCAM_MASKm_RANGE_CHECKf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,411,420,f)
#define BCM53600_A0_CFP_TCAM_MASKm_L4_FRAMINGf_GET(r) ((((r).cfp_tcam_mask[13]) >> 5) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_L4_FRAMINGf_SET(r,f) (r).cfp_tcam_mask[13]=(((r).cfp_tcam_mask[13] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53600_A0_CFP_TCAM_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_mask[13]) >> 7) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_mask[13]=(((r).cfp_tcam_mask[13] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_CFP_TCAM_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_mask[13]) >> 9) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_mask[13]=(((r).cfp_tcam_mask[13] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53600_A0_CFP_TCAM_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_mask[13]) >> 11) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_mask[13]=(((r).cfp_tcam_mask[13] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_CFP_TCAM_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_mask[13]) >> 13) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_mask[13]=(((r).cfp_tcam_mask[13] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53600_A0_CFP_TCAM_MASKm_SRC_PBMPf_GET(r) cdk_field32_get((r).cfp_tcam_mask,431,459)
#define BCM53600_A0_CFP_TCAM_MASKm_SRC_PBMPf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,431,459,f)
#define BCM53600_A0_CFP_TCAM_MASKm_VALIDf_GET(r) ((((r).cfp_tcam_mask[14]) >> 12) & 0x3)
#define BCM53600_A0_CFP_TCAM_MASKm_VALIDf_SET(r,f) (r).cfp_tcam_mask[14]=(((r).cfp_tcam_mask[14] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))

/*
 * These macros can be used to access CFP_TCAM_MASK.
 *
 */
#define BCM53600_A0_READ_CFP_TCAM_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_TCAM_MASKm,i,(m),58)
#define BCM53600_A0_WRITE_CFP_TCAM_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_TCAM_MASKm,i,&(m),58)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_MASKm BCM53600_A0_CFP_TCAM_MASKm
#define CFP_TCAM_MASKm_MIN BCM53600_A0_CFP_TCAM_MASKm_MIN
#define CFP_TCAM_MASKm_MAX BCM53600_A0_CFP_TCAM_MASKm_MAX
#define CFP_TCAM_MASKm_CMAX(u) BCM53600_A0_CFP_TCAM_MASKm_CMAX(u)
#define CFP_TCAM_MASKm_SIZE BCM53600_A0_CFP_TCAM_MASKm_SIZE
typedef BCM53600_A0_CFP_TCAM_MASKm_t CFP_TCAM_MASKm_t;
#define CFP_TCAM_MASKm_CLR BCM53600_A0_CFP_TCAM_MASKm_CLR
#define CFP_TCAM_MASKm_SET BCM53600_A0_CFP_TCAM_MASKm_SET
#define CFP_TCAM_MASKm_GET BCM53600_A0_CFP_TCAM_MASKm_GET
#define CFP_TCAM_MASKm_SLICEIDf_GET BCM53600_A0_CFP_TCAM_MASKm_SLICEIDf_GET
#define CFP_TCAM_MASKm_SLICEIDf_SET BCM53600_A0_CFP_TCAM_MASKm_SLICEIDf_SET
#define CFP_TCAM_MASKm_UDF_A0_LOf_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_LOf_GET
#define CFP_TCAM_MASKm_UDF_A0_LOf_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_LOf_SET
#define CFP_TCAM_MASKm_UDF_A0_HIf_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_HIf_GET
#define CFP_TCAM_MASKm_UDF_A0_HIf_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A0_HIf_SET
#define CFP_TCAM_MASKm_UDF_A1_LOf_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_LOf_GET
#define CFP_TCAM_MASKm_UDF_A1_LOf_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_LOf_SET
#define CFP_TCAM_MASKm_UDF_A1_HIf_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_HIf_GET
#define CFP_TCAM_MASKm_UDF_A1_HIf_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A1_HIf_SET
#define CFP_TCAM_MASKm_UDF_A2f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A2f_GET
#define CFP_TCAM_MASKm_UDF_A2f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A2f_SET
#define CFP_TCAM_MASKm_UDF_A3f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A3f_GET
#define CFP_TCAM_MASKm_UDF_A3f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A3f_SET
#define CFP_TCAM_MASKm_UDF_A4f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A4f_GET
#define CFP_TCAM_MASKm_UDF_A4f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A4f_SET
#define CFP_TCAM_MASKm_UDF_A5f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A5f_GET
#define CFP_TCAM_MASKm_UDF_A5f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A5f_SET
#define CFP_TCAM_MASKm_UDF_A6f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A6f_GET
#define CFP_TCAM_MASKm_UDF_A6f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A6f_SET
#define CFP_TCAM_MASKm_UDF_A7f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A7f_GET
#define CFP_TCAM_MASKm_UDF_A7f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A7f_SET
#define CFP_TCAM_MASKm_UDF_A8f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A8f_GET
#define CFP_TCAM_MASKm_UDF_A8f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A8f_SET
#define CFP_TCAM_MASKm_UDF_A9f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A9f_GET
#define CFP_TCAM_MASKm_UDF_A9f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A9f_SET
#define CFP_TCAM_MASKm_UDF_A10f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A10f_GET
#define CFP_TCAM_MASKm_UDF_A10f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A10f_SET
#define CFP_TCAM_MASKm_UDF_A11f_GET BCM53600_A0_CFP_TCAM_MASKm_UDF_A11f_GET
#define CFP_TCAM_MASKm_UDF_A11f_SET BCM53600_A0_CFP_TCAM_MASKm_UDF_A11f_SET
#define CFP_TCAM_MASKm_UDFA_VLDf_GET BCM53600_A0_CFP_TCAM_MASKm_UDFA_VLDf_GET
#define CFP_TCAM_MASKm_UDFA_VLDf_SET BCM53600_A0_CFP_TCAM_MASKm_UDFA_VLDf_SET
#define CFP_TCAM_MASKm_L4_SECOND_TWO_BYTESf_GET BCM53600_A0_CFP_TCAM_MASKm_L4_SECOND_TWO_BYTESf_GET
#define CFP_TCAM_MASKm_L4_SECOND_TWO_BYTESf_SET BCM53600_A0_CFP_TCAM_MASKm_L4_SECOND_TWO_BYTESf_SET
#define CFP_TCAM_MASKm_L4_FIRST_TWO_BYTESf_GET BCM53600_A0_CFP_TCAM_MASKm_L4_FIRST_TWO_BYTESf_GET
#define CFP_TCAM_MASKm_L4_FIRST_TWO_BYTESf_SET BCM53600_A0_CFP_TCAM_MASKm_L4_FIRST_TWO_BYTESf_SET
#define CFP_TCAM_MASKm_TTL_RANGEf_GET BCM53600_A0_CFP_TCAM_MASKm_TTL_RANGEf_GET
#define CFP_TCAM_MASKm_TTL_RANGEf_SET BCM53600_A0_CFP_TCAM_MASKm_TTL_RANGEf_SET
#define CFP_TCAM_MASKm_IP_AUTHf_GET BCM53600_A0_CFP_TCAM_MASKm_IP_AUTHf_GET
#define CFP_TCAM_MASKm_IP_AUTHf_SET BCM53600_A0_CFP_TCAM_MASKm_IP_AUTHf_SET
#define CFP_TCAM_MASKm_NON_FIRST_FRAGf_GET BCM53600_A0_CFP_TCAM_MASKm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_MASKm_NON_FIRST_FRAGf_SET BCM53600_A0_CFP_TCAM_MASKm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_MASKm_IP_FRAGf_GET BCM53600_A0_CFP_TCAM_MASKm_IP_FRAGf_GET
#define CFP_TCAM_MASKm_IP_FRAGf_SET BCM53600_A0_CFP_TCAM_MASKm_IP_FRAGf_SET
#define CFP_TCAM_MASKm_IP_PROTOf_GET BCM53600_A0_CFP_TCAM_MASKm_IP_PROTOf_GET
#define CFP_TCAM_MASKm_IP_PROTOf_SET BCM53600_A0_CFP_TCAM_MASKm_IP_PROTOf_SET
#define CFP_TCAM_MASKm_IP_TOSf_GET BCM53600_A0_CFP_TCAM_MASKm_IP_TOSf_GET
#define CFP_TCAM_MASKm_IP_TOSf_SET BCM53600_A0_CFP_TCAM_MASKm_IP_TOSf_SET
#define CFP_TCAM_MASKm_USR_VIDf_GET BCM53600_A0_CFP_TCAM_MASKm_USR_VIDf_GET
#define CFP_TCAM_MASKm_USR_VIDf_SET BCM53600_A0_CFP_TCAM_MASKm_USR_VIDf_SET
#define CFP_TCAM_MASKm_USR_CFIf_GET BCM53600_A0_CFP_TCAM_MASKm_USR_CFIf_GET
#define CFP_TCAM_MASKm_USR_CFIf_SET BCM53600_A0_CFP_TCAM_MASKm_USR_CFIf_SET
#define CFP_TCAM_MASKm_USR_PRIf_GET BCM53600_A0_CFP_TCAM_MASKm_USR_PRIf_GET
#define CFP_TCAM_MASKm_USR_PRIf_SET BCM53600_A0_CFP_TCAM_MASKm_USR_PRIf_SET
#define CFP_TCAM_MASKm_SP_VIDf_GET BCM53600_A0_CFP_TCAM_MASKm_SP_VIDf_GET
#define CFP_TCAM_MASKm_SP_VIDf_SET BCM53600_A0_CFP_TCAM_MASKm_SP_VIDf_SET
#define CFP_TCAM_MASKm_SP_CFIf_GET BCM53600_A0_CFP_TCAM_MASKm_SP_CFIf_GET
#define CFP_TCAM_MASKm_SP_CFIf_SET BCM53600_A0_CFP_TCAM_MASKm_SP_CFIf_SET
#define CFP_TCAM_MASKm_SP_PRIf_GET BCM53600_A0_CFP_TCAM_MASKm_SP_PRIf_GET
#define CFP_TCAM_MASKm_SP_PRIf_SET BCM53600_A0_CFP_TCAM_MASKm_SP_PRIf_SET
#define CFP_TCAM_MASKm_RANGE_CHECKf_GET BCM53600_A0_CFP_TCAM_MASKm_RANGE_CHECKf_GET
#define CFP_TCAM_MASKm_RANGE_CHECKf_SET BCM53600_A0_CFP_TCAM_MASKm_RANGE_CHECKf_SET
#define CFP_TCAM_MASKm_L4_FRAMINGf_GET BCM53600_A0_CFP_TCAM_MASKm_L4_FRAMINGf_GET
#define CFP_TCAM_MASKm_L4_FRAMINGf_SET BCM53600_A0_CFP_TCAM_MASKm_L4_FRAMINGf_SET
#define CFP_TCAM_MASKm_L3_FRAMINGf_GET BCM53600_A0_CFP_TCAM_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_MASKm_L3_FRAMINGf_SET BCM53600_A0_CFP_TCAM_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_MASKm_L2_FRAMINGf_GET BCM53600_A0_CFP_TCAM_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_MASKm_L2_FRAMINGf_SET BCM53600_A0_CFP_TCAM_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_MASKm_C_TAGGEDf_GET BCM53600_A0_CFP_TCAM_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_MASKm_C_TAGGEDf_SET BCM53600_A0_CFP_TCAM_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_MASKm_S_TAGGEDf_GET BCM53600_A0_CFP_TCAM_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_MASKm_S_TAGGEDf_SET BCM53600_A0_CFP_TCAM_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_MASKm_SRC_PBMPf_GET BCM53600_A0_CFP_TCAM_MASKm_SRC_PBMPf_GET
#define CFP_TCAM_MASKm_SRC_PBMPf_SET BCM53600_A0_CFP_TCAM_MASKm_SRC_PBMPf_SET
#define CFP_TCAM_MASKm_VALIDf_GET BCM53600_A0_CFP_TCAM_MASKm_VALIDf_GET
#define CFP_TCAM_MASKm_VALIDf_SET BCM53600_A0_CFP_TCAM_MASKm_VALIDf_SET
#define READ_CFP_TCAM_MASKm BCM53600_A0_READ_CFP_TCAM_MASKm
#define WRITE_CFP_TCAM_MASKm BCM53600_A0_WRITE_CFP_TCAM_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_TCAM_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  CFP_TCAM_SC
 * BLOCKS:   SYS
 * DESC:     TCAM SW Table
 * SIZE:     462
 * FIELDS:
 *     SLICEID          slice id
 *     UDF_A0_LO        UDF_n_A0 lo 32-bits
 *     UDF_A0_HI        UDF_n_A0 hi 16-bits
 *     UDF_A1_LO        UDF_n_A1 lo 32-bits
 *     UDF_A1_HI        UDF_n_A1 hi 16-bits
 *     UDF_A2           UDF_n_A2 32-bits
 *     UDF_A3           UDF_n_A3 32-bits
 *     UDF_A4           UDF_n_A4 32-bits
 *     UDF_A5           UDF_n_A5 32-bits
 *     UDF_A6           UDF_n_A6 16-bits
 *     UDF_A7           UDF_n_A7 16-bits
 *     UDF_A8           UDF_n_A8 16-bits
 *     UDF_A9           UDF_n_A9 16-bits
 *     UDF_A10          UDF_n_A10 16-bits
 *     UDF_A11          UDF_n_A11 8-bits
 *     UDFA_VLD         udf valid bits
 *     L4_SECOND_TWO_BYTES first 2 bytes of l4
 *     L4_FIRST_TWO_BYTES first 2 bytes of l4
 *     TTL_RANGE        b00: TTL=0b01: TTL=1b10: TTL=Othersb11: TTL=255
 *     IP_AUTH          0: Not Authenticated1: Authenticated
 *     NON_FIRST_FRAG   0: Not Fragmented or First Fragment1: NonFirst Fragment
 *     IP_FRAG          0: Not Fragmented1: Fragmented
 *     IP_PROTO         The Protocol field of IPv4 header
 *     IP_TOS           Type Of Service field in IPv4 header
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     RANGE_CHECK      Results of range check
 *     L4_FRAMING       00: TCP01: UDP10: ICMP/IGMP11: L4_Others
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PBMP         Ingress port map
 *     VALID            Valid bits
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_TCAM_SCm 0x00000000

#define BCM53600_A0_CFP_TCAM_SCm_MIN 0
#define BCM53600_A0_CFP_TCAM_SCm_MAX 1535
#define BCM53600_A0_CFP_TCAM_SCm_CMAX(u) 1535
#define BCM53600_A0_CFP_TCAM_SCm_SIZE 58

/*
 * This structure should be used to declare and program CFP_TCAM_SC.
 *
 */
typedef union BCM53600_A0_CFP_TCAM_SCm_s {
	uint32_t v[15];
	uint32_t cfp_tcam_sc[15];
	uint32_t _cfp_tcam_sc;
} BCM53600_A0_CFP_TCAM_SCm_t;

#define BCM53600_A0_CFP_TCAM_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_sc), 0, sizeof(BCM53600_A0_CFP_TCAM_SCm_t))
#define BCM53600_A0_CFP_TCAM_SCm_SET(r,i,d) (r).cfp_tcam_sc[i] = d
#define BCM53600_A0_CFP_TCAM_SCm_GET(r,i) (r).cfp_tcam_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_TCAM_SCm_SLICEIDf_GET(r) (((r).cfp_tcam_sc[0]) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_SLICEIDf_SET(r,f) (r).cfp_tcam_sc[0]=(((r).cfp_tcam_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A0_LOf_GET(r) cdk_field32_get((r).cfp_tcam_sc,2,33)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A0_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,2,33,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A0_HIf_GET(r) ((((r).cfp_tcam_sc[1]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A0_HIf_SET(r,f) (r).cfp_tcam_sc[1]=(((r).cfp_tcam_sc[1] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A1_LOf_GET(r) cdk_field32_get((r).cfp_tcam_sc,50,81)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A1_LOf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,50,81,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A1_HIf_GET(r) cdk_field32_get((r).cfp_tcam_sc,82,97)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A1_HIf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,82,97,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A2f_GET(r) cdk_field32_get((r).cfp_tcam_sc,98,129)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A2f_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,98,129,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A3f_GET(r) cdk_field32_get((r).cfp_tcam_sc,130,161)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A3f_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,130,161,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A4f_GET(r) cdk_field32_get((r).cfp_tcam_sc,162,193)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A4f_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,162,193,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A5f_GET(r) cdk_field32_get((r).cfp_tcam_sc,194,225)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A5f_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,194,225,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A6f_GET(r) ((((r).cfp_tcam_sc[7]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A6f_SET(r,f) (r).cfp_tcam_sc[7]=(((r).cfp_tcam_sc[7] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A7f_GET(r) cdk_field32_get((r).cfp_tcam_sc,242,257)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A7f_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,242,257,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A8f_GET(r) ((((r).cfp_tcam_sc[8]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A8f_SET(r,f) (r).cfp_tcam_sc[8]=(((r).cfp_tcam_sc[8] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A9f_GET(r) cdk_field32_get((r).cfp_tcam_sc,274,289)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A9f_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,274,289,f)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A10f_GET(r) ((((r).cfp_tcam_sc[9]) >> 2) & 0xffff)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A10f_SET(r,f) (r).cfp_tcam_sc[9]=(((r).cfp_tcam_sc[9] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A11f_GET(r) ((((r).cfp_tcam_sc[9]) >> 18) & 0xff)
#define BCM53600_A0_CFP_TCAM_SCm_UDF_A11f_SET(r,f) (r).cfp_tcam_sc[9]=(((r).cfp_tcam_sc[9] & ~((uint32_t)0xff << 18)) | ((((uint32_t)f) & 0xff) << 18))
#define BCM53600_A0_CFP_TCAM_SCm_UDFA_VLDf_GET(r) cdk_field32_get((r).cfp_tcam_sc,314,325)
#define BCM53600_A0_CFP_TCAM_SCm_UDFA_VLDf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,314,325,f)
#define BCM53600_A0_CFP_TCAM_SCm_L4_SECOND_TWO_BYTESf_GET(r) ((((r).cfp_tcam_sc[10]) >> 6) & 0xffff)
#define BCM53600_A0_CFP_TCAM_SCm_L4_SECOND_TWO_BYTESf_SET(r,f) (r).cfp_tcam_sc[10]=(((r).cfp_tcam_sc[10] & ~((uint32_t)0xffff << 6)) | ((((uint32_t)f) & 0xffff) << 6))
#define BCM53600_A0_CFP_TCAM_SCm_L4_FIRST_TWO_BYTESf_GET(r) cdk_field32_get((r).cfp_tcam_sc,342,357)
#define BCM53600_A0_CFP_TCAM_SCm_L4_FIRST_TWO_BYTESf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,342,357,f)
#define BCM53600_A0_CFP_TCAM_SCm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_sc[11]) >> 6) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_sc[11]=(((r).cfp_tcam_sc[11] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_CFP_TCAM_SCm_IP_AUTHf_GET(r) ((((r).cfp_tcam_sc[11]) >> 8) & 0x1)
#define BCM53600_A0_CFP_TCAM_SCm_IP_AUTHf_SET(r,f) (r).cfp_tcam_sc[11]=(((r).cfp_tcam_sc[11] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_CFP_TCAM_SCm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_sc[11]) >> 9) & 0x1)
#define BCM53600_A0_CFP_TCAM_SCm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_sc[11]=(((r).cfp_tcam_sc[11] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_CFP_TCAM_SCm_IP_FRAGf_GET(r) ((((r).cfp_tcam_sc[11]) >> 10) & 0x1)
#define BCM53600_A0_CFP_TCAM_SCm_IP_FRAGf_SET(r,f) (r).cfp_tcam_sc[11]=(((r).cfp_tcam_sc[11] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_CFP_TCAM_SCm_IP_PROTOf_GET(r) ((((r).cfp_tcam_sc[11]) >> 11) & 0xff)
#define BCM53600_A0_CFP_TCAM_SCm_IP_PROTOf_SET(r,f) (r).cfp_tcam_sc[11]=(((r).cfp_tcam_sc[11] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53600_A0_CFP_TCAM_SCm_IP_TOSf_GET(r) ((((r).cfp_tcam_sc[11]) >> 19) & 0xff)
#define BCM53600_A0_CFP_TCAM_SCm_IP_TOSf_SET(r,f) (r).cfp_tcam_sc[11]=(((r).cfp_tcam_sc[11] & ~((uint32_t)0xff << 19)) | ((((uint32_t)f) & 0xff) << 19))
#define BCM53600_A0_CFP_TCAM_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_sc,379,390)
#define BCM53600_A0_CFP_TCAM_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,379,390,f)
#define BCM53600_A0_CFP_TCAM_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_sc[12]) >> 7) & 0x1)
#define BCM53600_A0_CFP_TCAM_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_sc[12]=(((r).cfp_tcam_sc[12] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_CFP_TCAM_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_sc[12]) >> 8) & 0x7)
#define BCM53600_A0_CFP_TCAM_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_sc[12]=(((r).cfp_tcam_sc[12] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53600_A0_CFP_TCAM_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_sc[12]) >> 11) & 0xfff)
#define BCM53600_A0_CFP_TCAM_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_sc[12]=(((r).cfp_tcam_sc[12] & ~((uint32_t)0xfff << 11)) | ((((uint32_t)f) & 0xfff) << 11))
#define BCM53600_A0_CFP_TCAM_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_sc[12]) >> 23) & 0x1)
#define BCM53600_A0_CFP_TCAM_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_sc[12]=(((r).cfp_tcam_sc[12] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53600_A0_CFP_TCAM_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_sc[12]) >> 24) & 0x7)
#define BCM53600_A0_CFP_TCAM_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_sc[12]=(((r).cfp_tcam_sc[12] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53600_A0_CFP_TCAM_SCm_RANGE_CHECKf_GET(r) cdk_field32_get((r).cfp_tcam_sc,411,420)
#define BCM53600_A0_CFP_TCAM_SCm_RANGE_CHECKf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,411,420,f)
#define BCM53600_A0_CFP_TCAM_SCm_L4_FRAMINGf_GET(r) ((((r).cfp_tcam_sc[13]) >> 5) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_L4_FRAMINGf_SET(r,f) (r).cfp_tcam_sc[13]=(((r).cfp_tcam_sc[13] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53600_A0_CFP_TCAM_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_sc[13]) >> 7) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_sc[13]=(((r).cfp_tcam_sc[13] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_CFP_TCAM_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_sc[13]) >> 9) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_sc[13]=(((r).cfp_tcam_sc[13] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53600_A0_CFP_TCAM_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_sc[13]) >> 11) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_sc[13]=(((r).cfp_tcam_sc[13] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_CFP_TCAM_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_sc[13]) >> 13) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_sc[13]=(((r).cfp_tcam_sc[13] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53600_A0_CFP_TCAM_SCm_SRC_PBMPf_GET(r) cdk_field32_get((r).cfp_tcam_sc,431,459)
#define BCM53600_A0_CFP_TCAM_SCm_SRC_PBMPf_SET(r,f) cdk_field32_set((r).cfp_tcam_sc,431,459,f)
#define BCM53600_A0_CFP_TCAM_SCm_VALIDf_GET(r) ((((r).cfp_tcam_sc[14]) >> 12) & 0x3)
#define BCM53600_A0_CFP_TCAM_SCm_VALIDf_SET(r,f) (r).cfp_tcam_sc[14]=(((r).cfp_tcam_sc[14] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))

/*
 * These macros can be used to access CFP_TCAM_SC.
 *
 */
#define BCM53600_A0_READ_CFP_TCAM_SCm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_CFP_TCAM_SCm,i,(m),58)
#define BCM53600_A0_WRITE_CFP_TCAM_SCm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_CFP_TCAM_SCm,i,&(m),58)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_SCm BCM53600_A0_CFP_TCAM_SCm
#define CFP_TCAM_SCm_MIN BCM53600_A0_CFP_TCAM_SCm_MIN
#define CFP_TCAM_SCm_MAX BCM53600_A0_CFP_TCAM_SCm_MAX
#define CFP_TCAM_SCm_CMAX(u) BCM53600_A0_CFP_TCAM_SCm_CMAX(u)
#define CFP_TCAM_SCm_SIZE BCM53600_A0_CFP_TCAM_SCm_SIZE
typedef BCM53600_A0_CFP_TCAM_SCm_t CFP_TCAM_SCm_t;
#define CFP_TCAM_SCm_CLR BCM53600_A0_CFP_TCAM_SCm_CLR
#define CFP_TCAM_SCm_SET BCM53600_A0_CFP_TCAM_SCm_SET
#define CFP_TCAM_SCm_GET BCM53600_A0_CFP_TCAM_SCm_GET
#define CFP_TCAM_SCm_SLICEIDf_GET BCM53600_A0_CFP_TCAM_SCm_SLICEIDf_GET
#define CFP_TCAM_SCm_SLICEIDf_SET BCM53600_A0_CFP_TCAM_SCm_SLICEIDf_SET
#define CFP_TCAM_SCm_UDF_A0_LOf_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A0_LOf_GET
#define CFP_TCAM_SCm_UDF_A0_LOf_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A0_LOf_SET
#define CFP_TCAM_SCm_UDF_A0_HIf_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A0_HIf_GET
#define CFP_TCAM_SCm_UDF_A0_HIf_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A0_HIf_SET
#define CFP_TCAM_SCm_UDF_A1_LOf_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A1_LOf_GET
#define CFP_TCAM_SCm_UDF_A1_LOf_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A1_LOf_SET
#define CFP_TCAM_SCm_UDF_A1_HIf_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A1_HIf_GET
#define CFP_TCAM_SCm_UDF_A1_HIf_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A1_HIf_SET
#define CFP_TCAM_SCm_UDF_A2f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A2f_GET
#define CFP_TCAM_SCm_UDF_A2f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A2f_SET
#define CFP_TCAM_SCm_UDF_A3f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A3f_GET
#define CFP_TCAM_SCm_UDF_A3f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A3f_SET
#define CFP_TCAM_SCm_UDF_A4f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A4f_GET
#define CFP_TCAM_SCm_UDF_A4f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A4f_SET
#define CFP_TCAM_SCm_UDF_A5f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A5f_GET
#define CFP_TCAM_SCm_UDF_A5f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A5f_SET
#define CFP_TCAM_SCm_UDF_A6f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A6f_GET
#define CFP_TCAM_SCm_UDF_A6f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A6f_SET
#define CFP_TCAM_SCm_UDF_A7f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A7f_GET
#define CFP_TCAM_SCm_UDF_A7f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A7f_SET
#define CFP_TCAM_SCm_UDF_A8f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A8f_GET
#define CFP_TCAM_SCm_UDF_A8f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A8f_SET
#define CFP_TCAM_SCm_UDF_A9f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A9f_GET
#define CFP_TCAM_SCm_UDF_A9f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A9f_SET
#define CFP_TCAM_SCm_UDF_A10f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A10f_GET
#define CFP_TCAM_SCm_UDF_A10f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A10f_SET
#define CFP_TCAM_SCm_UDF_A11f_GET BCM53600_A0_CFP_TCAM_SCm_UDF_A11f_GET
#define CFP_TCAM_SCm_UDF_A11f_SET BCM53600_A0_CFP_TCAM_SCm_UDF_A11f_SET
#define CFP_TCAM_SCm_UDFA_VLDf_GET BCM53600_A0_CFP_TCAM_SCm_UDFA_VLDf_GET
#define CFP_TCAM_SCm_UDFA_VLDf_SET BCM53600_A0_CFP_TCAM_SCm_UDFA_VLDf_SET
#define CFP_TCAM_SCm_L4_SECOND_TWO_BYTESf_GET BCM53600_A0_CFP_TCAM_SCm_L4_SECOND_TWO_BYTESf_GET
#define CFP_TCAM_SCm_L4_SECOND_TWO_BYTESf_SET BCM53600_A0_CFP_TCAM_SCm_L4_SECOND_TWO_BYTESf_SET
#define CFP_TCAM_SCm_L4_FIRST_TWO_BYTESf_GET BCM53600_A0_CFP_TCAM_SCm_L4_FIRST_TWO_BYTESf_GET
#define CFP_TCAM_SCm_L4_FIRST_TWO_BYTESf_SET BCM53600_A0_CFP_TCAM_SCm_L4_FIRST_TWO_BYTESf_SET
#define CFP_TCAM_SCm_TTL_RANGEf_GET BCM53600_A0_CFP_TCAM_SCm_TTL_RANGEf_GET
#define CFP_TCAM_SCm_TTL_RANGEf_SET BCM53600_A0_CFP_TCAM_SCm_TTL_RANGEf_SET
#define CFP_TCAM_SCm_IP_AUTHf_GET BCM53600_A0_CFP_TCAM_SCm_IP_AUTHf_GET
#define CFP_TCAM_SCm_IP_AUTHf_SET BCM53600_A0_CFP_TCAM_SCm_IP_AUTHf_SET
#define CFP_TCAM_SCm_NON_FIRST_FRAGf_GET BCM53600_A0_CFP_TCAM_SCm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_SCm_NON_FIRST_FRAGf_SET BCM53600_A0_CFP_TCAM_SCm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_SCm_IP_FRAGf_GET BCM53600_A0_CFP_TCAM_SCm_IP_FRAGf_GET
#define CFP_TCAM_SCm_IP_FRAGf_SET BCM53600_A0_CFP_TCAM_SCm_IP_FRAGf_SET
#define CFP_TCAM_SCm_IP_PROTOf_GET BCM53600_A0_CFP_TCAM_SCm_IP_PROTOf_GET
#define CFP_TCAM_SCm_IP_PROTOf_SET BCM53600_A0_CFP_TCAM_SCm_IP_PROTOf_SET
#define CFP_TCAM_SCm_IP_TOSf_GET BCM53600_A0_CFP_TCAM_SCm_IP_TOSf_GET
#define CFP_TCAM_SCm_IP_TOSf_SET BCM53600_A0_CFP_TCAM_SCm_IP_TOSf_SET
#define CFP_TCAM_SCm_USR_VIDf_GET BCM53600_A0_CFP_TCAM_SCm_USR_VIDf_GET
#define CFP_TCAM_SCm_USR_VIDf_SET BCM53600_A0_CFP_TCAM_SCm_USR_VIDf_SET
#define CFP_TCAM_SCm_USR_CFIf_GET BCM53600_A0_CFP_TCAM_SCm_USR_CFIf_GET
#define CFP_TCAM_SCm_USR_CFIf_SET BCM53600_A0_CFP_TCAM_SCm_USR_CFIf_SET
#define CFP_TCAM_SCm_USR_PRIf_GET BCM53600_A0_CFP_TCAM_SCm_USR_PRIf_GET
#define CFP_TCAM_SCm_USR_PRIf_SET BCM53600_A0_CFP_TCAM_SCm_USR_PRIf_SET
#define CFP_TCAM_SCm_SP_VIDf_GET BCM53600_A0_CFP_TCAM_SCm_SP_VIDf_GET
#define CFP_TCAM_SCm_SP_VIDf_SET BCM53600_A0_CFP_TCAM_SCm_SP_VIDf_SET
#define CFP_TCAM_SCm_SP_CFIf_GET BCM53600_A0_CFP_TCAM_SCm_SP_CFIf_GET
#define CFP_TCAM_SCm_SP_CFIf_SET BCM53600_A0_CFP_TCAM_SCm_SP_CFIf_SET
#define CFP_TCAM_SCm_SP_PRIf_GET BCM53600_A0_CFP_TCAM_SCm_SP_PRIf_GET
#define CFP_TCAM_SCm_SP_PRIf_SET BCM53600_A0_CFP_TCAM_SCm_SP_PRIf_SET
#define CFP_TCAM_SCm_RANGE_CHECKf_GET BCM53600_A0_CFP_TCAM_SCm_RANGE_CHECKf_GET
#define CFP_TCAM_SCm_RANGE_CHECKf_SET BCM53600_A0_CFP_TCAM_SCm_RANGE_CHECKf_SET
#define CFP_TCAM_SCm_L4_FRAMINGf_GET BCM53600_A0_CFP_TCAM_SCm_L4_FRAMINGf_GET
#define CFP_TCAM_SCm_L4_FRAMINGf_SET BCM53600_A0_CFP_TCAM_SCm_L4_FRAMINGf_SET
#define CFP_TCAM_SCm_L3_FRAMINGf_GET BCM53600_A0_CFP_TCAM_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_SCm_L3_FRAMINGf_SET BCM53600_A0_CFP_TCAM_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_SCm_L2_FRAMINGf_GET BCM53600_A0_CFP_TCAM_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_SCm_L2_FRAMINGf_SET BCM53600_A0_CFP_TCAM_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_SCm_C_TAGGEDf_GET BCM53600_A0_CFP_TCAM_SCm_C_TAGGEDf_GET
#define CFP_TCAM_SCm_C_TAGGEDf_SET BCM53600_A0_CFP_TCAM_SCm_C_TAGGEDf_SET
#define CFP_TCAM_SCm_S_TAGGEDf_GET BCM53600_A0_CFP_TCAM_SCm_S_TAGGEDf_GET
#define CFP_TCAM_SCm_S_TAGGEDf_SET BCM53600_A0_CFP_TCAM_SCm_S_TAGGEDf_SET
#define CFP_TCAM_SCm_SRC_PBMPf_GET BCM53600_A0_CFP_TCAM_SCm_SRC_PBMPf_GET
#define CFP_TCAM_SCm_SRC_PBMPf_SET BCM53600_A0_CFP_TCAM_SCm_SRC_PBMPf_SET
#define CFP_TCAM_SCm_VALIDf_GET BCM53600_A0_CFP_TCAM_SCm_VALIDf_GET
#define CFP_TCAM_SCm_VALIDf_SET BCM53600_A0_CFP_TCAM_SCm_VALIDf_SET
#define READ_CFP_TCAM_SCm BCM53600_A0_READ_CFP_TCAM_SCm
#define WRITE_CFP_TCAM_SCm BCM53600_A0_WRITE_CFP_TCAM_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_TCAM_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CFP_UDF_0_A
 * BLOCKS:   SYS
 * DESC:     CFP User define A control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_N_X_OFFSET   The offset used for UDF_n_X. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_N_X_REF      UDF ConfigurationThis field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,D and [N] = 0-11...UDF_n_A0,UDF_n_A1,.......,UDF_n_A8: These UDFs are used for Slice n.(n = 0,1 or 2)..UDF_3_D0,UDF_3_D1,.......,UDF_3_D11: These UDFs are used by the Slice 3.----------------------------------------------------------------------------Based flag to select the base address is starting from :000: Start of frame,001: End of VLAN Tag,010: End of L2,011: End of L3.Others: Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_UDF_0_Ar 0x00002200

#define BCM53600_A0_CFP_UDF_0_Ar_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_0_A.
 *
 */
typedef union BCM53600_A0_CFP_UDF_0_Ar_s {
	uint32_t v[1];
	uint32_t cfp_udf_0_a[1];
	uint32_t _cfp_udf_0_a;
} BCM53600_A0_CFP_UDF_0_Ar_t;

#define BCM53600_A0_CFP_UDF_0_Ar_CLR(r) (r).cfp_udf_0_a[0] = 0
#define BCM53600_A0_CFP_UDF_0_Ar_SET(r,d) (r).cfp_udf_0_a[0] = d
#define BCM53600_A0_CFP_UDF_0_Ar_GET(r) (r).cfp_udf_0_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_OFFSETf_GET(r) (((r).cfp_udf_0_a[0]) & 0x1f)
#define BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_OFFSETf_SET(r,f) (r).cfp_udf_0_a[0]=(((r).cfp_udf_0_a[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_REFf_GET(r) ((((r).cfp_udf_0_a[0]) >> 5) & 0x7)
#define BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_REFf_SET(r,f) (r).cfp_udf_0_a[0]=(((r).cfp_udf_0_a[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access CFP_UDF_0_A.
 *
 */
#define BCM53600_A0_READ_CFP_UDF_0_Ar(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_CFP_UDF_0_Ar+(1*(i)),(r._cfp_udf_0_a),1)
#define BCM53600_A0_WRITE_CFP_UDF_0_Ar(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_CFP_UDF_0_Ar+(1*(i)),&(r._cfp_udf_0_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_0_Ar BCM53600_A0_CFP_UDF_0_Ar
#define CFP_UDF_0_Ar_SIZE BCM53600_A0_CFP_UDF_0_Ar_SIZE
typedef BCM53600_A0_CFP_UDF_0_Ar_t CFP_UDF_0_Ar_t;
#define CFP_UDF_0_Ar_CLR BCM53600_A0_CFP_UDF_0_Ar_CLR
#define CFP_UDF_0_Ar_SET BCM53600_A0_CFP_UDF_0_Ar_SET
#define CFP_UDF_0_Ar_GET BCM53600_A0_CFP_UDF_0_Ar_GET
#define CFP_UDF_0_Ar_UDF_N_X_OFFSETf_GET BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_OFFSETf_GET
#define CFP_UDF_0_Ar_UDF_N_X_OFFSETf_SET BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_OFFSETf_SET
#define CFP_UDF_0_Ar_UDF_N_X_REFf_GET BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_REFf_GET
#define CFP_UDF_0_Ar_UDF_N_X_REFf_SET BCM53600_A0_CFP_UDF_0_Ar_UDF_N_X_REFf_SET
#define READ_CFP_UDF_0_Ar BCM53600_A0_READ_CFP_UDF_0_Ar
#define WRITE_CFP_UDF_0_Ar BCM53600_A0_WRITE_CFP_UDF_0_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_UDF_0_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CFP_UDF_1_A
 * BLOCKS:   SYS
 * DESC:     CFP User define A control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_N_X_OFFSET   The offset used for UDF_n_X. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_N_X_REF      UDF ConfigurationThis field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,D and [N] = 0-11...UDF_n_A0,UDF_n_A1,.......,UDF_n_A8: These UDFs are used for Slice n.(n = 0,1 or 2)..UDF_3_D0,UDF_3_D1,.......,UDF_3_D11: These UDFs are used by the Slice 3.----------------------------------------------------------------------------Based flag to select the base address is starting from :000: Start of frame,001: End of VLAN Tag,010: End of L2,011: End of L3.Others: Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_UDF_1_Ar 0x00002210

#define BCM53600_A0_CFP_UDF_1_Ar_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_1_A.
 *
 */
typedef union BCM53600_A0_CFP_UDF_1_Ar_s {
	uint32_t v[1];
	uint32_t cfp_udf_1_a[1];
	uint32_t _cfp_udf_1_a;
} BCM53600_A0_CFP_UDF_1_Ar_t;

#define BCM53600_A0_CFP_UDF_1_Ar_CLR(r) (r).cfp_udf_1_a[0] = 0
#define BCM53600_A0_CFP_UDF_1_Ar_SET(r,d) (r).cfp_udf_1_a[0] = d
#define BCM53600_A0_CFP_UDF_1_Ar_GET(r) (r).cfp_udf_1_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_OFFSETf_GET(r) (((r).cfp_udf_1_a[0]) & 0x1f)
#define BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_OFFSETf_SET(r,f) (r).cfp_udf_1_a[0]=(((r).cfp_udf_1_a[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_REFf_GET(r) ((((r).cfp_udf_1_a[0]) >> 5) & 0x7)
#define BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_REFf_SET(r,f) (r).cfp_udf_1_a[0]=(((r).cfp_udf_1_a[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access CFP_UDF_1_A.
 *
 */
#define BCM53600_A0_READ_CFP_UDF_1_Ar(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_CFP_UDF_1_Ar+(1*(i)),(r._cfp_udf_1_a),1)
#define BCM53600_A0_WRITE_CFP_UDF_1_Ar(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_CFP_UDF_1_Ar+(1*(i)),&(r._cfp_udf_1_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_1_Ar BCM53600_A0_CFP_UDF_1_Ar
#define CFP_UDF_1_Ar_SIZE BCM53600_A0_CFP_UDF_1_Ar_SIZE
typedef BCM53600_A0_CFP_UDF_1_Ar_t CFP_UDF_1_Ar_t;
#define CFP_UDF_1_Ar_CLR BCM53600_A0_CFP_UDF_1_Ar_CLR
#define CFP_UDF_1_Ar_SET BCM53600_A0_CFP_UDF_1_Ar_SET
#define CFP_UDF_1_Ar_GET BCM53600_A0_CFP_UDF_1_Ar_GET
#define CFP_UDF_1_Ar_UDF_N_X_OFFSETf_GET BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_OFFSETf_GET
#define CFP_UDF_1_Ar_UDF_N_X_OFFSETf_SET BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_OFFSETf_SET
#define CFP_UDF_1_Ar_UDF_N_X_REFf_GET BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_REFf_GET
#define CFP_UDF_1_Ar_UDF_N_X_REFf_SET BCM53600_A0_CFP_UDF_1_Ar_UDF_N_X_REFf_SET
#define READ_CFP_UDF_1_Ar BCM53600_A0_READ_CFP_UDF_1_Ar
#define WRITE_CFP_UDF_1_Ar BCM53600_A0_WRITE_CFP_UDF_1_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_UDF_1_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CFP_UDF_2_A
 * BLOCKS:   SYS
 * DESC:     CFP User define A control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_N_X_OFFSET   The offset used for UDF_n_X. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_N_X_REF      UDF ConfigurationThis field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,D and [N] = 0-11...UDF_n_A0,UDF_n_A1,.......,UDF_n_A8: These UDFs are used for Slice n.(n = 0,1 or 2)..UDF_3_D0,UDF_3_D1,.......,UDF_3_D11: These UDFs are used by the Slice 3.----------------------------------------------------------------------------Based flag to select the base address is starting from :000: Start of frame,001: End of VLAN Tag,010: End of L2,011: End of L3.Others: Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_UDF_2_Ar 0x00002220

#define BCM53600_A0_CFP_UDF_2_Ar_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_2_A.
 *
 */
typedef union BCM53600_A0_CFP_UDF_2_Ar_s {
	uint32_t v[1];
	uint32_t cfp_udf_2_a[1];
	uint32_t _cfp_udf_2_a;
} BCM53600_A0_CFP_UDF_2_Ar_t;

#define BCM53600_A0_CFP_UDF_2_Ar_CLR(r) (r).cfp_udf_2_a[0] = 0
#define BCM53600_A0_CFP_UDF_2_Ar_SET(r,d) (r).cfp_udf_2_a[0] = d
#define BCM53600_A0_CFP_UDF_2_Ar_GET(r) (r).cfp_udf_2_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_OFFSETf_GET(r) (((r).cfp_udf_2_a[0]) & 0x1f)
#define BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_OFFSETf_SET(r,f) (r).cfp_udf_2_a[0]=(((r).cfp_udf_2_a[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_REFf_GET(r) ((((r).cfp_udf_2_a[0]) >> 5) & 0x7)
#define BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_REFf_SET(r,f) (r).cfp_udf_2_a[0]=(((r).cfp_udf_2_a[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access CFP_UDF_2_A.
 *
 */
#define BCM53600_A0_READ_CFP_UDF_2_Ar(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_CFP_UDF_2_Ar+(1*(i)),(r._cfp_udf_2_a),1)
#define BCM53600_A0_WRITE_CFP_UDF_2_Ar(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_CFP_UDF_2_Ar+(1*(i)),&(r._cfp_udf_2_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_2_Ar BCM53600_A0_CFP_UDF_2_Ar
#define CFP_UDF_2_Ar_SIZE BCM53600_A0_CFP_UDF_2_Ar_SIZE
typedef BCM53600_A0_CFP_UDF_2_Ar_t CFP_UDF_2_Ar_t;
#define CFP_UDF_2_Ar_CLR BCM53600_A0_CFP_UDF_2_Ar_CLR
#define CFP_UDF_2_Ar_SET BCM53600_A0_CFP_UDF_2_Ar_SET
#define CFP_UDF_2_Ar_GET BCM53600_A0_CFP_UDF_2_Ar_GET
#define CFP_UDF_2_Ar_UDF_N_X_OFFSETf_GET BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_OFFSETf_GET
#define CFP_UDF_2_Ar_UDF_N_X_OFFSETf_SET BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_OFFSETf_SET
#define CFP_UDF_2_Ar_UDF_N_X_REFf_GET BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_REFf_GET
#define CFP_UDF_2_Ar_UDF_N_X_REFf_SET BCM53600_A0_CFP_UDF_2_Ar_UDF_N_X_REFf_SET
#define READ_CFP_UDF_2_Ar BCM53600_A0_READ_CFP_UDF_2_Ar
#define WRITE_CFP_UDF_2_Ar BCM53600_A0_WRITE_CFP_UDF_2_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_UDF_2_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CFP_UDF_3_D
 * BLOCKS:   SYS
 * DESC:     CFP User define D control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_N_X_OFFSET   The offset used for UDF_n_X. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_N_X_REF      UDF ConfigurationThis field represents the configuration of each UDF_n_X[N], where n = 0,1,2;X = A,D and [N] = 0-11...UDF_n_A0,UDF_n_A1,.......,UDF_n_A8: These UDFs are used for Slice n.(n = 0,1 or 2)..UDF_3_D0,UDF_3_D1,.......,UDF_3_D11: These UDFs are used by the Slice 3.----------------------------------------------------------------------------Based flag to select the base address is starting from :000: Start of frame,001: End of VLAN Tag,010: End of L2,011: End of L3.Others: Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CFP_UDF_3_Dr 0x00002290

#define BCM53600_A0_CFP_UDF_3_Dr_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_3_D.
 *
 */
typedef union BCM53600_A0_CFP_UDF_3_Dr_s {
	uint32_t v[1];
	uint32_t cfp_udf_3_d[1];
	uint32_t _cfp_udf_3_d;
} BCM53600_A0_CFP_UDF_3_Dr_t;

#define BCM53600_A0_CFP_UDF_3_Dr_CLR(r) (r).cfp_udf_3_d[0] = 0
#define BCM53600_A0_CFP_UDF_3_Dr_SET(r,d) (r).cfp_udf_3_d[0] = d
#define BCM53600_A0_CFP_UDF_3_Dr_GET(r) (r).cfp_udf_3_d[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_OFFSETf_GET(r) (((r).cfp_udf_3_d[0]) & 0x1f)
#define BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_OFFSETf_SET(r,f) (r).cfp_udf_3_d[0]=(((r).cfp_udf_3_d[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_REFf_GET(r) ((((r).cfp_udf_3_d[0]) >> 5) & 0x7)
#define BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_REFf_SET(r,f) (r).cfp_udf_3_d[0]=(((r).cfp_udf_3_d[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access CFP_UDF_3_D.
 *
 */
#define BCM53600_A0_READ_CFP_UDF_3_Dr(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_CFP_UDF_3_Dr+(1*(i)),(r._cfp_udf_3_d),1)
#define BCM53600_A0_WRITE_CFP_UDF_3_Dr(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_CFP_UDF_3_Dr+(1*(i)),&(r._cfp_udf_3_d),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_3_Dr BCM53600_A0_CFP_UDF_3_Dr
#define CFP_UDF_3_Dr_SIZE BCM53600_A0_CFP_UDF_3_Dr_SIZE
typedef BCM53600_A0_CFP_UDF_3_Dr_t CFP_UDF_3_Dr_t;
#define CFP_UDF_3_Dr_CLR BCM53600_A0_CFP_UDF_3_Dr_CLR
#define CFP_UDF_3_Dr_SET BCM53600_A0_CFP_UDF_3_Dr_SET
#define CFP_UDF_3_Dr_GET BCM53600_A0_CFP_UDF_3_Dr_GET
#define CFP_UDF_3_Dr_UDF_N_X_OFFSETf_GET BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_OFFSETf_GET
#define CFP_UDF_3_Dr_UDF_N_X_OFFSETf_SET BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_OFFSETf_SET
#define CFP_UDF_3_Dr_UDF_N_X_REFf_GET BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_REFf_GET
#define CFP_UDF_3_Dr_UDF_N_X_REFf_SET BCM53600_A0_CFP_UDF_3_Dr_UDF_N_X_REFf_SET
#define READ_CFP_UDF_3_Dr BCM53600_A0_READ_CFP_UDF_3_Dr
#define WRITE_CFP_UDF_3_Dr BCM53600_A0_WRITE_CFP_UDF_3_Dr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CFP_UDF_3_Dr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CHIP_RST_CTL
 * BLOCKS:   SYS
 * DESC:     FULL Chip Reset Control Register
 * SIZE:     8
 * FIELDS:
 *     SWITCH_RST_CTL   Reset Switch modules, included switch logics, memory/table, and registers.Write "1" to activate a RESET, "0" to clear the reset state.1 = Activate reset.0 = Clear reset.
 *     RESERVED_0       Reserved.
 *     INTERNAL_RST_CTL Reset switch logics.Write "1" to activate a RESET, "0" to clear the reset state.1 = Activate reset.0 = Clear reset.(Not2Release)
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_CHIP_RST_CTLr 0x0000037c

#define BCM53600_A0_CHIP_RST_CTLr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_RST_CTL.
 *
 */
typedef union BCM53600_A0_CHIP_RST_CTLr_s {
	uint32_t v[1];
	uint32_t chip_rst_ctl[1];
	uint32_t _chip_rst_ctl;
} BCM53600_A0_CHIP_RST_CTLr_t;

#define BCM53600_A0_CHIP_RST_CTLr_CLR(r) (r).chip_rst_ctl[0] = 0
#define BCM53600_A0_CHIP_RST_CTLr_SET(r,d) (r).chip_rst_ctl[0] = d
#define BCM53600_A0_CHIP_RST_CTLr_GET(r) (r).chip_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CHIP_RST_CTLr_SWITCH_RST_CTLf_GET(r) (((r).chip_rst_ctl[0]) & 0x1)
#define BCM53600_A0_CHIP_RST_CTLr_SWITCH_RST_CTLf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_CHIP_RST_CTLr_RESERVED_0f_GET(r) ((((r).chip_rst_ctl[0]) >> 1) & 0xf)
#define BCM53600_A0_CHIP_RST_CTLr_RESERVED_0f_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM53600_A0_CHIP_RST_CTLr_INTERNAL_RST_CTLf_GET(r) ((((r).chip_rst_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_CHIP_RST_CTLr_INTERNAL_RST_CTLf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_CHIP_RST_CTLr_RESERVED_1f_GET(r) ((((r).chip_rst_ctl[0]) >> 6) & 0x3)
#define BCM53600_A0_CHIP_RST_CTLr_RESERVED_1f_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CHIP_RST_CTL.
 *
 */
#define BCM53600_A0_READ_CHIP_RST_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CHIP_RST_CTLr,(r._chip_rst_ctl),1)
#define BCM53600_A0_WRITE_CHIP_RST_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CHIP_RST_CTLr,&(r._chip_rst_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_RST_CTLr BCM53600_A0_CHIP_RST_CTLr
#define CHIP_RST_CTLr_SIZE BCM53600_A0_CHIP_RST_CTLr_SIZE
typedef BCM53600_A0_CHIP_RST_CTLr_t CHIP_RST_CTLr_t;
#define CHIP_RST_CTLr_CLR BCM53600_A0_CHIP_RST_CTLr_CLR
#define CHIP_RST_CTLr_SET BCM53600_A0_CHIP_RST_CTLr_SET
#define CHIP_RST_CTLr_GET BCM53600_A0_CHIP_RST_CTLr_GET
#define CHIP_RST_CTLr_SWITCH_RST_CTLf_GET BCM53600_A0_CHIP_RST_CTLr_SWITCH_RST_CTLf_GET
#define CHIP_RST_CTLr_SWITCH_RST_CTLf_SET BCM53600_A0_CHIP_RST_CTLr_SWITCH_RST_CTLf_SET
#define CHIP_RST_CTLr_RESERVED_0f_GET BCM53600_A0_CHIP_RST_CTLr_RESERVED_0f_GET
#define CHIP_RST_CTLr_RESERVED_0f_SET BCM53600_A0_CHIP_RST_CTLr_RESERVED_0f_SET
#define CHIP_RST_CTLr_INTERNAL_RST_CTLf_GET BCM53600_A0_CHIP_RST_CTLr_INTERNAL_RST_CTLf_GET
#define CHIP_RST_CTLr_INTERNAL_RST_CTLf_SET BCM53600_A0_CHIP_RST_CTLr_INTERNAL_RST_CTLf_SET
#define CHIP_RST_CTLr_RESERVED_1f_GET BCM53600_A0_CHIP_RST_CTLr_RESERVED_1f_GET
#define CHIP_RST_CTLr_RESERVED_1f_SET BCM53600_A0_CHIP_RST_CTLr_RESERVED_1f_SET
#define READ_CHIP_RST_CTLr BCM53600_A0_READ_CHIP_RST_CTLr
#define WRITE_CHIP_RST_CTLr BCM53600_A0_WRITE_CHIP_RST_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CHIP_RST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CLKSET
 * BLOCKS:   SPI
 * DESC:     Clock Period Setting Registers
 * SIZE:     32
 * FIELDS:
 *     RESERVED         CLKSET[31:28]: Reserved.CLKSET[27:24]: Initialize clock phase.CLKSET[23:20]: High clock period time for switch core.CLKSET[19:16]: Low clock period time for switch core. Clock period = (high_period + low_period) * 0.5ns,CLKSET[15:8] : CLKSET Key2 (xEA)CLKSET[7:0]  : CLKSET Key1 (x68)
 *
 ******************************************************************************/
#define BCM53600_A0_CLKSETr 0x0000fffa

#define BCM53600_A0_CLKSETr_SIZE 4

/*
 * This structure should be used to declare and program CLKSET.
 *
 */
typedef union BCM53600_A0_CLKSETr_s {
	uint32_t v[1];
	uint32_t clkset[1];
	uint32_t _clkset;
} BCM53600_A0_CLKSETr_t;

#define BCM53600_A0_CLKSETr_CLR(r) (r).clkset[0] = 0
#define BCM53600_A0_CLKSETr_SET(r,d) (r).clkset[0] = d
#define BCM53600_A0_CLKSETr_GET(r) (r).clkset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CLKSETr_RESERVEDf_GET(r) ((r).clkset[0])
#define BCM53600_A0_CLKSETr_RESERVEDf_SET(r,f) (r).clkset[0]=((uint32_t)f)

/*
 * These macros can be used to access CLKSET.
 *
 */
#define BCM53600_A0_READ_CLKSETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CLKSETr,(r._clkset),4)
#define BCM53600_A0_WRITE_CLKSETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CLKSETr,&(r._clkset),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CLKSETr BCM53600_A0_CLKSETr
#define CLKSETr_SIZE BCM53600_A0_CLKSETr_SIZE
typedef BCM53600_A0_CLKSETr_t CLKSETr_t;
#define CLKSETr_CLR BCM53600_A0_CLKSETr_CLR
#define CLKSETr_SET BCM53600_A0_CLKSETr_SET
#define CLKSETr_GET BCM53600_A0_CLKSETr_GET
#define CLKSETr_RESERVEDf_GET BCM53600_A0_CLKSETr_RESERVEDf_GET
#define CLKSETr_RESERVEDf_SET BCM53600_A0_CLKSETr_RESERVEDf_SET
#define READ_CLKSETr BCM53600_A0_READ_CLKSETr
#define WRITE_CLKSETr BCM53600_A0_WRITE_CLKSETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CLKSETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  COS_VALUE_CTRL
 * BLOCKS:   SYS
 * DESC:     AVB COS Value Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     CLASS_A_COS      AVB Class A COS valueThis field is used to set the COS value of AVB Class A packet. This AVB Class A packet will be sent to this queue.
 *     RESERVED_0       Reserved
 *     CLASS_B_COS      AVB Class B COS valueThis field is used to set the COS value of AVB Class B packet. This AVB Class B packet will be sent to this queue.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_COS_VALUE_CTRLr 0x00004606

#define BCM53600_A0_COS_VALUE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program COS_VALUE_CTRL.
 *
 */
typedef union BCM53600_A0_COS_VALUE_CTRLr_s {
	uint32_t v[1];
	uint32_t cos_value_ctrl[1];
	uint32_t _cos_value_ctrl;
} BCM53600_A0_COS_VALUE_CTRLr_t;

#define BCM53600_A0_COS_VALUE_CTRLr_CLR(r) (r).cos_value_ctrl[0] = 0
#define BCM53600_A0_COS_VALUE_CTRLr_SET(r,d) (r).cos_value_ctrl[0] = d
#define BCM53600_A0_COS_VALUE_CTRLr_GET(r) (r).cos_value_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_COS_VALUE_CTRLr_CLASS_A_COSf_GET(r) (((r).cos_value_ctrl[0]) & 0x7)
#define BCM53600_A0_COS_VALUE_CTRLr_CLASS_A_COSf_SET(r,f) (r).cos_value_ctrl[0]=(((r).cos_value_ctrl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_COS_VALUE_CTRLr_RESERVED_0f_GET(r) ((((r).cos_value_ctrl[0]) >> 3) & 0x1)
#define BCM53600_A0_COS_VALUE_CTRLr_RESERVED_0f_SET(r,f) (r).cos_value_ctrl[0]=(((r).cos_value_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_COS_VALUE_CTRLr_CLASS_B_COSf_GET(r) ((((r).cos_value_ctrl[0]) >> 4) & 0x7)
#define BCM53600_A0_COS_VALUE_CTRLr_CLASS_B_COSf_SET(r,f) (r).cos_value_ctrl[0]=(((r).cos_value_ctrl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53600_A0_COS_VALUE_CTRLr_RESERVED_1f_GET(r) ((((r).cos_value_ctrl[0]) >> 7) & 0x1)
#define BCM53600_A0_COS_VALUE_CTRLr_RESERVED_1f_SET(r,f) (r).cos_value_ctrl[0]=(((r).cos_value_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access COS_VALUE_CTRL.
 *
 */
#define BCM53600_A0_READ_COS_VALUE_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_COS_VALUE_CTRLr,(r._cos_value_ctrl),1)
#define BCM53600_A0_WRITE_COS_VALUE_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_COS_VALUE_CTRLr,&(r._cos_value_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_VALUE_CTRLr BCM53600_A0_COS_VALUE_CTRLr
#define COS_VALUE_CTRLr_SIZE BCM53600_A0_COS_VALUE_CTRLr_SIZE
typedef BCM53600_A0_COS_VALUE_CTRLr_t COS_VALUE_CTRLr_t;
#define COS_VALUE_CTRLr_CLR BCM53600_A0_COS_VALUE_CTRLr_CLR
#define COS_VALUE_CTRLr_SET BCM53600_A0_COS_VALUE_CTRLr_SET
#define COS_VALUE_CTRLr_GET BCM53600_A0_COS_VALUE_CTRLr_GET
#define COS_VALUE_CTRLr_CLASS_A_COSf_GET BCM53600_A0_COS_VALUE_CTRLr_CLASS_A_COSf_GET
#define COS_VALUE_CTRLr_CLASS_A_COSf_SET BCM53600_A0_COS_VALUE_CTRLr_CLASS_A_COSf_SET
#define COS_VALUE_CTRLr_RESERVED_0f_GET BCM53600_A0_COS_VALUE_CTRLr_RESERVED_0f_GET
#define COS_VALUE_CTRLr_RESERVED_0f_SET BCM53600_A0_COS_VALUE_CTRLr_RESERVED_0f_SET
#define COS_VALUE_CTRLr_CLASS_B_COSf_GET BCM53600_A0_COS_VALUE_CTRLr_CLASS_B_COSf_GET
#define COS_VALUE_CTRLr_CLASS_B_COSf_SET BCM53600_A0_COS_VALUE_CTRLr_CLASS_B_COSf_SET
#define COS_VALUE_CTRLr_RESERVED_1f_GET BCM53600_A0_COS_VALUE_CTRLr_RESERVED_1f_GET
#define COS_VALUE_CTRLr_RESERVED_1f_SET BCM53600_A0_COS_VALUE_CTRLr_RESERVED_1f_SET
#define READ_COS_VALUE_CTRLr BCM53600_A0_READ_COS_VALUE_CTRLr
#define WRITE_COS_VALUE_CTRLr BCM53600_A0_WRITE_COS_VALUE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_COS_VALUE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CPU_OTP_ADDR
 * BLOCKS:   SYS
 * DESC:     CPU OTP Address Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     CPU_ADDR         The 16 bits CPU OTP address register provides up to 64k bits address spacefor OTP program, read access from CPU interface. In prog_word command, itdetermines the address of the entire memory row to be programmed or thedata to be read.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_CPU_OTP_ADDRr 0x0000e004

#define BCM53600_A0_CPU_OTP_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program CPU_OTP_ADDR.
 *
 */
typedef union BCM53600_A0_CPU_OTP_ADDRr_s {
	uint32_t v[1];
	uint32_t cpu_otp_addr[1];
	uint32_t _cpu_otp_addr;
} BCM53600_A0_CPU_OTP_ADDRr_t;

#define BCM53600_A0_CPU_OTP_ADDRr_CLR(r) (r).cpu_otp_addr[0] = 0
#define BCM53600_A0_CPU_OTP_ADDRr_SET(r,d) (r).cpu_otp_addr[0] = d
#define BCM53600_A0_CPU_OTP_ADDRr_GET(r) (r).cpu_otp_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CPU_OTP_ADDRr_CPU_ADDRf_GET(r) (((r).cpu_otp_addr[0]) & 0xffff)
#define BCM53600_A0_CPU_OTP_ADDRr_CPU_ADDRf_SET(r,f) (r).cpu_otp_addr[0]=(((r).cpu_otp_addr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CPU_OTP_ADDR.
 *
 */
#define BCM53600_A0_READ_CPU_OTP_ADDRr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CPU_OTP_ADDRr,(r._cpu_otp_addr),2)
#define BCM53600_A0_WRITE_CPU_OTP_ADDRr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CPU_OTP_ADDRr,&(r._cpu_otp_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_OTP_ADDRr BCM53600_A0_CPU_OTP_ADDRr
#define CPU_OTP_ADDRr_SIZE BCM53600_A0_CPU_OTP_ADDRr_SIZE
typedef BCM53600_A0_CPU_OTP_ADDRr_t CPU_OTP_ADDRr_t;
#define CPU_OTP_ADDRr_CLR BCM53600_A0_CPU_OTP_ADDRr_CLR
#define CPU_OTP_ADDRr_SET BCM53600_A0_CPU_OTP_ADDRr_SET
#define CPU_OTP_ADDRr_GET BCM53600_A0_CPU_OTP_ADDRr_GET
#define CPU_OTP_ADDRr_CPU_ADDRf_GET BCM53600_A0_CPU_OTP_ADDRr_CPU_ADDRf_GET
#define CPU_OTP_ADDRr_CPU_ADDRf_SET BCM53600_A0_CPU_OTP_ADDRr_CPU_ADDRf_SET
#define READ_CPU_OTP_ADDRr BCM53600_A0_READ_CPU_OTP_ADDRr
#define WRITE_CPU_OTP_ADDRr BCM53600_A0_WRITE_CPU_OTP_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CPU_OTP_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CPU_OTP_CTL
 * BLOCKS:   SYS
 * DESC:     CPU OTP Control Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     START            Rising edge of the signal will execute OTP command.(Not2Release)
 *     COMMAND          0 : Read.1 : Program Bit internal clk.2 : Program Word.3 : Verify.4 : Init.5 : Set.6 : Reset.7 : OCST.8 : Lock.9 : Prescreen test.10 : Program bit External clock mode - field programming mode.11 : Program Word external clock.(Not2Release)
 *     WRP_PROG_SEL     Program select - debug only (bit[20] of this register must be set in order tosee the affect of this bits).(Not2Release)
 *     WRP_VSEL         verify level select - debug only (bit[20] of this register must be set in orderto see the affect of this bits).(Not2Release)
 *     WRP_PCOUNT       A FAIL was returned from the wrapper logic. The part is bad.(Not2Release)
 *     WRP_PBYP         OTP cell clock control - debug only (bit[20] of this register must be set inorder to see the affect of this bits).(Not2Release)
 *     RESERVED_0       Reserved for future expansion(Not2Release)
 *     WRP_SADBYP       sadbyp : senseAmp delay bypass - debug only (bit[20] of this register must beset in order to see the affect of this bits).(Not2Release)
 *     WRP_TIME_MARGIN  timing margin - debug only(bit[20] of this register must be set in order tosee the affect of this bits).(Not2Release)
 *     WRP_CONTINUE_ON_FAIL 0 = OTP will hang jtag_wrapper module on fail - stay in PROG_FAIL stateforever OR until reset is applied (or this bit is made 1).1 = OTP will set the FAIL status and continue to accept command. Please notethat even if this bit is 0, the jtag_otp module as such will not hang and thestatus indicates that there was programming failure. It is only the wrappermodule that hangs. Command_done signal will be asserted even in this condition.(Not2Release)
 *     OTP_DEBUG_MODE   Causes bits[18:5] to be used for direct OTP control - used by the librarygroup for debugging. The bits[18:5] are control bits of the OTP memory thatcan be programmed using software(CPU interface).(Not2Release)
 *     OTP_PROG_EN      Only when otp_prog_en is 1, otp programming from cpu is enable. Set thispin to 0 will disable otp programming from cpu side. This bit is usuallydriven by chip pin to prevent otp programming from cpu side when chipship to customer.(Not2Release)
 *     ACCESS_MODE      00 = Raw. This mode is used for all commmands except for prog_bit andprog_word command.01 = Manufacturing area.10 = configuration bits area.11 = ram repair bits area.The mode 01, 10 and 11 are used during prog_bit and prog_word command.(Not2Release)
 *     BURST_STATE_SEL  Used during word program command. 0=data from the OTP memory is send out,1=FAIL returned for programmed bits is sent out(used to debug the failedbits during burst program)(Not2Release)
 *     CPU_DEBUG_SEL    Select signal used to define if data or debug signals are sent to theo_otp_cpu_data output.(Not2Release)
 *     RESERVED_1       Reserved for future expansion(Not2Release)
 *     BYPASS_OTP_CLK   This bit, if set, replaces i_jtag_otp_clk by i_jtag_ser_clk throughout theJTAG_OTP IP. This control bit affects only CPU transtions.USE_TCK_IN_CPU_MODE define should be used for this bit to be effective.(This bit is not effective in Thunderbolt)(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_CPU_OTP_CTLr 0x0000e000

#define BCM53600_A0_CPU_OTP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CPU_OTP_CTL.
 *
 */
typedef union BCM53600_A0_CPU_OTP_CTLr_s {
	uint32_t v[1];
	uint32_t cpu_otp_ctl[1];
	uint32_t _cpu_otp_ctl;
} BCM53600_A0_CPU_OTP_CTLr_t;

#define BCM53600_A0_CPU_OTP_CTLr_CLR(r) (r).cpu_otp_ctl[0] = 0
#define BCM53600_A0_CPU_OTP_CTLr_SET(r,d) (r).cpu_otp_ctl[0] = d
#define BCM53600_A0_CPU_OTP_CTLr_GET(r) (r).cpu_otp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CPU_OTP_CTLr_STARTf_GET(r) (((r).cpu_otp_ctl[0]) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_STARTf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_CPU_OTP_CTLr_COMMANDf_GET(r) ((((r).cpu_otp_ctl[0]) >> 1) & 0xf)
#define BCM53600_A0_CPU_OTP_CTLr_COMMANDf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_PROG_SELf_GET(r) ((((r).cpu_otp_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_PROG_SELf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_VSELf_GET(r) ((((r).cpu_otp_ctl[0]) >> 6) & 0xf)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_VSELf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_PCOUNTf_GET(r) ((((r).cpu_otp_ctl[0]) >> 10) & 0x7)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_PCOUNTf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_PBYPf_GET(r) ((((r).cpu_otp_ctl[0]) >> 13) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_PBYPf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_CPU_OTP_CTLr_RESERVED_0f_GET(r) ((((r).cpu_otp_ctl[0]) >> 14) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_RESERVED_0f_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_SADBYPf_GET(r) ((((r).cpu_otp_ctl[0]) >> 15) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_SADBYPf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_TIME_MARGINf_GET(r) ((((r).cpu_otp_ctl[0]) >> 16) & 0x7)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_TIME_MARGINf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53600_A0_CPU_OTP_CTLr_WRP_CONTINUE_ON_FAILf_GET(r) ((((r).cpu_otp_ctl[0]) >> 19) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_WRP_CONTINUE_ON_FAILf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53600_A0_CPU_OTP_CTLr_OTP_DEBUG_MODEf_GET(r) ((((r).cpu_otp_ctl[0]) >> 20) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_OTP_DEBUG_MODEf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53600_A0_CPU_OTP_CTLr_OTP_PROG_ENf_GET(r) ((((r).cpu_otp_ctl[0]) >> 21) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_OTP_PROG_ENf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53600_A0_CPU_OTP_CTLr_ACCESS_MODEf_GET(r) ((((r).cpu_otp_ctl[0]) >> 22) & 0x3)
#define BCM53600_A0_CPU_OTP_CTLr_ACCESS_MODEf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_CPU_OTP_CTLr_BURST_STATE_SELf_GET(r) ((((r).cpu_otp_ctl[0]) >> 24) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_BURST_STATE_SELf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53600_A0_CPU_OTP_CTLr_CPU_DEBUG_SELf_GET(r) ((((r).cpu_otp_ctl[0]) >> 25) & 0xf)
#define BCM53600_A0_CPU_OTP_CTLr_CPU_DEBUG_SELf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM53600_A0_CPU_OTP_CTLr_RESERVED_1f_GET(r) ((((r).cpu_otp_ctl[0]) >> 29) & 0x3)
#define BCM53600_A0_CPU_OTP_CTLr_RESERVED_1f_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53600_A0_CPU_OTP_CTLr_BYPASS_OTP_CLKf_GET(r) ((((r).cpu_otp_ctl[0]) >> 31) & 0x1)
#define BCM53600_A0_CPU_OTP_CTLr_BYPASS_OTP_CLKf_SET(r,f) (r).cpu_otp_ctl[0]=(((r).cpu_otp_ctl[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CPU_OTP_CTL.
 *
 */
#define BCM53600_A0_READ_CPU_OTP_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CPU_OTP_CTLr,(r._cpu_otp_ctl),4)
#define BCM53600_A0_WRITE_CPU_OTP_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CPU_OTP_CTLr,&(r._cpu_otp_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_OTP_CTLr BCM53600_A0_CPU_OTP_CTLr
#define CPU_OTP_CTLr_SIZE BCM53600_A0_CPU_OTP_CTLr_SIZE
typedef BCM53600_A0_CPU_OTP_CTLr_t CPU_OTP_CTLr_t;
#define CPU_OTP_CTLr_CLR BCM53600_A0_CPU_OTP_CTLr_CLR
#define CPU_OTP_CTLr_SET BCM53600_A0_CPU_OTP_CTLr_SET
#define CPU_OTP_CTLr_GET BCM53600_A0_CPU_OTP_CTLr_GET
#define CPU_OTP_CTLr_STARTf_GET BCM53600_A0_CPU_OTP_CTLr_STARTf_GET
#define CPU_OTP_CTLr_STARTf_SET BCM53600_A0_CPU_OTP_CTLr_STARTf_SET
#define CPU_OTP_CTLr_COMMANDf_GET BCM53600_A0_CPU_OTP_CTLr_COMMANDf_GET
#define CPU_OTP_CTLr_COMMANDf_SET BCM53600_A0_CPU_OTP_CTLr_COMMANDf_SET
#define CPU_OTP_CTLr_WRP_PROG_SELf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_PROG_SELf_GET
#define CPU_OTP_CTLr_WRP_PROG_SELf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_PROG_SELf_SET
#define CPU_OTP_CTLr_WRP_VSELf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_VSELf_GET
#define CPU_OTP_CTLr_WRP_VSELf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_VSELf_SET
#define CPU_OTP_CTLr_WRP_PCOUNTf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_PCOUNTf_GET
#define CPU_OTP_CTLr_WRP_PCOUNTf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_PCOUNTf_SET
#define CPU_OTP_CTLr_WRP_PBYPf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_PBYPf_GET
#define CPU_OTP_CTLr_WRP_PBYPf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_PBYPf_SET
#define CPU_OTP_CTLr_RESERVED_0f_GET BCM53600_A0_CPU_OTP_CTLr_RESERVED_0f_GET
#define CPU_OTP_CTLr_RESERVED_0f_SET BCM53600_A0_CPU_OTP_CTLr_RESERVED_0f_SET
#define CPU_OTP_CTLr_WRP_SADBYPf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_SADBYPf_GET
#define CPU_OTP_CTLr_WRP_SADBYPf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_SADBYPf_SET
#define CPU_OTP_CTLr_WRP_TIME_MARGINf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_TIME_MARGINf_GET
#define CPU_OTP_CTLr_WRP_TIME_MARGINf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_TIME_MARGINf_SET
#define CPU_OTP_CTLr_WRP_CONTINUE_ON_FAILf_GET BCM53600_A0_CPU_OTP_CTLr_WRP_CONTINUE_ON_FAILf_GET
#define CPU_OTP_CTLr_WRP_CONTINUE_ON_FAILf_SET BCM53600_A0_CPU_OTP_CTLr_WRP_CONTINUE_ON_FAILf_SET
#define CPU_OTP_CTLr_OTP_DEBUG_MODEf_GET BCM53600_A0_CPU_OTP_CTLr_OTP_DEBUG_MODEf_GET
#define CPU_OTP_CTLr_OTP_DEBUG_MODEf_SET BCM53600_A0_CPU_OTP_CTLr_OTP_DEBUG_MODEf_SET
#define CPU_OTP_CTLr_OTP_PROG_ENf_GET BCM53600_A0_CPU_OTP_CTLr_OTP_PROG_ENf_GET
#define CPU_OTP_CTLr_OTP_PROG_ENf_SET BCM53600_A0_CPU_OTP_CTLr_OTP_PROG_ENf_SET
#define CPU_OTP_CTLr_ACCESS_MODEf_GET BCM53600_A0_CPU_OTP_CTLr_ACCESS_MODEf_GET
#define CPU_OTP_CTLr_ACCESS_MODEf_SET BCM53600_A0_CPU_OTP_CTLr_ACCESS_MODEf_SET
#define CPU_OTP_CTLr_BURST_STATE_SELf_GET BCM53600_A0_CPU_OTP_CTLr_BURST_STATE_SELf_GET
#define CPU_OTP_CTLr_BURST_STATE_SELf_SET BCM53600_A0_CPU_OTP_CTLr_BURST_STATE_SELf_SET
#define CPU_OTP_CTLr_CPU_DEBUG_SELf_GET BCM53600_A0_CPU_OTP_CTLr_CPU_DEBUG_SELf_GET
#define CPU_OTP_CTLr_CPU_DEBUG_SELf_SET BCM53600_A0_CPU_OTP_CTLr_CPU_DEBUG_SELf_SET
#define CPU_OTP_CTLr_RESERVED_1f_GET BCM53600_A0_CPU_OTP_CTLr_RESERVED_1f_GET
#define CPU_OTP_CTLr_RESERVED_1f_SET BCM53600_A0_CPU_OTP_CTLr_RESERVED_1f_SET
#define CPU_OTP_CTLr_BYPASS_OTP_CLKf_GET BCM53600_A0_CPU_OTP_CTLr_BYPASS_OTP_CLKf_GET
#define CPU_OTP_CTLr_BYPASS_OTP_CLKf_SET BCM53600_A0_CPU_OTP_CTLr_BYPASS_OTP_CLKf_SET
#define READ_CPU_OTP_CTLr BCM53600_A0_READ_CPU_OTP_CTLr
#define WRITE_CPU_OTP_CTLr BCM53600_A0_WRITE_CPU_OTP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CPU_OTP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CPU_OTP_RD_DATA
 * BLOCKS:   SYS
 * DESC:     CPU OTP Read Data Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     CPU_RD_DATA      The 32 bits CPU OTP read data register outputs the 32 bits read data from readcommand of CPU interface.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_CPU_OTP_RD_DATAr 0x0000e00c

#define BCM53600_A0_CPU_OTP_RD_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CPU_OTP_RD_DATA.
 *
 */
typedef union BCM53600_A0_CPU_OTP_RD_DATAr_s {
	uint32_t v[1];
	uint32_t cpu_otp_rd_data[1];
	uint32_t _cpu_otp_rd_data;
} BCM53600_A0_CPU_OTP_RD_DATAr_t;

#define BCM53600_A0_CPU_OTP_RD_DATAr_CLR(r) (r).cpu_otp_rd_data[0] = 0
#define BCM53600_A0_CPU_OTP_RD_DATAr_SET(r,d) (r).cpu_otp_rd_data[0] = d
#define BCM53600_A0_CPU_OTP_RD_DATAr_GET(r) (r).cpu_otp_rd_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CPU_OTP_RD_DATAr_CPU_RD_DATAf_GET(r) ((r).cpu_otp_rd_data[0])
#define BCM53600_A0_CPU_OTP_RD_DATAr_CPU_RD_DATAf_SET(r,f) (r).cpu_otp_rd_data[0]=((uint32_t)f)

/*
 * These macros can be used to access CPU_OTP_RD_DATA.
 *
 */
#define BCM53600_A0_READ_CPU_OTP_RD_DATAr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CPU_OTP_RD_DATAr,(r._cpu_otp_rd_data),4)
#define BCM53600_A0_WRITE_CPU_OTP_RD_DATAr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CPU_OTP_RD_DATAr,&(r._cpu_otp_rd_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_OTP_RD_DATAr BCM53600_A0_CPU_OTP_RD_DATAr
#define CPU_OTP_RD_DATAr_SIZE BCM53600_A0_CPU_OTP_RD_DATAr_SIZE
typedef BCM53600_A0_CPU_OTP_RD_DATAr_t CPU_OTP_RD_DATAr_t;
#define CPU_OTP_RD_DATAr_CLR BCM53600_A0_CPU_OTP_RD_DATAr_CLR
#define CPU_OTP_RD_DATAr_SET BCM53600_A0_CPU_OTP_RD_DATAr_SET
#define CPU_OTP_RD_DATAr_GET BCM53600_A0_CPU_OTP_RD_DATAr_GET
#define CPU_OTP_RD_DATAr_CPU_RD_DATAf_GET BCM53600_A0_CPU_OTP_RD_DATAr_CPU_RD_DATAf_GET
#define CPU_OTP_RD_DATAr_CPU_RD_DATAf_SET BCM53600_A0_CPU_OTP_RD_DATAr_CPU_RD_DATAf_SET
#define READ_CPU_OTP_RD_DATAr BCM53600_A0_READ_CPU_OTP_RD_DATAr
#define WRITE_CPU_OTP_RD_DATAr BCM53600_A0_WRITE_CPU_OTP_RD_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CPU_OTP_RD_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CPU_OTP_STATUS
 * BLOCKS:   SYS
 * DESC:     CPU OTP Status Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     COMMAND_DONE     This bit is set when the state machine has returned to IDLE. This will not be setuntil the last bit of a WORD program is complete.(Not2Release)
 *     WRP_DATA_READY   The wrp_dout is now valid to read.(Not2Release)
 *     WAP_DOUTL        This is the single bit data pointed to by the 12 bit address.(Not2Release)
 *     WRP_BUSY         A wrp_busy was seen - your request was started. Check command_done(bit 0) to seewhen it is complete.(Not2Release)
 *     WAP_FAIL         A FAIL was returned from the wrapper logic. the part is bad.(Not2Release)
 *     INVALID_PROG_REQ The program request was sent with incorrect access mode and 12 bit address setting.(Not2Release)
 *     PROG_BLOCKED     The row is locked and the programming attempt was not allowed.(Not2Release)
 *     INIT_WAIT_DONE   Can be used to indicate when OTP is out of RESET. Also if this bit is not a 1,there is no clock to the block OR the block is still in RESET.(Not2Release)
 *     OTP_STBY_REG     The OTP cell is in standby state. Applicable only when the OTP_STANDARDBYdefine is used. Else returns 0.(Always 0 in Thunderbolt)(Not2Release)
 *     INVALID_COMMAND  An invalid command was issued.(Not2Release)
 *     WRP_ERR          The wrapper module state machine went into an error state. Else returns 0.(Not2Release)
 *     CONTROL_ERR      The control module state machine went into an error state. Else returns 0.(Not2Release)
 *     RESERVED_1       Reserved for future expansion(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_CPU_OTP_STATUSr 0x0000e006

#define BCM53600_A0_CPU_OTP_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program CPU_OTP_STATUS.
 *
 */
typedef union BCM53600_A0_CPU_OTP_STATUSr_s {
	uint32_t v[1];
	uint32_t cpu_otp_status[1];
	uint32_t _cpu_otp_status;
} BCM53600_A0_CPU_OTP_STATUSr_t;

#define BCM53600_A0_CPU_OTP_STATUSr_CLR(r) (r).cpu_otp_status[0] = 0
#define BCM53600_A0_CPU_OTP_STATUSr_SET(r,d) (r).cpu_otp_status[0] = d
#define BCM53600_A0_CPU_OTP_STATUSr_GET(r) (r).cpu_otp_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CPU_OTP_STATUSr_COMMAND_DONEf_GET(r) (((r).cpu_otp_status[0]) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_COMMAND_DONEf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_CPU_OTP_STATUSr_WRP_DATA_READYf_GET(r) ((((r).cpu_otp_status[0]) >> 1) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_WRP_DATA_READYf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_CPU_OTP_STATUSr_WAP_DOUTLf_GET(r) ((((r).cpu_otp_status[0]) >> 2) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_WAP_DOUTLf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_CPU_OTP_STATUSr_WRP_BUSYf_GET(r) ((((r).cpu_otp_status[0]) >> 3) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_WRP_BUSYf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_CPU_OTP_STATUSr_WAP_FAILf_GET(r) ((((r).cpu_otp_status[0]) >> 4) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_WAP_FAILf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_CPU_OTP_STATUSr_INVALID_PROG_REQf_GET(r) ((((r).cpu_otp_status[0]) >> 5) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_INVALID_PROG_REQf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_CPU_OTP_STATUSr_PROG_BLOCKEDf_GET(r) ((((r).cpu_otp_status[0]) >> 6) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_PROG_BLOCKEDf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_CPU_OTP_STATUSr_INIT_WAIT_DONEf_GET(r) ((((r).cpu_otp_status[0]) >> 7) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_INIT_WAIT_DONEf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_CPU_OTP_STATUSr_OTP_STBY_REGf_GET(r) ((((r).cpu_otp_status[0]) >> 8) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_OTP_STBY_REGf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_CPU_OTP_STATUSr_INVALID_COMMANDf_GET(r) ((((r).cpu_otp_status[0]) >> 9) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_INVALID_COMMANDf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_CPU_OTP_STATUSr_WRP_ERRf_GET(r) ((((r).cpu_otp_status[0]) >> 10) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_WRP_ERRf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_CPU_OTP_STATUSr_CONTROL_ERRf_GET(r) ((((r).cpu_otp_status[0]) >> 11) & 0x1)
#define BCM53600_A0_CPU_OTP_STATUSr_CONTROL_ERRf_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_CPU_OTP_STATUSr_RESERVED_1f_GET(r) ((((r).cpu_otp_status[0]) >> 12) & 0xf)
#define BCM53600_A0_CPU_OTP_STATUSr_RESERVED_1f_SET(r,f) (r).cpu_otp_status[0]=(((r).cpu_otp_status[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access CPU_OTP_STATUS.
 *
 */
#define BCM53600_A0_READ_CPU_OTP_STATUSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CPU_OTP_STATUSr,(r._cpu_otp_status),2)
#define BCM53600_A0_WRITE_CPU_OTP_STATUSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CPU_OTP_STATUSr,&(r._cpu_otp_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_OTP_STATUSr BCM53600_A0_CPU_OTP_STATUSr
#define CPU_OTP_STATUSr_SIZE BCM53600_A0_CPU_OTP_STATUSr_SIZE
typedef BCM53600_A0_CPU_OTP_STATUSr_t CPU_OTP_STATUSr_t;
#define CPU_OTP_STATUSr_CLR BCM53600_A0_CPU_OTP_STATUSr_CLR
#define CPU_OTP_STATUSr_SET BCM53600_A0_CPU_OTP_STATUSr_SET
#define CPU_OTP_STATUSr_GET BCM53600_A0_CPU_OTP_STATUSr_GET
#define CPU_OTP_STATUSr_COMMAND_DONEf_GET BCM53600_A0_CPU_OTP_STATUSr_COMMAND_DONEf_GET
#define CPU_OTP_STATUSr_COMMAND_DONEf_SET BCM53600_A0_CPU_OTP_STATUSr_COMMAND_DONEf_SET
#define CPU_OTP_STATUSr_WRP_DATA_READYf_GET BCM53600_A0_CPU_OTP_STATUSr_WRP_DATA_READYf_GET
#define CPU_OTP_STATUSr_WRP_DATA_READYf_SET BCM53600_A0_CPU_OTP_STATUSr_WRP_DATA_READYf_SET
#define CPU_OTP_STATUSr_WAP_DOUTLf_GET BCM53600_A0_CPU_OTP_STATUSr_WAP_DOUTLf_GET
#define CPU_OTP_STATUSr_WAP_DOUTLf_SET BCM53600_A0_CPU_OTP_STATUSr_WAP_DOUTLf_SET
#define CPU_OTP_STATUSr_WRP_BUSYf_GET BCM53600_A0_CPU_OTP_STATUSr_WRP_BUSYf_GET
#define CPU_OTP_STATUSr_WRP_BUSYf_SET BCM53600_A0_CPU_OTP_STATUSr_WRP_BUSYf_SET
#define CPU_OTP_STATUSr_WAP_FAILf_GET BCM53600_A0_CPU_OTP_STATUSr_WAP_FAILf_GET
#define CPU_OTP_STATUSr_WAP_FAILf_SET BCM53600_A0_CPU_OTP_STATUSr_WAP_FAILf_SET
#define CPU_OTP_STATUSr_INVALID_PROG_REQf_GET BCM53600_A0_CPU_OTP_STATUSr_INVALID_PROG_REQf_GET
#define CPU_OTP_STATUSr_INVALID_PROG_REQf_SET BCM53600_A0_CPU_OTP_STATUSr_INVALID_PROG_REQf_SET
#define CPU_OTP_STATUSr_PROG_BLOCKEDf_GET BCM53600_A0_CPU_OTP_STATUSr_PROG_BLOCKEDf_GET
#define CPU_OTP_STATUSr_PROG_BLOCKEDf_SET BCM53600_A0_CPU_OTP_STATUSr_PROG_BLOCKEDf_SET
#define CPU_OTP_STATUSr_INIT_WAIT_DONEf_GET BCM53600_A0_CPU_OTP_STATUSr_INIT_WAIT_DONEf_GET
#define CPU_OTP_STATUSr_INIT_WAIT_DONEf_SET BCM53600_A0_CPU_OTP_STATUSr_INIT_WAIT_DONEf_SET
#define CPU_OTP_STATUSr_OTP_STBY_REGf_GET BCM53600_A0_CPU_OTP_STATUSr_OTP_STBY_REGf_GET
#define CPU_OTP_STATUSr_OTP_STBY_REGf_SET BCM53600_A0_CPU_OTP_STATUSr_OTP_STBY_REGf_SET
#define CPU_OTP_STATUSr_INVALID_COMMANDf_GET BCM53600_A0_CPU_OTP_STATUSr_INVALID_COMMANDf_GET
#define CPU_OTP_STATUSr_INVALID_COMMANDf_SET BCM53600_A0_CPU_OTP_STATUSr_INVALID_COMMANDf_SET
#define CPU_OTP_STATUSr_WRP_ERRf_GET BCM53600_A0_CPU_OTP_STATUSr_WRP_ERRf_GET
#define CPU_OTP_STATUSr_WRP_ERRf_SET BCM53600_A0_CPU_OTP_STATUSr_WRP_ERRf_SET
#define CPU_OTP_STATUSr_CONTROL_ERRf_GET BCM53600_A0_CPU_OTP_STATUSr_CONTROL_ERRf_GET
#define CPU_OTP_STATUSr_CONTROL_ERRf_SET BCM53600_A0_CPU_OTP_STATUSr_CONTROL_ERRf_SET
#define CPU_OTP_STATUSr_RESERVED_1f_GET BCM53600_A0_CPU_OTP_STATUSr_RESERVED_1f_GET
#define CPU_OTP_STATUSr_RESERVED_1f_SET BCM53600_A0_CPU_OTP_STATUSr_RESERVED_1f_SET
#define READ_CPU_OTP_STATUSr BCM53600_A0_READ_CPU_OTP_STATUSr
#define WRITE_CPU_OTP_STATUSr BCM53600_A0_WRITE_CPU_OTP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CPU_OTP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  CPU_OTP_WR_DATA
 * BLOCKS:   SYS
 * DESC:     CPU OTP Wrire Data Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     CPU_WR_DATA      The 32 bits CPU OTP write data register is used to provide write data withburst write command from CPU side. Different than the burst write from JTAG,cpu interface only supports 32 bit burst write data. This is to reduce thenumber of bits needed to wire to cpu interface at top level.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_CPU_OTP_WR_DATAr 0x0000e008

#define BCM53600_A0_CPU_OTP_WR_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CPU_OTP_WR_DATA.
 *
 */
typedef union BCM53600_A0_CPU_OTP_WR_DATAr_s {
	uint32_t v[1];
	uint32_t cpu_otp_wr_data[1];
	uint32_t _cpu_otp_wr_data;
} BCM53600_A0_CPU_OTP_WR_DATAr_t;

#define BCM53600_A0_CPU_OTP_WR_DATAr_CLR(r) (r).cpu_otp_wr_data[0] = 0
#define BCM53600_A0_CPU_OTP_WR_DATAr_SET(r,d) (r).cpu_otp_wr_data[0] = d
#define BCM53600_A0_CPU_OTP_WR_DATAr_GET(r) (r).cpu_otp_wr_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_CPU_OTP_WR_DATAr_CPU_WR_DATAf_GET(r) ((r).cpu_otp_wr_data[0])
#define BCM53600_A0_CPU_OTP_WR_DATAr_CPU_WR_DATAf_SET(r,f) (r).cpu_otp_wr_data[0]=((uint32_t)f)

/*
 * These macros can be used to access CPU_OTP_WR_DATA.
 *
 */
#define BCM53600_A0_READ_CPU_OTP_WR_DATAr(u,r) cdk_robo_reg_read(u,BCM53600_A0_CPU_OTP_WR_DATAr,(r._cpu_otp_wr_data),4)
#define BCM53600_A0_WRITE_CPU_OTP_WR_DATAr(u,r) cdk_robo_reg_write(u,BCM53600_A0_CPU_OTP_WR_DATAr,&(r._cpu_otp_wr_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_OTP_WR_DATAr BCM53600_A0_CPU_OTP_WR_DATAr
#define CPU_OTP_WR_DATAr_SIZE BCM53600_A0_CPU_OTP_WR_DATAr_SIZE
typedef BCM53600_A0_CPU_OTP_WR_DATAr_t CPU_OTP_WR_DATAr_t;
#define CPU_OTP_WR_DATAr_CLR BCM53600_A0_CPU_OTP_WR_DATAr_CLR
#define CPU_OTP_WR_DATAr_SET BCM53600_A0_CPU_OTP_WR_DATAr_SET
#define CPU_OTP_WR_DATAr_GET BCM53600_A0_CPU_OTP_WR_DATAr_GET
#define CPU_OTP_WR_DATAr_CPU_WR_DATAf_GET BCM53600_A0_CPU_OTP_WR_DATAr_CPU_WR_DATAf_GET
#define CPU_OTP_WR_DATAr_CPU_WR_DATAf_SET BCM53600_A0_CPU_OTP_WR_DATAr_CPU_WR_DATAf_SET
#define READ_CPU_OTP_WR_DATAr BCM53600_A0_READ_CPU_OTP_WR_DATAr
#define WRITE_CPU_OTP_WR_DATAr BCM53600_A0_WRITE_CPU_OTP_WR_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_CPU_OTP_WR_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  DEBUG_CONGESTION
 * BLOCKS:   SYS
 * DESC:     Debug Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_2SEC_FLUSH    Control bit for the symbol of enable_2sec_flush.(Not2Release)
 *     EN_LCOL_FLUSH    Control bit for the symbol of enable_lcol_flush.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *     ATEST_25MHZ_EN   Force the PAD_ATEST to output 25MHZ input clock.(Not2Release)
 *     EN_OTP_CPU_IF    Enable OTP CPU interface.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_DEBUG_CONGESTIONr 0x000000a0

#define BCM53600_A0_DEBUG_CONGESTIONr_SIZE 1

/*
 * This structure should be used to declare and program DEBUG_CONGESTION.
 *
 */
typedef union BCM53600_A0_DEBUG_CONGESTIONr_s {
	uint32_t v[1];
	uint32_t debug_congestion[1];
	uint32_t _debug_congestion;
} BCM53600_A0_DEBUG_CONGESTIONr_t;

#define BCM53600_A0_DEBUG_CONGESTIONr_CLR(r) (r).debug_congestion[0] = 0
#define BCM53600_A0_DEBUG_CONGESTIONr_SET(r,d) (r).debug_congestion[0] = d
#define BCM53600_A0_DEBUG_CONGESTIONr_GET(r) (r).debug_congestion[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DEBUG_CONGESTIONr_EN_2SEC_FLUSHf_GET(r) (((r).debug_congestion[0]) & 0x1)
#define BCM53600_A0_DEBUG_CONGESTIONr_EN_2SEC_FLUSHf_SET(r,f) (r).debug_congestion[0]=(((r).debug_congestion[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_DEBUG_CONGESTIONr_EN_LCOL_FLUSHf_GET(r) ((((r).debug_congestion[0]) >> 1) & 0x1)
#define BCM53600_A0_DEBUG_CONGESTIONr_EN_LCOL_FLUSHf_SET(r,f) (r).debug_congestion[0]=(((r).debug_congestion[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_DEBUG_CONGESTIONr_RESERVEDf_GET(r) ((((r).debug_congestion[0]) >> 2) & 0xf)
#define BCM53600_A0_DEBUG_CONGESTIONr_RESERVEDf_SET(r,f) (r).debug_congestion[0]=(((r).debug_congestion[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53600_A0_DEBUG_CONGESTIONr_ATEST_25MHZ_ENf_GET(r) ((((r).debug_congestion[0]) >> 6) & 0x1)
#define BCM53600_A0_DEBUG_CONGESTIONr_ATEST_25MHZ_ENf_SET(r,f) (r).debug_congestion[0]=(((r).debug_congestion[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_DEBUG_CONGESTIONr_EN_OTP_CPU_IFf_GET(r) ((((r).debug_congestion[0]) >> 7) & 0x1)
#define BCM53600_A0_DEBUG_CONGESTIONr_EN_OTP_CPU_IFf_SET(r,f) (r).debug_congestion[0]=(((r).debug_congestion[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access DEBUG_CONGESTION.
 *
 */
#define BCM53600_A0_READ_DEBUG_CONGESTIONr(u,r) cdk_robo_reg_read(u,BCM53600_A0_DEBUG_CONGESTIONr,(r._debug_congestion),1)
#define BCM53600_A0_WRITE_DEBUG_CONGESTIONr(u,r) cdk_robo_reg_write(u,BCM53600_A0_DEBUG_CONGESTIONr,&(r._debug_congestion),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_CONGESTIONr BCM53600_A0_DEBUG_CONGESTIONr
#define DEBUG_CONGESTIONr_SIZE BCM53600_A0_DEBUG_CONGESTIONr_SIZE
typedef BCM53600_A0_DEBUG_CONGESTIONr_t DEBUG_CONGESTIONr_t;
#define DEBUG_CONGESTIONr_CLR BCM53600_A0_DEBUG_CONGESTIONr_CLR
#define DEBUG_CONGESTIONr_SET BCM53600_A0_DEBUG_CONGESTIONr_SET
#define DEBUG_CONGESTIONr_GET BCM53600_A0_DEBUG_CONGESTIONr_GET
#define DEBUG_CONGESTIONr_EN_2SEC_FLUSHf_GET BCM53600_A0_DEBUG_CONGESTIONr_EN_2SEC_FLUSHf_GET
#define DEBUG_CONGESTIONr_EN_2SEC_FLUSHf_SET BCM53600_A0_DEBUG_CONGESTIONr_EN_2SEC_FLUSHf_SET
#define DEBUG_CONGESTIONr_EN_LCOL_FLUSHf_GET BCM53600_A0_DEBUG_CONGESTIONr_EN_LCOL_FLUSHf_GET
#define DEBUG_CONGESTIONr_EN_LCOL_FLUSHf_SET BCM53600_A0_DEBUG_CONGESTIONr_EN_LCOL_FLUSHf_SET
#define DEBUG_CONGESTIONr_RESERVEDf_GET BCM53600_A0_DEBUG_CONGESTIONr_RESERVEDf_GET
#define DEBUG_CONGESTIONr_RESERVEDf_SET BCM53600_A0_DEBUG_CONGESTIONr_RESERVEDf_SET
#define DEBUG_CONGESTIONr_ATEST_25MHZ_ENf_GET BCM53600_A0_DEBUG_CONGESTIONr_ATEST_25MHZ_ENf_GET
#define DEBUG_CONGESTIONr_ATEST_25MHZ_ENf_SET BCM53600_A0_DEBUG_CONGESTIONr_ATEST_25MHZ_ENf_SET
#define DEBUG_CONGESTIONr_EN_OTP_CPU_IFf_GET BCM53600_A0_DEBUG_CONGESTIONr_EN_OTP_CPU_IFf_GET
#define DEBUG_CONGESTIONr_EN_OTP_CPU_IFf_SET BCM53600_A0_DEBUG_CONGESTIONr_EN_OTP_CPU_IFf_SET
#define READ_DEBUG_CONGESTIONr BCM53600_A0_READ_DEBUG_CONGESTIONr
#define WRITE_DEBUG_CONGESTIONr BCM53600_A0_WRITE_DEBUG_CONGESTIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DEBUG_CONGESTIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  DEF_PORT_QOS_CFG
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Port n Default Port QOS Configuration Register
 * SIZE:     48
 * FIELDS:
 *     PORT_PROFILE     It indicates the port profile attributes associated with the port.
 *     TC               Default port Traffic Class.
 *     DP               Default port Drop Precedence.
 *     SVID             Default Service VLAN ID.
 *     RESERVED_0       Reserved
 *     SPCP             Default Service PCP.
 *     CVID             Default Customer VLAN ID.
 *     RESERVED_1       Reserved
 *     CPCP             Default Customer PCP.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_DEF_PORT_QOS_CFGr 0x00002800

#define BCM53600_A0_DEF_PORT_QOS_CFGr_SIZE 6

/*
 * This structure should be used to declare and program DEF_PORT_QOS_CFG.
 *
 */
typedef union BCM53600_A0_DEF_PORT_QOS_CFGr_s {
	uint32_t v[2];
	uint32_t def_port_qos_cfg[2];
	uint32_t _def_port_qos_cfg;
} BCM53600_A0_DEF_PORT_QOS_CFGr_t;

#define BCM53600_A0_DEF_PORT_QOS_CFGr_CLR(r) CDK_MEMSET(&((r)._def_port_qos_cfg), 0, sizeof(BCM53600_A0_DEF_PORT_QOS_CFGr_t))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_SET(r,i,d) (r).def_port_qos_cfg[i] = d
#define BCM53600_A0_DEF_PORT_QOS_CFGr_GET(r,i) (r).def_port_qos_cfg[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DEF_PORT_QOS_CFGr_PORT_PROFILEf_GET(r) (((r).def_port_qos_cfg[0]) & 0x3)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_PORT_PROFILEf_SET(r,f) (r).def_port_qos_cfg[0]=(((r).def_port_qos_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_TCf_GET(r) ((((r).def_port_qos_cfg[0]) >> 2) & 0xf)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_TCf_SET(r,f) (r).def_port_qos_cfg[0]=(((r).def_port_qos_cfg[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_DPf_GET(r) ((((r).def_port_qos_cfg[0]) >> 6) & 0x3)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_DPf_SET(r,f) (r).def_port_qos_cfg[0]=(((r).def_port_qos_cfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_SVIDf_GET(r) ((((r).def_port_qos_cfg[0]) >> 8) & 0xfff)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_SVIDf_SET(r,f) (r).def_port_qos_cfg[0]=(((r).def_port_qos_cfg[0] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_0f_GET(r) ((((r).def_port_qos_cfg[0]) >> 20) & 0x1)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_0f_SET(r,f) (r).def_port_qos_cfg[0]=(((r).def_port_qos_cfg[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_SPCPf_GET(r) ((((r).def_port_qos_cfg[0]) >> 21) & 0x7)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_SPCPf_SET(r,f) (r).def_port_qos_cfg[0]=(((r).def_port_qos_cfg[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_CVIDf_GET(r) cdk_field32_get((r).def_port_qos_cfg,24,35)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_CVIDf_SET(r,f) cdk_field32_set((r).def_port_qos_cfg,24,35,f)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_1f_GET(r) ((((r).def_port_qos_cfg[1]) >> 4) & 0x1)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_1f_SET(r,f) (r).def_port_qos_cfg[1]=(((r).def_port_qos_cfg[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_CPCPf_GET(r) ((((r).def_port_qos_cfg[1]) >> 5) & 0x7)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_CPCPf_SET(r,f) (r).def_port_qos_cfg[1]=(((r).def_port_qos_cfg[1] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_2f_GET(r) ((((r).def_port_qos_cfg[1]) >> 8) & 0xff)
#define BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_2f_SET(r,f) (r).def_port_qos_cfg[1]=(((r).def_port_qos_cfg[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access DEF_PORT_QOS_CFG.
 *
 */
#define BCM53600_A0_READ_DEF_PORT_QOS_CFGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_DEF_PORT_QOS_CFGr,(r._def_port_qos_cfg),6)
#define BCM53600_A0_WRITE_DEF_PORT_QOS_CFGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_DEF_PORT_QOS_CFGr,&(r._def_port_qos_cfg),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEF_PORT_QOS_CFGr BCM53600_A0_DEF_PORT_QOS_CFGr
#define DEF_PORT_QOS_CFGr_SIZE BCM53600_A0_DEF_PORT_QOS_CFGr_SIZE
typedef BCM53600_A0_DEF_PORT_QOS_CFGr_t DEF_PORT_QOS_CFGr_t;
#define DEF_PORT_QOS_CFGr_CLR BCM53600_A0_DEF_PORT_QOS_CFGr_CLR
#define DEF_PORT_QOS_CFGr_SET BCM53600_A0_DEF_PORT_QOS_CFGr_SET
#define DEF_PORT_QOS_CFGr_GET BCM53600_A0_DEF_PORT_QOS_CFGr_GET
#define DEF_PORT_QOS_CFGr_PORT_PROFILEf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_PORT_PROFILEf_GET
#define DEF_PORT_QOS_CFGr_PORT_PROFILEf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_PORT_PROFILEf_SET
#define DEF_PORT_QOS_CFGr_TCf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_TCf_GET
#define DEF_PORT_QOS_CFGr_TCf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_TCf_SET
#define DEF_PORT_QOS_CFGr_DPf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_DPf_GET
#define DEF_PORT_QOS_CFGr_DPf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_DPf_SET
#define DEF_PORT_QOS_CFGr_SVIDf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_SVIDf_GET
#define DEF_PORT_QOS_CFGr_SVIDf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_SVIDf_SET
#define DEF_PORT_QOS_CFGr_RESERVED_0f_GET BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_0f_GET
#define DEF_PORT_QOS_CFGr_RESERVED_0f_SET BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_0f_SET
#define DEF_PORT_QOS_CFGr_SPCPf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_SPCPf_GET
#define DEF_PORT_QOS_CFGr_SPCPf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_SPCPf_SET
#define DEF_PORT_QOS_CFGr_CVIDf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_CVIDf_GET
#define DEF_PORT_QOS_CFGr_CVIDf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_CVIDf_SET
#define DEF_PORT_QOS_CFGr_RESERVED_1f_GET BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_1f_GET
#define DEF_PORT_QOS_CFGr_RESERVED_1f_SET BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_1f_SET
#define DEF_PORT_QOS_CFGr_CPCPf_GET BCM53600_A0_DEF_PORT_QOS_CFGr_CPCPf_GET
#define DEF_PORT_QOS_CFGr_CPCPf_SET BCM53600_A0_DEF_PORT_QOS_CFGr_CPCPf_SET
#define DEF_PORT_QOS_CFGr_RESERVED_2f_GET BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_2f_GET
#define DEF_PORT_QOS_CFGr_RESERVED_2f_SET BCM53600_A0_DEF_PORT_QOS_CFGr_RESERVED_2f_SET
#define READ_DEF_PORT_QOS_CFGr BCM53600_A0_READ_DEF_PORT_QOS_CFGr
#define WRITE_DEF_PORT_QOS_CFGr BCM53600_A0_WRITE_DEF_PORT_QOS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DEF_PORT_QOS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  DOS_ATTACK_FILTER_DROP_CTL
 * BLOCKS:   SYS
 * DESC:     DOS Attack Filter Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Reserved
 *     EN_IP_LAND_DROP  IP_LAND: IPDA=IPSA.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_BLAT_DROP TCP_BLAT: DPort=Sport in a TCP header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_UDP_BLAT_DROP UDP_BLAT: DPort=Sport in a UDP header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_NULL_SCAN_DROP TCP_NULLScan: Seq_Num=0 && All TCP_Flags=0 in a TCP header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_XMAS_SCAN_DROP TCP_XMASScan: Seq_Num=0 && FIN=1 && URG=1 && PSH=1 in a TCPheader.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_SINFIN_SCAN_DROP TCP_SINFINScan: SYN=1 && FIN=1 in a TCP header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_SYN_ERR_DROP TCP_SYNErr: SYN=1 && ACK=0 && SPort<1024 in a TCP header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_SHORT_HDR_DROP TCP_ShortHdr: Length of TCP header is less than MIN_TCP_Header_Sizein a TCP header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_TCP_FRAG_ERR_DROP TCP_FRAGErr: Fragment_Offset=1 in any fragment of a fragmentedIP datagram carrying part of TCP data.datagram.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_ICMPV4_FRAG_DROP ICMPv4_Fragment: The ICMPv4 PDU is carried in a fragmented IPv4datagram.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_ICMPV6_FRAG_DROP ICMPv6_Fragment: The ICMPv6 PDU is carried in a fragmented IPv6datagram.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_ICMPV4_LONGPING_DROP ICMPv4_LongPing: The ICMPv4 Ping(Echo Request) PDU is carried in anunfragmented IPv4 datagram with its Total Length indicating a valueis greater than MAX_ICMPv4_Size + size of IPv4 header.1 = Drop the specified packet.0 = Do not drop the packet.
 *     EN_ICMPV6_LONGPING_DROP ICMPv6_LongPing: The ICMPv6 Ping(Echo Request) PDU is carried in anunfragmented IPv6 datagram with its Payload Length indicating a valueis greater than MAX_ICMPv6_Size.1 = Drop the specified packet.0 = Do not drop the packet.
 *     RESERVED_1       Reserved
 *     CPUCOPY_BYPASS_DOS 1 = Enable DOS attack packets which is configured to be dropped bypassedCpuCopy.
 *
 ******************************************************************************/
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr 0x00002c20

#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_SIZE 2

/*
 * This structure should be used to declare and program DOS_ATTACK_FILTER_DROP_CTL.
 *
 */
typedef union BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t dos_attack_filter_drop_ctl[1];
	uint32_t _dos_attack_filter_drop_ctl;
} BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_t;

#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_CLR(r) (r).dos_attack_filter_drop_ctl[0] = 0
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_SET(r,d) (r).dos_attack_filter_drop_ctl[0] = d
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_GET(r) (r).dos_attack_filter_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_0f_GET(r) (((r).dos_attack_filter_drop_ctl[0]) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_0f_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_IP_LAND_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_IP_LAND_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_BLAT_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_BLAT_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_UDP_BLAT_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_UDP_BLAT_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_NULL_SCAN_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_NULL_SCAN_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_XMAS_SCAN_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_XMAS_SCAN_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SINFIN_SCAN_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SINFIN_SCAN_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SYN_ERR_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SYN_ERR_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SHORT_HDR_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 8) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SHORT_HDR_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_FRAG_ERR_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 9) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_FRAG_ERR_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_FRAG_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 10) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_FRAG_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_FRAG_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 11) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_FRAG_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_LONGPING_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 12) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_LONGPING_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_LONGPING_DROPf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 13) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_LONGPING_DROPf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_1f_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 14) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_1f_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_CPUCOPY_BYPASS_DOSf_GET(r) ((((r).dos_attack_filter_drop_ctl[0]) >> 15) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_CPUCOPY_BYPASS_DOSf_SET(r,f) (r).dos_attack_filter_drop_ctl[0]=(((r).dos_attack_filter_drop_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access DOS_ATTACK_FILTER_DROP_CTL.
 *
 */
#define BCM53600_A0_READ_DOS_ATTACK_FILTER_DROP_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr,(r._dos_attack_filter_drop_ctl),2)
#define BCM53600_A0_WRITE_DOS_ATTACK_FILTER_DROP_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr,&(r._dos_attack_filter_drop_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_ATTACK_FILTER_DROP_CTLr BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr
#define DOS_ATTACK_FILTER_DROP_CTLr_SIZE BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_SIZE
typedef BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_t DOS_ATTACK_FILTER_DROP_CTLr_t;
#define DOS_ATTACK_FILTER_DROP_CTLr_CLR BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_CLR
#define DOS_ATTACK_FILTER_DROP_CTLr_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_0f_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_0f_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_0f_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_0f_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_IP_LAND_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_IP_LAND_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_IP_LAND_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_IP_LAND_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_BLAT_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_BLAT_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_BLAT_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_BLAT_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_UDP_BLAT_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_UDP_BLAT_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_UDP_BLAT_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_UDP_BLAT_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_NULL_SCAN_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_NULL_SCAN_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_NULL_SCAN_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_NULL_SCAN_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_XMAS_SCAN_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_XMAS_SCAN_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_XMAS_SCAN_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_XMAS_SCAN_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SINFIN_SCAN_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SINFIN_SCAN_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SINFIN_SCAN_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SINFIN_SCAN_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SYN_ERR_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SYN_ERR_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SYN_ERR_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SYN_ERR_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SHORT_HDR_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SHORT_HDR_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SHORT_HDR_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_SHORT_HDR_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_FRAG_ERR_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_FRAG_ERR_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_FRAG_ERR_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_TCP_FRAG_ERR_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_FRAG_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_FRAG_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_FRAG_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_FRAG_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_FRAG_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_FRAG_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_FRAG_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_FRAG_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_LONGPING_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_LONGPING_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_LONGPING_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV4_LONGPING_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_LONGPING_DROPf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_LONGPING_DROPf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_LONGPING_DROPf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_EN_ICMPV6_LONGPING_DROPf_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_1f_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_1f_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_1f_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_RESERVED_1f_SET
#define DOS_ATTACK_FILTER_DROP_CTLr_CPUCOPY_BYPASS_DOSf_GET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_CPUCOPY_BYPASS_DOSf_GET
#define DOS_ATTACK_FILTER_DROP_CTLr_CPUCOPY_BYPASS_DOSf_SET BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr_CPUCOPY_BYPASS_DOSf_SET
#define READ_DOS_ATTACK_FILTER_DROP_CTLr BCM53600_A0_READ_DOS_ATTACK_FILTER_DROP_CTLr
#define WRITE_DOS_ATTACK_FILTER_DROP_CTLr BCM53600_A0_WRITE_DOS_ATTACK_FILTER_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DOS_ATTACK_FILTER_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  DOS_ATTACK_FILTER_EVENT
 * BLOCKS:   SYS
 * DESC:     DOS Attack Filter Event Register
 * SIZE:     16
 * FIELDS:
 *     MAC_LAND_EVENT   MAC_LAND: MACDA=MACSA.It is a read-and-clear register1 = the event has been occured after previous read.
 *     IP_LAND_EVENT    IP_LAND: IPDA=IPSA.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_BLAT_EVENT   TCP_BLAT: DPort=Sport in a TCP header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     UDP_BLAT_EVENT   UDP_BLAT: DPort=Sport in a UDP header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_NULL_SCAN_EVENT TCP_NULLScan: Seq_Num=0 && All TCP_Flags=0 in a TCP header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_XMAS_SCAN_EVENT TCP_XMASScan: Seq_Num=0 && FIN=1 && URG=1 && PSH=1 in a TCPheader.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_SINFIN_SCAN_EVENT TCP_SINFINScan: SYN=1 && FIN=1 in a TCP header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_SYN_ERR_EVENT TCP_SYNErr: SYN=1 && ACK=0 && SPort<1024 in a TCP header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_SHORT_HDR_EVENT TCP_ShortHdr: Length of TCP header is less than MIN_TCP_Header_Sizein a TCP header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     TCP_FRAG_ERR_EVENT TCP_FRAGErr: Fragment_Offset=1 in any fragment of a fragmentedIP datagram carrying part of TCP data.datagram.It is a read-and-clear register1 = the event has been occured after previous read.
 *     ICMPV4_FRAG_EVENT ICMPv4_Fragment: The ICMPv4 PDU is carried in a fragmented IPv4datagram.It is a read-and-clear register1 = the event has been occured after previous read.
 *     ICMPV6_FRAG_EVENT ICMPv6_Fragment: The ICMPv6 PDU is carried in a fragmented IPv6datagram.It is a read-and-clear register1 = the event has been occured after previous read.
 *     ICMPV4_LONGPING_EVENT ICMPv4_LongPing: The ICMPv4 Ping(Echo Request) PDU is carried in anunfragmented IPv4 datagram with its Total Length indicating a valueis greater than MAX_ICMPv4_Size + size of IPv4 header.It is a read-and-clear register1 = the event has been occured after previous read.
 *     ICMPV6_LONGPING_EVENT ICMPv6_LongPing: The ICMPv6 Ping(Echo Request) PDU is carried in anunfragmented IPv6 datagram with its Payload Length indicating a valueis greater than MAX_ICMPv6_Size.It is a read-and-clear register1 = the event has been occured after previous read.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr 0x00002c30

#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_SIZE 2

/*
 * This structure should be used to declare and program DOS_ATTACK_FILTER_EVENT.
 *
 */
typedef union BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_s {
	uint32_t v[1];
	uint32_t dos_attack_filter_event[1];
	uint32_t _dos_attack_filter_event;
} BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_t;

#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_CLR(r) (r).dos_attack_filter_event[0] = 0
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_SET(r,d) (r).dos_attack_filter_event[0] = d
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_GET(r) (r).dos_attack_filter_event[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_MAC_LAND_EVENTf_GET(r) (((r).dos_attack_filter_event[0]) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_MAC_LAND_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_IP_LAND_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 1) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_IP_LAND_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_BLAT_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 2) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_BLAT_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_UDP_BLAT_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 3) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_UDP_BLAT_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_NULL_SCAN_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 4) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_NULL_SCAN_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_XMAS_SCAN_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 5) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_XMAS_SCAN_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SINFIN_SCAN_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 6) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SINFIN_SCAN_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SYN_ERR_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 7) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SYN_ERR_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SHORT_HDR_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 8) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SHORT_HDR_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_FRAG_ERR_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 9) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_FRAG_ERR_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_FRAG_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 10) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_FRAG_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_FRAG_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 11) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_FRAG_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_LONGPING_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 12) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_LONGPING_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_LONGPING_EVENTf_GET(r) ((((r).dos_attack_filter_event[0]) >> 13) & 0x1)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_LONGPING_EVENTf_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_RESERVED_1f_GET(r) ((((r).dos_attack_filter_event[0]) >> 14) & 0x3)
#define BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_RESERVED_1f_SET(r,f) (r).dos_attack_filter_event[0]=(((r).dos_attack_filter_event[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access DOS_ATTACK_FILTER_EVENT.
 *
 */
#define BCM53600_A0_READ_DOS_ATTACK_FILTER_EVENTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_DOS_ATTACK_FILTER_EVENTr,(r._dos_attack_filter_event),2)
#define BCM53600_A0_WRITE_DOS_ATTACK_FILTER_EVENTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_DOS_ATTACK_FILTER_EVENTr,&(r._dos_attack_filter_event),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_ATTACK_FILTER_EVENTr BCM53600_A0_DOS_ATTACK_FILTER_EVENTr
#define DOS_ATTACK_FILTER_EVENTr_SIZE BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_SIZE
typedef BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_t DOS_ATTACK_FILTER_EVENTr_t;
#define DOS_ATTACK_FILTER_EVENTr_CLR BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_CLR
#define DOS_ATTACK_FILTER_EVENTr_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_SET
#define DOS_ATTACK_FILTER_EVENTr_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_GET
#define DOS_ATTACK_FILTER_EVENTr_MAC_LAND_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_MAC_LAND_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_MAC_LAND_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_MAC_LAND_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_IP_LAND_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_IP_LAND_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_IP_LAND_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_IP_LAND_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_BLAT_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_BLAT_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_BLAT_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_BLAT_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_UDP_BLAT_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_UDP_BLAT_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_UDP_BLAT_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_UDP_BLAT_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_NULL_SCAN_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_NULL_SCAN_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_NULL_SCAN_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_NULL_SCAN_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_XMAS_SCAN_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_XMAS_SCAN_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_XMAS_SCAN_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_XMAS_SCAN_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_SINFIN_SCAN_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SINFIN_SCAN_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_SINFIN_SCAN_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SINFIN_SCAN_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_SYN_ERR_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SYN_ERR_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_SYN_ERR_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SYN_ERR_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_SHORT_HDR_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SHORT_HDR_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_SHORT_HDR_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_SHORT_HDR_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_TCP_FRAG_ERR_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_FRAG_ERR_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_TCP_FRAG_ERR_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_TCP_FRAG_ERR_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV4_FRAG_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_FRAG_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV4_FRAG_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_FRAG_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV6_FRAG_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_FRAG_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV6_FRAG_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_FRAG_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV4_LONGPING_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_LONGPING_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV4_LONGPING_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV4_LONGPING_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV6_LONGPING_EVENTf_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_LONGPING_EVENTf_GET
#define DOS_ATTACK_FILTER_EVENTr_ICMPV6_LONGPING_EVENTf_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_ICMPV6_LONGPING_EVENTf_SET
#define DOS_ATTACK_FILTER_EVENTr_RESERVED_1f_GET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_RESERVED_1f_GET
#define DOS_ATTACK_FILTER_EVENTr_RESERVED_1f_SET BCM53600_A0_DOS_ATTACK_FILTER_EVENTr_RESERVED_1f_SET
#define READ_DOS_ATTACK_FILTER_EVENTr BCM53600_A0_READ_DOS_ATTACK_FILTER_EVENTr
#define WRITE_DOS_ATTACK_FILTER_EVENTr BCM53600_A0_WRITE_DOS_ATTACK_FILTER_EVENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DOS_ATTACK_FILTER_EVENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  DPTC2PCP
 * BLOCKS:   SYS
 * DESC:     DPTC2PCP Table
 * SIZE:     8
 * FIELDS:
 *     C_DEI            C_DEI
 *     C_PCP            C_PCP
 *     S_DEI            S_DEI
 *     S_PCP            S_PCP
 *
 ******************************************************************************/
#define BCM53600_A0_DPTC2PCPm 0x00000000

#define BCM53600_A0_DPTC2PCPm_MIN 0
#define BCM53600_A0_DPTC2PCPm_MAX 1855
#define BCM53600_A0_DPTC2PCPm_CMAX(u) 1855
#define BCM53600_A0_DPTC2PCPm_SIZE 1

/*
 * This structure should be used to declare and program DPTC2PCP.
 *
 */
typedef union BCM53600_A0_DPTC2PCPm_s {
	uint32_t v[1];
	uint32_t dptc2pcp[1];
	uint32_t _dptc2pcp;
} BCM53600_A0_DPTC2PCPm_t;

#define BCM53600_A0_DPTC2PCPm_CLR(r) (r).dptc2pcp[0] = 0
#define BCM53600_A0_DPTC2PCPm_SET(r,d) (r).dptc2pcp[0] = d
#define BCM53600_A0_DPTC2PCPm_GET(r) (r).dptc2pcp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DPTC2PCPm_C_DEIf_GET(r) (((r).dptc2pcp[0]) & 0x1)
#define BCM53600_A0_DPTC2PCPm_C_DEIf_SET(r,f) (r).dptc2pcp[0]=(((r).dptc2pcp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_DPTC2PCPm_C_PCPf_GET(r) ((((r).dptc2pcp[0]) >> 1) & 0x7)
#define BCM53600_A0_DPTC2PCPm_C_PCPf_SET(r,f) (r).dptc2pcp[0]=(((r).dptc2pcp[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53600_A0_DPTC2PCPm_S_DEIf_GET(r) ((((r).dptc2pcp[0]) >> 4) & 0x1)
#define BCM53600_A0_DPTC2PCPm_S_DEIf_SET(r,f) (r).dptc2pcp[0]=(((r).dptc2pcp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_DPTC2PCPm_S_PCPf_GET(r) ((((r).dptc2pcp[0]) >> 5) & 0x7)
#define BCM53600_A0_DPTC2PCPm_S_PCPf_SET(r,f) (r).dptc2pcp[0]=(((r).dptc2pcp[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access DPTC2PCP.
 *
 */
#define BCM53600_A0_READ_DPTC2PCPm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_DPTC2PCPm,i,(m),1)
#define BCM53600_A0_WRITE_DPTC2PCPm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_DPTC2PCPm,i,&(m),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DPTC2PCPm BCM53600_A0_DPTC2PCPm
#define DPTC2PCPm_MIN BCM53600_A0_DPTC2PCPm_MIN
#define DPTC2PCPm_MAX BCM53600_A0_DPTC2PCPm_MAX
#define DPTC2PCPm_CMAX(u) BCM53600_A0_DPTC2PCPm_CMAX(u)
#define DPTC2PCPm_SIZE BCM53600_A0_DPTC2PCPm_SIZE
typedef BCM53600_A0_DPTC2PCPm_t DPTC2PCPm_t;
#define DPTC2PCPm_CLR BCM53600_A0_DPTC2PCPm_CLR
#define DPTC2PCPm_SET BCM53600_A0_DPTC2PCPm_SET
#define DPTC2PCPm_GET BCM53600_A0_DPTC2PCPm_GET
#define DPTC2PCPm_C_DEIf_GET BCM53600_A0_DPTC2PCPm_C_DEIf_GET
#define DPTC2PCPm_C_DEIf_SET BCM53600_A0_DPTC2PCPm_C_DEIf_SET
#define DPTC2PCPm_C_PCPf_GET BCM53600_A0_DPTC2PCPm_C_PCPf_GET
#define DPTC2PCPm_C_PCPf_SET BCM53600_A0_DPTC2PCPm_C_PCPf_SET
#define DPTC2PCPm_S_DEIf_GET BCM53600_A0_DPTC2PCPm_S_DEIf_GET
#define DPTC2PCPm_S_DEIf_SET BCM53600_A0_DPTC2PCPm_S_DEIf_SET
#define DPTC2PCPm_S_PCPf_GET BCM53600_A0_DPTC2PCPm_S_PCPf_GET
#define DPTC2PCPm_S_PCPf_SET BCM53600_A0_DPTC2PCPm_S_PCPf_SET
#define READ_DPTC2PCPm BCM53600_A0_READ_DPTC2PCPm
#define WRITE_DPTC2PCPm BCM53600_A0_WRITE_DPTC2PCPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DPTC2PCPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  DP_CTRL
 * BLOCKS:   SYS
 * DESC:     DP Control Register
 * SIZE:     8
 * FIELDS:
 *     SET_XOFF_DP      DP change control for the flow-controllable port.1:Set DP=DP0, if the port is flow-controllable port. A port is flow-controllableport when the XOFF State = 1 in the "Port XOFF Status Summary" register(Page02h,Addr38h). For Giga port, it indicates for TX pause capability.When the port is a non-flow-controllable port or the bit=0, the DP isdepended on the result of the other DP mapping process.
 *     SET_DLF_DP       DP change control for the unknown unicast/multicast packet.1:Set DP=DP_CTRL[3:2] if the packet is a DLF packet.When the packet is not a DLF packet or the bit=0, the DP is depended onthe result of the other DP mapping process.
 *     DLF_DP           DP value of the unknown unicast/multicast packet.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_DP_CTRLr 0x000028e0

#define BCM53600_A0_DP_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program DP_CTRL.
 *
 */
typedef union BCM53600_A0_DP_CTRLr_s {
	uint32_t v[1];
	uint32_t dp_ctrl[1];
	uint32_t _dp_ctrl;
} BCM53600_A0_DP_CTRLr_t;

#define BCM53600_A0_DP_CTRLr_CLR(r) (r).dp_ctrl[0] = 0
#define BCM53600_A0_DP_CTRLr_SET(r,d) (r).dp_ctrl[0] = d
#define BCM53600_A0_DP_CTRLr_GET(r) (r).dp_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DP_CTRLr_SET_XOFF_DPf_GET(r) (((r).dp_ctrl[0]) & 0x1)
#define BCM53600_A0_DP_CTRLr_SET_XOFF_DPf_SET(r,f) (r).dp_ctrl[0]=(((r).dp_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_DP_CTRLr_SET_DLF_DPf_GET(r) ((((r).dp_ctrl[0]) >> 1) & 0x1)
#define BCM53600_A0_DP_CTRLr_SET_DLF_DPf_SET(r,f) (r).dp_ctrl[0]=(((r).dp_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_DP_CTRLr_DLF_DPf_GET(r) ((((r).dp_ctrl[0]) >> 2) & 0x3)
#define BCM53600_A0_DP_CTRLr_DLF_DPf_SET(r,f) (r).dp_ctrl[0]=(((r).dp_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_DP_CTRLr_RESERVEDf_GET(r) ((((r).dp_ctrl[0]) >> 4) & 0xf)
#define BCM53600_A0_DP_CTRLr_RESERVEDf_SET(r,f) (r).dp_ctrl[0]=(((r).dp_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access DP_CTRL.
 *
 */
#define BCM53600_A0_READ_DP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_DP_CTRLr,(r._dp_ctrl),1)
#define BCM53600_A0_WRITE_DP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_DP_CTRLr,&(r._dp_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DP_CTRLr BCM53600_A0_DP_CTRLr
#define DP_CTRLr_SIZE BCM53600_A0_DP_CTRLr_SIZE
typedef BCM53600_A0_DP_CTRLr_t DP_CTRLr_t;
#define DP_CTRLr_CLR BCM53600_A0_DP_CTRLr_CLR
#define DP_CTRLr_SET BCM53600_A0_DP_CTRLr_SET
#define DP_CTRLr_GET BCM53600_A0_DP_CTRLr_GET
#define DP_CTRLr_SET_XOFF_DPf_GET BCM53600_A0_DP_CTRLr_SET_XOFF_DPf_GET
#define DP_CTRLr_SET_XOFF_DPf_SET BCM53600_A0_DP_CTRLr_SET_XOFF_DPf_SET
#define DP_CTRLr_SET_DLF_DPf_GET BCM53600_A0_DP_CTRLr_SET_DLF_DPf_GET
#define DP_CTRLr_SET_DLF_DPf_SET BCM53600_A0_DP_CTRLr_SET_DLF_DPf_SET
#define DP_CTRLr_DLF_DPf_GET BCM53600_A0_DP_CTRLr_DLF_DPf_GET
#define DP_CTRLr_DLF_DPf_SET BCM53600_A0_DP_CTRLr_DLF_DPf_SET
#define DP_CTRLr_RESERVEDf_GET BCM53600_A0_DP_CTRLr_RESERVEDf_GET
#define DP_CTRLr_RESERVEDf_SET BCM53600_A0_DP_CTRLr_RESERVEDf_SET
#define READ_DP_CTRLr BCM53600_A0_READ_DP_CTRLr
#define WRITE_DP_CTRLr BCM53600_A0_WRITE_DP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  DSCPECN2TCDP
 * BLOCKS:   SYS
 * DESC:     DSCPECN2TCDP Table
 * SIZE:     6
 * FIELDS:
 *     TC               TC
 *     DP               DP
 *
 ******************************************************************************/
#define BCM53600_A0_DSCPECN2TCDPm 0x00000000

#define BCM53600_A0_DSCPECN2TCDPm_MIN 0
#define BCM53600_A0_DSCPECN2TCDPm_MAX 255
#define BCM53600_A0_DSCPECN2TCDPm_CMAX(u) 255
#define BCM53600_A0_DSCPECN2TCDPm_SIZE 1

/*
 * This structure should be used to declare and program DSCPECN2TCDP.
 *
 */
typedef union BCM53600_A0_DSCPECN2TCDPm_s {
	uint32_t v[1];
	uint32_t dscpecn2tcdp[1];
	uint32_t _dscpecn2tcdp;
} BCM53600_A0_DSCPECN2TCDPm_t;

#define BCM53600_A0_DSCPECN2TCDPm_CLR(r) (r).dscpecn2tcdp[0] = 0
#define BCM53600_A0_DSCPECN2TCDPm_SET(r,d) (r).dscpecn2tcdp[0] = d
#define BCM53600_A0_DSCPECN2TCDPm_GET(r) (r).dscpecn2tcdp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DSCPECN2TCDPm_TCf_GET(r) (((r).dscpecn2tcdp[0]) & 0xf)
#define BCM53600_A0_DSCPECN2TCDPm_TCf_SET(r,f) (r).dscpecn2tcdp[0]=(((r).dscpecn2tcdp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_DSCPECN2TCDPm_DPf_GET(r) ((((r).dscpecn2tcdp[0]) >> 4) & 0x3)
#define BCM53600_A0_DSCPECN2TCDPm_DPf_SET(r,f) (r).dscpecn2tcdp[0]=(((r).dscpecn2tcdp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))

/*
 * These macros can be used to access DSCPECN2TCDP.
 *
 */
#define BCM53600_A0_READ_DSCPECN2TCDPm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_DSCPECN2TCDPm,i,(m),1)
#define BCM53600_A0_WRITE_DSCPECN2TCDPm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_DSCPECN2TCDPm,i,&(m),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCPECN2TCDPm BCM53600_A0_DSCPECN2TCDPm
#define DSCPECN2TCDPm_MIN BCM53600_A0_DSCPECN2TCDPm_MIN
#define DSCPECN2TCDPm_MAX BCM53600_A0_DSCPECN2TCDPm_MAX
#define DSCPECN2TCDPm_CMAX(u) BCM53600_A0_DSCPECN2TCDPm_CMAX(u)
#define DSCPECN2TCDPm_SIZE BCM53600_A0_DSCPECN2TCDPm_SIZE
typedef BCM53600_A0_DSCPECN2TCDPm_t DSCPECN2TCDPm_t;
#define DSCPECN2TCDPm_CLR BCM53600_A0_DSCPECN2TCDPm_CLR
#define DSCPECN2TCDPm_SET BCM53600_A0_DSCPECN2TCDPm_SET
#define DSCPECN2TCDPm_GET BCM53600_A0_DSCPECN2TCDPm_GET
#define DSCPECN2TCDPm_TCf_GET BCM53600_A0_DSCPECN2TCDPm_TCf_GET
#define DSCPECN2TCDPm_TCf_SET BCM53600_A0_DSCPECN2TCDPm_TCf_SET
#define DSCPECN2TCDPm_DPf_GET BCM53600_A0_DSCPECN2TCDPm_DPf_GET
#define DSCPECN2TCDPm_DPf_SET BCM53600_A0_DSCPECN2TCDPm_DPf_SET
#define READ_DSCPECN2TCDPm BCM53600_A0_READ_DSCPECN2TCDPm
#define WRITE_DSCPECN2TCDPm BCM53600_A0_WRITE_DSCPECN2TCDPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DSCPECN2TCDPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Port Duplex status SummaryRegister
 * SIZE:     32
 * FIELDS:
 *     DUP_STS          Duplex State.29 bit field indicating the half/full duplex state for each 10/100BASE-T port and the IMP port and two Giga port G0, G1(bits 0-23 = 10/ 100BASE-T ports, bit 24 = MII Port, bit 25 = Giga port go, bit 26 = Giga port G1, bit 27 = Giga port G2, bit 28 = Giga port G3).0 = Half Duplex1 = Full DuplexNote that duplex state for the IMP port can only be reported for an external transceiver by:(a) using the FDX# strap option to pass the transceiver's default state to the Thunderbolt:(b) using the CPU to read the half/full duplex state via the MDC/MDIO interface and write this back to the MII Port Status Override register.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_DUPSTSr 0x00000230

#define BCM53600_A0_DUPSTSr_SIZE 4

/*
 * This structure should be used to declare and program DUPSTS.
 *
 */
typedef union BCM53600_A0_DUPSTSr_s {
	uint32_t v[1];
	uint32_t dupsts[1];
	uint32_t _dupsts;
} BCM53600_A0_DUPSTSr_t;

#define BCM53600_A0_DUPSTSr_CLR(r) (r).dupsts[0] = 0
#define BCM53600_A0_DUPSTSr_SET(r,d) (r).dupsts[0] = d
#define BCM53600_A0_DUPSTSr_GET(r) (r).dupsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_DUPSTSr_DUP_STSf_GET(r) (((r).dupsts[0]) & 0x1fffffff)
#define BCM53600_A0_DUPSTSr_DUP_STSf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_DUPSTSr_RESERVED_1f_GET(r) ((((r).dupsts[0]) >> 29) & 0x7)
#define BCM53600_A0_DUPSTSr_RESERVED_1f_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access DUPSTS.
 *
 */
#define BCM53600_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_DUPSTSr,(r._dupsts),4)
#define BCM53600_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_DUPSTSr,&(r._dupsts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM53600_A0_DUPSTSr
#define DUPSTSr_SIZE BCM53600_A0_DUPSTSr_SIZE
typedef BCM53600_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM53600_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM53600_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM53600_A0_DUPSTSr_GET
#define DUPSTSr_DUP_STSf_GET BCM53600_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM53600_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVED_1f_GET BCM53600_A0_DUPSTSr_RESERVED_1f_GET
#define DUPSTSr_RESERVED_1f_SET BCM53600_A0_DUPSTSr_RESERVED_1f_SET
#define READ_DUPSTSr BCM53600_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM53600_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_DUPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  EAP_PORT_CTL
 * BLOCKS:   SYS
 * DESC:     EAP Port Control Registers
 * SIZE:     64
 * FIELDS:
 *     EAP_PORT_BLK     A 58-bit field to indicate the EAP Port State for each portTwo bit for each port. Bits 57:0=ports[port28-port0] respectatively.00 : Local port is not blocked.(default)01 : Local port is blocked in ingress side. Only 802.1x packet and specialframe will be received.10 : Local port is blocked in both ingress and egress side. Only 802.1x packetand special frame will be received.11 : Reserved.
 *     RESERVED_0       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_EAP_PORT_CTLr 0x00004010

#define BCM53600_A0_EAP_PORT_CTLr_SIZE 8

/*
 * This structure should be used to declare and program EAP_PORT_CTL.
 *
 */
typedef union BCM53600_A0_EAP_PORT_CTLr_s {
	uint32_t v[2];
	uint32_t eap_port_ctl[2];
	uint32_t _eap_port_ctl;
} BCM53600_A0_EAP_PORT_CTLr_t;

#define BCM53600_A0_EAP_PORT_CTLr_CLR(r) CDK_MEMSET(&((r)._eap_port_ctl), 0, sizeof(BCM53600_A0_EAP_PORT_CTLr_t))
#define BCM53600_A0_EAP_PORT_CTLr_SET(r,i,d) (r).eap_port_ctl[i] = d
#define BCM53600_A0_EAP_PORT_CTLr_GET(r,i) (r).eap_port_ctl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EAP_PORT_CTLr_EAP_PORT_BLKf_GET(r,a) cdk_field_get((r).eap_port_ctl,0,57,a)
#define BCM53600_A0_EAP_PORT_CTLr_EAP_PORT_BLKf_SET(r,a) cdk_field_set((r).eap_port_ctl,0,57,a)
#define BCM53600_A0_EAP_PORT_CTLr_RESERVED_0f_GET(r) ((((r).eap_port_ctl[1]) >> 26) & 0x3f)
#define BCM53600_A0_EAP_PORT_CTLr_RESERVED_0f_SET(r,f) (r).eap_port_ctl[1]=(((r).eap_port_ctl[1] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access EAP_PORT_CTL.
 *
 */
#define BCM53600_A0_READ_EAP_PORT_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_EAP_PORT_CTLr,(r._eap_port_ctl),8)
#define BCM53600_A0_WRITE_EAP_PORT_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_EAP_PORT_CTLr,&(r._eap_port_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_PORT_CTLr BCM53600_A0_EAP_PORT_CTLr
#define EAP_PORT_CTLr_SIZE BCM53600_A0_EAP_PORT_CTLr_SIZE
typedef BCM53600_A0_EAP_PORT_CTLr_t EAP_PORT_CTLr_t;
#define EAP_PORT_CTLr_CLR BCM53600_A0_EAP_PORT_CTLr_CLR
#define EAP_PORT_CTLr_SET BCM53600_A0_EAP_PORT_CTLr_SET
#define EAP_PORT_CTLr_GET BCM53600_A0_EAP_PORT_CTLr_GET
#define EAP_PORT_CTLr_EAP_PORT_BLKf_GET BCM53600_A0_EAP_PORT_CTLr_EAP_PORT_BLKf_GET
#define EAP_PORT_CTLr_EAP_PORT_BLKf_SET BCM53600_A0_EAP_PORT_CTLr_EAP_PORT_BLKf_SET
#define EAP_PORT_CTLr_RESERVED_0f_GET BCM53600_A0_EAP_PORT_CTLr_RESERVED_0f_GET
#define EAP_PORT_CTLr_RESERVED_0f_SET BCM53600_A0_EAP_PORT_CTLr_RESERVED_0f_SET
#define READ_EAP_PORT_CTLr BCM53600_A0_READ_EAP_PORT_CTLr
#define WRITE_EAP_PORT_CTLr BCM53600_A0_WRITE_EAP_PORT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EAP_PORT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     32
 * FIELDS:
 *     OUT_MIR_MSK      Egress Mirror Port Mask29 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIR_CAP_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIR_CAP_PORT.Bits 0-23 = FE PortsBit 24 = IMPBit 25 = Giga Port G0Bit 26 = Giga Port G1Bit 27 = Giga Port G2Bit 28 = Giga Port G3
 *     EGMIRCTL_RSRV0   Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_EGMIRCTLr 0x00000328

#define BCM53600_A0_EGMIRCTLr_SIZE 4

/*
 * This structure should be used to declare and program EGMIRCTL.
 *
 */
typedef union BCM53600_A0_EGMIRCTLr_s {
	uint32_t v[1];
	uint32_t egmirctl[1];
	uint32_t _egmirctl;
} BCM53600_A0_EGMIRCTLr_t;

#define BCM53600_A0_EGMIRCTLr_CLR(r) (r).egmirctl[0] = 0
#define BCM53600_A0_EGMIRCTLr_SET(r,d) (r).egmirctl[0] = d
#define BCM53600_A0_EGMIRCTLr_GET(r) (r).egmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) (((r).egmirctl[0]) & 0x1fffffff)
#define BCM53600_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_GET(r) ((((r).egmirctl[0]) >> 29) & 0x7)
#define BCM53600_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access EGMIRCTL.
 *
 */
#define BCM53600_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_EGMIRCTLr,(r._egmirctl),4)
#define BCM53600_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_EGMIRCTLr,&(r._egmirctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM53600_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM53600_A0_EGMIRCTLr_SIZE
typedef BCM53600_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM53600_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM53600_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM53600_A0_EGMIRCTLr_GET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM53600_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM53600_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_EGMIRCTL_RSRV0f_GET BCM53600_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_GET
#define EGMIRCTLr_EGMIRCTL_RSRV0f_SET BCM53600_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_SET
#define READ_EGMIRCTLr BCM53600_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM53600_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  EGRESS_SFLOW
 * BLOCKS:   SYS
 * DESC:     Egress SFLOW Control Register
 * SIZE:     16
 * FIELDS:
 *     EGRESS_PORT      Egress Sflow Port.
 *     RESERVED_0       Reserved
 *     EN_EGRESS_SFLOW  Enable Egress Sflow.1'b1 : Enable this feature.1'b0 : Disable this feature.
 *     RESERVED_1       Reserved
 *     EGRESS_CFG       Egress Sflow SettingA exponential value indicating the percentage of traffic that will be copied toCPU due to egress extended Sflow.percentage = 1/(2^(value+1)).
 *
 ******************************************************************************/
#define BCM53600_A0_EGRESS_SFLOWr 0x00000370

#define BCM53600_A0_EGRESS_SFLOWr_SIZE 2

/*
 * This structure should be used to declare and program EGRESS_SFLOW.
 *
 */
typedef union BCM53600_A0_EGRESS_SFLOWr_s {
	uint32_t v[1];
	uint32_t egress_sflow[1];
	uint32_t _egress_sflow;
} BCM53600_A0_EGRESS_SFLOWr_t;

#define BCM53600_A0_EGRESS_SFLOWr_CLR(r) (r).egress_sflow[0] = 0
#define BCM53600_A0_EGRESS_SFLOWr_SET(r,d) (r).egress_sflow[0] = d
#define BCM53600_A0_EGRESS_SFLOWr_GET(r) (r).egress_sflow[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EGRESS_SFLOWr_EGRESS_PORTf_GET(r) (((r).egress_sflow[0]) & 0x3f)
#define BCM53600_A0_EGRESS_SFLOWr_EGRESS_PORTf_SET(r,f) (r).egress_sflow[0]=(((r).egress_sflow[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_EGRESS_SFLOWr_RESERVED_0f_GET(r) ((((r).egress_sflow[0]) >> 6) & 0x1)
#define BCM53600_A0_EGRESS_SFLOWr_RESERVED_0f_SET(r,f) (r).egress_sflow[0]=(((r).egress_sflow[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_EGRESS_SFLOWr_EN_EGRESS_SFLOWf_GET(r) ((((r).egress_sflow[0]) >> 7) & 0x1)
#define BCM53600_A0_EGRESS_SFLOWr_EN_EGRESS_SFLOWf_SET(r,f) (r).egress_sflow[0]=(((r).egress_sflow[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_EGRESS_SFLOWr_RESERVED_1f_GET(r) ((((r).egress_sflow[0]) >> 8) & 0xf)
#define BCM53600_A0_EGRESS_SFLOWr_RESERVED_1f_SET(r,f) (r).egress_sflow[0]=(((r).egress_sflow[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53600_A0_EGRESS_SFLOWr_EGRESS_CFGf_GET(r) ((((r).egress_sflow[0]) >> 12) & 0xf)
#define BCM53600_A0_EGRESS_SFLOWr_EGRESS_CFGf_SET(r,f) (r).egress_sflow[0]=(((r).egress_sflow[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access EGRESS_SFLOW.
 *
 */
#define BCM53600_A0_READ_EGRESS_SFLOWr(u,r) cdk_robo_reg_read(u,BCM53600_A0_EGRESS_SFLOWr,(r._egress_sflow),2)
#define BCM53600_A0_WRITE_EGRESS_SFLOWr(u,r) cdk_robo_reg_write(u,BCM53600_A0_EGRESS_SFLOWr,&(r._egress_sflow),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_SFLOWr BCM53600_A0_EGRESS_SFLOWr
#define EGRESS_SFLOWr_SIZE BCM53600_A0_EGRESS_SFLOWr_SIZE
typedef BCM53600_A0_EGRESS_SFLOWr_t EGRESS_SFLOWr_t;
#define EGRESS_SFLOWr_CLR BCM53600_A0_EGRESS_SFLOWr_CLR
#define EGRESS_SFLOWr_SET BCM53600_A0_EGRESS_SFLOWr_SET
#define EGRESS_SFLOWr_GET BCM53600_A0_EGRESS_SFLOWr_GET
#define EGRESS_SFLOWr_EGRESS_PORTf_GET BCM53600_A0_EGRESS_SFLOWr_EGRESS_PORTf_GET
#define EGRESS_SFLOWr_EGRESS_PORTf_SET BCM53600_A0_EGRESS_SFLOWr_EGRESS_PORTf_SET
#define EGRESS_SFLOWr_RESERVED_0f_GET BCM53600_A0_EGRESS_SFLOWr_RESERVED_0f_GET
#define EGRESS_SFLOWr_RESERVED_0f_SET BCM53600_A0_EGRESS_SFLOWr_RESERVED_0f_SET
#define EGRESS_SFLOWr_EN_EGRESS_SFLOWf_GET BCM53600_A0_EGRESS_SFLOWr_EN_EGRESS_SFLOWf_GET
#define EGRESS_SFLOWr_EN_EGRESS_SFLOWf_SET BCM53600_A0_EGRESS_SFLOWr_EN_EGRESS_SFLOWf_SET
#define EGRESS_SFLOWr_RESERVED_1f_GET BCM53600_A0_EGRESS_SFLOWr_RESERVED_1f_GET
#define EGRESS_SFLOWr_RESERVED_1f_SET BCM53600_A0_EGRESS_SFLOWr_RESERVED_1f_SET
#define EGRESS_SFLOWr_EGRESS_CFGf_GET BCM53600_A0_EGRESS_SFLOWr_EGRESS_CFGf_GET
#define EGRESS_SFLOWr_EGRESS_CFGf_SET BCM53600_A0_EGRESS_SFLOWr_EGRESS_CFGf_SET
#define READ_EGRESS_SFLOWr BCM53600_A0_READ_EGRESS_SFLOWr
#define WRITE_EGRESS_SFLOWr BCM53600_A0_WRITE_EGRESS_SFLOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EGRESS_SFLOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  ERC_PORT
 * BLOCKS:   SYS
 * DESC:     ERC PORT Table
 * SIZE:     444
 * FIELDS:
 *     BKT_Q0_REF_CNT_MIN Bucket Q0 egress rate control min refresh count
 *     BKT_Q0_REF_CNT_MAX Bucket Q0 egress rate control max refresh count
 *     BKT_Q0_BKT_SIZE  Bucket Q0 egress rate control bucket size
 *     BKT_Q0_ERC_Q_EN  Bucket Q0 egress rate control q enable
 *     BKT_Q1_REF_CNT_MIN Bucket Q1 egress rate control min refresh count
 *     BKT_Q1_REF_CNT_MAX Bucket Q1 egress rate control max refresh count
 *     BKT_Q1_BKT_SIZE  Bucket Q1 egress rate control bucket size
 *     BKT_Q1_ERC_Q_EN  Bucket Q1 egress rate control q enable
 *     BKT_Q2_REF_CNT_MIN Bucket Q2 egress rate control min refresh count
 *     BKT_Q2_REF_CNT_MAX Bucket Q2 egress rate control max refresh count
 *     BKT_Q2_BKT_SIZE  Bucket Q2 egress rate control bucket size
 *     BKT_Q2_ERC_Q_EN  Bucket Q2 egress rate control q enable
 *     BKT_Q3_REF_CNT_MIN Bucket Q3 egress rate control min refresh count
 *     BKT_Q3_REF_CNT_MAX Bucket Q3 egress rate control max refresh count
 *     BKT_Q3_BKT_SIZE  Bucket Q3 egress rate control bucket size
 *     BKT_Q3_ERC_Q_EN  Bucket Q3 egress rate control q enable
 *     BKT_Q4_REF_CNT_MIN Bucket Q4 egress rate control min refresh count
 *     BKT_Q4_REF_CNT_MAX Bucket Q4 egress rate control max refresh count
 *     BKT_Q4_BKT_SIZE  Bucket Q4 egress rate control bucket size
 *     BKT_Q4_ERC_Q_EN  Bucket Q4 egress rate control q enable
 *     BKT_Q5_REF_CNT_MIN Bucket Q5 egress rate control min refresh count
 *     BKT_Q5_REF_CNT_MAX Bucket Q5 egress rate control max refresh count
 *     BKT_Q5_BKT_SIZE  Bucket Q5 egress rate control bucket size
 *     BKT_Q5_ERC_Q_EN  Bucket Q5 egress rate control q enable
 *     BKT_Q6_REF_CNT_MIN Bucket Q6 egress rate control min refresh count
 *     BKT_Q6_REF_CNT_MAX Bucket Q6 egress rate control max refresh count
 *     BKT_Q6_BKT_SIZE  Bucket Q6 egress rate control bucket size
 *     BKT_Q6_ERC_Q_EN  Bucket Q6 egress rate control q enable
 *     BKT_Q7_REF_CNT_MIN Bucket Q7 egress rate control min refresh count
 *     BKT_Q7_REF_CNT_MAX Bucket Q7 egress rate control max refresh count
 *     BKT_Q7_BKT_SIZE  Bucket Q7 egress rate control bucket size
 *     BKT_Q7_ERC_Q_EN  Bucket Q7 egress rate control q enable
 *     BKT_T_REF_CNT_MAX Bulket for total egress rate control refresh count
 *     BKT_T_BKT_SIZE   Bucket for total egress rate control bucket size
 *     BKT_T_TYPE       Bucket for total egress rate control type
 *     BKT_T_ERC_T_EN   Bucket for total egress rate control enable
 *     BKT_BAC          Burst Accumulation Control
 *
 ******************************************************************************/
#define BCM53600_A0_ERC_PORTm 0x00000000

#define BCM53600_A0_ERC_PORTm_MIN 0
#define BCM53600_A0_ERC_PORTm_MAX 28
#define BCM53600_A0_ERC_PORTm_CMAX(u) 28
#define BCM53600_A0_ERC_PORTm_SIZE 56

/*
 * This structure should be used to declare and program ERC_PORT.
 *
 */
typedef union BCM53600_A0_ERC_PORTm_s {
	uint32_t v[14];
	uint32_t erc_port[14];
	uint32_t _erc_port;
} BCM53600_A0_ERC_PORTm_t;

#define BCM53600_A0_ERC_PORTm_CLR(r) CDK_MEMSET(&((r)._erc_port), 0, sizeof(BCM53600_A0_ERC_PORTm_t))
#define BCM53600_A0_ERC_PORTm_SET(r,i,d) (r).erc_port[i] = d
#define BCM53600_A0_ERC_PORTm_GET(r,i) (r).erc_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MINf_GET(r) (((r).erc_port[0]) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MINf_SET(r,f) (r).erc_port[0]=(((r).erc_port[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MAXf_GET(r) cdk_field32_get((r).erc_port,17,33)
#define BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MAXf_SET(r,f) cdk_field32_set((r).erc_port,17,33,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q0_BKT_SIZEf_GET(r) ((((r).erc_port[1]) >> 2) & 0xffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q0_BKT_SIZEf_SET(r,f) (r).erc_port[1]=(((r).erc_port[1] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53600_A0_ERC_PORTm_BKT_Q0_ERC_Q_ENf_GET(r) ((((r).erc_port[1]) >> 18) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q0_ERC_Q_ENf_SET(r,f) (r).erc_port[1]=(((r).erc_port[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MINf_GET(r) cdk_field32_get((r).erc_port,51,67)
#define BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MINf_SET(r,f) cdk_field32_set((r).erc_port,51,67,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MAXf_GET(r) ((((r).erc_port[2]) >> 4) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MAXf_SET(r,f) (r).erc_port[2]=(((r).erc_port[2] & ~((uint32_t)0x1ffff << 4)) | ((((uint32_t)f) & 0x1ffff) << 4))
#define BCM53600_A0_ERC_PORTm_BKT_Q1_BKT_SIZEf_GET(r) cdk_field32_get((r).erc_port,85,100)
#define BCM53600_A0_ERC_PORTm_BKT_Q1_BKT_SIZEf_SET(r,f) cdk_field32_set((r).erc_port,85,100,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q1_ERC_Q_ENf_GET(r) ((((r).erc_port[3]) >> 5) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q1_ERC_Q_ENf_SET(r,f) (r).erc_port[3]=(((r).erc_port[3] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MINf_GET(r) ((((r).erc_port[3]) >> 6) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MINf_SET(r,f) (r).erc_port[3]=(((r).erc_port[3] & ~((uint32_t)0x1ffff << 6)) | ((((uint32_t)f) & 0x1ffff) << 6))
#define BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MAXf_GET(r) cdk_field32_get((r).erc_port,119,135)
#define BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MAXf_SET(r,f) cdk_field32_set((r).erc_port,119,135,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q2_BKT_SIZEf_GET(r) ((((r).erc_port[4]) >> 8) & 0xffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q2_BKT_SIZEf_SET(r,f) (r).erc_port[4]=(((r).erc_port[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53600_A0_ERC_PORTm_BKT_Q2_ERC_Q_ENf_GET(r) ((((r).erc_port[4]) >> 24) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q2_ERC_Q_ENf_SET(r,f) (r).erc_port[4]=(((r).erc_port[4] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MINf_GET(r) cdk_field32_get((r).erc_port,153,169)
#define BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MINf_SET(r,f) cdk_field32_set((r).erc_port,153,169,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MAXf_GET(r) ((((r).erc_port[5]) >> 10) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MAXf_SET(r,f) (r).erc_port[5]=(((r).erc_port[5] & ~((uint32_t)0x1ffff << 10)) | ((((uint32_t)f) & 0x1ffff) << 10))
#define BCM53600_A0_ERC_PORTm_BKT_Q3_BKT_SIZEf_GET(r) cdk_field32_get((r).erc_port,187,202)
#define BCM53600_A0_ERC_PORTm_BKT_Q3_BKT_SIZEf_SET(r,f) cdk_field32_set((r).erc_port,187,202,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q3_ERC_Q_ENf_GET(r) ((((r).erc_port[6]) >> 11) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q3_ERC_Q_ENf_SET(r,f) (r).erc_port[6]=(((r).erc_port[6] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MINf_GET(r) ((((r).erc_port[6]) >> 12) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MINf_SET(r,f) (r).erc_port[6]=(((r).erc_port[6] & ~((uint32_t)0x1ffff << 12)) | ((((uint32_t)f) & 0x1ffff) << 12))
#define BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MAXf_GET(r) cdk_field32_get((r).erc_port,221,237)
#define BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MAXf_SET(r,f) cdk_field32_set((r).erc_port,221,237,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q4_BKT_SIZEf_GET(r) ((((r).erc_port[7]) >> 14) & 0xffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q4_BKT_SIZEf_SET(r,f) (r).erc_port[7]=(((r).erc_port[7] & ~((uint32_t)0xffff << 14)) | ((((uint32_t)f) & 0xffff) << 14))
#define BCM53600_A0_ERC_PORTm_BKT_Q4_ERC_Q_ENf_GET(r) ((((r).erc_port[7]) >> 30) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q4_ERC_Q_ENf_SET(r,f) (r).erc_port[7]=(((r).erc_port[7] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MINf_GET(r) cdk_field32_get((r).erc_port,255,271)
#define BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MINf_SET(r,f) cdk_field32_set((r).erc_port,255,271,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MAXf_GET(r) cdk_field32_get((r).erc_port,272,288)
#define BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MAXf_SET(r,f) cdk_field32_set((r).erc_port,272,288,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q5_BKT_SIZEf_GET(r) ((((r).erc_port[9]) >> 1) & 0xffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q5_BKT_SIZEf_SET(r,f) (r).erc_port[9]=(((r).erc_port[9] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53600_A0_ERC_PORTm_BKT_Q5_ERC_Q_ENf_GET(r) ((((r).erc_port[9]) >> 17) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q5_ERC_Q_ENf_SET(r,f) (r).erc_port[9]=(((r).erc_port[9] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MINf_GET(r) cdk_field32_get((r).erc_port,306,322)
#define BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MINf_SET(r,f) cdk_field32_set((r).erc_port,306,322,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MAXf_GET(r) ((((r).erc_port[10]) >> 3) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MAXf_SET(r,f) (r).erc_port[10]=(((r).erc_port[10] & ~((uint32_t)0x1ffff << 3)) | ((((uint32_t)f) & 0x1ffff) << 3))
#define BCM53600_A0_ERC_PORTm_BKT_Q6_BKT_SIZEf_GET(r) cdk_field32_get((r).erc_port,340,355)
#define BCM53600_A0_ERC_PORTm_BKT_Q6_BKT_SIZEf_SET(r,f) cdk_field32_set((r).erc_port,340,355,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q6_ERC_Q_ENf_GET(r) ((((r).erc_port[11]) >> 4) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q6_ERC_Q_ENf_SET(r,f) (r).erc_port[11]=(((r).erc_port[11] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MINf_GET(r) ((((r).erc_port[11]) >> 5) & 0x1ffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MINf_SET(r,f) (r).erc_port[11]=(((r).erc_port[11] & ~((uint32_t)0x1ffff << 5)) | ((((uint32_t)f) & 0x1ffff) << 5))
#define BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MAXf_GET(r) cdk_field32_get((r).erc_port,374,390)
#define BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MAXf_SET(r,f) cdk_field32_set((r).erc_port,374,390,f)
#define BCM53600_A0_ERC_PORTm_BKT_Q7_BKT_SIZEf_GET(r) ((((r).erc_port[12]) >> 7) & 0xffff)
#define BCM53600_A0_ERC_PORTm_BKT_Q7_BKT_SIZEf_SET(r,f) (r).erc_port[12]=(((r).erc_port[12] & ~((uint32_t)0xffff << 7)) | ((((uint32_t)f) & 0xffff) << 7))
#define BCM53600_A0_ERC_PORTm_BKT_Q7_ERC_Q_ENf_GET(r) ((((r).erc_port[12]) >> 23) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_Q7_ERC_Q_ENf_SET(r,f) (r).erc_port[12]=(((r).erc_port[12] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53600_A0_ERC_PORTm_BKT_T_REF_CNT_MAXf_GET(r) cdk_field32_get((r).erc_port,408,424)
#define BCM53600_A0_ERC_PORTm_BKT_T_REF_CNT_MAXf_SET(r,f) cdk_field32_set((r).erc_port,408,424,f)
#define BCM53600_A0_ERC_PORTm_BKT_T_BKT_SIZEf_GET(r) ((((r).erc_port[13]) >> 9) & 0xffff)
#define BCM53600_A0_ERC_PORTm_BKT_T_BKT_SIZEf_SET(r,f) (r).erc_port[13]=(((r).erc_port[13] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM53600_A0_ERC_PORTm_BKT_T_TYPEf_GET(r) ((((r).erc_port[13]) >> 25) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_T_TYPEf_SET(r,f) (r).erc_port[13]=(((r).erc_port[13] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53600_A0_ERC_PORTm_BKT_T_ERC_T_ENf_GET(r) ((((r).erc_port[13]) >> 26) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_T_ERC_T_ENf_SET(r,f) (r).erc_port[13]=(((r).erc_port[13] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53600_A0_ERC_PORTm_BKT_BACf_GET(r) ((((r).erc_port[13]) >> 27) & 0x1)
#define BCM53600_A0_ERC_PORTm_BKT_BACf_SET(r,f) (r).erc_port[13]=(((r).erc_port[13] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access ERC_PORT.
 *
 */
#define BCM53600_A0_READ_ERC_PORTm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_ERC_PORTm,i,(m),56)
#define BCM53600_A0_WRITE_ERC_PORTm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_ERC_PORTm,i,&(m),56)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ERC_PORTm BCM53600_A0_ERC_PORTm
#define ERC_PORTm_MIN BCM53600_A0_ERC_PORTm_MIN
#define ERC_PORTm_MAX BCM53600_A0_ERC_PORTm_MAX
#define ERC_PORTm_CMAX(u) BCM53600_A0_ERC_PORTm_CMAX(u)
#define ERC_PORTm_SIZE BCM53600_A0_ERC_PORTm_SIZE
typedef BCM53600_A0_ERC_PORTm_t ERC_PORTm_t;
#define ERC_PORTm_CLR BCM53600_A0_ERC_PORTm_CLR
#define ERC_PORTm_SET BCM53600_A0_ERC_PORTm_SET
#define ERC_PORTm_GET BCM53600_A0_ERC_PORTm_GET
#define ERC_PORTm_BKT_Q0_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q0_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q0_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q0_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q0_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q0_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q0_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q0_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q0_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q0_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q0_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q0_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q0_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q1_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q1_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q1_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q1_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q1_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q1_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q1_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q1_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q1_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q1_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q1_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q1_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q1_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q2_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q2_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q2_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q2_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q2_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q2_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q2_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q2_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q2_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q2_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q2_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q2_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q2_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q3_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q3_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q3_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q3_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q3_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q3_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q3_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q3_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q3_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q3_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q3_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q3_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q3_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q4_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q4_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q4_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q4_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q4_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q4_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q4_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q4_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q4_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q4_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q4_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q4_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q4_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q5_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q5_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q5_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q5_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q5_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q5_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q5_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q5_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q5_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q5_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q5_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q5_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q5_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q6_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q6_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q6_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q6_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q6_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q6_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q6_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q6_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q6_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q6_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q6_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q6_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q6_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_Q7_REF_CNT_MINf_GET BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MINf_GET
#define ERC_PORTm_BKT_Q7_REF_CNT_MINf_SET BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MINf_SET
#define ERC_PORTm_BKT_Q7_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_Q7_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_Q7_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_Q7_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_Q7_BKT_SIZEf_GET
#define ERC_PORTm_BKT_Q7_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_Q7_BKT_SIZEf_SET
#define ERC_PORTm_BKT_Q7_ERC_Q_ENf_GET BCM53600_A0_ERC_PORTm_BKT_Q7_ERC_Q_ENf_GET
#define ERC_PORTm_BKT_Q7_ERC_Q_ENf_SET BCM53600_A0_ERC_PORTm_BKT_Q7_ERC_Q_ENf_SET
#define ERC_PORTm_BKT_T_REF_CNT_MAXf_GET BCM53600_A0_ERC_PORTm_BKT_T_REF_CNT_MAXf_GET
#define ERC_PORTm_BKT_T_REF_CNT_MAXf_SET BCM53600_A0_ERC_PORTm_BKT_T_REF_CNT_MAXf_SET
#define ERC_PORTm_BKT_T_BKT_SIZEf_GET BCM53600_A0_ERC_PORTm_BKT_T_BKT_SIZEf_GET
#define ERC_PORTm_BKT_T_BKT_SIZEf_SET BCM53600_A0_ERC_PORTm_BKT_T_BKT_SIZEf_SET
#define ERC_PORTm_BKT_T_TYPEf_GET BCM53600_A0_ERC_PORTm_BKT_T_TYPEf_GET
#define ERC_PORTm_BKT_T_TYPEf_SET BCM53600_A0_ERC_PORTm_BKT_T_TYPEf_SET
#define ERC_PORTm_BKT_T_ERC_T_ENf_GET BCM53600_A0_ERC_PORTm_BKT_T_ERC_T_ENf_GET
#define ERC_PORTm_BKT_T_ERC_T_ENf_SET BCM53600_A0_ERC_PORTm_BKT_T_ERC_T_ENf_SET
#define ERC_PORTm_BKT_BACf_GET BCM53600_A0_ERC_PORTm_BKT_BACf_GET
#define ERC_PORTm_BKT_BACf_SET BCM53600_A0_ERC_PORTm_BKT_BACf_SET
#define READ_ERC_PORTm BCM53600_A0_READ_ERC_PORTm
#define WRITE_ERC_PORTm BCM53600_A0_WRITE_ERC_PORTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ERC_PORTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  EVM_ACT
 * BLOCKS:   SYS
 * DESC:     EVM Action Table
 * SIZE:     38
 * FIELDS:
 *     NEW_CVID         New CVID
 *     CTAG_ACT         CTAG act
 *     NEW_SVID         New SVID
 *     STAG_ACT         STAG act
 *     NEW_CPCP         NEW_CPCP
 *     CHG_CPCP         CHG_CPCP
 *     NEW_SPCP         NEW_SPCP
 *     CHG_SPCP         CHG_SPCP
 *
 ******************************************************************************/
#define BCM53600_A0_EVM_ACTm 0x00000000

#define BCM53600_A0_EVM_ACTm_MIN 0
#define BCM53600_A0_EVM_ACTm_MAX 2047
#define BCM53600_A0_EVM_ACTm_CMAX(u) 2047
#define BCM53600_A0_EVM_ACTm_SIZE 5

/*
 * This structure should be used to declare and program EVM_ACT.
 *
 */
typedef union BCM53600_A0_EVM_ACTm_s {
	uint32_t v[2];
	uint32_t evm_act[2];
	uint32_t _evm_act;
} BCM53600_A0_EVM_ACTm_t;

#define BCM53600_A0_EVM_ACTm_CLR(r) CDK_MEMSET(&((r)._evm_act), 0, sizeof(BCM53600_A0_EVM_ACTm_t))
#define BCM53600_A0_EVM_ACTm_SET(r,i,d) (r).evm_act[i] = d
#define BCM53600_A0_EVM_ACTm_GET(r,i) (r).evm_act[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EVM_ACTm_NEW_CVIDf_GET(r) (((r).evm_act[0]) & 0xfff)
#define BCM53600_A0_EVM_ACTm_NEW_CVIDf_SET(r,f) (r).evm_act[0]=(((r).evm_act[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_EVM_ACTm_CTAG_ACTf_GET(r) ((((r).evm_act[0]) >> 12) & 0x7)
#define BCM53600_A0_EVM_ACTm_CTAG_ACTf_SET(r,f) (r).evm_act[0]=(((r).evm_act[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53600_A0_EVM_ACTm_NEW_SVIDf_GET(r) ((((r).evm_act[0]) >> 15) & 0xfff)
#define BCM53600_A0_EVM_ACTm_NEW_SVIDf_SET(r,f) (r).evm_act[0]=(((r).evm_act[0] & ~((uint32_t)0xfff << 15)) | ((((uint32_t)f) & 0xfff) << 15))
#define BCM53600_A0_EVM_ACTm_STAG_ACTf_GET(r) ((((r).evm_act[0]) >> 27) & 0x7)
#define BCM53600_A0_EVM_ACTm_STAG_ACTf_SET(r,f) (r).evm_act[0]=(((r).evm_act[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53600_A0_EVM_ACTm_NEW_CPCPf_GET(r) cdk_field32_get((r).evm_act,30,32)
#define BCM53600_A0_EVM_ACTm_NEW_CPCPf_SET(r,f) cdk_field32_set((r).evm_act,30,32,f)
#define BCM53600_A0_EVM_ACTm_CHG_CPCPf_GET(r) ((((r).evm_act[1]) >> 1) & 0x1)
#define BCM53600_A0_EVM_ACTm_CHG_CPCPf_SET(r,f) (r).evm_act[1]=(((r).evm_act[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_EVM_ACTm_NEW_SPCPf_GET(r) ((((r).evm_act[1]) >> 2) & 0x7)
#define BCM53600_A0_EVM_ACTm_NEW_SPCPf_SET(r,f) (r).evm_act[1]=(((r).evm_act[1] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53600_A0_EVM_ACTm_CHG_SPCPf_GET(r) ((((r).evm_act[1]) >> 5) & 0x1)
#define BCM53600_A0_EVM_ACTm_CHG_SPCPf_SET(r,f) (r).evm_act[1]=(((r).evm_act[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access EVM_ACT.
 *
 */
#define BCM53600_A0_READ_EVM_ACTm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_EVM_ACTm,i,(m),5)
#define BCM53600_A0_WRITE_EVM_ACTm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_EVM_ACTm,i,&(m),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVM_ACTm BCM53600_A0_EVM_ACTm
#define EVM_ACTm_MIN BCM53600_A0_EVM_ACTm_MIN
#define EVM_ACTm_MAX BCM53600_A0_EVM_ACTm_MAX
#define EVM_ACTm_CMAX(u) BCM53600_A0_EVM_ACTm_CMAX(u)
#define EVM_ACTm_SIZE BCM53600_A0_EVM_ACTm_SIZE
typedef BCM53600_A0_EVM_ACTm_t EVM_ACTm_t;
#define EVM_ACTm_CLR BCM53600_A0_EVM_ACTm_CLR
#define EVM_ACTm_SET BCM53600_A0_EVM_ACTm_SET
#define EVM_ACTm_GET BCM53600_A0_EVM_ACTm_GET
#define EVM_ACTm_NEW_CVIDf_GET BCM53600_A0_EVM_ACTm_NEW_CVIDf_GET
#define EVM_ACTm_NEW_CVIDf_SET BCM53600_A0_EVM_ACTm_NEW_CVIDf_SET
#define EVM_ACTm_CTAG_ACTf_GET BCM53600_A0_EVM_ACTm_CTAG_ACTf_GET
#define EVM_ACTm_CTAG_ACTf_SET BCM53600_A0_EVM_ACTm_CTAG_ACTf_SET
#define EVM_ACTm_NEW_SVIDf_GET BCM53600_A0_EVM_ACTm_NEW_SVIDf_GET
#define EVM_ACTm_NEW_SVIDf_SET BCM53600_A0_EVM_ACTm_NEW_SVIDf_SET
#define EVM_ACTm_STAG_ACTf_GET BCM53600_A0_EVM_ACTm_STAG_ACTf_GET
#define EVM_ACTm_STAG_ACTf_SET BCM53600_A0_EVM_ACTm_STAG_ACTf_SET
#define EVM_ACTm_NEW_CPCPf_GET BCM53600_A0_EVM_ACTm_NEW_CPCPf_GET
#define EVM_ACTm_NEW_CPCPf_SET BCM53600_A0_EVM_ACTm_NEW_CPCPf_SET
#define EVM_ACTm_CHG_CPCPf_GET BCM53600_A0_EVM_ACTm_CHG_CPCPf_GET
#define EVM_ACTm_CHG_CPCPf_SET BCM53600_A0_EVM_ACTm_CHG_CPCPf_SET
#define EVM_ACTm_NEW_SPCPf_GET BCM53600_A0_EVM_ACTm_NEW_SPCPf_GET
#define EVM_ACTm_NEW_SPCPf_SET BCM53600_A0_EVM_ACTm_NEW_SPCPf_SET
#define EVM_ACTm_CHG_SPCPf_GET BCM53600_A0_EVM_ACTm_CHG_SPCPf_GET
#define EVM_ACTm_CHG_SPCPf_SET BCM53600_A0_EVM_ACTm_CHG_SPCPf_SET
#define READ_EVM_ACTm BCM53600_A0_READ_EVM_ACTm
#define WRITE_EVM_ACTm BCM53600_A0_WRITE_EVM_ACTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EVM_ACTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  EVM_KEY_DATA
 * BLOCKS:   SYS
 * DESC:     EVM Table
 * SIZE:     64
 * FIELDS:
 *     EGRESS_VPORT_ID  Egress VPORT id
 *     EGRESS_PORT_ID   Egress port id
 *     FLOW_ID          Flow id
 *     INGRESS_VPORT_ID Ingress VPORT id
 *     INGRESS_PORT_ID  Ingress port id
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_EVM_KEY_DATAm 0x00000000

#define BCM53600_A0_EVM_KEY_DATAm_MIN 0
#define BCM53600_A0_EVM_KEY_DATAm_MAX 2047
#define BCM53600_A0_EVM_KEY_DATAm_CMAX(u) 2047
#define BCM53600_A0_EVM_KEY_DATAm_SIZE 8

/*
 * This structure should be used to declare and program EVM_KEY_DATA.
 *
 */
typedef union BCM53600_A0_EVM_KEY_DATAm_s {
	uint32_t v[2];
	uint32_t evm_key_data[2];
	uint32_t _evm_key_data;
} BCM53600_A0_EVM_KEY_DATAm_t;

#define BCM53600_A0_EVM_KEY_DATAm_CLR(r) CDK_MEMSET(&((r)._evm_key_data), 0, sizeof(BCM53600_A0_EVM_KEY_DATAm_t))
#define BCM53600_A0_EVM_KEY_DATAm_SET(r,i,d) (r).evm_key_data[i] = d
#define BCM53600_A0_EVM_KEY_DATAm_GET(r,i) (r).evm_key_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EVM_KEY_DATAm_EGRESS_VPORT_IDf_GET(r) (((r).evm_key_data[0]) & 0xf)
#define BCM53600_A0_EVM_KEY_DATAm_EGRESS_VPORT_IDf_SET(r,f) (r).evm_key_data[0]=(((r).evm_key_data[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_EVM_KEY_DATAm_EGRESS_PORT_IDf_GET(r) ((((r).evm_key_data[0]) >> 4) & 0x3f)
#define BCM53600_A0_EVM_KEY_DATAm_EGRESS_PORT_IDf_SET(r,f) (r).evm_key_data[0]=(((r).evm_key_data[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53600_A0_EVM_KEY_DATAm_FLOW_IDf_GET(r) ((((r).evm_key_data[0]) >> 10) & 0xfff)
#define BCM53600_A0_EVM_KEY_DATAm_FLOW_IDf_SET(r,f) (r).evm_key_data[0]=(((r).evm_key_data[0] & ~((uint32_t)0xfff << 10)) | ((((uint32_t)f) & 0xfff) << 10))
#define BCM53600_A0_EVM_KEY_DATAm_INGRESS_VPORT_IDf_GET(r) ((((r).evm_key_data[0]) >> 22) & 0xf)
#define BCM53600_A0_EVM_KEY_DATAm_INGRESS_VPORT_IDf_SET(r,f) (r).evm_key_data[0]=(((r).evm_key_data[0] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define BCM53600_A0_EVM_KEY_DATAm_INGRESS_PORT_IDf_GET(r) ((((r).evm_key_data[0]) >> 26) & 0x3f)
#define BCM53600_A0_EVM_KEY_DATAm_INGRESS_PORT_IDf_SET(r,f) (r).evm_key_data[0]=(((r).evm_key_data[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM53600_A0_EVM_KEY_DATAm_RESERVED_1Rf_GET(r) (((r).evm_key_data[1]) & 0x1ffff)
#define BCM53600_A0_EVM_KEY_DATAm_RESERVED_1Rf_SET(r,f) (r).evm_key_data[1]=(((r).evm_key_data[1] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53600_A0_EVM_KEY_DATAm_VALIDf_GET(r) ((((r).evm_key_data[1]) >> 17) & 0x1)
#define BCM53600_A0_EVM_KEY_DATAm_VALIDf_SET(r,f) (r).evm_key_data[1]=(((r).evm_key_data[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_EVM_KEY_DATAm_RESERVED_Rf_GET(r) ((((r).evm_key_data[1]) >> 18) & 0x3fff)
#define BCM53600_A0_EVM_KEY_DATAm_RESERVED_Rf_SET(r,f) (r).evm_key_data[1]=(((r).evm_key_data[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access EVM_KEY_DATA.
 *
 */
#define BCM53600_A0_READ_EVM_KEY_DATAm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_EVM_KEY_DATAm,i,(m),8)
#define BCM53600_A0_WRITE_EVM_KEY_DATAm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_EVM_KEY_DATAm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVM_KEY_DATAm BCM53600_A0_EVM_KEY_DATAm
#define EVM_KEY_DATAm_MIN BCM53600_A0_EVM_KEY_DATAm_MIN
#define EVM_KEY_DATAm_MAX BCM53600_A0_EVM_KEY_DATAm_MAX
#define EVM_KEY_DATAm_CMAX(u) BCM53600_A0_EVM_KEY_DATAm_CMAX(u)
#define EVM_KEY_DATAm_SIZE BCM53600_A0_EVM_KEY_DATAm_SIZE
typedef BCM53600_A0_EVM_KEY_DATAm_t EVM_KEY_DATAm_t;
#define EVM_KEY_DATAm_CLR BCM53600_A0_EVM_KEY_DATAm_CLR
#define EVM_KEY_DATAm_SET BCM53600_A0_EVM_KEY_DATAm_SET
#define EVM_KEY_DATAm_GET BCM53600_A0_EVM_KEY_DATAm_GET
#define EVM_KEY_DATAm_EGRESS_VPORT_IDf_GET BCM53600_A0_EVM_KEY_DATAm_EGRESS_VPORT_IDf_GET
#define EVM_KEY_DATAm_EGRESS_VPORT_IDf_SET BCM53600_A0_EVM_KEY_DATAm_EGRESS_VPORT_IDf_SET
#define EVM_KEY_DATAm_EGRESS_PORT_IDf_GET BCM53600_A0_EVM_KEY_DATAm_EGRESS_PORT_IDf_GET
#define EVM_KEY_DATAm_EGRESS_PORT_IDf_SET BCM53600_A0_EVM_KEY_DATAm_EGRESS_PORT_IDf_SET
#define EVM_KEY_DATAm_FLOW_IDf_GET BCM53600_A0_EVM_KEY_DATAm_FLOW_IDf_GET
#define EVM_KEY_DATAm_FLOW_IDf_SET BCM53600_A0_EVM_KEY_DATAm_FLOW_IDf_SET
#define EVM_KEY_DATAm_INGRESS_VPORT_IDf_GET BCM53600_A0_EVM_KEY_DATAm_INGRESS_VPORT_IDf_GET
#define EVM_KEY_DATAm_INGRESS_VPORT_IDf_SET BCM53600_A0_EVM_KEY_DATAm_INGRESS_VPORT_IDf_SET
#define EVM_KEY_DATAm_INGRESS_PORT_IDf_GET BCM53600_A0_EVM_KEY_DATAm_INGRESS_PORT_IDf_GET
#define EVM_KEY_DATAm_INGRESS_PORT_IDf_SET BCM53600_A0_EVM_KEY_DATAm_INGRESS_PORT_IDf_SET
#define EVM_KEY_DATAm_RESERVED_1Rf_GET BCM53600_A0_EVM_KEY_DATAm_RESERVED_1Rf_GET
#define EVM_KEY_DATAm_RESERVED_1Rf_SET BCM53600_A0_EVM_KEY_DATAm_RESERVED_1Rf_SET
#define EVM_KEY_DATAm_VALIDf_GET BCM53600_A0_EVM_KEY_DATAm_VALIDf_GET
#define EVM_KEY_DATAm_VALIDf_SET BCM53600_A0_EVM_KEY_DATAm_VALIDf_SET
#define EVM_KEY_DATAm_RESERVED_Rf_GET BCM53600_A0_EVM_KEY_DATAm_RESERVED_Rf_GET
#define EVM_KEY_DATAm_RESERVED_Rf_SET BCM53600_A0_EVM_KEY_DATAm_RESERVED_Rf_SET
#define READ_EVM_KEY_DATAm BCM53600_A0_READ_EVM_KEY_DATAm
#define WRITE_EVM_KEY_DATAm BCM53600_A0_WRITE_EVM_KEY_DATAm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EVM_KEY_DATAm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  EVM_KEY_DATA_MASK
 * BLOCKS:   SYS
 * DESC:     EVM_KEY_DATA_MASK Table
 * SIZE:     128
 * FIELDS:
 *     VM_KEY_DATA      VM_KEY_DATA
 *     RESERVED_1R      reserved
 *     VM_KEY_MASK      VM_KEY_MASK
 *     RESERVED_R       reserved
 *
 ******************************************************************************/
#define BCM53600_A0_EVM_KEY_DATA_MASKm 0x00000000

#define BCM53600_A0_EVM_KEY_DATA_MASKm_MIN 0
#define BCM53600_A0_EVM_KEY_DATA_MASKm_MAX 2047
#define BCM53600_A0_EVM_KEY_DATA_MASKm_CMAX(u) 2047
#define BCM53600_A0_EVM_KEY_DATA_MASKm_SIZE 16

/*
 * This structure should be used to declare and program EVM_KEY_DATA_MASK.
 *
 */
typedef union BCM53600_A0_EVM_KEY_DATA_MASKm_s {
	uint32_t v[4];
	uint32_t evm_key_data_mask[4];
	uint32_t _evm_key_data_mask;
} BCM53600_A0_EVM_KEY_DATA_MASKm_t;

#define BCM53600_A0_EVM_KEY_DATA_MASKm_CLR(r) CDK_MEMSET(&((r)._evm_key_data_mask), 0, sizeof(BCM53600_A0_EVM_KEY_DATA_MASKm_t))
#define BCM53600_A0_EVM_KEY_DATA_MASKm_SET(r,i,d) (r).evm_key_data_mask[i] = d
#define BCM53600_A0_EVM_KEY_DATA_MASKm_GET(r,i) (r).evm_key_data_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_DATAf_GET(r,a) cdk_field_get((r).evm_key_data_mask,0,49,a)
#define BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_DATAf_SET(r,a) cdk_field_set((r).evm_key_data_mask,0,49,a)
#define BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_1Rf_GET(r) ((((r).evm_key_data_mask[1]) >> 18) & 0x3fff)
#define BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_1Rf_SET(r,f) (r).evm_key_data_mask[1]=(((r).evm_key_data_mask[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))
#define BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_MASKf_GET(r,a) cdk_field_get((r).evm_key_data_mask,64,113,a)
#define BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_MASKf_SET(r,a) cdk_field_set((r).evm_key_data_mask,64,113,a)
#define BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_Rf_GET(r) ((((r).evm_key_data_mask[3]) >> 18) & 0x3fff)
#define BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_Rf_SET(r,f) (r).evm_key_data_mask[3]=(((r).evm_key_data_mask[3] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access EVM_KEY_DATA_MASK.
 *
 */
#define BCM53600_A0_READ_EVM_KEY_DATA_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_EVM_KEY_DATA_MASKm,i,(m),16)
#define BCM53600_A0_WRITE_EVM_KEY_DATA_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_EVM_KEY_DATA_MASKm,i,&(m),16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVM_KEY_DATA_MASKm BCM53600_A0_EVM_KEY_DATA_MASKm
#define EVM_KEY_DATA_MASKm_MIN BCM53600_A0_EVM_KEY_DATA_MASKm_MIN
#define EVM_KEY_DATA_MASKm_MAX BCM53600_A0_EVM_KEY_DATA_MASKm_MAX
#define EVM_KEY_DATA_MASKm_CMAX(u) BCM53600_A0_EVM_KEY_DATA_MASKm_CMAX(u)
#define EVM_KEY_DATA_MASKm_SIZE BCM53600_A0_EVM_KEY_DATA_MASKm_SIZE
typedef BCM53600_A0_EVM_KEY_DATA_MASKm_t EVM_KEY_DATA_MASKm_t;
#define EVM_KEY_DATA_MASKm_CLR BCM53600_A0_EVM_KEY_DATA_MASKm_CLR
#define EVM_KEY_DATA_MASKm_SET BCM53600_A0_EVM_KEY_DATA_MASKm_SET
#define EVM_KEY_DATA_MASKm_GET BCM53600_A0_EVM_KEY_DATA_MASKm_GET
#define EVM_KEY_DATA_MASKm_VM_KEY_DATAf_GET BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_DATAf_GET
#define EVM_KEY_DATA_MASKm_VM_KEY_DATAf_SET BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_DATAf_SET
#define EVM_KEY_DATA_MASKm_RESERVED_1Rf_GET BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_1Rf_GET
#define EVM_KEY_DATA_MASKm_RESERVED_1Rf_SET BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_1Rf_SET
#define EVM_KEY_DATA_MASKm_VM_KEY_MASKf_GET BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_MASKf_GET
#define EVM_KEY_DATA_MASKm_VM_KEY_MASKf_SET BCM53600_A0_EVM_KEY_DATA_MASKm_VM_KEY_MASKf_SET
#define EVM_KEY_DATA_MASKm_RESERVED_Rf_GET BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_Rf_GET
#define EVM_KEY_DATA_MASKm_RESERVED_Rf_SET BCM53600_A0_EVM_KEY_DATA_MASKm_RESERVED_Rf_SET
#define READ_EVM_KEY_DATA_MASKm BCM53600_A0_READ_EVM_KEY_DATA_MASKm
#define WRITE_EVM_KEY_DATA_MASKm BCM53600_A0_WRITE_EVM_KEY_DATA_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EVM_KEY_DATA_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  EVM_KEY_MASK
 * BLOCKS:   SYS
 * DESC:     EVM KEY MASK Table
 * SIZE:     64
 * FIELDS:
 *     EGRESS_VPORT_ID  Field Mask
 *     EGRESS_PORT_ID   Field Mask
 *     FLOW_ID          Field Mask
 *     INGRESS_VPORT_ID Field Mask
 *     INGRESS_PORT_ID  Field Mask
 *     RESERVED_1R      Field Mask
 *     VALID            Field Mask
 *     RESERVED_R       Field Mask
 *
 ******************************************************************************/
#define BCM53600_A0_EVM_KEY_MASKm 0x00000000

#define BCM53600_A0_EVM_KEY_MASKm_MIN 0
#define BCM53600_A0_EVM_KEY_MASKm_MAX 2047
#define BCM53600_A0_EVM_KEY_MASKm_CMAX(u) 2047
#define BCM53600_A0_EVM_KEY_MASKm_SIZE 8

/*
 * This structure should be used to declare and program EVM_KEY_MASK.
 *
 */
typedef union BCM53600_A0_EVM_KEY_MASKm_s {
	uint32_t v[2];
	uint32_t evm_key_mask[2];
	uint32_t _evm_key_mask;
} BCM53600_A0_EVM_KEY_MASKm_t;

#define BCM53600_A0_EVM_KEY_MASKm_CLR(r) CDK_MEMSET(&((r)._evm_key_mask), 0, sizeof(BCM53600_A0_EVM_KEY_MASKm_t))
#define BCM53600_A0_EVM_KEY_MASKm_SET(r,i,d) (r).evm_key_mask[i] = d
#define BCM53600_A0_EVM_KEY_MASKm_GET(r,i) (r).evm_key_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EVM_KEY_MASKm_EGRESS_VPORT_IDf_GET(r) (((r).evm_key_mask[0]) & 0xf)
#define BCM53600_A0_EVM_KEY_MASKm_EGRESS_VPORT_IDf_SET(r,f) (r).evm_key_mask[0]=(((r).evm_key_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_EVM_KEY_MASKm_EGRESS_PORT_IDf_GET(r) ((((r).evm_key_mask[0]) >> 4) & 0x3f)
#define BCM53600_A0_EVM_KEY_MASKm_EGRESS_PORT_IDf_SET(r,f) (r).evm_key_mask[0]=(((r).evm_key_mask[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53600_A0_EVM_KEY_MASKm_FLOW_IDf_GET(r) ((((r).evm_key_mask[0]) >> 10) & 0xfff)
#define BCM53600_A0_EVM_KEY_MASKm_FLOW_IDf_SET(r,f) (r).evm_key_mask[0]=(((r).evm_key_mask[0] & ~((uint32_t)0xfff << 10)) | ((((uint32_t)f) & 0xfff) << 10))
#define BCM53600_A0_EVM_KEY_MASKm_INGRESS_VPORT_IDf_GET(r) ((((r).evm_key_mask[0]) >> 22) & 0xf)
#define BCM53600_A0_EVM_KEY_MASKm_INGRESS_VPORT_IDf_SET(r,f) (r).evm_key_mask[0]=(((r).evm_key_mask[0] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define BCM53600_A0_EVM_KEY_MASKm_INGRESS_PORT_IDf_GET(r) ((((r).evm_key_mask[0]) >> 26) & 0x3f)
#define BCM53600_A0_EVM_KEY_MASKm_INGRESS_PORT_IDf_SET(r,f) (r).evm_key_mask[0]=(((r).evm_key_mask[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM53600_A0_EVM_KEY_MASKm_RESERVED_1Rf_GET(r) (((r).evm_key_mask[1]) & 0x1ffff)
#define BCM53600_A0_EVM_KEY_MASKm_RESERVED_1Rf_SET(r,f) (r).evm_key_mask[1]=(((r).evm_key_mask[1] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53600_A0_EVM_KEY_MASKm_VALIDf_GET(r) ((((r).evm_key_mask[1]) >> 17) & 0x1)
#define BCM53600_A0_EVM_KEY_MASKm_VALIDf_SET(r,f) (r).evm_key_mask[1]=(((r).evm_key_mask[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_EVM_KEY_MASKm_RESERVED_Rf_GET(r) ((((r).evm_key_mask[1]) >> 18) & 0x3fff)
#define BCM53600_A0_EVM_KEY_MASKm_RESERVED_Rf_SET(r,f) (r).evm_key_mask[1]=(((r).evm_key_mask[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access EVM_KEY_MASK.
 *
 */
#define BCM53600_A0_READ_EVM_KEY_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_EVM_KEY_MASKm,i,(m),8)
#define BCM53600_A0_WRITE_EVM_KEY_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_EVM_KEY_MASKm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVM_KEY_MASKm BCM53600_A0_EVM_KEY_MASKm
#define EVM_KEY_MASKm_MIN BCM53600_A0_EVM_KEY_MASKm_MIN
#define EVM_KEY_MASKm_MAX BCM53600_A0_EVM_KEY_MASKm_MAX
#define EVM_KEY_MASKm_CMAX(u) BCM53600_A0_EVM_KEY_MASKm_CMAX(u)
#define EVM_KEY_MASKm_SIZE BCM53600_A0_EVM_KEY_MASKm_SIZE
typedef BCM53600_A0_EVM_KEY_MASKm_t EVM_KEY_MASKm_t;
#define EVM_KEY_MASKm_CLR BCM53600_A0_EVM_KEY_MASKm_CLR
#define EVM_KEY_MASKm_SET BCM53600_A0_EVM_KEY_MASKm_SET
#define EVM_KEY_MASKm_GET BCM53600_A0_EVM_KEY_MASKm_GET
#define EVM_KEY_MASKm_EGRESS_VPORT_IDf_GET BCM53600_A0_EVM_KEY_MASKm_EGRESS_VPORT_IDf_GET
#define EVM_KEY_MASKm_EGRESS_VPORT_IDf_SET BCM53600_A0_EVM_KEY_MASKm_EGRESS_VPORT_IDf_SET
#define EVM_KEY_MASKm_EGRESS_PORT_IDf_GET BCM53600_A0_EVM_KEY_MASKm_EGRESS_PORT_IDf_GET
#define EVM_KEY_MASKm_EGRESS_PORT_IDf_SET BCM53600_A0_EVM_KEY_MASKm_EGRESS_PORT_IDf_SET
#define EVM_KEY_MASKm_FLOW_IDf_GET BCM53600_A0_EVM_KEY_MASKm_FLOW_IDf_GET
#define EVM_KEY_MASKm_FLOW_IDf_SET BCM53600_A0_EVM_KEY_MASKm_FLOW_IDf_SET
#define EVM_KEY_MASKm_INGRESS_VPORT_IDf_GET BCM53600_A0_EVM_KEY_MASKm_INGRESS_VPORT_IDf_GET
#define EVM_KEY_MASKm_INGRESS_VPORT_IDf_SET BCM53600_A0_EVM_KEY_MASKm_INGRESS_VPORT_IDf_SET
#define EVM_KEY_MASKm_INGRESS_PORT_IDf_GET BCM53600_A0_EVM_KEY_MASKm_INGRESS_PORT_IDf_GET
#define EVM_KEY_MASKm_INGRESS_PORT_IDf_SET BCM53600_A0_EVM_KEY_MASKm_INGRESS_PORT_IDf_SET
#define EVM_KEY_MASKm_RESERVED_1Rf_GET BCM53600_A0_EVM_KEY_MASKm_RESERVED_1Rf_GET
#define EVM_KEY_MASKm_RESERVED_1Rf_SET BCM53600_A0_EVM_KEY_MASKm_RESERVED_1Rf_SET
#define EVM_KEY_MASKm_VALIDf_GET BCM53600_A0_EVM_KEY_MASKm_VALIDf_GET
#define EVM_KEY_MASKm_VALIDf_SET BCM53600_A0_EVM_KEY_MASKm_VALIDf_SET
#define EVM_KEY_MASKm_RESERVED_Rf_GET BCM53600_A0_EVM_KEY_MASKm_RESERVED_Rf_GET
#define EVM_KEY_MASKm_RESERVED_Rf_SET BCM53600_A0_EVM_KEY_MASKm_RESERVED_Rf_SET
#define READ_EVM_KEY_MASKm BCM53600_A0_READ_EVM_KEY_MASKm
#define WRITE_EVM_KEY_MASKm BCM53600_A0_WRITE_EVM_KEY_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EVM_KEY_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  EXP_PORT
 * BLOCKS:   SYS
 * DESC:     Expansion Port Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_EXP           1: Enable expansion port. An expansion message will be added in the frame.0: Disable expansion port. No expansion message will be added in the frame. 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_EXP_PORTr 0x00004800

#define BCM53600_A0_EXP_PORTr_SIZE 1

/*
 * This structure should be used to declare and program EXP_PORT.
 *
 */
typedef union BCM53600_A0_EXP_PORTr_s {
	uint32_t v[1];
	uint32_t exp_port[1];
	uint32_t _exp_port;
} BCM53600_A0_EXP_PORTr_t;

#define BCM53600_A0_EXP_PORTr_CLR(r) (r).exp_port[0] = 0
#define BCM53600_A0_EXP_PORTr_SET(r,d) (r).exp_port[0] = d
#define BCM53600_A0_EXP_PORTr_GET(r) (r).exp_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_EXP_PORTr_EN_EXPf_GET(r) (((r).exp_port[0]) & 0x1)
#define BCM53600_A0_EXP_PORTr_EN_EXPf_SET(r,f) (r).exp_port[0]=(((r).exp_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_EXP_PORTr_RESERVEDf_GET(r) ((((r).exp_port[0]) >> 1) & 0x7f)
#define BCM53600_A0_EXP_PORTr_RESERVEDf_SET(r,f) (r).exp_port[0]=(((r).exp_port[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access EXP_PORT.
 *
 */
#define BCM53600_A0_READ_EXP_PORTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_EXP_PORTr,(r._exp_port),1)
#define BCM53600_A0_WRITE_EXP_PORTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_EXP_PORTr,&(r._exp_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EXP_PORTr BCM53600_A0_EXP_PORTr
#define EXP_PORTr_SIZE BCM53600_A0_EXP_PORTr_SIZE
typedef BCM53600_A0_EXP_PORTr_t EXP_PORTr_t;
#define EXP_PORTr_CLR BCM53600_A0_EXP_PORTr_CLR
#define EXP_PORTr_SET BCM53600_A0_EXP_PORTr_SET
#define EXP_PORTr_GET BCM53600_A0_EXP_PORTr_GET
#define EXP_PORTr_EN_EXPf_GET BCM53600_A0_EXP_PORTr_EN_EXPf_GET
#define EXP_PORTr_EN_EXPf_SET BCM53600_A0_EXP_PORTr_EN_EXPf_SET
#define EXP_PORTr_RESERVEDf_GET BCM53600_A0_EXP_PORTr_RESERVEDf_GET
#define EXP_PORTr_RESERVEDf_SET BCM53600_A0_EXP_PORTr_RESERVEDf_SET
#define READ_EXP_PORTr BCM53600_A0_READ_EXP_PORTr
#define WRITE_EXP_PORTr BCM53600_A0_WRITE_EXP_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_EXP_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_ANADV
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     ADV_SEL_FIELD    Indicates 802.3
 *     ADV_B10T         1 = Advertise 10BASE-T.
 *     ADV_B10T_FDX     1 = Advertise 10BASE-T full-duplex full-duplex.0 = Do not advertise 10BASE-T full-duplex.
 *     ADV_B100X        1 = Advertise 100BASE-X.
 *     ADV_B100X_FDX    1 = Advertise 100BASE-X full-duplex full-duplex.0 = Do not advertise 100BASE-X full-duplex.
 *     ADV_B100T4       1 = Advertise T4 capability.0 = Do not advertise T4 capability.
 *     ADV_PAUSE_CAP    1 = pause operation for full-duplex.
 *     RESV_TECH        
 *     REMOTE_FAULT     1 = Transmit remote fault.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = next page ability is enable.0 = next page ability is disable.
 *
 ******************************************************************************/
#define BCM53600_A0_E_ANADVr 0x0000c008

#define BCM53600_A0_E_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program E_ANADV.
 *
 */
typedef union BCM53600_A0_E_ANADVr_s {
	uint32_t v[1];
	uint32_t e_anadv[1];
	uint32_t _e_anadv;
} BCM53600_A0_E_ANADVr_t;

#define BCM53600_A0_E_ANADVr_CLR(r) (r).e_anadv[0] = 0
#define BCM53600_A0_E_ANADVr_SET(r,d) (r).e_anadv[0] = d
#define BCM53600_A0_E_ANADVr_GET(r) (r).e_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_ANADVr_ADV_SEL_FIELDf_GET(r) (((r).e_anadv[0]) & 0x1f)
#define BCM53600_A0_E_ANADVr_ADV_SEL_FIELDf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_E_ANADVr_ADV_B10Tf_GET(r) ((((r).e_anadv[0]) >> 5) & 0x1)
#define BCM53600_A0_E_ANADVr_ADV_B10Tf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_E_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).e_anadv[0]) >> 6) & 0x1)
#define BCM53600_A0_E_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_E_ANADVr_ADV_B100Xf_GET(r) ((((r).e_anadv[0]) >> 7) & 0x1)
#define BCM53600_A0_E_ANADVr_ADV_B100Xf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_E_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).e_anadv[0]) >> 8) & 0x1)
#define BCM53600_A0_E_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_E_ANADVr_ADV_B100T4f_GET(r) ((((r).e_anadv[0]) >> 9) & 0x1)
#define BCM53600_A0_E_ANADVr_ADV_B100T4f_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_E_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).e_anadv[0]) >> 10) & 0x1)
#define BCM53600_A0_E_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_E_ANADVr_RESV_TECHf_GET(r) ((((r).e_anadv[0]) >> 11) & 0x3)
#define BCM53600_A0_E_ANADVr_RESV_TECHf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_E_ANADVr_REMOTE_FAULTf_GET(r) ((((r).e_anadv[0]) >> 13) & 0x1)
#define BCM53600_A0_E_ANADVr_REMOTE_FAULTf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_E_ANADVr_RESERVEDf_GET(r) ((((r).e_anadv[0]) >> 14) & 0x1)
#define BCM53600_A0_E_ANADVr_RESERVEDf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_E_ANADVr_NEXT_PAGEf_GET(r) ((((r).e_anadv[0]) >> 15) & 0x1)
#define BCM53600_A0_E_ANADVr_NEXT_PAGEf_SET(r,f) (r).e_anadv[0]=(((r).e_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access E_ANADV.
 *
 */
#define BCM53600_A0_READ_E_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_ANADVr,(r._e_anadv),2)
#define BCM53600_A0_WRITE_E_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_ANADVr,&(r._e_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_ANADVr BCM53600_A0_E_ANADVr
#define E_ANADVr_SIZE BCM53600_A0_E_ANADVr_SIZE
typedef BCM53600_A0_E_ANADVr_t E_ANADVr_t;
#define E_ANADVr_CLR BCM53600_A0_E_ANADVr_CLR
#define E_ANADVr_SET BCM53600_A0_E_ANADVr_SET
#define E_ANADVr_GET BCM53600_A0_E_ANADVr_GET
#define E_ANADVr_ADV_SEL_FIELDf_GET BCM53600_A0_E_ANADVr_ADV_SEL_FIELDf_GET
#define E_ANADVr_ADV_SEL_FIELDf_SET BCM53600_A0_E_ANADVr_ADV_SEL_FIELDf_SET
#define E_ANADVr_ADV_B10Tf_GET BCM53600_A0_E_ANADVr_ADV_B10Tf_GET
#define E_ANADVr_ADV_B10Tf_SET BCM53600_A0_E_ANADVr_ADV_B10Tf_SET
#define E_ANADVr_ADV_B10T_FDXf_GET BCM53600_A0_E_ANADVr_ADV_B10T_FDXf_GET
#define E_ANADVr_ADV_B10T_FDXf_SET BCM53600_A0_E_ANADVr_ADV_B10T_FDXf_SET
#define E_ANADVr_ADV_B100Xf_GET BCM53600_A0_E_ANADVr_ADV_B100Xf_GET
#define E_ANADVr_ADV_B100Xf_SET BCM53600_A0_E_ANADVr_ADV_B100Xf_SET
#define E_ANADVr_ADV_B100X_FDXf_GET BCM53600_A0_E_ANADVr_ADV_B100X_FDXf_GET
#define E_ANADVr_ADV_B100X_FDXf_SET BCM53600_A0_E_ANADVr_ADV_B100X_FDXf_SET
#define E_ANADVr_ADV_B100T4f_GET BCM53600_A0_E_ANADVr_ADV_B100T4f_GET
#define E_ANADVr_ADV_B100T4f_SET BCM53600_A0_E_ANADVr_ADV_B100T4f_SET
#define E_ANADVr_ADV_PAUSE_CAPf_GET BCM53600_A0_E_ANADVr_ADV_PAUSE_CAPf_GET
#define E_ANADVr_ADV_PAUSE_CAPf_SET BCM53600_A0_E_ANADVr_ADV_PAUSE_CAPf_SET
#define E_ANADVr_RESV_TECHf_GET BCM53600_A0_E_ANADVr_RESV_TECHf_GET
#define E_ANADVr_RESV_TECHf_SET BCM53600_A0_E_ANADVr_RESV_TECHf_SET
#define E_ANADVr_REMOTE_FAULTf_GET BCM53600_A0_E_ANADVr_REMOTE_FAULTf_GET
#define E_ANADVr_REMOTE_FAULTf_SET BCM53600_A0_E_ANADVr_REMOTE_FAULTf_SET
#define E_ANADVr_RESERVEDf_GET BCM53600_A0_E_ANADVr_RESERVEDf_GET
#define E_ANADVr_RESERVEDf_SET BCM53600_A0_E_ANADVr_RESERVEDf_SET
#define E_ANADVr_NEXT_PAGEf_GET BCM53600_A0_E_ANADVr_NEXT_PAGEf_GET
#define E_ANADVr_NEXT_PAGEf_SET BCM53600_A0_E_ANADVr_NEXT_PAGEf_SET
#define READ_E_ANADVr BCM53600_A0_READ_E_ANADVr
#define WRITE_E_ANADVr BCM53600_A0_WRITE_E_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_ANEXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABLE       1 = Link partner has auto-negotiation capability.0 = Link partner does not have auto-negotiation capability.
 *     PAGE_RECEIVED    1 = New page has been received.0 = New page has not been received.
 *     NEXT_PAGE_ABLE   1 = Next Page able.
 *     LP_NEXT_PAGE_ABLE 1 = Link partner has Next Page capability.0 = Link partner does not have Next Page capability.
 *     PD_FAULT         1 = Parallel detection fault.0 = No parallel detection fault.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_E_ANEXPr 0x0000c00c

#define BCM53600_A0_E_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program E_ANEXP.
 *
 */
typedef union BCM53600_A0_E_ANEXPr_s {
	uint32_t v[1];
	uint32_t e_anexp[1];
	uint32_t _e_anexp;
} BCM53600_A0_E_ANEXPr_t;

#define BCM53600_A0_E_ANEXPr_CLR(r) (r).e_anexp[0] = 0
#define BCM53600_A0_E_ANEXPr_SET(r,d) (r).e_anexp[0] = d
#define BCM53600_A0_E_ANEXPr_GET(r) (r).e_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_ANEXPr_LP_AN_ABLEf_GET(r) (((r).e_anexp[0]) & 0x1)
#define BCM53600_A0_E_ANEXPr_LP_AN_ABLEf_SET(r,f) (r).e_anexp[0]=(((r).e_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_E_ANEXPr_PAGE_RECEIVEDf_GET(r) ((((r).e_anexp[0]) >> 1) & 0x1)
#define BCM53600_A0_E_ANEXPr_PAGE_RECEIVEDf_SET(r,f) (r).e_anexp[0]=(((r).e_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_E_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).e_anexp[0]) >> 2) & 0x1)
#define BCM53600_A0_E_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).e_anexp[0]=(((r).e_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_E_ANEXPr_LP_NEXT_PAGE_ABLEf_GET(r) ((((r).e_anexp[0]) >> 3) & 0x1)
#define BCM53600_A0_E_ANEXPr_LP_NEXT_PAGE_ABLEf_SET(r,f) (r).e_anexp[0]=(((r).e_anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_E_ANEXPr_PD_FAULTf_GET(r) ((((r).e_anexp[0]) >> 4) & 0x1)
#define BCM53600_A0_E_ANEXPr_PD_FAULTf_SET(r,f) (r).e_anexp[0]=(((r).e_anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_E_ANEXPr_RESERVEDf_GET(r) ((((r).e_anexp[0]) >> 5) & 0x7ff)
#define BCM53600_A0_E_ANEXPr_RESERVEDf_SET(r,f) (r).e_anexp[0]=(((r).e_anexp[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))

/*
 * These macros can be used to access E_ANEXP.
 *
 */
#define BCM53600_A0_READ_E_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_ANEXPr,(r._e_anexp),2)
#define BCM53600_A0_WRITE_E_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_ANEXPr,&(r._e_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_ANEXPr BCM53600_A0_E_ANEXPr
#define E_ANEXPr_SIZE BCM53600_A0_E_ANEXPr_SIZE
typedef BCM53600_A0_E_ANEXPr_t E_ANEXPr_t;
#define E_ANEXPr_CLR BCM53600_A0_E_ANEXPr_CLR
#define E_ANEXPr_SET BCM53600_A0_E_ANEXPr_SET
#define E_ANEXPr_GET BCM53600_A0_E_ANEXPr_GET
#define E_ANEXPr_LP_AN_ABLEf_GET BCM53600_A0_E_ANEXPr_LP_AN_ABLEf_GET
#define E_ANEXPr_LP_AN_ABLEf_SET BCM53600_A0_E_ANEXPr_LP_AN_ABLEf_SET
#define E_ANEXPr_PAGE_RECEIVEDf_GET BCM53600_A0_E_ANEXPr_PAGE_RECEIVEDf_GET
#define E_ANEXPr_PAGE_RECEIVEDf_SET BCM53600_A0_E_ANEXPr_PAGE_RECEIVEDf_SET
#define E_ANEXPr_NEXT_PAGE_ABLEf_GET BCM53600_A0_E_ANEXPr_NEXT_PAGE_ABLEf_GET
#define E_ANEXPr_NEXT_PAGE_ABLEf_SET BCM53600_A0_E_ANEXPr_NEXT_PAGE_ABLEf_SET
#define E_ANEXPr_LP_NEXT_PAGE_ABLEf_GET BCM53600_A0_E_ANEXPr_LP_NEXT_PAGE_ABLEf_GET
#define E_ANEXPr_LP_NEXT_PAGE_ABLEf_SET BCM53600_A0_E_ANEXPr_LP_NEXT_PAGE_ABLEf_SET
#define E_ANEXPr_PD_FAULTf_GET BCM53600_A0_E_ANEXPr_PD_FAULTf_GET
#define E_ANEXPr_PD_FAULTf_SET BCM53600_A0_E_ANEXPr_PD_FAULTf_SET
#define E_ANEXPr_RESERVEDf_GET BCM53600_A0_E_ANEXPr_RESERVEDf_GET
#define E_ANEXPr_RESERVEDf_SET BCM53600_A0_E_ANEXPr_RESERVEDf_SET
#define READ_E_ANEXPr BCM53600_A0_READ_E_ANEXPr
#define WRITE_E_ANEXPr BCM53600_A0_WRITE_E_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_ANLPA
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     LP_ADV_SEL_FIELD Link partner selector field.
 *     LP_ADV_B10T      Link partner has 10BASE-T capability.
 *     LP_ADV_B10T_FDX  Link partner has 10BASE-T FDX capability.
 *     LP_ADV_B100X     Link partner has 100BASE-X capability.
 *     LP_ADV_B100X_FDX Link partner has 100BASE-X FDX capability.
 *     LP_ADV_B100T4    Link partner has 100BASE-T4 capability.
 *     LP_ADV_PAUSE     Link partner has pause capability.
 *     RESV_TECH        
 *     LP_REMOTE_FAULT  Link partner remote fault indicator.
 *     LP_ACK           Link partner acknowledge bit.
 *     LP_NEXT_PAGE     Link partner Next Page bit.
 *
 ******************************************************************************/
#define BCM53600_A0_E_ANLPAr 0x0000c00a

#define BCM53600_A0_E_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program E_ANLPA.
 *
 */
typedef union BCM53600_A0_E_ANLPAr_s {
	uint32_t v[1];
	uint32_t e_anlpa[1];
	uint32_t _e_anlpa;
} BCM53600_A0_E_ANLPAr_t;

#define BCM53600_A0_E_ANLPAr_CLR(r) (r).e_anlpa[0] = 0
#define BCM53600_A0_E_ANLPAr_SET(r,d) (r).e_anlpa[0] = d
#define BCM53600_A0_E_ANLPAr_GET(r) (r).e_anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_ANLPAr_LP_ADV_SEL_FIELDf_GET(r) (((r).e_anlpa[0]) & 0x1f)
#define BCM53600_A0_E_ANLPAr_LP_ADV_SEL_FIELDf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_E_ANLPAr_LP_ADV_B10Tf_GET(r) ((((r).e_anlpa[0]) >> 5) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ADV_B10Tf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_E_ANLPAr_LP_ADV_B10T_FDXf_GET(r) ((((r).e_anlpa[0]) >> 6) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ADV_B10T_FDXf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_E_ANLPAr_LP_ADV_B100Xf_GET(r) ((((r).e_anlpa[0]) >> 7) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ADV_B100Xf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_E_ANLPAr_LP_ADV_B100X_FDXf_GET(r) ((((r).e_anlpa[0]) >> 8) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ADV_B100X_FDXf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_E_ANLPAr_LP_ADV_B100T4f_GET(r) ((((r).e_anlpa[0]) >> 9) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ADV_B100T4f_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_E_ANLPAr_LP_ADV_PAUSEf_GET(r) ((((r).e_anlpa[0]) >> 10) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ADV_PAUSEf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_E_ANLPAr_RESV_TECHf_GET(r) ((((r).e_anlpa[0]) >> 11) & 0x3)
#define BCM53600_A0_E_ANLPAr_RESV_TECHf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53600_A0_E_ANLPAr_LP_REMOTE_FAULTf_GET(r) ((((r).e_anlpa[0]) >> 13) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_REMOTE_FAULTf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_E_ANLPAr_LP_ACKf_GET(r) ((((r).e_anlpa[0]) >> 14) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_ACKf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_E_ANLPAr_LP_NEXT_PAGEf_GET(r) ((((r).e_anlpa[0]) >> 15) & 0x1)
#define BCM53600_A0_E_ANLPAr_LP_NEXT_PAGEf_SET(r,f) (r).e_anlpa[0]=(((r).e_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access E_ANLPA.
 *
 */
#define BCM53600_A0_READ_E_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_ANLPAr,(r._e_anlpa),2)
#define BCM53600_A0_WRITE_E_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_ANLPAr,&(r._e_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_ANLPAr BCM53600_A0_E_ANLPAr
#define E_ANLPAr_SIZE BCM53600_A0_E_ANLPAr_SIZE
typedef BCM53600_A0_E_ANLPAr_t E_ANLPAr_t;
#define E_ANLPAr_CLR BCM53600_A0_E_ANLPAr_CLR
#define E_ANLPAr_SET BCM53600_A0_E_ANLPAr_SET
#define E_ANLPAr_GET BCM53600_A0_E_ANLPAr_GET
#define E_ANLPAr_LP_ADV_SEL_FIELDf_GET BCM53600_A0_E_ANLPAr_LP_ADV_SEL_FIELDf_GET
#define E_ANLPAr_LP_ADV_SEL_FIELDf_SET BCM53600_A0_E_ANLPAr_LP_ADV_SEL_FIELDf_SET
#define E_ANLPAr_LP_ADV_B10Tf_GET BCM53600_A0_E_ANLPAr_LP_ADV_B10Tf_GET
#define E_ANLPAr_LP_ADV_B10Tf_SET BCM53600_A0_E_ANLPAr_LP_ADV_B10Tf_SET
#define E_ANLPAr_LP_ADV_B10T_FDXf_GET BCM53600_A0_E_ANLPAr_LP_ADV_B10T_FDXf_GET
#define E_ANLPAr_LP_ADV_B10T_FDXf_SET BCM53600_A0_E_ANLPAr_LP_ADV_B10T_FDXf_SET
#define E_ANLPAr_LP_ADV_B100Xf_GET BCM53600_A0_E_ANLPAr_LP_ADV_B100Xf_GET
#define E_ANLPAr_LP_ADV_B100Xf_SET BCM53600_A0_E_ANLPAr_LP_ADV_B100Xf_SET
#define E_ANLPAr_LP_ADV_B100X_FDXf_GET BCM53600_A0_E_ANLPAr_LP_ADV_B100X_FDXf_GET
#define E_ANLPAr_LP_ADV_B100X_FDXf_SET BCM53600_A0_E_ANLPAr_LP_ADV_B100X_FDXf_SET
#define E_ANLPAr_LP_ADV_B100T4f_GET BCM53600_A0_E_ANLPAr_LP_ADV_B100T4f_GET
#define E_ANLPAr_LP_ADV_B100T4f_SET BCM53600_A0_E_ANLPAr_LP_ADV_B100T4f_SET
#define E_ANLPAr_LP_ADV_PAUSEf_GET BCM53600_A0_E_ANLPAr_LP_ADV_PAUSEf_GET
#define E_ANLPAr_LP_ADV_PAUSEf_SET BCM53600_A0_E_ANLPAr_LP_ADV_PAUSEf_SET
#define E_ANLPAr_RESV_TECHf_GET BCM53600_A0_E_ANLPAr_RESV_TECHf_GET
#define E_ANLPAr_RESV_TECHf_SET BCM53600_A0_E_ANLPAr_RESV_TECHf_SET
#define E_ANLPAr_LP_REMOTE_FAULTf_GET BCM53600_A0_E_ANLPAr_LP_REMOTE_FAULTf_GET
#define E_ANLPAr_LP_REMOTE_FAULTf_SET BCM53600_A0_E_ANLPAr_LP_REMOTE_FAULTf_SET
#define E_ANLPAr_LP_ACKf_GET BCM53600_A0_E_ANLPAr_LP_ACKf_GET
#define E_ANLPAr_LP_ACKf_SET BCM53600_A0_E_ANLPAr_LP_ACKf_SET
#define E_ANLPAr_LP_NEXT_PAGEf_GET BCM53600_A0_E_ANLPAr_LP_NEXT_PAGEf_GET
#define E_ANLPAr_LP_NEXT_PAGEf_SET BCM53600_A0_E_ANLPAr_LP_NEXT_PAGEf_SET
#define READ_E_ANLPAr BCM53600_A0_READ_E_ANLPAr
#define WRITE_E_ANLPAr BCM53600_A0_WRITE_E_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_ANNXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       Message/Unformatted Code Field.
 *     TOGGLE           1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     ACK_2            1 = Will comply with message.0 = Can not comply with message.
 *     MESSAGE_PAGE     1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53600_A0_E_ANNXPr 0x0000c00e

#define BCM53600_A0_E_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program E_ANNXP.
 *
 */
typedef union BCM53600_A0_E_ANNXPr_s {
	uint32_t v[1];
	uint32_t e_annxp[1];
	uint32_t _e_annxp;
} BCM53600_A0_E_ANNXPr_t;

#define BCM53600_A0_E_ANNXPr_CLR(r) (r).e_annxp[0] = 0
#define BCM53600_A0_E_ANNXPr_SET(r,d) (r).e_annxp[0] = d
#define BCM53600_A0_E_ANNXPr_GET(r) (r).e_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_ANNXPr_CODE_FIELDf_GET(r) (((r).e_annxp[0]) & 0x7ff)
#define BCM53600_A0_E_ANNXPr_CODE_FIELDf_SET(r,f) (r).e_annxp[0]=(((r).e_annxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53600_A0_E_ANNXPr_TOGGLEf_GET(r) ((((r).e_annxp[0]) >> 11) & 0x1)
#define BCM53600_A0_E_ANNXPr_TOGGLEf_SET(r,f) (r).e_annxp[0]=(((r).e_annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_E_ANNXPr_ACK_2f_GET(r) ((((r).e_annxp[0]) >> 12) & 0x1)
#define BCM53600_A0_E_ANNXPr_ACK_2f_SET(r,f) (r).e_annxp[0]=(((r).e_annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_E_ANNXPr_MESSAGE_PAGEf_GET(r) ((((r).e_annxp[0]) >> 13) & 0x1)
#define BCM53600_A0_E_ANNXPr_MESSAGE_PAGEf_SET(r,f) (r).e_annxp[0]=(((r).e_annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_E_ANNXPr_RESERVEDf_GET(r) ((((r).e_annxp[0]) >> 14) & 0x1)
#define BCM53600_A0_E_ANNXPr_RESERVEDf_SET(r,f) (r).e_annxp[0]=(((r).e_annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_E_ANNXPr_NEXT_PAGEf_GET(r) ((((r).e_annxp[0]) >> 15) & 0x1)
#define BCM53600_A0_E_ANNXPr_NEXT_PAGEf_SET(r,f) (r).e_annxp[0]=(((r).e_annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access E_ANNXP.
 *
 */
#define BCM53600_A0_READ_E_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_ANNXPr,(r._e_annxp),2)
#define BCM53600_A0_WRITE_E_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_ANNXPr,&(r._e_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_ANNXPr BCM53600_A0_E_ANNXPr
#define E_ANNXPr_SIZE BCM53600_A0_E_ANNXPr_SIZE
typedef BCM53600_A0_E_ANNXPr_t E_ANNXPr_t;
#define E_ANNXPr_CLR BCM53600_A0_E_ANNXPr_CLR
#define E_ANNXPr_SET BCM53600_A0_E_ANNXPr_SET
#define E_ANNXPr_GET BCM53600_A0_E_ANNXPr_GET
#define E_ANNXPr_CODE_FIELDf_GET BCM53600_A0_E_ANNXPr_CODE_FIELDf_GET
#define E_ANNXPr_CODE_FIELDf_SET BCM53600_A0_E_ANNXPr_CODE_FIELDf_SET
#define E_ANNXPr_TOGGLEf_GET BCM53600_A0_E_ANNXPr_TOGGLEf_GET
#define E_ANNXPr_TOGGLEf_SET BCM53600_A0_E_ANNXPr_TOGGLEf_SET
#define E_ANNXPr_ACK_2f_GET BCM53600_A0_E_ANNXPr_ACK_2f_GET
#define E_ANNXPr_ACK_2f_SET BCM53600_A0_E_ANNXPr_ACK_2f_SET
#define E_ANNXPr_MESSAGE_PAGEf_GET BCM53600_A0_E_ANNXPr_MESSAGE_PAGEf_GET
#define E_ANNXPr_MESSAGE_PAGEf_SET BCM53600_A0_E_ANNXPr_MESSAGE_PAGEf_SET
#define E_ANNXPr_RESERVEDf_GET BCM53600_A0_E_ANNXPr_RESERVEDf_GET
#define E_ANNXPr_RESERVEDf_SET BCM53600_A0_E_ANNXPr_RESERVEDf_SET
#define E_ANNXPr_NEXT_PAGEf_GET BCM53600_A0_E_ANNXPr_NEXT_PAGEf_GET
#define E_ANNXPr_NEXT_PAGEf_SET BCM53600_A0_E_ANNXPr_NEXT_PAGEf_SET
#define READ_E_ANNXPr BCM53600_A0_READ_E_ANNXPr
#define WRITE_E_ANNXPr BCM53600_A0_WRITE_E_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_LPNXP
 * BLOCKS:   EPIC0
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     LP_CODE_FIELD    Message/Unformatted Code Field.
 *     LP_TOGGLE        1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     LP_ACK_2         1 = Will comply with message.0 = Can not comply with message.
 *     LP_MESSAGE_PAGE  1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     LP_NEXT_PAGE     1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53600_A0_E_LPNXPr 0x0000c010

#define BCM53600_A0_E_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program E_LPNXP.
 *
 */
typedef union BCM53600_A0_E_LPNXPr_s {
	uint32_t v[1];
	uint32_t e_lpnxp[1];
	uint32_t _e_lpnxp;
} BCM53600_A0_E_LPNXPr_t;

#define BCM53600_A0_E_LPNXPr_CLR(r) (r).e_lpnxp[0] = 0
#define BCM53600_A0_E_LPNXPr_SET(r,d) (r).e_lpnxp[0] = d
#define BCM53600_A0_E_LPNXPr_GET(r) (r).e_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_LPNXPr_LP_CODE_FIELDf_GET(r) (((r).e_lpnxp[0]) & 0x7ff)
#define BCM53600_A0_E_LPNXPr_LP_CODE_FIELDf_SET(r,f) (r).e_lpnxp[0]=(((r).e_lpnxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53600_A0_E_LPNXPr_LP_TOGGLEf_GET(r) ((((r).e_lpnxp[0]) >> 11) & 0x1)
#define BCM53600_A0_E_LPNXPr_LP_TOGGLEf_SET(r,f) (r).e_lpnxp[0]=(((r).e_lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_E_LPNXPr_LP_ACK_2f_GET(r) ((((r).e_lpnxp[0]) >> 12) & 0x1)
#define BCM53600_A0_E_LPNXPr_LP_ACK_2f_SET(r,f) (r).e_lpnxp[0]=(((r).e_lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_E_LPNXPr_LP_MESSAGE_PAGEf_GET(r) ((((r).e_lpnxp[0]) >> 13) & 0x1)
#define BCM53600_A0_E_LPNXPr_LP_MESSAGE_PAGEf_SET(r,f) (r).e_lpnxp[0]=(((r).e_lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_E_LPNXPr_RESERVEDf_GET(r) ((((r).e_lpnxp[0]) >> 14) & 0x1)
#define BCM53600_A0_E_LPNXPr_RESERVEDf_SET(r,f) (r).e_lpnxp[0]=(((r).e_lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_E_LPNXPr_LP_NEXT_PAGEf_GET(r) ((((r).e_lpnxp[0]) >> 15) & 0x1)
#define BCM53600_A0_E_LPNXPr_LP_NEXT_PAGEf_SET(r,f) (r).e_lpnxp[0]=(((r).e_lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access E_LPNXP.
 *
 */
#define BCM53600_A0_READ_E_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_LPNXPr,(r._e_lpnxp),2)
#define BCM53600_A0_WRITE_E_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_LPNXPr,&(r._e_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_LPNXPr BCM53600_A0_E_LPNXPr
#define E_LPNXPr_SIZE BCM53600_A0_E_LPNXPr_SIZE
typedef BCM53600_A0_E_LPNXPr_t E_LPNXPr_t;
#define E_LPNXPr_CLR BCM53600_A0_E_LPNXPr_CLR
#define E_LPNXPr_SET BCM53600_A0_E_LPNXPr_SET
#define E_LPNXPr_GET BCM53600_A0_E_LPNXPr_GET
#define E_LPNXPr_LP_CODE_FIELDf_GET BCM53600_A0_E_LPNXPr_LP_CODE_FIELDf_GET
#define E_LPNXPr_LP_CODE_FIELDf_SET BCM53600_A0_E_LPNXPr_LP_CODE_FIELDf_SET
#define E_LPNXPr_LP_TOGGLEf_GET BCM53600_A0_E_LPNXPr_LP_TOGGLEf_GET
#define E_LPNXPr_LP_TOGGLEf_SET BCM53600_A0_E_LPNXPr_LP_TOGGLEf_SET
#define E_LPNXPr_LP_ACK_2f_GET BCM53600_A0_E_LPNXPr_LP_ACK_2f_GET
#define E_LPNXPr_LP_ACK_2f_SET BCM53600_A0_E_LPNXPr_LP_ACK_2f_SET
#define E_LPNXPr_LP_MESSAGE_PAGEf_GET BCM53600_A0_E_LPNXPr_LP_MESSAGE_PAGEf_GET
#define E_LPNXPr_LP_MESSAGE_PAGEf_SET BCM53600_A0_E_LPNXPr_LP_MESSAGE_PAGEf_SET
#define E_LPNXPr_RESERVEDf_GET BCM53600_A0_E_LPNXPr_RESERVEDf_GET
#define E_LPNXPr_RESERVEDf_SET BCM53600_A0_E_LPNXPr_RESERVEDf_SET
#define E_LPNXPr_LP_NEXT_PAGEf_GET BCM53600_A0_E_LPNXPr_LP_NEXT_PAGEf_GET
#define E_LPNXPr_LP_NEXT_PAGEf_SET BCM53600_A0_E_LPNXPr_LP_NEXT_PAGEf_SET
#define READ_E_LPNXPr BCM53600_A0_READ_E_LPNXPr
#define WRITE_E_LPNXPr BCM53600_A0_WRITE_E_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_MIICTL
 * BLOCKS:   EPIC0
 * DESC:     EXT MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     DUPLEX_MOD       1'b1: Full Duplex.1'b0: Half Duplex.
 *     RE_AN            1'b1: Restart Auto-Negotiation process.1'b0: Normal operation.
 *     ISOLATE          1'b1: Electrically isolate PHY from MII 0.1'b0: Normal operation.
 *     RESERVED_1       Ignore when read.
 *     AN_EN            1'b1: Auto-Negotiation Enable.1'b0: Auto-Negotiation disable.
 *     F_SPD_SEL        1'b1: 100 Mbps1'b0: 10 Mbps.
 *     LOOPBACK         1'b1: Loopback mode.1'b0: Normal operation.
 *     RESET            1'b1: PHY reset.1'b0: Normal operation.
 *
 ******************************************************************************/
#define BCM53600_A0_E_MIICTLr 0x0000c000

#define BCM53600_A0_E_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program E_MIICTL.
 *
 */
typedef union BCM53600_A0_E_MIICTLr_s {
	uint32_t v[1];
	uint32_t e_miictl[1];
	uint32_t _e_miictl;
} BCM53600_A0_E_MIICTLr_t;

#define BCM53600_A0_E_MIICTLr_CLR(r) (r).e_miictl[0] = 0
#define BCM53600_A0_E_MIICTLr_SET(r,d) (r).e_miictl[0] = d
#define BCM53600_A0_E_MIICTLr_GET(r) (r).e_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_MIICTLr_RESERVEDf_GET(r) (((r).e_miictl[0]) & 0xff)
#define BCM53600_A0_E_MIICTLr_RESERVEDf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_E_MIICTLr_DUPLEX_MODf_GET(r) ((((r).e_miictl[0]) >> 8) & 0x1)
#define BCM53600_A0_E_MIICTLr_DUPLEX_MODf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_E_MIICTLr_RE_ANf_GET(r) ((((r).e_miictl[0]) >> 9) & 0x1)
#define BCM53600_A0_E_MIICTLr_RE_ANf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_E_MIICTLr_ISOLATEf_GET(r) ((((r).e_miictl[0]) >> 10) & 0x1)
#define BCM53600_A0_E_MIICTLr_ISOLATEf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_E_MIICTLr_RESERVED_1f_GET(r) ((((r).e_miictl[0]) >> 11) & 0x1)
#define BCM53600_A0_E_MIICTLr_RESERVED_1f_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_E_MIICTLr_AN_ENf_GET(r) ((((r).e_miictl[0]) >> 12) & 0x1)
#define BCM53600_A0_E_MIICTLr_AN_ENf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_E_MIICTLr_F_SPD_SELf_GET(r) ((((r).e_miictl[0]) >> 13) & 0x1)
#define BCM53600_A0_E_MIICTLr_F_SPD_SELf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_E_MIICTLr_LOOPBACKf_GET(r) ((((r).e_miictl[0]) >> 14) & 0x1)
#define BCM53600_A0_E_MIICTLr_LOOPBACKf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_E_MIICTLr_RESETf_GET(r) ((((r).e_miictl[0]) >> 15) & 0x1)
#define BCM53600_A0_E_MIICTLr_RESETf_SET(r,f) (r).e_miictl[0]=(((r).e_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access E_MIICTL.
 *
 */
#define BCM53600_A0_READ_E_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_MIICTLr,(r._e_miictl),2)
#define BCM53600_A0_WRITE_E_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_MIICTLr,&(r._e_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_MIICTLr BCM53600_A0_E_MIICTLr
#define E_MIICTLr_SIZE BCM53600_A0_E_MIICTLr_SIZE
typedef BCM53600_A0_E_MIICTLr_t E_MIICTLr_t;
#define E_MIICTLr_CLR BCM53600_A0_E_MIICTLr_CLR
#define E_MIICTLr_SET BCM53600_A0_E_MIICTLr_SET
#define E_MIICTLr_GET BCM53600_A0_E_MIICTLr_GET
#define E_MIICTLr_RESERVEDf_GET BCM53600_A0_E_MIICTLr_RESERVEDf_GET
#define E_MIICTLr_RESERVEDf_SET BCM53600_A0_E_MIICTLr_RESERVEDf_SET
#define E_MIICTLr_DUPLEX_MODf_GET BCM53600_A0_E_MIICTLr_DUPLEX_MODf_GET
#define E_MIICTLr_DUPLEX_MODf_SET BCM53600_A0_E_MIICTLr_DUPLEX_MODf_SET
#define E_MIICTLr_RE_ANf_GET BCM53600_A0_E_MIICTLr_RE_ANf_GET
#define E_MIICTLr_RE_ANf_SET BCM53600_A0_E_MIICTLr_RE_ANf_SET
#define E_MIICTLr_ISOLATEf_GET BCM53600_A0_E_MIICTLr_ISOLATEf_GET
#define E_MIICTLr_ISOLATEf_SET BCM53600_A0_E_MIICTLr_ISOLATEf_SET
#define E_MIICTLr_RESERVED_1f_GET BCM53600_A0_E_MIICTLr_RESERVED_1f_GET
#define E_MIICTLr_RESERVED_1f_SET BCM53600_A0_E_MIICTLr_RESERVED_1f_SET
#define E_MIICTLr_AN_ENf_GET BCM53600_A0_E_MIICTLr_AN_ENf_GET
#define E_MIICTLr_AN_ENf_SET BCM53600_A0_E_MIICTLr_AN_ENf_SET
#define E_MIICTLr_F_SPD_SELf_GET BCM53600_A0_E_MIICTLr_F_SPD_SELf_GET
#define E_MIICTLr_F_SPD_SELf_SET BCM53600_A0_E_MIICTLr_F_SPD_SELf_SET
#define E_MIICTLr_LOOPBACKf_GET BCM53600_A0_E_MIICTLr_LOOPBACKf_GET
#define E_MIICTLr_LOOPBACKf_SET BCM53600_A0_E_MIICTLr_LOOPBACKf_SET
#define E_MIICTLr_RESETf_GET BCM53600_A0_E_MIICTLr_RESETf_GET
#define E_MIICTLr_RESETf_SET BCM53600_A0_E_MIICTLr_RESETf_SET
#define READ_E_MIICTLr BCM53600_A0_READ_E_MIICTLr
#define WRITE_E_MIICTLr BCM53600_A0_WRITE_E_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_MIISTS
 * BLOCKS:   EPIC0
 * DESC:     EXT MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = Extended register capabe.
 *     JABBER_DET       1 = jabber condition detected.0 = no jabber condition detected.
 *     LINK_STA         1 = link is up(link pass state).0 = link is down(link fail state).
 *     AUTO_NEGO_CAP    1 = Auto-negotiation capable.0 = not auto-negotiation capable.
 *     RESERVED_1       Ignore when read.
 *     AUTO_NEGO_COMP   1 = Auto-negotiation process completed.0 = Auto-negotiation process not completed.
 *     MF_PRE_SUP       1 = Preamble may be suppressed.0 = Preamble always required.
 *     RESERVED         Reserved
 *     B10T_CAP         1 = 10BASE-T half-duplex capable.
 *     B10T_FDX_CAP     1 = 10BASE-T full-duplex capable.
 *     B100TX_CAP       1 = 100BASE-TX half-duplex capable.
 *     B100TX_FDX_CAP   1 = 100BASE-TX full-duplex capable.
 *     B100T4_CAP       0 = Not 100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM53600_A0_E_MIISTSr 0x0000c002

#define BCM53600_A0_E_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program E_MIISTS.
 *
 */
typedef union BCM53600_A0_E_MIISTSr_s {
	uint32_t v[1];
	uint32_t e_miists[1];
	uint32_t _e_miists;
} BCM53600_A0_E_MIISTSr_t;

#define BCM53600_A0_E_MIISTSr_CLR(r) (r).e_miists[0] = 0
#define BCM53600_A0_E_MIISTSr_SET(r,d) (r).e_miists[0] = d
#define BCM53600_A0_E_MIISTSr_GET(r) (r).e_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_MIISTSr_EXT_CAPf_GET(r) (((r).e_miists[0]) & 0x1)
#define BCM53600_A0_E_MIISTSr_EXT_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_E_MIISTSr_JABBER_DETf_GET(r) ((((r).e_miists[0]) >> 1) & 0x1)
#define BCM53600_A0_E_MIISTSr_JABBER_DETf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_E_MIISTSr_LINK_STAf_GET(r) ((((r).e_miists[0]) >> 2) & 0x1)
#define BCM53600_A0_E_MIISTSr_LINK_STAf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_E_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).e_miists[0]) >> 3) & 0x1)
#define BCM53600_A0_E_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_E_MIISTSr_RESERVED_1f_GET(r) ((((r).e_miists[0]) >> 4) & 0x1)
#define BCM53600_A0_E_MIISTSr_RESERVED_1f_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_E_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).e_miists[0]) >> 5) & 0x1)
#define BCM53600_A0_E_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_E_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).e_miists[0]) >> 6) & 0x1)
#define BCM53600_A0_E_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_E_MIISTSr_RESERVEDf_GET(r) ((((r).e_miists[0]) >> 7) & 0xf)
#define BCM53600_A0_E_MIISTSr_RESERVEDf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53600_A0_E_MIISTSr_B10T_CAPf_GET(r) ((((r).e_miists[0]) >> 11) & 0x1)
#define BCM53600_A0_E_MIISTSr_B10T_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_E_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).e_miists[0]) >> 12) & 0x1)
#define BCM53600_A0_E_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_E_MIISTSr_B100TX_CAPf_GET(r) ((((r).e_miists[0]) >> 13) & 0x1)
#define BCM53600_A0_E_MIISTSr_B100TX_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_E_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).e_miists[0]) >> 14) & 0x1)
#define BCM53600_A0_E_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_E_MIISTSr_B100T4_CAPf_GET(r) ((((r).e_miists[0]) >> 15) & 0x1)
#define BCM53600_A0_E_MIISTSr_B100T4_CAPf_SET(r,f) (r).e_miists[0]=(((r).e_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access E_MIISTS.
 *
 */
#define BCM53600_A0_READ_E_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_MIISTSr,(r._e_miists),2)
#define BCM53600_A0_WRITE_E_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_MIISTSr,&(r._e_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_MIISTSr BCM53600_A0_E_MIISTSr
#define E_MIISTSr_SIZE BCM53600_A0_E_MIISTSr_SIZE
typedef BCM53600_A0_E_MIISTSr_t E_MIISTSr_t;
#define E_MIISTSr_CLR BCM53600_A0_E_MIISTSr_CLR
#define E_MIISTSr_SET BCM53600_A0_E_MIISTSr_SET
#define E_MIISTSr_GET BCM53600_A0_E_MIISTSr_GET
#define E_MIISTSr_EXT_CAPf_GET BCM53600_A0_E_MIISTSr_EXT_CAPf_GET
#define E_MIISTSr_EXT_CAPf_SET BCM53600_A0_E_MIISTSr_EXT_CAPf_SET
#define E_MIISTSr_JABBER_DETf_GET BCM53600_A0_E_MIISTSr_JABBER_DETf_GET
#define E_MIISTSr_JABBER_DETf_SET BCM53600_A0_E_MIISTSr_JABBER_DETf_SET
#define E_MIISTSr_LINK_STAf_GET BCM53600_A0_E_MIISTSr_LINK_STAf_GET
#define E_MIISTSr_LINK_STAf_SET BCM53600_A0_E_MIISTSr_LINK_STAf_SET
#define E_MIISTSr_AUTO_NEGO_CAPf_GET BCM53600_A0_E_MIISTSr_AUTO_NEGO_CAPf_GET
#define E_MIISTSr_AUTO_NEGO_CAPf_SET BCM53600_A0_E_MIISTSr_AUTO_NEGO_CAPf_SET
#define E_MIISTSr_RESERVED_1f_GET BCM53600_A0_E_MIISTSr_RESERVED_1f_GET
#define E_MIISTSr_RESERVED_1f_SET BCM53600_A0_E_MIISTSr_RESERVED_1f_SET
#define E_MIISTSr_AUTO_NEGO_COMPf_GET BCM53600_A0_E_MIISTSr_AUTO_NEGO_COMPf_GET
#define E_MIISTSr_AUTO_NEGO_COMPf_SET BCM53600_A0_E_MIISTSr_AUTO_NEGO_COMPf_SET
#define E_MIISTSr_MF_PRE_SUPf_GET BCM53600_A0_E_MIISTSr_MF_PRE_SUPf_GET
#define E_MIISTSr_MF_PRE_SUPf_SET BCM53600_A0_E_MIISTSr_MF_PRE_SUPf_SET
#define E_MIISTSr_RESERVEDf_GET BCM53600_A0_E_MIISTSr_RESERVEDf_GET
#define E_MIISTSr_RESERVEDf_SET BCM53600_A0_E_MIISTSr_RESERVEDf_SET
#define E_MIISTSr_B10T_CAPf_GET BCM53600_A0_E_MIISTSr_B10T_CAPf_GET
#define E_MIISTSr_B10T_CAPf_SET BCM53600_A0_E_MIISTSr_B10T_CAPf_SET
#define E_MIISTSr_B10T_FDX_CAPf_GET BCM53600_A0_E_MIISTSr_B10T_FDX_CAPf_GET
#define E_MIISTSr_B10T_FDX_CAPf_SET BCM53600_A0_E_MIISTSr_B10T_FDX_CAPf_SET
#define E_MIISTSr_B100TX_CAPf_GET BCM53600_A0_E_MIISTSr_B100TX_CAPf_GET
#define E_MIISTSr_B100TX_CAPf_SET BCM53600_A0_E_MIISTSr_B100TX_CAPf_SET
#define E_MIISTSr_B100TX_FDX_CAPf_GET BCM53600_A0_E_MIISTSr_B100TX_FDX_CAPf_GET
#define E_MIISTSr_B100TX_FDX_CAPf_SET BCM53600_A0_E_MIISTSr_B100TX_FDX_CAPf_SET
#define E_MIISTSr_B100T4_CAPf_GET BCM53600_A0_E_MIISTSr_B100T4_CAPf_GET
#define E_MIISTSr_B100T4_CAPf_SET BCM53600_A0_E_MIISTSr_B100T4_CAPf_SET
#define READ_E_MIISTSr BCM53600_A0_READ_E_MIISTSr
#define WRITE_E_MIISTSr BCM53600_A0_WRITE_E_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_PHYIDH
 * BLOCKS:   EPIC0
 * DESC:     EXT PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.
 *
 ******************************************************************************/
#define BCM53600_A0_E_PHYIDHr 0x0000c004

#define BCM53600_A0_E_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program E_PHYIDH.
 *
 */
typedef union BCM53600_A0_E_PHYIDHr_s {
	uint32_t v[1];
	uint32_t e_phyidh[1];
	uint32_t _e_phyidh;
} BCM53600_A0_E_PHYIDHr_t;

#define BCM53600_A0_E_PHYIDHr_CLR(r) (r).e_phyidh[0] = 0
#define BCM53600_A0_E_PHYIDHr_SET(r,d) (r).e_phyidh[0] = d
#define BCM53600_A0_E_PHYIDHr_GET(r) (r).e_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_PHYIDHr_MII_ADDRf_GET(r) (((r).e_phyidh[0]) & 0xffff)
#define BCM53600_A0_E_PHYIDHr_MII_ADDRf_SET(r,f) (r).e_phyidh[0]=(((r).e_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E_PHYIDH.
 *
 */
#define BCM53600_A0_READ_E_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_PHYIDHr,(r._e_phyidh),2)
#define BCM53600_A0_WRITE_E_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_PHYIDHr,&(r._e_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_PHYIDHr BCM53600_A0_E_PHYIDHr
#define E_PHYIDHr_SIZE BCM53600_A0_E_PHYIDHr_SIZE
typedef BCM53600_A0_E_PHYIDHr_t E_PHYIDHr_t;
#define E_PHYIDHr_CLR BCM53600_A0_E_PHYIDHr_CLR
#define E_PHYIDHr_SET BCM53600_A0_E_PHYIDHr_SET
#define E_PHYIDHr_GET BCM53600_A0_E_PHYIDHr_GET
#define E_PHYIDHr_MII_ADDRf_GET BCM53600_A0_E_PHYIDHr_MII_ADDRf_GET
#define E_PHYIDHr_MII_ADDRf_SET BCM53600_A0_E_PHYIDHr_MII_ADDRf_SET
#define READ_E_PHYIDHr BCM53600_A0_READ_E_PHYIDHr
#define WRITE_E_PHYIDHr BCM53600_A0_WRITE_E_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  E_PHYIDL
 * BLOCKS:   EPIC0
 * DESC:     EXT PHY ID Low Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.Bit 3:2 - Revision ID- 00 = A- 01 = B- 10 = C- 11 = DBit 1:0 - Revision Number
 *
 ******************************************************************************/
#define BCM53600_A0_E_PHYIDLr 0x0000c006

#define BCM53600_A0_E_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program E_PHYIDL.
 *
 */
typedef union BCM53600_A0_E_PHYIDLr_s {
	uint32_t v[1];
	uint32_t e_phyidl[1];
	uint32_t _e_phyidl;
} BCM53600_A0_E_PHYIDLr_t;

#define BCM53600_A0_E_PHYIDLr_CLR(r) (r).e_phyidl[0] = 0
#define BCM53600_A0_E_PHYIDLr_SET(r,d) (r).e_phyidl[0] = d
#define BCM53600_A0_E_PHYIDLr_GET(r) (r).e_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_E_PHYIDLr_MII_ADDRf_GET(r) (((r).e_phyidl[0]) & 0xffff)
#define BCM53600_A0_E_PHYIDLr_MII_ADDRf_SET(r,f) (r).e_phyidl[0]=(((r).e_phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E_PHYIDL.
 *
 */
#define BCM53600_A0_READ_E_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_E_PHYIDLr,(r._e_phyidl),2)
#define BCM53600_A0_WRITE_E_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_E_PHYIDLr,&(r._e_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E_PHYIDLr BCM53600_A0_E_PHYIDLr
#define E_PHYIDLr_SIZE BCM53600_A0_E_PHYIDLr_SIZE
typedef BCM53600_A0_E_PHYIDLr_t E_PHYIDLr_t;
#define E_PHYIDLr_CLR BCM53600_A0_E_PHYIDLr_CLR
#define E_PHYIDLr_SET BCM53600_A0_E_PHYIDLr_SET
#define E_PHYIDLr_GET BCM53600_A0_E_PHYIDLr_GET
#define E_PHYIDLr_MII_ADDRf_GET BCM53600_A0_E_PHYIDLr_MII_ADDRf_GET
#define E_PHYIDLr_MII_ADDRf_SET BCM53600_A0_E_PHYIDLr_MII_ADDRf_SET
#define READ_E_PHYIDLr BCM53600_A0_READ_E_PHYIDLr
#define WRITE_E_PHYIDLr BCM53600_A0_WRITE_E_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_E_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  FAST_AGING_CTL
 * BLOCKS:   SYS
 * DESC:     Fast Aging Control Registers
 * SIZE:     8
 * FIELDS:
 *     AGE_MODE_CTRL    Aging Mode Control.000 = per-port, following AGE_EN_PORT[4:0] setting.001 = per-VLAN, following AGE_EN_VID[11:0] setting.010 = per-spanning tree, following SPT_AGE_EN[7:0] setting.011 = per Link Aggregation Group, following the AGE_EN_LAG[3:0] setting.100 = Fast aging all of the entries.(Not2Release).Others = Reserved.
 *     EN_AGE_STATIC_UC When set, age out Static unicast entry in the fast aging process.
 *     EN_AGE_STATIC_MC When set, age out Static multicast entry in the fast aging process.
 *     EN_AGE_DYNAMIC_UC When set, age out Dynamic unicast entry in the fast aging process.
 *     EN_AGE_DYNAMIC_MC When set, age out Dynamic multicast entry in the fast aging process.
 *     FAST_AGE_STDN    Write as 1 to initiate the fast ageing process following AGE_MODE_CTRLsetting.When fast ageing process is done, this bit will be clear to 0.
 *
 ******************************************************************************/
#define BCM53600_A0_FAST_AGING_CTLr 0x0000040b

#define BCM53600_A0_FAST_AGING_CTLr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGING_CTL.
 *
 */
typedef union BCM53600_A0_FAST_AGING_CTLr_s {
	uint32_t v[1];
	uint32_t fast_aging_ctl[1];
	uint32_t _fast_aging_ctl;
} BCM53600_A0_FAST_AGING_CTLr_t;

#define BCM53600_A0_FAST_AGING_CTLr_CLR(r) (r).fast_aging_ctl[0] = 0
#define BCM53600_A0_FAST_AGING_CTLr_SET(r,d) (r).fast_aging_ctl[0] = d
#define BCM53600_A0_FAST_AGING_CTLr_GET(r) (r).fast_aging_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_FAST_AGING_CTLr_AGE_MODE_CTRLf_GET(r) (((r).fast_aging_ctl[0]) & 0x7)
#define BCM53600_A0_FAST_AGING_CTLr_AGE_MODE_CTRLf_SET(r,f) (r).fast_aging_ctl[0]=(((r).fast_aging_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_UCf_GET(r) ((((r).fast_aging_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_UCf_SET(r,f) (r).fast_aging_ctl[0]=(((r).fast_aging_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_MCf_GET(r) ((((r).fast_aging_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_MCf_SET(r,f) (r).fast_aging_ctl[0]=(((r).fast_aging_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_UCf_GET(r) ((((r).fast_aging_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_UCf_SET(r,f) (r).fast_aging_ctl[0]=(((r).fast_aging_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_MCf_GET(r) ((((r).fast_aging_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_MCf_SET(r,f) (r).fast_aging_ctl[0]=(((r).fast_aging_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_FAST_AGING_CTLr_FAST_AGE_STDNf_GET(r) ((((r).fast_aging_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_FAST_AGING_CTLr_FAST_AGE_STDNf_SET(r,f) (r).fast_aging_ctl[0]=(((r).fast_aging_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FAST_AGING_CTL.
 *
 */
#define BCM53600_A0_READ_FAST_AGING_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_FAST_AGING_CTLr,(r._fast_aging_ctl),1)
#define BCM53600_A0_WRITE_FAST_AGING_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_FAST_AGING_CTLr,&(r._fast_aging_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGING_CTLr BCM53600_A0_FAST_AGING_CTLr
#define FAST_AGING_CTLr_SIZE BCM53600_A0_FAST_AGING_CTLr_SIZE
typedef BCM53600_A0_FAST_AGING_CTLr_t FAST_AGING_CTLr_t;
#define FAST_AGING_CTLr_CLR BCM53600_A0_FAST_AGING_CTLr_CLR
#define FAST_AGING_CTLr_SET BCM53600_A0_FAST_AGING_CTLr_SET
#define FAST_AGING_CTLr_GET BCM53600_A0_FAST_AGING_CTLr_GET
#define FAST_AGING_CTLr_AGE_MODE_CTRLf_GET BCM53600_A0_FAST_AGING_CTLr_AGE_MODE_CTRLf_GET
#define FAST_AGING_CTLr_AGE_MODE_CTRLf_SET BCM53600_A0_FAST_AGING_CTLr_AGE_MODE_CTRLf_SET
#define FAST_AGING_CTLr_EN_AGE_STATIC_UCf_GET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_UCf_GET
#define FAST_AGING_CTLr_EN_AGE_STATIC_UCf_SET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_UCf_SET
#define FAST_AGING_CTLr_EN_AGE_STATIC_MCf_GET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_MCf_GET
#define FAST_AGING_CTLr_EN_AGE_STATIC_MCf_SET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_STATIC_MCf_SET
#define FAST_AGING_CTLr_EN_AGE_DYNAMIC_UCf_GET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_UCf_GET
#define FAST_AGING_CTLr_EN_AGE_DYNAMIC_UCf_SET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_UCf_SET
#define FAST_AGING_CTLr_EN_AGE_DYNAMIC_MCf_GET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_MCf_GET
#define FAST_AGING_CTLr_EN_AGE_DYNAMIC_MCf_SET BCM53600_A0_FAST_AGING_CTLr_EN_AGE_DYNAMIC_MCf_SET
#define FAST_AGING_CTLr_FAST_AGE_STDNf_GET BCM53600_A0_FAST_AGING_CTLr_FAST_AGE_STDNf_GET
#define FAST_AGING_CTLr_FAST_AGE_STDNf_SET BCM53600_A0_FAST_AGING_CTLr_FAST_AGE_STDNf_SET
#define READ_FAST_AGING_CTLr BCM53600_A0_READ_FAST_AGING_CTLr
#define WRITE_FAST_AGING_CTLr BCM53600_A0_WRITE_FAST_AGING_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_FAST_AGING_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  FM_SIZE_CTL
 * BLOCKS:   SYS
 * DESC:     Frame Size Control Register
 * SIZE:     8
 * FIELDS:
 *     STD_MAX_FM_SIZE  Standard Max Frame SizeDefines the standard maximum frame size for MAC and MIB counter.This register is used to define good frame length.0 : 1518-byte1 : 2000-byte
 *     JUMBO_FM_SIZE    Jumbo Frame Size. The Maximum length limit to receive/transmit a packet.00 = Max 2032-byte for all received packet, max 2048-byte for transmit packet.01 = Max 9712-byte for all received packet, max 9728-byte for transmit packet.10 = Max (12K-16)byte for all received packet, max 12K-byte for transmit packet.(Internal reference only)(Not2Release)11 = Reserved
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_FM_SIZE_CTLr 0x00000001

#define BCM53600_A0_FM_SIZE_CTLr_SIZE 1

/*
 * This structure should be used to declare and program FM_SIZE_CTL.
 *
 */
typedef union BCM53600_A0_FM_SIZE_CTLr_s {
	uint32_t v[1];
	uint32_t fm_size_ctl[1];
	uint32_t _fm_size_ctl;
} BCM53600_A0_FM_SIZE_CTLr_t;

#define BCM53600_A0_FM_SIZE_CTLr_CLR(r) (r).fm_size_ctl[0] = 0
#define BCM53600_A0_FM_SIZE_CTLr_SET(r,d) (r).fm_size_ctl[0] = d
#define BCM53600_A0_FM_SIZE_CTLr_GET(r) (r).fm_size_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_FM_SIZE_CTLr_STD_MAX_FM_SIZEf_GET(r) (((r).fm_size_ctl[0]) & 0x1)
#define BCM53600_A0_FM_SIZE_CTLr_STD_MAX_FM_SIZEf_SET(r,f) (r).fm_size_ctl[0]=(((r).fm_size_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_FM_SIZE_CTLr_JUMBO_FM_SIZEf_GET(r) ((((r).fm_size_ctl[0]) >> 1) & 0x3)
#define BCM53600_A0_FM_SIZE_CTLr_JUMBO_FM_SIZEf_SET(r,f) (r).fm_size_ctl[0]=(((r).fm_size_ctl[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53600_A0_FM_SIZE_CTLr_RESERVEDf_GET(r) ((((r).fm_size_ctl[0]) >> 3) & 0x1f)
#define BCM53600_A0_FM_SIZE_CTLr_RESERVEDf_SET(r,f) (r).fm_size_ctl[0]=(((r).fm_size_ctl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access FM_SIZE_CTL.
 *
 */
#define BCM53600_A0_READ_FM_SIZE_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_FM_SIZE_CTLr,(r._fm_size_ctl),1)
#define BCM53600_A0_WRITE_FM_SIZE_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_FM_SIZE_CTLr,&(r._fm_size_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FM_SIZE_CTLr BCM53600_A0_FM_SIZE_CTLr
#define FM_SIZE_CTLr_SIZE BCM53600_A0_FM_SIZE_CTLr_SIZE
typedef BCM53600_A0_FM_SIZE_CTLr_t FM_SIZE_CTLr_t;
#define FM_SIZE_CTLr_CLR BCM53600_A0_FM_SIZE_CTLr_CLR
#define FM_SIZE_CTLr_SET BCM53600_A0_FM_SIZE_CTLr_SET
#define FM_SIZE_CTLr_GET BCM53600_A0_FM_SIZE_CTLr_GET
#define FM_SIZE_CTLr_STD_MAX_FM_SIZEf_GET BCM53600_A0_FM_SIZE_CTLr_STD_MAX_FM_SIZEf_GET
#define FM_SIZE_CTLr_STD_MAX_FM_SIZEf_SET BCM53600_A0_FM_SIZE_CTLr_STD_MAX_FM_SIZEf_SET
#define FM_SIZE_CTLr_JUMBO_FM_SIZEf_GET BCM53600_A0_FM_SIZE_CTLr_JUMBO_FM_SIZEf_GET
#define FM_SIZE_CTLr_JUMBO_FM_SIZEf_SET BCM53600_A0_FM_SIZE_CTLr_JUMBO_FM_SIZEf_SET
#define FM_SIZE_CTLr_RESERVEDf_GET BCM53600_A0_FM_SIZE_CTLr_RESERVEDf_GET
#define FM_SIZE_CTLr_RESERVEDf_SET BCM53600_A0_FM_SIZE_CTLr_RESERVEDf_SET
#define READ_FM_SIZE_CTLr BCM53600_A0_READ_FM_SIZE_CTLr
#define WRITE_FM_SIZE_CTLr BCM53600_A0_WRITE_FM_SIZE_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_FM_SIZE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  FRAMEBUF
 * BLOCKS:   SYS
 * DESC:     Frame Buffer Memory
 * SIZE:     256
 * FIELDS:
 *     FRM_63_0         Network Form display to Canonical form: B63-B0
 *     FRM_127_64       B127-B64
 *     FRM_191_128      B191-B128
 *     FRM_255_192      B255-B192
 *
 ******************************************************************************/
#define BCM53600_A0_FRAMEBUFm 0x00000000

#define BCM53600_A0_FRAMEBUFm_MIN 0
#define BCM53600_A0_FRAMEBUFm_MAX 49151
#define BCM53600_A0_FRAMEBUFm_CMAX(u) 49151
#define BCM53600_A0_FRAMEBUFm_SIZE 32

/*
 * This structure should be used to declare and program FRAMEBUF.
 *
 */
typedef union BCM53600_A0_FRAMEBUFm_s {
	uint32_t v[8];
	uint32_t framebuf[8];
	uint32_t _framebuf;
} BCM53600_A0_FRAMEBUFm_t;

#define BCM53600_A0_FRAMEBUFm_CLR(r) CDK_MEMSET(&((r)._framebuf), 0, sizeof(BCM53600_A0_FRAMEBUFm_t))
#define BCM53600_A0_FRAMEBUFm_SET(r,i,d) (r).framebuf[i] = d
#define BCM53600_A0_FRAMEBUFm_GET(r,i) (r).framebuf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_FRAMEBUFm_FRM_63_0f_GET(r,a) cdk_field_get((r).framebuf,0,63,a)
#define BCM53600_A0_FRAMEBUFm_FRM_63_0f_SET(r,a) cdk_field_set((r).framebuf,0,63,a)
#define BCM53600_A0_FRAMEBUFm_FRM_127_64f_GET(r,a) cdk_field_get((r).framebuf,64,127,a)
#define BCM53600_A0_FRAMEBUFm_FRM_127_64f_SET(r,a) cdk_field_set((r).framebuf,64,127,a)
#define BCM53600_A0_FRAMEBUFm_FRM_191_128f_GET(r,a) cdk_field_get((r).framebuf,128,191,a)
#define BCM53600_A0_FRAMEBUFm_FRM_191_128f_SET(r,a) cdk_field_set((r).framebuf,128,191,a)
#define BCM53600_A0_FRAMEBUFm_FRM_255_192f_GET(r,a) cdk_field_get((r).framebuf,192,255,a)
#define BCM53600_A0_FRAMEBUFm_FRM_255_192f_SET(r,a) cdk_field_set((r).framebuf,192,255,a)

/*
 * These macros can be used to access FRAMEBUF.
 *
 */
#define BCM53600_A0_READ_FRAMEBUFm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_FRAMEBUFm,i,(m),32)
#define BCM53600_A0_WRITE_FRAMEBUFm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_FRAMEBUFm,i,&(m),32)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FRAMEBUFm BCM53600_A0_FRAMEBUFm
#define FRAMEBUFm_MIN BCM53600_A0_FRAMEBUFm_MIN
#define FRAMEBUFm_MAX BCM53600_A0_FRAMEBUFm_MAX
#define FRAMEBUFm_CMAX(u) BCM53600_A0_FRAMEBUFm_CMAX(u)
#define FRAMEBUFm_SIZE BCM53600_A0_FRAMEBUFm_SIZE
typedef BCM53600_A0_FRAMEBUFm_t FRAMEBUFm_t;
#define FRAMEBUFm_CLR BCM53600_A0_FRAMEBUFm_CLR
#define FRAMEBUFm_SET BCM53600_A0_FRAMEBUFm_SET
#define FRAMEBUFm_GET BCM53600_A0_FRAMEBUFm_GET
#define FRAMEBUFm_FRM_63_0f_GET BCM53600_A0_FRAMEBUFm_FRM_63_0f_GET
#define FRAMEBUFm_FRM_63_0f_SET BCM53600_A0_FRAMEBUFm_FRM_63_0f_SET
#define FRAMEBUFm_FRM_127_64f_GET BCM53600_A0_FRAMEBUFm_FRM_127_64f_GET
#define FRAMEBUFm_FRM_127_64f_SET BCM53600_A0_FRAMEBUFm_FRM_127_64f_SET
#define FRAMEBUFm_FRM_191_128f_GET BCM53600_A0_FRAMEBUFm_FRM_191_128f_GET
#define FRAMEBUFm_FRM_191_128f_SET BCM53600_A0_FRAMEBUFm_FRM_191_128f_SET
#define FRAMEBUFm_FRM_255_192f_GET BCM53600_A0_FRAMEBUFm_FRM_255_192f_GET
#define FRAMEBUFm_FRM_255_192f_SET BCM53600_A0_FRAMEBUFm_FRM_255_192f_SET
#define READ_FRAMEBUFm BCM53600_A0_READ_FRAMEBUFm
#define WRITE_FRAMEBUFm BCM53600_A0_WRITE_FRAMEBUFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_FRAMEBUFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable the hash function for the ARL such that entries are direct mapped to the table. The hash function is enabled as the default for the Thunderbolt ARL, but can be disabled by setting this bit.(Not2Release)
 *     GLB_SA_LRN_CTRL  Global SA learning disable.1 = SA learning is disable.0 = SA learning is not disable.
 *     AGE_ACC          Test only.  Not to release to customers.(Not2Release)
 *     GARLCFG_RSRV0    Reserved
 *     MPADDR_EN        1: L2 User Address Enable. When set 1 by the host, enables the L2 User Address 1 and 2 registers, and their associated L2 User Vector 1 and 2 registers. This enables these registers in the ARL search.Note that if only one multiport address is required, the host should write both L2 User Address/Vector entries to the same value.
 *     GARLCFG_RSRV1    Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_GARLCFGr 0x00000400

#define BCM53600_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 *
 */
typedef union BCM53600_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM53600_A0_GARLCFGr_t;

#define BCM53600_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM53600_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM53600_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM53600_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_GARLCFGr_GLB_SA_LRN_CTRLf_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM53600_A0_GARLCFGr_GLB_SA_LRN_CTRLf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM53600_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_GARLCFGr_GARLCFG_RSRV0f_GET(r) ((((r).garlcfg[0]) >> 3) & 0x1)
#define BCM53600_A0_GARLCFGr_GARLCFG_RSRV0f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_GARLCFGr_MPADDR_ENf_GET(r) ((((r).garlcfg[0]) >> 4) & 0x1)
#define BCM53600_A0_GARLCFGr_MPADDR_ENf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_GARLCFGr_GARLCFG_RSRV1f_GET(r) ((((r).garlcfg[0]) >> 5) & 0x7)
#define BCM53600_A0_GARLCFGr_GARLCFG_RSRV1f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access GARLCFG.
 *
 */
#define BCM53600_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GARLCFGr,(r._garlcfg),1)
#define BCM53600_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM53600_A0_GARLCFGr
#define GARLCFGr_SIZE BCM53600_A0_GARLCFGr_SIZE
typedef BCM53600_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM53600_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM53600_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM53600_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM53600_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM53600_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_GLB_SA_LRN_CTRLf_GET BCM53600_A0_GARLCFGr_GLB_SA_LRN_CTRLf_GET
#define GARLCFGr_GLB_SA_LRN_CTRLf_SET BCM53600_A0_GARLCFGr_GLB_SA_LRN_CTRLf_SET
#define GARLCFGr_AGE_ACCf_GET BCM53600_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM53600_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_GARLCFG_RSRV0f_GET BCM53600_A0_GARLCFGr_GARLCFG_RSRV0f_GET
#define GARLCFGr_GARLCFG_RSRV0f_SET BCM53600_A0_GARLCFGr_GARLCFG_RSRV0f_SET
#define GARLCFGr_MPADDR_ENf_GET BCM53600_A0_GARLCFGr_MPADDR_ENf_GET
#define GARLCFGr_MPADDR_ENf_SET BCM53600_A0_GARLCFGr_MPADDR_ENf_SET
#define GARLCFGr_GARLCFG_RSRV1f_GET BCM53600_A0_GARLCFGr_GARLCFG_RSRV1f_GET
#define GARLCFGr_GARLCFG_RSRV1f_SET BCM53600_A0_GARLCFGr_GARLCFG_RSRV1f_SET
#define READ_GARLCFGr BCM53600_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM53600_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GARLCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GLB_OVERFLOW_DROP_PKT_CNT
 * BLOCKS:   SYS
 * DESC:     Global Overflow Drop Packet Counter Register
 * SIZE:     32
 * FIELDS:
 *     GLB_OVERFLOW_DROP_PKT Packet Drop Count due to Global Buffer overflow (limit reached).
 *
 ******************************************************************************/
#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr 0x00005044

#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GLB_OVERFLOW_DROP_PKT_CNT.
 *
 */
typedef union BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_s {
	uint32_t v[1];
	uint32_t glb_overflow_drop_pkt_cnt[1];
	uint32_t _glb_overflow_drop_pkt_cnt;
} BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_t;

#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_CLR(r) (r).glb_overflow_drop_pkt_cnt[0] = 0
#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_SET(r,d) (r).glb_overflow_drop_pkt_cnt[0] = d
#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_GET(r) (r).glb_overflow_drop_pkt_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_GLB_OVERFLOW_DROP_PKTf_GET(r) ((r).glb_overflow_drop_pkt_cnt[0])
#define BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_GLB_OVERFLOW_DROP_PKTf_SET(r,f) (r).glb_overflow_drop_pkt_cnt[0]=((uint32_t)f)

/*
 * These macros can be used to access GLB_OVERFLOW_DROP_PKT_CNT.
 *
 */
#define BCM53600_A0_READ_GLB_OVERFLOW_DROP_PKT_CNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr,(r._glb_overflow_drop_pkt_cnt),4)
#define BCM53600_A0_WRITE_GLB_OVERFLOW_DROP_PKT_CNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr,&(r._glb_overflow_drop_pkt_cnt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLB_OVERFLOW_DROP_PKT_CNTr BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr
#define GLB_OVERFLOW_DROP_PKT_CNTr_SIZE BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_SIZE
typedef BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_t GLB_OVERFLOW_DROP_PKT_CNTr_t;
#define GLB_OVERFLOW_DROP_PKT_CNTr_CLR BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_CLR
#define GLB_OVERFLOW_DROP_PKT_CNTr_SET BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_SET
#define GLB_OVERFLOW_DROP_PKT_CNTr_GET BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_GET
#define GLB_OVERFLOW_DROP_PKT_CNTr_GLB_OVERFLOW_DROP_PKTf_GET BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_GLB_OVERFLOW_DROP_PKTf_GET
#define GLB_OVERFLOW_DROP_PKT_CNTr_GLB_OVERFLOW_DROP_PKTf_SET BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr_GLB_OVERFLOW_DROP_PKTf_SET
#define READ_GLB_OVERFLOW_DROP_PKT_CNTr BCM53600_A0_READ_GLB_OVERFLOW_DROP_PKT_CNTr
#define WRITE_GLB_OVERFLOW_DROP_PKT_CNTr BCM53600_A0_WRITE_GLB_OVERFLOW_DROP_PKT_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GLB_OVERFLOW_DROP_PKT_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GLB_VLAN_ING_FILTER_CTL
 * BLOCKS:   SYS
 * DESC:     Global VLAN Ingress Filter Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_NONMEMBER_CPUCOPY NonMember: The ingress port is not a member of the VLAN the receivedpacket is associated with.1 = Enable to copy to IMP port.0 = Do not enable to copy to IMP port.
 *     DIS_LRN_NONMEMBER NonMember: The ingress port is not a member of the VLAN the receivedpacket is associated with.1 = Disable learn the packet.0 = Do not disable learn the packet.
 *     EN_UNREGISTERED_CPUCOPY UnRegistered: The VLAN of the received packet is associated with isnot a registered VLAN.1 = Enable to copy to IMP port.0 = Do not enable to copy to IMP port.
 *     DIS_LRN_UNREGISTERED UnRegistered: The VLAN of the received packet is associated with isnot a registered VLAN.1 = Disable learn the packet.0 = Do not disable learn the packet.
 *     EN_UNREGISTERED_DROP UnRegistered: The VLAN of the received packet is associated with isnot a registered VLAN.1 = Drop the packet.0 = Do not drop the packet.When UnRegistered packets are not configured to be dropped, theirforwarding is not subject to VLAN ingress/egress filter checking.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr 0x00003448

#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_SIZE 1

/*
 * This structure should be used to declare and program GLB_VLAN_ING_FILTER_CTL.
 *
 */
typedef union BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_s {
	uint32_t v[1];
	uint32_t glb_vlan_ing_filter_ctl[1];
	uint32_t _glb_vlan_ing_filter_ctl;
} BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_t;

#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_CLR(r) (r).glb_vlan_ing_filter_ctl[0] = 0
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_SET(r,d) (r).glb_vlan_ing_filter_ctl[0] = d
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_GET(r) (r).glb_vlan_ing_filter_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_NONMEMBER_CPUCOPYf_GET(r) (((r).glb_vlan_ing_filter_ctl[0]) & 0x1)
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_NONMEMBER_CPUCOPYf_SET(r,f) (r).glb_vlan_ing_filter_ctl[0]=(((r).glb_vlan_ing_filter_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_NONMEMBERf_GET(r) ((((r).glb_vlan_ing_filter_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_NONMEMBERf_SET(r,f) (r).glb_vlan_ing_filter_ctl[0]=(((r).glb_vlan_ing_filter_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_CPUCOPYf_GET(r) ((((r).glb_vlan_ing_filter_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_CPUCOPYf_SET(r,f) (r).glb_vlan_ing_filter_ctl[0]=(((r).glb_vlan_ing_filter_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_UNREGISTEREDf_GET(r) ((((r).glb_vlan_ing_filter_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_UNREGISTEREDf_SET(r,f) (r).glb_vlan_ing_filter_ctl[0]=(((r).glb_vlan_ing_filter_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_DROPf_GET(r) ((((r).glb_vlan_ing_filter_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_DROPf_SET(r,f) (r).glb_vlan_ing_filter_ctl[0]=(((r).glb_vlan_ing_filter_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_RESERVEDf_GET(r) ((((r).glb_vlan_ing_filter_ctl[0]) >> 5) & 0x7)
#define BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_RESERVEDf_SET(r,f) (r).glb_vlan_ing_filter_ctl[0]=(((r).glb_vlan_ing_filter_ctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access GLB_VLAN_ING_FILTER_CTL.
 *
 */
#define BCM53600_A0_READ_GLB_VLAN_ING_FILTER_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr,(r._glb_vlan_ing_filter_ctl),1)
#define BCM53600_A0_WRITE_GLB_VLAN_ING_FILTER_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr,&(r._glb_vlan_ing_filter_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLB_VLAN_ING_FILTER_CTLr BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr
#define GLB_VLAN_ING_FILTER_CTLr_SIZE BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_SIZE
typedef BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_t GLB_VLAN_ING_FILTER_CTLr_t;
#define GLB_VLAN_ING_FILTER_CTLr_CLR BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_CLR
#define GLB_VLAN_ING_FILTER_CTLr_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_SET
#define GLB_VLAN_ING_FILTER_CTLr_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_GET
#define GLB_VLAN_ING_FILTER_CTLr_EN_NONMEMBER_CPUCOPYf_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_NONMEMBER_CPUCOPYf_GET
#define GLB_VLAN_ING_FILTER_CTLr_EN_NONMEMBER_CPUCOPYf_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_NONMEMBER_CPUCOPYf_SET
#define GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_NONMEMBERf_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_NONMEMBERf_GET
#define GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_NONMEMBERf_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_NONMEMBERf_SET
#define GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_CPUCOPYf_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_CPUCOPYf_GET
#define GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_CPUCOPYf_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_CPUCOPYf_SET
#define GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_UNREGISTEREDf_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_UNREGISTEREDf_GET
#define GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_UNREGISTEREDf_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_DIS_LRN_UNREGISTEREDf_SET
#define GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_DROPf_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_DROPf_GET
#define GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_DROPf_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_EN_UNREGISTERED_DROPf_SET
#define GLB_VLAN_ING_FILTER_CTLr_RESERVEDf_GET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_RESERVEDf_GET
#define GLB_VLAN_ING_FILTER_CTLr_RESERVEDf_SET BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr_RESERVEDf_SET
#define READ_GLB_VLAN_ING_FILTER_CTLr BCM53600_A0_READ_GLB_VLAN_ING_FILTER_CTLr
#define WRITE_GLB_VLAN_ING_FILTER_CTLr BCM53600_A0_WRITE_GLB_VLAN_ING_FILTER_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GLB_VLAN_ING_FILTER_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GLOBAL_CONGESTION_CTRL
 * BLOCKS:   SYS
 * DESC:     Congestion Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     EN_RC_CM         1 = Enable read-and-clear operation on the registers of "XOFF port history"and "Peak xx Buffer used Count".(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr 0x00000a00

#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program GLOBAL_CONGESTION_CTRL.
 *
 */
typedef union BCM53600_A0_GLOBAL_CONGESTION_CTRLr_s {
	uint32_t v[1];
	uint32_t global_congestion_ctrl[1];
	uint32_t _global_congestion_ctrl;
} BCM53600_A0_GLOBAL_CONGESTION_CTRLr_t;

#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_CLR(r) (r).global_congestion_ctrl[0] = 0
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_SET(r,d) (r).global_congestion_ctrl[0] = d
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_GET(r) (r).global_congestion_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_EN_RC_CMf_GET(r) (((r).global_congestion_ctrl[0]) & 0x1)
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_EN_RC_CMf_SET(r,f) (r).global_congestion_ctrl[0]=(((r).global_congestion_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_RESERVEDf_GET(r) ((((r).global_congestion_ctrl[0]) >> 1) & 0x7f)
#define BCM53600_A0_GLOBAL_CONGESTION_CTRLr_RESERVEDf_SET(r,f) (r).global_congestion_ctrl[0]=(((r).global_congestion_ctrl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access GLOBAL_CONGESTION_CTRL.
 *
 */
#define BCM53600_A0_READ_GLOBAL_CONGESTION_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GLOBAL_CONGESTION_CTRLr,(r._global_congestion_ctrl),1)
#define BCM53600_A0_WRITE_GLOBAL_CONGESTION_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GLOBAL_CONGESTION_CTRLr,&(r._global_congestion_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLOBAL_CONGESTION_CTRLr BCM53600_A0_GLOBAL_CONGESTION_CTRLr
#define GLOBAL_CONGESTION_CTRLr_SIZE BCM53600_A0_GLOBAL_CONGESTION_CTRLr_SIZE
typedef BCM53600_A0_GLOBAL_CONGESTION_CTRLr_t GLOBAL_CONGESTION_CTRLr_t;
#define GLOBAL_CONGESTION_CTRLr_CLR BCM53600_A0_GLOBAL_CONGESTION_CTRLr_CLR
#define GLOBAL_CONGESTION_CTRLr_SET BCM53600_A0_GLOBAL_CONGESTION_CTRLr_SET
#define GLOBAL_CONGESTION_CTRLr_GET BCM53600_A0_GLOBAL_CONGESTION_CTRLr_GET
#define GLOBAL_CONGESTION_CTRLr_EN_RC_CMf_GET BCM53600_A0_GLOBAL_CONGESTION_CTRLr_EN_RC_CMf_GET
#define GLOBAL_CONGESTION_CTRLr_EN_RC_CMf_SET BCM53600_A0_GLOBAL_CONGESTION_CTRLr_EN_RC_CMf_SET
#define GLOBAL_CONGESTION_CTRLr_RESERVEDf_GET BCM53600_A0_GLOBAL_CONGESTION_CTRLr_RESERVEDf_GET
#define GLOBAL_CONGESTION_CTRLr_RESERVEDf_SET BCM53600_A0_GLOBAL_CONGESTION_CTRLr_RESERVEDf_SET
#define READ_GLOBAL_CONGESTION_CTRLr BCM53600_A0_READ_GLOBAL_CONGESTION_CTRLr
#define WRITE_GLOBAL_CONGESTION_CTRLr BCM53600_A0_WRITE_GLOBAL_CONGESTION_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GLOBAL_CONGESTION_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GLOBAL_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     Global Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     GLOBAL_TRUNK_CTL_RSRV0 Reserved.
 *     EN_TRUNK_LOCAL   Enable Trunk feature : boot 10/100 and Giga.
 *     GLOBAL_TRUNK_CTL_RSRV1 Reserved
 *     TRUNK_SEED       Trunk hash index selection.bit 7 : IP_SIPbit 6 : IP_DIPbit 5 : MAC_SAbit 4 : MAC_DA
 *
 ******************************************************************************/
#define BCM53600_A0_GLOBAL_TRUNK_CTLr 0x00003100

#define BCM53600_A0_GLOBAL_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program GLOBAL_TRUNK_CTL.
 *
 */
typedef union BCM53600_A0_GLOBAL_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t global_trunk_ctl[1];
	uint32_t _global_trunk_ctl;
} BCM53600_A0_GLOBAL_TRUNK_CTLr_t;

#define BCM53600_A0_GLOBAL_TRUNK_CTLr_CLR(r) (r).global_trunk_ctl[0] = 0
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_SET(r,d) (r).global_trunk_ctl[0] = d
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_GET(r) (r).global_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_GET(r) (((r).global_trunk_ctl[0]) & 0x1)
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).global_trunk_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_GET(r) ((((r).global_trunk_ctl[0]) >> 2) & 0x3)
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET(r) ((((r).global_trunk_ctl[0]) >> 4) & 0xf)
#define BCM53600_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access GLOBAL_TRUNK_CTL.
 *
 */
#define BCM53600_A0_READ_GLOBAL_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GLOBAL_TRUNK_CTLr,(r._global_trunk_ctl),1)
#define BCM53600_A0_WRITE_GLOBAL_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GLOBAL_TRUNK_CTLr,&(r._global_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLOBAL_TRUNK_CTLr BCM53600_A0_GLOBAL_TRUNK_CTLr
#define GLOBAL_TRUNK_CTLr_SIZE BCM53600_A0_GLOBAL_TRUNK_CTLr_SIZE
typedef BCM53600_A0_GLOBAL_TRUNK_CTLr_t GLOBAL_TRUNK_CTLr_t;
#define GLOBAL_TRUNK_CTLr_CLR BCM53600_A0_GLOBAL_TRUNK_CTLr_CLR
#define GLOBAL_TRUNK_CTLr_SET BCM53600_A0_GLOBAL_TRUNK_CTLr_SET
#define GLOBAL_TRUNK_CTLr_GET BCM53600_A0_GLOBAL_TRUNK_CTLr_GET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_GET BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_GET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_SET BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_SET
#define GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM53600_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM53600_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_GET BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_GET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_SET BCM53600_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_SET
#define GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET BCM53600_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET
#define GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET BCM53600_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET
#define READ_GLOBAL_TRUNK_CTLr BCM53600_A0_READ_GLOBAL_TRUNK_CTLr
#define WRITE_GLOBAL_TRUNK_CTLr BCM53600_A0_WRITE_GLOBAL_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GLOBAL_TRUNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     EN_CPU_RX_BYPASS_CRCCHK When set to 1, The management port(IMP port) with CPU on it will ignorethe CRC checking(BRCM tag frame, or Ethernet frame).When set to 0, The management port will check CRC.
 *     RX_BPDU_EN       Receive BPDU Enable.To indicate BPDU CPUCopy is enabled or not in manage mode.1 = Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.0 = Drop BPDU packet.
 *     EN_VPORT_REPLICATION 1 = Enable Virtual Port Multicast Replication.0 = Disable Virtual Port Multicast Replication.
 *     IGMP_MLD_CHK     00 : IGMP/MLD snooping is disabled. (default)01 : IGMP/MLD snooping is enabled. IGMP/MLD packet will be forwarded to IMP port only.11 : IGMP/MLD snooping is enabled. IGMP/MLD packet will be forwarded its original port forwarding map in addition to IMP port.
 *     RESERVED_2       Reserved.
 *     FRM_MNGP         Frame Management Port.Defines the physical port used to report management frames directed to the switch.00=No Management Port01=Reserved10=MII Port (In-band Management Port - IMP)11=ReservedThese bits are ignored when SW_FWD_MODE=Unmanaged in the Switch Mode Register, and the device will behave as if there is no defined management port.
 *
 ******************************************************************************/
#define BCM53600_A0_GMNGCFGr 0x00000300

#define BCM53600_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 *
 */
typedef union BCM53600_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM53600_A0_GMNGCFGr_t;

#define BCM53600_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM53600_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM53600_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GMNGCFGr_EN_CPU_RX_BYPASS_CRCCHKf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM53600_A0_GMNGCFGr_EN_CPU_RX_BYPASS_CRCCHKf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_GMNGCFGr_RX_BPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM53600_A0_GMNGCFGr_RX_BPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_GMNGCFGr_EN_VPORT_REPLICATIONf_GET(r) ((((r).gmngcfg[0]) >> 2) & 0x1)
#define BCM53600_A0_GMNGCFGr_EN_VPORT_REPLICATIONf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_GMNGCFGr_IGMP_MLD_CHKf_GET(r) ((((r).gmngcfg[0]) >> 3) & 0x3)
#define BCM53600_A0_GMNGCFGr_IGMP_MLD_CHKf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53600_A0_GMNGCFGr_RESERVED_2f_GET(r) ((((r).gmngcfg[0]) >> 5) & 0x1)
#define BCM53600_A0_GMNGCFGr_RESERVED_2f_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM53600_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 *
 */
#define BCM53600_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM53600_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM53600_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM53600_A0_GMNGCFGr_SIZE
typedef BCM53600_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM53600_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM53600_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM53600_A0_GMNGCFGr_GET
#define GMNGCFGr_EN_CPU_RX_BYPASS_CRCCHKf_GET BCM53600_A0_GMNGCFGr_EN_CPU_RX_BYPASS_CRCCHKf_GET
#define GMNGCFGr_EN_CPU_RX_BYPASS_CRCCHKf_SET BCM53600_A0_GMNGCFGr_EN_CPU_RX_BYPASS_CRCCHKf_SET
#define GMNGCFGr_RX_BPDU_ENf_GET BCM53600_A0_GMNGCFGr_RX_BPDU_ENf_GET
#define GMNGCFGr_RX_BPDU_ENf_SET BCM53600_A0_GMNGCFGr_RX_BPDU_ENf_SET
#define GMNGCFGr_EN_VPORT_REPLICATIONf_GET BCM53600_A0_GMNGCFGr_EN_VPORT_REPLICATIONf_GET
#define GMNGCFGr_EN_VPORT_REPLICATIONf_SET BCM53600_A0_GMNGCFGr_EN_VPORT_REPLICATIONf_SET
#define GMNGCFGr_IGMP_MLD_CHKf_GET BCM53600_A0_GMNGCFGr_IGMP_MLD_CHKf_GET
#define GMNGCFGr_IGMP_MLD_CHKf_SET BCM53600_A0_GMNGCFGr_IGMP_MLD_CHKf_SET
#define GMNGCFGr_RESERVED_2f_GET BCM53600_A0_GMNGCFGr_RESERVED_2f_GET
#define GMNGCFGr_RESERVED_2f_SET BCM53600_A0_GMNGCFGr_RESERVED_2f_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM53600_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM53600_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM53600_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM53600_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GMNGCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GROUP_CTRL
 * BLOCKS:   SYS
 * DESC:     Group Control Register
 * SIZE:     8
 * FIELDS:
 *     ALL_IND          1 = The command is operated in all of the related tables.It is used for CFP/IVM/EVM Move operation only.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_GROUP_CTRLr 0x00000809

#define BCM53600_A0_GROUP_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program GROUP_CTRL.
 *
 */
typedef union BCM53600_A0_GROUP_CTRLr_s {
	uint32_t v[1];
	uint32_t group_ctrl[1];
	uint32_t _group_ctrl;
} BCM53600_A0_GROUP_CTRLr_t;

#define BCM53600_A0_GROUP_CTRLr_CLR(r) (r).group_ctrl[0] = 0
#define BCM53600_A0_GROUP_CTRLr_SET(r,d) (r).group_ctrl[0] = d
#define BCM53600_A0_GROUP_CTRLr_GET(r) (r).group_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GROUP_CTRLr_ALL_INDf_GET(r) (((r).group_ctrl[0]) & 0x1)
#define BCM53600_A0_GROUP_CTRLr_ALL_INDf_SET(r,f) (r).group_ctrl[0]=(((r).group_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_GROUP_CTRLr_RESERVEDf_GET(r) ((((r).group_ctrl[0]) >> 1) & 0x7f)
#define BCM53600_A0_GROUP_CTRLr_RESERVEDf_SET(r,f) (r).group_ctrl[0]=(((r).group_ctrl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access GROUP_CTRL.
 *
 */
#define BCM53600_A0_READ_GROUP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_GROUP_CTRLr,(r._group_ctrl),1)
#define BCM53600_A0_WRITE_GROUP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_GROUP_CTRLr,&(r._group_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GROUP_CTRLr BCM53600_A0_GROUP_CTRLr
#define GROUP_CTRLr_SIZE BCM53600_A0_GROUP_CTRLr_SIZE
typedef BCM53600_A0_GROUP_CTRLr_t GROUP_CTRLr_t;
#define GROUP_CTRLr_CLR BCM53600_A0_GROUP_CTRLr_CLR
#define GROUP_CTRLr_SET BCM53600_A0_GROUP_CTRLr_SET
#define GROUP_CTRLr_GET BCM53600_A0_GROUP_CTRLr_GET
#define GROUP_CTRLr_ALL_INDf_GET BCM53600_A0_GROUP_CTRLr_ALL_INDf_GET
#define GROUP_CTRLr_ALL_INDf_SET BCM53600_A0_GROUP_CTRLr_ALL_INDf_SET
#define GROUP_CTRLr_RESERVEDf_GET BCM53600_A0_GROUP_CTRLr_RESERVEDf_GET
#define GROUP_CTRLr_RESERVEDf_SET BCM53600_A0_GROUP_CTRLr_RESERVEDf_SET
#define READ_GROUP_CTRLr BCM53600_A0_READ_GROUP_CTRLr
#define WRITE_GROUP_CTRLr BCM53600_A0_WRITE_GROUP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GROUP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GRPADDR1
 * BLOCKS:   SYS
 * DESC:     L2 User Address 1 Register
 * SIZE:     48
 * FIELDS:
 *     GRP_ADDR         L2 User Address 1Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the L2 User Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *
 ******************************************************************************/
#define BCM53600_A0_GRPADDR1r 0x00000410

#define BCM53600_A0_GRPADDR1r_SIZE 6

/*
 * This structure should be used to declare and program GRPADDR1.
 *
 */
typedef union BCM53600_A0_GRPADDR1r_s {
	uint32_t v[2];
	uint32_t grpaddr1[2];
	uint32_t _grpaddr1;
} BCM53600_A0_GRPADDR1r_t;

#define BCM53600_A0_GRPADDR1r_CLR(r) CDK_MEMSET(&((r)._grpaddr1), 0, sizeof(BCM53600_A0_GRPADDR1r_t))
#define BCM53600_A0_GRPADDR1r_SET(r,i,d) (r).grpaddr1[i] = d
#define BCM53600_A0_GRPADDR1r_GET(r,i) (r).grpaddr1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GRPADDR1r_GRP_ADDRf_GET(r,a) cdk_field_get((r).grpaddr1,0,47,a)
#define BCM53600_A0_GRPADDR1r_GRP_ADDRf_SET(r,a) cdk_field_set((r).grpaddr1,0,47,a)

/*
 * These macros can be used to access GRPADDR1.
 *
 */
#define BCM53600_A0_READ_GRPADDR1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_GRPADDR1r,(r._grpaddr1),6)
#define BCM53600_A0_WRITE_GRPADDR1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_GRPADDR1r,&(r._grpaddr1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPADDR1r BCM53600_A0_GRPADDR1r
#define GRPADDR1r_SIZE BCM53600_A0_GRPADDR1r_SIZE
typedef BCM53600_A0_GRPADDR1r_t GRPADDR1r_t;
#define GRPADDR1r_CLR BCM53600_A0_GRPADDR1r_CLR
#define GRPADDR1r_SET BCM53600_A0_GRPADDR1r_SET
#define GRPADDR1r_GET BCM53600_A0_GRPADDR1r_GET
#define GRPADDR1r_GRP_ADDRf_GET BCM53600_A0_GRPADDR1r_GRP_ADDRf_GET
#define GRPADDR1r_GRP_ADDRf_SET BCM53600_A0_GRPADDR1r_GRP_ADDRf_SET
#define READ_GRPADDR1r BCM53600_A0_READ_GRPADDR1r
#define WRITE_GRPADDR1r BCM53600_A0_WRITE_GRPADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GRPADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  GRPADDR2
 * BLOCKS:   SYS
 * DESC:     L2 User Address 2 Register
 * SIZE:     48
 * FIELDS:
 *     GRP_ADDR         L2 User Address 2Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the L2 User Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *
 ******************************************************************************/
#define BCM53600_A0_GRPADDR2r 0x00000420

#define BCM53600_A0_GRPADDR2r_SIZE 6

/*
 * This structure should be used to declare and program GRPADDR2.
 *
 */
typedef union BCM53600_A0_GRPADDR2r_s {
	uint32_t v[2];
	uint32_t grpaddr2[2];
	uint32_t _grpaddr2;
} BCM53600_A0_GRPADDR2r_t;

#define BCM53600_A0_GRPADDR2r_CLR(r) CDK_MEMSET(&((r)._grpaddr2), 0, sizeof(BCM53600_A0_GRPADDR2r_t))
#define BCM53600_A0_GRPADDR2r_SET(r,i,d) (r).grpaddr2[i] = d
#define BCM53600_A0_GRPADDR2r_GET(r,i) (r).grpaddr2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_GRPADDR2r_GRP_ADDRf_GET(r,a) cdk_field_get((r).grpaddr2,0,47,a)
#define BCM53600_A0_GRPADDR2r_GRP_ADDRf_SET(r,a) cdk_field_set((r).grpaddr2,0,47,a)

/*
 * These macros can be used to access GRPADDR2.
 *
 */
#define BCM53600_A0_READ_GRPADDR2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_GRPADDR2r,(r._grpaddr2),6)
#define BCM53600_A0_WRITE_GRPADDR2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_GRPADDR2r,&(r._grpaddr2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPADDR2r BCM53600_A0_GRPADDR2r
#define GRPADDR2r_SIZE BCM53600_A0_GRPADDR2r_SIZE
typedef BCM53600_A0_GRPADDR2r_t GRPADDR2r_t;
#define GRPADDR2r_CLR BCM53600_A0_GRPADDR2r_CLR
#define GRPADDR2r_SET BCM53600_A0_GRPADDR2r_SET
#define GRPADDR2r_GET BCM53600_A0_GRPADDR2r_GET
#define GRPADDR2r_GRP_ADDRf_GET BCM53600_A0_GRPADDR2r_GRP_ADDRf_GET
#define GRPADDR2r_GRP_ADDRf_SET BCM53600_A0_GRPADDR2r_GRP_ADDRf_SET
#define READ_GRPADDR2r BCM53600_A0_READ_GRPADDR2r
#define WRITE_GRPADDR2r BCM53600_A0_WRITE_GRPADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_GRPADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_ANADV
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-X capable,0 = not 100Base-X capable.
 *     ADV_B100X_FDX    1 = 100Base-X full duplex capable,0 = not 100Base-X full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53600_A0_G_ANADVr 0x0000d808

#define BCM53600_A0_G_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV.
 *
 */
typedef union BCM53600_A0_G_ANADVr_s {
	uint32_t v[1];
	uint32_t g_anadv[1];
	uint32_t _g_anadv;
} BCM53600_A0_G_ANADVr_t;

#define BCM53600_A0_G_ANADVr_CLR(r) (r).g_anadv[0] = 0
#define BCM53600_A0_G_ANADVr_SET(r,d) (r).g_anadv[0] = d
#define BCM53600_A0_G_ANADVr_GET(r) (r).g_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_ANADVr_PROTOCOL_SELf_GET(r) (((r).g_anadv[0]) & 0x1f)
#define BCM53600_A0_G_ANADVr_PROTOCOL_SELf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_G_ANADVr_ADV_B10Tf_GET(r) ((((r).g_anadv[0]) >> 5) & 0x1)
#define BCM53600_A0_G_ANADVr_ADV_B10Tf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_G_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv[0]) >> 6) & 0x1)
#define BCM53600_A0_G_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_G_ANADVr_ADV_B100Xf_GET(r) ((((r).g_anadv[0]) >> 7) & 0x1)
#define BCM53600_A0_G_ANADVr_ADV_B100Xf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_G_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).g_anadv[0]) >> 8) & 0x1)
#define BCM53600_A0_G_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_G_ANADVr_B100T4f_GET(r) ((((r).g_anadv[0]) >> 9) & 0x1)
#define BCM53600_A0_G_ANADVr_B100T4f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_G_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv[0]) >> 10) & 0x1)
#define BCM53600_A0_G_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_G_ANADVr_ASY_PAUSEf_GET(r) ((((r).g_anadv[0]) >> 11) & 0x1)
#define BCM53600_A0_G_ANADVr_ASY_PAUSEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_ANADVr_RESERVED_1f_GET(r) ((((r).g_anadv[0]) >> 12) & 0x1)
#define BCM53600_A0_G_ANADVr_RESERVED_1f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_ANADVr_REMOTE_FAULTf_GET(r) ((((r).g_anadv[0]) >> 13) & 0x1)
#define BCM53600_A0_G_ANADVr_REMOTE_FAULTf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_ANADVr_RESERVED_2f_GET(r) ((((r).g_anadv[0]) >> 14) & 0x1)
#define BCM53600_A0_G_ANADVr_RESERVED_2f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_ANADVr_NEXT_PAGEf_GET(r) ((((r).g_anadv[0]) >> 15) & 0x1)
#define BCM53600_A0_G_ANADVr_NEXT_PAGEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV.
 *
 */
#define BCM53600_A0_READ_G_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_ANADVr,(r._g_anadv),2)
#define BCM53600_A0_WRITE_G_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_ANADVr,&(r._g_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADVr BCM53600_A0_G_ANADVr
#define G_ANADVr_SIZE BCM53600_A0_G_ANADVr_SIZE
typedef BCM53600_A0_G_ANADVr_t G_ANADVr_t;
#define G_ANADVr_CLR BCM53600_A0_G_ANADVr_CLR
#define G_ANADVr_SET BCM53600_A0_G_ANADVr_SET
#define G_ANADVr_GET BCM53600_A0_G_ANADVr_GET
#define G_ANADVr_PROTOCOL_SELf_GET BCM53600_A0_G_ANADVr_PROTOCOL_SELf_GET
#define G_ANADVr_PROTOCOL_SELf_SET BCM53600_A0_G_ANADVr_PROTOCOL_SELf_SET
#define G_ANADVr_ADV_B10Tf_GET BCM53600_A0_G_ANADVr_ADV_B10Tf_GET
#define G_ANADVr_ADV_B10Tf_SET BCM53600_A0_G_ANADVr_ADV_B10Tf_SET
#define G_ANADVr_ADV_B10T_FDXf_GET BCM53600_A0_G_ANADVr_ADV_B10T_FDXf_GET
#define G_ANADVr_ADV_B10T_FDXf_SET BCM53600_A0_G_ANADVr_ADV_B10T_FDXf_SET
#define G_ANADVr_ADV_B100Xf_GET BCM53600_A0_G_ANADVr_ADV_B100Xf_GET
#define G_ANADVr_ADV_B100Xf_SET BCM53600_A0_G_ANADVr_ADV_B100Xf_SET
#define G_ANADVr_ADV_B100X_FDXf_GET BCM53600_A0_G_ANADVr_ADV_B100X_FDXf_GET
#define G_ANADVr_ADV_B100X_FDXf_SET BCM53600_A0_G_ANADVr_ADV_B100X_FDXf_SET
#define G_ANADVr_B100T4f_GET BCM53600_A0_G_ANADVr_B100T4f_GET
#define G_ANADVr_B100T4f_SET BCM53600_A0_G_ANADVr_B100T4f_SET
#define G_ANADVr_ADV_PAUSE_CAPf_GET BCM53600_A0_G_ANADVr_ADV_PAUSE_CAPf_GET
#define G_ANADVr_ADV_PAUSE_CAPf_SET BCM53600_A0_G_ANADVr_ADV_PAUSE_CAPf_SET
#define G_ANADVr_ASY_PAUSEf_GET BCM53600_A0_G_ANADVr_ASY_PAUSEf_GET
#define G_ANADVr_ASY_PAUSEf_SET BCM53600_A0_G_ANADVr_ASY_PAUSEf_SET
#define G_ANADVr_RESERVED_1f_GET BCM53600_A0_G_ANADVr_RESERVED_1f_GET
#define G_ANADVr_RESERVED_1f_SET BCM53600_A0_G_ANADVr_RESERVED_1f_SET
#define G_ANADVr_REMOTE_FAULTf_GET BCM53600_A0_G_ANADVr_REMOTE_FAULTf_GET
#define G_ANADVr_REMOTE_FAULTf_SET BCM53600_A0_G_ANADVr_REMOTE_FAULTf_SET
#define G_ANADVr_RESERVED_2f_GET BCM53600_A0_G_ANADVr_RESERVED_2f_GET
#define G_ANADVr_RESERVED_2f_SET BCM53600_A0_G_ANADVr_RESERVED_2f_SET
#define G_ANADVr_NEXT_PAGEf_GET BCM53600_A0_G_ANADVr_NEXT_PAGEf_GET
#define G_ANADVr_NEXT_PAGEf_SET BCM53600_A0_G_ANADVr_NEXT_PAGEf_SET
#define READ_G_ANADVr BCM53600_A0_READ_G_ANADVr
#define WRITE_G_ANADVr BCM53600_A0_WRITE_G_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_ANEXP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM53600_A0_G_ANEXPr 0x0000d80c

#define BCM53600_A0_G_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP.
 *
 */
typedef union BCM53600_A0_G_ANEXPr_s {
	uint32_t v[1];
	uint32_t g_anexp[1];
	uint32_t _g_anexp;
} BCM53600_A0_G_ANEXPr_t;

#define BCM53600_A0_G_ANEXPr_CLR(r) (r).g_anexp[0] = 0
#define BCM53600_A0_G_ANEXPr_SET(r,d) (r).g_anexp[0] = d
#define BCM53600_A0_G_ANEXPr_GET(r) (r).g_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_ANEXPr_LP_AN_ABIf_GET(r) (((r).g_anexp[0]) & 0x1)
#define BCM53600_A0_G_ANEXPr_LP_AN_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_G_ANEXPr_PAGE_RECf_GET(r) ((((r).g_anexp[0]) >> 1) & 0x1)
#define BCM53600_A0_G_ANEXPr_PAGE_RECf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 2) & 0x1)
#define BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 3) & 0x1)
#define BCM53600_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_G_ANEXPr_PAR_DET_FAILf_GET(r) ((((r).g_anexp[0]) >> 4) & 0x1)
#define BCM53600_A0_G_ANEXPr_PAR_DET_FAILf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_G_ANEXPr_NEXT_PAGEf_GET(r) ((((r).g_anexp[0]) >> 5) & 0x1)
#define BCM53600_A0_G_ANEXPr_NEXT_PAGEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp[0]) >> 6) & 0x1)
#define BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_G_ANEXPr_RESERVED_1f_GET(r) ((((r).g_anexp[0]) >> 7) & 0x1ff)
#define BCM53600_A0_G_ANEXPr_RESERVED_1f_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP.
 *
 */
#define BCM53600_A0_READ_G_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_ANEXPr,(r._g_anexp),2)
#define BCM53600_A0_WRITE_G_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_ANEXPr,&(r._g_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXPr BCM53600_A0_G_ANEXPr
#define G_ANEXPr_SIZE BCM53600_A0_G_ANEXPr_SIZE
typedef BCM53600_A0_G_ANEXPr_t G_ANEXPr_t;
#define G_ANEXPr_CLR BCM53600_A0_G_ANEXPr_CLR
#define G_ANEXPr_SET BCM53600_A0_G_ANEXPr_SET
#define G_ANEXPr_GET BCM53600_A0_G_ANEXPr_GET
#define G_ANEXPr_LP_AN_ABIf_GET BCM53600_A0_G_ANEXPr_LP_AN_ABIf_GET
#define G_ANEXPr_LP_AN_ABIf_SET BCM53600_A0_G_ANEXPr_LP_AN_ABIf_SET
#define G_ANEXPr_PAGE_RECf_GET BCM53600_A0_G_ANEXPr_PAGE_RECf_GET
#define G_ANEXPr_PAGE_RECf_SET BCM53600_A0_G_ANEXPr_PAGE_RECf_SET
#define G_ANEXPr_NEXT_PAGE_ABIf_GET BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_NEXT_PAGE_ABIf_SET BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_GET BCM53600_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_SET BCM53600_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_PAR_DET_FAILf_GET BCM53600_A0_G_ANEXPr_PAR_DET_FAILf_GET
#define G_ANEXPr_PAR_DET_FAILf_SET BCM53600_A0_G_ANEXPr_PAR_DET_FAILf_SET
#define G_ANEXPr_NEXT_PAGEf_GET BCM53600_A0_G_ANEXPr_NEXT_PAGEf_GET
#define G_ANEXPr_NEXT_PAGEf_SET BCM53600_A0_G_ANEXPr_NEXT_PAGEf_SET
#define G_ANEXPr_NEXT_PAGE_ABLEf_GET BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET
#define G_ANEXPr_NEXT_PAGE_ABLEf_SET BCM53600_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET
#define G_ANEXPr_RESERVED_1f_GET BCM53600_A0_G_ANEXPr_RESERVED_1f_GET
#define G_ANEXPr_RESERVED_1f_SET BCM53600_A0_G_ANEXPr_RESERVED_1f_SET
#define READ_G_ANEXPr BCM53600_A0_READ_G_ANEXPr
#define WRITE_G_ANEXPr BCM53600_A0_WRITE_G_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_ANLPA
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partner is protocol selector (see IEEE spec for encodings)
 *     B10T_HD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B10T_FD_CAP      1 = link partner is 10Base-T full duplex capable0 = link partner is not 10Base-T full duplex capable.
 *     B100_XHD_CAP     1 = link partner is 100Base-X half duplex capable0 = link partner is not 100Base-X half duplex capable.
 *     B100_XFD_CAP     1 = link partner is 100Base-X full duplex capable0 = link partner is not 100Base-X full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53600_A0_G_ANLPAr 0x0000d80a

#define BCM53600_A0_G_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA.
 *
 */
typedef union BCM53600_A0_G_ANLPAr_s {
	uint32_t v[1];
	uint32_t g_anlpa[1];
	uint32_t _g_anlpa;
} BCM53600_A0_G_ANLPAr_t;

#define BCM53600_A0_G_ANLPAr_CLR(r) (r).g_anlpa[0] = 0
#define BCM53600_A0_G_ANLPAr_SET(r,d) (r).g_anlpa[0] = d
#define BCM53600_A0_G_ANLPAr_GET(r) (r).g_anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_ANLPAr_PROTOCOL_SELf_GET(r) (((r).g_anlpa[0]) & 0x1f)
#define BCM53600_A0_G_ANLPAr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_G_ANLPAr_B10T_HD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 5) & 0x1)
#define BCM53600_A0_G_ANLPAr_B10T_HD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_G_ANLPAr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 6) & 0x1)
#define BCM53600_A0_G_ANLPAr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_G_ANLPAr_B100_XHD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 7) & 0x1)
#define BCM53600_A0_G_ANLPAr_B100_XHD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_G_ANLPAr_B100_XFD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 8) & 0x1)
#define BCM53600_A0_G_ANLPAr_B100_XFD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_G_ANLPAr_B100T4_CAPf_GET(r) ((((r).g_anlpa[0]) >> 9) & 0x1)
#define BCM53600_A0_G_ANLPAr_B100T4_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_G_ANLPAr_PAUSE_CAPf_GET(r) ((((r).g_anlpa[0]) >> 10) & 0x1)
#define BCM53600_A0_G_ANLPAr_PAUSE_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa[0]) >> 11) & 0x1)
#define BCM53600_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_ANLPAr_RESERVED_1f_GET(r) ((((r).g_anlpa[0]) >> 12) & 0x1)
#define BCM53600_A0_G_ANLPAr_RESERVED_1f_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_ANLPAr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa[0]) >> 13) & 0x1)
#define BCM53600_A0_G_ANLPAr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_ANLPAr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa[0]) >> 14) & 0x1)
#define BCM53600_A0_G_ANLPAr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_ANLPAr_NEXT_PAGEf_GET(r) ((((r).g_anlpa[0]) >> 15) & 0x1)
#define BCM53600_A0_G_ANLPAr_NEXT_PAGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA.
 *
 */
#define BCM53600_A0_READ_G_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_ANLPAr,(r._g_anlpa),2)
#define BCM53600_A0_WRITE_G_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_ANLPAr,&(r._g_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPAr BCM53600_A0_G_ANLPAr
#define G_ANLPAr_SIZE BCM53600_A0_G_ANLPAr_SIZE
typedef BCM53600_A0_G_ANLPAr_t G_ANLPAr_t;
#define G_ANLPAr_CLR BCM53600_A0_G_ANLPAr_CLR
#define G_ANLPAr_SET BCM53600_A0_G_ANLPAr_SET
#define G_ANLPAr_GET BCM53600_A0_G_ANLPAr_GET
#define G_ANLPAr_PROTOCOL_SELf_GET BCM53600_A0_G_ANLPAr_PROTOCOL_SELf_GET
#define G_ANLPAr_PROTOCOL_SELf_SET BCM53600_A0_G_ANLPAr_PROTOCOL_SELf_SET
#define G_ANLPAr_B10T_HD_CAPf_GET BCM53600_A0_G_ANLPAr_B10T_HD_CAPf_GET
#define G_ANLPAr_B10T_HD_CAPf_SET BCM53600_A0_G_ANLPAr_B10T_HD_CAPf_SET
#define G_ANLPAr_B10T_FD_CAPf_GET BCM53600_A0_G_ANLPAr_B10T_FD_CAPf_GET
#define G_ANLPAr_B10T_FD_CAPf_SET BCM53600_A0_G_ANLPAr_B10T_FD_CAPf_SET
#define G_ANLPAr_B100_XHD_CAPf_GET BCM53600_A0_G_ANLPAr_B100_XHD_CAPf_GET
#define G_ANLPAr_B100_XHD_CAPf_SET BCM53600_A0_G_ANLPAr_B100_XHD_CAPf_SET
#define G_ANLPAr_B100_XFD_CAPf_GET BCM53600_A0_G_ANLPAr_B100_XFD_CAPf_GET
#define G_ANLPAr_B100_XFD_CAPf_SET BCM53600_A0_G_ANLPAr_B100_XFD_CAPf_SET
#define G_ANLPAr_B100T4_CAPf_GET BCM53600_A0_G_ANLPAr_B100T4_CAPf_GET
#define G_ANLPAr_B100T4_CAPf_SET BCM53600_A0_G_ANLPAr_B100T4_CAPf_SET
#define G_ANLPAr_PAUSE_CAPf_GET BCM53600_A0_G_ANLPAr_PAUSE_CAPf_GET
#define G_ANLPAr_PAUSE_CAPf_SET BCM53600_A0_G_ANLPAr_PAUSE_CAPf_SET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_GET BCM53600_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_SET BCM53600_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPAr_RESERVED_1f_GET BCM53600_A0_G_ANLPAr_RESERVED_1f_GET
#define G_ANLPAr_RESERVED_1f_SET BCM53600_A0_G_ANLPAr_RESERVED_1f_SET
#define G_ANLPAr_REMOTE_FAULTf_GET BCM53600_A0_G_ANLPAr_REMOTE_FAULTf_GET
#define G_ANLPAr_REMOTE_FAULTf_SET BCM53600_A0_G_ANLPAr_REMOTE_FAULTf_SET
#define G_ANLPAr_ACKNOWLEDGEf_GET BCM53600_A0_G_ANLPAr_ACKNOWLEDGEf_GET
#define G_ANLPAr_ACKNOWLEDGEf_SET BCM53600_A0_G_ANLPAr_ACKNOWLEDGEf_SET
#define G_ANLPAr_NEXT_PAGEf_GET BCM53600_A0_G_ANLPAr_NEXT_PAGEf_GET
#define G_ANLPAr_NEXT_PAGEf_SET BCM53600_A0_G_ANLPAr_NEXT_PAGEf_SET
#define READ_G_ANLPAr BCM53600_A0_READ_G_ANLPAr
#define WRITE_G_ANLPAr BCM53600_A0_WRITE_G_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_ANNXP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Reserved
 *     CODE_FIELD       message code field or unformatted code field.
 *     RESERVED_1       Reserved
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_2       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53600_A0_G_ANNXPr 0x0000d80e

#define BCM53600_A0_G_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP.
 *
 */
typedef union BCM53600_A0_G_ANNXPr_s {
	uint32_t v[1];
	uint32_t g_annxp[1];
	uint32_t _g_annxp;
} BCM53600_A0_G_ANNXPr_t;

#define BCM53600_A0_G_ANNXPr_CLR(r) (r).g_annxp[0] = 0
#define BCM53600_A0_G_ANNXPr_SET(r,d) (r).g_annxp[0] = d
#define BCM53600_A0_G_ANNXPr_GET(r) (r).g_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_ANNXPr_RESERVED_0f_GET(r) (((r).g_annxp[0]) & 0x1f)
#define BCM53600_A0_G_ANNXPr_RESERVED_0f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_G_ANNXPr_CODE_FIELDf_GET(r) ((((r).g_annxp[0]) >> 5) & 0x1)
#define BCM53600_A0_G_ANNXPr_CODE_FIELDf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_G_ANNXPr_RESERVED_1f_GET(r) ((((r).g_annxp[0]) >> 6) & 0x1f)
#define BCM53600_A0_G_ANNXPr_RESERVED_1f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM53600_A0_G_ANNXPr_TOGGLEf_GET(r) ((((r).g_annxp[0]) >> 11) & 0x1)
#define BCM53600_A0_G_ANNXPr_TOGGLEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp[0]) >> 12) & 0x1)
#define BCM53600_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_ANNXPr_MES_PAGEf_GET(r) ((((r).g_annxp[0]) >> 13) & 0x1)
#define BCM53600_A0_G_ANNXPr_MES_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_ANNXPr_RESERVED_2f_GET(r) ((((r).g_annxp[0]) >> 14) & 0x1)
#define BCM53600_A0_G_ANNXPr_RESERVED_2f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_ANNXPr_NEXT_PAGEf_GET(r) ((((r).g_annxp[0]) >> 15) & 0x1)
#define BCM53600_A0_G_ANNXPr_NEXT_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP.
 *
 */
#define BCM53600_A0_READ_G_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_ANNXPr,(r._g_annxp),2)
#define BCM53600_A0_WRITE_G_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_ANNXPr,&(r._g_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXPr BCM53600_A0_G_ANNXPr
#define G_ANNXPr_SIZE BCM53600_A0_G_ANNXPr_SIZE
typedef BCM53600_A0_G_ANNXPr_t G_ANNXPr_t;
#define G_ANNXPr_CLR BCM53600_A0_G_ANNXPr_CLR
#define G_ANNXPr_SET BCM53600_A0_G_ANNXPr_SET
#define G_ANNXPr_GET BCM53600_A0_G_ANNXPr_GET
#define G_ANNXPr_RESERVED_0f_GET BCM53600_A0_G_ANNXPr_RESERVED_0f_GET
#define G_ANNXPr_RESERVED_0f_SET BCM53600_A0_G_ANNXPr_RESERVED_0f_SET
#define G_ANNXPr_CODE_FIELDf_GET BCM53600_A0_G_ANNXPr_CODE_FIELDf_GET
#define G_ANNXPr_CODE_FIELDf_SET BCM53600_A0_G_ANNXPr_CODE_FIELDf_SET
#define G_ANNXPr_RESERVED_1f_GET BCM53600_A0_G_ANNXPr_RESERVED_1f_GET
#define G_ANNXPr_RESERVED_1f_SET BCM53600_A0_G_ANNXPr_RESERVED_1f_SET
#define G_ANNXPr_TOGGLEf_GET BCM53600_A0_G_ANNXPr_TOGGLEf_GET
#define G_ANNXPr_TOGGLEf_SET BCM53600_A0_G_ANNXPr_TOGGLEf_SET
#define G_ANNXPr_ACKNOWLEDGE_2f_GET BCM53600_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET
#define G_ANNXPr_ACKNOWLEDGE_2f_SET BCM53600_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET
#define G_ANNXPr_MES_PAGEf_GET BCM53600_A0_G_ANNXPr_MES_PAGEf_GET
#define G_ANNXPr_MES_PAGEf_SET BCM53600_A0_G_ANNXPr_MES_PAGEf_SET
#define G_ANNXPr_RESERVED_2f_GET BCM53600_A0_G_ANNXPr_RESERVED_2f_GET
#define G_ANNXPr_RESERVED_2f_SET BCM53600_A0_G_ANNXPr_RESERVED_2f_SET
#define G_ANNXPr_NEXT_PAGEf_GET BCM53600_A0_G_ANNXPr_NEXT_PAGEf_GET
#define G_ANNXPr_NEXT_PAGEf_SET BCM53600_A0_G_ANNXPr_NEXT_PAGEf_SET
#define READ_G_ANNXPr BCM53600_A0_READ_G_ANNXPr
#define WRITE_G_ANNXPr BCM53600_A0_WRITE_G_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_B1000T_CTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53600_A0_G_B1000T_CTLr 0x0000d812

#define BCM53600_A0_G_B1000T_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL.
 *
 */
typedef union BCM53600_A0_G_B1000T_CTLr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl[1];
	uint32_t _g_b1000t_ctl;
} BCM53600_A0_G_B1000T_CTLr_t;

#define BCM53600_A0_G_B1000T_CTLr_CLR(r) (r).g_b1000t_ctl[0] = 0
#define BCM53600_A0_G_B1000T_CTLr_SET(r,d) (r).g_b1000t_ctl[0] = d
#define BCM53600_A0_G_B1000T_CTLr_GET(r) (r).g_b1000t_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_B1000T_CTLr_RESERVEDf_GET(r) (((r).g_b1000t_ctl[0]) & 0xff)
#define BCM53600_A0_G_B1000T_CTLr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 8) & 0x1)
#define BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 9) & 0x1)
#define BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_G_B1000T_CTLr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 10) & 0x1)
#define BCM53600_A0_G_B1000T_CTLr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 11) & 0x1)
#define BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl[0]) >> 12) & 0x1)
#define BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_B1000T_CTLr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 13) & 0x7)
#define BCM53600_A0_G_B1000T_CTLr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL.
 *
 */
#define BCM53600_A0_READ_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_B1000T_CTLr,(r._g_b1000t_ctl),2)
#define BCM53600_A0_WRITE_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_B1000T_CTLr,&(r._g_b1000t_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTLr BCM53600_A0_G_B1000T_CTLr
#define G_B1000T_CTLr_SIZE BCM53600_A0_G_B1000T_CTLr_SIZE
typedef BCM53600_A0_G_B1000T_CTLr_t G_B1000T_CTLr_t;
#define G_B1000T_CTLr_CLR BCM53600_A0_G_B1000T_CTLr_CLR
#define G_B1000T_CTLr_SET BCM53600_A0_G_B1000T_CTLr_SET
#define G_B1000T_CTLr_GET BCM53600_A0_G_B1000T_CTLr_GET
#define G_B1000T_CTLr_RESERVEDf_GET BCM53600_A0_G_B1000T_CTLr_RESERVEDf_GET
#define G_B1000T_CTLr_RESERVEDf_SET BCM53600_A0_G_B1000T_CTLr_RESERVEDf_SET
#define G_B1000T_CTLr_ADV_B1000T_HDf_GET BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET
#define G_B1000T_CTLr_ADV_B1000T_HDf_SET BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET
#define G_B1000T_CTLr_ADV_B1000T_FDf_GET BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET
#define G_B1000T_CTLr_ADV_B1000T_FDf_SET BCM53600_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET
#define G_B1000T_CTLr_REPEATER_DTEf_GET BCM53600_A0_G_B1000T_CTLr_REPEATER_DTEf_GET
#define G_B1000T_CTLr_REPEATER_DTEf_SET BCM53600_A0_G_B1000T_CTLr_REPEATER_DTEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET BCM53600_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTLr_TEST_MODEf_GET BCM53600_A0_G_B1000T_CTLr_TEST_MODEf_GET
#define G_B1000T_CTLr_TEST_MODEf_SET BCM53600_A0_G_B1000T_CTLr_TEST_MODEf_SET
#define READ_G_B1000T_CTLr BCM53600_A0_READ_G_B1000T_CTLr
#define WRITE_G_B1000T_CTLr BCM53600_A0_WRITE_G_B1000T_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_B1000T_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_B1000T_STS
 * BLOCKS:   CPIC GPIC0
 * DESC:     1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53600_A0_G_B1000T_STSr 0x0000d814

#define BCM53600_A0_G_B1000T_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS.
 *
 */
typedef union BCM53600_A0_G_B1000T_STSr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts[1];
	uint32_t _g_b1000t_sts;
} BCM53600_A0_G_B1000T_STSr_t;

#define BCM53600_A0_G_B1000T_STSr_CLR(r) (r).g_b1000t_sts[0] = 0
#define BCM53600_A0_G_B1000T_STSr_SET(r,d) (r).g_b1000t_sts[0] = d
#define BCM53600_A0_G_B1000T_STSr_GET(r) (r).g_b1000t_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts[0]) & 0xff)
#define BCM53600_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_G_B1000T_STSr_RESERVEDf_GET(r) ((((r).g_b1000t_sts[0]) >> 8) & 0x3)
#define BCM53600_A0_G_B1000T_STSr_RESERVEDf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53600_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 10) & 0x1)
#define BCM53600_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 11) & 0x1)
#define BCM53600_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 12) & 0x1)
#define BCM53600_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 13) & 0x1)
#define BCM53600_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 14) & 0x1)
#define BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts[0]) >> 15) & 0x1)
#define BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS.
 *
 */
#define BCM53600_A0_READ_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_B1000T_STSr,(r._g_b1000t_sts),2)
#define BCM53600_A0_WRITE_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_B1000T_STSr,&(r._g_b1000t_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STSr BCM53600_A0_G_B1000T_STSr
#define G_B1000T_STSr_SIZE BCM53600_A0_G_B1000T_STSr_SIZE
typedef BCM53600_A0_G_B1000T_STSr_t G_B1000T_STSr_t;
#define G_B1000T_STSr_CLR BCM53600_A0_G_B1000T_STSr_CLR
#define G_B1000T_STSr_SET BCM53600_A0_G_B1000T_STSr_SET
#define G_B1000T_STSr_GET BCM53600_A0_G_B1000T_STSr_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_GET BCM53600_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_SET BCM53600_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET
#define G_B1000T_STSr_RESERVEDf_GET BCM53600_A0_G_B1000T_STSr_RESERVEDf_GET
#define G_B1000T_STSr_RESERVEDf_SET BCM53600_A0_G_B1000T_STSr_RESERVEDf_SET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_GET BCM53600_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_SET BCM53600_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_GET BCM53600_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_SET BCM53600_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STSr_REMOTE_REC_STSf_GET BCM53600_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET
#define G_B1000T_STSr_REMOTE_REC_STSf_SET BCM53600_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET
#define G_B1000T_STSr_LOCAL_REC_STSf_GET BCM53600_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET
#define G_B1000T_STSr_LOCAL_REC_STSf_SET BCM53600_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_GET BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_SET BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET BCM53600_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STSr BCM53600_A0_READ_G_B1000T_STSr
#define WRITE_G_B1000T_STSr BCM53600_A0_WRITE_G_B1000T_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_B1000T_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_EXT_STS
 * BLOCKS:   CPIC GPIC0
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53600_A0_G_EXT_STSr 0x0000d81e

#define BCM53600_A0_G_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS.
 *
 */
typedef union BCM53600_A0_G_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_ext_sts[1];
	uint32_t _g_ext_sts;
} BCM53600_A0_G_EXT_STSr_t;

#define BCM53600_A0_G_EXT_STSr_CLR(r) (r).g_ext_sts[0] = 0
#define BCM53600_A0_G_EXT_STSr_SET(r,d) (r).g_ext_sts[0] = d
#define BCM53600_A0_G_EXT_STSr_GET(r) (r).g_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_EXT_STSr_RESERVEDf_GET(r) (((r).g_ext_sts[0]) & 0xfff)
#define BCM53600_A0_G_EXT_STSr_RESERVEDf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_G_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 12) & 0x1)
#define BCM53600_A0_G_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 13) & 0x1)
#define BCM53600_A0_G_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 14) & 0x1)
#define BCM53600_A0_G_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 15) & 0x1)
#define BCM53600_A0_G_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS.
 *
 */
#define BCM53600_A0_READ_G_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_EXT_STSr,(r._g_ext_sts),2)
#define BCM53600_A0_WRITE_G_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_EXT_STSr,&(r._g_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STSr BCM53600_A0_G_EXT_STSr
#define G_EXT_STSr_SIZE BCM53600_A0_G_EXT_STSr_SIZE
typedef BCM53600_A0_G_EXT_STSr_t G_EXT_STSr_t;
#define G_EXT_STSr_CLR BCM53600_A0_G_EXT_STSr_CLR
#define G_EXT_STSr_SET BCM53600_A0_G_EXT_STSr_SET
#define G_EXT_STSr_GET BCM53600_A0_G_EXT_STSr_GET
#define G_EXT_STSr_RESERVEDf_GET BCM53600_A0_G_EXT_STSr_RESERVEDf_GET
#define G_EXT_STSr_RESERVEDf_SET BCM53600_A0_G_EXT_STSr_RESERVEDf_SET
#define G_EXT_STSr_B1000T_HD_CAPf_GET BCM53600_A0_G_EXT_STSr_B1000T_HD_CAPf_GET
#define G_EXT_STSr_B1000T_HD_CAPf_SET BCM53600_A0_G_EXT_STSr_B1000T_HD_CAPf_SET
#define G_EXT_STSr_B1000T_FD_CAPf_GET BCM53600_A0_G_EXT_STSr_B1000T_FD_CAPf_GET
#define G_EXT_STSr_B1000T_FD_CAPf_SET BCM53600_A0_G_EXT_STSr_B1000T_FD_CAPf_SET
#define G_EXT_STSr_B1000X_HD_CAPf_GET BCM53600_A0_G_EXT_STSr_B1000X_HD_CAPf_GET
#define G_EXT_STSr_B1000X_HD_CAPf_SET BCM53600_A0_G_EXT_STSr_B1000X_HD_CAPf_SET
#define G_EXT_STSr_B1000X_FD_CAPf_GET BCM53600_A0_G_EXT_STSr_B1000X_FD_CAPf_GET
#define G_EXT_STSr_B1000X_FD_CAPf_SET BCM53600_A0_G_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STSr BCM53600_A0_READ_G_EXT_STSr
#define WRITE_G_EXT_STSr BCM53600_A0_WRITE_G_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_LPNXP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Reserved
 *     CODE_FIELD       message code field or unformatted code field.
 *     RESERVED_1       Reserved
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53600_A0_G_LPNXPr 0x0000d810

#define BCM53600_A0_G_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP.
 *
 */
typedef union BCM53600_A0_G_LPNXPr_s {
	uint32_t v[1];
	uint32_t g_lpnxp[1];
	uint32_t _g_lpnxp;
} BCM53600_A0_G_LPNXPr_t;

#define BCM53600_A0_G_LPNXPr_CLR(r) (r).g_lpnxp[0] = 0
#define BCM53600_A0_G_LPNXPr_SET(r,d) (r).g_lpnxp[0] = d
#define BCM53600_A0_G_LPNXPr_GET(r) (r).g_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_LPNXPr_RESERVED_0f_GET(r) (((r).g_lpnxp[0]) & 0x1f)
#define BCM53600_A0_G_LPNXPr_RESERVED_0f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_G_LPNXPr_CODE_FIELDf_GET(r) ((((r).g_lpnxp[0]) >> 5) & 0x1)
#define BCM53600_A0_G_LPNXPr_CODE_FIELDf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_G_LPNXPr_RESERVED_1f_GET(r) ((((r).g_lpnxp[0]) >> 6) & 0x1f)
#define BCM53600_A0_G_LPNXPr_RESERVED_1f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM53600_A0_G_LPNXPr_TOGGLEf_GET(r) ((((r).g_lpnxp[0]) >> 11) & 0x1)
#define BCM53600_A0_G_LPNXPr_TOGGLEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp[0]) >> 12) & 0x1)
#define BCM53600_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_LPNXPr_MES_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 13) & 0x1)
#define BCM53600_A0_G_LPNXPr_MES_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_LPNXPr_ACKf_GET(r) ((((r).g_lpnxp[0]) >> 14) & 0x1)
#define BCM53600_A0_G_LPNXPr_ACKf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_LPNXPr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 15) & 0x1)
#define BCM53600_A0_G_LPNXPr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP.
 *
 */
#define BCM53600_A0_READ_G_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_LPNXPr,(r._g_lpnxp),2)
#define BCM53600_A0_WRITE_G_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_LPNXPr,&(r._g_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXPr BCM53600_A0_G_LPNXPr
#define G_LPNXPr_SIZE BCM53600_A0_G_LPNXPr_SIZE
typedef BCM53600_A0_G_LPNXPr_t G_LPNXPr_t;
#define G_LPNXPr_CLR BCM53600_A0_G_LPNXPr_CLR
#define G_LPNXPr_SET BCM53600_A0_G_LPNXPr_SET
#define G_LPNXPr_GET BCM53600_A0_G_LPNXPr_GET
#define G_LPNXPr_RESERVED_0f_GET BCM53600_A0_G_LPNXPr_RESERVED_0f_GET
#define G_LPNXPr_RESERVED_0f_SET BCM53600_A0_G_LPNXPr_RESERVED_0f_SET
#define G_LPNXPr_CODE_FIELDf_GET BCM53600_A0_G_LPNXPr_CODE_FIELDf_GET
#define G_LPNXPr_CODE_FIELDf_SET BCM53600_A0_G_LPNXPr_CODE_FIELDf_SET
#define G_LPNXPr_RESERVED_1f_GET BCM53600_A0_G_LPNXPr_RESERVED_1f_GET
#define G_LPNXPr_RESERVED_1f_SET BCM53600_A0_G_LPNXPr_RESERVED_1f_SET
#define G_LPNXPr_TOGGLEf_GET BCM53600_A0_G_LPNXPr_TOGGLEf_GET
#define G_LPNXPr_TOGGLEf_SET BCM53600_A0_G_LPNXPr_TOGGLEf_SET
#define G_LPNXPr_ACKNOWLEDGE_2f_GET BCM53600_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET
#define G_LPNXPr_ACKNOWLEDGE_2f_SET BCM53600_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET
#define G_LPNXPr_MES_PAGEf_GET BCM53600_A0_G_LPNXPr_MES_PAGEf_GET
#define G_LPNXPr_MES_PAGEf_SET BCM53600_A0_G_LPNXPr_MES_PAGEf_SET
#define G_LPNXPr_ACKf_GET BCM53600_A0_G_LPNXPr_ACKf_GET
#define G_LPNXPr_ACKf_SET BCM53600_A0_G_LPNXPr_ACKf_SET
#define G_LPNXPr_NEXT_PAGEf_GET BCM53600_A0_G_LPNXPr_NEXT_PAGEf_GET
#define G_LPNXPr_NEXT_PAGEf_SET BCM53600_A0_G_LPNXPr_NEXT_PAGEf_SET
#define READ_G_LPNXPr BCM53600_A0_READ_G_LPNXPr
#define WRITE_G_LPNXPr BCM53600_A0_WRITE_G_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_MIICTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53600_A0_G_MIICTLr 0x0000d800

#define BCM53600_A0_G_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL.
 *
 */
typedef union BCM53600_A0_G_MIICTLr_s {
	uint32_t v[1];
	uint32_t g_miictl[1];
	uint32_t _g_miictl;
} BCM53600_A0_G_MIICTLr_t;

#define BCM53600_A0_G_MIICTLr_CLR(r) (r).g_miictl[0] = 0
#define BCM53600_A0_G_MIICTLr_SET(r,d) (r).g_miictl[0] = d
#define BCM53600_A0_G_MIICTLr_GET(r) (r).g_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_MIICTLr_RESERVEDf_GET(r) (((r).g_miictl[0]) & 0x3f)
#define BCM53600_A0_G_MIICTLr_RESERVEDf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_G_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl[0]) >> 6) & 0x1)
#define BCM53600_A0_G_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_G_MIICTLr_COL_TESTf_GET(r) ((((r).g_miictl[0]) >> 7) & 0x1)
#define BCM53600_A0_G_MIICTLr_COL_TESTf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_G_MIICTLr_DUPLEX_MODf_GET(r) ((((r).g_miictl[0]) >> 8) & 0x1)
#define BCM53600_A0_G_MIICTLr_DUPLEX_MODf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_G_MIICTLr_RE_ANf_GET(r) ((((r).g_miictl[0]) >> 9) & 0x1)
#define BCM53600_A0_G_MIICTLr_RE_ANf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_G_MIICTLr_ISOLATEf_GET(r) ((((r).g_miictl[0]) >> 10) & 0x1)
#define BCM53600_A0_G_MIICTLr_ISOLATEf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_G_MIICTLr_PWR_DOWNf_GET(r) ((((r).g_miictl[0]) >> 11) & 0x1)
#define BCM53600_A0_G_MIICTLr_PWR_DOWNf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_MIICTLr_AN_ENf_GET(r) ((((r).g_miictl[0]) >> 12) & 0x1)
#define BCM53600_A0_G_MIICTLr_AN_ENf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl[0]) >> 13) & 0x1)
#define BCM53600_A0_G_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_MIICTLr_LOOPBACKf_GET(r) ((((r).g_miictl[0]) >> 14) & 0x1)
#define BCM53600_A0_G_MIICTLr_LOOPBACKf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_MIICTLr_RESETf_GET(r) ((((r).g_miictl[0]) >> 15) & 0x1)
#define BCM53600_A0_G_MIICTLr_RESETf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL.
 *
 */
#define BCM53600_A0_READ_G_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_MIICTLr,(r._g_miictl),2)
#define BCM53600_A0_WRITE_G_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_MIICTLr,&(r._g_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTLr BCM53600_A0_G_MIICTLr
#define G_MIICTLr_SIZE BCM53600_A0_G_MIICTLr_SIZE
typedef BCM53600_A0_G_MIICTLr_t G_MIICTLr_t;
#define G_MIICTLr_CLR BCM53600_A0_G_MIICTLr_CLR
#define G_MIICTLr_SET BCM53600_A0_G_MIICTLr_SET
#define G_MIICTLr_GET BCM53600_A0_G_MIICTLr_GET
#define G_MIICTLr_RESERVEDf_GET BCM53600_A0_G_MIICTLr_RESERVEDf_GET
#define G_MIICTLr_RESERVEDf_SET BCM53600_A0_G_MIICTLr_RESERVEDf_SET
#define G_MIICTLr_SPD_SEL_MSBf_GET BCM53600_A0_G_MIICTLr_SPD_SEL_MSBf_GET
#define G_MIICTLr_SPD_SEL_MSBf_SET BCM53600_A0_G_MIICTLr_SPD_SEL_MSBf_SET
#define G_MIICTLr_COL_TESTf_GET BCM53600_A0_G_MIICTLr_COL_TESTf_GET
#define G_MIICTLr_COL_TESTf_SET BCM53600_A0_G_MIICTLr_COL_TESTf_SET
#define G_MIICTLr_DUPLEX_MODf_GET BCM53600_A0_G_MIICTLr_DUPLEX_MODf_GET
#define G_MIICTLr_DUPLEX_MODf_SET BCM53600_A0_G_MIICTLr_DUPLEX_MODf_SET
#define G_MIICTLr_RE_ANf_GET BCM53600_A0_G_MIICTLr_RE_ANf_GET
#define G_MIICTLr_RE_ANf_SET BCM53600_A0_G_MIICTLr_RE_ANf_SET
#define G_MIICTLr_ISOLATEf_GET BCM53600_A0_G_MIICTLr_ISOLATEf_GET
#define G_MIICTLr_ISOLATEf_SET BCM53600_A0_G_MIICTLr_ISOLATEf_SET
#define G_MIICTLr_PWR_DOWNf_GET BCM53600_A0_G_MIICTLr_PWR_DOWNf_GET
#define G_MIICTLr_PWR_DOWNf_SET BCM53600_A0_G_MIICTLr_PWR_DOWNf_SET
#define G_MIICTLr_AN_ENf_GET BCM53600_A0_G_MIICTLr_AN_ENf_GET
#define G_MIICTLr_AN_ENf_SET BCM53600_A0_G_MIICTLr_AN_ENf_SET
#define G_MIICTLr_SPD_SEL_LSBf_GET BCM53600_A0_G_MIICTLr_SPD_SEL_LSBf_GET
#define G_MIICTLr_SPD_SEL_LSBf_SET BCM53600_A0_G_MIICTLr_SPD_SEL_LSBf_SET
#define G_MIICTLr_LOOPBACKf_GET BCM53600_A0_G_MIICTLr_LOOPBACKf_GET
#define G_MIICTLr_LOOPBACKf_SET BCM53600_A0_G_MIICTLr_LOOPBACKf_SET
#define G_MIICTLr_RESETf_GET BCM53600_A0_G_MIICTLr_RESETf_GET
#define G_MIICTLr_RESETf_SET BCM53600_A0_G_MIICTLr_RESETf_SET
#define READ_G_MIICTLr BCM53600_A0_READ_G_MIICTLr
#define WRITE_G_MIICTLr BCM53600_A0_WRITE_G_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_MIISTS
 * BLOCKS:   CPIC GPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100X_CAP        1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100X_FDX_CAP    1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53600_A0_G_MIISTSr 0x0000d802

#define BCM53600_A0_G_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS.
 *
 */
typedef union BCM53600_A0_G_MIISTSr_s {
	uint32_t v[1];
	uint32_t g_miists[1];
	uint32_t _g_miists;
} BCM53600_A0_G_MIISTSr_t;

#define BCM53600_A0_G_MIISTSr_CLR(r) (r).g_miists[0] = 0
#define BCM53600_A0_G_MIISTSr_SET(r,d) (r).g_miists[0] = d
#define BCM53600_A0_G_MIISTSr_GET(r) (r).g_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_MIISTSr_EXT_CAPf_GET(r) (((r).g_miists[0]) & 0x1)
#define BCM53600_A0_G_MIISTSr_EXT_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_G_MIISTSr_JABBER_DETf_GET(r) ((((r).g_miists[0]) >> 1) & 0x1)
#define BCM53600_A0_G_MIISTSr_JABBER_DETf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_G_MIISTSr_LINK_STAf_GET(r) ((((r).g_miists[0]) >> 2) & 0x1)
#define BCM53600_A0_G_MIISTSr_LINK_STAf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists[0]) >> 3) & 0x1)
#define BCM53600_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_G_MIISTSr_REMOTE_FAULTf_GET(r) ((((r).g_miists[0]) >> 4) & 0x1)
#define BCM53600_A0_G_MIISTSr_REMOTE_FAULTf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists[0]) >> 5) & 0x1)
#define BCM53600_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_G_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).g_miists[0]) >> 6) & 0x1)
#define BCM53600_A0_G_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_G_MIISTSr_RESERVEDf_GET(r) ((((r).g_miists[0]) >> 7) & 0x1)
#define BCM53600_A0_G_MIISTSr_RESERVEDf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_G_MIISTSr_EXT_STSf_GET(r) ((((r).g_miists[0]) >> 8) & 0x1)
#define BCM53600_A0_G_MIISTSr_EXT_STSf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_G_MIISTSr_B100T2_HD_CAPf_GET(r) ((((r).g_miists[0]) >> 9) & 0x1)
#define BCM53600_A0_G_MIISTSr_B100T2_HD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_G_MIISTSr_B100T2_FD_CAPf_GET(r) ((((r).g_miists[0]) >> 10) & 0x1)
#define BCM53600_A0_G_MIISTSr_B100T2_FD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_G_MIISTSr_B10T_CAPf_GET(r) ((((r).g_miists[0]) >> 11) & 0x1)
#define BCM53600_A0_G_MIISTSr_B10T_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_G_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 12) & 0x1)
#define BCM53600_A0_G_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_G_MIISTSr_B100X_CAPf_GET(r) ((((r).g_miists[0]) >> 13) & 0x1)
#define BCM53600_A0_G_MIISTSr_B100X_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_G_MIISTSr_B100X_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 14) & 0x1)
#define BCM53600_A0_G_MIISTSr_B100X_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_G_MIISTSr_B100T4_CAPf_GET(r) ((((r).g_miists[0]) >> 15) & 0x1)
#define BCM53600_A0_G_MIISTSr_B100T4_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS.
 *
 */
#define BCM53600_A0_READ_G_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_MIISTSr,(r._g_miists),2)
#define BCM53600_A0_WRITE_G_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_MIISTSr,&(r._g_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTSr BCM53600_A0_G_MIISTSr
#define G_MIISTSr_SIZE BCM53600_A0_G_MIISTSr_SIZE
typedef BCM53600_A0_G_MIISTSr_t G_MIISTSr_t;
#define G_MIISTSr_CLR BCM53600_A0_G_MIISTSr_CLR
#define G_MIISTSr_SET BCM53600_A0_G_MIISTSr_SET
#define G_MIISTSr_GET BCM53600_A0_G_MIISTSr_GET
#define G_MIISTSr_EXT_CAPf_GET BCM53600_A0_G_MIISTSr_EXT_CAPf_GET
#define G_MIISTSr_EXT_CAPf_SET BCM53600_A0_G_MIISTSr_EXT_CAPf_SET
#define G_MIISTSr_JABBER_DETf_GET BCM53600_A0_G_MIISTSr_JABBER_DETf_GET
#define G_MIISTSr_JABBER_DETf_SET BCM53600_A0_G_MIISTSr_JABBER_DETf_SET
#define G_MIISTSr_LINK_STAf_GET BCM53600_A0_G_MIISTSr_LINK_STAf_GET
#define G_MIISTSr_LINK_STAf_SET BCM53600_A0_G_MIISTSr_LINK_STAf_SET
#define G_MIISTSr_AUTO_NEGO_CAPf_GET BCM53600_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET
#define G_MIISTSr_AUTO_NEGO_CAPf_SET BCM53600_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET
#define G_MIISTSr_REMOTE_FAULTf_GET BCM53600_A0_G_MIISTSr_REMOTE_FAULTf_GET
#define G_MIISTSr_REMOTE_FAULTf_SET BCM53600_A0_G_MIISTSr_REMOTE_FAULTf_SET
#define G_MIISTSr_AUTO_NEGO_COMPf_GET BCM53600_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET
#define G_MIISTSr_AUTO_NEGO_COMPf_SET BCM53600_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET
#define G_MIISTSr_MF_PRE_SUPf_GET BCM53600_A0_G_MIISTSr_MF_PRE_SUPf_GET
#define G_MIISTSr_MF_PRE_SUPf_SET BCM53600_A0_G_MIISTSr_MF_PRE_SUPf_SET
#define G_MIISTSr_RESERVEDf_GET BCM53600_A0_G_MIISTSr_RESERVEDf_GET
#define G_MIISTSr_RESERVEDf_SET BCM53600_A0_G_MIISTSr_RESERVEDf_SET
#define G_MIISTSr_EXT_STSf_GET BCM53600_A0_G_MIISTSr_EXT_STSf_GET
#define G_MIISTSr_EXT_STSf_SET BCM53600_A0_G_MIISTSr_EXT_STSf_SET
#define G_MIISTSr_B100T2_HD_CAPf_GET BCM53600_A0_G_MIISTSr_B100T2_HD_CAPf_GET
#define G_MIISTSr_B100T2_HD_CAPf_SET BCM53600_A0_G_MIISTSr_B100T2_HD_CAPf_SET
#define G_MIISTSr_B100T2_FD_CAPf_GET BCM53600_A0_G_MIISTSr_B100T2_FD_CAPf_GET
#define G_MIISTSr_B100T2_FD_CAPf_SET BCM53600_A0_G_MIISTSr_B100T2_FD_CAPf_SET
#define G_MIISTSr_B10T_CAPf_GET BCM53600_A0_G_MIISTSr_B10T_CAPf_GET
#define G_MIISTSr_B10T_CAPf_SET BCM53600_A0_G_MIISTSr_B10T_CAPf_SET
#define G_MIISTSr_B10T_FDX_CAPf_GET BCM53600_A0_G_MIISTSr_B10T_FDX_CAPf_GET
#define G_MIISTSr_B10T_FDX_CAPf_SET BCM53600_A0_G_MIISTSr_B10T_FDX_CAPf_SET
#define G_MIISTSr_B100X_CAPf_GET BCM53600_A0_G_MIISTSr_B100X_CAPf_GET
#define G_MIISTSr_B100X_CAPf_SET BCM53600_A0_G_MIISTSr_B100X_CAPf_SET
#define G_MIISTSr_B100X_FDX_CAPf_GET BCM53600_A0_G_MIISTSr_B100X_FDX_CAPf_GET
#define G_MIISTSr_B100X_FDX_CAPf_SET BCM53600_A0_G_MIISTSr_B100X_FDX_CAPf_SET
#define G_MIISTSr_B100T4_CAPf_GET BCM53600_A0_G_MIISTSr_B100T4_CAPf_GET
#define G_MIISTSr_B100T4_CAPf_SET BCM53600_A0_G_MIISTSr_B100T4_CAPf_SET
#define READ_G_MIISTSr BCM53600_A0_READ_G_MIISTSr
#define WRITE_G_MIISTSr BCM53600_A0_WRITE_G_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   GPIC0
 * DESC:     GIGA Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED         Reserved
 *     G_STP_STATE      CPU writes the current computed states of its Spanning Tree Algorithmfor this port.2'b00: Disable State(default for managed mode).2'b01: Discarding State.2'b10: Learning State.2'b11: Forwarding State(default for unmanaged mode).For BCM53602/BCM53603/BCM53604: Default value is read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently.If HW_FWDG_EN pin = 1, the default value = "11"(Forwarding State).If HW_FWDG_EN pin = 0, the default value = "0"(Disable State).For BCM53606/BCM53608: Default value is "11"(Forwarding State).
 *
 ******************************************************************************/
#define BCM53600_A0_G_PCTLr 0x001901a9

#define BCM53600_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 *
 */
typedef union BCM53600_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM53600_A0_G_PCTLr_t;

#define BCM53600_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM53600_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM53600_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_PCTLr_RX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM53600_A0_G_PCTLr_RX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_G_PCTLr_TX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM53600_A0_G_PCTLr_TX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_G_PCTLr_RESERVEDf_GET(r) ((((r).g_pctl[0]) >> 2) & 0xf)
#define BCM53600_A0_G_PCTLr_RESERVEDf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53600_A0_G_PCTLr_G_STP_STATEf_GET(r) ((((r).g_pctl[0]) >> 6) & 0x3)
#define BCM53600_A0_G_PCTLr_G_STP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access G_PCTL.
 *
 */
#define BCM53600_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_PCTLr,(r._g_pctl),1)
#define BCM53600_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM53600_A0_G_PCTLr
#define G_PCTLr_SIZE BCM53600_A0_G_PCTLr_SIZE
typedef BCM53600_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM53600_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM53600_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM53600_A0_G_PCTLr_GET
#define G_PCTLr_RX_DISf_GET BCM53600_A0_G_PCTLr_RX_DISf_GET
#define G_PCTLr_RX_DISf_SET BCM53600_A0_G_PCTLr_RX_DISf_SET
#define G_PCTLr_TX_DISf_GET BCM53600_A0_G_PCTLr_TX_DISf_GET
#define G_PCTLr_TX_DISf_SET BCM53600_A0_G_PCTLr_TX_DISf_SET
#define G_PCTLr_RESERVEDf_GET BCM53600_A0_G_PCTLr_RESERVEDf_GET
#define G_PCTLr_RESERVEDf_SET BCM53600_A0_G_PCTLr_RESERVEDf_SET
#define G_PCTLr_G_STP_STATEf_GET BCM53600_A0_G_PCTLr_G_STP_STATEf_GET
#define G_PCTLr_G_STP_STATEf_SET BCM53600_A0_G_PCTLr_G_STP_STATEf_SET
#define READ_G_PCTLr BCM53600_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM53600_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_PHYIDH
 * BLOCKS:   CPIC GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53600_A0_G_PHYIDHr 0x0000d804

#define BCM53600_A0_G_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH.
 *
 */
typedef union BCM53600_A0_G_PHYIDHr_s {
	uint32_t v[1];
	uint32_t g_phyidh[1];
	uint32_t _g_phyidh;
} BCM53600_A0_G_PHYIDHr_t;

#define BCM53600_A0_G_PHYIDHr_CLR(r) (r).g_phyidh[0] = 0
#define BCM53600_A0_G_PHYIDHr_SET(r,d) (r).g_phyidh[0] = d
#define BCM53600_A0_G_PHYIDHr_GET(r) (r).g_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_PHYIDHr_OUIf_GET(r) (((r).g_phyidh[0]) & 0xffff)
#define BCM53600_A0_G_PHYIDHr_OUIf_SET(r,f) (r).g_phyidh[0]=(((r).g_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH.
 *
 */
#define BCM53600_A0_READ_G_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_PHYIDHr,(r._g_phyidh),2)
#define BCM53600_A0_WRITE_G_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_PHYIDHr,&(r._g_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDHr BCM53600_A0_G_PHYIDHr
#define G_PHYIDHr_SIZE BCM53600_A0_G_PHYIDHr_SIZE
typedef BCM53600_A0_G_PHYIDHr_t G_PHYIDHr_t;
#define G_PHYIDHr_CLR BCM53600_A0_G_PHYIDHr_CLR
#define G_PHYIDHr_SET BCM53600_A0_G_PHYIDHr_SET
#define G_PHYIDHr_GET BCM53600_A0_G_PHYIDHr_GET
#define G_PHYIDHr_OUIf_GET BCM53600_A0_G_PHYIDHr_OUIf_GET
#define G_PHYIDHr_OUIf_SET BCM53600_A0_G_PHYIDHr_OUIf_SET
#define READ_G_PHYIDHr BCM53600_A0_READ_G_PHYIDHr
#define WRITE_G_PHYIDHr BCM53600_A0_WRITE_G_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  G_PHYIDL
 * BLOCKS:   CPIC GPIC0
 * DESC:     PHY ID Low Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53600_A0_G_PHYIDLr 0x0000d806

#define BCM53600_A0_G_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL.
 *
 */
typedef union BCM53600_A0_G_PHYIDLr_s {
	uint32_t v[1];
	uint32_t g_phyidl[1];
	uint32_t _g_phyidl;
} BCM53600_A0_G_PHYIDLr_t;

#define BCM53600_A0_G_PHYIDLr_CLR(r) (r).g_phyidl[0] = 0
#define BCM53600_A0_G_PHYIDLr_SET(r,d) (r).g_phyidl[0] = d
#define BCM53600_A0_G_PHYIDLr_GET(r) (r).g_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_G_PHYIDLr_REVISIONf_GET(r) (((r).g_phyidl[0]) & 0xf)
#define BCM53600_A0_G_PHYIDLr_REVISIONf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_G_PHYIDLr_MODELf_GET(r) ((((r).g_phyidl[0]) >> 4) & 0x3f)
#define BCM53600_A0_G_PHYIDLr_MODELf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53600_A0_G_PHYIDLr_OUIf_GET(r) ((((r).g_phyidl[0]) >> 10) & 0x3f)
#define BCM53600_A0_G_PHYIDLr_OUIf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL.
 *
 */
#define BCM53600_A0_READ_G_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_G_PHYIDLr,(r._g_phyidl),2)
#define BCM53600_A0_WRITE_G_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_G_PHYIDLr,&(r._g_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDLr BCM53600_A0_G_PHYIDLr
#define G_PHYIDLr_SIZE BCM53600_A0_G_PHYIDLr_SIZE
typedef BCM53600_A0_G_PHYIDLr_t G_PHYIDLr_t;
#define G_PHYIDLr_CLR BCM53600_A0_G_PHYIDLr_CLR
#define G_PHYIDLr_SET BCM53600_A0_G_PHYIDLr_SET
#define G_PHYIDLr_GET BCM53600_A0_G_PHYIDLr_GET
#define G_PHYIDLr_REVISIONf_GET BCM53600_A0_G_PHYIDLr_REVISIONf_GET
#define G_PHYIDLr_REVISIONf_SET BCM53600_A0_G_PHYIDLr_REVISIONf_SET
#define G_PHYIDLr_MODELf_GET BCM53600_A0_G_PHYIDLr_MODELf_GET
#define G_PHYIDLr_MODELf_SET BCM53600_A0_G_PHYIDLr_MODELf_SET
#define G_PHYIDLr_OUIf_GET BCM53600_A0_G_PHYIDLr_OUIf_GET
#define G_PHYIDLr_OUIf_SET BCM53600_A0_G_PHYIDLr_OUIf_SET
#define READ_G_PHYIDLr BCM53600_A0_READ_G_PHYIDLr
#define WRITE_G_PHYIDLr BCM53600_A0_WRITE_G_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_G_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     32
 * FIELDS:
 *     IN_MIR_MSK       Ingress Mirror Port Mask29 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIR_CAP_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIR_CAP_PORT.Bits 0-23 = FE PortsBit 24= IMP portBit 25 = Giga port G0Bit 26 = Giga port G1Bit 27 = Giga port G2Bit 28 = Giga port G3
 *     IGMIRCTL_RSRV0   Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_IGMIRCTLr 0x00000320

#define BCM53600_A0_IGMIRCTLr_SIZE 4

/*
 * This structure should be used to declare and program IGMIRCTL.
 *
 */
typedef union BCM53600_A0_IGMIRCTLr_s {
	uint32_t v[1];
	uint32_t igmirctl[1];
	uint32_t _igmirctl;
} BCM53600_A0_IGMIRCTLr_t;

#define BCM53600_A0_IGMIRCTLr_CLR(r) (r).igmirctl[0] = 0
#define BCM53600_A0_IGMIRCTLr_SET(r,d) (r).igmirctl[0] = d
#define BCM53600_A0_IGMIRCTLr_GET(r) (r).igmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) (((r).igmirctl[0]) & 0x1fffffff)
#define BCM53600_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_GET(r) ((((r).igmirctl[0]) >> 29) & 0x7)
#define BCM53600_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access IGMIRCTL.
 *
 */
#define BCM53600_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_IGMIRCTLr,(r._igmirctl),4)
#define BCM53600_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_IGMIRCTLr,&(r._igmirctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM53600_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM53600_A0_IGMIRCTLr_SIZE
typedef BCM53600_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM53600_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM53600_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM53600_A0_IGMIRCTLr_GET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM53600_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM53600_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_IGMIRCTL_RSRV0f_GET BCM53600_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_GET
#define IGMIRCTLr_IGMIRCTL_RSRV0f_SET BCM53600_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_SET
#define READ_IGMIRCTLr BCM53600_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM53600_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  IMP_PCTL
 * BLOCKS:   CPIC
 * DESC:     IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RX_BC_EN         Receive Broadcast Enable.Ignored if the MII/IMP port is not selected as the Frame Management Port.
 *     RX_MC_DLF_EN     Receive Unknown Multicast Enable.Enable the receipt of Unknown multicast DLF frame on the IMP, when the MII port isconfigured as the Frame management Port, and the frame was flooded dueto no matching address table entry.Ignored if the MII/IMP port is not selected as the Frame Management Port.
 *     RX_UC_DLF_EN     Receive Unknown Unicast Enable.Enable the receipt of Unknown unicast DLF frame on the IMP, when the MII port isconfigured as the Frame management Port, and the frame was flooded dueto no matching address table entry.Ignored if the MII/IMP port is not selected as the Frame Management Port.
 *     RESERVED         Reserved
 *     STP_STATE        CPU writes the current computed states of its Spanning Tree Algorithmfor this port.2'b00: Disable State(default for managed mode).2'b01: Discarding State.2'b10: Learning State.2'b11: Forwarding State(default for unmanaged mode).For BCM53602/BCM53603/BCM53604: Default value is read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently.If HW_FWDG_EN pin = 1, the default value = "11"(Forwarding State).If HW_FWDG_EN pin = 0, the default value = "0"(Disable State).For BCM53606/BCM53608: Default value is "11"(Forwarding State).
 *
 ******************************************************************************/
#define BCM53600_A0_IMP_PCTLr 0x000001a8

#define BCM53600_A0_IMP_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_PCTL.
 *
 */
typedef union BCM53600_A0_IMP_PCTLr_s {
	uint32_t v[1];
	uint32_t imp_pctl[1];
	uint32_t _imp_pctl;
} BCM53600_A0_IMP_PCTLr_t;

#define BCM53600_A0_IMP_PCTLr_CLR(r) (r).imp_pctl[0] = 0
#define BCM53600_A0_IMP_PCTLr_SET(r,d) (r).imp_pctl[0] = d
#define BCM53600_A0_IMP_PCTLr_GET(r) (r).imp_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IMP_PCTLr_RX_DISf_GET(r) (((r).imp_pctl[0]) & 0x1)
#define BCM53600_A0_IMP_PCTLr_RX_DISf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_IMP_PCTLr_TX_DISf_GET(r) ((((r).imp_pctl[0]) >> 1) & 0x1)
#define BCM53600_A0_IMP_PCTLr_TX_DISf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_IMP_PCTLr_RX_BC_ENf_GET(r) ((((r).imp_pctl[0]) >> 2) & 0x1)
#define BCM53600_A0_IMP_PCTLr_RX_BC_ENf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_IMP_PCTLr_RX_MC_DLF_ENf_GET(r) ((((r).imp_pctl[0]) >> 3) & 0x1)
#define BCM53600_A0_IMP_PCTLr_RX_MC_DLF_ENf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_IMP_PCTLr_RX_UC_DLF_ENf_GET(r) ((((r).imp_pctl[0]) >> 4) & 0x1)
#define BCM53600_A0_IMP_PCTLr_RX_UC_DLF_ENf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_IMP_PCTLr_RESERVEDf_GET(r) ((((r).imp_pctl[0]) >> 5) & 0x1)
#define BCM53600_A0_IMP_PCTLr_RESERVEDf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_IMP_PCTLr_STP_STATEf_GET(r) ((((r).imp_pctl[0]) >> 6) & 0x3)
#define BCM53600_A0_IMP_PCTLr_STP_STATEf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP_PCTL.
 *
 */
#define BCM53600_A0_READ_IMP_PCTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_IMP_PCTLr,(r._imp_pctl),1)
#define BCM53600_A0_WRITE_IMP_PCTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_IMP_PCTLr,&(r._imp_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_PCTLr BCM53600_A0_IMP_PCTLr
#define IMP_PCTLr_SIZE BCM53600_A0_IMP_PCTLr_SIZE
typedef BCM53600_A0_IMP_PCTLr_t IMP_PCTLr_t;
#define IMP_PCTLr_CLR BCM53600_A0_IMP_PCTLr_CLR
#define IMP_PCTLr_SET BCM53600_A0_IMP_PCTLr_SET
#define IMP_PCTLr_GET BCM53600_A0_IMP_PCTLr_GET
#define IMP_PCTLr_RX_DISf_GET BCM53600_A0_IMP_PCTLr_RX_DISf_GET
#define IMP_PCTLr_RX_DISf_SET BCM53600_A0_IMP_PCTLr_RX_DISf_SET
#define IMP_PCTLr_TX_DISf_GET BCM53600_A0_IMP_PCTLr_TX_DISf_GET
#define IMP_PCTLr_TX_DISf_SET BCM53600_A0_IMP_PCTLr_TX_DISf_SET
#define IMP_PCTLr_RX_BC_ENf_GET BCM53600_A0_IMP_PCTLr_RX_BC_ENf_GET
#define IMP_PCTLr_RX_BC_ENf_SET BCM53600_A0_IMP_PCTLr_RX_BC_ENf_SET
#define IMP_PCTLr_RX_MC_DLF_ENf_GET BCM53600_A0_IMP_PCTLr_RX_MC_DLF_ENf_GET
#define IMP_PCTLr_RX_MC_DLF_ENf_SET BCM53600_A0_IMP_PCTLr_RX_MC_DLF_ENf_SET
#define IMP_PCTLr_RX_UC_DLF_ENf_GET BCM53600_A0_IMP_PCTLr_RX_UC_DLF_ENf_GET
#define IMP_PCTLr_RX_UC_DLF_ENf_SET BCM53600_A0_IMP_PCTLr_RX_UC_DLF_ENf_SET
#define IMP_PCTLr_RESERVEDf_GET BCM53600_A0_IMP_PCTLr_RESERVEDf_GET
#define IMP_PCTLr_RESERVEDf_SET BCM53600_A0_IMP_PCTLr_RESERVEDf_SET
#define IMP_PCTLr_STP_STATEf_GET BCM53600_A0_IMP_PCTLr_STP_STATEf_GET
#define IMP_PCTLr_STP_STATEf_SET BCM53600_A0_IMP_PCTLr_STP_STATEf_SET
#define READ_IMP_PCTLr BCM53600_A0_READ_IMP_PCTLr
#define WRITE_IMP_PCTLr BCM53600_A0_WRITE_IMP_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IMP_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  INGRESS_SFLOW
 * BLOCKS:   SYS
 * DESC:     Ingress SFLOW Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1       Reserved.
 *     INGRESS_CFG      Ingress Sflow Setting.A exponential value indicating the percentage of traffic that will be copied toCPU due to Ingress extended Sflow.percentage = 1/(2^(value+1)).
 *
 ******************************************************************************/
#define BCM53600_A0_INGRESS_SFLOWr 0x00000360

#define BCM53600_A0_INGRESS_SFLOWr_SIZE 1

/*
 * This structure should be used to declare and program INGRESS_SFLOW.
 *
 */
typedef union BCM53600_A0_INGRESS_SFLOWr_s {
	uint32_t v[1];
	uint32_t ingress_sflow[1];
	uint32_t _ingress_sflow;
} BCM53600_A0_INGRESS_SFLOWr_t;

#define BCM53600_A0_INGRESS_SFLOWr_CLR(r) (r).ingress_sflow[0] = 0
#define BCM53600_A0_INGRESS_SFLOWr_SET(r,d) (r).ingress_sflow[0] = d
#define BCM53600_A0_INGRESS_SFLOWr_GET(r) (r).ingress_sflow[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_INGRESS_SFLOWr_RESERVED_1f_GET(r) (((r).ingress_sflow[0]) & 0xf)
#define BCM53600_A0_INGRESS_SFLOWr_RESERVED_1f_SET(r,f) (r).ingress_sflow[0]=(((r).ingress_sflow[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_INGRESS_SFLOWr_INGRESS_CFGf_GET(r) ((((r).ingress_sflow[0]) >> 4) & 0xf)
#define BCM53600_A0_INGRESS_SFLOWr_INGRESS_CFGf_SET(r,f) (r).ingress_sflow[0]=(((r).ingress_sflow[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access INGRESS_SFLOW.
 *
 */
#define BCM53600_A0_READ_INGRESS_SFLOWr(u,r) cdk_robo_reg_read(u,BCM53600_A0_INGRESS_SFLOWr,(r._ingress_sflow),1)
#define BCM53600_A0_WRITE_INGRESS_SFLOWr(u,r) cdk_robo_reg_write(u,BCM53600_A0_INGRESS_SFLOWr,&(r._ingress_sflow),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INGRESS_SFLOWr BCM53600_A0_INGRESS_SFLOWr
#define INGRESS_SFLOWr_SIZE BCM53600_A0_INGRESS_SFLOWr_SIZE
typedef BCM53600_A0_INGRESS_SFLOWr_t INGRESS_SFLOWr_t;
#define INGRESS_SFLOWr_CLR BCM53600_A0_INGRESS_SFLOWr_CLR
#define INGRESS_SFLOWr_SET BCM53600_A0_INGRESS_SFLOWr_SET
#define INGRESS_SFLOWr_GET BCM53600_A0_INGRESS_SFLOWr_GET
#define INGRESS_SFLOWr_RESERVED_1f_GET BCM53600_A0_INGRESS_SFLOWr_RESERVED_1f_GET
#define INGRESS_SFLOWr_RESERVED_1f_SET BCM53600_A0_INGRESS_SFLOWr_RESERVED_1f_SET
#define INGRESS_SFLOWr_INGRESS_CFGf_GET BCM53600_A0_INGRESS_SFLOWr_INGRESS_CFGf_GET
#define INGRESS_SFLOWr_INGRESS_CFGf_SET BCM53600_A0_INGRESS_SFLOWr_INGRESS_CFGf_SET
#define READ_INGRESS_SFLOWr BCM53600_A0_READ_INGRESS_SFLOWr
#define WRITE_INGRESS_SFLOWr BCM53600_A0_WRITE_INGRESS_SFLOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_INGRESS_SFLOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  INGRESS_SFLOW_PORT
 * BLOCKS:   SYS
 * DESC:     Ingress SFLOW Port Register
 * SIZE:     32
 * FIELDS:
 *     EN_INGRESS_PORTMAP Ingress SFLOW Enabled port map.A 29-bit mask which selectively allows any port with itscorresponding bits set, to enable Ingress Extended Sflow.Note:Bit 24 is reserved and must be set to 0.-Bit28 = GigaPort G3-Bit27 = GigaPort G2-Bit26 = GigaPort G1-Bit25 = GigaPort G0-Bit24 = Reserved. Must be 0.-Bit23:0 = Local 10/100 ports[port23-port0]A '1' indicates that the corresponding port is ingress extended Sflow enableand will copy packet to the IMP port.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_INGRESS_SFLOW_PORTr 0x00000368

#define BCM53600_A0_INGRESS_SFLOW_PORTr_SIZE 4

/*
 * This structure should be used to declare and program INGRESS_SFLOW_PORT.
 *
 */
typedef union BCM53600_A0_INGRESS_SFLOW_PORTr_s {
	uint32_t v[1];
	uint32_t ingress_sflow_port[1];
	uint32_t _ingress_sflow_port;
} BCM53600_A0_INGRESS_SFLOW_PORTr_t;

#define BCM53600_A0_INGRESS_SFLOW_PORTr_CLR(r) (r).ingress_sflow_port[0] = 0
#define BCM53600_A0_INGRESS_SFLOW_PORTr_SET(r,d) (r).ingress_sflow_port[0] = d
#define BCM53600_A0_INGRESS_SFLOW_PORTr_GET(r) (r).ingress_sflow_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_INGRESS_SFLOW_PORTr_EN_INGRESS_PORTMAPf_GET(r) (((r).ingress_sflow_port[0]) & 0x1fffffff)
#define BCM53600_A0_INGRESS_SFLOW_PORTr_EN_INGRESS_PORTMAPf_SET(r,f) (r).ingress_sflow_port[0]=(((r).ingress_sflow_port[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_INGRESS_SFLOW_PORTr_RESERVEDf_GET(r) ((((r).ingress_sflow_port[0]) >> 29) & 0x7)
#define BCM53600_A0_INGRESS_SFLOW_PORTr_RESERVEDf_SET(r,f) (r).ingress_sflow_port[0]=(((r).ingress_sflow_port[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access INGRESS_SFLOW_PORT.
 *
 */
#define BCM53600_A0_READ_INGRESS_SFLOW_PORTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_INGRESS_SFLOW_PORTr,(r._ingress_sflow_port),4)
#define BCM53600_A0_WRITE_INGRESS_SFLOW_PORTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_INGRESS_SFLOW_PORTr,&(r._ingress_sflow_port),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INGRESS_SFLOW_PORTr BCM53600_A0_INGRESS_SFLOW_PORTr
#define INGRESS_SFLOW_PORTr_SIZE BCM53600_A0_INGRESS_SFLOW_PORTr_SIZE
typedef BCM53600_A0_INGRESS_SFLOW_PORTr_t INGRESS_SFLOW_PORTr_t;
#define INGRESS_SFLOW_PORTr_CLR BCM53600_A0_INGRESS_SFLOW_PORTr_CLR
#define INGRESS_SFLOW_PORTr_SET BCM53600_A0_INGRESS_SFLOW_PORTr_SET
#define INGRESS_SFLOW_PORTr_GET BCM53600_A0_INGRESS_SFLOW_PORTr_GET
#define INGRESS_SFLOW_PORTr_EN_INGRESS_PORTMAPf_GET BCM53600_A0_INGRESS_SFLOW_PORTr_EN_INGRESS_PORTMAPf_GET
#define INGRESS_SFLOW_PORTr_EN_INGRESS_PORTMAPf_SET BCM53600_A0_INGRESS_SFLOW_PORTr_EN_INGRESS_PORTMAPf_SET
#define INGRESS_SFLOW_PORTr_RESERVEDf_GET BCM53600_A0_INGRESS_SFLOW_PORTr_RESERVEDf_GET
#define INGRESS_SFLOW_PORTr_RESERVEDf_SET BCM53600_A0_INGRESS_SFLOW_PORTr_RESERVEDf_SET
#define READ_INGRESS_SFLOW_PORTr BCM53600_A0_READ_INGRESS_SFLOW_PORTr
#define WRITE_INGRESS_SFLOW_PORTr BCM53600_A0_WRITE_INGRESS_SFLOW_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_INGRESS_SFLOW_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IRC_PORT
 * BLOCKS:   SYS
 * DESC:     IRC PORT Table
 * SIZE:     121
 * FIELDS:
 *     BKT0_REF_CNT     Bucket 0 ingress rate refresh count
 *     BKT0_BKT_SIZE    Bucket 0 ingress rate bucket size
 *     BKT0_PKT_MASK    Bucket 0 ingress rate pkt mask
 *     BKT0_IRC_EN      Bucket 0 ingress rate enable
 *     BKT1_REF_CNT     Bucket 1 ingress rate refresh count
 *     BKT1_BKT_SIZE    Bucket 1 ingress rate bucket size
 *     BKT1_PKT_MASK    Bucket 1 ingress rate pkt mask
 *     BKT1_IRC_EN      Bucket 1 ingress rate enable
 *     BKT2_REF_CNT     Bucket 2 ingress rate refresh count
 *     BKT2_BKT_SIZE    Bucket 2 ingress rate bucket size
 *     BKT2_PKT_MASK    Bucket 2 ingress rate pkt mask
 *     BKT2_IRC_EN      Bucket 2 ingress rate control enable
 *     EN_DROP          rate violation drop enable
 *
 ******************************************************************************/
#define BCM53600_A0_IRC_PORTm 0x00000000

#define BCM53600_A0_IRC_PORTm_MIN 0
#define BCM53600_A0_IRC_PORTm_MAX 28
#define BCM53600_A0_IRC_PORTm_CMAX(u) 28
#define BCM53600_A0_IRC_PORTm_SIZE 16

/*
 * This structure should be used to declare and program IRC_PORT.
 *
 */
typedef union BCM53600_A0_IRC_PORTm_s {
	uint32_t v[4];
	uint32_t irc_port[4];
	uint32_t _irc_port;
} BCM53600_A0_IRC_PORTm_t;

#define BCM53600_A0_IRC_PORTm_CLR(r) CDK_MEMSET(&((r)._irc_port), 0, sizeof(BCM53600_A0_IRC_PORTm_t))
#define BCM53600_A0_IRC_PORTm_SET(r,i,d) (r).irc_port[i] = d
#define BCM53600_A0_IRC_PORTm_GET(r,i) (r).irc_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IRC_PORTm_BKT0_REF_CNTf_GET(r) (((r).irc_port[0]) & 0x1ffff)
#define BCM53600_A0_IRC_PORTm_BKT0_REF_CNTf_SET(r,f) (r).irc_port[0]=(((r).irc_port[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53600_A0_IRC_PORTm_BKT0_BKT_SIZEf_GET(r) cdk_field32_get((r).irc_port,17,32)
#define BCM53600_A0_IRC_PORTm_BKT0_BKT_SIZEf_SET(r,f) cdk_field32_set((r).irc_port,17,32,f)
#define BCM53600_A0_IRC_PORTm_BKT0_PKT_MASKf_GET(r) ((((r).irc_port[1]) >> 1) & 0x3f)
#define BCM53600_A0_IRC_PORTm_BKT0_PKT_MASKf_SET(r,f) (r).irc_port[1]=(((r).irc_port[1] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53600_A0_IRC_PORTm_BKT0_IRC_ENf_GET(r) ((((r).irc_port[1]) >> 7) & 0x1)
#define BCM53600_A0_IRC_PORTm_BKT0_IRC_ENf_SET(r,f) (r).irc_port[1]=(((r).irc_port[1] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_IRC_PORTm_BKT1_REF_CNTf_GET(r) ((((r).irc_port[1]) >> 8) & 0x1ffff)
#define BCM53600_A0_IRC_PORTm_BKT1_REF_CNTf_SET(r,f) (r).irc_port[1]=(((r).irc_port[1] & ~((uint32_t)0x1ffff << 8)) | ((((uint32_t)f) & 0x1ffff) << 8))
#define BCM53600_A0_IRC_PORTm_BKT1_BKT_SIZEf_GET(r) cdk_field32_get((r).irc_port,57,72)
#define BCM53600_A0_IRC_PORTm_BKT1_BKT_SIZEf_SET(r,f) cdk_field32_set((r).irc_port,57,72,f)
#define BCM53600_A0_IRC_PORTm_BKT1_PKT_MASKf_GET(r) ((((r).irc_port[2]) >> 9) & 0x3f)
#define BCM53600_A0_IRC_PORTm_BKT1_PKT_MASKf_SET(r,f) (r).irc_port[2]=(((r).irc_port[2] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM53600_A0_IRC_PORTm_BKT1_IRC_ENf_GET(r) ((((r).irc_port[2]) >> 15) & 0x1)
#define BCM53600_A0_IRC_PORTm_BKT1_IRC_ENf_SET(r,f) (r).irc_port[2]=(((r).irc_port[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_IRC_PORTm_BKT2_REF_CNTf_GET(r) cdk_field32_get((r).irc_port,80,96)
#define BCM53600_A0_IRC_PORTm_BKT2_REF_CNTf_SET(r,f) cdk_field32_set((r).irc_port,80,96,f)
#define BCM53600_A0_IRC_PORTm_BKT2_BKT_SIZEf_GET(r) ((((r).irc_port[3]) >> 1) & 0xffff)
#define BCM53600_A0_IRC_PORTm_BKT2_BKT_SIZEf_SET(r,f) (r).irc_port[3]=(((r).irc_port[3] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53600_A0_IRC_PORTm_BKT2_PKT_MASKf_GET(r) ((((r).irc_port[3]) >> 17) & 0x3f)
#define BCM53600_A0_IRC_PORTm_BKT2_PKT_MASKf_SET(r,f) (r).irc_port[3]=(((r).irc_port[3] & ~((uint32_t)0x3f << 17)) | ((((uint32_t)f) & 0x3f) << 17))
#define BCM53600_A0_IRC_PORTm_BKT2_IRC_ENf_GET(r) ((((r).irc_port[3]) >> 23) & 0x1)
#define BCM53600_A0_IRC_PORTm_BKT2_IRC_ENf_SET(r,f) (r).irc_port[3]=(((r).irc_port[3] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53600_A0_IRC_PORTm_EN_DROPf_GET(r) ((((r).irc_port[3]) >> 24) & 0x1)
#define BCM53600_A0_IRC_PORTm_EN_DROPf_SET(r,f) (r).irc_port[3]=(((r).irc_port[3] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access IRC_PORT.
 *
 */
#define BCM53600_A0_READ_IRC_PORTm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IRC_PORTm,i,(m),16)
#define BCM53600_A0_WRITE_IRC_PORTm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IRC_PORTm,i,&(m),16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRC_PORTm BCM53600_A0_IRC_PORTm
#define IRC_PORTm_MIN BCM53600_A0_IRC_PORTm_MIN
#define IRC_PORTm_MAX BCM53600_A0_IRC_PORTm_MAX
#define IRC_PORTm_CMAX(u) BCM53600_A0_IRC_PORTm_CMAX(u)
#define IRC_PORTm_SIZE BCM53600_A0_IRC_PORTm_SIZE
typedef BCM53600_A0_IRC_PORTm_t IRC_PORTm_t;
#define IRC_PORTm_CLR BCM53600_A0_IRC_PORTm_CLR
#define IRC_PORTm_SET BCM53600_A0_IRC_PORTm_SET
#define IRC_PORTm_GET BCM53600_A0_IRC_PORTm_GET
#define IRC_PORTm_BKT0_REF_CNTf_GET BCM53600_A0_IRC_PORTm_BKT0_REF_CNTf_GET
#define IRC_PORTm_BKT0_REF_CNTf_SET BCM53600_A0_IRC_PORTm_BKT0_REF_CNTf_SET
#define IRC_PORTm_BKT0_BKT_SIZEf_GET BCM53600_A0_IRC_PORTm_BKT0_BKT_SIZEf_GET
#define IRC_PORTm_BKT0_BKT_SIZEf_SET BCM53600_A0_IRC_PORTm_BKT0_BKT_SIZEf_SET
#define IRC_PORTm_BKT0_PKT_MASKf_GET BCM53600_A0_IRC_PORTm_BKT0_PKT_MASKf_GET
#define IRC_PORTm_BKT0_PKT_MASKf_SET BCM53600_A0_IRC_PORTm_BKT0_PKT_MASKf_SET
#define IRC_PORTm_BKT0_IRC_ENf_GET BCM53600_A0_IRC_PORTm_BKT0_IRC_ENf_GET
#define IRC_PORTm_BKT0_IRC_ENf_SET BCM53600_A0_IRC_PORTm_BKT0_IRC_ENf_SET
#define IRC_PORTm_BKT1_REF_CNTf_GET BCM53600_A0_IRC_PORTm_BKT1_REF_CNTf_GET
#define IRC_PORTm_BKT1_REF_CNTf_SET BCM53600_A0_IRC_PORTm_BKT1_REF_CNTf_SET
#define IRC_PORTm_BKT1_BKT_SIZEf_GET BCM53600_A0_IRC_PORTm_BKT1_BKT_SIZEf_GET
#define IRC_PORTm_BKT1_BKT_SIZEf_SET BCM53600_A0_IRC_PORTm_BKT1_BKT_SIZEf_SET
#define IRC_PORTm_BKT1_PKT_MASKf_GET BCM53600_A0_IRC_PORTm_BKT1_PKT_MASKf_GET
#define IRC_PORTm_BKT1_PKT_MASKf_SET BCM53600_A0_IRC_PORTm_BKT1_PKT_MASKf_SET
#define IRC_PORTm_BKT1_IRC_ENf_GET BCM53600_A0_IRC_PORTm_BKT1_IRC_ENf_GET
#define IRC_PORTm_BKT1_IRC_ENf_SET BCM53600_A0_IRC_PORTm_BKT1_IRC_ENf_SET
#define IRC_PORTm_BKT2_REF_CNTf_GET BCM53600_A0_IRC_PORTm_BKT2_REF_CNTf_GET
#define IRC_PORTm_BKT2_REF_CNTf_SET BCM53600_A0_IRC_PORTm_BKT2_REF_CNTf_SET
#define IRC_PORTm_BKT2_BKT_SIZEf_GET BCM53600_A0_IRC_PORTm_BKT2_BKT_SIZEf_GET
#define IRC_PORTm_BKT2_BKT_SIZEf_SET BCM53600_A0_IRC_PORTm_BKT2_BKT_SIZEf_SET
#define IRC_PORTm_BKT2_PKT_MASKf_GET BCM53600_A0_IRC_PORTm_BKT2_PKT_MASKf_GET
#define IRC_PORTm_BKT2_PKT_MASKf_SET BCM53600_A0_IRC_PORTm_BKT2_PKT_MASKf_SET
#define IRC_PORTm_BKT2_IRC_ENf_GET BCM53600_A0_IRC_PORTm_BKT2_IRC_ENf_GET
#define IRC_PORTm_BKT2_IRC_ENf_SET BCM53600_A0_IRC_PORTm_BKT2_IRC_ENf_SET
#define IRC_PORTm_EN_DROPf_GET BCM53600_A0_IRC_PORTm_EN_DROPf_GET
#define IRC_PORTm_EN_DROPf_SET BCM53600_A0_IRC_PORTm_EN_DROPf_SET
#define READ_IRC_PORTm BCM53600_A0_READ_IRC_PORTm
#define WRITE_IRC_PORTm BCM53600_A0_WRITE_IRC_PORTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IRC_PORTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  ISP_SEL_PORTMAP
 * BLOCKS:   SYS
 * DESC:     ISP Port Selection Portmap Registers
 * SIZE:     32
 * FIELDS:
 *     ISP_PORTMAP      Portmap to define which port as ISP-port.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_ISP_SEL_PORTMAPr 0x00003408

#define BCM53600_A0_ISP_SEL_PORTMAPr_SIZE 4

/*
 * This structure should be used to declare and program ISP_SEL_PORTMAP.
 *
 */
typedef union BCM53600_A0_ISP_SEL_PORTMAPr_s {
	uint32_t v[1];
	uint32_t isp_sel_portmap[1];
	uint32_t _isp_sel_portmap;
} BCM53600_A0_ISP_SEL_PORTMAPr_t;

#define BCM53600_A0_ISP_SEL_PORTMAPr_CLR(r) (r).isp_sel_portmap[0] = 0
#define BCM53600_A0_ISP_SEL_PORTMAPr_SET(r,d) (r).isp_sel_portmap[0] = d
#define BCM53600_A0_ISP_SEL_PORTMAPr_GET(r) (r).isp_sel_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET(r) (((r).isp_sel_portmap[0]) & 0x1fffffff)
#define BCM53600_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET(r) ((((r).isp_sel_portmap[0]) >> 29) & 0x7)
#define BCM53600_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access ISP_SEL_PORTMAP.
 *
 */
#define BCM53600_A0_READ_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_ISP_SEL_PORTMAPr,(r._isp_sel_portmap),4)
#define BCM53600_A0_WRITE_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_ISP_SEL_PORTMAPr,&(r._isp_sel_portmap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_SEL_PORTMAPr BCM53600_A0_ISP_SEL_PORTMAPr
#define ISP_SEL_PORTMAPr_SIZE BCM53600_A0_ISP_SEL_PORTMAPr_SIZE
typedef BCM53600_A0_ISP_SEL_PORTMAPr_t ISP_SEL_PORTMAPr_t;
#define ISP_SEL_PORTMAPr_CLR BCM53600_A0_ISP_SEL_PORTMAPr_CLR
#define ISP_SEL_PORTMAPr_SET BCM53600_A0_ISP_SEL_PORTMAPr_SET
#define ISP_SEL_PORTMAPr_GET BCM53600_A0_ISP_SEL_PORTMAPr_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET BCM53600_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET BCM53600_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET
#define ISP_SEL_PORTMAPr_RESERVEDf_GET BCM53600_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET
#define ISP_SEL_PORTMAPr_RESERVEDf_SET BCM53600_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET
#define READ_ISP_SEL_PORTMAPr BCM53600_A0_READ_ISP_SEL_PORTMAPr
#define WRITE_ISP_SEL_PORTMAPr BCM53600_A0_WRITE_ISP_SEL_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ISP_SEL_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  ISP_TPID
 * BLOCKS:   SYS
 * DESC:     ISP TPID Control Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_VLAN_DELIMITER The Delimiter of ISP Tagged frame. The Delimiter of .1Q tagged frame is8100.
 *
 ******************************************************************************/
#define BCM53600_A0_ISP_TPIDr 0x00003406

#define BCM53600_A0_ISP_TPIDr_SIZE 2

/*
 * This structure should be used to declare and program ISP_TPID.
 *
 */
typedef union BCM53600_A0_ISP_TPIDr_s {
	uint32_t v[1];
	uint32_t isp_tpid[1];
	uint32_t _isp_tpid;
} BCM53600_A0_ISP_TPIDr_t;

#define BCM53600_A0_ISP_TPIDr_CLR(r) (r).isp_tpid[0] = 0
#define BCM53600_A0_ISP_TPIDr_SET(r,d) (r).isp_tpid[0] = d
#define BCM53600_A0_ISP_TPIDr_GET(r) (r).isp_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_ISP_TPIDr_ISP_VLAN_DELIMITERf_GET(r) (((r).isp_tpid[0]) & 0xffff)
#define BCM53600_A0_ISP_TPIDr_ISP_VLAN_DELIMITERf_SET(r,f) (r).isp_tpid[0]=(((r).isp_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ISP_TPID.
 *
 */
#define BCM53600_A0_READ_ISP_TPIDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_ISP_TPIDr,(r._isp_tpid),2)
#define BCM53600_A0_WRITE_ISP_TPIDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_ISP_TPIDr,&(r._isp_tpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_TPIDr BCM53600_A0_ISP_TPIDr
#define ISP_TPIDr_SIZE BCM53600_A0_ISP_TPIDr_SIZE
typedef BCM53600_A0_ISP_TPIDr_t ISP_TPIDr_t;
#define ISP_TPIDr_CLR BCM53600_A0_ISP_TPIDr_CLR
#define ISP_TPIDr_SET BCM53600_A0_ISP_TPIDr_SET
#define ISP_TPIDr_GET BCM53600_A0_ISP_TPIDr_GET
#define ISP_TPIDr_ISP_VLAN_DELIMITERf_GET BCM53600_A0_ISP_TPIDr_ISP_VLAN_DELIMITERf_GET
#define ISP_TPIDr_ISP_VLAN_DELIMITERf_SET BCM53600_A0_ISP_TPIDr_ISP_VLAN_DELIMITERf_SET
#define READ_ISP_TPIDr BCM53600_A0_READ_ISP_TPIDr
#define WRITE_ISP_TPIDr BCM53600_A0_WRITE_ISP_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_ISP_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_ACT
 * BLOCKS:   SYS
 * DESC:     IVM Action Table
 * SIZE:     44
 * FIELDS:
 *     VPORT_TC         VPORT DP
 *     VPORT_DP         VPORT TC
 *     VPORT_CPCP       VPORT CPCP
 *     VPORT_SPCP       VPORT SPCP
 *     VPORT_ID         VPORT id
 *     FLOW_ID          Flow id
 *     NEW_VID          Vlan id
 *     CPCP_MARK        CPCP Marking Policy
 *     SPCP_MARK        SPCP Marking Policy
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_ACTm 0x00000000

#define BCM53600_A0_IVM_ACTm_MIN 0
#define BCM53600_A0_IVM_ACTm_MAX 2047
#define BCM53600_A0_IVM_ACTm_CMAX(u) 2047
#define BCM53600_A0_IVM_ACTm_SIZE 6

/*
 * This structure should be used to declare and program IVM_ACT.
 *
 */
typedef union BCM53600_A0_IVM_ACTm_s {
	uint32_t v[2];
	uint32_t ivm_act[2];
	uint32_t _ivm_act;
} BCM53600_A0_IVM_ACTm_t;

#define BCM53600_A0_IVM_ACTm_CLR(r) CDK_MEMSET(&((r)._ivm_act), 0, sizeof(BCM53600_A0_IVM_ACTm_t))
#define BCM53600_A0_IVM_ACTm_SET(r,i,d) (r).ivm_act[i] = d
#define BCM53600_A0_IVM_ACTm_GET(r,i) (r).ivm_act[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_ACTm_VPORT_TCf_GET(r) (((r).ivm_act[0]) & 0xf)
#define BCM53600_A0_IVM_ACTm_VPORT_TCf_SET(r,f) (r).ivm_act[0]=(((r).ivm_act[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_IVM_ACTm_VPORT_DPf_GET(r) ((((r).ivm_act[0]) >> 4) & 0x3)
#define BCM53600_A0_IVM_ACTm_VPORT_DPf_SET(r,f) (r).ivm_act[0]=(((r).ivm_act[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53600_A0_IVM_ACTm_VPORT_CPCPf_GET(r) ((((r).ivm_act[0]) >> 6) & 0x7)
#define BCM53600_A0_IVM_ACTm_VPORT_CPCPf_SET(r,f) (r).ivm_act[0]=(((r).ivm_act[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53600_A0_IVM_ACTm_VPORT_SPCPf_GET(r) ((((r).ivm_act[0]) >> 9) & 0x7)
#define BCM53600_A0_IVM_ACTm_VPORT_SPCPf_SET(r,f) (r).ivm_act[0]=(((r).ivm_act[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53600_A0_IVM_ACTm_VPORT_IDf_GET(r) ((((r).ivm_act[0]) >> 12) & 0xf)
#define BCM53600_A0_IVM_ACTm_VPORT_IDf_SET(r,f) (r).ivm_act[0]=(((r).ivm_act[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_IVM_ACTm_FLOW_IDf_GET(r) ((((r).ivm_act[0]) >> 16) & 0xfff)
#define BCM53600_A0_IVM_ACTm_FLOW_IDf_SET(r,f) (r).ivm_act[0]=(((r).ivm_act[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_IVM_ACTm_NEW_VIDf_GET(r) cdk_field32_get((r).ivm_act,28,39)
#define BCM53600_A0_IVM_ACTm_NEW_VIDf_SET(r,f) cdk_field32_set((r).ivm_act,28,39,f)
#define BCM53600_A0_IVM_ACTm_CPCP_MARKf_GET(r) ((((r).ivm_act[1]) >> 8) & 0x3)
#define BCM53600_A0_IVM_ACTm_CPCP_MARKf_SET(r,f) (r).ivm_act[1]=(((r).ivm_act[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53600_A0_IVM_ACTm_SPCP_MARKf_GET(r) ((((r).ivm_act[1]) >> 10) & 0x3)
#define BCM53600_A0_IVM_ACTm_SPCP_MARKf_SET(r,f) (r).ivm_act[1]=(((r).ivm_act[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))

/*
 * These macros can be used to access IVM_ACT.
 *
 */
#define BCM53600_A0_READ_IVM_ACTm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_ACTm,i,(m),6)
#define BCM53600_A0_WRITE_IVM_ACTm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_ACTm,i,&(m),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_ACTm BCM53600_A0_IVM_ACTm
#define IVM_ACTm_MIN BCM53600_A0_IVM_ACTm_MIN
#define IVM_ACTm_MAX BCM53600_A0_IVM_ACTm_MAX
#define IVM_ACTm_CMAX(u) BCM53600_A0_IVM_ACTm_CMAX(u)
#define IVM_ACTm_SIZE BCM53600_A0_IVM_ACTm_SIZE
typedef BCM53600_A0_IVM_ACTm_t IVM_ACTm_t;
#define IVM_ACTm_CLR BCM53600_A0_IVM_ACTm_CLR
#define IVM_ACTm_SET BCM53600_A0_IVM_ACTm_SET
#define IVM_ACTm_GET BCM53600_A0_IVM_ACTm_GET
#define IVM_ACTm_VPORT_TCf_GET BCM53600_A0_IVM_ACTm_VPORT_TCf_GET
#define IVM_ACTm_VPORT_TCf_SET BCM53600_A0_IVM_ACTm_VPORT_TCf_SET
#define IVM_ACTm_VPORT_DPf_GET BCM53600_A0_IVM_ACTm_VPORT_DPf_GET
#define IVM_ACTm_VPORT_DPf_SET BCM53600_A0_IVM_ACTm_VPORT_DPf_SET
#define IVM_ACTm_VPORT_CPCPf_GET BCM53600_A0_IVM_ACTm_VPORT_CPCPf_GET
#define IVM_ACTm_VPORT_CPCPf_SET BCM53600_A0_IVM_ACTm_VPORT_CPCPf_SET
#define IVM_ACTm_VPORT_SPCPf_GET BCM53600_A0_IVM_ACTm_VPORT_SPCPf_GET
#define IVM_ACTm_VPORT_SPCPf_SET BCM53600_A0_IVM_ACTm_VPORT_SPCPf_SET
#define IVM_ACTm_VPORT_IDf_GET BCM53600_A0_IVM_ACTm_VPORT_IDf_GET
#define IVM_ACTm_VPORT_IDf_SET BCM53600_A0_IVM_ACTm_VPORT_IDf_SET
#define IVM_ACTm_FLOW_IDf_GET BCM53600_A0_IVM_ACTm_FLOW_IDf_GET
#define IVM_ACTm_FLOW_IDf_SET BCM53600_A0_IVM_ACTm_FLOW_IDf_SET
#define IVM_ACTm_NEW_VIDf_GET BCM53600_A0_IVM_ACTm_NEW_VIDf_GET
#define IVM_ACTm_NEW_VIDf_SET BCM53600_A0_IVM_ACTm_NEW_VIDf_SET
#define IVM_ACTm_CPCP_MARKf_GET BCM53600_A0_IVM_ACTm_CPCP_MARKf_GET
#define IVM_ACTm_CPCP_MARKf_SET BCM53600_A0_IVM_ACTm_CPCP_MARKf_SET
#define IVM_ACTm_SPCP_MARKf_GET BCM53600_A0_IVM_ACTm_SPCP_MARKf_GET
#define IVM_ACTm_SPCP_MARKf_SET BCM53600_A0_IVM_ACTm_SPCP_MARKf_SET
#define READ_IVM_ACTm BCM53600_A0_READ_IVM_ACTm
#define WRITE_IVM_ACTm BCM53600_A0_WRITE_IVM_ACTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_ACTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  IVM_EVM_HIT_ENTRY
 * BLOCKS:   SYS
 * DESC:     IVM/EVM Hit Entry Register
 * SIZE:     32
 * FIELDS:
 *     IVM_HIT_ENTRY    IVM hit entry.Bit 15 = 1 indicate the IVM is hit in the last IVM TCAM comparation.Bit 14~0 = the hit entry[14:0].
 *     EVM_HIT_ENTRY    EVM hit entry.Bit 31 = 1 indicate the EVM is hit in the last EVM TCAM comparation.Bit 30~16 = the hit entry[14:0].
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr 0x00002180

#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_SIZE 4

/*
 * This structure should be used to declare and program IVM_EVM_HIT_ENTRY.
 *
 */
typedef union BCM53600_A0_IVM_EVM_HIT_ENTRYr_s {
	uint32_t v[1];
	uint32_t ivm_evm_hit_entry[1];
	uint32_t _ivm_evm_hit_entry;
} BCM53600_A0_IVM_EVM_HIT_ENTRYr_t;

#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_CLR(r) (r).ivm_evm_hit_entry[0] = 0
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_SET(r,d) (r).ivm_evm_hit_entry[0] = d
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_GET(r) (r).ivm_evm_hit_entry[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_IVM_HIT_ENTRYf_GET(r) (((r).ivm_evm_hit_entry[0]) & 0xffff)
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_IVM_HIT_ENTRYf_SET(r,f) (r).ivm_evm_hit_entry[0]=(((r).ivm_evm_hit_entry[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_EVM_HIT_ENTRYf_GET(r) ((((r).ivm_evm_hit_entry[0]) >> 16) & 0xffff)
#define BCM53600_A0_IVM_EVM_HIT_ENTRYr_EVM_HIT_ENTRYf_SET(r,f) (r).ivm_evm_hit_entry[0]=(((r).ivm_evm_hit_entry[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access IVM_EVM_HIT_ENTRY.
 *
 */
#define BCM53600_A0_READ_IVM_EVM_HIT_ENTRYr(u,r) cdk_robo_reg_read(u,BCM53600_A0_IVM_EVM_HIT_ENTRYr,(r._ivm_evm_hit_entry),4)
#define BCM53600_A0_WRITE_IVM_EVM_HIT_ENTRYr(u,r) cdk_robo_reg_write(u,BCM53600_A0_IVM_EVM_HIT_ENTRYr,&(r._ivm_evm_hit_entry),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_EVM_HIT_ENTRYr BCM53600_A0_IVM_EVM_HIT_ENTRYr
#define IVM_EVM_HIT_ENTRYr_SIZE BCM53600_A0_IVM_EVM_HIT_ENTRYr_SIZE
typedef BCM53600_A0_IVM_EVM_HIT_ENTRYr_t IVM_EVM_HIT_ENTRYr_t;
#define IVM_EVM_HIT_ENTRYr_CLR BCM53600_A0_IVM_EVM_HIT_ENTRYr_CLR
#define IVM_EVM_HIT_ENTRYr_SET BCM53600_A0_IVM_EVM_HIT_ENTRYr_SET
#define IVM_EVM_HIT_ENTRYr_GET BCM53600_A0_IVM_EVM_HIT_ENTRYr_GET
#define IVM_EVM_HIT_ENTRYr_IVM_HIT_ENTRYf_GET BCM53600_A0_IVM_EVM_HIT_ENTRYr_IVM_HIT_ENTRYf_GET
#define IVM_EVM_HIT_ENTRYr_IVM_HIT_ENTRYf_SET BCM53600_A0_IVM_EVM_HIT_ENTRYr_IVM_HIT_ENTRYf_SET
#define IVM_EVM_HIT_ENTRYr_EVM_HIT_ENTRYf_GET BCM53600_A0_IVM_EVM_HIT_ENTRYr_EVM_HIT_ENTRYf_GET
#define IVM_EVM_HIT_ENTRYr_EVM_HIT_ENTRYf_SET BCM53600_A0_IVM_EVM_HIT_ENTRYr_EVM_HIT_ENTRYf_SET
#define READ_IVM_EVM_HIT_ENTRYr BCM53600_A0_READ_IVM_EVM_HIT_ENTRYr
#define WRITE_IVM_EVM_HIT_ENTRYr BCM53600_A0_WRITE_IVM_EVM_HIT_ENTRYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_EVM_HIT_ENTRYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_DATA_0
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     INGRESS_CVID     Ingress CVID
 *     INGRESS_CVID_RANGE Ingress CVID Range
 *     INGRESS_SVID     Ingress SVID
 *     INGRESS_CTAG_STS Ingress CTAG status
 *     INGRESS_STAG_STS Ingress STAG status
 *     INGRESS_PORT_ID  Ingress port id
 *     INGRESS_PORT_PROFILE Ingress port profile
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_DATA_0m 0x00000000

#define BCM53600_A0_IVM_KEY_DATA_0m_MIN 0
#define BCM53600_A0_IVM_KEY_DATA_0m_MAX 2047
#define BCM53600_A0_IVM_KEY_DATA_0m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_DATA_0m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_DATA_0.
 *
 */
typedef union BCM53600_A0_IVM_KEY_DATA_0m_s {
	uint32_t v[2];
	uint32_t ivm_key_data_0[2];
	uint32_t _ivm_key_data_0;
} BCM53600_A0_IVM_KEY_DATA_0m_t;

#define BCM53600_A0_IVM_KEY_DATA_0m_CLR(r) CDK_MEMSET(&((r)._ivm_key_data_0), 0, sizeof(BCM53600_A0_IVM_KEY_DATA_0m_t))
#define BCM53600_A0_IVM_KEY_DATA_0m_SET(r,i,d) (r).ivm_key_data_0[i] = d
#define BCM53600_A0_IVM_KEY_DATA_0m_GET(r,i) (r).ivm_key_data_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVIDf_GET(r) (((r).ivm_key_data_0[0]) & 0xfff)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVIDf_SET(r,f) (r).ivm_key_data_0[0]=(((r).ivm_key_data_0[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVID_RANGEf_GET(r) ((((r).ivm_key_data_0[0]) >> 12) & 0xf)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVID_RANGEf_SET(r,f) (r).ivm_key_data_0[0]=(((r).ivm_key_data_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_SVIDf_GET(r) ((((r).ivm_key_data_0[0]) >> 16) & 0xfff)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_SVIDf_SET(r,f) (r).ivm_key_data_0[0]=(((r).ivm_key_data_0[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_data_0[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_data_0[0]=(((r).ivm_key_data_0[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_data_0[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_data_0[0]=(((r).ivm_key_data_0[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_data_0[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_data_0[1]=(((r).ivm_key_data_0[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_data_0[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_data_0[1]=(((r).ivm_key_data_0[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_1Rf_GET(r) ((((r).ivm_key_data_0[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_1Rf_SET(r,f) (r).ivm_key_data_0[1]=(((r).ivm_key_data_0[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_DATA_0m_VALIDf_GET(r) ((((r).ivm_key_data_0[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_DATA_0m_VALIDf_SET(r,f) (r).ivm_key_data_0[1]=(((r).ivm_key_data_0[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_Rf_GET(r) ((((r).ivm_key_data_0[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_Rf_SET(r,f) (r).ivm_key_data_0[1]=(((r).ivm_key_data_0[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_DATA_0.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_DATA_0m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_DATA_0m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_DATA_0m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_DATA_0m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_DATA_0m BCM53600_A0_IVM_KEY_DATA_0m
#define IVM_KEY_DATA_0m_MIN BCM53600_A0_IVM_KEY_DATA_0m_MIN
#define IVM_KEY_DATA_0m_MAX BCM53600_A0_IVM_KEY_DATA_0m_MAX
#define IVM_KEY_DATA_0m_CMAX(u) BCM53600_A0_IVM_KEY_DATA_0m_CMAX(u)
#define IVM_KEY_DATA_0m_SIZE BCM53600_A0_IVM_KEY_DATA_0m_SIZE
typedef BCM53600_A0_IVM_KEY_DATA_0m_t IVM_KEY_DATA_0m_t;
#define IVM_KEY_DATA_0m_CLR BCM53600_A0_IVM_KEY_DATA_0m_CLR
#define IVM_KEY_DATA_0m_SET BCM53600_A0_IVM_KEY_DATA_0m_SET
#define IVM_KEY_DATA_0m_GET BCM53600_A0_IVM_KEY_DATA_0m_GET
#define IVM_KEY_DATA_0m_INGRESS_CVIDf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVIDf_GET
#define IVM_KEY_DATA_0m_INGRESS_CVIDf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVIDf_SET
#define IVM_KEY_DATA_0m_INGRESS_CVID_RANGEf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVID_RANGEf_GET
#define IVM_KEY_DATA_0m_INGRESS_CVID_RANGEf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CVID_RANGEf_SET
#define IVM_KEY_DATA_0m_INGRESS_SVIDf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_SVIDf_GET
#define IVM_KEY_DATA_0m_INGRESS_SVIDf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_SVIDf_SET
#define IVM_KEY_DATA_0m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_DATA_0m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_DATA_0m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_STAG_STSf_GET
#define IVM_KEY_DATA_0m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_STAG_STSf_SET
#define IVM_KEY_DATA_0m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_IDf_GET
#define IVM_KEY_DATA_0m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_IDf_SET
#define IVM_KEY_DATA_0m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_DATA_0m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_DATA_0m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_DATA_0m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_1Rf_GET
#define IVM_KEY_DATA_0m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_1Rf_SET
#define IVM_KEY_DATA_0m_VALIDf_GET BCM53600_A0_IVM_KEY_DATA_0m_VALIDf_GET
#define IVM_KEY_DATA_0m_VALIDf_SET BCM53600_A0_IVM_KEY_DATA_0m_VALIDf_SET
#define IVM_KEY_DATA_0m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_Rf_GET
#define IVM_KEY_DATA_0m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_DATA_0m_RESERVED_Rf_SET
#define READ_IVM_KEY_DATA_0m BCM53600_A0_READ_IVM_KEY_DATA_0m
#define WRITE_IVM_KEY_DATA_0m BCM53600_A0_WRITE_IVM_KEY_DATA_0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_DATA_0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_DATA_1
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     ETH_TYPE         EtherType
 *     FRAMING_TYPE     Frame Type
 *     INGRESS_CPCP     Ingress CPCP
 *     INGRESS_SPCP     Ingress SPCP
 *     RESERVED_2R      reserved. should be all zero
 *     INGRESS_CTAG_STS Ingress CTAG status
 *     INGRESS_STAG_STS Ingress STAG status
 *     INGRESS_PORT_ID  Ingress port id
 *     INGRESS_PORT_PROFILE Ingress port profile
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_DATA_1m 0x00000000

#define BCM53600_A0_IVM_KEY_DATA_1m_MIN 0
#define BCM53600_A0_IVM_KEY_DATA_1m_MAX 2047
#define BCM53600_A0_IVM_KEY_DATA_1m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_DATA_1m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_DATA_1.
 *
 */
typedef union BCM53600_A0_IVM_KEY_DATA_1m_s {
	uint32_t v[2];
	uint32_t ivm_key_data_1[2];
	uint32_t _ivm_key_data_1;
} BCM53600_A0_IVM_KEY_DATA_1m_t;

#define BCM53600_A0_IVM_KEY_DATA_1m_CLR(r) CDK_MEMSET(&((r)._ivm_key_data_1), 0, sizeof(BCM53600_A0_IVM_KEY_DATA_1m_t))
#define BCM53600_A0_IVM_KEY_DATA_1m_SET(r,i,d) (r).ivm_key_data_1[i] = d
#define BCM53600_A0_IVM_KEY_DATA_1m_GET(r,i) (r).ivm_key_data_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_DATA_1m_ETH_TYPEf_GET(r) (((r).ivm_key_data_1[0]) & 0xffff)
#define BCM53600_A0_IVM_KEY_DATA_1m_ETH_TYPEf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_IVM_KEY_DATA_1m_FRAMING_TYPEf_GET(r) ((((r).ivm_key_data_1[0]) >> 16) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_1m_FRAMING_TYPEf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CPCPf_GET(r) ((((r).ivm_key_data_1[0]) >> 18) & 0x7)
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CPCPf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_SPCPf_GET(r) ((((r).ivm_key_data_1[0]) >> 21) & 0x7)
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_SPCPf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_2Rf_GET(r) ((((r).ivm_key_data_1[0]) >> 24) & 0xf)
#define BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_2Rf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_data_1[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_data_1[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_data_1[0]=(((r).ivm_key_data_1[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_data_1[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_data_1[1]=(((r).ivm_key_data_1[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_data_1[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_data_1[1]=(((r).ivm_key_data_1[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_1Rf_GET(r) ((((r).ivm_key_data_1[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_1Rf_SET(r,f) (r).ivm_key_data_1[1]=(((r).ivm_key_data_1[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_DATA_1m_VALIDf_GET(r) ((((r).ivm_key_data_1[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_DATA_1m_VALIDf_SET(r,f) (r).ivm_key_data_1[1]=(((r).ivm_key_data_1[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_Rf_GET(r) ((((r).ivm_key_data_1[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_Rf_SET(r,f) (r).ivm_key_data_1[1]=(((r).ivm_key_data_1[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_DATA_1.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_DATA_1m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_DATA_1m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_DATA_1m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_DATA_1m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_DATA_1m BCM53600_A0_IVM_KEY_DATA_1m
#define IVM_KEY_DATA_1m_MIN BCM53600_A0_IVM_KEY_DATA_1m_MIN
#define IVM_KEY_DATA_1m_MAX BCM53600_A0_IVM_KEY_DATA_1m_MAX
#define IVM_KEY_DATA_1m_CMAX(u) BCM53600_A0_IVM_KEY_DATA_1m_CMAX(u)
#define IVM_KEY_DATA_1m_SIZE BCM53600_A0_IVM_KEY_DATA_1m_SIZE
typedef BCM53600_A0_IVM_KEY_DATA_1m_t IVM_KEY_DATA_1m_t;
#define IVM_KEY_DATA_1m_CLR BCM53600_A0_IVM_KEY_DATA_1m_CLR
#define IVM_KEY_DATA_1m_SET BCM53600_A0_IVM_KEY_DATA_1m_SET
#define IVM_KEY_DATA_1m_GET BCM53600_A0_IVM_KEY_DATA_1m_GET
#define IVM_KEY_DATA_1m_ETH_TYPEf_GET BCM53600_A0_IVM_KEY_DATA_1m_ETH_TYPEf_GET
#define IVM_KEY_DATA_1m_ETH_TYPEf_SET BCM53600_A0_IVM_KEY_DATA_1m_ETH_TYPEf_SET
#define IVM_KEY_DATA_1m_FRAMING_TYPEf_GET BCM53600_A0_IVM_KEY_DATA_1m_FRAMING_TYPEf_GET
#define IVM_KEY_DATA_1m_FRAMING_TYPEf_SET BCM53600_A0_IVM_KEY_DATA_1m_FRAMING_TYPEf_SET
#define IVM_KEY_DATA_1m_INGRESS_CPCPf_GET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CPCPf_GET
#define IVM_KEY_DATA_1m_INGRESS_CPCPf_SET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CPCPf_SET
#define IVM_KEY_DATA_1m_INGRESS_SPCPf_GET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_SPCPf_GET
#define IVM_KEY_DATA_1m_INGRESS_SPCPf_SET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_SPCPf_SET
#define IVM_KEY_DATA_1m_RESERVED_2Rf_GET BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_2Rf_GET
#define IVM_KEY_DATA_1m_RESERVED_2Rf_SET BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_2Rf_SET
#define IVM_KEY_DATA_1m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_DATA_1m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_DATA_1m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_STAG_STSf_GET
#define IVM_KEY_DATA_1m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_STAG_STSf_SET
#define IVM_KEY_DATA_1m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_IDf_GET
#define IVM_KEY_DATA_1m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_IDf_SET
#define IVM_KEY_DATA_1m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_DATA_1m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_DATA_1m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_DATA_1m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_1Rf_GET
#define IVM_KEY_DATA_1m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_1Rf_SET
#define IVM_KEY_DATA_1m_VALIDf_GET BCM53600_A0_IVM_KEY_DATA_1m_VALIDf_GET
#define IVM_KEY_DATA_1m_VALIDf_SET BCM53600_A0_IVM_KEY_DATA_1m_VALIDf_SET
#define IVM_KEY_DATA_1m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_Rf_GET
#define IVM_KEY_DATA_1m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_DATA_1m_RESERVED_Rf_SET
#define READ_IVM_KEY_DATA_1m BCM53600_A0_READ_IVM_KEY_DATA_1m
#define WRITE_IVM_KEY_DATA_1m BCM53600_A0_WRITE_IVM_KEY_DATA_1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_DATA_1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_DATA_2
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     INGRESS_CVID     Ingress CVID
 *     INGRESS_CVID_RANGE Ingress CVID Range
 *     FRAMING_TYPE     Frame Type
 *     INGRESS_CPCP     Ingress CPCP
 *     INGRESS_SPCP     Ingress SPCP
 *     RESERVED_2R      reserved. should be all zero
 *     INGRESS_CTAG_STS Ingress CTAG status
 *     INGRESS_STAG_STS Ingress STAG status
 *     INGRESS_PORT_ID  Ingress port id
 *     INGRESS_PORT_PROFILE Ingress port profile
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_DATA_2m 0x00000000

#define BCM53600_A0_IVM_KEY_DATA_2m_MIN 0
#define BCM53600_A0_IVM_KEY_DATA_2m_MAX 2047
#define BCM53600_A0_IVM_KEY_DATA_2m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_DATA_2m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_DATA_2.
 *
 */
typedef union BCM53600_A0_IVM_KEY_DATA_2m_s {
	uint32_t v[2];
	uint32_t ivm_key_data_2[2];
	uint32_t _ivm_key_data_2;
} BCM53600_A0_IVM_KEY_DATA_2m_t;

#define BCM53600_A0_IVM_KEY_DATA_2m_CLR(r) CDK_MEMSET(&((r)._ivm_key_data_2), 0, sizeof(BCM53600_A0_IVM_KEY_DATA_2m_t))
#define BCM53600_A0_IVM_KEY_DATA_2m_SET(r,i,d) (r).ivm_key_data_2[i] = d
#define BCM53600_A0_IVM_KEY_DATA_2m_GET(r,i) (r).ivm_key_data_2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVIDf_GET(r) (((r).ivm_key_data_2[0]) & 0xfff)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVIDf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVID_RANGEf_GET(r) ((((r).ivm_key_data_2[0]) >> 12) & 0xf)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVID_RANGEf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_IVM_KEY_DATA_2m_FRAMING_TYPEf_GET(r) ((((r).ivm_key_data_2[0]) >> 16) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_2m_FRAMING_TYPEf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CPCPf_GET(r) ((((r).ivm_key_data_2[0]) >> 18) & 0x7)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CPCPf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_SPCPf_GET(r) ((((r).ivm_key_data_2[0]) >> 21) & 0x7)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_SPCPf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_2Rf_GET(r) ((((r).ivm_key_data_2[0]) >> 24) & 0xf)
#define BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_2Rf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_data_2[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_data_2[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_data_2[0]=(((r).ivm_key_data_2[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_data_2[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_data_2[1]=(((r).ivm_key_data_2[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_data_2[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_data_2[1]=(((r).ivm_key_data_2[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_1Rf_GET(r) ((((r).ivm_key_data_2[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_1Rf_SET(r,f) (r).ivm_key_data_2[1]=(((r).ivm_key_data_2[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_DATA_2m_VALIDf_GET(r) ((((r).ivm_key_data_2[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_DATA_2m_VALIDf_SET(r,f) (r).ivm_key_data_2[1]=(((r).ivm_key_data_2[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_Rf_GET(r) ((((r).ivm_key_data_2[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_Rf_SET(r,f) (r).ivm_key_data_2[1]=(((r).ivm_key_data_2[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_DATA_2.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_DATA_2m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_DATA_2m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_DATA_2m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_DATA_2m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_DATA_2m BCM53600_A0_IVM_KEY_DATA_2m
#define IVM_KEY_DATA_2m_MIN BCM53600_A0_IVM_KEY_DATA_2m_MIN
#define IVM_KEY_DATA_2m_MAX BCM53600_A0_IVM_KEY_DATA_2m_MAX
#define IVM_KEY_DATA_2m_CMAX(u) BCM53600_A0_IVM_KEY_DATA_2m_CMAX(u)
#define IVM_KEY_DATA_2m_SIZE BCM53600_A0_IVM_KEY_DATA_2m_SIZE
typedef BCM53600_A0_IVM_KEY_DATA_2m_t IVM_KEY_DATA_2m_t;
#define IVM_KEY_DATA_2m_CLR BCM53600_A0_IVM_KEY_DATA_2m_CLR
#define IVM_KEY_DATA_2m_SET BCM53600_A0_IVM_KEY_DATA_2m_SET
#define IVM_KEY_DATA_2m_GET BCM53600_A0_IVM_KEY_DATA_2m_GET
#define IVM_KEY_DATA_2m_INGRESS_CVIDf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVIDf_GET
#define IVM_KEY_DATA_2m_INGRESS_CVIDf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVIDf_SET
#define IVM_KEY_DATA_2m_INGRESS_CVID_RANGEf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVID_RANGEf_GET
#define IVM_KEY_DATA_2m_INGRESS_CVID_RANGEf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CVID_RANGEf_SET
#define IVM_KEY_DATA_2m_FRAMING_TYPEf_GET BCM53600_A0_IVM_KEY_DATA_2m_FRAMING_TYPEf_GET
#define IVM_KEY_DATA_2m_FRAMING_TYPEf_SET BCM53600_A0_IVM_KEY_DATA_2m_FRAMING_TYPEf_SET
#define IVM_KEY_DATA_2m_INGRESS_CPCPf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CPCPf_GET
#define IVM_KEY_DATA_2m_INGRESS_CPCPf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CPCPf_SET
#define IVM_KEY_DATA_2m_INGRESS_SPCPf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_SPCPf_GET
#define IVM_KEY_DATA_2m_INGRESS_SPCPf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_SPCPf_SET
#define IVM_KEY_DATA_2m_RESERVED_2Rf_GET BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_2Rf_GET
#define IVM_KEY_DATA_2m_RESERVED_2Rf_SET BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_2Rf_SET
#define IVM_KEY_DATA_2m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_DATA_2m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_DATA_2m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_STAG_STSf_GET
#define IVM_KEY_DATA_2m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_STAG_STSf_SET
#define IVM_KEY_DATA_2m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_IDf_GET
#define IVM_KEY_DATA_2m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_IDf_SET
#define IVM_KEY_DATA_2m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_DATA_2m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_DATA_2m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_DATA_2m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_1Rf_GET
#define IVM_KEY_DATA_2m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_1Rf_SET
#define IVM_KEY_DATA_2m_VALIDf_GET BCM53600_A0_IVM_KEY_DATA_2m_VALIDf_GET
#define IVM_KEY_DATA_2m_VALIDf_SET BCM53600_A0_IVM_KEY_DATA_2m_VALIDf_SET
#define IVM_KEY_DATA_2m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_Rf_GET
#define IVM_KEY_DATA_2m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_DATA_2m_RESERVED_Rf_SET
#define READ_IVM_KEY_DATA_2m BCM53600_A0_READ_IVM_KEY_DATA_2m
#define WRITE_IVM_KEY_DATA_2m BCM53600_A0_WRITE_IVM_KEY_DATA_2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_DATA_2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_DATA_3
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     ETH_TYPE         EtherType
 *     INGRESS_SVID     Ingress SVID
 *     INGRESS_CTAG_STS Ingress CTAG status
 *     INGRESS_STAG_STS Ingress STAG status
 *     INGRESS_PORT_ID  Ingress port id
 *     INGRESS_PORT_PROFILE Ingress port profile
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_DATA_3m 0x00000000

#define BCM53600_A0_IVM_KEY_DATA_3m_MIN 0
#define BCM53600_A0_IVM_KEY_DATA_3m_MAX 2047
#define BCM53600_A0_IVM_KEY_DATA_3m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_DATA_3m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_DATA_3.
 *
 */
typedef union BCM53600_A0_IVM_KEY_DATA_3m_s {
	uint32_t v[2];
	uint32_t ivm_key_data_3[2];
	uint32_t _ivm_key_data_3;
} BCM53600_A0_IVM_KEY_DATA_3m_t;

#define BCM53600_A0_IVM_KEY_DATA_3m_CLR(r) CDK_MEMSET(&((r)._ivm_key_data_3), 0, sizeof(BCM53600_A0_IVM_KEY_DATA_3m_t))
#define BCM53600_A0_IVM_KEY_DATA_3m_SET(r,i,d) (r).ivm_key_data_3[i] = d
#define BCM53600_A0_IVM_KEY_DATA_3m_GET(r,i) (r).ivm_key_data_3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_DATA_3m_ETH_TYPEf_GET(r) (((r).ivm_key_data_3[0]) & 0xffff)
#define BCM53600_A0_IVM_KEY_DATA_3m_ETH_TYPEf_SET(r,f) (r).ivm_key_data_3[0]=(((r).ivm_key_data_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_SVIDf_GET(r) ((((r).ivm_key_data_3[0]) >> 16) & 0xfff)
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_SVIDf_SET(r,f) (r).ivm_key_data_3[0]=(((r).ivm_key_data_3[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_data_3[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_data_3[0]=(((r).ivm_key_data_3[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_data_3[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_data_3[0]=(((r).ivm_key_data_3[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_data_3[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_data_3[1]=(((r).ivm_key_data_3[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_data_3[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_data_3[1]=(((r).ivm_key_data_3[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_1Rf_GET(r) ((((r).ivm_key_data_3[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_1Rf_SET(r,f) (r).ivm_key_data_3[1]=(((r).ivm_key_data_3[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_DATA_3m_VALIDf_GET(r) ((((r).ivm_key_data_3[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_DATA_3m_VALIDf_SET(r,f) (r).ivm_key_data_3[1]=(((r).ivm_key_data_3[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_Rf_GET(r) ((((r).ivm_key_data_3[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_Rf_SET(r,f) (r).ivm_key_data_3[1]=(((r).ivm_key_data_3[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_DATA_3.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_DATA_3m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_DATA_3m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_DATA_3m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_DATA_3m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_DATA_3m BCM53600_A0_IVM_KEY_DATA_3m
#define IVM_KEY_DATA_3m_MIN BCM53600_A0_IVM_KEY_DATA_3m_MIN
#define IVM_KEY_DATA_3m_MAX BCM53600_A0_IVM_KEY_DATA_3m_MAX
#define IVM_KEY_DATA_3m_CMAX(u) BCM53600_A0_IVM_KEY_DATA_3m_CMAX(u)
#define IVM_KEY_DATA_3m_SIZE BCM53600_A0_IVM_KEY_DATA_3m_SIZE
typedef BCM53600_A0_IVM_KEY_DATA_3m_t IVM_KEY_DATA_3m_t;
#define IVM_KEY_DATA_3m_CLR BCM53600_A0_IVM_KEY_DATA_3m_CLR
#define IVM_KEY_DATA_3m_SET BCM53600_A0_IVM_KEY_DATA_3m_SET
#define IVM_KEY_DATA_3m_GET BCM53600_A0_IVM_KEY_DATA_3m_GET
#define IVM_KEY_DATA_3m_ETH_TYPEf_GET BCM53600_A0_IVM_KEY_DATA_3m_ETH_TYPEf_GET
#define IVM_KEY_DATA_3m_ETH_TYPEf_SET BCM53600_A0_IVM_KEY_DATA_3m_ETH_TYPEf_SET
#define IVM_KEY_DATA_3m_INGRESS_SVIDf_GET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_SVIDf_GET
#define IVM_KEY_DATA_3m_INGRESS_SVIDf_SET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_SVIDf_SET
#define IVM_KEY_DATA_3m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_DATA_3m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_DATA_3m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_STAG_STSf_GET
#define IVM_KEY_DATA_3m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_STAG_STSf_SET
#define IVM_KEY_DATA_3m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_IDf_GET
#define IVM_KEY_DATA_3m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_IDf_SET
#define IVM_KEY_DATA_3m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_DATA_3m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_DATA_3m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_DATA_3m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_1Rf_GET
#define IVM_KEY_DATA_3m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_1Rf_SET
#define IVM_KEY_DATA_3m_VALIDf_GET BCM53600_A0_IVM_KEY_DATA_3m_VALIDf_GET
#define IVM_KEY_DATA_3m_VALIDf_SET BCM53600_A0_IVM_KEY_DATA_3m_VALIDf_SET
#define IVM_KEY_DATA_3m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_Rf_GET
#define IVM_KEY_DATA_3m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_DATA_3m_RESERVED_Rf_SET
#define READ_IVM_KEY_DATA_3m BCM53600_A0_READ_IVM_KEY_DATA_3m
#define WRITE_IVM_KEY_DATA_3m BCM53600_A0_WRITE_IVM_KEY_DATA_3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_DATA_3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_DATA_MASK
 * BLOCKS:   SYS
 * DESC:     IVM_KEY_DATA_MASK Table
 * SIZE:     128
 * FIELDS:
 *     VM_KEY_DATA      VM_KEY_DATA
 *     RESERVED_1R      reserved
 *     VM_KEY_MASK      VM_KEY_MASK
 *     RESERVED_R       reserved
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_DATA_MASKm 0x00000000

#define BCM53600_A0_IVM_KEY_DATA_MASKm_MIN 0
#define BCM53600_A0_IVM_KEY_DATA_MASKm_MAX 2047
#define BCM53600_A0_IVM_KEY_DATA_MASKm_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_DATA_MASKm_SIZE 16

/*
 * This structure should be used to declare and program IVM_KEY_DATA_MASK.
 *
 */
typedef union BCM53600_A0_IVM_KEY_DATA_MASKm_s {
	uint32_t v[4];
	uint32_t ivm_key_data_mask[4];
	uint32_t _ivm_key_data_mask;
} BCM53600_A0_IVM_KEY_DATA_MASKm_t;

#define BCM53600_A0_IVM_KEY_DATA_MASKm_CLR(r) CDK_MEMSET(&((r)._ivm_key_data_mask), 0, sizeof(BCM53600_A0_IVM_KEY_DATA_MASKm_t))
#define BCM53600_A0_IVM_KEY_DATA_MASKm_SET(r,i,d) (r).ivm_key_data_mask[i] = d
#define BCM53600_A0_IVM_KEY_DATA_MASKm_GET(r,i) (r).ivm_key_data_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_DATAf_GET(r,a) cdk_field_get((r).ivm_key_data_mask,0,49,a)
#define BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_DATAf_SET(r,a) cdk_field_set((r).ivm_key_data_mask,0,49,a)
#define BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_1Rf_GET(r) ((((r).ivm_key_data_mask[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_1Rf_SET(r,f) (r).ivm_key_data_mask[1]=(((r).ivm_key_data_mask[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))
#define BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_MASKf_GET(r,a) cdk_field_get((r).ivm_key_data_mask,64,113,a)
#define BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_MASKf_SET(r,a) cdk_field_set((r).ivm_key_data_mask,64,113,a)
#define BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_Rf_GET(r) ((((r).ivm_key_data_mask[3]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_Rf_SET(r,f) (r).ivm_key_data_mask[3]=(((r).ivm_key_data_mask[3] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_DATA_MASK.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_DATA_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_DATA_MASKm,i,(m),16)
#define BCM53600_A0_WRITE_IVM_KEY_DATA_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_DATA_MASKm,i,&(m),16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_DATA_MASKm BCM53600_A0_IVM_KEY_DATA_MASKm
#define IVM_KEY_DATA_MASKm_MIN BCM53600_A0_IVM_KEY_DATA_MASKm_MIN
#define IVM_KEY_DATA_MASKm_MAX BCM53600_A0_IVM_KEY_DATA_MASKm_MAX
#define IVM_KEY_DATA_MASKm_CMAX(u) BCM53600_A0_IVM_KEY_DATA_MASKm_CMAX(u)
#define IVM_KEY_DATA_MASKm_SIZE BCM53600_A0_IVM_KEY_DATA_MASKm_SIZE
typedef BCM53600_A0_IVM_KEY_DATA_MASKm_t IVM_KEY_DATA_MASKm_t;
#define IVM_KEY_DATA_MASKm_CLR BCM53600_A0_IVM_KEY_DATA_MASKm_CLR
#define IVM_KEY_DATA_MASKm_SET BCM53600_A0_IVM_KEY_DATA_MASKm_SET
#define IVM_KEY_DATA_MASKm_GET BCM53600_A0_IVM_KEY_DATA_MASKm_GET
#define IVM_KEY_DATA_MASKm_VM_KEY_DATAf_GET BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_DATAf_GET
#define IVM_KEY_DATA_MASKm_VM_KEY_DATAf_SET BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_DATAf_SET
#define IVM_KEY_DATA_MASKm_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_1Rf_GET
#define IVM_KEY_DATA_MASKm_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_1Rf_SET
#define IVM_KEY_DATA_MASKm_VM_KEY_MASKf_GET BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_MASKf_GET
#define IVM_KEY_DATA_MASKm_VM_KEY_MASKf_SET BCM53600_A0_IVM_KEY_DATA_MASKm_VM_KEY_MASKf_SET
#define IVM_KEY_DATA_MASKm_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_Rf_GET
#define IVM_KEY_DATA_MASKm_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_DATA_MASKm_RESERVED_Rf_SET
#define READ_IVM_KEY_DATA_MASKm BCM53600_A0_READ_IVM_KEY_DATA_MASKm
#define WRITE_IVM_KEY_DATA_MASKm BCM53600_A0_WRITE_IVM_KEY_DATA_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_DATA_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_MASK_0
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     INGRESS_CVID     Field Mask
 *     INGRESS_CVID_RANGE Field Mask
 *     INGRESS_SVID     Field Mask
 *     INGRESS_CTAG_STS Field Mask
 *     INGRESS_STAG_STS Field Mask
 *     INGRESS_PORT_ID  Field Mask
 *     INGRESS_PORT_PROFILE Field Mask
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_MASK_0m 0x00000000

#define BCM53600_A0_IVM_KEY_MASK_0m_MIN 0
#define BCM53600_A0_IVM_KEY_MASK_0m_MAX 2047
#define BCM53600_A0_IVM_KEY_MASK_0m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_MASK_0m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_MASK_0.
 *
 */
typedef union BCM53600_A0_IVM_KEY_MASK_0m_s {
	uint32_t v[2];
	uint32_t ivm_key_mask_0[2];
	uint32_t _ivm_key_mask_0;
} BCM53600_A0_IVM_KEY_MASK_0m_t;

#define BCM53600_A0_IVM_KEY_MASK_0m_CLR(r) CDK_MEMSET(&((r)._ivm_key_mask_0), 0, sizeof(BCM53600_A0_IVM_KEY_MASK_0m_t))
#define BCM53600_A0_IVM_KEY_MASK_0m_SET(r,i,d) (r).ivm_key_mask_0[i] = d
#define BCM53600_A0_IVM_KEY_MASK_0m_GET(r,i) (r).ivm_key_mask_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVIDf_GET(r) (((r).ivm_key_mask_0[0]) & 0xfff)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVIDf_SET(r,f) (r).ivm_key_mask_0[0]=(((r).ivm_key_mask_0[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVID_RANGEf_GET(r) ((((r).ivm_key_mask_0[0]) >> 12) & 0xf)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVID_RANGEf_SET(r,f) (r).ivm_key_mask_0[0]=(((r).ivm_key_mask_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_SVIDf_GET(r) ((((r).ivm_key_mask_0[0]) >> 16) & 0xfff)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_SVIDf_SET(r,f) (r).ivm_key_mask_0[0]=(((r).ivm_key_mask_0[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_mask_0[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_mask_0[0]=(((r).ivm_key_mask_0[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_mask_0[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_mask_0[0]=(((r).ivm_key_mask_0[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_mask_0[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_mask_0[1]=(((r).ivm_key_mask_0[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_mask_0[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_mask_0[1]=(((r).ivm_key_mask_0[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_1Rf_GET(r) ((((r).ivm_key_mask_0[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_1Rf_SET(r,f) (r).ivm_key_mask_0[1]=(((r).ivm_key_mask_0[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_MASK_0m_VALIDf_GET(r) ((((r).ivm_key_mask_0[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_MASK_0m_VALIDf_SET(r,f) (r).ivm_key_mask_0[1]=(((r).ivm_key_mask_0[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_Rf_GET(r) ((((r).ivm_key_mask_0[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_Rf_SET(r,f) (r).ivm_key_mask_0[1]=(((r).ivm_key_mask_0[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_MASK_0.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_MASK_0m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_MASK_0m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_MASK_0m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_MASK_0m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_MASK_0m BCM53600_A0_IVM_KEY_MASK_0m
#define IVM_KEY_MASK_0m_MIN BCM53600_A0_IVM_KEY_MASK_0m_MIN
#define IVM_KEY_MASK_0m_MAX BCM53600_A0_IVM_KEY_MASK_0m_MAX
#define IVM_KEY_MASK_0m_CMAX(u) BCM53600_A0_IVM_KEY_MASK_0m_CMAX(u)
#define IVM_KEY_MASK_0m_SIZE BCM53600_A0_IVM_KEY_MASK_0m_SIZE
typedef BCM53600_A0_IVM_KEY_MASK_0m_t IVM_KEY_MASK_0m_t;
#define IVM_KEY_MASK_0m_CLR BCM53600_A0_IVM_KEY_MASK_0m_CLR
#define IVM_KEY_MASK_0m_SET BCM53600_A0_IVM_KEY_MASK_0m_SET
#define IVM_KEY_MASK_0m_GET BCM53600_A0_IVM_KEY_MASK_0m_GET
#define IVM_KEY_MASK_0m_INGRESS_CVIDf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVIDf_GET
#define IVM_KEY_MASK_0m_INGRESS_CVIDf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVIDf_SET
#define IVM_KEY_MASK_0m_INGRESS_CVID_RANGEf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVID_RANGEf_GET
#define IVM_KEY_MASK_0m_INGRESS_CVID_RANGEf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CVID_RANGEf_SET
#define IVM_KEY_MASK_0m_INGRESS_SVIDf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_SVIDf_GET
#define IVM_KEY_MASK_0m_INGRESS_SVIDf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_SVIDf_SET
#define IVM_KEY_MASK_0m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_MASK_0m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_MASK_0m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_STAG_STSf_GET
#define IVM_KEY_MASK_0m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_STAG_STSf_SET
#define IVM_KEY_MASK_0m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_IDf_GET
#define IVM_KEY_MASK_0m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_IDf_SET
#define IVM_KEY_MASK_0m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_MASK_0m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_MASK_0m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_MASK_0m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_1Rf_GET
#define IVM_KEY_MASK_0m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_1Rf_SET
#define IVM_KEY_MASK_0m_VALIDf_GET BCM53600_A0_IVM_KEY_MASK_0m_VALIDf_GET
#define IVM_KEY_MASK_0m_VALIDf_SET BCM53600_A0_IVM_KEY_MASK_0m_VALIDf_SET
#define IVM_KEY_MASK_0m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_Rf_GET
#define IVM_KEY_MASK_0m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_MASK_0m_RESERVED_Rf_SET
#define READ_IVM_KEY_MASK_0m BCM53600_A0_READ_IVM_KEY_MASK_0m
#define WRITE_IVM_KEY_MASK_0m BCM53600_A0_WRITE_IVM_KEY_MASK_0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_MASK_0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_MASK_1
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     ETH_TYPE         Field Mask
 *     FRAMING_TYPE     Field Mask
 *     INGRESS_CPCP     Field Mask
 *     INGRESS_SPCP     Field Mask
 *     RESERVED_2R      Field Mask
 *     INGRESS_CTAG_STS Field Mask
 *     INGRESS_STAG_STS Field Mask
 *     INGRESS_PORT_ID  Field Mask
 *     INGRESS_PORT_PROFILE Field Mask
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_MASK_1m 0x00000000

#define BCM53600_A0_IVM_KEY_MASK_1m_MIN 0
#define BCM53600_A0_IVM_KEY_MASK_1m_MAX 2047
#define BCM53600_A0_IVM_KEY_MASK_1m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_MASK_1m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_MASK_1.
 *
 */
typedef union BCM53600_A0_IVM_KEY_MASK_1m_s {
	uint32_t v[2];
	uint32_t ivm_key_mask_1[2];
	uint32_t _ivm_key_mask_1;
} BCM53600_A0_IVM_KEY_MASK_1m_t;

#define BCM53600_A0_IVM_KEY_MASK_1m_CLR(r) CDK_MEMSET(&((r)._ivm_key_mask_1), 0, sizeof(BCM53600_A0_IVM_KEY_MASK_1m_t))
#define BCM53600_A0_IVM_KEY_MASK_1m_SET(r,i,d) (r).ivm_key_mask_1[i] = d
#define BCM53600_A0_IVM_KEY_MASK_1m_GET(r,i) (r).ivm_key_mask_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_MASK_1m_ETH_TYPEf_GET(r) (((r).ivm_key_mask_1[0]) & 0xffff)
#define BCM53600_A0_IVM_KEY_MASK_1m_ETH_TYPEf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_IVM_KEY_MASK_1m_FRAMING_TYPEf_GET(r) ((((r).ivm_key_mask_1[0]) >> 16) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_1m_FRAMING_TYPEf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CPCPf_GET(r) ((((r).ivm_key_mask_1[0]) >> 18) & 0x7)
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CPCPf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_SPCPf_GET(r) ((((r).ivm_key_mask_1[0]) >> 21) & 0x7)
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_SPCPf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_2Rf_GET(r) ((((r).ivm_key_mask_1[0]) >> 24) & 0xf)
#define BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_2Rf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_mask_1[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_mask_1[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_mask_1[0]=(((r).ivm_key_mask_1[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_mask_1[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_mask_1[1]=(((r).ivm_key_mask_1[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_mask_1[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_mask_1[1]=(((r).ivm_key_mask_1[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_1Rf_GET(r) ((((r).ivm_key_mask_1[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_1Rf_SET(r,f) (r).ivm_key_mask_1[1]=(((r).ivm_key_mask_1[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_MASK_1m_VALIDf_GET(r) ((((r).ivm_key_mask_1[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_MASK_1m_VALIDf_SET(r,f) (r).ivm_key_mask_1[1]=(((r).ivm_key_mask_1[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_Rf_GET(r) ((((r).ivm_key_mask_1[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_Rf_SET(r,f) (r).ivm_key_mask_1[1]=(((r).ivm_key_mask_1[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_MASK_1.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_MASK_1m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_MASK_1m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_MASK_1m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_MASK_1m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_MASK_1m BCM53600_A0_IVM_KEY_MASK_1m
#define IVM_KEY_MASK_1m_MIN BCM53600_A0_IVM_KEY_MASK_1m_MIN
#define IVM_KEY_MASK_1m_MAX BCM53600_A0_IVM_KEY_MASK_1m_MAX
#define IVM_KEY_MASK_1m_CMAX(u) BCM53600_A0_IVM_KEY_MASK_1m_CMAX(u)
#define IVM_KEY_MASK_1m_SIZE BCM53600_A0_IVM_KEY_MASK_1m_SIZE
typedef BCM53600_A0_IVM_KEY_MASK_1m_t IVM_KEY_MASK_1m_t;
#define IVM_KEY_MASK_1m_CLR BCM53600_A0_IVM_KEY_MASK_1m_CLR
#define IVM_KEY_MASK_1m_SET BCM53600_A0_IVM_KEY_MASK_1m_SET
#define IVM_KEY_MASK_1m_GET BCM53600_A0_IVM_KEY_MASK_1m_GET
#define IVM_KEY_MASK_1m_ETH_TYPEf_GET BCM53600_A0_IVM_KEY_MASK_1m_ETH_TYPEf_GET
#define IVM_KEY_MASK_1m_ETH_TYPEf_SET BCM53600_A0_IVM_KEY_MASK_1m_ETH_TYPEf_SET
#define IVM_KEY_MASK_1m_FRAMING_TYPEf_GET BCM53600_A0_IVM_KEY_MASK_1m_FRAMING_TYPEf_GET
#define IVM_KEY_MASK_1m_FRAMING_TYPEf_SET BCM53600_A0_IVM_KEY_MASK_1m_FRAMING_TYPEf_SET
#define IVM_KEY_MASK_1m_INGRESS_CPCPf_GET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CPCPf_GET
#define IVM_KEY_MASK_1m_INGRESS_CPCPf_SET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CPCPf_SET
#define IVM_KEY_MASK_1m_INGRESS_SPCPf_GET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_SPCPf_GET
#define IVM_KEY_MASK_1m_INGRESS_SPCPf_SET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_SPCPf_SET
#define IVM_KEY_MASK_1m_RESERVED_2Rf_GET BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_2Rf_GET
#define IVM_KEY_MASK_1m_RESERVED_2Rf_SET BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_2Rf_SET
#define IVM_KEY_MASK_1m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_MASK_1m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_MASK_1m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_STAG_STSf_GET
#define IVM_KEY_MASK_1m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_STAG_STSf_SET
#define IVM_KEY_MASK_1m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_IDf_GET
#define IVM_KEY_MASK_1m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_IDf_SET
#define IVM_KEY_MASK_1m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_MASK_1m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_MASK_1m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_MASK_1m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_1Rf_GET
#define IVM_KEY_MASK_1m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_1Rf_SET
#define IVM_KEY_MASK_1m_VALIDf_GET BCM53600_A0_IVM_KEY_MASK_1m_VALIDf_GET
#define IVM_KEY_MASK_1m_VALIDf_SET BCM53600_A0_IVM_KEY_MASK_1m_VALIDf_SET
#define IVM_KEY_MASK_1m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_Rf_GET
#define IVM_KEY_MASK_1m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_MASK_1m_RESERVED_Rf_SET
#define READ_IVM_KEY_MASK_1m BCM53600_A0_READ_IVM_KEY_MASK_1m
#define WRITE_IVM_KEY_MASK_1m BCM53600_A0_WRITE_IVM_KEY_MASK_1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_MASK_1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_MASK_2
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     INGRESS_CVID     Field Mask
 *     INGRESS_CVID_RANGE Field Mask
 *     FRAMING_TYPE     Field Mask
 *     INGRESS_CPCP     Field Mask
 *     INGRESS_SPCP     Field Mask
 *     RESERVED_2R      Field Mask
 *     INGRESS_CTAG_STS Field Mask
 *     INGRESS_STAG_STS Field Mask
 *     INGRESS_PORT_ID  Field Mask
 *     INGRESS_PORT_PROFILE Field Mask
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_MASK_2m 0x00000000

#define BCM53600_A0_IVM_KEY_MASK_2m_MIN 0
#define BCM53600_A0_IVM_KEY_MASK_2m_MAX 2047
#define BCM53600_A0_IVM_KEY_MASK_2m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_MASK_2m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_MASK_2.
 *
 */
typedef union BCM53600_A0_IVM_KEY_MASK_2m_s {
	uint32_t v[2];
	uint32_t ivm_key_mask_2[2];
	uint32_t _ivm_key_mask_2;
} BCM53600_A0_IVM_KEY_MASK_2m_t;

#define BCM53600_A0_IVM_KEY_MASK_2m_CLR(r) CDK_MEMSET(&((r)._ivm_key_mask_2), 0, sizeof(BCM53600_A0_IVM_KEY_MASK_2m_t))
#define BCM53600_A0_IVM_KEY_MASK_2m_SET(r,i,d) (r).ivm_key_mask_2[i] = d
#define BCM53600_A0_IVM_KEY_MASK_2m_GET(r,i) (r).ivm_key_mask_2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVIDf_GET(r) (((r).ivm_key_mask_2[0]) & 0xfff)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVIDf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVID_RANGEf_GET(r) ((((r).ivm_key_mask_2[0]) >> 12) & 0xf)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVID_RANGEf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_IVM_KEY_MASK_2m_FRAMING_TYPEf_GET(r) ((((r).ivm_key_mask_2[0]) >> 16) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_2m_FRAMING_TYPEf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CPCPf_GET(r) ((((r).ivm_key_mask_2[0]) >> 18) & 0x7)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CPCPf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_SPCPf_GET(r) ((((r).ivm_key_mask_2[0]) >> 21) & 0x7)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_SPCPf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_2Rf_GET(r) ((((r).ivm_key_mask_2[0]) >> 24) & 0xf)
#define BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_2Rf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_mask_2[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_mask_2[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_mask_2[0]=(((r).ivm_key_mask_2[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_mask_2[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_mask_2[1]=(((r).ivm_key_mask_2[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_mask_2[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_mask_2[1]=(((r).ivm_key_mask_2[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_1Rf_GET(r) ((((r).ivm_key_mask_2[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_1Rf_SET(r,f) (r).ivm_key_mask_2[1]=(((r).ivm_key_mask_2[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_MASK_2m_VALIDf_GET(r) ((((r).ivm_key_mask_2[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_MASK_2m_VALIDf_SET(r,f) (r).ivm_key_mask_2[1]=(((r).ivm_key_mask_2[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_Rf_GET(r) ((((r).ivm_key_mask_2[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_Rf_SET(r,f) (r).ivm_key_mask_2[1]=(((r).ivm_key_mask_2[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_MASK_2.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_MASK_2m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_MASK_2m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_MASK_2m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_MASK_2m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_MASK_2m BCM53600_A0_IVM_KEY_MASK_2m
#define IVM_KEY_MASK_2m_MIN BCM53600_A0_IVM_KEY_MASK_2m_MIN
#define IVM_KEY_MASK_2m_MAX BCM53600_A0_IVM_KEY_MASK_2m_MAX
#define IVM_KEY_MASK_2m_CMAX(u) BCM53600_A0_IVM_KEY_MASK_2m_CMAX(u)
#define IVM_KEY_MASK_2m_SIZE BCM53600_A0_IVM_KEY_MASK_2m_SIZE
typedef BCM53600_A0_IVM_KEY_MASK_2m_t IVM_KEY_MASK_2m_t;
#define IVM_KEY_MASK_2m_CLR BCM53600_A0_IVM_KEY_MASK_2m_CLR
#define IVM_KEY_MASK_2m_SET BCM53600_A0_IVM_KEY_MASK_2m_SET
#define IVM_KEY_MASK_2m_GET BCM53600_A0_IVM_KEY_MASK_2m_GET
#define IVM_KEY_MASK_2m_INGRESS_CVIDf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVIDf_GET
#define IVM_KEY_MASK_2m_INGRESS_CVIDf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVIDf_SET
#define IVM_KEY_MASK_2m_INGRESS_CVID_RANGEf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVID_RANGEf_GET
#define IVM_KEY_MASK_2m_INGRESS_CVID_RANGEf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CVID_RANGEf_SET
#define IVM_KEY_MASK_2m_FRAMING_TYPEf_GET BCM53600_A0_IVM_KEY_MASK_2m_FRAMING_TYPEf_GET
#define IVM_KEY_MASK_2m_FRAMING_TYPEf_SET BCM53600_A0_IVM_KEY_MASK_2m_FRAMING_TYPEf_SET
#define IVM_KEY_MASK_2m_INGRESS_CPCPf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CPCPf_GET
#define IVM_KEY_MASK_2m_INGRESS_CPCPf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CPCPf_SET
#define IVM_KEY_MASK_2m_INGRESS_SPCPf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_SPCPf_GET
#define IVM_KEY_MASK_2m_INGRESS_SPCPf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_SPCPf_SET
#define IVM_KEY_MASK_2m_RESERVED_2Rf_GET BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_2Rf_GET
#define IVM_KEY_MASK_2m_RESERVED_2Rf_SET BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_2Rf_SET
#define IVM_KEY_MASK_2m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_MASK_2m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_MASK_2m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_STAG_STSf_GET
#define IVM_KEY_MASK_2m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_STAG_STSf_SET
#define IVM_KEY_MASK_2m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_IDf_GET
#define IVM_KEY_MASK_2m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_IDf_SET
#define IVM_KEY_MASK_2m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_MASK_2m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_MASK_2m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_MASK_2m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_1Rf_GET
#define IVM_KEY_MASK_2m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_1Rf_SET
#define IVM_KEY_MASK_2m_VALIDf_GET BCM53600_A0_IVM_KEY_MASK_2m_VALIDf_GET
#define IVM_KEY_MASK_2m_VALIDf_SET BCM53600_A0_IVM_KEY_MASK_2m_VALIDf_SET
#define IVM_KEY_MASK_2m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_Rf_GET
#define IVM_KEY_MASK_2m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_MASK_2m_RESERVED_Rf_SET
#define READ_IVM_KEY_MASK_2m BCM53600_A0_READ_IVM_KEY_MASK_2m
#define WRITE_IVM_KEY_MASK_2m BCM53600_A0_WRITE_IVM_KEY_MASK_2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_MASK_2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  IVM_KEY_MASK_3
 * BLOCKS:   SYS
 * DESC:     IVM Table
 * SIZE:     64
 * FIELDS:
 *     ETH_TYPE         Field Mask
 *     INGRESS_SVID     Field Mask
 *     INGRESS_CTAG_STS Field Mask
 *     INGRESS_STAG_STS Field Mask
 *     INGRESS_PORT_ID  Field Mask
 *     INGRESS_PORT_PROFILE Field Mask
 *     RESERVED_1R      reserved
 *     VALID            Valid bit
 *     RESERVED_R       reserved should be all zero
 *
 ******************************************************************************/
#define BCM53600_A0_IVM_KEY_MASK_3m 0x00000000

#define BCM53600_A0_IVM_KEY_MASK_3m_MIN 0
#define BCM53600_A0_IVM_KEY_MASK_3m_MAX 2047
#define BCM53600_A0_IVM_KEY_MASK_3m_CMAX(u) 2047
#define BCM53600_A0_IVM_KEY_MASK_3m_SIZE 8

/*
 * This structure should be used to declare and program IVM_KEY_MASK_3.
 *
 */
typedef union BCM53600_A0_IVM_KEY_MASK_3m_s {
	uint32_t v[2];
	uint32_t ivm_key_mask_3[2];
	uint32_t _ivm_key_mask_3;
} BCM53600_A0_IVM_KEY_MASK_3m_t;

#define BCM53600_A0_IVM_KEY_MASK_3m_CLR(r) CDK_MEMSET(&((r)._ivm_key_mask_3), 0, sizeof(BCM53600_A0_IVM_KEY_MASK_3m_t))
#define BCM53600_A0_IVM_KEY_MASK_3m_SET(r,i,d) (r).ivm_key_mask_3[i] = d
#define BCM53600_A0_IVM_KEY_MASK_3m_GET(r,i) (r).ivm_key_mask_3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_IVM_KEY_MASK_3m_ETH_TYPEf_GET(r) (((r).ivm_key_mask_3[0]) & 0xffff)
#define BCM53600_A0_IVM_KEY_MASK_3m_ETH_TYPEf_SET(r,f) (r).ivm_key_mask_3[0]=(((r).ivm_key_mask_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_SVIDf_GET(r) ((((r).ivm_key_mask_3[0]) >> 16) & 0xfff)
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_SVIDf_SET(r,f) (r).ivm_key_mask_3[0]=(((r).ivm_key_mask_3[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_CTAG_STSf_GET(r) ((((r).ivm_key_mask_3[0]) >> 28) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_CTAG_STSf_SET(r,f) (r).ivm_key_mask_3[0]=(((r).ivm_key_mask_3[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_STAG_STSf_GET(r) ((((r).ivm_key_mask_3[0]) >> 30) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_STAG_STSf_SET(r,f) (r).ivm_key_mask_3[0]=(((r).ivm_key_mask_3[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_IDf_GET(r) (((r).ivm_key_mask_3[1]) & 0x3f)
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_IDf_SET(r,f) (r).ivm_key_mask_3[1]=(((r).ivm_key_mask_3[1] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_PROFILEf_GET(r) ((((r).ivm_key_mask_3[1]) >> 6) & 0x3)
#define BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_PROFILEf_SET(r,f) (r).ivm_key_mask_3[1]=(((r).ivm_key_mask_3[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_1Rf_GET(r) ((((r).ivm_key_mask_3[1]) >> 8) & 0x1ff)
#define BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_1Rf_SET(r,f) (r).ivm_key_mask_3[1]=(((r).ivm_key_mask_3[1] & ~((uint32_t)0x1ff << 8)) | ((((uint32_t)f) & 0x1ff) << 8))
#define BCM53600_A0_IVM_KEY_MASK_3m_VALIDf_GET(r) ((((r).ivm_key_mask_3[1]) >> 17) & 0x1)
#define BCM53600_A0_IVM_KEY_MASK_3m_VALIDf_SET(r,f) (r).ivm_key_mask_3[1]=(((r).ivm_key_mask_3[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_Rf_GET(r) ((((r).ivm_key_mask_3[1]) >> 18) & 0x3fff)
#define BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_Rf_SET(r,f) (r).ivm_key_mask_3[1]=(((r).ivm_key_mask_3[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IVM_KEY_MASK_3.
 *
 */
#define BCM53600_A0_READ_IVM_KEY_MASK_3m(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_IVM_KEY_MASK_3m,i,(m),8)
#define BCM53600_A0_WRITE_IVM_KEY_MASK_3m(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_IVM_KEY_MASK_3m,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVM_KEY_MASK_3m BCM53600_A0_IVM_KEY_MASK_3m
#define IVM_KEY_MASK_3m_MIN BCM53600_A0_IVM_KEY_MASK_3m_MIN
#define IVM_KEY_MASK_3m_MAX BCM53600_A0_IVM_KEY_MASK_3m_MAX
#define IVM_KEY_MASK_3m_CMAX(u) BCM53600_A0_IVM_KEY_MASK_3m_CMAX(u)
#define IVM_KEY_MASK_3m_SIZE BCM53600_A0_IVM_KEY_MASK_3m_SIZE
typedef BCM53600_A0_IVM_KEY_MASK_3m_t IVM_KEY_MASK_3m_t;
#define IVM_KEY_MASK_3m_CLR BCM53600_A0_IVM_KEY_MASK_3m_CLR
#define IVM_KEY_MASK_3m_SET BCM53600_A0_IVM_KEY_MASK_3m_SET
#define IVM_KEY_MASK_3m_GET BCM53600_A0_IVM_KEY_MASK_3m_GET
#define IVM_KEY_MASK_3m_ETH_TYPEf_GET BCM53600_A0_IVM_KEY_MASK_3m_ETH_TYPEf_GET
#define IVM_KEY_MASK_3m_ETH_TYPEf_SET BCM53600_A0_IVM_KEY_MASK_3m_ETH_TYPEf_SET
#define IVM_KEY_MASK_3m_INGRESS_SVIDf_GET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_SVIDf_GET
#define IVM_KEY_MASK_3m_INGRESS_SVIDf_SET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_SVIDf_SET
#define IVM_KEY_MASK_3m_INGRESS_CTAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_CTAG_STSf_GET
#define IVM_KEY_MASK_3m_INGRESS_CTAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_CTAG_STSf_SET
#define IVM_KEY_MASK_3m_INGRESS_STAG_STSf_GET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_STAG_STSf_GET
#define IVM_KEY_MASK_3m_INGRESS_STAG_STSf_SET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_STAG_STSf_SET
#define IVM_KEY_MASK_3m_INGRESS_PORT_IDf_GET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_IDf_GET
#define IVM_KEY_MASK_3m_INGRESS_PORT_IDf_SET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_IDf_SET
#define IVM_KEY_MASK_3m_INGRESS_PORT_PROFILEf_GET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_PROFILEf_GET
#define IVM_KEY_MASK_3m_INGRESS_PORT_PROFILEf_SET BCM53600_A0_IVM_KEY_MASK_3m_INGRESS_PORT_PROFILEf_SET
#define IVM_KEY_MASK_3m_RESERVED_1Rf_GET BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_1Rf_GET
#define IVM_KEY_MASK_3m_RESERVED_1Rf_SET BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_1Rf_SET
#define IVM_KEY_MASK_3m_VALIDf_GET BCM53600_A0_IVM_KEY_MASK_3m_VALIDf_GET
#define IVM_KEY_MASK_3m_VALIDf_SET BCM53600_A0_IVM_KEY_MASK_3m_VALIDf_SET
#define IVM_KEY_MASK_3m_RESERVED_Rf_GET BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_Rf_GET
#define IVM_KEY_MASK_3m_RESERVED_Rf_SET BCM53600_A0_IVM_KEY_MASK_3m_RESERVED_Rf_SET
#define READ_IVM_KEY_MASK_3m BCM53600_A0_READ_IVM_KEY_MASK_3m
#define WRITE_IVM_KEY_MASK_3m BCM53600_A0_WRITE_IVM_KEY_MASK_3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_IVM_KEY_MASK_3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  InRangeErrPkts
 * BLOCKS:   SYS
 * DESC:     InRange Errors Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_INRANGEERRPKTSr 0x00005164

#define BCM53600_A0_INRANGEERRPKTSr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrPkts.
 *
 */
typedef union BCM53600_A0_INRANGEERRPKTSr_s {
	uint32_t v[1];
	uint32_t inrangeerrpkts[1];
	uint32_t _inrangeerrpkts;
} BCM53600_A0_INRANGEERRPKTSr_t;

#define BCM53600_A0_INRANGEERRPKTSr_CLR(r) (r).inrangeerrpkts[0] = 0
#define BCM53600_A0_INRANGEERRPKTSr_SET(r,d) (r).inrangeerrpkts[0] = d
#define BCM53600_A0_INRANGEERRPKTSr_GET(r) (r).inrangeerrpkts[0]


/*
 * These macros can be used to access InRangeErrPkts.
 *
 */
#define BCM53600_A0_READ_INRANGEERRPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_INRANGEERRPKTSr,(r._inrangeerrpkts),4)
#define BCM53600_A0_WRITE_INRANGEERRPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_INRANGEERRPKTSr,&(r._inrangeerrpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRPKTSr BCM53600_A0_INRANGEERRPKTSr
#define INRANGEERRPKTSr_SIZE BCM53600_A0_INRANGEERRPKTSr_SIZE
typedef BCM53600_A0_INRANGEERRPKTSr_t INRANGEERRPKTSr_t;
#define INRANGEERRPKTSr_CLR BCM53600_A0_INRANGEERRPKTSr_CLR
#define INRANGEERRPKTSr_SET BCM53600_A0_INRANGEERRPKTSr_SET
#define INRANGEERRPKTSr_GET BCM53600_A0_INRANGEERRPKTSr_GET
#define READ_INRANGEERRPKTSr BCM53600_A0_READ_INRANGEERRPKTSr
#define WRITE_INRANGEERRPKTSr BCM53600_A0_WRITE_INRANGEERRPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_INRANGEERRPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     71
 * FIELDS:
 *     MACADDR_47_12    Source Address[47:12]
 *     PORTID           Port ID 
 *     RESERVED0_R      Unused
 *     V_PORTID         Virtual Port ID
 *     RESERVED1_R      Unused
 *     VID              VLAN ID
 *     STATIC           Static status
 *     AGE              Age Counter
 *     VA               Valid status
 *     USER             User Rev
 *     CON              Con function
 *
 ******************************************************************************/
#define BCM53600_A0_L2_ARLm 0x64010800

#define BCM53600_A0_L2_ARLm_MIN 0
#define BCM53600_A0_L2_ARLm_MAX 16383
#define BCM53600_A0_L2_ARLm_CMAX(u) 16383
#define BCM53600_A0_L2_ARLm_SIZE 9

/*
 * This structure should be used to declare and program L2_ARL.
 *
 */
typedef union BCM53600_A0_L2_ARLm_s {
	uint32_t v[3];
	uint32_t l2_arl[3];
	uint32_t _l2_arl;
} BCM53600_A0_L2_ARLm_t;

#define BCM53600_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM53600_A0_L2_ARLm_t))
#define BCM53600_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM53600_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,0,35,a)
#define BCM53600_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,0,35,a)
#define BCM53600_A0_L2_ARLm_PORTIDf_GET(r) ((((r).l2_arl[1]) >> 4) & 0x1f)
#define BCM53600_A0_L2_ARLm_PORTIDf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM53600_A0_L2_ARLm_RESERVED0_Rf_GET(r) ((((r).l2_arl[1]) >> 9) & 0x1)
#define BCM53600_A0_L2_ARLm_RESERVED0_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_L2_ARLm_V_PORTIDf_GET(r) ((((r).l2_arl[1]) >> 10) & 0xf)
#define BCM53600_A0_L2_ARLm_V_PORTIDf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM53600_A0_L2_ARLm_RESERVED1_Rf_GET(r) ((((r).l2_arl[1]) >> 14) & 0x3)
#define BCM53600_A0_L2_ARLm_RESERVED1_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53600_A0_L2_ARLm_VIDf_GET(r) ((((r).l2_arl[1]) >> 16) & 0xfff)
#define BCM53600_A0_L2_ARLm_VIDf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_L2_ARLm_STATICf_GET(r) ((((r).l2_arl[1]) >> 28) & 0x1)
#define BCM53600_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53600_A0_L2_ARLm_AGEf_GET(r) ((((r).l2_arl[1]) >> 29) & 0x7)
#define BCM53600_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM53600_A0_L2_ARLm_VAf_GET(r) (((r).l2_arl[2]) & 0x3)
#define BCM53600_A0_L2_ARLm_VAf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_L2_ARLm_USERf_GET(r) ((((r).l2_arl[2]) >> 2) & 0x7)
#define BCM53600_A0_L2_ARLm_USERf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53600_A0_L2_ARLm_CONf_GET(r) ((((r).l2_arl[2]) >> 5) & 0x3)
#define BCM53600_A0_L2_ARLm_CONf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))

/*
 * These macros can be used to access L2_ARL.
 *
 */
#define BCM53600_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_L2_ARLm,i,(m),9)
#define BCM53600_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_L2_ARLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM53600_A0_L2_ARLm
#define L2_ARLm_MIN BCM53600_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM53600_A0_L2_ARLm_MAX
#define L2_ARLm_CMAX(u) BCM53600_A0_L2_ARLm_CMAX(u)
#define L2_ARLm_SIZE BCM53600_A0_L2_ARLm_SIZE
typedef BCM53600_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM53600_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM53600_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM53600_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM53600_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM53600_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_PORTIDf_GET BCM53600_A0_L2_ARLm_PORTIDf_GET
#define L2_ARLm_PORTIDf_SET BCM53600_A0_L2_ARLm_PORTIDf_SET
#define L2_ARLm_RESERVED0_Rf_GET BCM53600_A0_L2_ARLm_RESERVED0_Rf_GET
#define L2_ARLm_RESERVED0_Rf_SET BCM53600_A0_L2_ARLm_RESERVED0_Rf_SET
#define L2_ARLm_V_PORTIDf_GET BCM53600_A0_L2_ARLm_V_PORTIDf_GET
#define L2_ARLm_V_PORTIDf_SET BCM53600_A0_L2_ARLm_V_PORTIDf_SET
#define L2_ARLm_RESERVED1_Rf_GET BCM53600_A0_L2_ARLm_RESERVED1_Rf_GET
#define L2_ARLm_RESERVED1_Rf_SET BCM53600_A0_L2_ARLm_RESERVED1_Rf_SET
#define L2_ARLm_VIDf_GET BCM53600_A0_L2_ARLm_VIDf_GET
#define L2_ARLm_VIDf_SET BCM53600_A0_L2_ARLm_VIDf_SET
#define L2_ARLm_STATICf_GET BCM53600_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM53600_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_AGEf_GET BCM53600_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM53600_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_VAf_GET BCM53600_A0_L2_ARLm_VAf_GET
#define L2_ARLm_VAf_SET BCM53600_A0_L2_ARLm_VAf_SET
#define L2_ARLm_USERf_GET BCM53600_A0_L2_ARLm_USERf_GET
#define L2_ARLm_USERf_SET BCM53600_A0_L2_ARLm_USERf_SET
#define L2_ARLm_CONf_GET BCM53600_A0_L2_ARLm_CONf_GET
#define L2_ARLm_CONf_SET BCM53600_A0_L2_ARLm_CONf_SET
#define READ_L2_ARLm BCM53600_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM53600_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_L2_ARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  L2_MARL
 * BLOCKS:   SYS
 * DESC:     MARL Table
 * SIZE:     71
 * FIELDS:
 *     MACADDR          SA in last 36 bits
 *     MGID             Multicast Group ID 
 *     VID              VLAN ID
 *     STATIC           Static status
 *     AGE              Age Counter
 *     VA               Valid status
 *     USER             User Rev
 *     CON              Con function
 *
 ******************************************************************************/
#define BCM53600_A0_L2_MARLm 0x00000000

#define BCM53600_A0_L2_MARLm_MIN 0
#define BCM53600_A0_L2_MARLm_MAX 16383
#define BCM53600_A0_L2_MARLm_CMAX(u) 16383
#define BCM53600_A0_L2_MARLm_SIZE 9

/*
 * This structure should be used to declare and program L2_MARL.
 *
 */
typedef union BCM53600_A0_L2_MARLm_s {
	uint32_t v[3];
	uint32_t l2_marl[3];
	uint32_t _l2_marl;
} BCM53600_A0_L2_MARLm_t;

#define BCM53600_A0_L2_MARLm_CLR(r) CDK_MEMSET(&((r)._l2_marl), 0, sizeof(BCM53600_A0_L2_MARLm_t))
#define BCM53600_A0_L2_MARLm_SET(r,i,d) (r).l2_marl[i] = d
#define BCM53600_A0_L2_MARLm_GET(r,i) (r).l2_marl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_L2_MARLm_MACADDRf_GET(r,a) cdk_field_get((r).l2_marl,0,35,a)
#define BCM53600_A0_L2_MARLm_MACADDRf_SET(r,a) cdk_field_set((r).l2_marl,0,35,a)
#define BCM53600_A0_L2_MARLm_MGIDf_GET(r) ((((r).l2_marl[1]) >> 4) & 0xfff)
#define BCM53600_A0_L2_MARLm_MGIDf_SET(r,f) (r).l2_marl[1]=(((r).l2_marl[1] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53600_A0_L2_MARLm_VIDf_GET(r) ((((r).l2_marl[1]) >> 16) & 0xfff)
#define BCM53600_A0_L2_MARLm_VIDf_SET(r,f) (r).l2_marl[1]=(((r).l2_marl[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_L2_MARLm_STATICf_GET(r) ((((r).l2_marl[1]) >> 28) & 0x1)
#define BCM53600_A0_L2_MARLm_STATICf_SET(r,f) (r).l2_marl[1]=(((r).l2_marl[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53600_A0_L2_MARLm_AGEf_GET(r) ((((r).l2_marl[1]) >> 29) & 0x7)
#define BCM53600_A0_L2_MARLm_AGEf_SET(r,f) (r).l2_marl[1]=(((r).l2_marl[1] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM53600_A0_L2_MARLm_VAf_GET(r) (((r).l2_marl[2]) & 0x3)
#define BCM53600_A0_L2_MARLm_VAf_SET(r,f) (r).l2_marl[2]=(((r).l2_marl[2] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_L2_MARLm_USERf_GET(r) ((((r).l2_marl[2]) >> 2) & 0x7)
#define BCM53600_A0_L2_MARLm_USERf_SET(r,f) (r).l2_marl[2]=(((r).l2_marl[2] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53600_A0_L2_MARLm_CONf_GET(r) ((((r).l2_marl[2]) >> 5) & 0x3)
#define BCM53600_A0_L2_MARLm_CONf_SET(r,f) (r).l2_marl[2]=(((r).l2_marl[2] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))

/*
 * These macros can be used to access L2_MARL.
 *
 */
#define BCM53600_A0_READ_L2_MARLm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_L2_MARLm,i,(m),9)
#define BCM53600_A0_WRITE_L2_MARLm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_L2_MARLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MARLm BCM53600_A0_L2_MARLm
#define L2_MARLm_MIN BCM53600_A0_L2_MARLm_MIN
#define L2_MARLm_MAX BCM53600_A0_L2_MARLm_MAX
#define L2_MARLm_CMAX(u) BCM53600_A0_L2_MARLm_CMAX(u)
#define L2_MARLm_SIZE BCM53600_A0_L2_MARLm_SIZE
typedef BCM53600_A0_L2_MARLm_t L2_MARLm_t;
#define L2_MARLm_CLR BCM53600_A0_L2_MARLm_CLR
#define L2_MARLm_SET BCM53600_A0_L2_MARLm_SET
#define L2_MARLm_GET BCM53600_A0_L2_MARLm_GET
#define L2_MARLm_MACADDRf_GET BCM53600_A0_L2_MARLm_MACADDRf_GET
#define L2_MARLm_MACADDRf_SET BCM53600_A0_L2_MARLm_MACADDRf_SET
#define L2_MARLm_MGIDf_GET BCM53600_A0_L2_MARLm_MGIDf_GET
#define L2_MARLm_MGIDf_SET BCM53600_A0_L2_MARLm_MGIDf_SET
#define L2_MARLm_VIDf_GET BCM53600_A0_L2_MARLm_VIDf_GET
#define L2_MARLm_VIDf_SET BCM53600_A0_L2_MARLm_VIDf_SET
#define L2_MARLm_STATICf_GET BCM53600_A0_L2_MARLm_STATICf_GET
#define L2_MARLm_STATICf_SET BCM53600_A0_L2_MARLm_STATICf_SET
#define L2_MARLm_AGEf_GET BCM53600_A0_L2_MARLm_AGEf_GET
#define L2_MARLm_AGEf_SET BCM53600_A0_L2_MARLm_AGEf_SET
#define L2_MARLm_VAf_GET BCM53600_A0_L2_MARLm_VAf_GET
#define L2_MARLm_VAf_SET BCM53600_A0_L2_MARLm_VAf_SET
#define L2_MARLm_USERf_GET BCM53600_A0_L2_MARLm_USERf_GET
#define L2_MARLm_USERf_SET BCM53600_A0_L2_MARLm_USERf_SET
#define L2_MARLm_CONf_GET BCM53600_A0_L2_MARLm_CONf_GET
#define L2_MARLm_CONf_SET BCM53600_A0_L2_MARLm_CONf_SET
#define READ_L2_MARLm BCM53600_A0_READ_L2_MARLm
#define WRITE_L2_MARLm BCM53600_A0_WRITE_L2_MARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_L2_MARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LCPLL_CTRL_H
 * BLOCKS:   SYS
 * DESC:     LCPLL Control-H Registers(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     DLY_BEFORE_OPENLOOP Bits[71:64] - delayBeforeOpenLoop[7:0].Charge pump current control(Not2Release)
 *     DLY_AFTER_REFRESH Bits[79:72] - delayAfterRefresh[7:0].(Not2Release)
 *     DLY_AFTER_OPENLOOP Bits[87:80] - delayAfterOpenLoop[7:0].(Not2Release)
 *     DLY_AFTER_CLOSELOOP Bits[95:88] - delayAfterCloseLoop[7:0].(Not2Release)
 *     CAL_SET_CNT      Bits[107:96] - calSetCount[11:0].(Not2Release)
 *     FORCE_CAPS       Bits[108] - force_caps.(Not2Release)
 *     CLK_GATE_OVR     Bits[109] - clk_gate_ovr.(Not2Release)
 *     CAL_MODE         Bits[110] - cal_mode.(Not2Release)
 *     CAL_SET_CNT_OVR  Bits[111] - calSetCountOvr.(Not2Release)
 *     CAL_REF_TIMEOUT  Bits[119:112] - cal_ref_timeout[7:0].(Not2Release)
 *     EN_TIMEOUT       Bits[124:120] - enable timeOut.(Not2Release)
 *     RESERVED         Bits[127:125] - reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_LCPLL_CTRL_Hr 0x00000b18

#define BCM53600_A0_LCPLL_CTRL_Hr_SIZE 8

/*
 * This structure should be used to declare and program LCPLL_CTRL_H.
 *
 */
typedef union BCM53600_A0_LCPLL_CTRL_Hr_s {
	uint32_t v[2];
	uint32_t lcpll_ctrl_h[2];
	uint32_t _lcpll_ctrl_h;
} BCM53600_A0_LCPLL_CTRL_Hr_t;

#define BCM53600_A0_LCPLL_CTRL_Hr_CLR(r) CDK_MEMSET(&((r)._lcpll_ctrl_h), 0, sizeof(BCM53600_A0_LCPLL_CTRL_Hr_t))
#define BCM53600_A0_LCPLL_CTRL_Hr_SET(r,i,d) (r).lcpll_ctrl_h[i] = d
#define BCM53600_A0_LCPLL_CTRL_Hr_GET(r,i) (r).lcpll_ctrl_h[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_BEFORE_OPENLOOPf_GET(r) (((r).lcpll_ctrl_h[0]) & 0xff)
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_BEFORE_OPENLOOPf_SET(r,f) (r).lcpll_ctrl_h[0]=(((r).lcpll_ctrl_h[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_REFRESHf_GET(r) ((((r).lcpll_ctrl_h[0]) >> 8) & 0xff)
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_REFRESHf_SET(r,f) (r).lcpll_ctrl_h[0]=(((r).lcpll_ctrl_h[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_OPENLOOPf_GET(r) ((((r).lcpll_ctrl_h[0]) >> 16) & 0xff)
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_OPENLOOPf_SET(r,f) (r).lcpll_ctrl_h[0]=(((r).lcpll_ctrl_h[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_CLOSELOOPf_GET(r) ((((r).lcpll_ctrl_h[0]) >> 24) & 0xff)
#define BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_CLOSELOOPf_SET(r,f) (r).lcpll_ctrl_h[0]=(((r).lcpll_ctrl_h[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNTf_GET(r) (((r).lcpll_ctrl_h[1]) & 0xfff)
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNTf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_LCPLL_CTRL_Hr_FORCE_CAPSf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 12) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Hr_FORCE_CAPSf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_LCPLL_CTRL_Hr_CLK_GATE_OVRf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 13) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Hr_CLK_GATE_OVRf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_MODEf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 14) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_MODEf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNT_OVRf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 15) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNT_OVRf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_REF_TIMEOUTf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 16) & 0xff)
#define BCM53600_A0_LCPLL_CTRL_Hr_CAL_REF_TIMEOUTf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_LCPLL_CTRL_Hr_EN_TIMEOUTf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 24) & 0x1f)
#define BCM53600_A0_LCPLL_CTRL_Hr_EN_TIMEOUTf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM53600_A0_LCPLL_CTRL_Hr_RESERVEDf_GET(r) ((((r).lcpll_ctrl_h[1]) >> 29) & 0x7)
#define BCM53600_A0_LCPLL_CTRL_Hr_RESERVEDf_SET(r,f) (r).lcpll_ctrl_h[1]=(((r).lcpll_ctrl_h[1] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LCPLL_CTRL_H.
 *
 */
#define BCM53600_A0_READ_LCPLL_CTRL_Hr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LCPLL_CTRL_Hr,(r._lcpll_ctrl_h),8)
#define BCM53600_A0_WRITE_LCPLL_CTRL_Hr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LCPLL_CTRL_Hr,&(r._lcpll_ctrl_h),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LCPLL_CTRL_Hr BCM53600_A0_LCPLL_CTRL_Hr
#define LCPLL_CTRL_Hr_SIZE BCM53600_A0_LCPLL_CTRL_Hr_SIZE
typedef BCM53600_A0_LCPLL_CTRL_Hr_t LCPLL_CTRL_Hr_t;
#define LCPLL_CTRL_Hr_CLR BCM53600_A0_LCPLL_CTRL_Hr_CLR
#define LCPLL_CTRL_Hr_SET BCM53600_A0_LCPLL_CTRL_Hr_SET
#define LCPLL_CTRL_Hr_GET BCM53600_A0_LCPLL_CTRL_Hr_GET
#define LCPLL_CTRL_Hr_DLY_BEFORE_OPENLOOPf_GET BCM53600_A0_LCPLL_CTRL_Hr_DLY_BEFORE_OPENLOOPf_GET
#define LCPLL_CTRL_Hr_DLY_BEFORE_OPENLOOPf_SET BCM53600_A0_LCPLL_CTRL_Hr_DLY_BEFORE_OPENLOOPf_SET
#define LCPLL_CTRL_Hr_DLY_AFTER_REFRESHf_GET BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_REFRESHf_GET
#define LCPLL_CTRL_Hr_DLY_AFTER_REFRESHf_SET BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_REFRESHf_SET
#define LCPLL_CTRL_Hr_DLY_AFTER_OPENLOOPf_GET BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_OPENLOOPf_GET
#define LCPLL_CTRL_Hr_DLY_AFTER_OPENLOOPf_SET BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_OPENLOOPf_SET
#define LCPLL_CTRL_Hr_DLY_AFTER_CLOSELOOPf_GET BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_CLOSELOOPf_GET
#define LCPLL_CTRL_Hr_DLY_AFTER_CLOSELOOPf_SET BCM53600_A0_LCPLL_CTRL_Hr_DLY_AFTER_CLOSELOOPf_SET
#define LCPLL_CTRL_Hr_CAL_SET_CNTf_GET BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNTf_GET
#define LCPLL_CTRL_Hr_CAL_SET_CNTf_SET BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNTf_SET
#define LCPLL_CTRL_Hr_FORCE_CAPSf_GET BCM53600_A0_LCPLL_CTRL_Hr_FORCE_CAPSf_GET
#define LCPLL_CTRL_Hr_FORCE_CAPSf_SET BCM53600_A0_LCPLL_CTRL_Hr_FORCE_CAPSf_SET
#define LCPLL_CTRL_Hr_CLK_GATE_OVRf_GET BCM53600_A0_LCPLL_CTRL_Hr_CLK_GATE_OVRf_GET
#define LCPLL_CTRL_Hr_CLK_GATE_OVRf_SET BCM53600_A0_LCPLL_CTRL_Hr_CLK_GATE_OVRf_SET
#define LCPLL_CTRL_Hr_CAL_MODEf_GET BCM53600_A0_LCPLL_CTRL_Hr_CAL_MODEf_GET
#define LCPLL_CTRL_Hr_CAL_MODEf_SET BCM53600_A0_LCPLL_CTRL_Hr_CAL_MODEf_SET
#define LCPLL_CTRL_Hr_CAL_SET_CNT_OVRf_GET BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNT_OVRf_GET
#define LCPLL_CTRL_Hr_CAL_SET_CNT_OVRf_SET BCM53600_A0_LCPLL_CTRL_Hr_CAL_SET_CNT_OVRf_SET
#define LCPLL_CTRL_Hr_CAL_REF_TIMEOUTf_GET BCM53600_A0_LCPLL_CTRL_Hr_CAL_REF_TIMEOUTf_GET
#define LCPLL_CTRL_Hr_CAL_REF_TIMEOUTf_SET BCM53600_A0_LCPLL_CTRL_Hr_CAL_REF_TIMEOUTf_SET
#define LCPLL_CTRL_Hr_EN_TIMEOUTf_GET BCM53600_A0_LCPLL_CTRL_Hr_EN_TIMEOUTf_GET
#define LCPLL_CTRL_Hr_EN_TIMEOUTf_SET BCM53600_A0_LCPLL_CTRL_Hr_EN_TIMEOUTf_SET
#define LCPLL_CTRL_Hr_RESERVEDf_GET BCM53600_A0_LCPLL_CTRL_Hr_RESERVEDf_GET
#define LCPLL_CTRL_Hr_RESERVEDf_SET BCM53600_A0_LCPLL_CTRL_Hr_RESERVEDf_SET
#define READ_LCPLL_CTRL_Hr BCM53600_A0_READ_LCPLL_CTRL_Hr
#define WRITE_LCPLL_CTRL_Hr BCM53600_A0_WRITE_LCPLL_CTRL_Hr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LCPLL_CTRL_Hr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LCPLL_CTRL_L
 * BLOCKS:   SYS
 * DESC:     LCPLL Control-L Registers(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     RESERVED         Bits[0] - reserved(Not2Release)
 *     OC               Bits[4:1] - OC[3:0].CML clock output buffer power downOC[3] = 1, FOUT4 downOC[2] = 1, FOUT3 downOC[1] = 1, FOUT2 downOC[0] = 1, FOUT1 down(Not2Release)
 *     LCP_CTRL         Bits[8:5] - lcp_ctrl[3:0].Charge pump current control(Not2Release)
 *     PDF_CTRL         Bits[10:9] - PDF_ctrl[1:0].PDF pulse width control(Not2Release)
 *     BIAS_CTRL        Bits[14:11] - Bias_ctrl[3:0].Global bias control(Not2Release)
 *     PLL_OBSERVE      Bits[20:15] - pll_observe[5:0].Test-out configuartion(Not2Release)
 *     LF_CTRL          Bits[26:21] - LF_ctrl[5:0].Loop Filter control(Not2Release)
 *     PLL_CTRL         Bits[31:27] - pll_ctrl[5:0].PLL configuration(Not2Release)
 *     PLL_VAL          Bits[43:32] - pll_val[11:0].(Not2Release)
 *     REF_VAL          Bits[45:44] - ref_val[1:0].(Not2Release)
 *     XTAL_ENABLE_B    Bits[46] - XTAL_enable_b.(Not2Release)
 *     CAL_ENABLE_B     Bits[47] - cal_enable_b.(Not2Release)
 *     REFRESH_CAP_CNT  Bits[50:48] - refresh_caps_cnt[2:0].(Not2Release)
 *     REFRESH_CAL      Bits[51] - refresh_cal.(Not2Release)
 *     NUM_CAPS_CHANGE  Bits[54:52] - numCapChange[2:0].(Not2Release)
 *     FORCE_CAPS_VAL   Bits[63:55] - force_caps_val[8:0].(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_LCPLL_CTRL_Lr 0x00000b10

#define BCM53600_A0_LCPLL_CTRL_Lr_SIZE 8

/*
 * This structure should be used to declare and program LCPLL_CTRL_L.
 *
 */
typedef union BCM53600_A0_LCPLL_CTRL_Lr_s {
	uint32_t v[2];
	uint32_t lcpll_ctrl_l[2];
	uint32_t _lcpll_ctrl_l;
} BCM53600_A0_LCPLL_CTRL_Lr_t;

#define BCM53600_A0_LCPLL_CTRL_Lr_CLR(r) CDK_MEMSET(&((r)._lcpll_ctrl_l), 0, sizeof(BCM53600_A0_LCPLL_CTRL_Lr_t))
#define BCM53600_A0_LCPLL_CTRL_Lr_SET(r,i,d) (r).lcpll_ctrl_l[i] = d
#define BCM53600_A0_LCPLL_CTRL_Lr_GET(r,i) (r).lcpll_ctrl_l[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LCPLL_CTRL_Lr_RESERVEDf_GET(r) (((r).lcpll_ctrl_l[0]) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Lr_RESERVEDf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_LCPLL_CTRL_Lr_OCf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 1) & 0xf)
#define BCM53600_A0_LCPLL_CTRL_Lr_OCf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM53600_A0_LCPLL_CTRL_Lr_LCP_CTRLf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 5) & 0xf)
#define BCM53600_A0_LCPLL_CTRL_Lr_LCP_CTRLf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCM53600_A0_LCPLL_CTRL_Lr_PDF_CTRLf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 9) & 0x3)
#define BCM53600_A0_LCPLL_CTRL_Lr_PDF_CTRLf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53600_A0_LCPLL_CTRL_Lr_BIAS_CTRLf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 11) & 0xf)
#define BCM53600_A0_LCPLL_CTRL_Lr_BIAS_CTRLf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53600_A0_LCPLL_CTRL_Lr_PLL_OBSERVEf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 15) & 0x3f)
#define BCM53600_A0_LCPLL_CTRL_Lr_PLL_OBSERVEf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0x3f << 15)) | ((((uint32_t)f) & 0x3f) << 15))
#define BCM53600_A0_LCPLL_CTRL_Lr_LF_CTRLf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 21) & 0x3f)
#define BCM53600_A0_LCPLL_CTRL_Lr_LF_CTRLf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0x3f << 21)) | ((((uint32_t)f) & 0x3f) << 21))
#define BCM53600_A0_LCPLL_CTRL_Lr_PLL_CTRLf_GET(r) ((((r).lcpll_ctrl_l[0]) >> 27) & 0x1f)
#define BCM53600_A0_LCPLL_CTRL_Lr_PLL_CTRLf_SET(r,f) (r).lcpll_ctrl_l[0]=(((r).lcpll_ctrl_l[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM53600_A0_LCPLL_CTRL_Lr_PLL_VALf_GET(r) (((r).lcpll_ctrl_l[1]) & 0xfff)
#define BCM53600_A0_LCPLL_CTRL_Lr_PLL_VALf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_LCPLL_CTRL_Lr_REF_VALf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 12) & 0x3)
#define BCM53600_A0_LCPLL_CTRL_Lr_REF_VALf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_LCPLL_CTRL_Lr_XTAL_ENABLE_Bf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 14) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Lr_XTAL_ENABLE_Bf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_LCPLL_CTRL_Lr_CAL_ENABLE_Bf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 15) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Lr_CAL_ENABLE_Bf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CAP_CNTf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 16) & 0x7)
#define BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CAP_CNTf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CALf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 19) & 0x1)
#define BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CALf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53600_A0_LCPLL_CTRL_Lr_NUM_CAPS_CHANGEf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 20) & 0x7)
#define BCM53600_A0_LCPLL_CTRL_Lr_NUM_CAPS_CHANGEf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM53600_A0_LCPLL_CTRL_Lr_FORCE_CAPS_VALf_GET(r) ((((r).lcpll_ctrl_l[1]) >> 23) & 0x1ff)
#define BCM53600_A0_LCPLL_CTRL_Lr_FORCE_CAPS_VALf_SET(r,f) (r).lcpll_ctrl_l[1]=(((r).lcpll_ctrl_l[1] & ~((uint32_t)0x1ff << 23)) | ((((uint32_t)f) & 0x1ff) << 23))

/*
 * These macros can be used to access LCPLL_CTRL_L.
 *
 */
#define BCM53600_A0_READ_LCPLL_CTRL_Lr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LCPLL_CTRL_Lr,(r._lcpll_ctrl_l),8)
#define BCM53600_A0_WRITE_LCPLL_CTRL_Lr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LCPLL_CTRL_Lr,&(r._lcpll_ctrl_l),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LCPLL_CTRL_Lr BCM53600_A0_LCPLL_CTRL_Lr
#define LCPLL_CTRL_Lr_SIZE BCM53600_A0_LCPLL_CTRL_Lr_SIZE
typedef BCM53600_A0_LCPLL_CTRL_Lr_t LCPLL_CTRL_Lr_t;
#define LCPLL_CTRL_Lr_CLR BCM53600_A0_LCPLL_CTRL_Lr_CLR
#define LCPLL_CTRL_Lr_SET BCM53600_A0_LCPLL_CTRL_Lr_SET
#define LCPLL_CTRL_Lr_GET BCM53600_A0_LCPLL_CTRL_Lr_GET
#define LCPLL_CTRL_Lr_RESERVEDf_GET BCM53600_A0_LCPLL_CTRL_Lr_RESERVEDf_GET
#define LCPLL_CTRL_Lr_RESERVEDf_SET BCM53600_A0_LCPLL_CTRL_Lr_RESERVEDf_SET
#define LCPLL_CTRL_Lr_OCf_GET BCM53600_A0_LCPLL_CTRL_Lr_OCf_GET
#define LCPLL_CTRL_Lr_OCf_SET BCM53600_A0_LCPLL_CTRL_Lr_OCf_SET
#define LCPLL_CTRL_Lr_LCP_CTRLf_GET BCM53600_A0_LCPLL_CTRL_Lr_LCP_CTRLf_GET
#define LCPLL_CTRL_Lr_LCP_CTRLf_SET BCM53600_A0_LCPLL_CTRL_Lr_LCP_CTRLf_SET
#define LCPLL_CTRL_Lr_PDF_CTRLf_GET BCM53600_A0_LCPLL_CTRL_Lr_PDF_CTRLf_GET
#define LCPLL_CTRL_Lr_PDF_CTRLf_SET BCM53600_A0_LCPLL_CTRL_Lr_PDF_CTRLf_SET
#define LCPLL_CTRL_Lr_BIAS_CTRLf_GET BCM53600_A0_LCPLL_CTRL_Lr_BIAS_CTRLf_GET
#define LCPLL_CTRL_Lr_BIAS_CTRLf_SET BCM53600_A0_LCPLL_CTRL_Lr_BIAS_CTRLf_SET
#define LCPLL_CTRL_Lr_PLL_OBSERVEf_GET BCM53600_A0_LCPLL_CTRL_Lr_PLL_OBSERVEf_GET
#define LCPLL_CTRL_Lr_PLL_OBSERVEf_SET BCM53600_A0_LCPLL_CTRL_Lr_PLL_OBSERVEf_SET
#define LCPLL_CTRL_Lr_LF_CTRLf_GET BCM53600_A0_LCPLL_CTRL_Lr_LF_CTRLf_GET
#define LCPLL_CTRL_Lr_LF_CTRLf_SET BCM53600_A0_LCPLL_CTRL_Lr_LF_CTRLf_SET
#define LCPLL_CTRL_Lr_PLL_CTRLf_GET BCM53600_A0_LCPLL_CTRL_Lr_PLL_CTRLf_GET
#define LCPLL_CTRL_Lr_PLL_CTRLf_SET BCM53600_A0_LCPLL_CTRL_Lr_PLL_CTRLf_SET
#define LCPLL_CTRL_Lr_PLL_VALf_GET BCM53600_A0_LCPLL_CTRL_Lr_PLL_VALf_GET
#define LCPLL_CTRL_Lr_PLL_VALf_SET BCM53600_A0_LCPLL_CTRL_Lr_PLL_VALf_SET
#define LCPLL_CTRL_Lr_REF_VALf_GET BCM53600_A0_LCPLL_CTRL_Lr_REF_VALf_GET
#define LCPLL_CTRL_Lr_REF_VALf_SET BCM53600_A0_LCPLL_CTRL_Lr_REF_VALf_SET
#define LCPLL_CTRL_Lr_XTAL_ENABLE_Bf_GET BCM53600_A0_LCPLL_CTRL_Lr_XTAL_ENABLE_Bf_GET
#define LCPLL_CTRL_Lr_XTAL_ENABLE_Bf_SET BCM53600_A0_LCPLL_CTRL_Lr_XTAL_ENABLE_Bf_SET
#define LCPLL_CTRL_Lr_CAL_ENABLE_Bf_GET BCM53600_A0_LCPLL_CTRL_Lr_CAL_ENABLE_Bf_GET
#define LCPLL_CTRL_Lr_CAL_ENABLE_Bf_SET BCM53600_A0_LCPLL_CTRL_Lr_CAL_ENABLE_Bf_SET
#define LCPLL_CTRL_Lr_REFRESH_CAP_CNTf_GET BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CAP_CNTf_GET
#define LCPLL_CTRL_Lr_REFRESH_CAP_CNTf_SET BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CAP_CNTf_SET
#define LCPLL_CTRL_Lr_REFRESH_CALf_GET BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CALf_GET
#define LCPLL_CTRL_Lr_REFRESH_CALf_SET BCM53600_A0_LCPLL_CTRL_Lr_REFRESH_CALf_SET
#define LCPLL_CTRL_Lr_NUM_CAPS_CHANGEf_GET BCM53600_A0_LCPLL_CTRL_Lr_NUM_CAPS_CHANGEf_GET
#define LCPLL_CTRL_Lr_NUM_CAPS_CHANGEf_SET BCM53600_A0_LCPLL_CTRL_Lr_NUM_CAPS_CHANGEf_SET
#define LCPLL_CTRL_Lr_FORCE_CAPS_VALf_GET BCM53600_A0_LCPLL_CTRL_Lr_FORCE_CAPS_VALf_GET
#define LCPLL_CTRL_Lr_FORCE_CAPS_VALf_SET BCM53600_A0_LCPLL_CTRL_Lr_FORCE_CAPS_VALf_SET
#define READ_LCPLL_CTRL_Lr BCM53600_A0_READ_LCPLL_CTRL_Lr
#define WRITE_LCPLL_CTRL_Lr BCM53600_A0_WRITE_LCPLL_CTRL_Lr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LCPLL_CTRL_Lr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LCPLL_STATE_OUTPUT
 * BLOCKS:   SYS
 * DESC:     LCPLL State Output Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DONE_CAL         Bits[0] - done_cal.bit indicating calibration is done.(Not2Release)
 *     HOLD_VCTRL       Bits[1] - hold_vctrl.(Not2Release)
 *     READ_CAP_VAL     Bits[10:2] - read_cap_val[8:0].(Not2Release)
 *     REFRESH_CAL_VALID Bits[11] - refresh_cal_valid.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_LCPLL_STATE_OUTPUTr 0x00000b20

#define BCM53600_A0_LCPLL_STATE_OUTPUTr_SIZE 2

/*
 * This structure should be used to declare and program LCPLL_STATE_OUTPUT.
 *
 */
typedef union BCM53600_A0_LCPLL_STATE_OUTPUTr_s {
	uint32_t v[1];
	uint32_t lcpll_state_output[1];
	uint32_t _lcpll_state_output;
} BCM53600_A0_LCPLL_STATE_OUTPUTr_t;

#define BCM53600_A0_LCPLL_STATE_OUTPUTr_CLR(r) (r).lcpll_state_output[0] = 0
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_SET(r,d) (r).lcpll_state_output[0] = d
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_GET(r) (r).lcpll_state_output[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_DONE_CALf_GET(r) (((r).lcpll_state_output[0]) & 0x1)
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_DONE_CALf_SET(r,f) (r).lcpll_state_output[0]=(((r).lcpll_state_output[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_HOLD_VCTRLf_GET(r) ((((r).lcpll_state_output[0]) >> 1) & 0x1)
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_HOLD_VCTRLf_SET(r,f) (r).lcpll_state_output[0]=(((r).lcpll_state_output[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_READ_CAP_VALf_GET(r) ((((r).lcpll_state_output[0]) >> 2) & 0x1ff)
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_READ_CAP_VALf_SET(r,f) (r).lcpll_state_output[0]=(((r).lcpll_state_output[0] & ~((uint32_t)0x1ff << 2)) | ((((uint32_t)f) & 0x1ff) << 2))
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_REFRESH_CAL_VALIDf_GET(r) ((((r).lcpll_state_output[0]) >> 11) & 0x1)
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_REFRESH_CAL_VALIDf_SET(r,f) (r).lcpll_state_output[0]=(((r).lcpll_state_output[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_RESERVEDf_GET(r) ((((r).lcpll_state_output[0]) >> 12) & 0xf)
#define BCM53600_A0_LCPLL_STATE_OUTPUTr_RESERVEDf_SET(r,f) (r).lcpll_state_output[0]=(((r).lcpll_state_output[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access LCPLL_STATE_OUTPUT.
 *
 */
#define BCM53600_A0_READ_LCPLL_STATE_OUTPUTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LCPLL_STATE_OUTPUTr,(r._lcpll_state_output),2)
#define BCM53600_A0_WRITE_LCPLL_STATE_OUTPUTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LCPLL_STATE_OUTPUTr,&(r._lcpll_state_output),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LCPLL_STATE_OUTPUTr BCM53600_A0_LCPLL_STATE_OUTPUTr
#define LCPLL_STATE_OUTPUTr_SIZE BCM53600_A0_LCPLL_STATE_OUTPUTr_SIZE
typedef BCM53600_A0_LCPLL_STATE_OUTPUTr_t LCPLL_STATE_OUTPUTr_t;
#define LCPLL_STATE_OUTPUTr_CLR BCM53600_A0_LCPLL_STATE_OUTPUTr_CLR
#define LCPLL_STATE_OUTPUTr_SET BCM53600_A0_LCPLL_STATE_OUTPUTr_SET
#define LCPLL_STATE_OUTPUTr_GET BCM53600_A0_LCPLL_STATE_OUTPUTr_GET
#define LCPLL_STATE_OUTPUTr_DONE_CALf_GET BCM53600_A0_LCPLL_STATE_OUTPUTr_DONE_CALf_GET
#define LCPLL_STATE_OUTPUTr_DONE_CALf_SET BCM53600_A0_LCPLL_STATE_OUTPUTr_DONE_CALf_SET
#define LCPLL_STATE_OUTPUTr_HOLD_VCTRLf_GET BCM53600_A0_LCPLL_STATE_OUTPUTr_HOLD_VCTRLf_GET
#define LCPLL_STATE_OUTPUTr_HOLD_VCTRLf_SET BCM53600_A0_LCPLL_STATE_OUTPUTr_HOLD_VCTRLf_SET
#define LCPLL_STATE_OUTPUTr_READ_CAP_VALf_GET BCM53600_A0_LCPLL_STATE_OUTPUTr_READ_CAP_VALf_GET
#define LCPLL_STATE_OUTPUTr_READ_CAP_VALf_SET BCM53600_A0_LCPLL_STATE_OUTPUTr_READ_CAP_VALf_SET
#define LCPLL_STATE_OUTPUTr_REFRESH_CAL_VALIDf_GET BCM53600_A0_LCPLL_STATE_OUTPUTr_REFRESH_CAL_VALIDf_GET
#define LCPLL_STATE_OUTPUTr_REFRESH_CAL_VALIDf_SET BCM53600_A0_LCPLL_STATE_OUTPUTr_REFRESH_CAL_VALIDf_SET
#define LCPLL_STATE_OUTPUTr_RESERVEDf_GET BCM53600_A0_LCPLL_STATE_OUTPUTr_RESERVEDf_GET
#define LCPLL_STATE_OUTPUTr_RESERVEDf_SET BCM53600_A0_LCPLL_STATE_OUTPUTr_RESERVEDf_SET
#define READ_LCPLL_STATE_OUTPUTr BCM53600_A0_READ_LCPLL_STATE_OUTPUTr
#define WRITE_LCPLL_STATE_OUTPUTr BCM53600_A0_WRITE_LCPLL_STATE_OUTPUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LCPLL_STATE_OUTPUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_CONTROL
 * BLOCKS:   SYS
 * DESC:     LED ReFlash control register
 * SIZE:     16
 * FIELDS:
 *     LED_RFS_STOP     LED reflsh control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     LED_NORM_CD_EN   (Not2Release)
 *     LED_POST_CD_EN   (Not2Release)
 *     LED_PSCAN_EN     
 *     LED_POST_EXEC    (Not2Release)
 *     LED_EN           1 : forwarding process enable.0 : turn off forwarding process. Assertion for dumb switchdefault value base on strap pin.output order from low port to high port.(Not2Release)
 *     EN_LOW_PORT_START Enable LED data output order from low port to high port.(Not2Release)
 *     EN_LNKACT_RATE   Enable LNK/ACT blinking rate for different link speed. 3Hz for 10M, 6Hz for100M, 12Hz for 1G.(Not2Release)
 *     EN_FUNCMAP_REORDER Enable another LED function map 0/1 order.15:reserved14:AVB Link(Internal reference only in TB B0)13:1G/ACT12:10/100M/ACT11:100M/ACT10:10M/ACT9:SPD10M8:LNK/ACT7:DPX/COL6:LNK5:ACT4:DPX3:COL2:SPD100M1:SPD1G0:reserved
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_LED_CONTROLr 0x0000005a

#define BCM53600_A0_LED_CONTROLr_SIZE 2

/*
 * This structure should be used to declare and program LED_CONTROL.
 *
 */
typedef union BCM53600_A0_LED_CONTROLr_s {
	uint32_t v[1];
	uint32_t led_control[1];
	uint32_t _led_control;
} BCM53600_A0_LED_CONTROLr_t;

#define BCM53600_A0_LED_CONTROLr_CLR(r) (r).led_control[0] = 0
#define BCM53600_A0_LED_CONTROLr_SET(r,d) (r).led_control[0] = d
#define BCM53600_A0_LED_CONTROLr_GET(r) (r).led_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_CONTROLr_LED_RFS_STOPf_GET(r) (((r).led_control[0]) & 0x7)
#define BCM53600_A0_LED_CONTROLr_LED_RFS_STOPf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_LED_CONTROLr_LED_NORM_CD_ENf_GET(r) ((((r).led_control[0]) >> 3) & 0x1)
#define BCM53600_A0_LED_CONTROLr_LED_NORM_CD_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_LED_CONTROLr_LED_POST_CD_ENf_GET(r) ((((r).led_control[0]) >> 4) & 0x1)
#define BCM53600_A0_LED_CONTROLr_LED_POST_CD_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_LED_CONTROLr_LED_PSCAN_ENf_GET(r) ((((r).led_control[0]) >> 5) & 0x1)
#define BCM53600_A0_LED_CONTROLr_LED_PSCAN_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_LED_CONTROLr_LED_POST_EXECf_GET(r) ((((r).led_control[0]) >> 6) & 0x1)
#define BCM53600_A0_LED_CONTROLr_LED_POST_EXECf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_LED_CONTROLr_LED_ENf_GET(r) ((((r).led_control[0]) >> 7) & 0x1)
#define BCM53600_A0_LED_CONTROLr_LED_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_GET(r) ((((r).led_control[0]) >> 8) & 0x1)
#define BCM53600_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_LED_CONTROLr_EN_LNKACT_RATEf_GET(r) ((((r).led_control[0]) >> 9) & 0x1)
#define BCM53600_A0_LED_CONTROLr_EN_LNKACT_RATEf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_GET(r) ((((r).led_control[0]) >> 10) & 0x1)
#define BCM53600_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_LED_CONTROLr_RESERVEDf_GET(r) ((((r).led_control[0]) >> 11) & 0x1f)
#define BCM53600_A0_LED_CONTROLr_RESERVEDf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access LED_CONTROL.
 *
 */
#define BCM53600_A0_READ_LED_CONTROLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_CONTROLr,(r._led_control),2)
#define BCM53600_A0_WRITE_LED_CONTROLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_CONTROLr,&(r._led_control),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_CONTROLr BCM53600_A0_LED_CONTROLr
#define LED_CONTROLr_SIZE BCM53600_A0_LED_CONTROLr_SIZE
typedef BCM53600_A0_LED_CONTROLr_t LED_CONTROLr_t;
#define LED_CONTROLr_CLR BCM53600_A0_LED_CONTROLr_CLR
#define LED_CONTROLr_SET BCM53600_A0_LED_CONTROLr_SET
#define LED_CONTROLr_GET BCM53600_A0_LED_CONTROLr_GET
#define LED_CONTROLr_LED_RFS_STOPf_GET BCM53600_A0_LED_CONTROLr_LED_RFS_STOPf_GET
#define LED_CONTROLr_LED_RFS_STOPf_SET BCM53600_A0_LED_CONTROLr_LED_RFS_STOPf_SET
#define LED_CONTROLr_LED_NORM_CD_ENf_GET BCM53600_A0_LED_CONTROLr_LED_NORM_CD_ENf_GET
#define LED_CONTROLr_LED_NORM_CD_ENf_SET BCM53600_A0_LED_CONTROLr_LED_NORM_CD_ENf_SET
#define LED_CONTROLr_LED_POST_CD_ENf_GET BCM53600_A0_LED_CONTROLr_LED_POST_CD_ENf_GET
#define LED_CONTROLr_LED_POST_CD_ENf_SET BCM53600_A0_LED_CONTROLr_LED_POST_CD_ENf_SET
#define LED_CONTROLr_LED_PSCAN_ENf_GET BCM53600_A0_LED_CONTROLr_LED_PSCAN_ENf_GET
#define LED_CONTROLr_LED_PSCAN_ENf_SET BCM53600_A0_LED_CONTROLr_LED_PSCAN_ENf_SET
#define LED_CONTROLr_LED_POST_EXECf_GET BCM53600_A0_LED_CONTROLr_LED_POST_EXECf_GET
#define LED_CONTROLr_LED_POST_EXECf_SET BCM53600_A0_LED_CONTROLr_LED_POST_EXECf_SET
#define LED_CONTROLr_LED_ENf_GET BCM53600_A0_LED_CONTROLr_LED_ENf_GET
#define LED_CONTROLr_LED_ENf_SET BCM53600_A0_LED_CONTROLr_LED_ENf_SET
#define LED_CONTROLr_EN_LOW_PORT_STARTf_GET BCM53600_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_GET
#define LED_CONTROLr_EN_LOW_PORT_STARTf_SET BCM53600_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_SET
#define LED_CONTROLr_EN_LNKACT_RATEf_GET BCM53600_A0_LED_CONTROLr_EN_LNKACT_RATEf_GET
#define LED_CONTROLr_EN_LNKACT_RATEf_SET BCM53600_A0_LED_CONTROLr_EN_LNKACT_RATEf_SET
#define LED_CONTROLr_EN_FUNCMAP_REORDERf_GET BCM53600_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_GET
#define LED_CONTROLr_EN_FUNCMAP_REORDERf_SET BCM53600_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_SET
#define LED_CONTROLr_RESERVEDf_GET BCM53600_A0_LED_CONTROLr_RESERVEDf_GET
#define LED_CONTROLr_RESERVEDf_SET BCM53600_A0_LED_CONTROLr_RESERVEDf_SET
#define READ_LED_CONTROLr BCM53600_A0_READ_LED_CONTROLr
#define WRITE_LED_CONTROLr BCM53600_A0_WRITE_LED_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     32
 * FIELDS:
 *     LED_EN_MAP       Per port enable function bit,default value base strap pin.53604 : 0x1aff_ffff(default)53603 : 0x1a00_ffff53602 : 0x1a00_00ff53606 : 0x1aff_ffff
 *     RESERVED_0       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_LED_EN_MAPr 0x00000068

#define BCM53600_A0_LED_EN_MAPr_SIZE 4

/*
 * This structure should be used to declare and program LED_EN_MAP.
 *
 */
typedef union BCM53600_A0_LED_EN_MAPr_s {
	uint32_t v[1];
	uint32_t led_en_map[1];
	uint32_t _led_en_map;
} BCM53600_A0_LED_EN_MAPr_t;

#define BCM53600_A0_LED_EN_MAPr_CLR(r) (r).led_en_map[0] = 0
#define BCM53600_A0_LED_EN_MAPr_SET(r,d) (r).led_en_map[0] = d
#define BCM53600_A0_LED_EN_MAPr_GET(r) (r).led_en_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) (((r).led_en_map[0]) & 0x1fffffff)
#define BCM53600_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_LED_EN_MAPr_RESERVED_0f_GET(r) ((((r).led_en_map[0]) >> 29) & 0x7)
#define BCM53600_A0_LED_EN_MAPr_RESERVED_0f_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LED_EN_MAP.
 *
 */
#define BCM53600_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_EN_MAPr,(r._led_en_map),4)
#define BCM53600_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_EN_MAPr,&(r._led_en_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM53600_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM53600_A0_LED_EN_MAPr_SIZE
typedef BCM53600_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM53600_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM53600_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM53600_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM53600_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM53600_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVED_0f_GET BCM53600_A0_LED_EN_MAPr_RESERVED_0f_GET
#define LED_EN_MAPr_RESERVED_0f_SET BCM53600_A0_LED_EN_MAPr_RESERVED_0f_SET
#define READ_LED_EN_MAPr BCM53600_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM53600_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_EN_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        15: RESV14:AVB Link(Internal reference only in TB B0)13: 1G/ACT12: 10/100M/ACT11: 100M/ACT10: 10M/ACT9: SPD1G8: SPD100M7: SPD10M6: DPX/COL5: LNK/ACT4: COL3: ACT2: DPX1: LNK0: RESVDefault value is read from LEDMODE[1:0] strap pin state on power-on. Can be overwritten subsequently.LEDMODE[00] = 0x0120(default)LEDMODE[01] = 0x0C40LEDMODE[10] = 0x0124LEDMODE[11] = 0x0C04
 *
 ******************************************************************************/
#define BCM53600_A0_LED_FUNC0_CTLr 0x0000005c

#define BCM53600_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 *
 */
typedef union BCM53600_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM53600_A0_LED_FUNC0_CTLr_t;

#define BCM53600_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM53600_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM53600_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET(r) (((r).led_func0_ctl[0]) & 0xffff)
#define BCM53600_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 *
 */
#define BCM53600_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM53600_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM53600_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM53600_A0_LED_FUNC0_CTLr_SIZE
typedef BCM53600_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM53600_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM53600_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM53600_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_GET BCM53600_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_SET BCM53600_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC0_CTLr BCM53600_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM53600_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_FUNC0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC1        15: RESV14:AVB Link(Internal reference only in TB B0)13: 1G/ACT12: 10/100M/ACT11: 100M/ACT10: 10M/ACT9: SPD1G8: SPD100M7: SPD10M6: DPX/COL5: LNK/ACT4: COL3: ACT2: DPX1: LNK0: RESVDefault value is read from LEDMODE[1:0] strap pin state on power-on. Can be overwritten subsequently.LEDMODE[00] = 0x0320(default)LEDMODE[01] = 0x3040LEDMODE[10] = 0x0324LEDMODE[11] = 0x2C04
 *
 ******************************************************************************/
#define BCM53600_A0_LED_FUNC1_CTLr 0x0000005e

#define BCM53600_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 *
 */
typedef union BCM53600_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM53600_A0_LED_FUNC1_CTLr_t;

#define BCM53600_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM53600_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM53600_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET(r) (((r).led_func1_ctl[0]) & 0xffff)
#define BCM53600_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 *
 */
#define BCM53600_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM53600_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM53600_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM53600_A0_LED_FUNC1_CTLr_SIZE
typedef BCM53600_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM53600_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM53600_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM53600_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_GET BCM53600_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_SET BCM53600_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET
#define READ_LED_FUNC1_CTLr BCM53600_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM53600_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_FUNC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     32
 * FIELDS:
 *     LED_FUNC_MAP     Per port select function bit.1: select function 1,0: select function 0.
 *     RESERVED_0       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_LED_FUNC_MAPr 0x00000060

#define BCM53600_A0_LED_FUNC_MAPr_SIZE 4

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 *
 */
typedef union BCM53600_A0_LED_FUNC_MAPr_s {
	uint32_t v[1];
	uint32_t led_func_map[1];
	uint32_t _led_func_map;
} BCM53600_A0_LED_FUNC_MAPr_t;

#define BCM53600_A0_LED_FUNC_MAPr_CLR(r) (r).led_func_map[0] = 0
#define BCM53600_A0_LED_FUNC_MAPr_SET(r,d) (r).led_func_map[0] = d
#define BCM53600_A0_LED_FUNC_MAPr_GET(r) (r).led_func_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) (((r).led_func_map[0]) & 0x1fffffff)
#define BCM53600_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_LED_FUNC_MAPr_RESERVED_0f_GET(r) ((((r).led_func_map[0]) >> 29) & 0x7)
#define BCM53600_A0_LED_FUNC_MAPr_RESERVED_0f_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LED_FUNC_MAP.
 *
 */
#define BCM53600_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_FUNC_MAPr,(r._led_func_map),4)
#define BCM53600_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_FUNC_MAPr,&(r._led_func_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM53600_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM53600_A0_LED_FUNC_MAPr_SIZE
typedef BCM53600_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM53600_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM53600_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM53600_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM53600_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM53600_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVED_0f_GET BCM53600_A0_LED_FUNC_MAPr_RESERVED_0f_GET
#define LED_FUNC_MAPr_RESERVED_0f_SET BCM53600_A0_LED_FUNC_MAPr_RESERVED_0f_SET
#define READ_LED_FUNC_MAPr BCM53600_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM53600_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_FUNC_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     32
 * FIELDS:
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_0       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_LED_MODE_MAP_0r 0x00000070

#define BCM53600_A0_LED_MODE_MAP_0r_SIZE 4

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 *
 */
typedef union BCM53600_A0_LED_MODE_MAP_0r_s {
	uint32_t v[1];
	uint32_t led_mode_map_0[1];
	uint32_t _led_mode_map_0;
} BCM53600_A0_LED_MODE_MAP_0r_t;

#define BCM53600_A0_LED_MODE_MAP_0r_CLR(r) (r).led_mode_map_0[0] = 0
#define BCM53600_A0_LED_MODE_MAP_0r_SET(r,d) (r).led_mode_map_0[0] = d
#define BCM53600_A0_LED_MODE_MAP_0r_GET(r) (r).led_mode_map_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET(r) (((r).led_mode_map_0[0]) & 0x1fffffff)
#define BCM53600_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_LED_MODE_MAP_0r_RESERVED_0f_GET(r) ((((r).led_mode_map_0[0]) >> 29) & 0x7)
#define BCM53600_A0_LED_MODE_MAP_0r_RESERVED_0f_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 *
 */
#define BCM53600_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),4)
#define BCM53600_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM53600_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM53600_A0_LED_MODE_MAP_0r_SIZE
typedef BCM53600_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM53600_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM53600_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM53600_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_GET BCM53600_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_SET BCM53600_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_0r_RESERVED_0f_GET BCM53600_A0_LED_MODE_MAP_0r_RESERVED_0f_GET
#define LED_MODE_MAP_0r_RESERVED_0f_SET BCM53600_A0_LED_MODE_MAP_0r_RESERVED_0f_SET
#define READ_LED_MODE_MAP_0r BCM53600_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM53600_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_MODE_MAP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     32
 * FIELDS:
 *     LED_MODE_MAP     Combine with LED_MODEMAP0 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_0       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_LED_MODE_MAP_1r 0x00000078

#define BCM53600_A0_LED_MODE_MAP_1r_SIZE 4

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 *
 */
typedef union BCM53600_A0_LED_MODE_MAP_1r_s {
	uint32_t v[1];
	uint32_t led_mode_map_1[1];
	uint32_t _led_mode_map_1;
} BCM53600_A0_LED_MODE_MAP_1r_t;

#define BCM53600_A0_LED_MODE_MAP_1r_CLR(r) (r).led_mode_map_1[0] = 0
#define BCM53600_A0_LED_MODE_MAP_1r_SET(r,d) (r).led_mode_map_1[0] = d
#define BCM53600_A0_LED_MODE_MAP_1r_GET(r) (r).led_mode_map_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET(r) (((r).led_mode_map_1[0]) & 0x1fffffff)
#define BCM53600_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_LED_MODE_MAP_1r_RESERVED_0f_GET(r) ((((r).led_mode_map_1[0]) >> 29) & 0x7)
#define BCM53600_A0_LED_MODE_MAP_1r_RESERVED_0f_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 *
 */
#define BCM53600_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),4)
#define BCM53600_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM53600_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM53600_A0_LED_MODE_MAP_1r_SIZE
typedef BCM53600_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM53600_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM53600_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM53600_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_GET BCM53600_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_SET BCM53600_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_1r_RESERVED_0f_GET BCM53600_A0_LED_MODE_MAP_1r_RESERVED_0f_GET
#define LED_MODE_MAP_1r_RESERVED_0f_SET BCM53600_A0_LED_MODE_MAP_1r_RESERVED_0f_SET
#define READ_LED_MODE_MAP_1r BCM53600_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM53600_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LED_MODE_MAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     Port Link Status Summary Register
 * SIZE:     32
 * FIELDS:
 *     LNK_STS          Link Status.29bit field indicating the Link Status for each 10/ 100BASE-T port, IMP port, Giga G0 ~ G3 (bits 0-23 = 10/ 100BASE-T ports, bit 24 = IMP Port, bit25 = Giga G0, bit26= Giga G1, bit27 = Giga G2, bit28= Giga G3 ).0 = Link Fail1 = Link PassNote that link status for the IMP port can only be reported for an external transceiver by:(a) using the LINK# pin to pass the transceiver's state to the Thunderbolt:(b) using the CPU to read the link status via the MDC/ MDIO interface and write this back to the IMP Port Status Override register.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_LNKSTSr 0x00000210

#define BCM53600_A0_LNKSTSr_SIZE 4

/*
 * This structure should be used to declare and program LNKSTS.
 *
 */
typedef union BCM53600_A0_LNKSTSr_s {
	uint32_t v[1];
	uint32_t lnksts[1];
	uint32_t _lnksts;
} BCM53600_A0_LNKSTSr_t;

#define BCM53600_A0_LNKSTSr_CLR(r) (r).lnksts[0] = 0
#define BCM53600_A0_LNKSTSr_SET(r,d) (r).lnksts[0] = d
#define BCM53600_A0_LNKSTSr_GET(r) (r).lnksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LNKSTSr_LNK_STSf_GET(r) (((r).lnksts[0]) & 0x1fffffff)
#define BCM53600_A0_LNKSTSr_LNK_STSf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_LNKSTSr_RESERVED_1f_GET(r) ((((r).lnksts[0]) >> 29) & 0x7)
#define BCM53600_A0_LNKSTSr_RESERVED_1f_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LNKSTS.
 *
 */
#define BCM53600_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LNKSTSr,(r._lnksts),4)
#define BCM53600_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LNKSTSr,&(r._lnksts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM53600_A0_LNKSTSr
#define LNKSTSr_SIZE BCM53600_A0_LNKSTSr_SIZE
typedef BCM53600_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM53600_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM53600_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM53600_A0_LNKSTSr_GET
#define LNKSTSr_LNK_STSf_GET BCM53600_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM53600_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVED_1f_GET BCM53600_A0_LNKSTSr_RESERVED_1f_GET
#define LNKSTSr_RESERVED_1f_SET BCM53600_A0_LNKSTSr_RESERVED_1f_SET
#define READ_LNKSTSr BCM53600_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM53600_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LNKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Port Link Status Change Register
 * SIZE:     32
 * FIELDS:
 *     LNK_STS_CHG      Link Status Change.29 bit field indicating that the Link Status for an individual 10/100BASE-T port , IMP port, Giga G0~G3 had changed since the last read operation (bits 0-23 = 10/100BASE- T ports, bit 24 = IMP Port, bit25 = Giga G0, bit26 = Giga G1, bit27 = Giga G2, bit28 = Giga G3). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant1 = Link Status ChangeNote that link status change for the IMP port can only be reported for an external transceiver by:(a) using the LINK# pin to pass the transceiver's state to the Thunderbolt:(b) using the CPU to read the link status via the MDC/ MDIO interface and write this back to the IMP Port Status Override register.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_LNKSTSCHGr 0x00000218

#define BCM53600_A0_LNKSTSCHGr_SIZE 4

/*
 * This structure should be used to declare and program LNKSTSCHG.
 *
 */
typedef union BCM53600_A0_LNKSTSCHGr_s {
	uint32_t v[1];
	uint32_t lnkstschg[1];
	uint32_t _lnkstschg;
} BCM53600_A0_LNKSTSCHGr_t;

#define BCM53600_A0_LNKSTSCHGr_CLR(r) (r).lnkstschg[0] = 0
#define BCM53600_A0_LNKSTSCHGr_SET(r,d) (r).lnkstschg[0] = d
#define BCM53600_A0_LNKSTSCHGr_GET(r) (r).lnkstschg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) (((r).lnkstschg[0]) & 0x1fffffff)
#define BCM53600_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_LNKSTSCHGr_RESERVED_1f_GET(r) ((((r).lnkstschg[0]) >> 29) & 0x7)
#define BCM53600_A0_LNKSTSCHGr_RESERVED_1f_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access LNKSTSCHG.
 *
 */
#define BCM53600_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM53600_A0_LNKSTSCHGr,(r._lnkstschg),4)
#define BCM53600_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM53600_A0_LNKSTSCHGr,&(r._lnkstschg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM53600_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM53600_A0_LNKSTSCHGr_SIZE
typedef BCM53600_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM53600_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM53600_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM53600_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM53600_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM53600_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVED_1f_GET BCM53600_A0_LNKSTSCHGr_RESERVED_1f_GET
#define LNKSTSCHGr_RESERVED_1f_SET BCM53600_A0_LNKSTSCHGr_RESERVED_1f_SET
#define READ_LNKSTSCHGr BCM53600_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM53600_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LNKSTSCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  LPNXP
 * BLOCKS:   EPIC0
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     LP_CODE_FIELD    Message/Unformatted Code Field.
 *     LP_TOGGLE        1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     LP_ACK_2         1 = Will comply with message.0 = Can not comply with message.
 *     LP_MESSAGE_PAGE  1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     LP_NEXT_PAGE     1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53600_A0_LPNXPr 0x0000a010

#define BCM53600_A0_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program LPNXP.
 *
 */
typedef union BCM53600_A0_LPNXPr_s {
	uint32_t v[1];
	uint32_t lpnxp[1];
	uint32_t _lpnxp;
} BCM53600_A0_LPNXPr_t;

#define BCM53600_A0_LPNXPr_CLR(r) (r).lpnxp[0] = 0
#define BCM53600_A0_LPNXPr_SET(r,d) (r).lpnxp[0] = d
#define BCM53600_A0_LPNXPr_GET(r) (r).lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_LPNXPr_LP_CODE_FIELDf_GET(r) (((r).lpnxp[0]) & 0x7ff)
#define BCM53600_A0_LPNXPr_LP_CODE_FIELDf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53600_A0_LPNXPr_LP_TOGGLEf_GET(r) ((((r).lpnxp[0]) >> 11) & 0x1)
#define BCM53600_A0_LPNXPr_LP_TOGGLEf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_LPNXPr_LP_ACK_2f_GET(r) ((((r).lpnxp[0]) >> 12) & 0x1)
#define BCM53600_A0_LPNXPr_LP_ACK_2f_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_LPNXPr_LP_MESSAGE_PAGEf_GET(r) ((((r).lpnxp[0]) >> 13) & 0x1)
#define BCM53600_A0_LPNXPr_LP_MESSAGE_PAGEf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_LPNXPr_RESERVEDf_GET(r) ((((r).lpnxp[0]) >> 14) & 0x1)
#define BCM53600_A0_LPNXPr_RESERVEDf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_LPNXPr_LP_NEXT_PAGEf_GET(r) ((((r).lpnxp[0]) >> 15) & 0x1)
#define BCM53600_A0_LPNXPr_LP_NEXT_PAGEf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LPNXP.
 *
 */
#define BCM53600_A0_READ_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_LPNXPr,(r._lpnxp),2)
#define BCM53600_A0_WRITE_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_LPNXPr,&(r._lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPNXPr BCM53600_A0_LPNXPr
#define LPNXPr_SIZE BCM53600_A0_LPNXPr_SIZE
typedef BCM53600_A0_LPNXPr_t LPNXPr_t;
#define LPNXPr_CLR BCM53600_A0_LPNXPr_CLR
#define LPNXPr_SET BCM53600_A0_LPNXPr_SET
#define LPNXPr_GET BCM53600_A0_LPNXPr_GET
#define LPNXPr_LP_CODE_FIELDf_GET BCM53600_A0_LPNXPr_LP_CODE_FIELDf_GET
#define LPNXPr_LP_CODE_FIELDf_SET BCM53600_A0_LPNXPr_LP_CODE_FIELDf_SET
#define LPNXPr_LP_TOGGLEf_GET BCM53600_A0_LPNXPr_LP_TOGGLEf_GET
#define LPNXPr_LP_TOGGLEf_SET BCM53600_A0_LPNXPr_LP_TOGGLEf_SET
#define LPNXPr_LP_ACK_2f_GET BCM53600_A0_LPNXPr_LP_ACK_2f_GET
#define LPNXPr_LP_ACK_2f_SET BCM53600_A0_LPNXPr_LP_ACK_2f_SET
#define LPNXPr_LP_MESSAGE_PAGEf_GET BCM53600_A0_LPNXPr_LP_MESSAGE_PAGEf_GET
#define LPNXPr_LP_MESSAGE_PAGEf_SET BCM53600_A0_LPNXPr_LP_MESSAGE_PAGEf_SET
#define LPNXPr_RESERVEDf_GET BCM53600_A0_LPNXPr_RESERVEDf_GET
#define LPNXPr_RESERVEDf_SET BCM53600_A0_LPNXPr_RESERVEDf_SET
#define LPNXPr_LP_NEXT_PAGEf_GET BCM53600_A0_LPNXPr_LP_NEXT_PAGEf_GET
#define LPNXPr_LP_NEXT_PAGEf_SET BCM53600_A0_LPNXPr_LP_NEXT_PAGEf_SET
#define READ_LPNXPr BCM53600_A0_READ_LPNXPr
#define WRITE_LPNXPr BCM53600_A0_WRITE_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MAC_FM_DROP_CTL
 * BLOCKS:   SYS
 * DESC:     Global MAC Framing Filter Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_JUMBO_FM_DROP Jumbo_frame: A packet is received with MaxSize < frame size <= JumboSize and good CRC.1 = Drop the packet.0 = Do not drop the packet.When EN_JUMBO_FM_DROP=1, all frames will be dropped if the frame size is larger than the standard maximum frame size.When EN_JUMBO_FM_DROP=0, all frames will be dropped if the frame size is larger than JUMBO_FM_SIZE defined at Page 00h, Addr 01h, Bit 2:1.
 *     DIS_LRN_JUMBO_FM_DROP Jumbo_Frame: A packet is received with MaxSize < frame size <= JumboSizeand good CRC.1 = Disable learn if the packet is dropped.0 = Do not Disable learn if the packet is dropped.
 *     EN_RANGE_ERR_DROP InRange_Error or OutOfRange_Error drop control.1).InRange_Error: A packet is received with MinSize <= frame size <= MaxSizeand good CRC, but with one of the following 2 conditions:  a). 46 <= Length <= 1500 && Length != # of data bytes;  b). Length < 46 < # of data bytes.2).OutOfRange_err: A packet is received with MinSize <= frame size<= MaxSize and good CRC, but with 1500 < Length < 1536.1 = Drop the packet.0 = Do not drop the packet.
 *     DIS_LRN_RANGE_ERR 1 = Disable learn if the packet is dropped by InRange_Error orOutOfRange_Error.0 = Do not dsable learn.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MAC_FM_DROP_CTLr 0x00002c00

#define BCM53600_A0_MAC_FM_DROP_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MAC_FM_DROP_CTL.
 *
 */
typedef union BCM53600_A0_MAC_FM_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t mac_fm_drop_ctl[1];
	uint32_t _mac_fm_drop_ctl;
} BCM53600_A0_MAC_FM_DROP_CTLr_t;

#define BCM53600_A0_MAC_FM_DROP_CTLr_CLR(r) (r).mac_fm_drop_ctl[0] = 0
#define BCM53600_A0_MAC_FM_DROP_CTLr_SET(r,d) (r).mac_fm_drop_ctl[0] = d
#define BCM53600_A0_MAC_FM_DROP_CTLr_GET(r) (r).mac_fm_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MAC_FM_DROP_CTLr_EN_JUMBO_FM_DROPf_GET(r) (((r).mac_fm_drop_ctl[0]) & 0x1)
#define BCM53600_A0_MAC_FM_DROP_CTLr_EN_JUMBO_FM_DROPf_SET(r,f) (r).mac_fm_drop_ctl[0]=(((r).mac_fm_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_JUMBO_FM_DROPf_GET(r) ((((r).mac_fm_drop_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_JUMBO_FM_DROPf_SET(r,f) (r).mac_fm_drop_ctl[0]=(((r).mac_fm_drop_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_MAC_FM_DROP_CTLr_EN_RANGE_ERR_DROPf_GET(r) ((((r).mac_fm_drop_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_MAC_FM_DROP_CTLr_EN_RANGE_ERR_DROPf_SET(r,f) (r).mac_fm_drop_ctl[0]=(((r).mac_fm_drop_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_RANGE_ERRf_GET(r) ((((r).mac_fm_drop_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_RANGE_ERRf_SET(r,f) (r).mac_fm_drop_ctl[0]=(((r).mac_fm_drop_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_MAC_FM_DROP_CTLr_RESERVEDf_GET(r) ((((r).mac_fm_drop_ctl[0]) >> 4) & 0xf)
#define BCM53600_A0_MAC_FM_DROP_CTLr_RESERVEDf_SET(r,f) (r).mac_fm_drop_ctl[0]=(((r).mac_fm_drop_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access MAC_FM_DROP_CTL.
 *
 */
#define BCM53600_A0_READ_MAC_FM_DROP_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MAC_FM_DROP_CTLr,(r._mac_fm_drop_ctl),1)
#define BCM53600_A0_WRITE_MAC_FM_DROP_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MAC_FM_DROP_CTLr,&(r._mac_fm_drop_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_FM_DROP_CTLr BCM53600_A0_MAC_FM_DROP_CTLr
#define MAC_FM_DROP_CTLr_SIZE BCM53600_A0_MAC_FM_DROP_CTLr_SIZE
typedef BCM53600_A0_MAC_FM_DROP_CTLr_t MAC_FM_DROP_CTLr_t;
#define MAC_FM_DROP_CTLr_CLR BCM53600_A0_MAC_FM_DROP_CTLr_CLR
#define MAC_FM_DROP_CTLr_SET BCM53600_A0_MAC_FM_DROP_CTLr_SET
#define MAC_FM_DROP_CTLr_GET BCM53600_A0_MAC_FM_DROP_CTLr_GET
#define MAC_FM_DROP_CTLr_EN_JUMBO_FM_DROPf_GET BCM53600_A0_MAC_FM_DROP_CTLr_EN_JUMBO_FM_DROPf_GET
#define MAC_FM_DROP_CTLr_EN_JUMBO_FM_DROPf_SET BCM53600_A0_MAC_FM_DROP_CTLr_EN_JUMBO_FM_DROPf_SET
#define MAC_FM_DROP_CTLr_DIS_LRN_JUMBO_FM_DROPf_GET BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_JUMBO_FM_DROPf_GET
#define MAC_FM_DROP_CTLr_DIS_LRN_JUMBO_FM_DROPf_SET BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_JUMBO_FM_DROPf_SET
#define MAC_FM_DROP_CTLr_EN_RANGE_ERR_DROPf_GET BCM53600_A0_MAC_FM_DROP_CTLr_EN_RANGE_ERR_DROPf_GET
#define MAC_FM_DROP_CTLr_EN_RANGE_ERR_DROPf_SET BCM53600_A0_MAC_FM_DROP_CTLr_EN_RANGE_ERR_DROPf_SET
#define MAC_FM_DROP_CTLr_DIS_LRN_RANGE_ERRf_GET BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_RANGE_ERRf_GET
#define MAC_FM_DROP_CTLr_DIS_LRN_RANGE_ERRf_SET BCM53600_A0_MAC_FM_DROP_CTLr_DIS_LRN_RANGE_ERRf_SET
#define MAC_FM_DROP_CTLr_RESERVEDf_GET BCM53600_A0_MAC_FM_DROP_CTLr_RESERVEDf_GET
#define MAC_FM_DROP_CTLr_RESERVEDf_SET BCM53600_A0_MAC_FM_DROP_CTLr_RESERVEDf_SET
#define READ_MAC_FM_DROP_CTLr BCM53600_A0_READ_MAC_FM_DROP_CTLr
#define WRITE_MAC_FM_DROP_CTLr BCM53600_A0_WRITE_MAC_FM_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MAC_FM_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  MARL_PBMP
 * BLOCKS:   SYS
 * DESC:     Multicast Table
 * SIZE:     29
 * FIELDS:
 *     PBMP             Multicast forwarding vector
 *
 ******************************************************************************/
#define BCM53600_A0_MARL_PBMPm 0x00000000

#define BCM53600_A0_MARL_PBMPm_MIN 0
#define BCM53600_A0_MARL_PBMPm_MAX 4095
#define BCM53600_A0_MARL_PBMPm_CMAX(u) 4095
#define BCM53600_A0_MARL_PBMPm_SIZE 4

/*
 * This structure should be used to declare and program MARL_PBMP.
 *
 */
typedef union BCM53600_A0_MARL_PBMPm_s {
	uint32_t v[1];
	uint32_t marl_pbmp[1];
	uint32_t _marl_pbmp;
} BCM53600_A0_MARL_PBMPm_t;

#define BCM53600_A0_MARL_PBMPm_CLR(r) (r).marl_pbmp[0] = 0
#define BCM53600_A0_MARL_PBMPm_SET(r,d) (r).marl_pbmp[0] = d
#define BCM53600_A0_MARL_PBMPm_GET(r) (r).marl_pbmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MARL_PBMPm_PBMPf_GET(r) (((r).marl_pbmp[0]) & 0x1fffffff)
#define BCM53600_A0_MARL_PBMPm_PBMPf_SET(r,f) (r).marl_pbmp[0]=(((r).marl_pbmp[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access MARL_PBMP.
 *
 */
#define BCM53600_A0_READ_MARL_PBMPm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_MARL_PBMPm,i,(m),4)
#define BCM53600_A0_WRITE_MARL_PBMPm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_MARL_PBMPm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARL_PBMPm BCM53600_A0_MARL_PBMPm
#define MARL_PBMPm_MIN BCM53600_A0_MARL_PBMPm_MIN
#define MARL_PBMPm_MAX BCM53600_A0_MARL_PBMPm_MAX
#define MARL_PBMPm_CMAX(u) BCM53600_A0_MARL_PBMPm_CMAX(u)
#define MARL_PBMPm_SIZE BCM53600_A0_MARL_PBMPm_SIZE
typedef BCM53600_A0_MARL_PBMPm_t MARL_PBMPm_t;
#define MARL_PBMPm_CLR BCM53600_A0_MARL_PBMPm_CLR
#define MARL_PBMPm_SET BCM53600_A0_MARL_PBMPm_SET
#define MARL_PBMPm_GET BCM53600_A0_MARL_PBMPm_GET
#define MARL_PBMPm_PBMPf_GET BCM53600_A0_MARL_PBMPm_PBMPf_GET
#define MARL_PBMPm_PBMPf_SET BCM53600_A0_MARL_PBMPm_PBMPf_SET
#define READ_MARL_PBMPm BCM53600_A0_READ_MARL_PBMPm
#define WRITE_MARL_PBMPm BCM53600_A0_WRITE_MARL_PBMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MARL_PBMPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MAX_ICMPV4_SIZE
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv4 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV4_SIZE  MAX_ICMPv4_Size is programable between 0 and 9728 bytes, inclusive.The default value is set to 512 bytes.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MAX_ICMPV4_SIZEr 0x00002c24

#define BCM53600_A0_MAX_ICMPV4_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV4_SIZE.
 *
 */
typedef union BCM53600_A0_MAX_ICMPV4_SIZEr_s {
	uint32_t v[1];
	uint32_t max_icmpv4_size[1];
	uint32_t _max_icmpv4_size;
} BCM53600_A0_MAX_ICMPV4_SIZEr_t;

#define BCM53600_A0_MAX_ICMPV4_SIZEr_CLR(r) (r).max_icmpv4_size[0] = 0
#define BCM53600_A0_MAX_ICMPV4_SIZEr_SET(r,d) (r).max_icmpv4_size[0] = d
#define BCM53600_A0_MAX_ICMPV4_SIZEr_GET(r) (r).max_icmpv4_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MAX_ICMPV4_SIZEr_MAX_ICMPV4_SIZEf_GET(r) (((r).max_icmpv4_size[0]) & 0x3fff)
#define BCM53600_A0_MAX_ICMPV4_SIZEr_MAX_ICMPV4_SIZEf_SET(r,f) (r).max_icmpv4_size[0]=(((r).max_icmpv4_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53600_A0_MAX_ICMPV4_SIZEr_RESERVEDf_GET(r) ((((r).max_icmpv4_size[0]) >> 14) & 0x3ffff)
#define BCM53600_A0_MAX_ICMPV4_SIZEr_RESERVEDf_SET(r,f) (r).max_icmpv4_size[0]=(((r).max_icmpv4_size[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access MAX_ICMPV4_SIZE.
 *
 */
#define BCM53600_A0_READ_MAX_ICMPV4_SIZEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MAX_ICMPV4_SIZEr,(r._max_icmpv4_size),4)
#define BCM53600_A0_WRITE_MAX_ICMPV4_SIZEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MAX_ICMPV4_SIZEr,&(r._max_icmpv4_size),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV4_SIZEr BCM53600_A0_MAX_ICMPV4_SIZEr
#define MAX_ICMPV4_SIZEr_SIZE BCM53600_A0_MAX_ICMPV4_SIZEr_SIZE
typedef BCM53600_A0_MAX_ICMPV4_SIZEr_t MAX_ICMPV4_SIZEr_t;
#define MAX_ICMPV4_SIZEr_CLR BCM53600_A0_MAX_ICMPV4_SIZEr_CLR
#define MAX_ICMPV4_SIZEr_SET BCM53600_A0_MAX_ICMPV4_SIZEr_SET
#define MAX_ICMPV4_SIZEr_GET BCM53600_A0_MAX_ICMPV4_SIZEr_GET
#define MAX_ICMPV4_SIZEr_MAX_ICMPV4_SIZEf_GET BCM53600_A0_MAX_ICMPV4_SIZEr_MAX_ICMPV4_SIZEf_GET
#define MAX_ICMPV4_SIZEr_MAX_ICMPV4_SIZEf_SET BCM53600_A0_MAX_ICMPV4_SIZEr_MAX_ICMPV4_SIZEf_SET
#define MAX_ICMPV4_SIZEr_RESERVEDf_GET BCM53600_A0_MAX_ICMPV4_SIZEr_RESERVEDf_GET
#define MAX_ICMPV4_SIZEr_RESERVEDf_SET BCM53600_A0_MAX_ICMPV4_SIZEr_RESERVEDf_SET
#define READ_MAX_ICMPV4_SIZEr BCM53600_A0_READ_MAX_ICMPV4_SIZEr
#define WRITE_MAX_ICMPV4_SIZEr BCM53600_A0_WRITE_MAX_ICMPV4_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MAX_ICMPV4_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MAX_ICMPV6_SIZE
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv6 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV6_SIZE  MAX_ICMPv6_Size is programable between 0 and 9728 bytes, inclusive.The default value is set to 512 bytes.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MAX_ICMPV6_SIZEr 0x00002c28

#define BCM53600_A0_MAX_ICMPV6_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV6_SIZE.
 *
 */
typedef union BCM53600_A0_MAX_ICMPV6_SIZEr_s {
	uint32_t v[1];
	uint32_t max_icmpv6_size[1];
	uint32_t _max_icmpv6_size;
} BCM53600_A0_MAX_ICMPV6_SIZEr_t;

#define BCM53600_A0_MAX_ICMPV6_SIZEr_CLR(r) (r).max_icmpv6_size[0] = 0
#define BCM53600_A0_MAX_ICMPV6_SIZEr_SET(r,d) (r).max_icmpv6_size[0] = d
#define BCM53600_A0_MAX_ICMPV6_SIZEr_GET(r) (r).max_icmpv6_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MAX_ICMPV6_SIZEr_MAX_ICMPV6_SIZEf_GET(r) (((r).max_icmpv6_size[0]) & 0x3fff)
#define BCM53600_A0_MAX_ICMPV6_SIZEr_MAX_ICMPV6_SIZEf_SET(r,f) (r).max_icmpv6_size[0]=(((r).max_icmpv6_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53600_A0_MAX_ICMPV6_SIZEr_RESERVEDf_GET(r) ((((r).max_icmpv6_size[0]) >> 14) & 0x3ffff)
#define BCM53600_A0_MAX_ICMPV6_SIZEr_RESERVEDf_SET(r,f) (r).max_icmpv6_size[0]=(((r).max_icmpv6_size[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access MAX_ICMPV6_SIZE.
 *
 */
#define BCM53600_A0_READ_MAX_ICMPV6_SIZEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MAX_ICMPV6_SIZEr,(r._max_icmpv6_size),4)
#define BCM53600_A0_WRITE_MAX_ICMPV6_SIZEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MAX_ICMPV6_SIZEr,&(r._max_icmpv6_size),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV6_SIZEr BCM53600_A0_MAX_ICMPV6_SIZEr
#define MAX_ICMPV6_SIZEr_SIZE BCM53600_A0_MAX_ICMPV6_SIZEr_SIZE
typedef BCM53600_A0_MAX_ICMPV6_SIZEr_t MAX_ICMPV6_SIZEr_t;
#define MAX_ICMPV6_SIZEr_CLR BCM53600_A0_MAX_ICMPV6_SIZEr_CLR
#define MAX_ICMPV6_SIZEr_SET BCM53600_A0_MAX_ICMPV6_SIZEr_SET
#define MAX_ICMPV6_SIZEr_GET BCM53600_A0_MAX_ICMPV6_SIZEr_GET
#define MAX_ICMPV6_SIZEr_MAX_ICMPV6_SIZEf_GET BCM53600_A0_MAX_ICMPV6_SIZEr_MAX_ICMPV6_SIZEf_GET
#define MAX_ICMPV6_SIZEr_MAX_ICMPV6_SIZEf_SET BCM53600_A0_MAX_ICMPV6_SIZEr_MAX_ICMPV6_SIZEf_SET
#define MAX_ICMPV6_SIZEr_RESERVEDf_GET BCM53600_A0_MAX_ICMPV6_SIZEr_RESERVEDf_GET
#define MAX_ICMPV6_SIZEr_RESERVEDf_SET BCM53600_A0_MAX_ICMPV6_SIZEr_RESERVEDf_SET
#define READ_MAX_ICMPV6_SIZEr BCM53600_A0_READ_MAX_ICMPV6_SIZEr
#define WRITE_MAX_ICMPV6_SIZEr BCM53600_A0_WRITE_MAX_ICMPV6_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MAX_ICMPV6_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  MCAST_VPORT_MAP
 * BLOCKS:   SYS
 * DESC:     MCAST_VPORT_MAP Table
 * SIZE:     16
 * FIELDS:
 *     VPORT_0          Virtual Port 0
 *     VPORT_1          Virtual Port 1
 *     VPORT_2          Virtual Port 2
 *     VPORT_3          Virtual Port 3
 *     VPORT_4          Virtual Port 4
 *     VPORT_5          Virtual Port 5
 *     VPORT_6          Virtual Port 6
 *     VPORT_7          Virtual Port 7
 *     VPORT_8          Virtual Port 8
 *     VPORT_9          Virtual Port 9
 *     VPORT_10         Virtual Port 10
 *     VPORT_11         Virtual Port 11
 *     VPORT_12         Virtual Port 12
 *     VPORT_13         Virtual Port 13
 *     VPORT_14         Virtual Port 14
 *     VPORT_15         Virtual Port 15
 *
 ******************************************************************************/
#define BCM53600_A0_MCAST_VPORT_MAPm 0x00000000

#define BCM53600_A0_MCAST_VPORT_MAPm_MIN 0
#define BCM53600_A0_MCAST_VPORT_MAPm_MAX 7423
#define BCM53600_A0_MCAST_VPORT_MAPm_CMAX(u) 7423
#define BCM53600_A0_MCAST_VPORT_MAPm_SIZE 2

/*
 * This structure should be used to declare and program MCAST_VPORT_MAP.
 *
 */
typedef union BCM53600_A0_MCAST_VPORT_MAPm_s {
	uint32_t v[1];
	uint32_t mcast_vport_map[1];
	uint32_t _mcast_vport_map;
} BCM53600_A0_MCAST_VPORT_MAPm_t;

#define BCM53600_A0_MCAST_VPORT_MAPm_CLR(r) (r).mcast_vport_map[0] = 0
#define BCM53600_A0_MCAST_VPORT_MAPm_SET(r,d) (r).mcast_vport_map[0] = d
#define BCM53600_A0_MCAST_VPORT_MAPm_GET(r) (r).mcast_vport_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_0f_GET(r) (((r).mcast_vport_map[0]) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_0f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_1f_GET(r) ((((r).mcast_vport_map[0]) >> 1) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_1f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_2f_GET(r) ((((r).mcast_vport_map[0]) >> 2) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_2f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_3f_GET(r) ((((r).mcast_vport_map[0]) >> 3) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_3f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_4f_GET(r) ((((r).mcast_vport_map[0]) >> 4) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_4f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_5f_GET(r) ((((r).mcast_vport_map[0]) >> 5) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_5f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_6f_GET(r) ((((r).mcast_vport_map[0]) >> 6) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_6f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_7f_GET(r) ((((r).mcast_vport_map[0]) >> 7) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_7f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_8f_GET(r) ((((r).mcast_vport_map[0]) >> 8) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_8f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_9f_GET(r) ((((r).mcast_vport_map[0]) >> 9) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_9f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_10f_GET(r) ((((r).mcast_vport_map[0]) >> 10) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_10f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_11f_GET(r) ((((r).mcast_vport_map[0]) >> 11) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_11f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_12f_GET(r) ((((r).mcast_vport_map[0]) >> 12) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_12f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_13f_GET(r) ((((r).mcast_vport_map[0]) >> 13) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_13f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_14f_GET(r) ((((r).mcast_vport_map[0]) >> 14) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_14f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_15f_GET(r) ((((r).mcast_vport_map[0]) >> 15) & 0x1)
#define BCM53600_A0_MCAST_VPORT_MAPm_VPORT_15f_SET(r,f) (r).mcast_vport_map[0]=(((r).mcast_vport_map[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MCAST_VPORT_MAP.
 *
 */
#define BCM53600_A0_READ_MCAST_VPORT_MAPm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_MCAST_VPORT_MAPm,i,(m),2)
#define BCM53600_A0_WRITE_MCAST_VPORT_MAPm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_MCAST_VPORT_MAPm,i,&(m),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MCAST_VPORT_MAPm BCM53600_A0_MCAST_VPORT_MAPm
#define MCAST_VPORT_MAPm_MIN BCM53600_A0_MCAST_VPORT_MAPm_MIN
#define MCAST_VPORT_MAPm_MAX BCM53600_A0_MCAST_VPORT_MAPm_MAX
#define MCAST_VPORT_MAPm_CMAX(u) BCM53600_A0_MCAST_VPORT_MAPm_CMAX(u)
#define MCAST_VPORT_MAPm_SIZE BCM53600_A0_MCAST_VPORT_MAPm_SIZE
typedef BCM53600_A0_MCAST_VPORT_MAPm_t MCAST_VPORT_MAPm_t;
#define MCAST_VPORT_MAPm_CLR BCM53600_A0_MCAST_VPORT_MAPm_CLR
#define MCAST_VPORT_MAPm_SET BCM53600_A0_MCAST_VPORT_MAPm_SET
#define MCAST_VPORT_MAPm_GET BCM53600_A0_MCAST_VPORT_MAPm_GET
#define MCAST_VPORT_MAPm_VPORT_0f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_0f_GET
#define MCAST_VPORT_MAPm_VPORT_0f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_0f_SET
#define MCAST_VPORT_MAPm_VPORT_1f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_1f_GET
#define MCAST_VPORT_MAPm_VPORT_1f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_1f_SET
#define MCAST_VPORT_MAPm_VPORT_2f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_2f_GET
#define MCAST_VPORT_MAPm_VPORT_2f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_2f_SET
#define MCAST_VPORT_MAPm_VPORT_3f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_3f_GET
#define MCAST_VPORT_MAPm_VPORT_3f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_3f_SET
#define MCAST_VPORT_MAPm_VPORT_4f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_4f_GET
#define MCAST_VPORT_MAPm_VPORT_4f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_4f_SET
#define MCAST_VPORT_MAPm_VPORT_5f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_5f_GET
#define MCAST_VPORT_MAPm_VPORT_5f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_5f_SET
#define MCAST_VPORT_MAPm_VPORT_6f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_6f_GET
#define MCAST_VPORT_MAPm_VPORT_6f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_6f_SET
#define MCAST_VPORT_MAPm_VPORT_7f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_7f_GET
#define MCAST_VPORT_MAPm_VPORT_7f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_7f_SET
#define MCAST_VPORT_MAPm_VPORT_8f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_8f_GET
#define MCAST_VPORT_MAPm_VPORT_8f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_8f_SET
#define MCAST_VPORT_MAPm_VPORT_9f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_9f_GET
#define MCAST_VPORT_MAPm_VPORT_9f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_9f_SET
#define MCAST_VPORT_MAPm_VPORT_10f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_10f_GET
#define MCAST_VPORT_MAPm_VPORT_10f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_10f_SET
#define MCAST_VPORT_MAPm_VPORT_11f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_11f_GET
#define MCAST_VPORT_MAPm_VPORT_11f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_11f_SET
#define MCAST_VPORT_MAPm_VPORT_12f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_12f_GET
#define MCAST_VPORT_MAPm_VPORT_12f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_12f_SET
#define MCAST_VPORT_MAPm_VPORT_13f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_13f_GET
#define MCAST_VPORT_MAPm_VPORT_13f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_13f_SET
#define MCAST_VPORT_MAPm_VPORT_14f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_14f_GET
#define MCAST_VPORT_MAPm_VPORT_14f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_14f_SET
#define MCAST_VPORT_MAPm_VPORT_15f_GET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_15f_GET
#define MCAST_VPORT_MAPm_VPORT_15f_SET BCM53600_A0_MCAST_VPORT_MAPm_VPORT_15f_SET
#define READ_MCAST_VPORT_MAPm BCM53600_A0_READ_MCAST_VPORT_MAPm
#define WRITE_MCAST_VPORT_MAPm BCM53600_A0_WRITE_MCAST_VPORT_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MCAST_VPORT_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MDIO_BASE_ADDR
 * BLOCKS:   SYS
 * DESC:     SERDES MDIO Base Address Registrer(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     BASE_ADDR        SerDes MDIO SCAN Base ADDRESS.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *     DELAY_CONTROL    Enable SerDes early detect for CRS and COL signals in 10/100 half duplex mode.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MDIO_BASE_ADDRr 0x000000b0

#define BCM53600_A0_MDIO_BASE_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_BASE_ADDR.
 *
 */
typedef union BCM53600_A0_MDIO_BASE_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_base_addr[1];
	uint32_t _mdio_base_addr;
} BCM53600_A0_MDIO_BASE_ADDRr_t;

#define BCM53600_A0_MDIO_BASE_ADDRr_CLR(r) (r).mdio_base_addr[0] = 0
#define BCM53600_A0_MDIO_BASE_ADDRr_SET(r,d) (r).mdio_base_addr[0] = d
#define BCM53600_A0_MDIO_BASE_ADDRr_GET(r) (r).mdio_base_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MDIO_BASE_ADDRr_BASE_ADDRf_GET(r) (((r).mdio_base_addr[0]) & 0x1f)
#define BCM53600_A0_MDIO_BASE_ADDRr_BASE_ADDRf_SET(r,f) (r).mdio_base_addr[0]=(((r).mdio_base_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_MDIO_BASE_ADDRr_RESERVEDf_GET(r) ((((r).mdio_base_addr[0]) >> 5) & 0x3)
#define BCM53600_A0_MDIO_BASE_ADDRr_RESERVEDf_SET(r,f) (r).mdio_base_addr[0]=(((r).mdio_base_addr[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53600_A0_MDIO_BASE_ADDRr_DELAY_CONTROLf_GET(r) ((((r).mdio_base_addr[0]) >> 7) & 0x1)
#define BCM53600_A0_MDIO_BASE_ADDRr_DELAY_CONTROLf_SET(r,f) (r).mdio_base_addr[0]=(((r).mdio_base_addr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MDIO_BASE_ADDR.
 *
 */
#define BCM53600_A0_READ_MDIO_BASE_ADDRr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MDIO_BASE_ADDRr,(r._mdio_base_addr),1)
#define BCM53600_A0_WRITE_MDIO_BASE_ADDRr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MDIO_BASE_ADDRr,&(r._mdio_base_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BASE_ADDRr BCM53600_A0_MDIO_BASE_ADDRr
#define MDIO_BASE_ADDRr_SIZE BCM53600_A0_MDIO_BASE_ADDRr_SIZE
typedef BCM53600_A0_MDIO_BASE_ADDRr_t MDIO_BASE_ADDRr_t;
#define MDIO_BASE_ADDRr_CLR BCM53600_A0_MDIO_BASE_ADDRr_CLR
#define MDIO_BASE_ADDRr_SET BCM53600_A0_MDIO_BASE_ADDRr_SET
#define MDIO_BASE_ADDRr_GET BCM53600_A0_MDIO_BASE_ADDRr_GET
#define MDIO_BASE_ADDRr_BASE_ADDRf_GET BCM53600_A0_MDIO_BASE_ADDRr_BASE_ADDRf_GET
#define MDIO_BASE_ADDRr_BASE_ADDRf_SET BCM53600_A0_MDIO_BASE_ADDRr_BASE_ADDRf_SET
#define MDIO_BASE_ADDRr_RESERVEDf_GET BCM53600_A0_MDIO_BASE_ADDRr_RESERVEDf_GET
#define MDIO_BASE_ADDRr_RESERVEDf_SET BCM53600_A0_MDIO_BASE_ADDRr_RESERVEDf_SET
#define MDIO_BASE_ADDRr_DELAY_CONTROLf_GET BCM53600_A0_MDIO_BASE_ADDRr_DELAY_CONTROLf_GET
#define MDIO_BASE_ADDRr_DELAY_CONTROLf_SET BCM53600_A0_MDIO_BASE_ADDRr_DELAY_CONTROLf_SET
#define READ_MDIO_BASE_ADDRr BCM53600_A0_READ_MDIO_BASE_ADDRr
#define WRITE_MDIO_BASE_ADDRr BCM53600_A0_WRITE_MDIO_BASE_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MDIO_BASE_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_ADDR_0
 * BLOCKS:   SYS
 * DESC:     Memory Address0/Offset Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADDR_OFFSET  Memory Address/Offset
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_ADDR_0r 0x00000810

#define BCM53600_A0_MEM_ADDR_0r_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR_0.
 *
 */
typedef union BCM53600_A0_MEM_ADDR_0r_s {
	uint32_t v[1];
	uint32_t mem_addr_0[1];
	uint32_t _mem_addr_0;
} BCM53600_A0_MEM_ADDR_0r_t;

#define BCM53600_A0_MEM_ADDR_0r_CLR(r) (r).mem_addr_0[0] = 0
#define BCM53600_A0_MEM_ADDR_0r_SET(r,d) (r).mem_addr_0[0] = d
#define BCM53600_A0_MEM_ADDR_0r_GET(r) (r).mem_addr_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_ADDR_0r_MEM_ADDR_OFFSETf_GET(r) (((r).mem_addr_0[0]) & 0xffff)
#define BCM53600_A0_MEM_ADDR_0r_MEM_ADDR_OFFSETf_SET(r,f) (r).mem_addr_0[0]=(((r).mem_addr_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_ADDR_0.
 *
 */
#define BCM53600_A0_READ_MEM_ADDR_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_ADDR_0r,(r._mem_addr_0),2)
#define BCM53600_A0_WRITE_MEM_ADDR_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_ADDR_0r,&(r._mem_addr_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDR_0r BCM53600_A0_MEM_ADDR_0r
#define MEM_ADDR_0r_SIZE BCM53600_A0_MEM_ADDR_0r_SIZE
typedef BCM53600_A0_MEM_ADDR_0r_t MEM_ADDR_0r_t;
#define MEM_ADDR_0r_CLR BCM53600_A0_MEM_ADDR_0r_CLR
#define MEM_ADDR_0r_SET BCM53600_A0_MEM_ADDR_0r_SET
#define MEM_ADDR_0r_GET BCM53600_A0_MEM_ADDR_0r_GET
#define MEM_ADDR_0r_MEM_ADDR_OFFSETf_GET BCM53600_A0_MEM_ADDR_0r_MEM_ADDR_OFFSETf_GET
#define MEM_ADDR_0r_MEM_ADDR_OFFSETf_SET BCM53600_A0_MEM_ADDR_0r_MEM_ADDR_OFFSETf_SET
#define READ_MEM_ADDR_0r BCM53600_A0_READ_MEM_ADDR_0r
#define WRITE_MEM_ADDR_0r BCM53600_A0_WRITE_MEM_ADDR_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_ADDR_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_ADDR_1
 * BLOCKS:   SYS
 * DESC:     Memory Address1/Offset Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADDR_OFFSET  Memory Address/Offset
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_ADDR_1r 0x00000812

#define BCM53600_A0_MEM_ADDR_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR_1.
 *
 */
typedef union BCM53600_A0_MEM_ADDR_1r_s {
	uint32_t v[1];
	uint32_t mem_addr_1[1];
	uint32_t _mem_addr_1;
} BCM53600_A0_MEM_ADDR_1r_t;

#define BCM53600_A0_MEM_ADDR_1r_CLR(r) (r).mem_addr_1[0] = 0
#define BCM53600_A0_MEM_ADDR_1r_SET(r,d) (r).mem_addr_1[0] = d
#define BCM53600_A0_MEM_ADDR_1r_GET(r) (r).mem_addr_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_ADDR_1r_MEM_ADDR_OFFSETf_GET(r) (((r).mem_addr_1[0]) & 0xffff)
#define BCM53600_A0_MEM_ADDR_1r_MEM_ADDR_OFFSETf_SET(r,f) (r).mem_addr_1[0]=(((r).mem_addr_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_ADDR_1.
 *
 */
#define BCM53600_A0_READ_MEM_ADDR_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_ADDR_1r,(r._mem_addr_1),2)
#define BCM53600_A0_WRITE_MEM_ADDR_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_ADDR_1r,&(r._mem_addr_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDR_1r BCM53600_A0_MEM_ADDR_1r
#define MEM_ADDR_1r_SIZE BCM53600_A0_MEM_ADDR_1r_SIZE
typedef BCM53600_A0_MEM_ADDR_1r_t MEM_ADDR_1r_t;
#define MEM_ADDR_1r_CLR BCM53600_A0_MEM_ADDR_1r_CLR
#define MEM_ADDR_1r_SET BCM53600_A0_MEM_ADDR_1r_SET
#define MEM_ADDR_1r_GET BCM53600_A0_MEM_ADDR_1r_GET
#define MEM_ADDR_1r_MEM_ADDR_OFFSETf_GET BCM53600_A0_MEM_ADDR_1r_MEM_ADDR_OFFSETf_GET
#define MEM_ADDR_1r_MEM_ADDR_OFFSETf_SET BCM53600_A0_MEM_ADDR_1r_MEM_ADDR_OFFSETf_SET
#define READ_MEM_ADDR_1r BCM53600_A0_READ_MEM_ADDR_1r
#define WRITE_MEM_ADDR_1r BCM53600_A0_WRITE_MEM_ADDR_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_ADDR_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_ADDR_2
 * BLOCKS:   SYS
 * DESC:     Memory Address2/Offset Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADDR_OFFSET  Memory Address/Offset
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_ADDR_2r 0x00000814

#define BCM53600_A0_MEM_ADDR_2r_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR_2.
 *
 */
typedef union BCM53600_A0_MEM_ADDR_2r_s {
	uint32_t v[1];
	uint32_t mem_addr_2[1];
	uint32_t _mem_addr_2;
} BCM53600_A0_MEM_ADDR_2r_t;

#define BCM53600_A0_MEM_ADDR_2r_CLR(r) (r).mem_addr_2[0] = 0
#define BCM53600_A0_MEM_ADDR_2r_SET(r,d) (r).mem_addr_2[0] = d
#define BCM53600_A0_MEM_ADDR_2r_GET(r) (r).mem_addr_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_ADDR_2r_MEM_ADDR_OFFSETf_GET(r) (((r).mem_addr_2[0]) & 0xffff)
#define BCM53600_A0_MEM_ADDR_2r_MEM_ADDR_OFFSETf_SET(r,f) (r).mem_addr_2[0]=(((r).mem_addr_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_ADDR_2.
 *
 */
#define BCM53600_A0_READ_MEM_ADDR_2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_ADDR_2r,(r._mem_addr_2),2)
#define BCM53600_A0_WRITE_MEM_ADDR_2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_ADDR_2r,&(r._mem_addr_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDR_2r BCM53600_A0_MEM_ADDR_2r
#define MEM_ADDR_2r_SIZE BCM53600_A0_MEM_ADDR_2r_SIZE
typedef BCM53600_A0_MEM_ADDR_2r_t MEM_ADDR_2r_t;
#define MEM_ADDR_2r_CLR BCM53600_A0_MEM_ADDR_2r_CLR
#define MEM_ADDR_2r_SET BCM53600_A0_MEM_ADDR_2r_SET
#define MEM_ADDR_2r_GET BCM53600_A0_MEM_ADDR_2r_GET
#define MEM_ADDR_2r_MEM_ADDR_OFFSETf_GET BCM53600_A0_MEM_ADDR_2r_MEM_ADDR_OFFSETf_GET
#define MEM_ADDR_2r_MEM_ADDR_OFFSETf_SET BCM53600_A0_MEM_ADDR_2r_MEM_ADDR_OFFSETf_SET
#define READ_MEM_ADDR_2r BCM53600_A0_READ_MEM_ADDR_2r
#define WRITE_MEM_ADDR_2r BCM53600_A0_WRITE_MEM_ADDR_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_ADDR_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_ADDR_3
 * BLOCKS:   SYS
 * DESC:     Memory Address3/Offset Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADDR_OFFSET  Memory Address/Offset
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_ADDR_3r 0x00000816

#define BCM53600_A0_MEM_ADDR_3r_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR_3.
 *
 */
typedef union BCM53600_A0_MEM_ADDR_3r_s {
	uint32_t v[1];
	uint32_t mem_addr_3[1];
	uint32_t _mem_addr_3;
} BCM53600_A0_MEM_ADDR_3r_t;

#define BCM53600_A0_MEM_ADDR_3r_CLR(r) (r).mem_addr_3[0] = 0
#define BCM53600_A0_MEM_ADDR_3r_SET(r,d) (r).mem_addr_3[0] = d
#define BCM53600_A0_MEM_ADDR_3r_GET(r) (r).mem_addr_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_ADDR_3r_MEM_ADDR_OFFSETf_GET(r) (((r).mem_addr_3[0]) & 0xffff)
#define BCM53600_A0_MEM_ADDR_3r_MEM_ADDR_OFFSETf_SET(r,f) (r).mem_addr_3[0]=(((r).mem_addr_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_ADDR_3.
 *
 */
#define BCM53600_A0_READ_MEM_ADDR_3r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_ADDR_3r,(r._mem_addr_3),2)
#define BCM53600_A0_WRITE_MEM_ADDR_3r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_ADDR_3r,&(r._mem_addr_3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDR_3r BCM53600_A0_MEM_ADDR_3r
#define MEM_ADDR_3r_SIZE BCM53600_A0_MEM_ADDR_3r_SIZE
typedef BCM53600_A0_MEM_ADDR_3r_t MEM_ADDR_3r_t;
#define MEM_ADDR_3r_CLR BCM53600_A0_MEM_ADDR_3r_CLR
#define MEM_ADDR_3r_SET BCM53600_A0_MEM_ADDR_3r_SET
#define MEM_ADDR_3r_GET BCM53600_A0_MEM_ADDR_3r_GET
#define MEM_ADDR_3r_MEM_ADDR_OFFSETf_GET BCM53600_A0_MEM_ADDR_3r_MEM_ADDR_OFFSETf_GET
#define MEM_ADDR_3r_MEM_ADDR_OFFSETf_SET BCM53600_A0_MEM_ADDR_3r_MEM_ADDR_OFFSETf_SET
#define READ_MEM_ADDR_3r BCM53600_A0_READ_MEM_ADDR_3r
#define WRITE_MEM_ADDR_3r BCM53600_A0_WRITE_MEM_ADDR_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_ADDR_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Control Register
 * SIZE:     8
 * FIELDS:
 *     OP_CMD           The 6 bit Operation Command6'b000000 = No operation6'b000001 = Read Operation6'b000010 = Write Operation6'b000011 = Index Read Operation(NOTE:the operation is only for ARL Table)6'b000100 = Index Write Operation(NOTE:the operation is only for ARL Table)6'b000101 = Valid scan Operation6'b000110 = Memory Fill Operation6'b000111 = Memory Move Operation6'b001000 = Write Limit operation(NOTE:the operation is only for SA Learning Counter Configuration Table)6'b001001 = Reset 0 operation(NOTE:the operation is only for SA Learning Counter Configuration Table)6'b001010 = Increase One operation(NOTE:the operation is only for SA Learning Counter Configuration Table)6'b001011 = Decrease One operation(NOTE:the operation is only for SA Learning Counter Configuration Table)6'b001100 = TCAM compare operation(Not2Release)6'b001101-6'b111110 = No Define
 *     MEM_INDICATION   Memory Indication for CFP TCAM data/mask access.0- TCAM Data table1- TCAM Mask table
 *     MEM_STDN         Start/Done Command
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_CTRLr 0x00000808

#define BCM53600_A0_MEM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_CTRL.
 *
 */
typedef union BCM53600_A0_MEM_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_ctrl[1];
	uint32_t _mem_ctrl;
} BCM53600_A0_MEM_CTRLr_t;

#define BCM53600_A0_MEM_CTRLr_CLR(r) (r).mem_ctrl[0] = 0
#define BCM53600_A0_MEM_CTRLr_SET(r,d) (r).mem_ctrl[0] = d
#define BCM53600_A0_MEM_CTRLr_GET(r) (r).mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_CTRLr_OP_CMDf_GET(r) (((r).mem_ctrl[0]) & 0x3f)
#define BCM53600_A0_MEM_CTRLr_OP_CMDf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_MEM_CTRLr_MEM_INDICATIONf_GET(r) ((((r).mem_ctrl[0]) >> 6) & 0x1)
#define BCM53600_A0_MEM_CTRLr_MEM_INDICATIONf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MEM_CTRLr_MEM_STDNf_GET(r) ((((r).mem_ctrl[0]) >> 7) & 0x1)
#define BCM53600_A0_MEM_CTRLr_MEM_STDNf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MEM_CTRL.
 *
 */
#define BCM53600_A0_READ_MEM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_CTRLr,(r._mem_ctrl),1)
#define BCM53600_A0_WRITE_MEM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_CTRLr,&(r._mem_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_CTRLr BCM53600_A0_MEM_CTRLr
#define MEM_CTRLr_SIZE BCM53600_A0_MEM_CTRLr_SIZE
typedef BCM53600_A0_MEM_CTRLr_t MEM_CTRLr_t;
#define MEM_CTRLr_CLR BCM53600_A0_MEM_CTRLr_CLR
#define MEM_CTRLr_SET BCM53600_A0_MEM_CTRLr_SET
#define MEM_CTRLr_GET BCM53600_A0_MEM_CTRLr_GET
#define MEM_CTRLr_OP_CMDf_GET BCM53600_A0_MEM_CTRLr_OP_CMDf_GET
#define MEM_CTRLr_OP_CMDf_SET BCM53600_A0_MEM_CTRLr_OP_CMDf_SET
#define MEM_CTRLr_MEM_INDICATIONf_GET BCM53600_A0_MEM_CTRLr_MEM_INDICATIONf_GET
#define MEM_CTRLr_MEM_INDICATIONf_SET BCM53600_A0_MEM_CTRLr_MEM_INDICATIONf_SET
#define MEM_CTRLr_MEM_STDNf_GET BCM53600_A0_MEM_CTRLr_MEM_STDNf_GET
#define MEM_CTRLr_MEM_STDNf_SET BCM53600_A0_MEM_CTRLr_MEM_STDNf_SET
#define READ_MEM_CTRLr BCM53600_A0_READ_MEM_CTRLr
#define WRITE_MEM_CTRLr BCM53600_A0_WRITE_MEM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA
 * BLOCKS:   SYS
 * DESC:     Memory Data 0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATAr 0x00000820

#define BCM53600_A0_MEM_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA.
 *
 */
typedef union BCM53600_A0_MEM_DATAr_s {
	uint32_t v[2];
	uint32_t mem_data[2];
	uint32_t _mem_data;
} BCM53600_A0_MEM_DATAr_t;

#define BCM53600_A0_MEM_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_data), 0, sizeof(BCM53600_A0_MEM_DATAr_t))
#define BCM53600_A0_MEM_DATAr_SET(r,i,d) (r).mem_data[i] = d
#define BCM53600_A0_MEM_DATAr_GET(r,i) (r).mem_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATAr_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data,0,63,a)
#define BCM53600_A0_MEM_DATAr_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data,0,63,a)

/*
 * These macros can be used to access MEM_DATA.
 *
 */
#define BCM53600_A0_READ_MEM_DATAr(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATAr+(8*(i)),(r._mem_data),8)
#define BCM53600_A0_WRITE_MEM_DATAr(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATAr+(8*(i)),&(r._mem_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATAr BCM53600_A0_MEM_DATAr
#define MEM_DATAr_SIZE BCM53600_A0_MEM_DATAr_SIZE
typedef BCM53600_A0_MEM_DATAr_t MEM_DATAr_t;
#define MEM_DATAr_CLR BCM53600_A0_MEM_DATAr_CLR
#define MEM_DATAr_SET BCM53600_A0_MEM_DATAr_SET
#define MEM_DATAr_GET BCM53600_A0_MEM_DATAr_GET
#define MEM_DATAr_MEM_DATAf_GET BCM53600_A0_MEM_DATAr_MEM_DATAf_GET
#define MEM_DATAr_MEM_DATAf_SET BCM53600_A0_MEM_DATAr_MEM_DATAf_SET
#define READ_MEM_DATAr BCM53600_A0_READ_MEM_DATAr
#define WRITE_MEM_DATAr BCM53600_A0_WRITE_MEM_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_0
 * BLOCKS:   SYS
 * DESC:     Memory Data 0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_0r 0x00000820

#define BCM53600_A0_MEM_DATA_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_0.
 *
 */
typedef union BCM53600_A0_MEM_DATA_0r_s {
	uint32_t v[2];
	uint32_t mem_data_0[2];
	uint32_t _mem_data_0;
} BCM53600_A0_MEM_DATA_0r_t;

#define BCM53600_A0_MEM_DATA_0r_CLR(r) CDK_MEMSET(&((r)._mem_data_0), 0, sizeof(BCM53600_A0_MEM_DATA_0r_t))
#define BCM53600_A0_MEM_DATA_0r_SET(r,i,d) (r).mem_data_0[i] = d
#define BCM53600_A0_MEM_DATA_0r_GET(r,i) (r).mem_data_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_0,0,63,a)
#define BCM53600_A0_MEM_DATA_0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_0,0,63,a)

/*
 * These macros can be used to access MEM_DATA_0.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_0r,(r._mem_data_0),8)
#define BCM53600_A0_WRITE_MEM_DATA_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_0r,&(r._mem_data_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_0r BCM53600_A0_MEM_DATA_0r
#define MEM_DATA_0r_SIZE BCM53600_A0_MEM_DATA_0r_SIZE
typedef BCM53600_A0_MEM_DATA_0r_t MEM_DATA_0r_t;
#define MEM_DATA_0r_CLR BCM53600_A0_MEM_DATA_0r_CLR
#define MEM_DATA_0r_SET BCM53600_A0_MEM_DATA_0r_SET
#define MEM_DATA_0r_GET BCM53600_A0_MEM_DATA_0r_GET
#define MEM_DATA_0r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_0r_MEM_DATAf_GET
#define MEM_DATA_0r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_0r_MEM_DATAf_SET
#define READ_MEM_DATA_0r BCM53600_A0_READ_MEM_DATA_0r
#define WRITE_MEM_DATA_0r BCM53600_A0_WRITE_MEM_DATA_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_1
 * BLOCKS:   SYS
 * DESC:     Memory Data 1 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_1r 0x00000828

#define BCM53600_A0_MEM_DATA_1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_1.
 *
 */
typedef union BCM53600_A0_MEM_DATA_1r_s {
	uint32_t v[2];
	uint32_t mem_data_1[2];
	uint32_t _mem_data_1;
} BCM53600_A0_MEM_DATA_1r_t;

#define BCM53600_A0_MEM_DATA_1r_CLR(r) CDK_MEMSET(&((r)._mem_data_1), 0, sizeof(BCM53600_A0_MEM_DATA_1r_t))
#define BCM53600_A0_MEM_DATA_1r_SET(r,i,d) (r).mem_data_1[i] = d
#define BCM53600_A0_MEM_DATA_1r_GET(r,i) (r).mem_data_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_1r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_1,0,63,a)
#define BCM53600_A0_MEM_DATA_1r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_1,0,63,a)

/*
 * These macros can be used to access MEM_DATA_1.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_1r,(r._mem_data_1),8)
#define BCM53600_A0_WRITE_MEM_DATA_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_1r,&(r._mem_data_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_1r BCM53600_A0_MEM_DATA_1r
#define MEM_DATA_1r_SIZE BCM53600_A0_MEM_DATA_1r_SIZE
typedef BCM53600_A0_MEM_DATA_1r_t MEM_DATA_1r_t;
#define MEM_DATA_1r_CLR BCM53600_A0_MEM_DATA_1r_CLR
#define MEM_DATA_1r_SET BCM53600_A0_MEM_DATA_1r_SET
#define MEM_DATA_1r_GET BCM53600_A0_MEM_DATA_1r_GET
#define MEM_DATA_1r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_1r_MEM_DATAf_GET
#define MEM_DATA_1r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_1r_MEM_DATAf_SET
#define READ_MEM_DATA_1r BCM53600_A0_READ_MEM_DATA_1r
#define WRITE_MEM_DATA_1r BCM53600_A0_WRITE_MEM_DATA_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_2
 * BLOCKS:   SYS
 * DESC:     Memory Data 2 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_2r 0x00000830

#define BCM53600_A0_MEM_DATA_2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_2.
 *
 */
typedef union BCM53600_A0_MEM_DATA_2r_s {
	uint32_t v[2];
	uint32_t mem_data_2[2];
	uint32_t _mem_data_2;
} BCM53600_A0_MEM_DATA_2r_t;

#define BCM53600_A0_MEM_DATA_2r_CLR(r) CDK_MEMSET(&((r)._mem_data_2), 0, sizeof(BCM53600_A0_MEM_DATA_2r_t))
#define BCM53600_A0_MEM_DATA_2r_SET(r,i,d) (r).mem_data_2[i] = d
#define BCM53600_A0_MEM_DATA_2r_GET(r,i) (r).mem_data_2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_2r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_2,0,63,a)
#define BCM53600_A0_MEM_DATA_2r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_2,0,63,a)

/*
 * These macros can be used to access MEM_DATA_2.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_2r,(r._mem_data_2),8)
#define BCM53600_A0_WRITE_MEM_DATA_2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_2r,&(r._mem_data_2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_2r BCM53600_A0_MEM_DATA_2r
#define MEM_DATA_2r_SIZE BCM53600_A0_MEM_DATA_2r_SIZE
typedef BCM53600_A0_MEM_DATA_2r_t MEM_DATA_2r_t;
#define MEM_DATA_2r_CLR BCM53600_A0_MEM_DATA_2r_CLR
#define MEM_DATA_2r_SET BCM53600_A0_MEM_DATA_2r_SET
#define MEM_DATA_2r_GET BCM53600_A0_MEM_DATA_2r_GET
#define MEM_DATA_2r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_2r_MEM_DATAf_GET
#define MEM_DATA_2r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_2r_MEM_DATAf_SET
#define READ_MEM_DATA_2r BCM53600_A0_READ_MEM_DATA_2r
#define WRITE_MEM_DATA_2r BCM53600_A0_WRITE_MEM_DATA_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_3
 * BLOCKS:   SYS
 * DESC:     Memory Data 3 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_3r 0x00000838

#define BCM53600_A0_MEM_DATA_3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_3.
 *
 */
typedef union BCM53600_A0_MEM_DATA_3r_s {
	uint32_t v[2];
	uint32_t mem_data_3[2];
	uint32_t _mem_data_3;
} BCM53600_A0_MEM_DATA_3r_t;

#define BCM53600_A0_MEM_DATA_3r_CLR(r) CDK_MEMSET(&((r)._mem_data_3), 0, sizeof(BCM53600_A0_MEM_DATA_3r_t))
#define BCM53600_A0_MEM_DATA_3r_SET(r,i,d) (r).mem_data_3[i] = d
#define BCM53600_A0_MEM_DATA_3r_GET(r,i) (r).mem_data_3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_3r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_3,0,63,a)
#define BCM53600_A0_MEM_DATA_3r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_3,0,63,a)

/*
 * These macros can be used to access MEM_DATA_3.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_3r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_3r,(r._mem_data_3),8)
#define BCM53600_A0_WRITE_MEM_DATA_3r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_3r,&(r._mem_data_3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_3r BCM53600_A0_MEM_DATA_3r
#define MEM_DATA_3r_SIZE BCM53600_A0_MEM_DATA_3r_SIZE
typedef BCM53600_A0_MEM_DATA_3r_t MEM_DATA_3r_t;
#define MEM_DATA_3r_CLR BCM53600_A0_MEM_DATA_3r_CLR
#define MEM_DATA_3r_SET BCM53600_A0_MEM_DATA_3r_SET
#define MEM_DATA_3r_GET BCM53600_A0_MEM_DATA_3r_GET
#define MEM_DATA_3r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_3r_MEM_DATAf_GET
#define MEM_DATA_3r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_3r_MEM_DATAf_SET
#define READ_MEM_DATA_3r BCM53600_A0_READ_MEM_DATA_3r
#define WRITE_MEM_DATA_3r BCM53600_A0_WRITE_MEM_DATA_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_4
 * BLOCKS:   SYS
 * DESC:     Memory Data 4 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_4r 0x00000840

#define BCM53600_A0_MEM_DATA_4r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_4.
 *
 */
typedef union BCM53600_A0_MEM_DATA_4r_s {
	uint32_t v[2];
	uint32_t mem_data_4[2];
	uint32_t _mem_data_4;
} BCM53600_A0_MEM_DATA_4r_t;

#define BCM53600_A0_MEM_DATA_4r_CLR(r) CDK_MEMSET(&((r)._mem_data_4), 0, sizeof(BCM53600_A0_MEM_DATA_4r_t))
#define BCM53600_A0_MEM_DATA_4r_SET(r,i,d) (r).mem_data_4[i] = d
#define BCM53600_A0_MEM_DATA_4r_GET(r,i) (r).mem_data_4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_4r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_4,0,63,a)
#define BCM53600_A0_MEM_DATA_4r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_4,0,63,a)

/*
 * These macros can be used to access MEM_DATA_4.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_4r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_4r,(r._mem_data_4),8)
#define BCM53600_A0_WRITE_MEM_DATA_4r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_4r,&(r._mem_data_4),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_4r BCM53600_A0_MEM_DATA_4r
#define MEM_DATA_4r_SIZE BCM53600_A0_MEM_DATA_4r_SIZE
typedef BCM53600_A0_MEM_DATA_4r_t MEM_DATA_4r_t;
#define MEM_DATA_4r_CLR BCM53600_A0_MEM_DATA_4r_CLR
#define MEM_DATA_4r_SET BCM53600_A0_MEM_DATA_4r_SET
#define MEM_DATA_4r_GET BCM53600_A0_MEM_DATA_4r_GET
#define MEM_DATA_4r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_4r_MEM_DATAf_GET
#define MEM_DATA_4r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_4r_MEM_DATAf_SET
#define READ_MEM_DATA_4r BCM53600_A0_READ_MEM_DATA_4r
#define WRITE_MEM_DATA_4r BCM53600_A0_WRITE_MEM_DATA_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_5
 * BLOCKS:   SYS
 * DESC:     Memory Data 5 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_5r 0x00000848

#define BCM53600_A0_MEM_DATA_5r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_5.
 *
 */
typedef union BCM53600_A0_MEM_DATA_5r_s {
	uint32_t v[2];
	uint32_t mem_data_5[2];
	uint32_t _mem_data_5;
} BCM53600_A0_MEM_DATA_5r_t;

#define BCM53600_A0_MEM_DATA_5r_CLR(r) CDK_MEMSET(&((r)._mem_data_5), 0, sizeof(BCM53600_A0_MEM_DATA_5r_t))
#define BCM53600_A0_MEM_DATA_5r_SET(r,i,d) (r).mem_data_5[i] = d
#define BCM53600_A0_MEM_DATA_5r_GET(r,i) (r).mem_data_5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_5r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_5,0,63,a)
#define BCM53600_A0_MEM_DATA_5r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_5,0,63,a)

/*
 * These macros can be used to access MEM_DATA_5.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_5r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_5r,(r._mem_data_5),8)
#define BCM53600_A0_WRITE_MEM_DATA_5r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_5r,&(r._mem_data_5),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_5r BCM53600_A0_MEM_DATA_5r
#define MEM_DATA_5r_SIZE BCM53600_A0_MEM_DATA_5r_SIZE
typedef BCM53600_A0_MEM_DATA_5r_t MEM_DATA_5r_t;
#define MEM_DATA_5r_CLR BCM53600_A0_MEM_DATA_5r_CLR
#define MEM_DATA_5r_SET BCM53600_A0_MEM_DATA_5r_SET
#define MEM_DATA_5r_GET BCM53600_A0_MEM_DATA_5r_GET
#define MEM_DATA_5r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_5r_MEM_DATAf_GET
#define MEM_DATA_5r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_5r_MEM_DATAf_SET
#define READ_MEM_DATA_5r BCM53600_A0_READ_MEM_DATA_5r
#define WRITE_MEM_DATA_5r BCM53600_A0_WRITE_MEM_DATA_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_6
 * BLOCKS:   SYS
 * DESC:     Memory Data 6 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_6r 0x00000850

#define BCM53600_A0_MEM_DATA_6r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_6.
 *
 */
typedef union BCM53600_A0_MEM_DATA_6r_s {
	uint32_t v[2];
	uint32_t mem_data_6[2];
	uint32_t _mem_data_6;
} BCM53600_A0_MEM_DATA_6r_t;

#define BCM53600_A0_MEM_DATA_6r_CLR(r) CDK_MEMSET(&((r)._mem_data_6), 0, sizeof(BCM53600_A0_MEM_DATA_6r_t))
#define BCM53600_A0_MEM_DATA_6r_SET(r,i,d) (r).mem_data_6[i] = d
#define BCM53600_A0_MEM_DATA_6r_GET(r,i) (r).mem_data_6[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_6r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_6,0,63,a)
#define BCM53600_A0_MEM_DATA_6r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_6,0,63,a)

/*
 * These macros can be used to access MEM_DATA_6.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_6r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_6r,(r._mem_data_6),8)
#define BCM53600_A0_WRITE_MEM_DATA_6r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_6r,&(r._mem_data_6),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_6r BCM53600_A0_MEM_DATA_6r
#define MEM_DATA_6r_SIZE BCM53600_A0_MEM_DATA_6r_SIZE
typedef BCM53600_A0_MEM_DATA_6r_t MEM_DATA_6r_t;
#define MEM_DATA_6r_CLR BCM53600_A0_MEM_DATA_6r_CLR
#define MEM_DATA_6r_SET BCM53600_A0_MEM_DATA_6r_SET
#define MEM_DATA_6r_GET BCM53600_A0_MEM_DATA_6r_GET
#define MEM_DATA_6r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_6r_MEM_DATAf_GET
#define MEM_DATA_6r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_6r_MEM_DATAf_SET
#define READ_MEM_DATA_6r BCM53600_A0_READ_MEM_DATA_6r
#define WRITE_MEM_DATA_6r BCM53600_A0_WRITE_MEM_DATA_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_DATA_7
 * BLOCKS:   SYS
 * DESC:     Memory Data 7 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_DATA_7r 0x00000858

#define BCM53600_A0_MEM_DATA_7r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_7.
 *
 */
typedef union BCM53600_A0_MEM_DATA_7r_s {
	uint32_t v[2];
	uint32_t mem_data_7[2];
	uint32_t _mem_data_7;
} BCM53600_A0_MEM_DATA_7r_t;

#define BCM53600_A0_MEM_DATA_7r_CLR(r) CDK_MEMSET(&((r)._mem_data_7), 0, sizeof(BCM53600_A0_MEM_DATA_7r_t))
#define BCM53600_A0_MEM_DATA_7r_SET(r,i,d) (r).mem_data_7[i] = d
#define BCM53600_A0_MEM_DATA_7r_GET(r,i) (r).mem_data_7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_DATA_7r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_data_7,0,63,a)
#define BCM53600_A0_MEM_DATA_7r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_data_7,0,63,a)

/*
 * These macros can be used to access MEM_DATA_7.
 *
 */
#define BCM53600_A0_READ_MEM_DATA_7r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_DATA_7r,(r._mem_data_7),8)
#define BCM53600_A0_WRITE_MEM_DATA_7r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_DATA_7r,&(r._mem_data_7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_7r BCM53600_A0_MEM_DATA_7r
#define MEM_DATA_7r_SIZE BCM53600_A0_MEM_DATA_7r_SIZE
typedef BCM53600_A0_MEM_DATA_7r_t MEM_DATA_7r_t;
#define MEM_DATA_7r_CLR BCM53600_A0_MEM_DATA_7r_CLR
#define MEM_DATA_7r_SET BCM53600_A0_MEM_DATA_7r_SET
#define MEM_DATA_7r_GET BCM53600_A0_MEM_DATA_7r_GET
#define MEM_DATA_7r_MEM_DATAf_GET BCM53600_A0_MEM_DATA_7r_MEM_DATAf_GET
#define MEM_DATA_7r_MEM_DATAf_SET BCM53600_A0_MEM_DATA_7r_MEM_DATAf_SET
#define READ_MEM_DATA_7r BCM53600_A0_READ_MEM_DATA_7r
#define WRITE_MEM_DATA_7r BCM53600_A0_WRITE_MEM_DATA_7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_DATA_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_INDEX
 * BLOCKS:   SYS
 * DESC:     Memory/Table Index Register
 * SIZE:     8
 * FIELDS:
 *     INDEX            The 8 bit memory-table index8'h01 = ARL Table8'h02 = Multicast Table8'h03 = VLAN Table8'h04 = Multiple Spanning Tree Table8'h10 = CFP TCAM Data/Mask8'h11 = CFP Action/Policy RAM8'h12 = CFP Rate Meter RAM8'h13 = CFP Green/Yellow/Red Statistic RAM8'h20 = IVM Key TCAM Data/Mask8'h21 = IVM Action RAM8'h30 = EVM Key TCAM Data/Mask8'h31 = EVM Action RAM8'h40 = Ingress Rate Control Port Table8'h41 = Egress Rate Control Port Table8'h50 = 1P-to-TCDP Port Mapping Table8'h51 = TCDP-to-1P Port Mapping Table8'h52 = Port Mask Table8'h53 = SA Learning Counter Configuration Table8'h54 = DSCPECN-to-TCDP Mapping Table8'h55 = TCDP-to-DSCPECN MAPPING Table8'h60 = Multicast Group Virtual Port ID Mapping Table8'h61 = Virtual Port VID Mapping Table8'hF0 = Frame Buffer Memory Table(Reserved for Engineering only)8'hF1 = Buffer Tag Control Table(Reserved for Engineering only)
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_INDEXr 0x00000800

#define BCM53600_A0_MEM_INDEXr_SIZE 1

/*
 * This structure should be used to declare and program MEM_INDEX.
 *
 */
typedef union BCM53600_A0_MEM_INDEXr_s {
	uint32_t v[1];
	uint32_t mem_index[1];
	uint32_t _mem_index;
} BCM53600_A0_MEM_INDEXr_t;

#define BCM53600_A0_MEM_INDEXr_CLR(r) (r).mem_index[0] = 0
#define BCM53600_A0_MEM_INDEXr_SET(r,d) (r).mem_index[0] = d
#define BCM53600_A0_MEM_INDEXr_GET(r) (r).mem_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_INDEXr_INDEXf_GET(r) (((r).mem_index[0]) & 0xff)
#define BCM53600_A0_MEM_INDEXr_INDEXf_SET(r,f) (r).mem_index[0]=(((r).mem_index[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MEM_INDEX.
 *
 */
#define BCM53600_A0_READ_MEM_INDEXr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_INDEXr,(r._mem_index),1)
#define BCM53600_A0_WRITE_MEM_INDEXr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_INDEXr,&(r._mem_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_INDEXr BCM53600_A0_MEM_INDEXr
#define MEM_INDEXr_SIZE BCM53600_A0_MEM_INDEXr_SIZE
typedef BCM53600_A0_MEM_INDEXr_t MEM_INDEXr_t;
#define MEM_INDEXr_CLR BCM53600_A0_MEM_INDEXr_CLR
#define MEM_INDEXr_SET BCM53600_A0_MEM_INDEXr_SET
#define MEM_INDEXr_GET BCM53600_A0_MEM_INDEXr_GET
#define MEM_INDEXr_INDEXf_GET BCM53600_A0_MEM_INDEXr_INDEXf_GET
#define MEM_INDEXr_INDEXf_SET BCM53600_A0_MEM_INDEXr_INDEXf_SET
#define READ_MEM_INDEXr BCM53600_A0_READ_MEM_INDEXr
#define WRITE_MEM_INDEXr BCM53600_A0_WRITE_MEM_INDEXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_INDEXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_0
 * BLOCKS:   SYS
 * DESC:     Memory Key 0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_0r 0x00000880

#define BCM53600_A0_MEM_KEY_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_0.
 *
 */
typedef union BCM53600_A0_MEM_KEY_0r_s {
	uint32_t v[2];
	uint32_t mem_key_0[2];
	uint32_t _mem_key_0;
} BCM53600_A0_MEM_KEY_0r_t;

#define BCM53600_A0_MEM_KEY_0r_CLR(r) CDK_MEMSET(&((r)._mem_key_0), 0, sizeof(BCM53600_A0_MEM_KEY_0r_t))
#define BCM53600_A0_MEM_KEY_0r_SET(r,i,d) (r).mem_key_0[i] = d
#define BCM53600_A0_MEM_KEY_0r_GET(r,i) (r).mem_key_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_0r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_0,0,63,a)
#define BCM53600_A0_MEM_KEY_0r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_0,0,63,a)

/*
 * These macros can be used to access MEM_KEY_0.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_0r,(r._mem_key_0),8)
#define BCM53600_A0_WRITE_MEM_KEY_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_0r,&(r._mem_key_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_0r BCM53600_A0_MEM_KEY_0r
#define MEM_KEY_0r_SIZE BCM53600_A0_MEM_KEY_0r_SIZE
typedef BCM53600_A0_MEM_KEY_0r_t MEM_KEY_0r_t;
#define MEM_KEY_0r_CLR BCM53600_A0_MEM_KEY_0r_CLR
#define MEM_KEY_0r_SET BCM53600_A0_MEM_KEY_0r_SET
#define MEM_KEY_0r_GET BCM53600_A0_MEM_KEY_0r_GET
#define MEM_KEY_0r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_0r_MEM_KEYf_GET
#define MEM_KEY_0r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_0r_MEM_KEYf_SET
#define READ_MEM_KEY_0r BCM53600_A0_READ_MEM_KEY_0r
#define WRITE_MEM_KEY_0r BCM53600_A0_WRITE_MEM_KEY_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_1
 * BLOCKS:   SYS
 * DESC:     Memory Key 1 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_1r 0x00000888

#define BCM53600_A0_MEM_KEY_1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_1.
 *
 */
typedef union BCM53600_A0_MEM_KEY_1r_s {
	uint32_t v[2];
	uint32_t mem_key_1[2];
	uint32_t _mem_key_1;
} BCM53600_A0_MEM_KEY_1r_t;

#define BCM53600_A0_MEM_KEY_1r_CLR(r) CDK_MEMSET(&((r)._mem_key_1), 0, sizeof(BCM53600_A0_MEM_KEY_1r_t))
#define BCM53600_A0_MEM_KEY_1r_SET(r,i,d) (r).mem_key_1[i] = d
#define BCM53600_A0_MEM_KEY_1r_GET(r,i) (r).mem_key_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_1r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_1,0,63,a)
#define BCM53600_A0_MEM_KEY_1r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_1,0,63,a)

/*
 * These macros can be used to access MEM_KEY_1.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_1r,(r._mem_key_1),8)
#define BCM53600_A0_WRITE_MEM_KEY_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_1r,&(r._mem_key_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_1r BCM53600_A0_MEM_KEY_1r
#define MEM_KEY_1r_SIZE BCM53600_A0_MEM_KEY_1r_SIZE
typedef BCM53600_A0_MEM_KEY_1r_t MEM_KEY_1r_t;
#define MEM_KEY_1r_CLR BCM53600_A0_MEM_KEY_1r_CLR
#define MEM_KEY_1r_SET BCM53600_A0_MEM_KEY_1r_SET
#define MEM_KEY_1r_GET BCM53600_A0_MEM_KEY_1r_GET
#define MEM_KEY_1r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_1r_MEM_KEYf_GET
#define MEM_KEY_1r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_1r_MEM_KEYf_SET
#define READ_MEM_KEY_1r BCM53600_A0_READ_MEM_KEY_1r
#define WRITE_MEM_KEY_1r BCM53600_A0_WRITE_MEM_KEY_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_2
 * BLOCKS:   SYS
 * DESC:     Memory Key 2 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_2r 0x00000890

#define BCM53600_A0_MEM_KEY_2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_2.
 *
 */
typedef union BCM53600_A0_MEM_KEY_2r_s {
	uint32_t v[2];
	uint32_t mem_key_2[2];
	uint32_t _mem_key_2;
} BCM53600_A0_MEM_KEY_2r_t;

#define BCM53600_A0_MEM_KEY_2r_CLR(r) CDK_MEMSET(&((r)._mem_key_2), 0, sizeof(BCM53600_A0_MEM_KEY_2r_t))
#define BCM53600_A0_MEM_KEY_2r_SET(r,i,d) (r).mem_key_2[i] = d
#define BCM53600_A0_MEM_KEY_2r_GET(r,i) (r).mem_key_2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_2r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_2,0,63,a)
#define BCM53600_A0_MEM_KEY_2r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_2,0,63,a)

/*
 * These macros can be used to access MEM_KEY_2.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_2r,(r._mem_key_2),8)
#define BCM53600_A0_WRITE_MEM_KEY_2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_2r,&(r._mem_key_2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_2r BCM53600_A0_MEM_KEY_2r
#define MEM_KEY_2r_SIZE BCM53600_A0_MEM_KEY_2r_SIZE
typedef BCM53600_A0_MEM_KEY_2r_t MEM_KEY_2r_t;
#define MEM_KEY_2r_CLR BCM53600_A0_MEM_KEY_2r_CLR
#define MEM_KEY_2r_SET BCM53600_A0_MEM_KEY_2r_SET
#define MEM_KEY_2r_GET BCM53600_A0_MEM_KEY_2r_GET
#define MEM_KEY_2r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_2r_MEM_KEYf_GET
#define MEM_KEY_2r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_2r_MEM_KEYf_SET
#define READ_MEM_KEY_2r BCM53600_A0_READ_MEM_KEY_2r
#define WRITE_MEM_KEY_2r BCM53600_A0_WRITE_MEM_KEY_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_3
 * BLOCKS:   SYS
 * DESC:     Memory Key 3 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_3r 0x00000898

#define BCM53600_A0_MEM_KEY_3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_3.
 *
 */
typedef union BCM53600_A0_MEM_KEY_3r_s {
	uint32_t v[2];
	uint32_t mem_key_3[2];
	uint32_t _mem_key_3;
} BCM53600_A0_MEM_KEY_3r_t;

#define BCM53600_A0_MEM_KEY_3r_CLR(r) CDK_MEMSET(&((r)._mem_key_3), 0, sizeof(BCM53600_A0_MEM_KEY_3r_t))
#define BCM53600_A0_MEM_KEY_3r_SET(r,i,d) (r).mem_key_3[i] = d
#define BCM53600_A0_MEM_KEY_3r_GET(r,i) (r).mem_key_3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_3r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_3,0,63,a)
#define BCM53600_A0_MEM_KEY_3r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_3,0,63,a)

/*
 * These macros can be used to access MEM_KEY_3.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_3r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_3r,(r._mem_key_3),8)
#define BCM53600_A0_WRITE_MEM_KEY_3r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_3r,&(r._mem_key_3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_3r BCM53600_A0_MEM_KEY_3r
#define MEM_KEY_3r_SIZE BCM53600_A0_MEM_KEY_3r_SIZE
typedef BCM53600_A0_MEM_KEY_3r_t MEM_KEY_3r_t;
#define MEM_KEY_3r_CLR BCM53600_A0_MEM_KEY_3r_CLR
#define MEM_KEY_3r_SET BCM53600_A0_MEM_KEY_3r_SET
#define MEM_KEY_3r_GET BCM53600_A0_MEM_KEY_3r_GET
#define MEM_KEY_3r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_3r_MEM_KEYf_GET
#define MEM_KEY_3r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_3r_MEM_KEYf_SET
#define READ_MEM_KEY_3r BCM53600_A0_READ_MEM_KEY_3r
#define WRITE_MEM_KEY_3r BCM53600_A0_WRITE_MEM_KEY_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_4
 * BLOCKS:   SYS
 * DESC:     Memory Key 4 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_4r 0x000008a0

#define BCM53600_A0_MEM_KEY_4r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_4.
 *
 */
typedef union BCM53600_A0_MEM_KEY_4r_s {
	uint32_t v[2];
	uint32_t mem_key_4[2];
	uint32_t _mem_key_4;
} BCM53600_A0_MEM_KEY_4r_t;

#define BCM53600_A0_MEM_KEY_4r_CLR(r) CDK_MEMSET(&((r)._mem_key_4), 0, sizeof(BCM53600_A0_MEM_KEY_4r_t))
#define BCM53600_A0_MEM_KEY_4r_SET(r,i,d) (r).mem_key_4[i] = d
#define BCM53600_A0_MEM_KEY_4r_GET(r,i) (r).mem_key_4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_4r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_4,0,63,a)
#define BCM53600_A0_MEM_KEY_4r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_4,0,63,a)

/*
 * These macros can be used to access MEM_KEY_4.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_4r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_4r,(r._mem_key_4),8)
#define BCM53600_A0_WRITE_MEM_KEY_4r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_4r,&(r._mem_key_4),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_4r BCM53600_A0_MEM_KEY_4r
#define MEM_KEY_4r_SIZE BCM53600_A0_MEM_KEY_4r_SIZE
typedef BCM53600_A0_MEM_KEY_4r_t MEM_KEY_4r_t;
#define MEM_KEY_4r_CLR BCM53600_A0_MEM_KEY_4r_CLR
#define MEM_KEY_4r_SET BCM53600_A0_MEM_KEY_4r_SET
#define MEM_KEY_4r_GET BCM53600_A0_MEM_KEY_4r_GET
#define MEM_KEY_4r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_4r_MEM_KEYf_GET
#define MEM_KEY_4r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_4r_MEM_KEYf_SET
#define READ_MEM_KEY_4r BCM53600_A0_READ_MEM_KEY_4r
#define WRITE_MEM_KEY_4r BCM53600_A0_WRITE_MEM_KEY_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_5
 * BLOCKS:   SYS
 * DESC:     Memory Key 5 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_5r 0x000008a8

#define BCM53600_A0_MEM_KEY_5r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_5.
 *
 */
typedef union BCM53600_A0_MEM_KEY_5r_s {
	uint32_t v[2];
	uint32_t mem_key_5[2];
	uint32_t _mem_key_5;
} BCM53600_A0_MEM_KEY_5r_t;

#define BCM53600_A0_MEM_KEY_5r_CLR(r) CDK_MEMSET(&((r)._mem_key_5), 0, sizeof(BCM53600_A0_MEM_KEY_5r_t))
#define BCM53600_A0_MEM_KEY_5r_SET(r,i,d) (r).mem_key_5[i] = d
#define BCM53600_A0_MEM_KEY_5r_GET(r,i) (r).mem_key_5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_5r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_5,0,63,a)
#define BCM53600_A0_MEM_KEY_5r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_5,0,63,a)

/*
 * These macros can be used to access MEM_KEY_5.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_5r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_5r,(r._mem_key_5),8)
#define BCM53600_A0_WRITE_MEM_KEY_5r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_5r,&(r._mem_key_5),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_5r BCM53600_A0_MEM_KEY_5r
#define MEM_KEY_5r_SIZE BCM53600_A0_MEM_KEY_5r_SIZE
typedef BCM53600_A0_MEM_KEY_5r_t MEM_KEY_5r_t;
#define MEM_KEY_5r_CLR BCM53600_A0_MEM_KEY_5r_CLR
#define MEM_KEY_5r_SET BCM53600_A0_MEM_KEY_5r_SET
#define MEM_KEY_5r_GET BCM53600_A0_MEM_KEY_5r_GET
#define MEM_KEY_5r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_5r_MEM_KEYf_GET
#define MEM_KEY_5r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_5r_MEM_KEYf_SET
#define READ_MEM_KEY_5r BCM53600_A0_READ_MEM_KEY_5r
#define WRITE_MEM_KEY_5r BCM53600_A0_WRITE_MEM_KEY_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_6
 * BLOCKS:   SYS
 * DESC:     Memory Key 6 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_6r 0x000008b0

#define BCM53600_A0_MEM_KEY_6r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_6.
 *
 */
typedef union BCM53600_A0_MEM_KEY_6r_s {
	uint32_t v[2];
	uint32_t mem_key_6[2];
	uint32_t _mem_key_6;
} BCM53600_A0_MEM_KEY_6r_t;

#define BCM53600_A0_MEM_KEY_6r_CLR(r) CDK_MEMSET(&((r)._mem_key_6), 0, sizeof(BCM53600_A0_MEM_KEY_6r_t))
#define BCM53600_A0_MEM_KEY_6r_SET(r,i,d) (r).mem_key_6[i] = d
#define BCM53600_A0_MEM_KEY_6r_GET(r,i) (r).mem_key_6[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_6r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_6,0,63,a)
#define BCM53600_A0_MEM_KEY_6r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_6,0,63,a)

/*
 * These macros can be used to access MEM_KEY_6.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_6r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_6r,(r._mem_key_6),8)
#define BCM53600_A0_WRITE_MEM_KEY_6r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_6r,&(r._mem_key_6),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_6r BCM53600_A0_MEM_KEY_6r
#define MEM_KEY_6r_SIZE BCM53600_A0_MEM_KEY_6r_SIZE
typedef BCM53600_A0_MEM_KEY_6r_t MEM_KEY_6r_t;
#define MEM_KEY_6r_CLR BCM53600_A0_MEM_KEY_6r_CLR
#define MEM_KEY_6r_SET BCM53600_A0_MEM_KEY_6r_SET
#define MEM_KEY_6r_GET BCM53600_A0_MEM_KEY_6r_GET
#define MEM_KEY_6r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_6r_MEM_KEYf_GET
#define MEM_KEY_6r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_6r_MEM_KEYf_SET
#define READ_MEM_KEY_6r BCM53600_A0_READ_MEM_KEY_6r
#define WRITE_MEM_KEY_6r BCM53600_A0_WRITE_MEM_KEY_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_KEY_7
 * BLOCKS:   SYS
 * DESC:     Memory Key 6 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_KEY          Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_KEY_7r 0x000008b8

#define BCM53600_A0_MEM_KEY_7r_SIZE 8

/*
 * This structure should be used to declare and program MEM_KEY_7.
 *
 */
typedef union BCM53600_A0_MEM_KEY_7r_s {
	uint32_t v[2];
	uint32_t mem_key_7[2];
	uint32_t _mem_key_7;
} BCM53600_A0_MEM_KEY_7r_t;

#define BCM53600_A0_MEM_KEY_7r_CLR(r) CDK_MEMSET(&((r)._mem_key_7), 0, sizeof(BCM53600_A0_MEM_KEY_7r_t))
#define BCM53600_A0_MEM_KEY_7r_SET(r,i,d) (r).mem_key_7[i] = d
#define BCM53600_A0_MEM_KEY_7r_GET(r,i) (r).mem_key_7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_KEY_7r_MEM_KEYf_GET(r,a) cdk_field_get((r).mem_key_7,0,63,a)
#define BCM53600_A0_MEM_KEY_7r_MEM_KEYf_SET(r,a) cdk_field_set((r).mem_key_7,0,63,a)

/*
 * These macros can be used to access MEM_KEY_7.
 *
 */
#define BCM53600_A0_READ_MEM_KEY_7r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_KEY_7r,(r._mem_key_7),8)
#define BCM53600_A0_WRITE_MEM_KEY_7r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_KEY_7r,&(r._mem_key_7),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_KEY_7r BCM53600_A0_MEM_KEY_7r
#define MEM_KEY_7r_SIZE BCM53600_A0_MEM_KEY_7r_SIZE
typedef BCM53600_A0_MEM_KEY_7r_t MEM_KEY_7r_t;
#define MEM_KEY_7r_CLR BCM53600_A0_MEM_KEY_7r_CLR
#define MEM_KEY_7r_SET BCM53600_A0_MEM_KEY_7r_SET
#define MEM_KEY_7r_GET BCM53600_A0_MEM_KEY_7r_GET
#define MEM_KEY_7r_MEM_KEYf_GET BCM53600_A0_MEM_KEY_7r_MEM_KEYf_GET
#define MEM_KEY_7r_MEM_KEYf_SET BCM53600_A0_MEM_KEY_7r_MEM_KEYf_SET
#define READ_MEM_KEY_7r BCM53600_A0_READ_MEM_KEY_7r
#define WRITE_MEM_KEY_7r BCM53600_A0_WRITE_MEM_KEY_7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_KEY_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_SRCH_ADDR_0
 * BLOCKS:   SYS
 * DESC:     Memory Addres/Offset Index Register
 * SIZE:     16
 * FIELDS:
 *     MEM_SRCH_ADDR_OFFSET Memory Addres/Offset.
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_SRCH_ADDR_0r 0x00000710

#define BCM53600_A0_MEM_SRCH_ADDR_0r_SIZE 2

/*
 * This structure should be used to declare and program MEM_SRCH_ADDR_0.
 *
 */
typedef union BCM53600_A0_MEM_SRCH_ADDR_0r_s {
	uint32_t v[1];
	uint32_t mem_srch_addr_0[1];
	uint32_t _mem_srch_addr_0;
} BCM53600_A0_MEM_SRCH_ADDR_0r_t;

#define BCM53600_A0_MEM_SRCH_ADDR_0r_CLR(r) (r).mem_srch_addr_0[0] = 0
#define BCM53600_A0_MEM_SRCH_ADDR_0r_SET(r,d) (r).mem_srch_addr_0[0] = d
#define BCM53600_A0_MEM_SRCH_ADDR_0r_GET(r) (r).mem_srch_addr_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_SRCH_ADDR_0r_MEM_SRCH_ADDR_OFFSETf_GET(r) (((r).mem_srch_addr_0[0]) & 0xffff)
#define BCM53600_A0_MEM_SRCH_ADDR_0r_MEM_SRCH_ADDR_OFFSETf_SET(r,f) (r).mem_srch_addr_0[0]=(((r).mem_srch_addr_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_SRCH_ADDR_0.
 *
 */
#define BCM53600_A0_READ_MEM_SRCH_ADDR_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_SRCH_ADDR_0r,(r._mem_srch_addr_0),2)
#define BCM53600_A0_WRITE_MEM_SRCH_ADDR_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_SRCH_ADDR_0r,&(r._mem_srch_addr_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_SRCH_ADDR_0r BCM53600_A0_MEM_SRCH_ADDR_0r
#define MEM_SRCH_ADDR_0r_SIZE BCM53600_A0_MEM_SRCH_ADDR_0r_SIZE
typedef BCM53600_A0_MEM_SRCH_ADDR_0r_t MEM_SRCH_ADDR_0r_t;
#define MEM_SRCH_ADDR_0r_CLR BCM53600_A0_MEM_SRCH_ADDR_0r_CLR
#define MEM_SRCH_ADDR_0r_SET BCM53600_A0_MEM_SRCH_ADDR_0r_SET
#define MEM_SRCH_ADDR_0r_GET BCM53600_A0_MEM_SRCH_ADDR_0r_GET
#define MEM_SRCH_ADDR_0r_MEM_SRCH_ADDR_OFFSETf_GET BCM53600_A0_MEM_SRCH_ADDR_0r_MEM_SRCH_ADDR_OFFSETf_GET
#define MEM_SRCH_ADDR_0r_MEM_SRCH_ADDR_OFFSETf_SET BCM53600_A0_MEM_SRCH_ADDR_0r_MEM_SRCH_ADDR_OFFSETf_SET
#define READ_MEM_SRCH_ADDR_0r BCM53600_A0_READ_MEM_SRCH_ADDR_0r
#define WRITE_MEM_SRCH_ADDR_0r BCM53600_A0_WRITE_MEM_SRCH_ADDR_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_SRCH_ADDR_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_SRCH_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Control Register
 * SIZE:     8
 * FIELDS:
 *     MEM_SRCH_OP_CMD  6'b000101 = Search operation.
 *     MEM_SRCH_OP_VALID The result of the operation is valid.
 *     MEM_SRCH_STDN    Start/Done Command
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_SRCH_CTRLr 0x00000708

#define BCM53600_A0_MEM_SRCH_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_SRCH_CTRL.
 *
 */
typedef union BCM53600_A0_MEM_SRCH_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_srch_ctrl[1];
	uint32_t _mem_srch_ctrl;
} BCM53600_A0_MEM_SRCH_CTRLr_t;

#define BCM53600_A0_MEM_SRCH_CTRLr_CLR(r) (r).mem_srch_ctrl[0] = 0
#define BCM53600_A0_MEM_SRCH_CTRLr_SET(r,d) (r).mem_srch_ctrl[0] = d
#define BCM53600_A0_MEM_SRCH_CTRLr_GET(r) (r).mem_srch_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_CMDf_GET(r) (((r).mem_srch_ctrl[0]) & 0x3f)
#define BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_CMDf_SET(r,f) (r).mem_srch_ctrl[0]=(((r).mem_srch_ctrl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_VALIDf_GET(r) ((((r).mem_srch_ctrl[0]) >> 6) & 0x1)
#define BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_VALIDf_SET(r,f) (r).mem_srch_ctrl[0]=(((r).mem_srch_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_STDNf_GET(r) ((((r).mem_srch_ctrl[0]) >> 7) & 0x1)
#define BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_STDNf_SET(r,f) (r).mem_srch_ctrl[0]=(((r).mem_srch_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MEM_SRCH_CTRL.
 *
 */
#define BCM53600_A0_READ_MEM_SRCH_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_SRCH_CTRLr,(r._mem_srch_ctrl),1)
#define BCM53600_A0_WRITE_MEM_SRCH_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_SRCH_CTRLr,&(r._mem_srch_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_SRCH_CTRLr BCM53600_A0_MEM_SRCH_CTRLr
#define MEM_SRCH_CTRLr_SIZE BCM53600_A0_MEM_SRCH_CTRLr_SIZE
typedef BCM53600_A0_MEM_SRCH_CTRLr_t MEM_SRCH_CTRLr_t;
#define MEM_SRCH_CTRLr_CLR BCM53600_A0_MEM_SRCH_CTRLr_CLR
#define MEM_SRCH_CTRLr_SET BCM53600_A0_MEM_SRCH_CTRLr_SET
#define MEM_SRCH_CTRLr_GET BCM53600_A0_MEM_SRCH_CTRLr_GET
#define MEM_SRCH_CTRLr_MEM_SRCH_OP_CMDf_GET BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_CMDf_GET
#define MEM_SRCH_CTRLr_MEM_SRCH_OP_CMDf_SET BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_CMDf_SET
#define MEM_SRCH_CTRLr_MEM_SRCH_OP_VALIDf_GET BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_VALIDf_GET
#define MEM_SRCH_CTRLr_MEM_SRCH_OP_VALIDf_SET BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_OP_VALIDf_SET
#define MEM_SRCH_CTRLr_MEM_SRCH_STDNf_GET BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_STDNf_GET
#define MEM_SRCH_CTRLr_MEM_SRCH_STDNf_SET BCM53600_A0_MEM_SRCH_CTRLr_MEM_SRCH_STDNf_SET
#define READ_MEM_SRCH_CTRLr BCM53600_A0_READ_MEM_SRCH_CTRLr
#define WRITE_MEM_SRCH_CTRLr BCM53600_A0_WRITE_MEM_SRCH_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_SRCH_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_SRCH_DATA_0
 * BLOCKS:   SYS
 * DESC:     Memory Data 0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_SRCH_DATA    Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_SRCH_DATA_0r 0x00000720

#define BCM53600_A0_MEM_SRCH_DATA_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_SRCH_DATA_0.
 *
 */
typedef union BCM53600_A0_MEM_SRCH_DATA_0r_s {
	uint32_t v[2];
	uint32_t mem_srch_data_0[2];
	uint32_t _mem_srch_data_0;
} BCM53600_A0_MEM_SRCH_DATA_0r_t;

#define BCM53600_A0_MEM_SRCH_DATA_0r_CLR(r) CDK_MEMSET(&((r)._mem_srch_data_0), 0, sizeof(BCM53600_A0_MEM_SRCH_DATA_0r_t))
#define BCM53600_A0_MEM_SRCH_DATA_0r_SET(r,i,d) (r).mem_srch_data_0[i] = d
#define BCM53600_A0_MEM_SRCH_DATA_0r_GET(r,i) (r).mem_srch_data_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_SRCH_DATA_0r_MEM_SRCH_DATAf_GET(r,a) cdk_field_get((r).mem_srch_data_0,0,63,a)
#define BCM53600_A0_MEM_SRCH_DATA_0r_MEM_SRCH_DATAf_SET(r,a) cdk_field_set((r).mem_srch_data_0,0,63,a)

/*
 * These macros can be used to access MEM_SRCH_DATA_0.
 *
 */
#define BCM53600_A0_READ_MEM_SRCH_DATA_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_SRCH_DATA_0r,(r._mem_srch_data_0),8)
#define BCM53600_A0_WRITE_MEM_SRCH_DATA_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_SRCH_DATA_0r,&(r._mem_srch_data_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_SRCH_DATA_0r BCM53600_A0_MEM_SRCH_DATA_0r
#define MEM_SRCH_DATA_0r_SIZE BCM53600_A0_MEM_SRCH_DATA_0r_SIZE
typedef BCM53600_A0_MEM_SRCH_DATA_0r_t MEM_SRCH_DATA_0r_t;
#define MEM_SRCH_DATA_0r_CLR BCM53600_A0_MEM_SRCH_DATA_0r_CLR
#define MEM_SRCH_DATA_0r_SET BCM53600_A0_MEM_SRCH_DATA_0r_SET
#define MEM_SRCH_DATA_0r_GET BCM53600_A0_MEM_SRCH_DATA_0r_GET
#define MEM_SRCH_DATA_0r_MEM_SRCH_DATAf_GET BCM53600_A0_MEM_SRCH_DATA_0r_MEM_SRCH_DATAf_GET
#define MEM_SRCH_DATA_0r_MEM_SRCH_DATAf_SET BCM53600_A0_MEM_SRCH_DATA_0r_MEM_SRCH_DATAf_SET
#define READ_MEM_SRCH_DATA_0r BCM53600_A0_READ_MEM_SRCH_DATA_0r
#define WRITE_MEM_SRCH_DATA_0r BCM53600_A0_WRITE_MEM_SRCH_DATA_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_SRCH_DATA_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_SRCH_DATA_1
 * BLOCKS:   SYS
 * DESC:     Memory Data 1 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_SRCH_DATA    Memory data information.NOTE: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_SRCH_DATA_1r 0x00000728

#define BCM53600_A0_MEM_SRCH_DATA_1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_SRCH_DATA_1.
 *
 */
typedef union BCM53600_A0_MEM_SRCH_DATA_1r_s {
	uint32_t v[2];
	uint32_t mem_srch_data_1[2];
	uint32_t _mem_srch_data_1;
} BCM53600_A0_MEM_SRCH_DATA_1r_t;

#define BCM53600_A0_MEM_SRCH_DATA_1r_CLR(r) CDK_MEMSET(&((r)._mem_srch_data_1), 0, sizeof(BCM53600_A0_MEM_SRCH_DATA_1r_t))
#define BCM53600_A0_MEM_SRCH_DATA_1r_SET(r,i,d) (r).mem_srch_data_1[i] = d
#define BCM53600_A0_MEM_SRCH_DATA_1r_GET(r,i) (r).mem_srch_data_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_SRCH_DATA_1r_MEM_SRCH_DATAf_GET(r,a) cdk_field_get((r).mem_srch_data_1,0,63,a)
#define BCM53600_A0_MEM_SRCH_DATA_1r_MEM_SRCH_DATAf_SET(r,a) cdk_field_set((r).mem_srch_data_1,0,63,a)

/*
 * These macros can be used to access MEM_SRCH_DATA_1.
 *
 */
#define BCM53600_A0_READ_MEM_SRCH_DATA_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_SRCH_DATA_1r,(r._mem_srch_data_1),8)
#define BCM53600_A0_WRITE_MEM_SRCH_DATA_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_SRCH_DATA_1r,&(r._mem_srch_data_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_SRCH_DATA_1r BCM53600_A0_MEM_SRCH_DATA_1r
#define MEM_SRCH_DATA_1r_SIZE BCM53600_A0_MEM_SRCH_DATA_1r_SIZE
typedef BCM53600_A0_MEM_SRCH_DATA_1r_t MEM_SRCH_DATA_1r_t;
#define MEM_SRCH_DATA_1r_CLR BCM53600_A0_MEM_SRCH_DATA_1r_CLR
#define MEM_SRCH_DATA_1r_SET BCM53600_A0_MEM_SRCH_DATA_1r_SET
#define MEM_SRCH_DATA_1r_GET BCM53600_A0_MEM_SRCH_DATA_1r_GET
#define MEM_SRCH_DATA_1r_MEM_SRCH_DATAf_GET BCM53600_A0_MEM_SRCH_DATA_1r_MEM_SRCH_DATAf_GET
#define MEM_SRCH_DATA_1r_MEM_SRCH_DATAf_SET BCM53600_A0_MEM_SRCH_DATA_1r_MEM_SRCH_DATAf_SET
#define READ_MEM_SRCH_DATA_1r BCM53600_A0_READ_MEM_SRCH_DATA_1r
#define WRITE_MEM_SRCH_DATA_1r BCM53600_A0_WRITE_MEM_SRCH_DATA_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_SRCH_DATA_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_SRCH_INDEX
 * BLOCKS:   SYS
 * DESC:     Memory/Table Index Register
 * SIZE:     8
 * FIELDS:
 *     INDEX            The 8 bit memory-table index8'h01 = ARL Table
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_SRCH_INDEXr 0x00000700

#define BCM53600_A0_MEM_SRCH_INDEXr_SIZE 1

/*
 * This structure should be used to declare and program MEM_SRCH_INDEX.
 *
 */
typedef union BCM53600_A0_MEM_SRCH_INDEXr_s {
	uint32_t v[1];
	uint32_t mem_srch_index[1];
	uint32_t _mem_srch_index;
} BCM53600_A0_MEM_SRCH_INDEXr_t;

#define BCM53600_A0_MEM_SRCH_INDEXr_CLR(r) (r).mem_srch_index[0] = 0
#define BCM53600_A0_MEM_SRCH_INDEXr_SET(r,d) (r).mem_srch_index[0] = d
#define BCM53600_A0_MEM_SRCH_INDEXr_GET(r) (r).mem_srch_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_SRCH_INDEXr_INDEXf_GET(r) (((r).mem_srch_index[0]) & 0xff)
#define BCM53600_A0_MEM_SRCH_INDEXr_INDEXf_SET(r,f) (r).mem_srch_index[0]=(((r).mem_srch_index[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MEM_SRCH_INDEX.
 *
 */
#define BCM53600_A0_READ_MEM_SRCH_INDEXr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_SRCH_INDEXr,(r._mem_srch_index),1)
#define BCM53600_A0_WRITE_MEM_SRCH_INDEXr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_SRCH_INDEXr,&(r._mem_srch_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_SRCH_INDEXr BCM53600_A0_MEM_SRCH_INDEXr
#define MEM_SRCH_INDEXr_SIZE BCM53600_A0_MEM_SRCH_INDEXr_SIZE
typedef BCM53600_A0_MEM_SRCH_INDEXr_t MEM_SRCH_INDEXr_t;
#define MEM_SRCH_INDEXr_CLR BCM53600_A0_MEM_SRCH_INDEXr_CLR
#define MEM_SRCH_INDEXr_SET BCM53600_A0_MEM_SRCH_INDEXr_SET
#define MEM_SRCH_INDEXr_GET BCM53600_A0_MEM_SRCH_INDEXr_GET
#define MEM_SRCH_INDEXr_INDEXf_GET BCM53600_A0_MEM_SRCH_INDEXr_INDEXf_GET
#define MEM_SRCH_INDEXr_INDEXf_SET BCM53600_A0_MEM_SRCH_INDEXr_INDEXf_SET
#define READ_MEM_SRCH_INDEXr BCM53600_A0_READ_MEM_SRCH_INDEXr
#define WRITE_MEM_SRCH_INDEXr BCM53600_A0_WRITE_MEM_SRCH_INDEXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_SRCH_INDEXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_SRCH_KEY_2
 * BLOCKS:   SYS
 * DESC:     Memory Key 2 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_SRCH_KEY_2   Memory key information.Note: refer to MemoryAccess
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_SRCH_KEY_2r 0x00000790

#define BCM53600_A0_MEM_SRCH_KEY_2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_SRCH_KEY_2.
 *
 */
typedef union BCM53600_A0_MEM_SRCH_KEY_2r_s {
	uint32_t v[2];
	uint32_t mem_srch_key_2[2];
	uint32_t _mem_srch_key_2;
} BCM53600_A0_MEM_SRCH_KEY_2r_t;

#define BCM53600_A0_MEM_SRCH_KEY_2r_CLR(r) CDK_MEMSET(&((r)._mem_srch_key_2), 0, sizeof(BCM53600_A0_MEM_SRCH_KEY_2r_t))
#define BCM53600_A0_MEM_SRCH_KEY_2r_SET(r,i,d) (r).mem_srch_key_2[i] = d
#define BCM53600_A0_MEM_SRCH_KEY_2r_GET(r,i) (r).mem_srch_key_2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_SRCH_KEY_2r_MEM_SRCH_KEY_2f_GET(r,a) cdk_field_get((r).mem_srch_key_2,0,63,a)
#define BCM53600_A0_MEM_SRCH_KEY_2r_MEM_SRCH_KEY_2f_SET(r,a) cdk_field_set((r).mem_srch_key_2,0,63,a)

/*
 * These macros can be used to access MEM_SRCH_KEY_2.
 *
 */
#define BCM53600_A0_READ_MEM_SRCH_KEY_2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_SRCH_KEY_2r,(r._mem_srch_key_2),8)
#define BCM53600_A0_WRITE_MEM_SRCH_KEY_2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_SRCH_KEY_2r,&(r._mem_srch_key_2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_SRCH_KEY_2r BCM53600_A0_MEM_SRCH_KEY_2r
#define MEM_SRCH_KEY_2r_SIZE BCM53600_A0_MEM_SRCH_KEY_2r_SIZE
typedef BCM53600_A0_MEM_SRCH_KEY_2r_t MEM_SRCH_KEY_2r_t;
#define MEM_SRCH_KEY_2r_CLR BCM53600_A0_MEM_SRCH_KEY_2r_CLR
#define MEM_SRCH_KEY_2r_SET BCM53600_A0_MEM_SRCH_KEY_2r_SET
#define MEM_SRCH_KEY_2r_GET BCM53600_A0_MEM_SRCH_KEY_2r_GET
#define MEM_SRCH_KEY_2r_MEM_SRCH_KEY_2f_GET BCM53600_A0_MEM_SRCH_KEY_2r_MEM_SRCH_KEY_2f_GET
#define MEM_SRCH_KEY_2r_MEM_SRCH_KEY_2f_SET BCM53600_A0_MEM_SRCH_KEY_2r_MEM_SRCH_KEY_2f_SET
#define READ_MEM_SRCH_KEY_2r BCM53600_A0_READ_MEM_SRCH_KEY_2r
#define WRITE_MEM_SRCH_KEY_2r BCM53600_A0_WRITE_MEM_SRCH_KEY_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_SRCH_KEY_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_TEST_CTRL_0
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register 0(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     AT_TM            TM control[7:0] for ARL.(Not2Release)
 *     CFP_RC_TM        TM control[7:0] for CFP_CFP_CRC.(Not2Release)
 *     CFP_CNT_TM       TM control[7:0] for CFP_CNT.(Not2Release)
 *     CFP_ACT_TM       TM control[7:0] for CFP_ACT.(Not2Release)
 *     TXQ_TM           TM control[7:0] for TXQ.(Not2Release)
 *     FM_1_TM          TM control[7:0] for FM Memory 4-9(49152X31).(Not2Release)
 *     FM_0_TM          TM control[7:0] for FM Memory 0-3(49152X30).(Not2Release)
 *     BT_MEM_TM        TM control[7:0] for BT Memory.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_TEST_CTRL_0r 0x0000e200

#define BCM53600_A0_MEM_TEST_CTRL_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_TEST_CTRL_0.
 *
 */
typedef union BCM53600_A0_MEM_TEST_CTRL_0r_s {
	uint32_t v[2];
	uint32_t mem_test_ctrl_0[2];
	uint32_t _mem_test_ctrl_0;
} BCM53600_A0_MEM_TEST_CTRL_0r_t;

#define BCM53600_A0_MEM_TEST_CTRL_0r_CLR(r) CDK_MEMSET(&((r)._mem_test_ctrl_0), 0, sizeof(BCM53600_A0_MEM_TEST_CTRL_0r_t))
#define BCM53600_A0_MEM_TEST_CTRL_0r_SET(r,i,d) (r).mem_test_ctrl_0[i] = d
#define BCM53600_A0_MEM_TEST_CTRL_0r_GET(r,i) (r).mem_test_ctrl_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_TEST_CTRL_0r_AT_TMf_GET(r) (((r).mem_test_ctrl_0[0]) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_AT_TMf_SET(r,f) (r).mem_test_ctrl_0[0]=(((r).mem_test_ctrl_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_MEM_TEST_CTRL_0r_CFP_RC_TMf_GET(r) ((((r).mem_test_ctrl_0[0]) >> 8) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_CFP_RC_TMf_SET(r,f) (r).mem_test_ctrl_0[0]=(((r).mem_test_ctrl_0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_MEM_TEST_CTRL_0r_CFP_CNT_TMf_GET(r) ((((r).mem_test_ctrl_0[0]) >> 16) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_CFP_CNT_TMf_SET(r,f) (r).mem_test_ctrl_0[0]=(((r).mem_test_ctrl_0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_MEM_TEST_CTRL_0r_CFP_ACT_TMf_GET(r) ((((r).mem_test_ctrl_0[0]) >> 24) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_CFP_ACT_TMf_SET(r,f) (r).mem_test_ctrl_0[0]=(((r).mem_test_ctrl_0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53600_A0_MEM_TEST_CTRL_0r_TXQ_TMf_GET(r) (((r).mem_test_ctrl_0[1]) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_TXQ_TMf_SET(r,f) (r).mem_test_ctrl_0[1]=(((r).mem_test_ctrl_0[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_MEM_TEST_CTRL_0r_FM_1_TMf_GET(r) ((((r).mem_test_ctrl_0[1]) >> 8) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_FM_1_TMf_SET(r,f) (r).mem_test_ctrl_0[1]=(((r).mem_test_ctrl_0[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_MEM_TEST_CTRL_0r_FM_0_TMf_GET(r) ((((r).mem_test_ctrl_0[1]) >> 16) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_FM_0_TMf_SET(r,f) (r).mem_test_ctrl_0[1]=(((r).mem_test_ctrl_0[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_MEM_TEST_CTRL_0r_BT_MEM_TMf_GET(r) ((((r).mem_test_ctrl_0[1]) >> 24) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_0r_BT_MEM_TMf_SET(r,f) (r).mem_test_ctrl_0[1]=(((r).mem_test_ctrl_0[1] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access MEM_TEST_CTRL_0.
 *
 */
#define BCM53600_A0_READ_MEM_TEST_CTRL_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_TEST_CTRL_0r,(r._mem_test_ctrl_0),8)
#define BCM53600_A0_WRITE_MEM_TEST_CTRL_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_TEST_CTRL_0r,&(r._mem_test_ctrl_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_TEST_CTRL_0r BCM53600_A0_MEM_TEST_CTRL_0r
#define MEM_TEST_CTRL_0r_SIZE BCM53600_A0_MEM_TEST_CTRL_0r_SIZE
typedef BCM53600_A0_MEM_TEST_CTRL_0r_t MEM_TEST_CTRL_0r_t;
#define MEM_TEST_CTRL_0r_CLR BCM53600_A0_MEM_TEST_CTRL_0r_CLR
#define MEM_TEST_CTRL_0r_SET BCM53600_A0_MEM_TEST_CTRL_0r_SET
#define MEM_TEST_CTRL_0r_GET BCM53600_A0_MEM_TEST_CTRL_0r_GET
#define MEM_TEST_CTRL_0r_AT_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_AT_TMf_GET
#define MEM_TEST_CTRL_0r_AT_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_AT_TMf_SET
#define MEM_TEST_CTRL_0r_CFP_RC_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_CFP_RC_TMf_GET
#define MEM_TEST_CTRL_0r_CFP_RC_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_CFP_RC_TMf_SET
#define MEM_TEST_CTRL_0r_CFP_CNT_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_CFP_CNT_TMf_GET
#define MEM_TEST_CTRL_0r_CFP_CNT_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_CFP_CNT_TMf_SET
#define MEM_TEST_CTRL_0r_CFP_ACT_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_CFP_ACT_TMf_GET
#define MEM_TEST_CTRL_0r_CFP_ACT_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_CFP_ACT_TMf_SET
#define MEM_TEST_CTRL_0r_TXQ_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_TXQ_TMf_GET
#define MEM_TEST_CTRL_0r_TXQ_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_TXQ_TMf_SET
#define MEM_TEST_CTRL_0r_FM_1_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_FM_1_TMf_GET
#define MEM_TEST_CTRL_0r_FM_1_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_FM_1_TMf_SET
#define MEM_TEST_CTRL_0r_FM_0_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_FM_0_TMf_GET
#define MEM_TEST_CTRL_0r_FM_0_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_FM_0_TMf_SET
#define MEM_TEST_CTRL_0r_BT_MEM_TMf_GET BCM53600_A0_MEM_TEST_CTRL_0r_BT_MEM_TMf_GET
#define MEM_TEST_CTRL_0r_BT_MEM_TMf_SET BCM53600_A0_MEM_TEST_CTRL_0r_BT_MEM_TMf_SET
#define READ_MEM_TEST_CTRL_0r BCM53600_A0_READ_MEM_TEST_CTRL_0r
#define WRITE_MEM_TEST_CTRL_0r BCM53600_A0_WRITE_MEM_TEST_CTRL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_TEST_CTRL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_TEST_CTRL_1
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register 1(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     DPTC2PCP_TM      TM control[3:0] for DPTC2PCP .(Not2Release)
 *     MGVP_TM          TM control[3:0] for MGVIP.(Not2Release)
 *     VPVID_TM         TM control[3:0] for VPVID.(Not2Release)
 *     MCST_TM          TM control[3:0] for Multicast.(Not2Release)
 *     VLAN_TM          TM control[7:0] for VLAN.(Not2Release)
 *     MSTP_TM          TM control[3:0] for Multiple Spanning tree.(Not2Release)
 *     PCP2DPTC_TM      TM control[3:0] for PCP2DPTC.(Not2Release)
 *     PORTCFG_TM       TM control[3:0] for PORT_CFG.(Not2Release)
 *     IRC_TM           TM control[7:0] for IRC.(Not2Release)
 *     ERC_0_TM         TM control[7:0] for ERC_0(q01_mem~q67_mem)(32X198).(Not2Release)
 *     ERC_1_TM         TM control[7:0] for ERC_1(qt_mem)(32X65).(Not2Release)
 *     IVM_ACT_TM       TM control[3:0] for IVM ACTION.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_TEST_CTRL_1r 0x0000e208

#define BCM53600_A0_MEM_TEST_CTRL_1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_TEST_CTRL_1.
 *
 */
typedef union BCM53600_A0_MEM_TEST_CTRL_1r_s {
	uint32_t v[2];
	uint32_t mem_test_ctrl_1[2];
	uint32_t _mem_test_ctrl_1;
} BCM53600_A0_MEM_TEST_CTRL_1r_t;

#define BCM53600_A0_MEM_TEST_CTRL_1r_CLR(r) CDK_MEMSET(&((r)._mem_test_ctrl_1), 0, sizeof(BCM53600_A0_MEM_TEST_CTRL_1r_t))
#define BCM53600_A0_MEM_TEST_CTRL_1r_SET(r,i,d) (r).mem_test_ctrl_1[i] = d
#define BCM53600_A0_MEM_TEST_CTRL_1r_GET(r,i) (r).mem_test_ctrl_1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_TEST_CTRL_1r_DPTC2PCP_TMf_GET(r) (((r).mem_test_ctrl_1[0]) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_DPTC2PCP_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_MEM_TEST_CTRL_1r_MGVP_TMf_GET(r) ((((r).mem_test_ctrl_1[0]) >> 4) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_MGVP_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53600_A0_MEM_TEST_CTRL_1r_VPVID_TMf_GET(r) ((((r).mem_test_ctrl_1[0]) >> 8) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_VPVID_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53600_A0_MEM_TEST_CTRL_1r_MCST_TMf_GET(r) ((((r).mem_test_ctrl_1[0]) >> 12) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_MCST_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_MEM_TEST_CTRL_1r_VLAN_TMf_GET(r) ((((r).mem_test_ctrl_1[0]) >> 16) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_1r_VLAN_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_MEM_TEST_CTRL_1r_MSTP_TMf_GET(r) ((((r).mem_test_ctrl_1[0]) >> 24) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_MSTP_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53600_A0_MEM_TEST_CTRL_1r_PCP2DPTC_TMf_GET(r) ((((r).mem_test_ctrl_1[0]) >> 28) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_PCP2DPTC_TMf_SET(r,f) (r).mem_test_ctrl_1[0]=(((r).mem_test_ctrl_1[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53600_A0_MEM_TEST_CTRL_1r_PORTCFG_TMf_GET(r) (((r).mem_test_ctrl_1[1]) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_PORTCFG_TMf_SET(r,f) (r).mem_test_ctrl_1[1]=(((r).mem_test_ctrl_1[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_MEM_TEST_CTRL_1r_IRC_TMf_GET(r) ((((r).mem_test_ctrl_1[1]) >> 4) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_1r_IRC_TMf_SET(r,f) (r).mem_test_ctrl_1[1]=(((r).mem_test_ctrl_1[1] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))
#define BCM53600_A0_MEM_TEST_CTRL_1r_ERC_0_TMf_GET(r) ((((r).mem_test_ctrl_1[1]) >> 12) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_1r_ERC_0_TMf_SET(r,f) (r).mem_test_ctrl_1[1]=(((r).mem_test_ctrl_1[1] & ~((uint32_t)0xff << 12)) | ((((uint32_t)f) & 0xff) << 12))
#define BCM53600_A0_MEM_TEST_CTRL_1r_ERC_1_TMf_GET(r) ((((r).mem_test_ctrl_1[1]) >> 20) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_1r_ERC_1_TMf_SET(r,f) (r).mem_test_ctrl_1[1]=(((r).mem_test_ctrl_1[1] & ~((uint32_t)0xff << 20)) | ((((uint32_t)f) & 0xff) << 20))
#define BCM53600_A0_MEM_TEST_CTRL_1r_IVM_ACT_TMf_GET(r) ((((r).mem_test_ctrl_1[1]) >> 28) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_1r_IVM_ACT_TMf_SET(r,f) (r).mem_test_ctrl_1[1]=(((r).mem_test_ctrl_1[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access MEM_TEST_CTRL_1.
 *
 */
#define BCM53600_A0_READ_MEM_TEST_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_TEST_CTRL_1r,(r._mem_test_ctrl_1),8)
#define BCM53600_A0_WRITE_MEM_TEST_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_TEST_CTRL_1r,&(r._mem_test_ctrl_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_TEST_CTRL_1r BCM53600_A0_MEM_TEST_CTRL_1r
#define MEM_TEST_CTRL_1r_SIZE BCM53600_A0_MEM_TEST_CTRL_1r_SIZE
typedef BCM53600_A0_MEM_TEST_CTRL_1r_t MEM_TEST_CTRL_1r_t;
#define MEM_TEST_CTRL_1r_CLR BCM53600_A0_MEM_TEST_CTRL_1r_CLR
#define MEM_TEST_CTRL_1r_SET BCM53600_A0_MEM_TEST_CTRL_1r_SET
#define MEM_TEST_CTRL_1r_GET BCM53600_A0_MEM_TEST_CTRL_1r_GET
#define MEM_TEST_CTRL_1r_DPTC2PCP_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_DPTC2PCP_TMf_GET
#define MEM_TEST_CTRL_1r_DPTC2PCP_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_DPTC2PCP_TMf_SET
#define MEM_TEST_CTRL_1r_MGVP_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_MGVP_TMf_GET
#define MEM_TEST_CTRL_1r_MGVP_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_MGVP_TMf_SET
#define MEM_TEST_CTRL_1r_VPVID_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_VPVID_TMf_GET
#define MEM_TEST_CTRL_1r_VPVID_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_VPVID_TMf_SET
#define MEM_TEST_CTRL_1r_MCST_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_MCST_TMf_GET
#define MEM_TEST_CTRL_1r_MCST_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_MCST_TMf_SET
#define MEM_TEST_CTRL_1r_VLAN_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_VLAN_TMf_GET
#define MEM_TEST_CTRL_1r_VLAN_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_VLAN_TMf_SET
#define MEM_TEST_CTRL_1r_MSTP_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_MSTP_TMf_GET
#define MEM_TEST_CTRL_1r_MSTP_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_MSTP_TMf_SET
#define MEM_TEST_CTRL_1r_PCP2DPTC_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_PCP2DPTC_TMf_GET
#define MEM_TEST_CTRL_1r_PCP2DPTC_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_PCP2DPTC_TMf_SET
#define MEM_TEST_CTRL_1r_PORTCFG_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_PORTCFG_TMf_GET
#define MEM_TEST_CTRL_1r_PORTCFG_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_PORTCFG_TMf_SET
#define MEM_TEST_CTRL_1r_IRC_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_IRC_TMf_GET
#define MEM_TEST_CTRL_1r_IRC_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_IRC_TMf_SET
#define MEM_TEST_CTRL_1r_ERC_0_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_ERC_0_TMf_GET
#define MEM_TEST_CTRL_1r_ERC_0_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_ERC_0_TMf_SET
#define MEM_TEST_CTRL_1r_ERC_1_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_ERC_1_TMf_GET
#define MEM_TEST_CTRL_1r_ERC_1_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_ERC_1_TMf_SET
#define MEM_TEST_CTRL_1r_IVM_ACT_TMf_GET BCM53600_A0_MEM_TEST_CTRL_1r_IVM_ACT_TMf_GET
#define MEM_TEST_CTRL_1r_IVM_ACT_TMf_SET BCM53600_A0_MEM_TEST_CTRL_1r_IVM_ACT_TMf_SET
#define READ_MEM_TEST_CTRL_1r BCM53600_A0_READ_MEM_TEST_CTRL_1r
#define WRITE_MEM_TEST_CTRL_1r BCM53600_A0_WRITE_MEM_TEST_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_TEST_CTRL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_TEST_CTRL_2
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register 2(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     EVM_ACT_TM       TM control[3:0] for EVM ACTION.(Not2Release)
 *     CFP_TCAM_CHKSUM_TM TM control[3:0] for CFP TCAM Checksum.(Not2Release)
 *     IVM_EVM_TCAM_CHKSUM_TM TM control[3:0] for IVM EVM TCAM Checksum.(Not2Release)
 *     CFP_TCAM_TM      TM control[10:0] for CFP TCAM.(Not2Release)
 *     IVM_EVM_TCAM_TM  TM control[10:0] for IVM EVM TCAM.(Not2Release)
 *     BT_MCNT_TM       TM control[7:0] for bt_man.mcnt.(Not2Release)
 *     RESERVED_0       Reserved
 *     BT_MPTR_TM       TM control[7:0] for bt_mam.mptr.(Not2Release)
 *     RESERVED_1       Reserved
 *     BT_DENG_TM       TM control[7:0] for bt_mam.deng.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_TEST_CTRL_2r 0x0000e210

#define BCM53600_A0_MEM_TEST_CTRL_2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_TEST_CTRL_2.
 *
 */
typedef union BCM53600_A0_MEM_TEST_CTRL_2r_s {
	uint32_t v[2];
	uint32_t mem_test_ctrl_2[2];
	uint32_t _mem_test_ctrl_2;
} BCM53600_A0_MEM_TEST_CTRL_2r_t;

#define BCM53600_A0_MEM_TEST_CTRL_2r_CLR(r) CDK_MEMSET(&((r)._mem_test_ctrl_2), 0, sizeof(BCM53600_A0_MEM_TEST_CTRL_2r_t))
#define BCM53600_A0_MEM_TEST_CTRL_2r_SET(r,i,d) (r).mem_test_ctrl_2[i] = d
#define BCM53600_A0_MEM_TEST_CTRL_2r_GET(r,i) (r).mem_test_ctrl_2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_TEST_CTRL_2r_EVM_ACT_TMf_GET(r) (((r).mem_test_ctrl_2[0]) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_2r_EVM_ACT_TMf_SET(r,f) (r).mem_test_ctrl_2[0]=(((r).mem_test_ctrl_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_CHKSUM_TMf_GET(r) ((((r).mem_test_ctrl_2[0]) >> 4) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_CHKSUM_TMf_SET(r,f) (r).mem_test_ctrl_2[0]=(((r).mem_test_ctrl_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_CHKSUM_TMf_GET(r) ((((r).mem_test_ctrl_2[0]) >> 8) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_CHKSUM_TMf_SET(r,f) (r).mem_test_ctrl_2[0]=(((r).mem_test_ctrl_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_TMf_GET(r) ((((r).mem_test_ctrl_2[0]) >> 12) & 0x7ff)
#define BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_TMf_SET(r,f) (r).mem_test_ctrl_2[0]=(((r).mem_test_ctrl_2[0] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_TMf_GET(r) cdk_field32_get((r).mem_test_ctrl_2,23,33)
#define BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_TMf_SET(r,f) cdk_field32_set((r).mem_test_ctrl_2,23,33,f)
#define BCM53600_A0_MEM_TEST_CTRL_2r_BT_MCNT_TMf_GET(r) ((((r).mem_test_ctrl_2[1]) >> 2) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_2r_BT_MCNT_TMf_SET(r,f) (r).mem_test_ctrl_2[1]=(((r).mem_test_ctrl_2[1] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_0f_GET(r) ((((r).mem_test_ctrl_2[1]) >> 10) & 0x7)
#define BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_0f_SET(r,f) (r).mem_test_ctrl_2[1]=(((r).mem_test_ctrl_2[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53600_A0_MEM_TEST_CTRL_2r_BT_MPTR_TMf_GET(r) ((((r).mem_test_ctrl_2[1]) >> 13) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_2r_BT_MPTR_TMf_SET(r,f) (r).mem_test_ctrl_2[1]=(((r).mem_test_ctrl_2[1] & ~((uint32_t)0xff << 13)) | ((((uint32_t)f) & 0xff) << 13))
#define BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_1f_GET(r) ((((r).mem_test_ctrl_2[1]) >> 21) & 0x7)
#define BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_1f_SET(r,f) (r).mem_test_ctrl_2[1]=(((r).mem_test_ctrl_2[1] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_MEM_TEST_CTRL_2r_BT_DENG_TMf_GET(r) ((((r).mem_test_ctrl_2[1]) >> 24) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_2r_BT_DENG_TMf_SET(r,f) (r).mem_test_ctrl_2[1]=(((r).mem_test_ctrl_2[1] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access MEM_TEST_CTRL_2.
 *
 */
#define BCM53600_A0_READ_MEM_TEST_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_TEST_CTRL_2r,(r._mem_test_ctrl_2),8)
#define BCM53600_A0_WRITE_MEM_TEST_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_TEST_CTRL_2r,&(r._mem_test_ctrl_2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_TEST_CTRL_2r BCM53600_A0_MEM_TEST_CTRL_2r
#define MEM_TEST_CTRL_2r_SIZE BCM53600_A0_MEM_TEST_CTRL_2r_SIZE
typedef BCM53600_A0_MEM_TEST_CTRL_2r_t MEM_TEST_CTRL_2r_t;
#define MEM_TEST_CTRL_2r_CLR BCM53600_A0_MEM_TEST_CTRL_2r_CLR
#define MEM_TEST_CTRL_2r_SET BCM53600_A0_MEM_TEST_CTRL_2r_SET
#define MEM_TEST_CTRL_2r_GET BCM53600_A0_MEM_TEST_CTRL_2r_GET
#define MEM_TEST_CTRL_2r_EVM_ACT_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_EVM_ACT_TMf_GET
#define MEM_TEST_CTRL_2r_EVM_ACT_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_EVM_ACT_TMf_SET
#define MEM_TEST_CTRL_2r_CFP_TCAM_CHKSUM_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_CHKSUM_TMf_GET
#define MEM_TEST_CTRL_2r_CFP_TCAM_CHKSUM_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_CHKSUM_TMf_SET
#define MEM_TEST_CTRL_2r_IVM_EVM_TCAM_CHKSUM_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_CHKSUM_TMf_GET
#define MEM_TEST_CTRL_2r_IVM_EVM_TCAM_CHKSUM_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_CHKSUM_TMf_SET
#define MEM_TEST_CTRL_2r_CFP_TCAM_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_TMf_GET
#define MEM_TEST_CTRL_2r_CFP_TCAM_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_CFP_TCAM_TMf_SET
#define MEM_TEST_CTRL_2r_IVM_EVM_TCAM_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_TMf_GET
#define MEM_TEST_CTRL_2r_IVM_EVM_TCAM_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_IVM_EVM_TCAM_TMf_SET
#define MEM_TEST_CTRL_2r_BT_MCNT_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_BT_MCNT_TMf_GET
#define MEM_TEST_CTRL_2r_BT_MCNT_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_BT_MCNT_TMf_SET
#define MEM_TEST_CTRL_2r_RESERVED_0f_GET BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_0f_GET
#define MEM_TEST_CTRL_2r_RESERVED_0f_SET BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_0f_SET
#define MEM_TEST_CTRL_2r_BT_MPTR_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_BT_MPTR_TMf_GET
#define MEM_TEST_CTRL_2r_BT_MPTR_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_BT_MPTR_TMf_SET
#define MEM_TEST_CTRL_2r_RESERVED_1f_GET BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_1f_GET
#define MEM_TEST_CTRL_2r_RESERVED_1f_SET BCM53600_A0_MEM_TEST_CTRL_2r_RESERVED_1f_SET
#define MEM_TEST_CTRL_2r_BT_DENG_TMf_GET BCM53600_A0_MEM_TEST_CTRL_2r_BT_DENG_TMf_GET
#define MEM_TEST_CTRL_2r_BT_DENG_TMf_SET BCM53600_A0_MEM_TEST_CTRL_2r_BT_DENG_TMf_SET
#define READ_MEM_TEST_CTRL_2r BCM53600_A0_READ_MEM_TEST_CTRL_2r
#define WRITE_MEM_TEST_CTRL_2r BCM53600_A0_WRITE_MEM_TEST_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_TEST_CTRL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MEM_TEST_CTRL_3
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register 3(Not2Release)
 * SIZE:     64
 * FIELDS:
 *     CFP_ERC_TM       TM control[7:0] for CFP_ERC.(Not2Release)
 *     TX_TS_DATA_TM    TM control[7:0] for TX TimeStamp Data.(Not2Release)
 *     DPTC2DSCP_TM     TM control[3:0] for DPTC2DSCP.(Not2Release)
 *     DSCP2DPTC_TM     TM control[3:0] for DSCP2DPTC.(Not2Release)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MEM_TEST_CTRL_3r 0x0000e218

#define BCM53600_A0_MEM_TEST_CTRL_3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_TEST_CTRL_3.
 *
 */
typedef union BCM53600_A0_MEM_TEST_CTRL_3r_s {
	uint32_t v[2];
	uint32_t mem_test_ctrl_3[2];
	uint32_t _mem_test_ctrl_3;
} BCM53600_A0_MEM_TEST_CTRL_3r_t;

#define BCM53600_A0_MEM_TEST_CTRL_3r_CLR(r) CDK_MEMSET(&((r)._mem_test_ctrl_3), 0, sizeof(BCM53600_A0_MEM_TEST_CTRL_3r_t))
#define BCM53600_A0_MEM_TEST_CTRL_3r_SET(r,i,d) (r).mem_test_ctrl_3[i] = d
#define BCM53600_A0_MEM_TEST_CTRL_3r_GET(r,i) (r).mem_test_ctrl_3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MEM_TEST_CTRL_3r_CFP_ERC_TMf_GET(r) (((r).mem_test_ctrl_3[0]) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_3r_CFP_ERC_TMf_SET(r,f) (r).mem_test_ctrl_3[0]=(((r).mem_test_ctrl_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_MEM_TEST_CTRL_3r_TX_TS_DATA_TMf_GET(r) ((((r).mem_test_ctrl_3[0]) >> 8) & 0xff)
#define BCM53600_A0_MEM_TEST_CTRL_3r_TX_TS_DATA_TMf_SET(r,f) (r).mem_test_ctrl_3[0]=(((r).mem_test_ctrl_3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_MEM_TEST_CTRL_3r_DPTC2DSCP_TMf_GET(r) ((((r).mem_test_ctrl_3[0]) >> 16) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_3r_DPTC2DSCP_TMf_SET(r,f) (r).mem_test_ctrl_3[0]=(((r).mem_test_ctrl_3[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53600_A0_MEM_TEST_CTRL_3r_DSCP2DPTC_TMf_GET(r) ((((r).mem_test_ctrl_3[0]) >> 20) & 0xf)
#define BCM53600_A0_MEM_TEST_CTRL_3r_DSCP2DPTC_TMf_SET(r,f) (r).mem_test_ctrl_3[0]=(((r).mem_test_ctrl_3[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53600_A0_MEM_TEST_CTRL_3r_RESERVEDf_GET(r,a) cdk_field_get((r).mem_test_ctrl_3,24,63,a)
#define BCM53600_A0_MEM_TEST_CTRL_3r_RESERVEDf_SET(r,a) cdk_field_set((r).mem_test_ctrl_3,24,63,a)

/*
 * These macros can be used to access MEM_TEST_CTRL_3.
 *
 */
#define BCM53600_A0_READ_MEM_TEST_CTRL_3r(u,r) cdk_robo_reg_read(u,BCM53600_A0_MEM_TEST_CTRL_3r,(r._mem_test_ctrl_3),8)
#define BCM53600_A0_WRITE_MEM_TEST_CTRL_3r(u,r) cdk_robo_reg_write(u,BCM53600_A0_MEM_TEST_CTRL_3r,&(r._mem_test_ctrl_3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_TEST_CTRL_3r BCM53600_A0_MEM_TEST_CTRL_3r
#define MEM_TEST_CTRL_3r_SIZE BCM53600_A0_MEM_TEST_CTRL_3r_SIZE
typedef BCM53600_A0_MEM_TEST_CTRL_3r_t MEM_TEST_CTRL_3r_t;
#define MEM_TEST_CTRL_3r_CLR BCM53600_A0_MEM_TEST_CTRL_3r_CLR
#define MEM_TEST_CTRL_3r_SET BCM53600_A0_MEM_TEST_CTRL_3r_SET
#define MEM_TEST_CTRL_3r_GET BCM53600_A0_MEM_TEST_CTRL_3r_GET
#define MEM_TEST_CTRL_3r_CFP_ERC_TMf_GET BCM53600_A0_MEM_TEST_CTRL_3r_CFP_ERC_TMf_GET
#define MEM_TEST_CTRL_3r_CFP_ERC_TMf_SET BCM53600_A0_MEM_TEST_CTRL_3r_CFP_ERC_TMf_SET
#define MEM_TEST_CTRL_3r_TX_TS_DATA_TMf_GET BCM53600_A0_MEM_TEST_CTRL_3r_TX_TS_DATA_TMf_GET
#define MEM_TEST_CTRL_3r_TX_TS_DATA_TMf_SET BCM53600_A0_MEM_TEST_CTRL_3r_TX_TS_DATA_TMf_SET
#define MEM_TEST_CTRL_3r_DPTC2DSCP_TMf_GET BCM53600_A0_MEM_TEST_CTRL_3r_DPTC2DSCP_TMf_GET
#define MEM_TEST_CTRL_3r_DPTC2DSCP_TMf_SET BCM53600_A0_MEM_TEST_CTRL_3r_DPTC2DSCP_TMf_SET
#define MEM_TEST_CTRL_3r_DSCP2DPTC_TMf_GET BCM53600_A0_MEM_TEST_CTRL_3r_DSCP2DPTC_TMf_GET
#define MEM_TEST_CTRL_3r_DSCP2DPTC_TMf_SET BCM53600_A0_MEM_TEST_CTRL_3r_DSCP2DPTC_TMf_SET
#define MEM_TEST_CTRL_3r_RESERVEDf_GET BCM53600_A0_MEM_TEST_CTRL_3r_RESERVEDf_GET
#define MEM_TEST_CTRL_3r_RESERVEDf_SET BCM53600_A0_MEM_TEST_CTRL_3r_RESERVEDf_SET
#define READ_MEM_TEST_CTRL_3r BCM53600_A0_READ_MEM_TEST_CTRL_3r
#define WRITE_MEM_TEST_CTRL_3r BCM53600_A0_WRITE_MEM_TEST_CTRL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MEM_TEST_CTRL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIBKILLOVR
 * BLOCKS:   SYS
 * DESC:     MIB Kill Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     MEM_DAT_VID      When set this register to 3Ch, all MIB counters will be disable.When set this register to Non-3Ch, all MIB counters will be enable.The register can be written once only.Note : Not to release this register to customers(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MIBKILLOVRr 0x000008e0

#define BCM53600_A0_MIBKILLOVRr_SIZE 1

/*
 * This structure should be used to declare and program MIBKILLOVR.
 *
 */
typedef union BCM53600_A0_MIBKILLOVRr_s {
	uint32_t v[1];
	uint32_t mibkillovr[1];
	uint32_t _mibkillovr;
} BCM53600_A0_MIBKILLOVRr_t;

#define BCM53600_A0_MIBKILLOVRr_CLR(r) (r).mibkillovr[0] = 0
#define BCM53600_A0_MIBKILLOVRr_SET(r,d) (r).mibkillovr[0] = d
#define BCM53600_A0_MIBKILLOVRr_GET(r) (r).mibkillovr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIBKILLOVRr_MEM_DAT_VIDf_GET(r) (((r).mibkillovr[0]) & 0xff)
#define BCM53600_A0_MIBKILLOVRr_MEM_DAT_VIDf_SET(r,f) (r).mibkillovr[0]=(((r).mibkillovr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIBKILLOVR.
 *
 */
#define BCM53600_A0_READ_MIBKILLOVRr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MIBKILLOVRr,(r._mibkillovr),1)
#define BCM53600_A0_WRITE_MIBKILLOVRr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MIBKILLOVRr,&(r._mibkillovr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIBKILLOVRr BCM53600_A0_MIBKILLOVRr
#define MIBKILLOVRr_SIZE BCM53600_A0_MIBKILLOVRr_SIZE
typedef BCM53600_A0_MIBKILLOVRr_t MIBKILLOVRr_t;
#define MIBKILLOVRr_CLR BCM53600_A0_MIBKILLOVRr_CLR
#define MIBKILLOVRr_SET BCM53600_A0_MIBKILLOVRr_SET
#define MIBKILLOVRr_GET BCM53600_A0_MIBKILLOVRr_GET
#define MIBKILLOVRr_MEM_DAT_VIDf_GET BCM53600_A0_MIBKILLOVRr_MEM_DAT_VIDf_GET
#define MIBKILLOVRr_MEM_DAT_VIDf_SET BCM53600_A0_MIBKILLOVRr_MEM_DAT_VIDf_SET
#define READ_MIBKILLOVRr BCM53600_A0_READ_MIBKILLOVRr
#define WRITE_MIBKILLOVRr BCM53600_A0_WRITE_MIBKILLOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIBKILLOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIB_PORT_SEL
 * BLOCKS:   SYS
 * DESC:     MIB Port Select Register
 * SIZE:     8
 * FIELDS:
 *     MIB_PORT         Port mumber for MIB selection
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MIB_PORT_SELr 0x00005000

#define BCM53600_A0_MIB_PORT_SELr_SIZE 1

/*
 * This structure should be used to declare and program MIB_PORT_SEL.
 *
 */
typedef union BCM53600_A0_MIB_PORT_SELr_s {
	uint32_t v[1];
	uint32_t mib_port_sel[1];
	uint32_t _mib_port_sel;
} BCM53600_A0_MIB_PORT_SELr_t;

#define BCM53600_A0_MIB_PORT_SELr_CLR(r) (r).mib_port_sel[0] = 0
#define BCM53600_A0_MIB_PORT_SELr_SET(r,d) (r).mib_port_sel[0] = d
#define BCM53600_A0_MIB_PORT_SELr_GET(r) (r).mib_port_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIB_PORT_SELr_MIB_PORTf_GET(r) (((r).mib_port_sel[0]) & 0x1f)
#define BCM53600_A0_MIB_PORT_SELr_MIB_PORTf_SET(r,f) (r).mib_port_sel[0]=(((r).mib_port_sel[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_MIB_PORT_SELr_RESERVED_0f_GET(r) ((((r).mib_port_sel[0]) >> 5) & 0x1)
#define BCM53600_A0_MIB_PORT_SELr_RESERVED_0f_SET(r,f) (r).mib_port_sel[0]=(((r).mib_port_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MIB_PORT_SELr_RESERVED_1f_GET(r) ((((r).mib_port_sel[0]) >> 6) & 0x3)
#define BCM53600_A0_MIB_PORT_SELr_RESERVED_1f_SET(r,f) (r).mib_port_sel[0]=(((r).mib_port_sel[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MIB_PORT_SEL.
 *
 */
#define BCM53600_A0_READ_MIB_PORT_SELr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MIB_PORT_SELr,(r._mib_port_sel),1)
#define BCM53600_A0_WRITE_MIB_PORT_SELr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MIB_PORT_SELr,&(r._mib_port_sel),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_PORT_SELr BCM53600_A0_MIB_PORT_SELr
#define MIB_PORT_SELr_SIZE BCM53600_A0_MIB_PORT_SELr_SIZE
typedef BCM53600_A0_MIB_PORT_SELr_t MIB_PORT_SELr_t;
#define MIB_PORT_SELr_CLR BCM53600_A0_MIB_PORT_SELr_CLR
#define MIB_PORT_SELr_SET BCM53600_A0_MIB_PORT_SELr_SET
#define MIB_PORT_SELr_GET BCM53600_A0_MIB_PORT_SELr_GET
#define MIB_PORT_SELr_MIB_PORTf_GET BCM53600_A0_MIB_PORT_SELr_MIB_PORTf_GET
#define MIB_PORT_SELr_MIB_PORTf_SET BCM53600_A0_MIB_PORT_SELr_MIB_PORTf_SET
#define MIB_PORT_SELr_RESERVED_0f_GET BCM53600_A0_MIB_PORT_SELr_RESERVED_0f_GET
#define MIB_PORT_SELr_RESERVED_0f_SET BCM53600_A0_MIB_PORT_SELr_RESERVED_0f_SET
#define MIB_PORT_SELr_RESERVED_1f_GET BCM53600_A0_MIB_PORT_SELr_RESERVED_1f_GET
#define MIB_PORT_SELr_RESERVED_1f_SET BCM53600_A0_MIB_PORT_SELr_RESERVED_1f_SET
#define READ_MIB_PORT_SELr BCM53600_A0_READ_MIB_PORT_SELr
#define WRITE_MIB_PORT_SELr BCM53600_A0_WRITE_MIB_PORT_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIB_PORT_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Control Register
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     RESERVED         Reserved
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDN    Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 *
 ******************************************************************************/
#define BCM53600_A0_MIB_SNAPSHOT_CTLr 0x00005002

#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 *
 */
typedef union BCM53600_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM53600_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM53600_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0x1f)
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDNf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDNf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 *
 */
#define BCM53600_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM53600_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM53600_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM53600_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM53600_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM53600_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM53600_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM53600_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_GET BCM53600_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_SET BCM53600_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDNf_GET BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDNf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDNf_SET BCM53600_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDNf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM53600_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM53600_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIB_SNAPSHOT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIICTL
 * BLOCKS:   EPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     DUPLEX_MOD       1'b1: Full Duplex.1'b0: Half Duplex.
 *     RE_AN            1'b1: Restart Auto-Negotiation process.1'b0: Normal operation.
 *     ISOLATE          1'b1: Electrically isolate PHY from MII 0.1'b0: Normal operation.
 *     RESERVED_1       Ignore when read.
 *     AN_EN            1'b1: Auto-Negotiation Enable.1'b0: Auto-Negotiation disable.
 *     F_SPD_SEL        1'b1: 100 Mbps1'b0: 10 Mbps.
 *     LOOPBACK         1'b1: Loopback mode.1'b0: Normal operation.
 *     RESET            1'b1: PHY reset.1'b0: Normal operation.
 *
 ******************************************************************************/
#define BCM53600_A0_MIICTLr 0x0000a000

#define BCM53600_A0_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program MIICTL.
 *
 */
typedef union BCM53600_A0_MIICTLr_s {
	uint32_t v[1];
	uint32_t miictl[1];
	uint32_t _miictl;
} BCM53600_A0_MIICTLr_t;

#define BCM53600_A0_MIICTLr_CLR(r) (r).miictl[0] = 0
#define BCM53600_A0_MIICTLr_SET(r,d) (r).miictl[0] = d
#define BCM53600_A0_MIICTLr_GET(r) (r).miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIICTLr_RESERVEDf_GET(r) (((r).miictl[0]) & 0xff)
#define BCM53600_A0_MIICTLr_RESERVEDf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_MIICTLr_DUPLEX_MODf_GET(r) ((((r).miictl[0]) >> 8) & 0x1)
#define BCM53600_A0_MIICTLr_DUPLEX_MODf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_MIICTLr_RE_ANf_GET(r) ((((r).miictl[0]) >> 9) & 0x1)
#define BCM53600_A0_MIICTLr_RE_ANf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_MIICTLr_ISOLATEf_GET(r) ((((r).miictl[0]) >> 10) & 0x1)
#define BCM53600_A0_MIICTLr_ISOLATEf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_MIICTLr_RESERVED_1f_GET(r) ((((r).miictl[0]) >> 11) & 0x1)
#define BCM53600_A0_MIICTLr_RESERVED_1f_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_MIICTLr_AN_ENf_GET(r) ((((r).miictl[0]) >> 12) & 0x1)
#define BCM53600_A0_MIICTLr_AN_ENf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_MIICTLr_F_SPD_SELf_GET(r) ((((r).miictl[0]) >> 13) & 0x1)
#define BCM53600_A0_MIICTLr_F_SPD_SELf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_MIICTLr_LOOPBACKf_GET(r) ((((r).miictl[0]) >> 14) & 0x1)
#define BCM53600_A0_MIICTLr_LOOPBACKf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_MIICTLr_RESETf_GET(r) ((((r).miictl[0]) >> 15) & 0x1)
#define BCM53600_A0_MIICTLr_RESETf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIICTL.
 *
 */
#define BCM53600_A0_READ_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_MIICTLr,(r._miictl),2)
#define BCM53600_A0_WRITE_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_MIICTLr,&(r._miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIICTLr BCM53600_A0_MIICTLr
#define MIICTLr_SIZE BCM53600_A0_MIICTLr_SIZE
typedef BCM53600_A0_MIICTLr_t MIICTLr_t;
#define MIICTLr_CLR BCM53600_A0_MIICTLr_CLR
#define MIICTLr_SET BCM53600_A0_MIICTLr_SET
#define MIICTLr_GET BCM53600_A0_MIICTLr_GET
#define MIICTLr_RESERVEDf_GET BCM53600_A0_MIICTLr_RESERVEDf_GET
#define MIICTLr_RESERVEDf_SET BCM53600_A0_MIICTLr_RESERVEDf_SET
#define MIICTLr_DUPLEX_MODf_GET BCM53600_A0_MIICTLr_DUPLEX_MODf_GET
#define MIICTLr_DUPLEX_MODf_SET BCM53600_A0_MIICTLr_DUPLEX_MODf_SET
#define MIICTLr_RE_ANf_GET BCM53600_A0_MIICTLr_RE_ANf_GET
#define MIICTLr_RE_ANf_SET BCM53600_A0_MIICTLr_RE_ANf_SET
#define MIICTLr_ISOLATEf_GET BCM53600_A0_MIICTLr_ISOLATEf_GET
#define MIICTLr_ISOLATEf_SET BCM53600_A0_MIICTLr_ISOLATEf_SET
#define MIICTLr_RESERVED_1f_GET BCM53600_A0_MIICTLr_RESERVED_1f_GET
#define MIICTLr_RESERVED_1f_SET BCM53600_A0_MIICTLr_RESERVED_1f_SET
#define MIICTLr_AN_ENf_GET BCM53600_A0_MIICTLr_AN_ENf_GET
#define MIICTLr_AN_ENf_SET BCM53600_A0_MIICTLr_AN_ENf_SET
#define MIICTLr_F_SPD_SELf_GET BCM53600_A0_MIICTLr_F_SPD_SELf_GET
#define MIICTLr_F_SPD_SELf_SET BCM53600_A0_MIICTLr_F_SPD_SELf_SET
#define MIICTLr_LOOPBACKf_GET BCM53600_A0_MIICTLr_LOOPBACKf_GET
#define MIICTLr_LOOPBACKf_SET BCM53600_A0_MIICTLr_LOOPBACKf_SET
#define MIICTLr_RESETf_GET BCM53600_A0_MIICTLr_RESETf_GET
#define MIICTLr_RESETf_SET BCM53600_A0_MIICTLr_RESETf_SET
#define READ_MIICTLr BCM53600_A0_READ_MIICTLr
#define WRITE_MIICTLr BCM53600_A0_WRITE_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIISTS
 * BLOCKS:   EPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = Extended register capabe.
 *     JABBER_DET       1 = jabber condition detected.0 = no jabber condition detected.
 *     LINK_STA         1 = link is up(link pass state).0 = link is down(link fail state).
 *     AUTO_NEGO_CAP    1 = Auto-negotiation capable.0 = not auto-negotiation capable.
 *     RESERVED_1       Ignore when read.
 *     AUTO_NEGO_COMP   1 = Auto-negotiation process completed.0 = Auto-negotiation process not completed.
 *     MF_PRE_SUP       1 = Preamble may be suppressed.0 = Preamble always required.
 *     RESERVED         Reserved
 *     B10T_CAP         1 = 10BASE-T half-duplex capable.
 *     B10T_FDX_CAP     1 = 10BASE-T full-duplex capable.
 *     B100TX_CAP       1 = 100BASE-TX half-duplex capable.
 *     B100TX_FDX_CAP   1 = 100BASE-TX full-duplex capable.
 *     B100T4_CAP       0 = Not 100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM53600_A0_MIISTSr 0x0000a002

#define BCM53600_A0_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program MIISTS.
 *
 */
typedef union BCM53600_A0_MIISTSr_s {
	uint32_t v[1];
	uint32_t miists[1];
	uint32_t _miists;
} BCM53600_A0_MIISTSr_t;

#define BCM53600_A0_MIISTSr_CLR(r) (r).miists[0] = 0
#define BCM53600_A0_MIISTSr_SET(r,d) (r).miists[0] = d
#define BCM53600_A0_MIISTSr_GET(r) (r).miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIISTSr_EXT_CAPf_GET(r) (((r).miists[0]) & 0x1)
#define BCM53600_A0_MIISTSr_EXT_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_MIISTSr_JABBER_DETf_GET(r) ((((r).miists[0]) >> 1) & 0x1)
#define BCM53600_A0_MIISTSr_JABBER_DETf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_MIISTSr_LINK_STAf_GET(r) ((((r).miists[0]) >> 2) & 0x1)
#define BCM53600_A0_MIISTSr_LINK_STAf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).miists[0]) >> 3) & 0x1)
#define BCM53600_A0_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_MIISTSr_RESERVED_1f_GET(r) ((((r).miists[0]) >> 4) & 0x1)
#define BCM53600_A0_MIISTSr_RESERVED_1f_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).miists[0]) >> 5) & 0x1)
#define BCM53600_A0_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).miists[0]) >> 6) & 0x1)
#define BCM53600_A0_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MIISTSr_RESERVEDf_GET(r) ((((r).miists[0]) >> 7) & 0xf)
#define BCM53600_A0_MIISTSr_RESERVEDf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53600_A0_MIISTSr_B10T_CAPf_GET(r) ((((r).miists[0]) >> 11) & 0x1)
#define BCM53600_A0_MIISTSr_B10T_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).miists[0]) >> 12) & 0x1)
#define BCM53600_A0_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_MIISTSr_B100TX_CAPf_GET(r) ((((r).miists[0]) >> 13) & 0x1)
#define BCM53600_A0_MIISTSr_B100TX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).miists[0]) >> 14) & 0x1)
#define BCM53600_A0_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_MIISTSr_B100T4_CAPf_GET(r) ((((r).miists[0]) >> 15) & 0x1)
#define BCM53600_A0_MIISTSr_B100T4_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIISTS.
 *
 */
#define BCM53600_A0_READ_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_MIISTSr,(r._miists),2)
#define BCM53600_A0_WRITE_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_MIISTSr,&(r._miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIISTSr BCM53600_A0_MIISTSr
#define MIISTSr_SIZE BCM53600_A0_MIISTSr_SIZE
typedef BCM53600_A0_MIISTSr_t MIISTSr_t;
#define MIISTSr_CLR BCM53600_A0_MIISTSr_CLR
#define MIISTSr_SET BCM53600_A0_MIISTSr_SET
#define MIISTSr_GET BCM53600_A0_MIISTSr_GET
#define MIISTSr_EXT_CAPf_GET BCM53600_A0_MIISTSr_EXT_CAPf_GET
#define MIISTSr_EXT_CAPf_SET BCM53600_A0_MIISTSr_EXT_CAPf_SET
#define MIISTSr_JABBER_DETf_GET BCM53600_A0_MIISTSr_JABBER_DETf_GET
#define MIISTSr_JABBER_DETf_SET BCM53600_A0_MIISTSr_JABBER_DETf_SET
#define MIISTSr_LINK_STAf_GET BCM53600_A0_MIISTSr_LINK_STAf_GET
#define MIISTSr_LINK_STAf_SET BCM53600_A0_MIISTSr_LINK_STAf_SET
#define MIISTSr_AUTO_NEGO_CAPf_GET BCM53600_A0_MIISTSr_AUTO_NEGO_CAPf_GET
#define MIISTSr_AUTO_NEGO_CAPf_SET BCM53600_A0_MIISTSr_AUTO_NEGO_CAPf_SET
#define MIISTSr_RESERVED_1f_GET BCM53600_A0_MIISTSr_RESERVED_1f_GET
#define MIISTSr_RESERVED_1f_SET BCM53600_A0_MIISTSr_RESERVED_1f_SET
#define MIISTSr_AUTO_NEGO_COMPf_GET BCM53600_A0_MIISTSr_AUTO_NEGO_COMPf_GET
#define MIISTSr_AUTO_NEGO_COMPf_SET BCM53600_A0_MIISTSr_AUTO_NEGO_COMPf_SET
#define MIISTSr_MF_PRE_SUPf_GET BCM53600_A0_MIISTSr_MF_PRE_SUPf_GET
#define MIISTSr_MF_PRE_SUPf_SET BCM53600_A0_MIISTSr_MF_PRE_SUPf_SET
#define MIISTSr_RESERVEDf_GET BCM53600_A0_MIISTSr_RESERVEDf_GET
#define MIISTSr_RESERVEDf_SET BCM53600_A0_MIISTSr_RESERVEDf_SET
#define MIISTSr_B10T_CAPf_GET BCM53600_A0_MIISTSr_B10T_CAPf_GET
#define MIISTSr_B10T_CAPf_SET BCM53600_A0_MIISTSr_B10T_CAPf_SET
#define MIISTSr_B10T_FDX_CAPf_GET BCM53600_A0_MIISTSr_B10T_FDX_CAPf_GET
#define MIISTSr_B10T_FDX_CAPf_SET BCM53600_A0_MIISTSr_B10T_FDX_CAPf_SET
#define MIISTSr_B100TX_CAPf_GET BCM53600_A0_MIISTSr_B100TX_CAPf_GET
#define MIISTSr_B100TX_CAPf_SET BCM53600_A0_MIISTSr_B100TX_CAPf_SET
#define MIISTSr_B100TX_FDX_CAPf_GET BCM53600_A0_MIISTSr_B100TX_FDX_CAPf_GET
#define MIISTSr_B100TX_FDX_CAPf_SET BCM53600_A0_MIISTSr_B100TX_FDX_CAPf_SET
#define MIISTSr_B100T4_CAPf_GET BCM53600_A0_MIISTSr_B100T4_CAPf_GET
#define MIISTSr_B100T4_CAPf_SET BCM53600_A0_MIISTSr_B100T4_CAPf_SET
#define READ_MIISTSr BCM53600_A0_READ_MIISTSr
#define WRITE_MIISTSr BCM53600_A0_WRITE_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIN_TCP_HEADER_SIZE
 * BLOCKS:   SYS
 * DESC:     Minimum TCP Header Size Register
 * SIZE:     8
 * FIELDS:
 *     MIN_TCP_HDR_SIZE MIN_TCP_Header_Size is programable between 0 and 255 bytes, inclusive.The default value is set to 20 bytes(TCP header without options).
 *
 ******************************************************************************/
#define BCM53600_A0_MIN_TCP_HEADER_SIZEr 0x00002c22

#define BCM53600_A0_MIN_TCP_HEADER_SIZEr_SIZE 1

/*
 * This structure should be used to declare and program MIN_TCP_HEADER_SIZE.
 *
 */
typedef union BCM53600_A0_MIN_TCP_HEADER_SIZEr_s {
	uint32_t v[1];
	uint32_t min_tcp_header_size[1];
	uint32_t _min_tcp_header_size;
} BCM53600_A0_MIN_TCP_HEADER_SIZEr_t;

#define BCM53600_A0_MIN_TCP_HEADER_SIZEr_CLR(r) (r).min_tcp_header_size[0] = 0
#define BCM53600_A0_MIN_TCP_HEADER_SIZEr_SET(r,d) (r).min_tcp_header_size[0] = d
#define BCM53600_A0_MIN_TCP_HEADER_SIZEr_GET(r) (r).min_tcp_header_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIN_TCP_HEADER_SIZEr_MIN_TCP_HDR_SIZEf_GET(r) (((r).min_tcp_header_size[0]) & 0xff)
#define BCM53600_A0_MIN_TCP_HEADER_SIZEr_MIN_TCP_HDR_SIZEf_SET(r,f) (r).min_tcp_header_size[0]=(((r).min_tcp_header_size[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIN_TCP_HEADER_SIZE.
 *
 */
#define BCM53600_A0_READ_MIN_TCP_HEADER_SIZEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MIN_TCP_HEADER_SIZEr,(r._min_tcp_header_size),1)
#define BCM53600_A0_WRITE_MIN_TCP_HEADER_SIZEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MIN_TCP_HEADER_SIZEr,&(r._min_tcp_header_size),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIN_TCP_HEADER_SIZEr BCM53600_A0_MIN_TCP_HEADER_SIZEr
#define MIN_TCP_HEADER_SIZEr_SIZE BCM53600_A0_MIN_TCP_HEADER_SIZEr_SIZE
typedef BCM53600_A0_MIN_TCP_HEADER_SIZEr_t MIN_TCP_HEADER_SIZEr_t;
#define MIN_TCP_HEADER_SIZEr_CLR BCM53600_A0_MIN_TCP_HEADER_SIZEr_CLR
#define MIN_TCP_HEADER_SIZEr_SET BCM53600_A0_MIN_TCP_HEADER_SIZEr_SET
#define MIN_TCP_HEADER_SIZEr_GET BCM53600_A0_MIN_TCP_HEADER_SIZEr_GET
#define MIN_TCP_HEADER_SIZEr_MIN_TCP_HDR_SIZEf_GET BCM53600_A0_MIN_TCP_HEADER_SIZEr_MIN_TCP_HDR_SIZEf_GET
#define MIN_TCP_HEADER_SIZEr_MIN_TCP_HDR_SIZEf_SET BCM53600_A0_MIN_TCP_HEADER_SIZEr_MIN_TCP_HDR_SIZEf_SET
#define READ_MIN_TCP_HEADER_SIZEr BCM53600_A0_READ_MIN_TCP_HEADER_SIZEr
#define WRITE_MIN_TCP_HEADER_SIZEr BCM53600_A0_WRITE_MIN_TCP_HEADER_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIN_TCP_HEADER_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     32
 * FIELDS:
 *     MIR_CAP_PORT     Mirror Capture Port.Bit mask which identifies the ports which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.Bits 0-23 = FE PortsBit 24 = MII/IMPBit 25 = Giga port G0Bit 26 = Giga port G1Bit 27 = Giga port G2Bit 28 = Giga port G3
 *     MIRCAPCTL_RSRV0  Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MIRCAPCTLr 0x00000318

#define BCM53600_A0_MIRCAPCTLr_SIZE 4

/*
 * This structure should be used to declare and program MIRCAPCTL.
 *
 */
typedef union BCM53600_A0_MIRCAPCTLr_s {
	uint32_t v[1];
	uint32_t mircapctl[1];
	uint32_t _mircapctl;
} BCM53600_A0_MIRCAPCTLr_t;

#define BCM53600_A0_MIRCAPCTLr_CLR(r) (r).mircapctl[0] = 0
#define BCM53600_A0_MIRCAPCTLr_SET(r,d) (r).mircapctl[0] = d
#define BCM53600_A0_MIRCAPCTLr_GET(r) (r).mircapctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIRCAPCTLr_MIR_CAP_PORTf_GET(r) (((r).mircapctl[0]) & 0x1fffffff)
#define BCM53600_A0_MIRCAPCTLr_MIR_CAP_PORTf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_GET(r) ((((r).mircapctl[0]) >> 29) & 0x7)
#define BCM53600_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access MIRCAPCTL.
 *
 */
#define BCM53600_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MIRCAPCTLr,(r._mircapctl),4)
#define BCM53600_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MIRCAPCTLr,&(r._mircapctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM53600_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM53600_A0_MIRCAPCTLr_SIZE
typedef BCM53600_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM53600_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM53600_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM53600_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_MIR_CAP_PORTf_GET BCM53600_A0_MIRCAPCTLr_MIR_CAP_PORTf_GET
#define MIRCAPCTLr_MIR_CAP_PORTf_SET BCM53600_A0_MIRCAPCTLr_MIR_CAP_PORTf_SET
#define MIRCAPCTLr_MIRCAPCTL_RSRV0f_GET BCM53600_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_GET
#define MIRCAPCTLr_MIRCAPCTL_RSRV0f_SET BCM53600_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_SET
#define READ_MIRCAPCTLr BCM53600_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM53600_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIRCAPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MIRRORCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1       Reserved
 *     EN_OUT_MIR_FLTR  Enable/Disable Egress Mirror Filter0: Disable Egress Mirror Filter.1: Enable Egress Mirror Filter. The frames transmitted on a port that has beenselected in the OUT_MIR_MSK, will be copied to the MIR_CAP_PORT.
 *     EN_IN_MIR_FLTR   Enable/Disable Ingress Mirror Filter.0: Disable Ingress Mirror Filter.1: Enable Ingress Mirror Filter. The frames received on a port that has beenselected in the IN_MIR_MSK, will be copied to the MIR_CAP_PORT.
 *     BLK_NOT_MIR      When enable, all traffic to MIR_CAP_PORT will be blocked except mirror traffic.(Not2Release)
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_MIRRORCTLr 0x00000310

#define BCM53600_A0_MIRRORCTLr_SIZE 1

/*
 * This structure should be used to declare and program MIRRORCTL.
 *
 */
typedef union BCM53600_A0_MIRRORCTLr_s {
	uint32_t v[1];
	uint32_t mirrorctl[1];
	uint32_t _mirrorctl;
} BCM53600_A0_MIRRORCTLr_t;

#define BCM53600_A0_MIRRORCTLr_CLR(r) (r).mirrorctl[0] = 0
#define BCM53600_A0_MIRRORCTLr_SET(r,d) (r).mirrorctl[0] = d
#define BCM53600_A0_MIRRORCTLr_GET(r) (r).mirrorctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MIRRORCTLr_RESERVED_1f_GET(r) (((r).mirrorctl[0]) & 0xf)
#define BCM53600_A0_MIRRORCTLr_RESERVED_1f_SET(r,f) (r).mirrorctl[0]=(((r).mirrorctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_MIRRORCTLr_EN_OUT_MIR_FLTRf_GET(r) ((((r).mirrorctl[0]) >> 4) & 0x1)
#define BCM53600_A0_MIRRORCTLr_EN_OUT_MIR_FLTRf_SET(r,f) (r).mirrorctl[0]=(((r).mirrorctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_MIRRORCTLr_EN_IN_MIR_FLTRf_GET(r) ((((r).mirrorctl[0]) >> 5) & 0x1)
#define BCM53600_A0_MIRRORCTLr_EN_IN_MIR_FLTRf_SET(r,f) (r).mirrorctl[0]=(((r).mirrorctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MIRRORCTLr_BLK_NOT_MIRf_GET(r) ((((r).mirrorctl[0]) >> 6) & 0x1)
#define BCM53600_A0_MIRRORCTLr_BLK_NOT_MIRf_SET(r,f) (r).mirrorctl[0]=(((r).mirrorctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MIRRORCTLr_RESERVED_0f_GET(r) ((((r).mirrorctl[0]) >> 7) & 0x1)
#define BCM53600_A0_MIRRORCTLr_RESERVED_0f_SET(r,f) (r).mirrorctl[0]=(((r).mirrorctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIRRORCTL.
 *
 */
#define BCM53600_A0_READ_MIRRORCTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MIRRORCTLr,(r._mirrorctl),1)
#define BCM53600_A0_WRITE_MIRRORCTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MIRRORCTLr,&(r._mirrorctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRRORCTLr BCM53600_A0_MIRRORCTLr
#define MIRRORCTLr_SIZE BCM53600_A0_MIRRORCTLr_SIZE
typedef BCM53600_A0_MIRRORCTLr_t MIRRORCTLr_t;
#define MIRRORCTLr_CLR BCM53600_A0_MIRRORCTLr_CLR
#define MIRRORCTLr_SET BCM53600_A0_MIRRORCTLr_SET
#define MIRRORCTLr_GET BCM53600_A0_MIRRORCTLr_GET
#define MIRRORCTLr_RESERVED_1f_GET BCM53600_A0_MIRRORCTLr_RESERVED_1f_GET
#define MIRRORCTLr_RESERVED_1f_SET BCM53600_A0_MIRRORCTLr_RESERVED_1f_SET
#define MIRRORCTLr_EN_OUT_MIR_FLTRf_GET BCM53600_A0_MIRRORCTLr_EN_OUT_MIR_FLTRf_GET
#define MIRRORCTLr_EN_OUT_MIR_FLTRf_SET BCM53600_A0_MIRRORCTLr_EN_OUT_MIR_FLTRf_SET
#define MIRRORCTLr_EN_IN_MIR_FLTRf_GET BCM53600_A0_MIRRORCTLr_EN_IN_MIR_FLTRf_GET
#define MIRRORCTLr_EN_IN_MIR_FLTRf_SET BCM53600_A0_MIRRORCTLr_EN_IN_MIR_FLTRf_SET
#define MIRRORCTLr_BLK_NOT_MIRf_GET BCM53600_A0_MIRRORCTLr_BLK_NOT_MIRf_GET
#define MIRRORCTLr_BLK_NOT_MIRf_SET BCM53600_A0_MIRRORCTLr_BLK_NOT_MIRf_SET
#define MIRRORCTLr_RESERVED_0f_GET BCM53600_A0_MIRRORCTLr_RESERVED_0f_GET
#define MIRRORCTLr_RESERVED_0f_SET BCM53600_A0_MIRRORCTLr_RESERVED_0f_SET
#define READ_MIRRORCTLr BCM53600_A0_READ_MIRRORCTLr
#define WRITE_MIRRORCTLr BCM53600_A0_WRITE_MIRRORCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MIRRORCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TOTAL_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor Total Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TOTAL_BUF_CNT Monitor Global Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr 0x00000ac4

#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TOTAL_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_total_buf_used_count[1];
	uint32_t _monitor_total_buf_used_count;
} BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_CLR(r) (r).monitor_total_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_SET(r,d) (r).monitor_total_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_GET(r) (r).monitor_total_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_MON_TOTAL_BUF_CNTf_GET(r) (((r).monitor_total_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_MON_TOTAL_BUF_CNTf_SET(r,f) (r).monitor_total_buf_used_count[0]=(((r).monitor_total_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_total_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_total_buf_used_count[0]=(((r).monitor_total_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TOTAL_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TOTAL_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr,(r._monitor_total_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TOTAL_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr,&(r._monitor_total_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TOTAL_BUF_USED_COUNTr BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr
#define MONITOR_TOTAL_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_t MONITOR_TOTAL_BUF_USED_COUNTr_t;
#define MONITOR_TOTAL_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_CLR
#define MONITOR_TOTAL_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_SET
#define MONITOR_TOTAL_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_GET
#define MONITOR_TOTAL_BUF_USED_COUNTr_MON_TOTAL_BUF_CNTf_GET BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_MON_TOTAL_BUF_CNTf_GET
#define MONITOR_TOTAL_BUF_USED_COUNTr_MON_TOTAL_BUF_CNTf_SET BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_MON_TOTAL_BUF_CNTf_SET
#define MONITOR_TOTAL_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TOTAL_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TOTAL_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TOTAL_BUF_USED_COUNTr
#define WRITE_MONITOR_TOTAL_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TOTAL_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TOTAL_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ0_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q0 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ0_BUF_CNT Monitor TXQ-Q0 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr 0x00000ada

#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ0_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq0_buf_used_count[1];
	uint32_t _monitor_txq0_buf_used_count;
} BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_CLR(r) (r).monitor_txq0_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq0_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_GET(r) (r).monitor_txq0_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_MON_TXQ0_BUF_CNTf_GET(r) (((r).monitor_txq0_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_MON_TXQ0_BUF_CNTf_SET(r,f) (r).monitor_txq0_buf_used_count[0]=(((r).monitor_txq0_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq0_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq0_buf_used_count[0]=(((r).monitor_txq0_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ0_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ0_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr,(r._monitor_txq0_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ0_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr,&(r._monitor_txq0_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ0_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr
#define MONITOR_TXQ0_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_t MONITOR_TXQ0_BUF_USED_COUNTr_t;
#define MONITOR_TXQ0_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ0_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_SET
#define MONITOR_TXQ0_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_GET
#define MONITOR_TXQ0_BUF_USED_COUNTr_MON_TXQ0_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_MON_TXQ0_BUF_CNTf_GET
#define MONITOR_TXQ0_BUF_USED_COUNTr_MON_TXQ0_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_MON_TXQ0_BUF_CNTf_SET
#define MONITOR_TXQ0_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ0_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ0_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ0_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ0_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ0_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ0_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ1_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q1 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ1_BUF_CNT Monitor TXQ-Q1 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr 0x00000adc

#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ1_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq1_buf_used_count[1];
	uint32_t _monitor_txq1_buf_used_count;
} BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_CLR(r) (r).monitor_txq1_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq1_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_GET(r) (r).monitor_txq1_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_MON_TXQ1_BUF_CNTf_GET(r) (((r).monitor_txq1_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_MON_TXQ1_BUF_CNTf_SET(r,f) (r).monitor_txq1_buf_used_count[0]=(((r).monitor_txq1_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq1_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq1_buf_used_count[0]=(((r).monitor_txq1_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ1_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ1_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr,(r._monitor_txq1_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ1_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr,&(r._monitor_txq1_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ1_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr
#define MONITOR_TXQ1_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_t MONITOR_TXQ1_BUF_USED_COUNTr_t;
#define MONITOR_TXQ1_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ1_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_SET
#define MONITOR_TXQ1_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_GET
#define MONITOR_TXQ1_BUF_USED_COUNTr_MON_TXQ1_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_MON_TXQ1_BUF_CNTf_GET
#define MONITOR_TXQ1_BUF_USED_COUNTr_MON_TXQ1_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_MON_TXQ1_BUF_CNTf_SET
#define MONITOR_TXQ1_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ1_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ1_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ1_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ1_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ1_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ1_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ2_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q2 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ2_BUF_CNT Monitor TXQ-Q2 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr 0x00000ade

#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ2_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq2_buf_used_count[1];
	uint32_t _monitor_txq2_buf_used_count;
} BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_CLR(r) (r).monitor_txq2_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq2_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_GET(r) (r).monitor_txq2_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_MON_TXQ2_BUF_CNTf_GET(r) (((r).monitor_txq2_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_MON_TXQ2_BUF_CNTf_SET(r,f) (r).monitor_txq2_buf_used_count[0]=(((r).monitor_txq2_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq2_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq2_buf_used_count[0]=(((r).monitor_txq2_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ2_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ2_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr,(r._monitor_txq2_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ2_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr,&(r._monitor_txq2_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ2_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr
#define MONITOR_TXQ2_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_t MONITOR_TXQ2_BUF_USED_COUNTr_t;
#define MONITOR_TXQ2_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ2_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_SET
#define MONITOR_TXQ2_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_GET
#define MONITOR_TXQ2_BUF_USED_COUNTr_MON_TXQ2_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_MON_TXQ2_BUF_CNTf_GET
#define MONITOR_TXQ2_BUF_USED_COUNTr_MON_TXQ2_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_MON_TXQ2_BUF_CNTf_SET
#define MONITOR_TXQ2_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ2_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ2_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ2_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ2_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ2_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ2_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ3_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q3 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ3_BUF_CNT Monitor TXQ-Q3 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr 0x00000ae0

#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ3_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq3_buf_used_count[1];
	uint32_t _monitor_txq3_buf_used_count;
} BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_CLR(r) (r).monitor_txq3_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq3_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_GET(r) (r).monitor_txq3_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_MON_TXQ3_BUF_CNTf_GET(r) (((r).monitor_txq3_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_MON_TXQ3_BUF_CNTf_SET(r,f) (r).monitor_txq3_buf_used_count[0]=(((r).monitor_txq3_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq3_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq3_buf_used_count[0]=(((r).monitor_txq3_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ3_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ3_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr,(r._monitor_txq3_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ3_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr,&(r._monitor_txq3_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ3_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr
#define MONITOR_TXQ3_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_t MONITOR_TXQ3_BUF_USED_COUNTr_t;
#define MONITOR_TXQ3_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ3_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_SET
#define MONITOR_TXQ3_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_GET
#define MONITOR_TXQ3_BUF_USED_COUNTr_MON_TXQ3_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_MON_TXQ3_BUF_CNTf_GET
#define MONITOR_TXQ3_BUF_USED_COUNTr_MON_TXQ3_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_MON_TXQ3_BUF_CNTf_SET
#define MONITOR_TXQ3_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ3_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ3_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ3_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ3_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ3_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ3_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ4_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q4 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ4_BUF_CNT Monitor TXQ-Q4 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr 0x00000ae2

#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ4_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq4_buf_used_count[1];
	uint32_t _monitor_txq4_buf_used_count;
} BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_CLR(r) (r).monitor_txq4_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq4_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_GET(r) (r).monitor_txq4_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_MON_TXQ4_BUF_CNTf_GET(r) (((r).monitor_txq4_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_MON_TXQ4_BUF_CNTf_SET(r,f) (r).monitor_txq4_buf_used_count[0]=(((r).monitor_txq4_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq4_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq4_buf_used_count[0]=(((r).monitor_txq4_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ4_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ4_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr,(r._monitor_txq4_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ4_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr,&(r._monitor_txq4_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ4_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr
#define MONITOR_TXQ4_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_t MONITOR_TXQ4_BUF_USED_COUNTr_t;
#define MONITOR_TXQ4_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ4_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_SET
#define MONITOR_TXQ4_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_GET
#define MONITOR_TXQ4_BUF_USED_COUNTr_MON_TXQ4_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_MON_TXQ4_BUF_CNTf_GET
#define MONITOR_TXQ4_BUF_USED_COUNTr_MON_TXQ4_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_MON_TXQ4_BUF_CNTf_SET
#define MONITOR_TXQ4_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ4_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ4_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ4_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ4_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ4_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ4_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ5_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q5 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ5_BUF_CNT Monitor TXQ-Q5 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr 0x00000ae4

#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ5_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq5_buf_used_count[1];
	uint32_t _monitor_txq5_buf_used_count;
} BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_CLR(r) (r).monitor_txq5_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq5_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_GET(r) (r).monitor_txq5_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_MON_TXQ5_BUF_CNTf_GET(r) (((r).monitor_txq5_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_MON_TXQ5_BUF_CNTf_SET(r,f) (r).monitor_txq5_buf_used_count[0]=(((r).monitor_txq5_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq5_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq5_buf_used_count[0]=(((r).monitor_txq5_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ5_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ5_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr,(r._monitor_txq5_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ5_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr,&(r._monitor_txq5_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ5_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr
#define MONITOR_TXQ5_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_t MONITOR_TXQ5_BUF_USED_COUNTr_t;
#define MONITOR_TXQ5_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ5_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_SET
#define MONITOR_TXQ5_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_GET
#define MONITOR_TXQ5_BUF_USED_COUNTr_MON_TXQ5_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_MON_TXQ5_BUF_CNTf_GET
#define MONITOR_TXQ5_BUF_USED_COUNTr_MON_TXQ5_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_MON_TXQ5_BUF_CNTf_SET
#define MONITOR_TXQ5_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ5_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ5_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ5_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ5_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ5_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ5_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ6_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q6 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ6_BUF_CNT Monitor TXQ-Q6 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr 0x00000ae6

#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ6_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq6_buf_used_count[1];
	uint32_t _monitor_txq6_buf_used_count;
} BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_CLR(r) (r).monitor_txq6_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq6_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_GET(r) (r).monitor_txq6_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_MON_TXQ6_BUF_CNTf_GET(r) (((r).monitor_txq6_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_MON_TXQ6_BUF_CNTf_SET(r,f) (r).monitor_txq6_buf_used_count[0]=(((r).monitor_txq6_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq6_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq6_buf_used_count[0]=(((r).monitor_txq6_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ6_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ6_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr,(r._monitor_txq6_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ6_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr,&(r._monitor_txq6_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ6_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr
#define MONITOR_TXQ6_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_t MONITOR_TXQ6_BUF_USED_COUNTr_t;
#define MONITOR_TXQ6_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ6_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_SET
#define MONITOR_TXQ6_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_GET
#define MONITOR_TXQ6_BUF_USED_COUNTr_MON_TXQ6_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_MON_TXQ6_BUF_CNTf_GET
#define MONITOR_TXQ6_BUF_USED_COUNTr_MON_TXQ6_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_MON_TXQ6_BUF_CNTf_SET
#define MONITOR_TXQ6_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ6_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ6_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ6_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ6_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ6_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ6_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TXQ7_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Monitor TXQ-Q7 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ7_BUF_CNT Monitor TXQ-Q7 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr 0x00000ae8

#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program MONITOR_TXQ7_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t monitor_txq7_buf_used_count[1];
	uint32_t _monitor_txq7_buf_used_count;
} BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_t;

#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_CLR(r) (r).monitor_txq7_buf_used_count[0] = 0
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_SET(r,d) (r).monitor_txq7_buf_used_count[0] = d
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_GET(r) (r).monitor_txq7_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_MON_TXQ7_BUF_CNTf_GET(r) (((r).monitor_txq7_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_MON_TXQ7_BUF_CNTf_SET(r,f) (r).monitor_txq7_buf_used_count[0]=(((r).monitor_txq7_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).monitor_txq7_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).monitor_txq7_buf_used_count[0]=(((r).monitor_txq7_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access MONITOR_TXQ7_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_MONITOR_TXQ7_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr,(r._monitor_txq7_buf_used_count),2)
#define BCM53600_A0_WRITE_MONITOR_TXQ7_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr,&(r._monitor_txq7_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TXQ7_BUF_USED_COUNTr BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr
#define MONITOR_TXQ7_BUF_USED_COUNTr_SIZE BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_t MONITOR_TXQ7_BUF_USED_COUNTr_t;
#define MONITOR_TXQ7_BUF_USED_COUNTr_CLR BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_CLR
#define MONITOR_TXQ7_BUF_USED_COUNTr_SET BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_SET
#define MONITOR_TXQ7_BUF_USED_COUNTr_GET BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_GET
#define MONITOR_TXQ7_BUF_USED_COUNTr_MON_TXQ7_BUF_CNTf_GET BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_MON_TXQ7_BUF_CNTf_GET
#define MONITOR_TXQ7_BUF_USED_COUNTr_MON_TXQ7_BUF_CNTf_SET BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_MON_TXQ7_BUF_CNTf_SET
#define MONITOR_TXQ7_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_RESERVEDf_GET
#define MONITOR_TXQ7_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_MONITOR_TXQ7_BUF_USED_COUNTr BCM53600_A0_READ_MONITOR_TXQ7_BUF_USED_COUNTr
#define WRITE_MONITOR_TXQ7_BUF_USED_COUNTr BCM53600_A0_WRITE_MONITOR_TXQ7_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TXQ7_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MONITOR_TX_PORT_CTRL
 * BLOCKS:   SYS
 * DESC:     Monitor TX Port Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     TX_PORT_SELECT   The monitor port ID selection for "Peak TXQ-Qn Buffer Used Count" and"Monitor TXQ-Qn Buffer Used Count".(Not2Release)
 *     RESERVED_0       Reservedf for extension(Not2Release)
 *     RESERVED_1       Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr 0x00000ac0

#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MONITOR_TX_PORT_CTRL.
 *
 */
typedef union BCM53600_A0_MONITOR_TX_PORT_CTRLr_s {
	uint32_t v[1];
	uint32_t monitor_tx_port_ctrl[1];
	uint32_t _monitor_tx_port_ctrl;
} BCM53600_A0_MONITOR_TX_PORT_CTRLr_t;

#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_CLR(r) (r).monitor_tx_port_ctrl[0] = 0
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_SET(r,d) (r).monitor_tx_port_ctrl[0] = d
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_GET(r) (r).monitor_tx_port_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_TX_PORT_SELECTf_GET(r) (((r).monitor_tx_port_ctrl[0]) & 0x1f)
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_TX_PORT_SELECTf_SET(r,f) (r).monitor_tx_port_ctrl[0]=(((r).monitor_tx_port_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_0f_GET(r) ((((r).monitor_tx_port_ctrl[0]) >> 5) & 0x1)
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_0f_SET(r,f) (r).monitor_tx_port_ctrl[0]=(((r).monitor_tx_port_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_1f_GET(r) ((((r).monitor_tx_port_ctrl[0]) >> 6) & 0x3)
#define BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_1f_SET(r,f) (r).monitor_tx_port_ctrl[0]=(((r).monitor_tx_port_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MONITOR_TX_PORT_CTRL.
 *
 */
#define BCM53600_A0_READ_MONITOR_TX_PORT_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MONITOR_TX_PORT_CTRLr,(r._monitor_tx_port_ctrl),1)
#define BCM53600_A0_WRITE_MONITOR_TX_PORT_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MONITOR_TX_PORT_CTRLr,&(r._monitor_tx_port_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MONITOR_TX_PORT_CTRLr BCM53600_A0_MONITOR_TX_PORT_CTRLr
#define MONITOR_TX_PORT_CTRLr_SIZE BCM53600_A0_MONITOR_TX_PORT_CTRLr_SIZE
typedef BCM53600_A0_MONITOR_TX_PORT_CTRLr_t MONITOR_TX_PORT_CTRLr_t;
#define MONITOR_TX_PORT_CTRLr_CLR BCM53600_A0_MONITOR_TX_PORT_CTRLr_CLR
#define MONITOR_TX_PORT_CTRLr_SET BCM53600_A0_MONITOR_TX_PORT_CTRLr_SET
#define MONITOR_TX_PORT_CTRLr_GET BCM53600_A0_MONITOR_TX_PORT_CTRLr_GET
#define MONITOR_TX_PORT_CTRLr_TX_PORT_SELECTf_GET BCM53600_A0_MONITOR_TX_PORT_CTRLr_TX_PORT_SELECTf_GET
#define MONITOR_TX_PORT_CTRLr_TX_PORT_SELECTf_SET BCM53600_A0_MONITOR_TX_PORT_CTRLr_TX_PORT_SELECTf_SET
#define MONITOR_TX_PORT_CTRLr_RESERVED_0f_GET BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_0f_GET
#define MONITOR_TX_PORT_CTRLr_RESERVED_0f_SET BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_0f_SET
#define MONITOR_TX_PORT_CTRLr_RESERVED_1f_GET BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_1f_GET
#define MONITOR_TX_PORT_CTRLr_RESERVED_1f_SET BCM53600_A0_MONITOR_TX_PORT_CTRLr_RESERVED_1f_SET
#define READ_MONITOR_TX_PORT_CTRLr BCM53600_A0_READ_MONITOR_TX_PORT_CTRLr
#define WRITE_MONITOR_TX_PORT_CTRLr BCM53600_A0_WRITE_MONITOR_TX_PORT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MONITOR_TX_PORT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  MSPT_TAB
 * BLOCKS:   SYS
 * DESC:     Multiple Spanning Tree Table
 * SIZE:     58
 * FIELDS:
 *     MSP_TREE_PORT0   Port 0 SPT status
 *     MSP_TREE_PORT1   Port 1 SPT status
 *     MSP_TREE_PORT2   Port 2 SPT status
 *     MSP_TREE_PORT3   Port 3 SPT status
 *     MSP_TREE_PORT4   Port 4 SPT status
 *     MSP_TREE_PORT5   Port 5 SPT status
 *     MSP_TREE_PORT6   Port 6 SPT status
 *     MSP_TREE_PORT7   Port 7 SPT status
 *     MSP_TREE_PORT8   Port 8 SPT status
 *     MSP_TREE_PORT9   Port 9 SPT status
 *     MSP_TREE_PORT10  Port 10 SPT status
 *     MSP_TREE_PORT11  Port 11 SPT status
 *     MSP_TREE_PORT12  Port 12 SPT status
 *     MSP_TREE_PORT13  Port 13 SPT status
 *     MSP_TREE_PORT14  Port 14 SPT status
 *     MSP_TREE_PORT15  Port 15 SPT status
 *     MSP_TREE_PORT16  Port 16 SPT status
 *     MSP_TREE_PORT17  Port 17 SPT status
 *     MSP_TREE_PORT18  Port 18 SPT status
 *     MSP_TREE_PORT19  Port 19 SPT status
 *     MSP_TREE_PORT20  Port 20 SPT status
 *     MSP_TREE_PORT21  Port 21 SPT status
 *     MSP_TREE_PORT22  Port 22 SPT status
 *     MSP_TREE_PORT23  Port 23 SPT status
 *     MSP_TREE_PORT24  Port 24 SPT status
 *     MSP_TREE_PORT25  Port 25 SPT status
 *     MSP_TREE_PORT26  Port 26 SPT status
 *     MSP_TREE_PORT27  Port 27 SPT status
 *     MSP_TREE_PORT28  Port 28 SPT status
 *
 ******************************************************************************/
#define BCM53600_A0_MSPT_TABm 0x60040800

#define BCM53600_A0_MSPT_TABm_MIN 0
#define BCM53600_A0_MSPT_TABm_MAX 255
#define BCM53600_A0_MSPT_TABm_CMAX(u) 255
#define BCM53600_A0_MSPT_TABm_SIZE 8

/*
 * This structure should be used to declare and program MSPT_TAB.
 *
 */
typedef union BCM53600_A0_MSPT_TABm_s {
	uint32_t v[2];
	uint32_t mspt_tab[2];
	uint32_t _mspt_tab;
} BCM53600_A0_MSPT_TABm_t;

#define BCM53600_A0_MSPT_TABm_CLR(r) CDK_MEMSET(&((r)._mspt_tab), 0, sizeof(BCM53600_A0_MSPT_TABm_t))
#define BCM53600_A0_MSPT_TABm_SET(r,i,d) (r).mspt_tab[i] = d
#define BCM53600_A0_MSPT_TABm_GET(r,i) (r).mspt_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT0f_GET(r) (((r).mspt_tab[0]) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT0f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT1f_GET(r) ((((r).mspt_tab[0]) >> 2) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT1f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT2f_GET(r) ((((r).mspt_tab[0]) >> 4) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT2f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT3f_GET(r) ((((r).mspt_tab[0]) >> 6) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT3f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT4f_GET(r) ((((r).mspt_tab[0]) >> 8) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT4f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT5f_GET(r) ((((r).mspt_tab[0]) >> 10) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT5f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT6f_GET(r) ((((r).mspt_tab[0]) >> 12) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT6f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT7f_GET(r) ((((r).mspt_tab[0]) >> 14) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT7f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT8f_GET(r) ((((r).mspt_tab[0]) >> 16) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT8f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT9f_GET(r) ((((r).mspt_tab[0]) >> 18) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT9f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT10f_GET(r) ((((r).mspt_tab[0]) >> 20) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT10f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT11f_GET(r) ((((r).mspt_tab[0]) >> 22) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT11f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT12f_GET(r) ((((r).mspt_tab[0]) >> 24) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT12f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT13f_GET(r) ((((r).mspt_tab[0]) >> 26) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT13f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT14f_GET(r) ((((r).mspt_tab[0]) >> 28) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT14f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT15f_GET(r) ((((r).mspt_tab[0]) >> 30) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT15f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT16f_GET(r) (((r).mspt_tab[1]) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT16f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT17f_GET(r) ((((r).mspt_tab[1]) >> 2) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT17f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT18f_GET(r) ((((r).mspt_tab[1]) >> 4) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT18f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT19f_GET(r) ((((r).mspt_tab[1]) >> 6) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT19f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT20f_GET(r) ((((r).mspt_tab[1]) >> 8) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT20f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT21f_GET(r) ((((r).mspt_tab[1]) >> 10) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT21f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT22f_GET(r) ((((r).mspt_tab[1]) >> 12) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT22f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT23f_GET(r) ((((r).mspt_tab[1]) >> 14) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT23f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT24f_GET(r) ((((r).mspt_tab[1]) >> 16) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT24f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT25f_GET(r) ((((r).mspt_tab[1]) >> 18) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT25f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT26f_GET(r) ((((r).mspt_tab[1]) >> 20) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT26f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT27f_GET(r) ((((r).mspt_tab[1]) >> 22) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT27f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT28f_GET(r) ((((r).mspt_tab[1]) >> 24) & 0x3)
#define BCM53600_A0_MSPT_TABm_MSP_TREE_PORT28f_SET(r,f) (r).mspt_tab[1]=(((r).mspt_tab[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))

/*
 * These macros can be used to access MSPT_TAB.
 *
 */
#define BCM53600_A0_READ_MSPT_TABm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_MSPT_TABm,i,(m),8)
#define BCM53600_A0_WRITE_MSPT_TABm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_MSPT_TABm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MSPT_TABm BCM53600_A0_MSPT_TABm
#define MSPT_TABm_MIN BCM53600_A0_MSPT_TABm_MIN
#define MSPT_TABm_MAX BCM53600_A0_MSPT_TABm_MAX
#define MSPT_TABm_CMAX(u) BCM53600_A0_MSPT_TABm_CMAX(u)
#define MSPT_TABm_SIZE BCM53600_A0_MSPT_TABm_SIZE
typedef BCM53600_A0_MSPT_TABm_t MSPT_TABm_t;
#define MSPT_TABm_CLR BCM53600_A0_MSPT_TABm_CLR
#define MSPT_TABm_SET BCM53600_A0_MSPT_TABm_SET
#define MSPT_TABm_GET BCM53600_A0_MSPT_TABm_GET
#define MSPT_TABm_MSP_TREE_PORT0f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT0f_GET
#define MSPT_TABm_MSP_TREE_PORT0f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT0f_SET
#define MSPT_TABm_MSP_TREE_PORT1f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT1f_GET
#define MSPT_TABm_MSP_TREE_PORT1f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT1f_SET
#define MSPT_TABm_MSP_TREE_PORT2f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT2f_GET
#define MSPT_TABm_MSP_TREE_PORT2f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT2f_SET
#define MSPT_TABm_MSP_TREE_PORT3f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT3f_GET
#define MSPT_TABm_MSP_TREE_PORT3f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT3f_SET
#define MSPT_TABm_MSP_TREE_PORT4f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT4f_GET
#define MSPT_TABm_MSP_TREE_PORT4f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT4f_SET
#define MSPT_TABm_MSP_TREE_PORT5f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT5f_GET
#define MSPT_TABm_MSP_TREE_PORT5f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT5f_SET
#define MSPT_TABm_MSP_TREE_PORT6f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT6f_GET
#define MSPT_TABm_MSP_TREE_PORT6f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT6f_SET
#define MSPT_TABm_MSP_TREE_PORT7f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT7f_GET
#define MSPT_TABm_MSP_TREE_PORT7f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT7f_SET
#define MSPT_TABm_MSP_TREE_PORT8f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT8f_GET
#define MSPT_TABm_MSP_TREE_PORT8f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT8f_SET
#define MSPT_TABm_MSP_TREE_PORT9f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT9f_GET
#define MSPT_TABm_MSP_TREE_PORT9f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT9f_SET
#define MSPT_TABm_MSP_TREE_PORT10f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT10f_GET
#define MSPT_TABm_MSP_TREE_PORT10f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT10f_SET
#define MSPT_TABm_MSP_TREE_PORT11f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT11f_GET
#define MSPT_TABm_MSP_TREE_PORT11f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT11f_SET
#define MSPT_TABm_MSP_TREE_PORT12f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT12f_GET
#define MSPT_TABm_MSP_TREE_PORT12f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT12f_SET
#define MSPT_TABm_MSP_TREE_PORT13f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT13f_GET
#define MSPT_TABm_MSP_TREE_PORT13f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT13f_SET
#define MSPT_TABm_MSP_TREE_PORT14f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT14f_GET
#define MSPT_TABm_MSP_TREE_PORT14f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT14f_SET
#define MSPT_TABm_MSP_TREE_PORT15f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT15f_GET
#define MSPT_TABm_MSP_TREE_PORT15f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT15f_SET
#define MSPT_TABm_MSP_TREE_PORT16f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT16f_GET
#define MSPT_TABm_MSP_TREE_PORT16f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT16f_SET
#define MSPT_TABm_MSP_TREE_PORT17f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT17f_GET
#define MSPT_TABm_MSP_TREE_PORT17f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT17f_SET
#define MSPT_TABm_MSP_TREE_PORT18f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT18f_GET
#define MSPT_TABm_MSP_TREE_PORT18f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT18f_SET
#define MSPT_TABm_MSP_TREE_PORT19f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT19f_GET
#define MSPT_TABm_MSP_TREE_PORT19f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT19f_SET
#define MSPT_TABm_MSP_TREE_PORT20f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT20f_GET
#define MSPT_TABm_MSP_TREE_PORT20f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT20f_SET
#define MSPT_TABm_MSP_TREE_PORT21f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT21f_GET
#define MSPT_TABm_MSP_TREE_PORT21f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT21f_SET
#define MSPT_TABm_MSP_TREE_PORT22f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT22f_GET
#define MSPT_TABm_MSP_TREE_PORT22f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT22f_SET
#define MSPT_TABm_MSP_TREE_PORT23f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT23f_GET
#define MSPT_TABm_MSP_TREE_PORT23f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT23f_SET
#define MSPT_TABm_MSP_TREE_PORT24f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT24f_GET
#define MSPT_TABm_MSP_TREE_PORT24f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT24f_SET
#define MSPT_TABm_MSP_TREE_PORT25f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT25f_GET
#define MSPT_TABm_MSP_TREE_PORT25f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT25f_SET
#define MSPT_TABm_MSP_TREE_PORT26f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT26f_GET
#define MSPT_TABm_MSP_TREE_PORT26f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT26f_SET
#define MSPT_TABm_MSP_TREE_PORT27f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT27f_GET
#define MSPT_TABm_MSP_TREE_PORT27f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT27f_SET
#define MSPT_TABm_MSP_TREE_PORT28f_GET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT28f_GET
#define MSPT_TABm_MSP_TREE_PORT28f_SET BCM53600_A0_MSPT_TABm_MSP_TREE_PORT28f_SET
#define READ_MSPT_TABm BCM53600_A0_READ_MSPT_TABm
#define WRITE_MSPT_TABm BCM53600_A0_WRITE_MSPT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MSPT_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MSTP Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        1 : Support 802.1s (Multiple Spanning Tree); spanning tree status will be fetched from MST_table.0 : Only one spanning tree supported. (Original mode)
 *     RESERVED         Reserved
 *     EN_AGE_STATIC_UC When set, age out static unicast entry in the normal aging process.The VALID field of the static unicast entry is set to Invalid status,if its AGE field is 0 when scanned.
 *     EN_AGE_STATIC_MC When set, age out static multicast entry in the normal aging process.The VALID field of the static multicast entry is set to Invalid status,if its AGE field is 0 when scanned.
 *     EN_AGE_DYNAMIC_UC When set, age out dynamic unicast entry in the normal aging process.The VALID field of the dynamic unicast entry is set to Invalid status,if its AGE field is 0 when scanned.
 *     EN_AGE_DYNAMIC_MC When set, age out dynamic multicast entry in the normal aging process.The VALID field of the dynamic multicast entry is set to Invalid status,if its AGE field is 0 when scanned.
 *     EN_UPDATE_STATIC When set, enable the AGE bit of the static entry to be updated.The AGE field of the static entry is set to 100, when a packet is receivedwith its SA matching the static entry which is in Valid status.
 *
 ******************************************************************************/
#define BCM53600_A0_MST_CONr 0x0000040a

#define BCM53600_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 *
 */
typedef union BCM53600_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM53600_A0_MST_CONr_t;

#define BCM53600_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM53600_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM53600_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM53600_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_MST_CONr_RESERVEDf_GET(r) ((((r).mst_con[0]) >> 1) & 0x3)
#define BCM53600_A0_MST_CONr_RESERVEDf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53600_A0_MST_CONr_EN_AGE_STATIC_UCf_GET(r) ((((r).mst_con[0]) >> 3) & 0x1)
#define BCM53600_A0_MST_CONr_EN_AGE_STATIC_UCf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_MST_CONr_EN_AGE_STATIC_MCf_GET(r) ((((r).mst_con[0]) >> 4) & 0x1)
#define BCM53600_A0_MST_CONr_EN_AGE_STATIC_MCf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_UCf_GET(r) ((((r).mst_con[0]) >> 5) & 0x1)
#define BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_UCf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_MCf_GET(r) ((((r).mst_con[0]) >> 6) & 0x1)
#define BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_MCf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_MST_CONr_EN_UPDATE_STATICf_GET(r) ((((r).mst_con[0]) >> 7) & 0x1)
#define BCM53600_A0_MST_CONr_EN_UPDATE_STATICf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MST_CON.
 *
 */
#define BCM53600_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM53600_A0_MST_CONr,(r._mst_con),1)
#define BCM53600_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM53600_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM53600_A0_MST_CONr
#define MST_CONr_SIZE BCM53600_A0_MST_CONr_SIZE
typedef BCM53600_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM53600_A0_MST_CONr_CLR
#define MST_CONr_SET BCM53600_A0_MST_CONr_SET
#define MST_CONr_GET BCM53600_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM53600_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM53600_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_RESERVEDf_GET BCM53600_A0_MST_CONr_RESERVEDf_GET
#define MST_CONr_RESERVEDf_SET BCM53600_A0_MST_CONr_RESERVEDf_SET
#define MST_CONr_EN_AGE_STATIC_UCf_GET BCM53600_A0_MST_CONr_EN_AGE_STATIC_UCf_GET
#define MST_CONr_EN_AGE_STATIC_UCf_SET BCM53600_A0_MST_CONr_EN_AGE_STATIC_UCf_SET
#define MST_CONr_EN_AGE_STATIC_MCf_GET BCM53600_A0_MST_CONr_EN_AGE_STATIC_MCf_GET
#define MST_CONr_EN_AGE_STATIC_MCf_SET BCM53600_A0_MST_CONr_EN_AGE_STATIC_MCf_SET
#define MST_CONr_EN_AGE_DYNAMIC_UCf_GET BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_UCf_GET
#define MST_CONr_EN_AGE_DYNAMIC_UCf_SET BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_UCf_SET
#define MST_CONr_EN_AGE_DYNAMIC_MCf_GET BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_MCf_GET
#define MST_CONr_EN_AGE_DYNAMIC_MCf_SET BCM53600_A0_MST_CONr_EN_AGE_DYNAMIC_MCf_SET
#define MST_CONr_EN_UPDATE_STATICf_GET BCM53600_A0_MST_CONr_EN_UPDATE_STATICf_GET
#define MST_CONr_EN_UPDATE_STATICf_SET BCM53600_A0_MST_CONr_EN_UPDATE_STATICf_SET
#define READ_MST_CONr BCM53600_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM53600_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_MST_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  NEW_CONTROL
 * BLOCKS:   SYS
 * DESC:     New Control Register
 * SIZE:     8
 * FIELDS:
 *     DIS_ECC_CHK      Disable ecc check.
 *     WIRE_RATE_MODE   Packet Length Correction.2'b00: In Rate Meter Operation, the packet length(starting from the first byte of MACDA to the last byte of CRC) should be deducted from bucket. 2'b01: In Rate Meter Operation, the packet length(starting from the first byte of MACDA to the last byte of CRC), plus IPG(12bytes) & Preamble/SDF(8bytes) should be deducted from bucket.2'b10: In Rate Meter Operation, the packet length(starting from the first byte of MACDA to the last byte of CRC), plus Preamble/SDF(8bytes) should be deducted from bucket.2'b11: Reseerved
 *     RESERVED_1       Reserved
 *     CLK25            1'b1: Enable 25MHz clock output.1'b0: Disable 25MHz clock output.
 *     TXFLOW_HALF_MODE Reserved.(Not2Release)
 *     EN_SW_FLOW_CON   Enable software override XOFF result.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_NEW_CONTROLr 0x00000003

#define BCM53600_A0_NEW_CONTROLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CONTROL.
 *
 */
typedef union BCM53600_A0_NEW_CONTROLr_s {
	uint32_t v[1];
	uint32_t new_control[1];
	uint32_t _new_control;
} BCM53600_A0_NEW_CONTROLr_t;

#define BCM53600_A0_NEW_CONTROLr_CLR(r) (r).new_control[0] = 0
#define BCM53600_A0_NEW_CONTROLr_SET(r,d) (r).new_control[0] = d
#define BCM53600_A0_NEW_CONTROLr_GET(r) (r).new_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_NEW_CONTROLr_DIS_ECC_CHKf_GET(r) (((r).new_control[0]) & 0x1)
#define BCM53600_A0_NEW_CONTROLr_DIS_ECC_CHKf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_NEW_CONTROLr_WIRE_RATE_MODEf_GET(r) ((((r).new_control[0]) >> 1) & 0x3)
#define BCM53600_A0_NEW_CONTROLr_WIRE_RATE_MODEf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53600_A0_NEW_CONTROLr_RESERVED_1f_GET(r) ((((r).new_control[0]) >> 3) & 0x1)
#define BCM53600_A0_NEW_CONTROLr_RESERVED_1f_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_NEW_CONTROLr_CLK25f_GET(r) ((((r).new_control[0]) >> 4) & 0x1)
#define BCM53600_A0_NEW_CONTROLr_CLK25f_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_NEW_CONTROLr_TXFLOW_HALF_MODEf_GET(r) ((((r).new_control[0]) >> 5) & 0x1)
#define BCM53600_A0_NEW_CONTROLr_TXFLOW_HALF_MODEf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_NEW_CONTROLr_EN_SW_FLOW_CONf_GET(r) ((((r).new_control[0]) >> 6) & 0x1)
#define BCM53600_A0_NEW_CONTROLr_EN_SW_FLOW_CONf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_NEW_CONTROLr_RESERVED_0f_GET(r) ((((r).new_control[0]) >> 7) & 0x1)
#define BCM53600_A0_NEW_CONTROLr_RESERVED_0f_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access NEW_CONTROL.
 *
 */
#define BCM53600_A0_READ_NEW_CONTROLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_NEW_CONTROLr,(r._new_control),1)
#define BCM53600_A0_WRITE_NEW_CONTROLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_NEW_CONTROLr,&(r._new_control),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CONTROLr BCM53600_A0_NEW_CONTROLr
#define NEW_CONTROLr_SIZE BCM53600_A0_NEW_CONTROLr_SIZE
typedef BCM53600_A0_NEW_CONTROLr_t NEW_CONTROLr_t;
#define NEW_CONTROLr_CLR BCM53600_A0_NEW_CONTROLr_CLR
#define NEW_CONTROLr_SET BCM53600_A0_NEW_CONTROLr_SET
#define NEW_CONTROLr_GET BCM53600_A0_NEW_CONTROLr_GET
#define NEW_CONTROLr_DIS_ECC_CHKf_GET BCM53600_A0_NEW_CONTROLr_DIS_ECC_CHKf_GET
#define NEW_CONTROLr_DIS_ECC_CHKf_SET BCM53600_A0_NEW_CONTROLr_DIS_ECC_CHKf_SET
#define NEW_CONTROLr_WIRE_RATE_MODEf_GET BCM53600_A0_NEW_CONTROLr_WIRE_RATE_MODEf_GET
#define NEW_CONTROLr_WIRE_RATE_MODEf_SET BCM53600_A0_NEW_CONTROLr_WIRE_RATE_MODEf_SET
#define NEW_CONTROLr_RESERVED_1f_GET BCM53600_A0_NEW_CONTROLr_RESERVED_1f_GET
#define NEW_CONTROLr_RESERVED_1f_SET BCM53600_A0_NEW_CONTROLr_RESERVED_1f_SET
#define NEW_CONTROLr_CLK25f_GET BCM53600_A0_NEW_CONTROLr_CLK25f_GET
#define NEW_CONTROLr_CLK25f_SET BCM53600_A0_NEW_CONTROLr_CLK25f_SET
#define NEW_CONTROLr_TXFLOW_HALF_MODEf_GET BCM53600_A0_NEW_CONTROLr_TXFLOW_HALF_MODEf_GET
#define NEW_CONTROLr_TXFLOW_HALF_MODEf_SET BCM53600_A0_NEW_CONTROLr_TXFLOW_HALF_MODEf_SET
#define NEW_CONTROLr_EN_SW_FLOW_CONf_GET BCM53600_A0_NEW_CONTROLr_EN_SW_FLOW_CONf_GET
#define NEW_CONTROLr_EN_SW_FLOW_CONf_SET BCM53600_A0_NEW_CONTROLr_EN_SW_FLOW_CONf_SET
#define NEW_CONTROLr_RESERVED_0f_GET BCM53600_A0_NEW_CONTROLr_RESERVED_0f_GET
#define NEW_CONTROLr_RESERVED_0f_SET BCM53600_A0_NEW_CONTROLr_RESERVED_0f_SET
#define READ_NEW_CONTROLr BCM53600_A0_READ_NEW_CONTROLr
#define WRITE_NEW_CONTROLr BCM53600_A0_WRITE_NEW_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_NEW_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  OutOfRangeErrPkts
 * BLOCKS:   SYS
 * DESC:     OutofRange Errors Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_OUTOFRANGEERRPKTSr 0x00005168

#define BCM53600_A0_OUTOFRANGEERRPKTSr_SIZE 4

/*
 * This structure should be used to declare and program OutOfRangeErrPkts.
 *
 */
typedef union BCM53600_A0_OUTOFRANGEERRPKTSr_s {
	uint32_t v[1];
	uint32_t outofrangeerrpkts[1];
	uint32_t _outofrangeerrpkts;
} BCM53600_A0_OUTOFRANGEERRPKTSr_t;

#define BCM53600_A0_OUTOFRANGEERRPKTSr_CLR(r) (r).outofrangeerrpkts[0] = 0
#define BCM53600_A0_OUTOFRANGEERRPKTSr_SET(r,d) (r).outofrangeerrpkts[0] = d
#define BCM53600_A0_OUTOFRANGEERRPKTSr_GET(r) (r).outofrangeerrpkts[0]


/*
 * These macros can be used to access OutOfRangeErrPkts.
 *
 */
#define BCM53600_A0_READ_OUTOFRANGEERRPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_OUTOFRANGEERRPKTSr,(r._outofrangeerrpkts),4)
#define BCM53600_A0_WRITE_OUTOFRANGEERRPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_OUTOFRANGEERRPKTSr,&(r._outofrangeerrpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTOFRANGEERRPKTSr BCM53600_A0_OUTOFRANGEERRPKTSr
#define OUTOFRANGEERRPKTSr_SIZE BCM53600_A0_OUTOFRANGEERRPKTSr_SIZE
typedef BCM53600_A0_OUTOFRANGEERRPKTSr_t OUTOFRANGEERRPKTSr_t;
#define OUTOFRANGEERRPKTSr_CLR BCM53600_A0_OUTOFRANGEERRPKTSr_CLR
#define OUTOFRANGEERRPKTSr_SET BCM53600_A0_OUTOFRANGEERRPKTSr_SET
#define OUTOFRANGEERRPKTSr_GET BCM53600_A0_OUTOFRANGEERRPKTSr_GET
#define READ_OUTOFRANGEERRPKTSr BCM53600_A0_READ_OUTOFRANGEERRPKTSr
#define WRITE_OUTOFRANGEERRPKTSr BCM53600_A0_WRITE_OUTOFRANGEERRPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_OUTOFRANGEERRPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PAGEREG
 * BLOCKS:   SPI
 * DESC:     PAGE Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_PAGEREGr 0x0000ffff

#define BCM53600_A0_PAGEREGr_SIZE 1

/*
 * This structure should be used to declare and program PAGEREG.
 *
 */
typedef union BCM53600_A0_PAGEREGr_s {
	uint32_t v[1];
	uint32_t pagereg[1];
	uint32_t _pagereg;
} BCM53600_A0_PAGEREGr_t;

#define BCM53600_A0_PAGEREGr_CLR(r) (r).pagereg[0] = 0
#define BCM53600_A0_PAGEREGr_SET(r,d) (r).pagereg[0] = d
#define BCM53600_A0_PAGEREGr_GET(r) (r).pagereg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PAGEREGr_RESERVEDf_GET(r) (((r).pagereg[0]) & 0xff)
#define BCM53600_A0_PAGEREGr_RESERVEDf_SET(r,f) (r).pagereg[0]=(((r).pagereg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PAGEREG.
 *
 */
#define BCM53600_A0_READ_PAGEREGr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PAGEREGr,(r._pagereg),1)
#define BCM53600_A0_WRITE_PAGEREGr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PAGEREGr,&(r._pagereg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAGEREGr BCM53600_A0_PAGEREGr
#define PAGEREGr_SIZE BCM53600_A0_PAGEREGr_SIZE
typedef BCM53600_A0_PAGEREGr_t PAGEREGr_t;
#define PAGEREGr_CLR BCM53600_A0_PAGEREGr_CLR
#define PAGEREGr_SET BCM53600_A0_PAGEREGr_SET
#define PAGEREGr_GET BCM53600_A0_PAGEREGr_GET
#define PAGEREGr_RESERVEDf_GET BCM53600_A0_PAGEREGr_RESERVEDf_GET
#define PAGEREGr_RESERVEDf_SET BCM53600_A0_PAGEREGr_RESERVEDf_SET
#define READ_PAGEREGr BCM53600_A0_READ_PAGEREGr
#define WRITE_PAGEREGr BCM53600_A0_WRITE_PAGEREGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PAGEREGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PAUSE_FM_SA
 * BLOCKS:   SYS
 * DESC:     Pause Frame Source Address Register
 * SIZE:     48
 * FIELDS:
 *     PAUSE_SA         Pause Frame source Address.
 *
 ******************************************************************************/
#define BCM53600_A0_PAUSE_FM_SAr 0x00000480

#define BCM53600_A0_PAUSE_FM_SAr_SIZE 6

/*
 * This structure should be used to declare and program PAUSE_FM_SA.
 *
 */
typedef union BCM53600_A0_PAUSE_FM_SAr_s {
	uint32_t v[2];
	uint32_t pause_fm_sa[2];
	uint32_t _pause_fm_sa;
} BCM53600_A0_PAUSE_FM_SAr_t;

#define BCM53600_A0_PAUSE_FM_SAr_CLR(r) CDK_MEMSET(&((r)._pause_fm_sa), 0, sizeof(BCM53600_A0_PAUSE_FM_SAr_t))
#define BCM53600_A0_PAUSE_FM_SAr_SET(r,i,d) (r).pause_fm_sa[i] = d
#define BCM53600_A0_PAUSE_FM_SAr_GET(r,i) (r).pause_fm_sa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PAUSE_FM_SAr_PAUSE_SAf_GET(r,a) cdk_field_get((r).pause_fm_sa,0,47,a)
#define BCM53600_A0_PAUSE_FM_SAr_PAUSE_SAf_SET(r,a) cdk_field_set((r).pause_fm_sa,0,47,a)

/*
 * These macros can be used to access PAUSE_FM_SA.
 *
 */
#define BCM53600_A0_READ_PAUSE_FM_SAr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PAUSE_FM_SAr,(r._pause_fm_sa),6)
#define BCM53600_A0_WRITE_PAUSE_FM_SAr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PAUSE_FM_SAr,&(r._pause_fm_sa),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_FM_SAr BCM53600_A0_PAUSE_FM_SAr
#define PAUSE_FM_SAr_SIZE BCM53600_A0_PAUSE_FM_SAr_SIZE
typedef BCM53600_A0_PAUSE_FM_SAr_t PAUSE_FM_SAr_t;
#define PAUSE_FM_SAr_CLR BCM53600_A0_PAUSE_FM_SAr_CLR
#define PAUSE_FM_SAr_SET BCM53600_A0_PAUSE_FM_SAr_SET
#define PAUSE_FM_SAr_GET BCM53600_A0_PAUSE_FM_SAr_GET
#define PAUSE_FM_SAr_PAUSE_SAf_GET BCM53600_A0_PAUSE_FM_SAr_PAUSE_SAf_GET
#define PAUSE_FM_SAr_PAUSE_SAf_SET BCM53600_A0_PAUSE_FM_SAr_PAUSE_SAf_SET
#define READ_PAUSE_FM_SAr BCM53600_A0_READ_PAUSE_FM_SAr
#define WRITE_PAUSE_FM_SAr BCM53600_A0_WRITE_PAUSE_FM_SAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PAUSE_FM_SAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  PCP2DPTC
 * BLOCKS:   SYS
 * DESC:     PCP2DPTC Table
 * SIZE:     6
 * FIELDS:
 *     PCP2TC           TC
 *     PCP2DP           DP
 *
 ******************************************************************************/
#define BCM53600_A0_PCP2DPTCm 0x00000000

#define BCM53600_A0_PCP2DPTCm_MIN 0
#define BCM53600_A0_PCP2DPTCm_MAX 463
#define BCM53600_A0_PCP2DPTCm_CMAX(u) 463
#define BCM53600_A0_PCP2DPTCm_SIZE 1

/*
 * This structure should be used to declare and program PCP2DPTC.
 *
 */
typedef union BCM53600_A0_PCP2DPTCm_s {
	uint32_t v[1];
	uint32_t pcp2dptc[1];
	uint32_t _pcp2dptc;
} BCM53600_A0_PCP2DPTCm_t;

#define BCM53600_A0_PCP2DPTCm_CLR(r) (r).pcp2dptc[0] = 0
#define BCM53600_A0_PCP2DPTCm_SET(r,d) (r).pcp2dptc[0] = d
#define BCM53600_A0_PCP2DPTCm_GET(r) (r).pcp2dptc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PCP2DPTCm_PCP2TCf_GET(r) (((r).pcp2dptc[0]) & 0xf)
#define BCM53600_A0_PCP2DPTCm_PCP2TCf_SET(r,f) (r).pcp2dptc[0]=(((r).pcp2dptc[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_PCP2DPTCm_PCP2DPf_GET(r) ((((r).pcp2dptc[0]) >> 4) & 0x3)
#define BCM53600_A0_PCP2DPTCm_PCP2DPf_SET(r,f) (r).pcp2dptc[0]=(((r).pcp2dptc[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))

/*
 * These macros can be used to access PCP2DPTC.
 *
 */
#define BCM53600_A0_READ_PCP2DPTCm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_PCP2DPTCm,i,(m),1)
#define BCM53600_A0_WRITE_PCP2DPTCm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_PCP2DPTCm,i,&(m),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PCP2DPTCm BCM53600_A0_PCP2DPTCm
#define PCP2DPTCm_MIN BCM53600_A0_PCP2DPTCm_MIN
#define PCP2DPTCm_MAX BCM53600_A0_PCP2DPTCm_MAX
#define PCP2DPTCm_CMAX(u) BCM53600_A0_PCP2DPTCm_CMAX(u)
#define PCP2DPTCm_SIZE BCM53600_A0_PCP2DPTCm_SIZE
typedef BCM53600_A0_PCP2DPTCm_t PCP2DPTCm_t;
#define PCP2DPTCm_CLR BCM53600_A0_PCP2DPTCm_CLR
#define PCP2DPTCm_SET BCM53600_A0_PCP2DPTCm_SET
#define PCP2DPTCm_GET BCM53600_A0_PCP2DPTCm_GET
#define PCP2DPTCm_PCP2TCf_GET BCM53600_A0_PCP2DPTCm_PCP2TCf_GET
#define PCP2DPTCm_PCP2TCf_SET BCM53600_A0_PCP2DPTCm_PCP2TCf_SET
#define PCP2DPTCm_PCP2DPf_GET BCM53600_A0_PCP2DPTCm_PCP2DPf_GET
#define PCP2DPTCm_PCP2DPf_SET BCM53600_A0_PCP2DPTCm_PCP2DPf_SET
#define READ_PCP2DPTCm BCM53600_A0_READ_PCP2DPTCm
#define WRITE_PCP2DPTCm BCM53600_A0_WRITE_PCP2DPTCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PCP2DPTCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PCP_VALUE_CTRL
 * BLOCKS:   SYS
 * DESC:     AVB PCP Value Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     CLASS_A_PCP      AVB Class A pcp valueThis field is used to qualify the pcp value of AVB Class A packet.
 *     CLASS_B_PCP      AVB Class B pcp valueThis field is used to qualify the pcp value of AVB Class B packet.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_PCP_VALUE_CTRLr 0x00004605

#define BCM53600_A0_PCP_VALUE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PCP_VALUE_CTRL.
 *
 */
typedef union BCM53600_A0_PCP_VALUE_CTRLr_s {
	uint32_t v[1];
	uint32_t pcp_value_ctrl[1];
	uint32_t _pcp_value_ctrl;
} BCM53600_A0_PCP_VALUE_CTRLr_t;

#define BCM53600_A0_PCP_VALUE_CTRLr_CLR(r) (r).pcp_value_ctrl[0] = 0
#define BCM53600_A0_PCP_VALUE_CTRLr_SET(r,d) (r).pcp_value_ctrl[0] = d
#define BCM53600_A0_PCP_VALUE_CTRLr_GET(r) (r).pcp_value_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_GET(r) (((r).pcp_value_ctrl[0]) & 0x7)
#define BCM53600_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_SET(r,f) (r).pcp_value_ctrl[0]=(((r).pcp_value_ctrl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_GET(r) ((((r).pcp_value_ctrl[0]) >> 3) & 0x7)
#define BCM53600_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_SET(r,f) (r).pcp_value_ctrl[0]=(((r).pcp_value_ctrl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53600_A0_PCP_VALUE_CTRLr_RESERVEDf_GET(r) ((((r).pcp_value_ctrl[0]) >> 6) & 0x3)
#define BCM53600_A0_PCP_VALUE_CTRLr_RESERVEDf_SET(r,f) (r).pcp_value_ctrl[0]=(((r).pcp_value_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access PCP_VALUE_CTRL.
 *
 */
#define BCM53600_A0_READ_PCP_VALUE_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PCP_VALUE_CTRLr,(r._pcp_value_ctrl),1)
#define BCM53600_A0_WRITE_PCP_VALUE_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PCP_VALUE_CTRLr,&(r._pcp_value_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PCP_VALUE_CTRLr BCM53600_A0_PCP_VALUE_CTRLr
#define PCP_VALUE_CTRLr_SIZE BCM53600_A0_PCP_VALUE_CTRLr_SIZE
typedef BCM53600_A0_PCP_VALUE_CTRLr_t PCP_VALUE_CTRLr_t;
#define PCP_VALUE_CTRLr_CLR BCM53600_A0_PCP_VALUE_CTRLr_CLR
#define PCP_VALUE_CTRLr_SET BCM53600_A0_PCP_VALUE_CTRLr_SET
#define PCP_VALUE_CTRLr_GET BCM53600_A0_PCP_VALUE_CTRLr_GET
#define PCP_VALUE_CTRLr_CLASS_A_PCPf_GET BCM53600_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_GET
#define PCP_VALUE_CTRLr_CLASS_A_PCPf_SET BCM53600_A0_PCP_VALUE_CTRLr_CLASS_A_PCPf_SET
#define PCP_VALUE_CTRLr_CLASS_B_PCPf_GET BCM53600_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_GET
#define PCP_VALUE_CTRLr_CLASS_B_PCPf_SET BCM53600_A0_PCP_VALUE_CTRLr_CLASS_B_PCPf_SET
#define PCP_VALUE_CTRLr_RESERVEDf_GET BCM53600_A0_PCP_VALUE_CTRLr_RESERVEDf_GET
#define PCP_VALUE_CTRLr_RESERVEDf_SET BCM53600_A0_PCP_VALUE_CTRLr_RESERVEDf_SET
#define READ_PCP_VALUE_CTRLr BCM53600_A0_READ_PCP_VALUE_CTRLr
#define WRITE_PCP_VALUE_CTRLr BCM53600_A0_WRITE_PCP_VALUE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PCP_VALUE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Peak Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TEMP_DATA   It keeps track the peak temperature monitor result since the last read.- It's the minimum code for the highest temperature since the last read.- After read, the register to be reset to 0x1FF.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TEMP_MON_RESUr 0x00000b04

#define BCM53600_A0_PEAK_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TEMP_MON_RESU.
 *
 */
typedef union BCM53600_A0_PEAK_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t peak_temp_mon_resu[1];
	uint32_t _peak_temp_mon_resu;
} BCM53600_A0_PEAK_TEMP_MON_RESUr_t;

#define BCM53600_A0_PEAK_TEMP_MON_RESUr_CLR(r) (r).peak_temp_mon_resu[0] = 0
#define BCM53600_A0_PEAK_TEMP_MON_RESUr_SET(r,d) (r).peak_temp_mon_resu[0] = d
#define BCM53600_A0_PEAK_TEMP_MON_RESUr_GET(r) (r).peak_temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET(r) (((r).peak_temp_mon_resu[0]) & 0x1ff)
#define BCM53600_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53600_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).peak_temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM53600_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PEAK_TEMP_MON_RESU.
 *
 */
#define BCM53600_A0_READ_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TEMP_MON_RESUr,(r._peak_temp_mon_resu),2)
#define BCM53600_A0_WRITE_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TEMP_MON_RESUr,&(r._peak_temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TEMP_MON_RESUr BCM53600_A0_PEAK_TEMP_MON_RESUr
#define PEAK_TEMP_MON_RESUr_SIZE BCM53600_A0_PEAK_TEMP_MON_RESUr_SIZE
typedef BCM53600_A0_PEAK_TEMP_MON_RESUr_t PEAK_TEMP_MON_RESUr_t;
#define PEAK_TEMP_MON_RESUr_CLR BCM53600_A0_PEAK_TEMP_MON_RESUr_CLR
#define PEAK_TEMP_MON_RESUr_SET BCM53600_A0_PEAK_TEMP_MON_RESUr_SET
#define PEAK_TEMP_MON_RESUr_GET BCM53600_A0_PEAK_TEMP_MON_RESUr_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET BCM53600_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET BCM53600_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_GET BCM53600_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_SET BCM53600_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_PEAK_TEMP_MON_RESUr BCM53600_A0_READ_PEAK_TEMP_MON_RESUr
#define WRITE_PEAK_TEMP_MON_RESUr BCM53600_A0_WRITE_PEAK_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TOTAL_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak Total Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_BUF_CNT Peak Global Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr 0x00000ac2

#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TOTAL_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_total_buf_used_count[1];
	uint32_t _peak_total_buf_used_count;
} BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_CLR(r) (r).peak_total_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_SET(r,d) (r).peak_total_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_GET(r) (r).peak_total_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_PEAK_TOTAL_BUF_CNTf_GET(r) (((r).peak_total_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_PEAK_TOTAL_BUF_CNTf_SET(r,f) (r).peak_total_buf_used_count[0]=(((r).peak_total_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_total_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_total_buf_used_count[0]=(((r).peak_total_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TOTAL_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TOTAL_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr,(r._peak_total_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TOTAL_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr,&(r._peak_total_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TOTAL_BUF_USED_COUNTr BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr
#define PEAK_TOTAL_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_t PEAK_TOTAL_BUF_USED_COUNTr_t;
#define PEAK_TOTAL_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_CLR
#define PEAK_TOTAL_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_SET
#define PEAK_TOTAL_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_GET
#define PEAK_TOTAL_BUF_USED_COUNTr_PEAK_TOTAL_BUF_CNTf_GET BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_PEAK_TOTAL_BUF_CNTf_GET
#define PEAK_TOTAL_BUF_USED_COUNTr_PEAK_TOTAL_BUF_CNTf_SET BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_PEAK_TOTAL_BUF_CNTf_SET
#define PEAK_TOTAL_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TOTAL_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TOTAL_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TOTAL_BUF_USED_COUNTr
#define WRITE_PEAK_TOTAL_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TOTAL_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TOTAL_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ0_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q0 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ0_BUF_CNT Peak TXQ-Q0 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr 0x00000aca

#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ0_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq0_buf_used_count[1];
	uint32_t _peak_txq0_buf_used_count;
} BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_CLR(r) (r).peak_txq0_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_SET(r,d) (r).peak_txq0_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_GET(r) (r).peak_txq0_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_PEAK_TXQ0_BUF_CNTf_GET(r) (((r).peak_txq0_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_PEAK_TXQ0_BUF_CNTf_SET(r,f) (r).peak_txq0_buf_used_count[0]=(((r).peak_txq0_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq0_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq0_buf_used_count[0]=(((r).peak_txq0_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ0_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ0_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr,(r._peak_txq0_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ0_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr,&(r._peak_txq0_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ0_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr
#define PEAK_TXQ0_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_t PEAK_TXQ0_BUF_USED_COUNTr_t;
#define PEAK_TXQ0_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_CLR
#define PEAK_TXQ0_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_SET
#define PEAK_TXQ0_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_GET
#define PEAK_TXQ0_BUF_USED_COUNTr_PEAK_TXQ0_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_PEAK_TXQ0_BUF_CNTf_GET
#define PEAK_TXQ0_BUF_USED_COUNTr_PEAK_TXQ0_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_PEAK_TXQ0_BUF_CNTf_SET
#define PEAK_TXQ0_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ0_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ0_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ0_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ0_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ0_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ0_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ1_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q1 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ1_BUF_CNT Peak TXQ-Q1 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr 0x00000acc

#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ1_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq1_buf_used_count[1];
	uint32_t _peak_txq1_buf_used_count;
} BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_CLR(r) (r).peak_txq1_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_SET(r,d) (r).peak_txq1_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_GET(r) (r).peak_txq1_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_PEAK_TXQ1_BUF_CNTf_GET(r) (((r).peak_txq1_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_PEAK_TXQ1_BUF_CNTf_SET(r,f) (r).peak_txq1_buf_used_count[0]=(((r).peak_txq1_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq1_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq1_buf_used_count[0]=(((r).peak_txq1_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ1_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ1_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr,(r._peak_txq1_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ1_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr,&(r._peak_txq1_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ1_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr
#define PEAK_TXQ1_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_t PEAK_TXQ1_BUF_USED_COUNTr_t;
#define PEAK_TXQ1_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_CLR
#define PEAK_TXQ1_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_SET
#define PEAK_TXQ1_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_GET
#define PEAK_TXQ1_BUF_USED_COUNTr_PEAK_TXQ1_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_PEAK_TXQ1_BUF_CNTf_GET
#define PEAK_TXQ1_BUF_USED_COUNTr_PEAK_TXQ1_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_PEAK_TXQ1_BUF_CNTf_SET
#define PEAK_TXQ1_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ1_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ1_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ1_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ1_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ1_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ1_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ2_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q2 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ2_BUF_CNT Peak TXQ-Q2 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr 0x00000ace

#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ2_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq2_buf_used_count[1];
	uint32_t _peak_txq2_buf_used_count;
} BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_CLR(r) (r).peak_txq2_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_SET(r,d) (r).peak_txq2_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_GET(r) (r).peak_txq2_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_PEAK_TXQ2_BUF_CNTf_GET(r) (((r).peak_txq2_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_PEAK_TXQ2_BUF_CNTf_SET(r,f) (r).peak_txq2_buf_used_count[0]=(((r).peak_txq2_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq2_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq2_buf_used_count[0]=(((r).peak_txq2_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ2_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ2_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr,(r._peak_txq2_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ2_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr,&(r._peak_txq2_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ2_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr
#define PEAK_TXQ2_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_t PEAK_TXQ2_BUF_USED_COUNTr_t;
#define PEAK_TXQ2_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_CLR
#define PEAK_TXQ2_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_SET
#define PEAK_TXQ2_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_GET
#define PEAK_TXQ2_BUF_USED_COUNTr_PEAK_TXQ2_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_PEAK_TXQ2_BUF_CNTf_GET
#define PEAK_TXQ2_BUF_USED_COUNTr_PEAK_TXQ2_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_PEAK_TXQ2_BUF_CNTf_SET
#define PEAK_TXQ2_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ2_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ2_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ2_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ2_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ2_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ2_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ3_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q3 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ3_BUF_CNT Peak TXQ-Q3 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr 0x00000ad0

#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ3_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq3_buf_used_count[1];
	uint32_t _peak_txq3_buf_used_count;
} BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_CLR(r) (r).peak_txq3_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_SET(r,d) (r).peak_txq3_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_GET(r) (r).peak_txq3_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_PEAK_TXQ3_BUF_CNTf_GET(r) (((r).peak_txq3_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_PEAK_TXQ3_BUF_CNTf_SET(r,f) (r).peak_txq3_buf_used_count[0]=(((r).peak_txq3_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq3_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq3_buf_used_count[0]=(((r).peak_txq3_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ3_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ3_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr,(r._peak_txq3_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ3_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr,&(r._peak_txq3_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ3_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr
#define PEAK_TXQ3_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_t PEAK_TXQ3_BUF_USED_COUNTr_t;
#define PEAK_TXQ3_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_CLR
#define PEAK_TXQ3_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_SET
#define PEAK_TXQ3_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_GET
#define PEAK_TXQ3_BUF_USED_COUNTr_PEAK_TXQ3_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_PEAK_TXQ3_BUF_CNTf_GET
#define PEAK_TXQ3_BUF_USED_COUNTr_PEAK_TXQ3_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_PEAK_TXQ3_BUF_CNTf_SET
#define PEAK_TXQ3_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ3_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ3_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ3_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ3_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ3_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ3_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ4_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q4 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ4_BUF_CNT Peak TXQ-Q4 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr 0x00000ad2

#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ4_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq4_buf_used_count[1];
	uint32_t _peak_txq4_buf_used_count;
} BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_CLR(r) (r).peak_txq4_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_SET(r,d) (r).peak_txq4_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_GET(r) (r).peak_txq4_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_PEAK_TXQ4_BUF_CNTf_GET(r) (((r).peak_txq4_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_PEAK_TXQ4_BUF_CNTf_SET(r,f) (r).peak_txq4_buf_used_count[0]=(((r).peak_txq4_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq4_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq4_buf_used_count[0]=(((r).peak_txq4_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ4_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ4_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr,(r._peak_txq4_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ4_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr,&(r._peak_txq4_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ4_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr
#define PEAK_TXQ4_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_t PEAK_TXQ4_BUF_USED_COUNTr_t;
#define PEAK_TXQ4_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_CLR
#define PEAK_TXQ4_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_SET
#define PEAK_TXQ4_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_GET
#define PEAK_TXQ4_BUF_USED_COUNTr_PEAK_TXQ4_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_PEAK_TXQ4_BUF_CNTf_GET
#define PEAK_TXQ4_BUF_USED_COUNTr_PEAK_TXQ4_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_PEAK_TXQ4_BUF_CNTf_SET
#define PEAK_TXQ4_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ4_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ4_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ4_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ4_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ4_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ4_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ5_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q5 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ5_BUF_CNT Peak TXQ-Q5 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr 0x00000ad4

#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ5_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq5_buf_used_count[1];
	uint32_t _peak_txq5_buf_used_count;
} BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_CLR(r) (r).peak_txq5_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_SET(r,d) (r).peak_txq5_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_GET(r) (r).peak_txq5_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_PEAK_TXQ5_BUF_CNTf_GET(r) (((r).peak_txq5_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_PEAK_TXQ5_BUF_CNTf_SET(r,f) (r).peak_txq5_buf_used_count[0]=(((r).peak_txq5_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq5_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq5_buf_used_count[0]=(((r).peak_txq5_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ5_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ5_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr,(r._peak_txq5_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ5_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr,&(r._peak_txq5_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ5_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr
#define PEAK_TXQ5_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_t PEAK_TXQ5_BUF_USED_COUNTr_t;
#define PEAK_TXQ5_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_CLR
#define PEAK_TXQ5_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_SET
#define PEAK_TXQ5_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_GET
#define PEAK_TXQ5_BUF_USED_COUNTr_PEAK_TXQ5_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_PEAK_TXQ5_BUF_CNTf_GET
#define PEAK_TXQ5_BUF_USED_COUNTr_PEAK_TXQ5_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_PEAK_TXQ5_BUF_CNTf_SET
#define PEAK_TXQ5_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ5_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ5_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ5_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ5_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ5_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ5_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ6_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q6 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ6_BUF_CNT Peak TXQ-Q6 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr 0x00000ad6

#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ6_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq6_buf_used_count[1];
	uint32_t _peak_txq6_buf_used_count;
} BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_CLR(r) (r).peak_txq6_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_SET(r,d) (r).peak_txq6_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_GET(r) (r).peak_txq6_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_PEAK_TXQ6_BUF_CNTf_GET(r) (((r).peak_txq6_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_PEAK_TXQ6_BUF_CNTf_SET(r,f) (r).peak_txq6_buf_used_count[0]=(((r).peak_txq6_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq6_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq6_buf_used_count[0]=(((r).peak_txq6_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ6_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ6_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr,(r._peak_txq6_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ6_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr,&(r._peak_txq6_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ6_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr
#define PEAK_TXQ6_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_t PEAK_TXQ6_BUF_USED_COUNTr_t;
#define PEAK_TXQ6_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_CLR
#define PEAK_TXQ6_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_SET
#define PEAK_TXQ6_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_GET
#define PEAK_TXQ6_BUF_USED_COUNTr_PEAK_TXQ6_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_PEAK_TXQ6_BUF_CNTf_GET
#define PEAK_TXQ6_BUF_USED_COUNTr_PEAK_TXQ6_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_PEAK_TXQ6_BUF_CNTf_SET
#define PEAK_TXQ6_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ6_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ6_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ6_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ6_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ6_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ6_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PEAK_TXQ7_BUF_USED_COUNT
 * BLOCKS:   SYS
 * DESC:     Peak TXQ-Q7 Buffer Used Count Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ7_BUF_CNT Peak TXQ-Q7 Buffer Used Count.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr 0x00000ad8

#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TXQ7_BUF_USED_COUNT.
 *
 */
typedef union BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_s {
	uint32_t v[1];
	uint32_t peak_txq7_buf_used_count[1];
	uint32_t _peak_txq7_buf_used_count;
} BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_t;

#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_CLR(r) (r).peak_txq7_buf_used_count[0] = 0
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_SET(r,d) (r).peak_txq7_buf_used_count[0] = d
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_GET(r) (r).peak_txq7_buf_used_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_PEAK_TXQ7_BUF_CNTf_GET(r) (((r).peak_txq7_buf_used_count[0]) & 0x1fff)
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_PEAK_TXQ7_BUF_CNTf_SET(r,f) (r).peak_txq7_buf_used_count[0]=(((r).peak_txq7_buf_used_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_RESERVEDf_GET(r) ((((r).peak_txq7_buf_used_count[0]) >> 13) & 0x7)
#define BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_RESERVEDf_SET(r,f) (r).peak_txq7_buf_used_count[0]=(((r).peak_txq7_buf_used_count[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PEAK_TXQ7_BUF_USED_COUNT.
 *
 */
#define BCM53600_A0_READ_PEAK_TXQ7_BUF_USED_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr,(r._peak_txq7_buf_used_count),2)
#define BCM53600_A0_WRITE_PEAK_TXQ7_BUF_USED_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr,&(r._peak_txq7_buf_used_count),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TXQ7_BUF_USED_COUNTr BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr
#define PEAK_TXQ7_BUF_USED_COUNTr_SIZE BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_SIZE
typedef BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_t PEAK_TXQ7_BUF_USED_COUNTr_t;
#define PEAK_TXQ7_BUF_USED_COUNTr_CLR BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_CLR
#define PEAK_TXQ7_BUF_USED_COUNTr_SET BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_SET
#define PEAK_TXQ7_BUF_USED_COUNTr_GET BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_GET
#define PEAK_TXQ7_BUF_USED_COUNTr_PEAK_TXQ7_BUF_CNTf_GET BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_PEAK_TXQ7_BUF_CNTf_GET
#define PEAK_TXQ7_BUF_USED_COUNTr_PEAK_TXQ7_BUF_CNTf_SET BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_PEAK_TXQ7_BUF_CNTf_SET
#define PEAK_TXQ7_BUF_USED_COUNTr_RESERVEDf_GET BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_RESERVEDf_GET
#define PEAK_TXQ7_BUF_USED_COUNTr_RESERVEDf_SET BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr_RESERVEDf_SET
#define READ_PEAK_TXQ7_BUF_USED_COUNTr BCM53600_A0_READ_PEAK_TXQ7_BUF_USED_COUNTr
#define WRITE_PEAK_TXQ7_BUF_USED_COUNTr BCM53600_A0_WRITE_PEAK_TXQ7_BUF_USED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PEAK_TXQ7_BUF_USED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PHYIDH
 * BLOCKS:   EPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.
 *
 ******************************************************************************/
#define BCM53600_A0_PHYIDHr 0x0000a004

#define BCM53600_A0_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDH.
 *
 */
typedef union BCM53600_A0_PHYIDHr_s {
	uint32_t v[1];
	uint32_t phyidh[1];
	uint32_t _phyidh;
} BCM53600_A0_PHYIDHr_t;

#define BCM53600_A0_PHYIDHr_CLR(r) (r).phyidh[0] = 0
#define BCM53600_A0_PHYIDHr_SET(r,d) (r).phyidh[0] = d
#define BCM53600_A0_PHYIDHr_GET(r) (r).phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PHYIDHr_MII_ADDRf_GET(r) (((r).phyidh[0]) & 0xffff)
#define BCM53600_A0_PHYIDHr_MII_ADDRf_SET(r,f) (r).phyidh[0]=(((r).phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDH.
 *
 */
#define BCM53600_A0_READ_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_PHYIDHr,(r._phyidh),2)
#define BCM53600_A0_WRITE_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_PHYIDHr,&(r._phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDHr BCM53600_A0_PHYIDHr
#define PHYIDHr_SIZE BCM53600_A0_PHYIDHr_SIZE
typedef BCM53600_A0_PHYIDHr_t PHYIDHr_t;
#define PHYIDHr_CLR BCM53600_A0_PHYIDHr_CLR
#define PHYIDHr_SET BCM53600_A0_PHYIDHr_SET
#define PHYIDHr_GET BCM53600_A0_PHYIDHr_GET
#define PHYIDHr_MII_ADDRf_GET BCM53600_A0_PHYIDHr_MII_ADDRf_GET
#define PHYIDHr_MII_ADDRf_SET BCM53600_A0_PHYIDHr_MII_ADDRf_SET
#define READ_PHYIDHr BCM53600_A0_READ_PHYIDHr
#define WRITE_PHYIDHr BCM53600_A0_WRITE_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PHYIDL
 * BLOCKS:   EPIC0
 * DESC:     PHY ID Low Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.Bit 3:2 - Revision ID- 00 = A- 01 = B- 10 = C- 11 = DBit 1:0 - Revision Number
 *
 ******************************************************************************/
#define BCM53600_A0_PHYIDLr 0x0000a006

#define BCM53600_A0_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDL.
 *
 */
typedef union BCM53600_A0_PHYIDLr_s {
	uint32_t v[1];
	uint32_t phyidl[1];
	uint32_t _phyidl;
} BCM53600_A0_PHYIDLr_t;

#define BCM53600_A0_PHYIDLr_CLR(r) (r).phyidl[0] = 0
#define BCM53600_A0_PHYIDLr_SET(r,d) (r).phyidl[0] = d
#define BCM53600_A0_PHYIDLr_GET(r) (r).phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PHYIDLr_MII_ADDRf_GET(r) (((r).phyidl[0]) & 0xffff)
#define BCM53600_A0_PHYIDLr_MII_ADDRf_SET(r,f) (r).phyidl[0]=(((r).phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDL.
 *
 */
#define BCM53600_A0_READ_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_PHYIDLr,(r._phyidl),2)
#define BCM53600_A0_WRITE_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_PHYIDLr,&(r._phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDLr BCM53600_A0_PHYIDLr
#define PHYIDLr_SIZE BCM53600_A0_PHYIDLr_SIZE
typedef BCM53600_A0_PHYIDLr_t PHYIDLr_t;
#define PHYIDLr_CLR BCM53600_A0_PHYIDLr_CLR
#define PHYIDLr_SET BCM53600_A0_PHYIDLr_SET
#define PHYIDLr_GET BCM53600_A0_PHYIDLr_GET
#define PHYIDLr_MII_ADDRf_GET BCM53600_A0_PHYIDLr_MII_ADDRf_GET
#define PHYIDLr_MII_ADDRf_SET BCM53600_A0_PHYIDLr_MII_ADDRf_SET
#define READ_PHYIDLr BCM53600_A0_READ_PHYIDLr
#define WRITE_PHYIDLr BCM53600_A0_WRITE_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PHYINFO_PHYIDH
 * BLOCKS:   SYS
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID
 *
 ******************************************************************************/
#define BCM53600_A0_PHYINFO_PHYIDHr 0x00001004

#define BCM53600_A0_PHYINFO_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program PHYINFO_PHYIDH.
 *
 */
typedef union BCM53600_A0_PHYINFO_PHYIDHr_s {
	uint32_t v[1];
	uint32_t phyinfo_phyidh[1];
	uint32_t _phyinfo_phyidh;
} BCM53600_A0_PHYINFO_PHYIDHr_t;

#define BCM53600_A0_PHYINFO_PHYIDHr_CLR(r) (r).phyinfo_phyidh[0] = 0
#define BCM53600_A0_PHYINFO_PHYIDHr_SET(r,d) (r).phyinfo_phyidh[0] = d
#define BCM53600_A0_PHYINFO_PHYIDHr_GET(r) (r).phyinfo_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PHYINFO_PHYIDHr_MII_ADDRf_GET(r) (((r).phyinfo_phyidh[0]) & 0xffff)
#define BCM53600_A0_PHYINFO_PHYIDHr_MII_ADDRf_SET(r,f) (r).phyinfo_phyidh[0]=(((r).phyinfo_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYINFO_PHYIDH.
 *
 */
#define BCM53600_A0_READ_PHYINFO_PHYIDHr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PHYINFO_PHYIDHr,(r._phyinfo_phyidh),2)
#define BCM53600_A0_WRITE_PHYINFO_PHYIDHr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PHYINFO_PHYIDHr,&(r._phyinfo_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYINFO_PHYIDHr BCM53600_A0_PHYINFO_PHYIDHr
#define PHYINFO_PHYIDHr_SIZE BCM53600_A0_PHYINFO_PHYIDHr_SIZE
typedef BCM53600_A0_PHYINFO_PHYIDHr_t PHYINFO_PHYIDHr_t;
#define PHYINFO_PHYIDHr_CLR BCM53600_A0_PHYINFO_PHYIDHr_CLR
#define PHYINFO_PHYIDHr_SET BCM53600_A0_PHYINFO_PHYIDHr_SET
#define PHYINFO_PHYIDHr_GET BCM53600_A0_PHYINFO_PHYIDHr_GET
#define PHYINFO_PHYIDHr_MII_ADDRf_GET BCM53600_A0_PHYINFO_PHYIDHr_MII_ADDRf_GET
#define PHYINFO_PHYIDHr_MII_ADDRf_SET BCM53600_A0_PHYINFO_PHYIDHr_MII_ADDRf_SET
#define READ_PHYINFO_PHYIDHr BCM53600_A0_READ_PHYINFO_PHYIDHr
#define WRITE_PHYINFO_PHYIDHr BCM53600_A0_WRITE_PHYINFO_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PHYINFO_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PHYINFO_PHYIDL
 * BLOCKS:   SYS
 * DESC:     PHY ID Low Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.Bit 3:2 - Revision ID- 00 = A- 01 = B- 10 = C- 11 = DBit 1:0 - Revision Number
 *
 ******************************************************************************/
#define BCM53600_A0_PHYINFO_PHYIDLr 0x00001006

#define BCM53600_A0_PHYINFO_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program PHYINFO_PHYIDL.
 *
 */
typedef union BCM53600_A0_PHYINFO_PHYIDLr_s {
	uint32_t v[1];
	uint32_t phyinfo_phyidl[1];
	uint32_t _phyinfo_phyidl;
} BCM53600_A0_PHYINFO_PHYIDLr_t;

#define BCM53600_A0_PHYINFO_PHYIDLr_CLR(r) (r).phyinfo_phyidl[0] = 0
#define BCM53600_A0_PHYINFO_PHYIDLr_SET(r,d) (r).phyinfo_phyidl[0] = d
#define BCM53600_A0_PHYINFO_PHYIDLr_GET(r) (r).phyinfo_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PHYINFO_PHYIDLr_MII_ADDRf_GET(r) (((r).phyinfo_phyidl[0]) & 0xffff)
#define BCM53600_A0_PHYINFO_PHYIDLr_MII_ADDRf_SET(r,f) (r).phyinfo_phyidl[0]=(((r).phyinfo_phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYINFO_PHYIDL.
 *
 */
#define BCM53600_A0_READ_PHYINFO_PHYIDLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PHYINFO_PHYIDLr,(r._phyinfo_phyidl),2)
#define BCM53600_A0_WRITE_PHYINFO_PHYIDLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PHYINFO_PHYIDLr,&(r._phyinfo_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYINFO_PHYIDLr BCM53600_A0_PHYINFO_PHYIDLr
#define PHYINFO_PHYIDLr_SIZE BCM53600_A0_PHYINFO_PHYIDLr_SIZE
typedef BCM53600_A0_PHYINFO_PHYIDLr_t PHYINFO_PHYIDLr_t;
#define PHYINFO_PHYIDLr_CLR BCM53600_A0_PHYINFO_PHYIDLr_CLR
#define PHYINFO_PHYIDLr_SET BCM53600_A0_PHYINFO_PHYIDLr_SET
#define PHYINFO_PHYIDLr_GET BCM53600_A0_PHYINFO_PHYIDLr_GET
#define PHYINFO_PHYIDLr_MII_ADDRf_GET BCM53600_A0_PHYINFO_PHYIDLr_MII_ADDRf_GET
#define PHYINFO_PHYIDLr_MII_ADDRf_SET BCM53600_A0_PHYINFO_PHYIDLr_MII_ADDRf_SET
#define READ_PHYINFO_PHYIDLr BCM53600_A0_READ_PHYINFO_PHYIDLr
#define WRITE_PHYINFO_PHYIDLr BCM53600_A0_WRITE_PHYINFO_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PHYINFO_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PHYSCAN_CTL
 * BLOCKS:   SYS
 * DESC:     PHY Scan Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_INIT_CFG      Enable initial configure.
 *     EN_PHY_SCAN      Enable PHY Scan.1'b1: Enable PHY scanning.1'b0: Disable PHY scanning.Default value is read from the inversed PHY_POLL_DIS pin on power-on. can be overwritten subsequently.
 *     RESERVED         Reserved
 *     PHY_START_ADDR   1'b0: PHY 0 address is 5'h00;1'b1: PHY 0 address is 5'h01,
 *
 ******************************************************************************/
#define BCM53600_A0_PHYSCAN_CTLr 0x00000002

#define BCM53600_A0_PHYSCAN_CTLr_SIZE 1

/*
 * This structure should be used to declare and program PHYSCAN_CTL.
 *
 */
typedef union BCM53600_A0_PHYSCAN_CTLr_s {
	uint32_t v[1];
	uint32_t physcan_ctl[1];
	uint32_t _physcan_ctl;
} BCM53600_A0_PHYSCAN_CTLr_t;

#define BCM53600_A0_PHYSCAN_CTLr_CLR(r) (r).physcan_ctl[0] = 0
#define BCM53600_A0_PHYSCAN_CTLr_SET(r,d) (r).physcan_ctl[0] = d
#define BCM53600_A0_PHYSCAN_CTLr_GET(r) (r).physcan_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PHYSCAN_CTLr_EN_INIT_CFGf_GET(r) (((r).physcan_ctl[0]) & 0x1)
#define BCM53600_A0_PHYSCAN_CTLr_EN_INIT_CFGf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_PHYSCAN_CTLr_EN_PHY_SCANf_GET(r) ((((r).physcan_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_PHYSCAN_CTLr_EN_PHY_SCANf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_PHYSCAN_CTLr_RESERVEDf_GET(r) ((((r).physcan_ctl[0]) >> 2) & 0x1f)
#define BCM53600_A0_PHYSCAN_CTLr_RESERVEDf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53600_A0_PHYSCAN_CTLr_PHY_START_ADDRf_GET(r) ((((r).physcan_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_PHYSCAN_CTLr_PHY_START_ADDRf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PHYSCAN_CTL.
 *
 */
#define BCM53600_A0_READ_PHYSCAN_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PHYSCAN_CTLr,(r._physcan_ctl),1)
#define BCM53600_A0_WRITE_PHYSCAN_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PHYSCAN_CTLr,&(r._physcan_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYSCAN_CTLr BCM53600_A0_PHYSCAN_CTLr
#define PHYSCAN_CTLr_SIZE BCM53600_A0_PHYSCAN_CTLr_SIZE
typedef BCM53600_A0_PHYSCAN_CTLr_t PHYSCAN_CTLr_t;
#define PHYSCAN_CTLr_CLR BCM53600_A0_PHYSCAN_CTLr_CLR
#define PHYSCAN_CTLr_SET BCM53600_A0_PHYSCAN_CTLr_SET
#define PHYSCAN_CTLr_GET BCM53600_A0_PHYSCAN_CTLr_GET
#define PHYSCAN_CTLr_EN_INIT_CFGf_GET BCM53600_A0_PHYSCAN_CTLr_EN_INIT_CFGf_GET
#define PHYSCAN_CTLr_EN_INIT_CFGf_SET BCM53600_A0_PHYSCAN_CTLr_EN_INIT_CFGf_SET
#define PHYSCAN_CTLr_EN_PHY_SCANf_GET BCM53600_A0_PHYSCAN_CTLr_EN_PHY_SCANf_GET
#define PHYSCAN_CTLr_EN_PHY_SCANf_SET BCM53600_A0_PHYSCAN_CTLr_EN_PHY_SCANf_SET
#define PHYSCAN_CTLr_RESERVEDf_GET BCM53600_A0_PHYSCAN_CTLr_RESERVEDf_GET
#define PHYSCAN_CTLr_RESERVEDf_SET BCM53600_A0_PHYSCAN_CTLr_RESERVEDf_SET
#define PHYSCAN_CTLr_PHY_START_ADDRf_GET BCM53600_A0_PHYSCAN_CTLr_PHY_START_ADDRf_GET
#define PHYSCAN_CTLr_PHY_START_ADDRf_SET BCM53600_A0_PHYSCAN_CTLr_PHY_START_ADDRf_SET
#define READ_PHYSCAN_CTLr BCM53600_A0_READ_PHYSCAN_CTLr
#define WRITE_PHYSCAN_CTLr BCM53600_A0_WRITE_PHYSCAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PHYSCAN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PKT_MARK_CTL
 * BLOCKS:   SYS
 * DESC:     Packet Marking Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *     EN_ECN_REMARK    Egress ECN marking control.1 : Enable.0 : Disable. 
 *     RESERVED_1       Reserved
 *     EN_PCP_MAPPING_AVB Egress TC/DP to PCP mapping is enabled for AVB packet(AV is enable in this port and the packet is queued in Class-A COS or Class-B). 1 : Enable. The egress PCP of AVB packet is gotten from the TC/DP to PCP mapping table.0 : Disable.The egress PCP of AVB packet is the same as received PCP.(Not2Release)  
 *
 ******************************************************************************/
#define BCM53600_A0_PKT_MARK_CTLr 0x00003001

#define BCM53600_A0_PKT_MARK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program PKT_MARK_CTL.
 *
 */
typedef union BCM53600_A0_PKT_MARK_CTLr_s {
	uint32_t v[1];
	uint32_t pkt_mark_ctl[1];
	uint32_t _pkt_mark_ctl;
} BCM53600_A0_PKT_MARK_CTLr_t;

#define BCM53600_A0_PKT_MARK_CTLr_CLR(r) (r).pkt_mark_ctl[0] = 0
#define BCM53600_A0_PKT_MARK_CTLr_SET(r,d) (r).pkt_mark_ctl[0] = d
#define BCM53600_A0_PKT_MARK_CTLr_GET(r) (r).pkt_mark_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PKT_MARK_CTLr_RESERVEDf_GET(r) (((r).pkt_mark_ctl[0]) & 0x1)
#define BCM53600_A0_PKT_MARK_CTLr_RESERVEDf_SET(r,f) (r).pkt_mark_ctl[0]=(((r).pkt_mark_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_PKT_MARK_CTLr_EN_ECN_REMARKf_GET(r) ((((r).pkt_mark_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_PKT_MARK_CTLr_EN_ECN_REMARKf_SET(r,f) (r).pkt_mark_ctl[0]=(((r).pkt_mark_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_PKT_MARK_CTLr_RESERVED_1f_GET(r) ((((r).pkt_mark_ctl[0]) >> 2) & 0x1f)
#define BCM53600_A0_PKT_MARK_CTLr_RESERVED_1f_SET(r,f) (r).pkt_mark_ctl[0]=(((r).pkt_mark_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53600_A0_PKT_MARK_CTLr_EN_PCP_MAPPING_AVBf_GET(r) ((((r).pkt_mark_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_PKT_MARK_CTLr_EN_PCP_MAPPING_AVBf_SET(r,f) (r).pkt_mark_ctl[0]=(((r).pkt_mark_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PKT_MARK_CTL.
 *
 */
#define BCM53600_A0_READ_PKT_MARK_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PKT_MARK_CTLr,(r._pkt_mark_ctl),1)
#define BCM53600_A0_WRITE_PKT_MARK_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PKT_MARK_CTLr,&(r._pkt_mark_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKT_MARK_CTLr BCM53600_A0_PKT_MARK_CTLr
#define PKT_MARK_CTLr_SIZE BCM53600_A0_PKT_MARK_CTLr_SIZE
typedef BCM53600_A0_PKT_MARK_CTLr_t PKT_MARK_CTLr_t;
#define PKT_MARK_CTLr_CLR BCM53600_A0_PKT_MARK_CTLr_CLR
#define PKT_MARK_CTLr_SET BCM53600_A0_PKT_MARK_CTLr_SET
#define PKT_MARK_CTLr_GET BCM53600_A0_PKT_MARK_CTLr_GET
#define PKT_MARK_CTLr_RESERVEDf_GET BCM53600_A0_PKT_MARK_CTLr_RESERVEDf_GET
#define PKT_MARK_CTLr_RESERVEDf_SET BCM53600_A0_PKT_MARK_CTLr_RESERVEDf_SET
#define PKT_MARK_CTLr_EN_ECN_REMARKf_GET BCM53600_A0_PKT_MARK_CTLr_EN_ECN_REMARKf_GET
#define PKT_MARK_CTLr_EN_ECN_REMARKf_SET BCM53600_A0_PKT_MARK_CTLr_EN_ECN_REMARKf_SET
#define PKT_MARK_CTLr_RESERVED_1f_GET BCM53600_A0_PKT_MARK_CTLr_RESERVED_1f_GET
#define PKT_MARK_CTLr_RESERVED_1f_SET BCM53600_A0_PKT_MARK_CTLr_RESERVED_1f_SET
#define PKT_MARK_CTLr_EN_PCP_MAPPING_AVBf_GET BCM53600_A0_PKT_MARK_CTLr_EN_PCP_MAPPING_AVBf_GET
#define PKT_MARK_CTLr_EN_PCP_MAPPING_AVBf_SET BCM53600_A0_PKT_MARK_CTLr_EN_PCP_MAPPING_AVBf_SET
#define READ_PKT_MARK_CTLr BCM53600_A0_READ_PKT_MARK_CTLr
#define WRITE_PKT_MARK_CTLr BCM53600_A0_WRITE_PKT_MARK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PKT_MARK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PLL_CTRL_0
 * BLOCKS:   SYS
 * DESC:     PLL Control 0 Registrer(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     I_NDIV_MODE      (Not2Release)
 *     I_NDIV_INT       N=75, use Integer only.(Not2Release)
 *     I_P1DIV          (Not2Release)
 *     I_P2DIV          (Not2Release)
 *     I_VCO_RNG        1600Mhz<VCO<3200Mhz.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *     I_PLL_CTRL       (Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PLL_CTRL_0r 0x000000c0

#define BCM53600_A0_PLL_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTRL_0.
 *
 */
typedef union BCM53600_A0_PLL_CTRL_0r_s {
	uint32_t v[1];
	uint32_t pll_ctrl_0[1];
	uint32_t _pll_ctrl_0;
} BCM53600_A0_PLL_CTRL_0r_t;

#define BCM53600_A0_PLL_CTRL_0r_CLR(r) (r).pll_ctrl_0[0] = 0
#define BCM53600_A0_PLL_CTRL_0r_SET(r,d) (r).pll_ctrl_0[0] = d
#define BCM53600_A0_PLL_CTRL_0r_GET(r) (r).pll_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PLL_CTRL_0r_I_NDIV_MODEf_GET(r) (((r).pll_ctrl_0[0]) & 0x7)
#define BCM53600_A0_PLL_CTRL_0r_I_NDIV_MODEf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_PLL_CTRL_0r_I_NDIV_INTf_GET(r) ((((r).pll_ctrl_0[0]) >> 3) & 0x1ff)
#define BCM53600_A0_PLL_CTRL_0r_I_NDIV_INTf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3))
#define BCM53600_A0_PLL_CTRL_0r_I_P1DIVf_GET(r) ((((r).pll_ctrl_0[0]) >> 12) & 0xf)
#define BCM53600_A0_PLL_CTRL_0r_I_P1DIVf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_PLL_CTRL_0r_I_P2DIVf_GET(r) ((((r).pll_ctrl_0[0]) >> 16) & 0xf)
#define BCM53600_A0_PLL_CTRL_0r_I_P2DIVf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53600_A0_PLL_CTRL_0r_I_VCO_RNGf_GET(r) ((((r).pll_ctrl_0[0]) >> 20) & 0x3)
#define BCM53600_A0_PLL_CTRL_0r_I_VCO_RNGf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53600_A0_PLL_CTRL_0r_RESERVEDf_GET(r) ((((r).pll_ctrl_0[0]) >> 22) & 0x3)
#define BCM53600_A0_PLL_CTRL_0r_RESERVEDf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_PLL_CTRL_0r_I_PLL_CTRLf_GET(r) ((((r).pll_ctrl_0[0]) >> 24) & 0xff)
#define BCM53600_A0_PLL_CTRL_0r_I_PLL_CTRLf_SET(r,f) (r).pll_ctrl_0[0]=(((r).pll_ctrl_0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PLL_CTRL_0.
 *
 */
#define BCM53600_A0_READ_PLL_CTRL_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_PLL_CTRL_0r,(r._pll_ctrl_0),4)
#define BCM53600_A0_WRITE_PLL_CTRL_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_PLL_CTRL_0r,&(r._pll_ctrl_0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRL_0r BCM53600_A0_PLL_CTRL_0r
#define PLL_CTRL_0r_SIZE BCM53600_A0_PLL_CTRL_0r_SIZE
typedef BCM53600_A0_PLL_CTRL_0r_t PLL_CTRL_0r_t;
#define PLL_CTRL_0r_CLR BCM53600_A0_PLL_CTRL_0r_CLR
#define PLL_CTRL_0r_SET BCM53600_A0_PLL_CTRL_0r_SET
#define PLL_CTRL_0r_GET BCM53600_A0_PLL_CTRL_0r_GET
#define PLL_CTRL_0r_I_NDIV_MODEf_GET BCM53600_A0_PLL_CTRL_0r_I_NDIV_MODEf_GET
#define PLL_CTRL_0r_I_NDIV_MODEf_SET BCM53600_A0_PLL_CTRL_0r_I_NDIV_MODEf_SET
#define PLL_CTRL_0r_I_NDIV_INTf_GET BCM53600_A0_PLL_CTRL_0r_I_NDIV_INTf_GET
#define PLL_CTRL_0r_I_NDIV_INTf_SET BCM53600_A0_PLL_CTRL_0r_I_NDIV_INTf_SET
#define PLL_CTRL_0r_I_P1DIVf_GET BCM53600_A0_PLL_CTRL_0r_I_P1DIVf_GET
#define PLL_CTRL_0r_I_P1DIVf_SET BCM53600_A0_PLL_CTRL_0r_I_P1DIVf_SET
#define PLL_CTRL_0r_I_P2DIVf_GET BCM53600_A0_PLL_CTRL_0r_I_P2DIVf_GET
#define PLL_CTRL_0r_I_P2DIVf_SET BCM53600_A0_PLL_CTRL_0r_I_P2DIVf_SET
#define PLL_CTRL_0r_I_VCO_RNGf_GET BCM53600_A0_PLL_CTRL_0r_I_VCO_RNGf_GET
#define PLL_CTRL_0r_I_VCO_RNGf_SET BCM53600_A0_PLL_CTRL_0r_I_VCO_RNGf_SET
#define PLL_CTRL_0r_RESERVEDf_GET BCM53600_A0_PLL_CTRL_0r_RESERVEDf_GET
#define PLL_CTRL_0r_RESERVEDf_SET BCM53600_A0_PLL_CTRL_0r_RESERVEDf_SET
#define PLL_CTRL_0r_I_PLL_CTRLf_GET BCM53600_A0_PLL_CTRL_0r_I_PLL_CTRLf_GET
#define PLL_CTRL_0r_I_PLL_CTRLf_SET BCM53600_A0_PLL_CTRL_0r_I_PLL_CTRLf_SET
#define READ_PLL_CTRL_0r BCM53600_A0_READ_PLL_CTRL_0r
#define WRITE_PLL_CTRL_0r BCM53600_A0_WRITE_PLL_CTRL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PLL_CTRL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PLL_CTRL_1
 * BLOCKS:   SYS
 * DESC:     PLL Control 1 Registrer(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     I_PLL_CTRL       (Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PLL_CTRL_1r 0x000000c4

#define BCM53600_A0_PLL_CTRL_1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTRL_1.
 *
 */
typedef union BCM53600_A0_PLL_CTRL_1r_s {
	uint32_t v[1];
	uint32_t pll_ctrl_1[1];
	uint32_t _pll_ctrl_1;
} BCM53600_A0_PLL_CTRL_1r_t;

#define BCM53600_A0_PLL_CTRL_1r_CLR(r) (r).pll_ctrl_1[0] = 0
#define BCM53600_A0_PLL_CTRL_1r_SET(r,d) (r).pll_ctrl_1[0] = d
#define BCM53600_A0_PLL_CTRL_1r_GET(r) (r).pll_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PLL_CTRL_1r_I_PLL_CTRLf_GET(r) (((r).pll_ctrl_1[0]) & 0x3fffffff)
#define BCM53600_A0_PLL_CTRL_1r_I_PLL_CTRLf_SET(r,f) (r).pll_ctrl_1[0]=(((r).pll_ctrl_1[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM53600_A0_PLL_CTRL_1r_RESERVEDf_GET(r) ((((r).pll_ctrl_1[0]) >> 30) & 0x3)
#define BCM53600_A0_PLL_CTRL_1r_RESERVEDf_SET(r,f) (r).pll_ctrl_1[0]=(((r).pll_ctrl_1[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access PLL_CTRL_1.
 *
 */
#define BCM53600_A0_READ_PLL_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_PLL_CTRL_1r,(r._pll_ctrl_1),4)
#define BCM53600_A0_WRITE_PLL_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_PLL_CTRL_1r,&(r._pll_ctrl_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRL_1r BCM53600_A0_PLL_CTRL_1r
#define PLL_CTRL_1r_SIZE BCM53600_A0_PLL_CTRL_1r_SIZE
typedef BCM53600_A0_PLL_CTRL_1r_t PLL_CTRL_1r_t;
#define PLL_CTRL_1r_CLR BCM53600_A0_PLL_CTRL_1r_CLR
#define PLL_CTRL_1r_SET BCM53600_A0_PLL_CTRL_1r_SET
#define PLL_CTRL_1r_GET BCM53600_A0_PLL_CTRL_1r_GET
#define PLL_CTRL_1r_I_PLL_CTRLf_GET BCM53600_A0_PLL_CTRL_1r_I_PLL_CTRLf_GET
#define PLL_CTRL_1r_I_PLL_CTRLf_SET BCM53600_A0_PLL_CTRL_1r_I_PLL_CTRLf_SET
#define PLL_CTRL_1r_RESERVEDf_GET BCM53600_A0_PLL_CTRL_1r_RESERVEDf_GET
#define PLL_CTRL_1r_RESERVEDf_SET BCM53600_A0_PLL_CTRL_1r_RESERVEDf_SET
#define READ_PLL_CTRL_1r BCM53600_A0_READ_PLL_CTRL_1r
#define WRITE_PLL_CTRL_1r BCM53600_A0_WRITE_PLL_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PLL_CTRL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PLL_CTRL_2
 * BLOCKS:   SYS
 * DESC:     PLL Control 2 Registrer(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     I_PWRDRN_CH1     (Not2Release)
 *     RESERVED_0       Reserved(Not2Release)
 *     I_DLY_CH1        (Not2Release)
 *     RESERVED_1       Reserved(Not2Release)
 *     I_M1DIV          M=6(Not2Release)
 *     RESERVED_2       Reserved(Not2Release)
 *     I_TEST_SEL       Test mode clock select:000=VCO Vcontrol(default)001=VCO/8 clock010=frefi011=fdbki100=watchdog timer reset output101=clkout1110=clkout2111=clk0ut3 (Not2Release)
 *     I_TEST_EN        Test mode output enable:0=testout in High-Z state.(default)1=testout active.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PLL_CTRL_2r 0x000000c8

#define BCM53600_A0_PLL_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTRL_2.
 *
 */
typedef union BCM53600_A0_PLL_CTRL_2r_s {
	uint32_t v[1];
	uint32_t pll_ctrl_2[1];
	uint32_t _pll_ctrl_2;
} BCM53600_A0_PLL_CTRL_2r_t;

#define BCM53600_A0_PLL_CTRL_2r_CLR(r) (r).pll_ctrl_2[0] = 0
#define BCM53600_A0_PLL_CTRL_2r_SET(r,d) (r).pll_ctrl_2[0] = d
#define BCM53600_A0_PLL_CTRL_2r_GET(r) (r).pll_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PLL_CTRL_2r_I_PWRDRN_CH1f_GET(r) (((r).pll_ctrl_2[0]) & 0x1)
#define BCM53600_A0_PLL_CTRL_2r_I_PWRDRN_CH1f_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_PLL_CTRL_2r_RESERVED_0f_GET(r) ((((r).pll_ctrl_2[0]) >> 1) & 0x7)
#define BCM53600_A0_PLL_CTRL_2r_RESERVED_0f_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53600_A0_PLL_CTRL_2r_I_DLY_CH1f_GET(r) ((((r).pll_ctrl_2[0]) >> 4) & 0x3)
#define BCM53600_A0_PLL_CTRL_2r_I_DLY_CH1f_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53600_A0_PLL_CTRL_2r_RESERVED_1f_GET(r) ((((r).pll_ctrl_2[0]) >> 6) & 0x3)
#define BCM53600_A0_PLL_CTRL_2r_RESERVED_1f_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_PLL_CTRL_2r_I_M1DIVf_GET(r) ((((r).pll_ctrl_2[0]) >> 8) & 0xff)
#define BCM53600_A0_PLL_CTRL_2r_I_M1DIVf_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_PLL_CTRL_2r_RESERVED_2f_GET(r) ((((r).pll_ctrl_2[0]) >> 16) & 0xfff)
#define BCM53600_A0_PLL_CTRL_2r_RESERVED_2f_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_PLL_CTRL_2r_I_TEST_SELf_GET(r) ((((r).pll_ctrl_2[0]) >> 28) & 0x7)
#define BCM53600_A0_PLL_CTRL_2r_I_TEST_SELf_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53600_A0_PLL_CTRL_2r_I_TEST_ENf_GET(r) ((((r).pll_ctrl_2[0]) >> 31) & 0x1)
#define BCM53600_A0_PLL_CTRL_2r_I_TEST_ENf_SET(r,f) (r).pll_ctrl_2[0]=(((r).pll_ctrl_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PLL_CTRL_2.
 *
 */
#define BCM53600_A0_READ_PLL_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_PLL_CTRL_2r,(r._pll_ctrl_2),4)
#define BCM53600_A0_WRITE_PLL_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_PLL_CTRL_2r,&(r._pll_ctrl_2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRL_2r BCM53600_A0_PLL_CTRL_2r
#define PLL_CTRL_2r_SIZE BCM53600_A0_PLL_CTRL_2r_SIZE
typedef BCM53600_A0_PLL_CTRL_2r_t PLL_CTRL_2r_t;
#define PLL_CTRL_2r_CLR BCM53600_A0_PLL_CTRL_2r_CLR
#define PLL_CTRL_2r_SET BCM53600_A0_PLL_CTRL_2r_SET
#define PLL_CTRL_2r_GET BCM53600_A0_PLL_CTRL_2r_GET
#define PLL_CTRL_2r_I_PWRDRN_CH1f_GET BCM53600_A0_PLL_CTRL_2r_I_PWRDRN_CH1f_GET
#define PLL_CTRL_2r_I_PWRDRN_CH1f_SET BCM53600_A0_PLL_CTRL_2r_I_PWRDRN_CH1f_SET
#define PLL_CTRL_2r_RESERVED_0f_GET BCM53600_A0_PLL_CTRL_2r_RESERVED_0f_GET
#define PLL_CTRL_2r_RESERVED_0f_SET BCM53600_A0_PLL_CTRL_2r_RESERVED_0f_SET
#define PLL_CTRL_2r_I_DLY_CH1f_GET BCM53600_A0_PLL_CTRL_2r_I_DLY_CH1f_GET
#define PLL_CTRL_2r_I_DLY_CH1f_SET BCM53600_A0_PLL_CTRL_2r_I_DLY_CH1f_SET
#define PLL_CTRL_2r_RESERVED_1f_GET BCM53600_A0_PLL_CTRL_2r_RESERVED_1f_GET
#define PLL_CTRL_2r_RESERVED_1f_SET BCM53600_A0_PLL_CTRL_2r_RESERVED_1f_SET
#define PLL_CTRL_2r_I_M1DIVf_GET BCM53600_A0_PLL_CTRL_2r_I_M1DIVf_GET
#define PLL_CTRL_2r_I_M1DIVf_SET BCM53600_A0_PLL_CTRL_2r_I_M1DIVf_SET
#define PLL_CTRL_2r_RESERVED_2f_GET BCM53600_A0_PLL_CTRL_2r_RESERVED_2f_GET
#define PLL_CTRL_2r_RESERVED_2f_SET BCM53600_A0_PLL_CTRL_2r_RESERVED_2f_SET
#define PLL_CTRL_2r_I_TEST_SELf_GET BCM53600_A0_PLL_CTRL_2r_I_TEST_SELf_GET
#define PLL_CTRL_2r_I_TEST_SELf_SET BCM53600_A0_PLL_CTRL_2r_I_TEST_SELf_SET
#define PLL_CTRL_2r_I_TEST_ENf_GET BCM53600_A0_PLL_CTRL_2r_I_TEST_ENf_GET
#define PLL_CTRL_2r_I_TEST_ENf_SET BCM53600_A0_PLL_CTRL_2r_I_TEST_ENf_SET
#define READ_PLL_CTRL_2r BCM53600_A0_READ_PLL_CTRL_2r
#define WRITE_PLL_CTRL_2r BCM53600_A0_WRITE_PLL_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PLL_CTRL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PORTVEC1
 * BLOCKS:   SYS
 * DESC:     L2 User Vector 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        L2 User Vector 1A bit mask corresponding to the physical ports on the chip. A frame with a DA matching the content of the L2 User Address 1 register will be forwarded to each port with a bit set in the L2 User Vector 1 bit map.Bits 0-23: FE PortsBit 24: IMP PortsBit 25: Giga Port G0Bit 26: Giga port G1Bit 27: Giga Port G2Bit 28: Giga port G3
 *     PORTVEC_RSRV0    Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_PORTVEC1r 0x00000418

#define BCM53600_A0_PORTVEC1r_SIZE 4

/*
 * This structure should be used to declare and program PORTVEC1.
 *
 */
typedef union BCM53600_A0_PORTVEC1r_s {
	uint32_t v[1];
	uint32_t portvec1[1];
	uint32_t _portvec1;
} BCM53600_A0_PORTVEC1r_t;

#define BCM53600_A0_PORTVEC1r_CLR(r) (r).portvec1[0] = 0
#define BCM53600_A0_PORTVEC1r_SET(r,d) (r).portvec1[0] = d
#define BCM53600_A0_PORTVEC1r_GET(r) (r).portvec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PORTVEC1r_PORT_VCTRf_GET(r) (((r).portvec1[0]) & 0x1fffffff)
#define BCM53600_A0_PORTVEC1r_PORT_VCTRf_SET(r,f) (r).portvec1[0]=(((r).portvec1[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_PORTVEC1r_PORTVEC_RSRV0f_GET(r) ((((r).portvec1[0]) >> 29) & 0x7)
#define BCM53600_A0_PORTVEC1r_PORTVEC_RSRV0f_SET(r,f) (r).portvec1[0]=(((r).portvec1[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access PORTVEC1.
 *
 */
#define BCM53600_A0_READ_PORTVEC1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_PORTVEC1r,(r._portvec1),4)
#define BCM53600_A0_WRITE_PORTVEC1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_PORTVEC1r,&(r._portvec1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORTVEC1r BCM53600_A0_PORTVEC1r
#define PORTVEC1r_SIZE BCM53600_A0_PORTVEC1r_SIZE
typedef BCM53600_A0_PORTVEC1r_t PORTVEC1r_t;
#define PORTVEC1r_CLR BCM53600_A0_PORTVEC1r_CLR
#define PORTVEC1r_SET BCM53600_A0_PORTVEC1r_SET
#define PORTVEC1r_GET BCM53600_A0_PORTVEC1r_GET
#define PORTVEC1r_PORT_VCTRf_GET BCM53600_A0_PORTVEC1r_PORT_VCTRf_GET
#define PORTVEC1r_PORT_VCTRf_SET BCM53600_A0_PORTVEC1r_PORT_VCTRf_SET
#define PORTVEC1r_PORTVEC_RSRV0f_GET BCM53600_A0_PORTVEC1r_PORTVEC_RSRV0f_GET
#define PORTVEC1r_PORTVEC_RSRV0f_SET BCM53600_A0_PORTVEC1r_PORTVEC_RSRV0f_SET
#define READ_PORTVEC1r BCM53600_A0_READ_PORTVEC1r
#define WRITE_PORTVEC1r BCM53600_A0_WRITE_PORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PORTVEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PORTVEC2
 * BLOCKS:   SYS
 * DESC:     L2 User Vector 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        L2 User Vector 2A bit mask corresponding to the physical ports on the chip. A frame with a DA matching the content of the L2 User Address 2 register will be forwarded to each port with a bit set in the L2 User Vector 2 bit map.Bits 0-23: FE PortsBit 24: MII PortBit 25: Giga port G0Bit 26: Giga Port G1Bit 27: Giga port G2Bit 28: Giga Port G3
 *     PORTVEC_RSRV0    Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_PORTVEC2r 0x00000428

#define BCM53600_A0_PORTVEC2r_SIZE 4

/*
 * This structure should be used to declare and program PORTVEC2.
 *
 */
typedef union BCM53600_A0_PORTVEC2r_s {
	uint32_t v[1];
	uint32_t portvec2[1];
	uint32_t _portvec2;
} BCM53600_A0_PORTVEC2r_t;

#define BCM53600_A0_PORTVEC2r_CLR(r) (r).portvec2[0] = 0
#define BCM53600_A0_PORTVEC2r_SET(r,d) (r).portvec2[0] = d
#define BCM53600_A0_PORTVEC2r_GET(r) (r).portvec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PORTVEC2r_PORT_VCTRf_GET(r) (((r).portvec2[0]) & 0x1fffffff)
#define BCM53600_A0_PORTVEC2r_PORT_VCTRf_SET(r,f) (r).portvec2[0]=(((r).portvec2[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_PORTVEC2r_PORTVEC_RSRV0f_GET(r) ((((r).portvec2[0]) >> 29) & 0x7)
#define BCM53600_A0_PORTVEC2r_PORTVEC_RSRV0f_SET(r,f) (r).portvec2[0]=(((r).portvec2[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access PORTVEC2.
 *
 */
#define BCM53600_A0_READ_PORTVEC2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_PORTVEC2r,(r._portvec2),4)
#define BCM53600_A0_WRITE_PORTVEC2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_PORTVEC2r,&(r._portvec2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORTVEC2r BCM53600_A0_PORTVEC2r
#define PORTVEC2r_SIZE BCM53600_A0_PORTVEC2r_SIZE
typedef BCM53600_A0_PORTVEC2r_t PORTVEC2r_t;
#define PORTVEC2r_CLR BCM53600_A0_PORTVEC2r_CLR
#define PORTVEC2r_SET BCM53600_A0_PORTVEC2r_SET
#define PORTVEC2r_GET BCM53600_A0_PORTVEC2r_GET
#define PORTVEC2r_PORT_VCTRf_GET BCM53600_A0_PORTVEC2r_PORT_VCTRf_GET
#define PORTVEC2r_PORT_VCTRf_SET BCM53600_A0_PORTVEC2r_PORT_VCTRf_SET
#define PORTVEC2r_PORTVEC_RSRV0f_GET BCM53600_A0_PORTVEC2r_PORTVEC_RSRV0f_GET
#define PORTVEC2r_PORTVEC_RSRV0f_SET BCM53600_A0_PORTVEC2r_PORTVEC_RSRV0f_SET
#define READ_PORTVEC2r BCM53600_A0_READ_PORTVEC2r
#define WRITE_PORTVEC2r BCM53600_A0_WRITE_PORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PORTVEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  PORT_MASK
 * BLOCKS:   SYS
 * DESC:     PORT MASK Table
 * SIZE:     160
 * FIELDS:
 *     MASK_ANY         MASK_ANY
 *     MASK_DLF_UCST    MASK_DLF_UCST
 *     MASK_DLF_L2MCST  MASK_DLF_L2MCST
 *     MASK_DLF_L3MCAST MASK_DLF_L3MCAST
 *     MASK_BCST        MASK_BCST
 *     PORT_CONFIG      PORT_CONFIG
 *
 ******************************************************************************/
#define BCM53600_A0_PORT_MASKm 0x00000000

#define BCM53600_A0_PORT_MASKm_MIN 0
#define BCM53600_A0_PORT_MASKm_MAX 28
#define BCM53600_A0_PORT_MASKm_CMAX(u) 28
#define BCM53600_A0_PORT_MASKm_SIZE 20

/*
 * This structure should be used to declare and program PORT_MASK.
 *
 */
typedef union BCM53600_A0_PORT_MASKm_s {
	uint32_t v[5];
	uint32_t port_mask[5];
	uint32_t _port_mask;
} BCM53600_A0_PORT_MASKm_t;

#define BCM53600_A0_PORT_MASKm_CLR(r) CDK_MEMSET(&((r)._port_mask), 0, sizeof(BCM53600_A0_PORT_MASKm_t))
#define BCM53600_A0_PORT_MASKm_SET(r,i,d) (r).port_mask[i] = d
#define BCM53600_A0_PORT_MASKm_GET(r,i) (r).port_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PORT_MASKm_MASK_ANYf_GET(r) (((r).port_mask[0]) & 0x1fffffff)
#define BCM53600_A0_PORT_MASKm_MASK_ANYf_SET(r,f) (r).port_mask[0]=(((r).port_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_PORT_MASKm_MASK_DLF_UCSTf_GET(r) cdk_field32_get((r).port_mask,29,57)
#define BCM53600_A0_PORT_MASKm_MASK_DLF_UCSTf_SET(r,f) cdk_field32_set((r).port_mask,29,57,f)
#define BCM53600_A0_PORT_MASKm_MASK_DLF_L2MCSTf_GET(r) cdk_field32_get((r).port_mask,58,86)
#define BCM53600_A0_PORT_MASKm_MASK_DLF_L2MCSTf_SET(r,f) cdk_field32_set((r).port_mask,58,86,f)
#define BCM53600_A0_PORT_MASKm_MASK_DLF_L3MCASTf_GET(r) cdk_field32_get((r).port_mask,87,115)
#define BCM53600_A0_PORT_MASKm_MASK_DLF_L3MCASTf_SET(r,f) cdk_field32_set((r).port_mask,87,115,f)
#define BCM53600_A0_PORT_MASKm_MASK_BCSTf_GET(r) cdk_field32_get((r).port_mask,116,144)
#define BCM53600_A0_PORT_MASKm_MASK_BCSTf_SET(r,f) cdk_field32_set((r).port_mask,116,144,f)
#define BCM53600_A0_PORT_MASKm_PORT_CONFIGf_GET(r) ((((r).port_mask[4]) >> 17) & 0x7fff)
#define BCM53600_A0_PORT_MASKm_PORT_CONFIGf_SET(r,f) (r).port_mask[4]=(((r).port_mask[4] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access PORT_MASK.
 *
 */
#define BCM53600_A0_READ_PORT_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_PORT_MASKm,i,(m),20)
#define BCM53600_A0_WRITE_PORT_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_PORT_MASKm,i,&(m),20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_MASKm BCM53600_A0_PORT_MASKm
#define PORT_MASKm_MIN BCM53600_A0_PORT_MASKm_MIN
#define PORT_MASKm_MAX BCM53600_A0_PORT_MASKm_MAX
#define PORT_MASKm_CMAX(u) BCM53600_A0_PORT_MASKm_CMAX(u)
#define PORT_MASKm_SIZE BCM53600_A0_PORT_MASKm_SIZE
typedef BCM53600_A0_PORT_MASKm_t PORT_MASKm_t;
#define PORT_MASKm_CLR BCM53600_A0_PORT_MASKm_CLR
#define PORT_MASKm_SET BCM53600_A0_PORT_MASKm_SET
#define PORT_MASKm_GET BCM53600_A0_PORT_MASKm_GET
#define PORT_MASKm_MASK_ANYf_GET BCM53600_A0_PORT_MASKm_MASK_ANYf_GET
#define PORT_MASKm_MASK_ANYf_SET BCM53600_A0_PORT_MASKm_MASK_ANYf_SET
#define PORT_MASKm_MASK_DLF_UCSTf_GET BCM53600_A0_PORT_MASKm_MASK_DLF_UCSTf_GET
#define PORT_MASKm_MASK_DLF_UCSTf_SET BCM53600_A0_PORT_MASKm_MASK_DLF_UCSTf_SET
#define PORT_MASKm_MASK_DLF_L2MCSTf_GET BCM53600_A0_PORT_MASKm_MASK_DLF_L2MCSTf_GET
#define PORT_MASKm_MASK_DLF_L2MCSTf_SET BCM53600_A0_PORT_MASKm_MASK_DLF_L2MCSTf_SET
#define PORT_MASKm_MASK_DLF_L3MCASTf_GET BCM53600_A0_PORT_MASKm_MASK_DLF_L3MCASTf_GET
#define PORT_MASKm_MASK_DLF_L3MCASTf_SET BCM53600_A0_PORT_MASKm_MASK_DLF_L3MCASTf_SET
#define PORT_MASKm_MASK_BCSTf_GET BCM53600_A0_PORT_MASKm_MASK_BCSTf_GET
#define PORT_MASKm_MASK_BCSTf_SET BCM53600_A0_PORT_MASKm_MASK_BCSTf_SET
#define PORT_MASKm_PORT_CONFIGf_GET BCM53600_A0_PORT_MASKm_PORT_CONFIGf_GET
#define PORT_MASKm_PORT_CONFIGf_SET BCM53600_A0_PORT_MASKm_PORT_CONFIGf_SET
#define READ_PORT_MASKm BCM53600_A0_READ_PORT_MASKm
#define WRITE_PORT_MASKm BCM53600_A0_WRITE_PORT_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PORT_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PORT_XOFF_STS
 * BLOCKS:   SYS
 * DESC:     Port XOFF Status Summary Register
 * SIZE:     64
 * FIELDS:
 *     PAUSE_STS_FE     XOFF State for FE ports.A 48bit field to indicate the XOFF state for each 10/100 BASE-T port.1).In full duplex mode, the transmit/receive pause capability is enabledwhen XOFF state is enabled.2).In half duplex mode, the transmit jam capability is enabled when XOFFstate is enabled.Two bit for each port. Bits 47:0 - 10/100 ports[port23-port0] respectatively.BIT 0 = 0, XOFF state is disabled.Bit 0 = 1, XOFF state is enabled.Bit 1 = Reserved.
 *     PAUSE_STS_IMP    XOFF State for IMP Port.Bit1 : for TX pause capability.Bit0 : for RX pause capability.
 *     PAUSE_STS_G0     XOFF State for Giga Port G0.Bit1 : for TX pause capability.Bit0 : for RX pause capability.
 *     PAUSE_STS_G1     XOFF State for Giga Port G1.Bit1 : for TX pause capability.Bit0 : for RX pause capability.
 *     PAUSE_STS_G2     XOFF State for Giga Port G2.Bit1 : for TX pause capability.Bit0 : for RX pause capability.
 *     PAUSE_STS_G3     XOFF State for Giga Port G3.Bit1 : for TX pause capability.Bit0 : for RX pause capability.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_PORT_XOFF_STSr 0x00000238

#define BCM53600_A0_PORT_XOFF_STSr_SIZE 8

/*
 * This structure should be used to declare and program PORT_XOFF_STS.
 *
 */
typedef union BCM53600_A0_PORT_XOFF_STSr_s {
	uint32_t v[2];
	uint32_t port_xoff_sts[2];
	uint32_t _port_xoff_sts;
} BCM53600_A0_PORT_XOFF_STSr_t;

#define BCM53600_A0_PORT_XOFF_STSr_CLR(r) CDK_MEMSET(&((r)._port_xoff_sts), 0, sizeof(BCM53600_A0_PORT_XOFF_STSr_t))
#define BCM53600_A0_PORT_XOFF_STSr_SET(r,i,d) (r).port_xoff_sts[i] = d
#define BCM53600_A0_PORT_XOFF_STSr_GET(r,i) (r).port_xoff_sts[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_FEf_GET(r,a) cdk_field_get((r).port_xoff_sts,0,47,a)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_FEf_SET(r,a) cdk_field_set((r).port_xoff_sts,0,47,a)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_IMPf_GET(r) ((((r).port_xoff_sts[1]) >> 16) & 0x3)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_IMPf_SET(r,f) (r).port_xoff_sts[1]=(((r).port_xoff_sts[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G0f_GET(r) ((((r).port_xoff_sts[1]) >> 18) & 0x3)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G0f_SET(r,f) (r).port_xoff_sts[1]=(((r).port_xoff_sts[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G1f_GET(r) ((((r).port_xoff_sts[1]) >> 20) & 0x3)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G1f_SET(r,f) (r).port_xoff_sts[1]=(((r).port_xoff_sts[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G2f_GET(r) ((((r).port_xoff_sts[1]) >> 22) & 0x3)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G2f_SET(r,f) (r).port_xoff_sts[1]=(((r).port_xoff_sts[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G3f_GET(r) ((((r).port_xoff_sts[1]) >> 24) & 0x3)
#define BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G3f_SET(r,f) (r).port_xoff_sts[1]=(((r).port_xoff_sts[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53600_A0_PORT_XOFF_STSr_RESERVED_1f_GET(r) ((((r).port_xoff_sts[1]) >> 26) & 0x3f)
#define BCM53600_A0_PORT_XOFF_STSr_RESERVED_1f_SET(r,f) (r).port_xoff_sts[1]=(((r).port_xoff_sts[1] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access PORT_XOFF_STS.
 *
 */
#define BCM53600_A0_READ_PORT_XOFF_STSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PORT_XOFF_STSr,(r._port_xoff_sts),8)
#define BCM53600_A0_WRITE_PORT_XOFF_STSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PORT_XOFF_STSr,&(r._port_xoff_sts),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_XOFF_STSr BCM53600_A0_PORT_XOFF_STSr
#define PORT_XOFF_STSr_SIZE BCM53600_A0_PORT_XOFF_STSr_SIZE
typedef BCM53600_A0_PORT_XOFF_STSr_t PORT_XOFF_STSr_t;
#define PORT_XOFF_STSr_CLR BCM53600_A0_PORT_XOFF_STSr_CLR
#define PORT_XOFF_STSr_SET BCM53600_A0_PORT_XOFF_STSr_SET
#define PORT_XOFF_STSr_GET BCM53600_A0_PORT_XOFF_STSr_GET
#define PORT_XOFF_STSr_PAUSE_STS_FEf_GET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_FEf_GET
#define PORT_XOFF_STSr_PAUSE_STS_FEf_SET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_FEf_SET
#define PORT_XOFF_STSr_PAUSE_STS_IMPf_GET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_IMPf_GET
#define PORT_XOFF_STSr_PAUSE_STS_IMPf_SET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_IMPf_SET
#define PORT_XOFF_STSr_PAUSE_STS_G0f_GET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G0f_GET
#define PORT_XOFF_STSr_PAUSE_STS_G0f_SET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G0f_SET
#define PORT_XOFF_STSr_PAUSE_STS_G1f_GET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G1f_GET
#define PORT_XOFF_STSr_PAUSE_STS_G1f_SET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G1f_SET
#define PORT_XOFF_STSr_PAUSE_STS_G2f_GET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G2f_GET
#define PORT_XOFF_STSr_PAUSE_STS_G2f_SET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G2f_SET
#define PORT_XOFF_STSr_PAUSE_STS_G3f_GET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G3f_GET
#define PORT_XOFF_STSr_PAUSE_STS_G3f_SET BCM53600_A0_PORT_XOFF_STSr_PAUSE_STS_G3f_SET
#define PORT_XOFF_STSr_RESERVED_1f_GET BCM53600_A0_PORT_XOFF_STSr_RESERVED_1f_GET
#define PORT_XOFF_STSr_RESERVED_1f_SET BCM53600_A0_PORT_XOFF_STSr_RESERVED_1f_SET
#define READ_PORT_XOFF_STSr BCM53600_A0_READ_PORT_XOFF_STSr
#define WRITE_PORT_XOFF_STSr BCM53600_A0_WRITE_PORT_XOFF_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PORT_XOFF_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PROFILE_CTL
 * BLOCKS:   SYS
 * DESC:     Profile Control Registers
 * SIZE:     8
 * FIELDS:
 *     EVM_MISS_PROFILE_CTL Profile setting for S-Tag modification instruction when EVM missed inVT_MODE=00(VT_ENABLE=0, V_DOMAIN=0).Bit0:for profile-00Bit1:for profile-01Bit2:for profile-10Bit3:for profile-11 - 1'b0:Remove - 1'b1:As Is
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_PROFILE_CTLr 0x00003404

#define BCM53600_A0_PROFILE_CTLr_SIZE 1

/*
 * This structure should be used to declare and program PROFILE_CTL.
 *
 */
typedef union BCM53600_A0_PROFILE_CTLr_s {
	uint32_t v[1];
	uint32_t profile_ctl[1];
	uint32_t _profile_ctl;
} BCM53600_A0_PROFILE_CTLr_t;

#define BCM53600_A0_PROFILE_CTLr_CLR(r) (r).profile_ctl[0] = 0
#define BCM53600_A0_PROFILE_CTLr_SET(r,d) (r).profile_ctl[0] = d
#define BCM53600_A0_PROFILE_CTLr_GET(r) (r).profile_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PROFILE_CTLr_EVM_MISS_PROFILE_CTLf_GET(r) (((r).profile_ctl[0]) & 0xf)
#define BCM53600_A0_PROFILE_CTLr_EVM_MISS_PROFILE_CTLf_SET(r,f) (r).profile_ctl[0]=(((r).profile_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_PROFILE_CTLr_RESERVEDf_GET(r) ((((r).profile_ctl[0]) >> 4) & 0xf)
#define BCM53600_A0_PROFILE_CTLr_RESERVEDf_SET(r,f) (r).profile_ctl[0]=(((r).profile_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PROFILE_CTL.
 *
 */
#define BCM53600_A0_READ_PROFILE_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PROFILE_CTLr,(r._profile_ctl),1)
#define BCM53600_A0_WRITE_PROFILE_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PROFILE_CTLr,&(r._profile_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROFILE_CTLr BCM53600_A0_PROFILE_CTLr
#define PROFILE_CTLr_SIZE BCM53600_A0_PROFILE_CTLr_SIZE
typedef BCM53600_A0_PROFILE_CTLr_t PROFILE_CTLr_t;
#define PROFILE_CTLr_CLR BCM53600_A0_PROFILE_CTLr_CLR
#define PROFILE_CTLr_SET BCM53600_A0_PROFILE_CTLr_SET
#define PROFILE_CTLr_GET BCM53600_A0_PROFILE_CTLr_GET
#define PROFILE_CTLr_EVM_MISS_PROFILE_CTLf_GET BCM53600_A0_PROFILE_CTLr_EVM_MISS_PROFILE_CTLf_GET
#define PROFILE_CTLr_EVM_MISS_PROFILE_CTLf_SET BCM53600_A0_PROFILE_CTLr_EVM_MISS_PROFILE_CTLf_SET
#define PROFILE_CTLr_RESERVEDf_GET BCM53600_A0_PROFILE_CTLr_RESERVEDf_GET
#define PROFILE_CTLr_RESERVEDf_SET BCM53600_A0_PROFILE_CTLr_RESERVEDf_SET
#define READ_PROFILE_CTLr BCM53600_A0_READ_PROFILE_CTLr
#define WRITE_PROFILE_CTLr BCM53600_A0_WRITE_PROFILE_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PROFILE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  PWR_DOWN_MODE
 * BLOCKS:   SYS
 * DESC:     Power Down Mode Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     PORTX_PWR_DOWN   Octal_EPHY power down register.Disables all clocking to an individual PHY port.0: PHY is enabled.1: PHY is disabled.bit23~bit0 for port23 ~ port0,(Not2Release)
 *     PWR_DOWN_RESERVED_0 Reserved(Not2Release)
 *     GPORTX_PWR_DOWN  Giga ports power down register.Disables all clocking to an individual giga port serdes.0: Serdes is enabled.1: Serdes is disabled.bit27 for port 27(G2), bit28 for port 28(G3)(Not2Release)
 *     PWR_DOWN_RESERVED_1 Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_PWR_DOWN_MODEr 0x00000004

#define BCM53600_A0_PWR_DOWN_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PWR_DOWN_MODE.
 *
 */
typedef union BCM53600_A0_PWR_DOWN_MODEr_s {
	uint32_t v[1];
	uint32_t pwr_down_mode[1];
	uint32_t _pwr_down_mode;
} BCM53600_A0_PWR_DOWN_MODEr_t;

#define BCM53600_A0_PWR_DOWN_MODEr_CLR(r) (r).pwr_down_mode[0] = 0
#define BCM53600_A0_PWR_DOWN_MODEr_SET(r,d) (r).pwr_down_mode[0] = d
#define BCM53600_A0_PWR_DOWN_MODEr_GET(r) (r).pwr_down_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_GET(r) (((r).pwr_down_mode[0]) & 0xffffff)
#define BCM53600_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_SET(r,f) (r).pwr_down_mode[0]=(((r).pwr_down_mode[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_0f_GET(r) ((((r).pwr_down_mode[0]) >> 24) & 0x7)
#define BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_0f_SET(r,f) (r).pwr_down_mode[0]=(((r).pwr_down_mode[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53600_A0_PWR_DOWN_MODEr_GPORTX_PWR_DOWNf_GET(r) ((((r).pwr_down_mode[0]) >> 27) & 0x3)
#define BCM53600_A0_PWR_DOWN_MODEr_GPORTX_PWR_DOWNf_SET(r,f) (r).pwr_down_mode[0]=(((r).pwr_down_mode[0] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_1f_GET(r) ((((r).pwr_down_mode[0]) >> 29) & 0x7)
#define BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_1f_SET(r,f) (r).pwr_down_mode[0]=(((r).pwr_down_mode[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access PWR_DOWN_MODE.
 *
 */
#define BCM53600_A0_READ_PWR_DOWN_MODEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_PWR_DOWN_MODEr,(r._pwr_down_mode),4)
#define BCM53600_A0_WRITE_PWR_DOWN_MODEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_PWR_DOWN_MODEr,&(r._pwr_down_mode),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PWR_DOWN_MODEr BCM53600_A0_PWR_DOWN_MODEr
#define PWR_DOWN_MODEr_SIZE BCM53600_A0_PWR_DOWN_MODEr_SIZE
typedef BCM53600_A0_PWR_DOWN_MODEr_t PWR_DOWN_MODEr_t;
#define PWR_DOWN_MODEr_CLR BCM53600_A0_PWR_DOWN_MODEr_CLR
#define PWR_DOWN_MODEr_SET BCM53600_A0_PWR_DOWN_MODEr_SET
#define PWR_DOWN_MODEr_GET BCM53600_A0_PWR_DOWN_MODEr_GET
#define PWR_DOWN_MODEr_PORTX_PWR_DOWNf_GET BCM53600_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_GET
#define PWR_DOWN_MODEr_PORTX_PWR_DOWNf_SET BCM53600_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_SET
#define PWR_DOWN_MODEr_PWR_DOWN_RESERVED_0f_GET BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_0f_GET
#define PWR_DOWN_MODEr_PWR_DOWN_RESERVED_0f_SET BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_0f_SET
#define PWR_DOWN_MODEr_GPORTX_PWR_DOWNf_GET BCM53600_A0_PWR_DOWN_MODEr_GPORTX_PWR_DOWNf_GET
#define PWR_DOWN_MODEr_GPORTX_PWR_DOWNf_SET BCM53600_A0_PWR_DOWN_MODEr_GPORTX_PWR_DOWNf_SET
#define PWR_DOWN_MODEr_PWR_DOWN_RESERVED_1f_GET BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_1f_GET
#define PWR_DOWN_MODEr_PWR_DOWN_RESERVED_1f_SET BCM53600_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVED_1f_SET
#define READ_PWR_DOWN_MODEr BCM53600_A0_READ_PWR_DOWN_MODEr
#define WRITE_PWR_DOWN_MODEr BCM53600_A0_WRITE_PWR_DOWN_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_PWR_DOWN_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  QOS_CTL
 * BLOCKS:   SYS
 * DESC:     QoS Control Register
 * SIZE:     8
 * FIELDS:
 *     SCHEDULE_SELECT  Scheduling policy.000 : 8SP (default)001 : 1SP-7WDRR010 : 2SP-6WDRR011 : 3SP-5WDRR100 : 4SP-4WDRR101 : 8WDRR
 *     WDRR_GRANULARITY Granularity selector for WDRR weight1 = number of packet.0 = number of 16-bytes.
 *     EN_DSCP_REMARK   Egress DSCP marking control.1). Enable DSCP remarking.2). markColorAtLayer3 control for "Mark Egress Packet Function".1 = Enable.0 = Disable.
 *     EN_PCP_REMARK    Egress PCP/DEI marking control.1). Enable PCP/DEI remarking.2). markColorAtLayer2 control for "Mark Egress Packet Function".1 = Enable.0 = Disable.
 *     USE_TC           1 = Use generic TC based COS mapping for forwarding packets to CPU.0 = Use Reason based COS mapping for forwarding packets to CPU.
 *     QOS_EN           QOS enable.
 *
 ******************************************************************************/
#define BCM53600_A0_QOS_CTLr 0x00003000

#define BCM53600_A0_QOS_CTLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_CTL.
 *
 */
typedef union BCM53600_A0_QOS_CTLr_s {
	uint32_t v[1];
	uint32_t qos_ctl[1];
	uint32_t _qos_ctl;
} BCM53600_A0_QOS_CTLr_t;

#define BCM53600_A0_QOS_CTLr_CLR(r) (r).qos_ctl[0] = 0
#define BCM53600_A0_QOS_CTLr_SET(r,d) (r).qos_ctl[0] = d
#define BCM53600_A0_QOS_CTLr_GET(r) (r).qos_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_QOS_CTLr_SCHEDULE_SELECTf_GET(r) (((r).qos_ctl[0]) & 0x7)
#define BCM53600_A0_QOS_CTLr_SCHEDULE_SELECTf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_QOS_CTLr_WDRR_GRANULARITYf_GET(r) ((((r).qos_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_QOS_CTLr_WDRR_GRANULARITYf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_QOS_CTLr_EN_DSCP_REMARKf_GET(r) ((((r).qos_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_QOS_CTLr_EN_DSCP_REMARKf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_QOS_CTLr_EN_PCP_REMARKf_GET(r) ((((r).qos_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_QOS_CTLr_EN_PCP_REMARKf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_QOS_CTLr_USE_TCf_GET(r) ((((r).qos_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_QOS_CTLr_USE_TCf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_QOS_CTLr_QOS_ENf_GET(r) ((((r).qos_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_QOS_CTLr_QOS_ENf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access QOS_CTL.
 *
 */
#define BCM53600_A0_READ_QOS_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_QOS_CTLr,(r._qos_ctl),1)
#define BCM53600_A0_WRITE_QOS_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_QOS_CTLr,&(r._qos_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_CTLr BCM53600_A0_QOS_CTLr
#define QOS_CTLr_SIZE BCM53600_A0_QOS_CTLr_SIZE
typedef BCM53600_A0_QOS_CTLr_t QOS_CTLr_t;
#define QOS_CTLr_CLR BCM53600_A0_QOS_CTLr_CLR
#define QOS_CTLr_SET BCM53600_A0_QOS_CTLr_SET
#define QOS_CTLr_GET BCM53600_A0_QOS_CTLr_GET
#define QOS_CTLr_SCHEDULE_SELECTf_GET BCM53600_A0_QOS_CTLr_SCHEDULE_SELECTf_GET
#define QOS_CTLr_SCHEDULE_SELECTf_SET BCM53600_A0_QOS_CTLr_SCHEDULE_SELECTf_SET
#define QOS_CTLr_WDRR_GRANULARITYf_GET BCM53600_A0_QOS_CTLr_WDRR_GRANULARITYf_GET
#define QOS_CTLr_WDRR_GRANULARITYf_SET BCM53600_A0_QOS_CTLr_WDRR_GRANULARITYf_SET
#define QOS_CTLr_EN_DSCP_REMARKf_GET BCM53600_A0_QOS_CTLr_EN_DSCP_REMARKf_GET
#define QOS_CTLr_EN_DSCP_REMARKf_SET BCM53600_A0_QOS_CTLr_EN_DSCP_REMARKf_SET
#define QOS_CTLr_EN_PCP_REMARKf_GET BCM53600_A0_QOS_CTLr_EN_PCP_REMARKf_GET
#define QOS_CTLr_EN_PCP_REMARKf_SET BCM53600_A0_QOS_CTLr_EN_PCP_REMARKf_SET
#define QOS_CTLr_USE_TCf_GET BCM53600_A0_QOS_CTLr_USE_TCf_GET
#define QOS_CTLr_USE_TCf_SET BCM53600_A0_QOS_CTLr_USE_TCf_SET
#define QOS_CTLr_QOS_ENf_GET BCM53600_A0_QOS_CTLr_QOS_ENf_GET
#define QOS_CTLr_QOS_ENf_SET BCM53600_A0_QOS_CTLr_QOS_ENf_SET
#define READ_QOS_CTLr BCM53600_A0_READ_QOS_CTLr
#define WRITE_QOS_CTLr BCM53600_A0_WRITE_QOS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_QOS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  QOS_REASON_CODE
 * BLOCKS:   SYS
 * DESC:     QoS Reason Code Register
 * SIZE:     64
 * FIELDS:
 *     ARL_KNOWN_DA_TERMIN ARL_CPUCopy=001, Known-DA Forwarding.The packet is copied to CPU due to ARL forwarding decision = Known-DAForwarding.
 *     ARL_UNKNOWN_DA_FLOOD ARL_CPUCopy=010, Unknown-DA Flooding.The packet is copied to CPU due to ARL forwarding decision = Unknown-DAFlooding.
 *     ARL_8021_PROT_TRAP ARL_CPUCopy=011, 802.1 Protocol Trapping.The packet is copied to CPU due to ARL forwarding decision = 802.1Protocol Trapping.
 *     ARL_APPL_PROT_SNOOP ARL_CPUCopy=100, Application Protocol Snooping.The packet is copied to CPU due to ARL forwarding decision = ApplicationProtocol Snooping.
 *     ARL_VLAN_DIR_FWD ARL_CPUCopy=101, VLAN based direct forwarding.The packet is copied to CPU due to VLAN based direct forwarding.
 *     ARL_CFP_FWD      ARL_CPUCopy=110, CFP based forwarding.The packet is copied to CPU due to CFP BASED forwarding.
 *     ARL_LOOPBACK     ARL_CPUCopy=111, Loopback.The packet is copied to CPU due to ARL forwarding decision = Loopback.
 *     MIRROR_COPY      The packet is copied to CPU (as an MTP) due to mirroring configuration.
 *     INGRESS_SFLOW    The packet is copied to CPU due to random sample based on ingress flowsample configuration.
 *     EGRESS_SFLOW     The packet is copied to CPU due to random sample based on egress flowsample configuration.
 *     SA_MOVEMENT_EVENT SA_Check_Event=01, SA_MovementIndicating that the SA cannot be found in ARL table, but the incoming port IDdoes not match the SA associated port ID.
 *     SA_UNKNOWN_EVENT SA_Check_Event=10, SA_UnknownIndicating that the SA cannot be found in ARL table and SA learninglimit has not yet been reached.
 *     SA_OVER_LIMIT_EVENT SA_Check_Event=11, SA_OverLimitIndicating that the SA cannot be found in ARL table and SA learninglimit has already been reached.
 *     INP_NON_MEMBER   The packet is copied to CPU due to membership violation of the ingress port withthe associated VLAN.
 *     VLAN_UNKNOWN     The packet is copied to CPU due to Unregistered VLAN.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_QOS_REASON_CODEr 0x000030c0

#define BCM53600_A0_QOS_REASON_CODEr_SIZE 8

/*
 * This structure should be used to declare and program QOS_REASON_CODE.
 *
 */
typedef union BCM53600_A0_QOS_REASON_CODEr_s {
	uint32_t v[2];
	uint32_t qos_reason_code[2];
	uint32_t _qos_reason_code;
} BCM53600_A0_QOS_REASON_CODEr_t;

#define BCM53600_A0_QOS_REASON_CODEr_CLR(r) CDK_MEMSET(&((r)._qos_reason_code), 0, sizeof(BCM53600_A0_QOS_REASON_CODEr_t))
#define BCM53600_A0_QOS_REASON_CODEr_SET(r,i,d) (r).qos_reason_code[i] = d
#define BCM53600_A0_QOS_REASON_CODEr_GET(r,i) (r).qos_reason_code[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_QOS_REASON_CODEr_ARL_KNOWN_DA_TERMINf_GET(r) (((r).qos_reason_code[0]) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_KNOWN_DA_TERMINf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_QOS_REASON_CODEr_ARL_UNKNOWN_DA_FLOODf_GET(r) ((((r).qos_reason_code[0]) >> 3) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_UNKNOWN_DA_FLOODf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53600_A0_QOS_REASON_CODEr_ARL_8021_PROT_TRAPf_GET(r) ((((r).qos_reason_code[0]) >> 6) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_8021_PROT_TRAPf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53600_A0_QOS_REASON_CODEr_ARL_APPL_PROT_SNOOPf_GET(r) ((((r).qos_reason_code[0]) >> 9) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_APPL_PROT_SNOOPf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53600_A0_QOS_REASON_CODEr_ARL_VLAN_DIR_FWDf_GET(r) ((((r).qos_reason_code[0]) >> 12) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_VLAN_DIR_FWDf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53600_A0_QOS_REASON_CODEr_ARL_CFP_FWDf_GET(r) ((((r).qos_reason_code[0]) >> 15) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_CFP_FWDf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53600_A0_QOS_REASON_CODEr_ARL_LOOPBACKf_GET(r) ((((r).qos_reason_code[0]) >> 18) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_ARL_LOOPBACKf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_QOS_REASON_CODEr_MIRROR_COPYf_GET(r) ((((r).qos_reason_code[0]) >> 21) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_MIRROR_COPYf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_QOS_REASON_CODEr_INGRESS_SFLOWf_GET(r) ((((r).qos_reason_code[0]) >> 24) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_INGRESS_SFLOWf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53600_A0_QOS_REASON_CODEr_EGRESS_SFLOWf_GET(r) ((((r).qos_reason_code[0]) >> 27) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_EGRESS_SFLOWf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53600_A0_QOS_REASON_CODEr_SA_MOVEMENT_EVENTf_GET(r) cdk_field32_get((r).qos_reason_code,30,32)
#define BCM53600_A0_QOS_REASON_CODEr_SA_MOVEMENT_EVENTf_SET(r,f) cdk_field32_set((r).qos_reason_code,30,32,f)
#define BCM53600_A0_QOS_REASON_CODEr_SA_UNKNOWN_EVENTf_GET(r) ((((r).qos_reason_code[1]) >> 1) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_SA_UNKNOWN_EVENTf_SET(r,f) (r).qos_reason_code[1]=(((r).qos_reason_code[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53600_A0_QOS_REASON_CODEr_SA_OVER_LIMIT_EVENTf_GET(r) ((((r).qos_reason_code[1]) >> 4) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_SA_OVER_LIMIT_EVENTf_SET(r,f) (r).qos_reason_code[1]=(((r).qos_reason_code[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53600_A0_QOS_REASON_CODEr_INP_NON_MEMBERf_GET(r) ((((r).qos_reason_code[1]) >> 7) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_INP_NON_MEMBERf_SET(r,f) (r).qos_reason_code[1]=(((r).qos_reason_code[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53600_A0_QOS_REASON_CODEr_VLAN_UNKNOWNf_GET(r) ((((r).qos_reason_code[1]) >> 10) & 0x7)
#define BCM53600_A0_QOS_REASON_CODEr_VLAN_UNKNOWNf_SET(r,f) (r).qos_reason_code[1]=(((r).qos_reason_code[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53600_A0_QOS_REASON_CODEr_RESERVEDf_GET(r) ((((r).qos_reason_code[1]) >> 13) & 0x7ffff)
#define BCM53600_A0_QOS_REASON_CODEr_RESERVEDf_SET(r,f) (r).qos_reason_code[1]=(((r).qos_reason_code[1] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access QOS_REASON_CODE.
 *
 */
#define BCM53600_A0_READ_QOS_REASON_CODEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_QOS_REASON_CODEr,(r._qos_reason_code),8)
#define BCM53600_A0_WRITE_QOS_REASON_CODEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_QOS_REASON_CODEr,&(r._qos_reason_code),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_REASON_CODEr BCM53600_A0_QOS_REASON_CODEr
#define QOS_REASON_CODEr_SIZE BCM53600_A0_QOS_REASON_CODEr_SIZE
typedef BCM53600_A0_QOS_REASON_CODEr_t QOS_REASON_CODEr_t;
#define QOS_REASON_CODEr_CLR BCM53600_A0_QOS_REASON_CODEr_CLR
#define QOS_REASON_CODEr_SET BCM53600_A0_QOS_REASON_CODEr_SET
#define QOS_REASON_CODEr_GET BCM53600_A0_QOS_REASON_CODEr_GET
#define QOS_REASON_CODEr_ARL_KNOWN_DA_TERMINf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_KNOWN_DA_TERMINf_GET
#define QOS_REASON_CODEr_ARL_KNOWN_DA_TERMINf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_KNOWN_DA_TERMINf_SET
#define QOS_REASON_CODEr_ARL_UNKNOWN_DA_FLOODf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_UNKNOWN_DA_FLOODf_GET
#define QOS_REASON_CODEr_ARL_UNKNOWN_DA_FLOODf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_UNKNOWN_DA_FLOODf_SET
#define QOS_REASON_CODEr_ARL_8021_PROT_TRAPf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_8021_PROT_TRAPf_GET
#define QOS_REASON_CODEr_ARL_8021_PROT_TRAPf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_8021_PROT_TRAPf_SET
#define QOS_REASON_CODEr_ARL_APPL_PROT_SNOOPf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_APPL_PROT_SNOOPf_GET
#define QOS_REASON_CODEr_ARL_APPL_PROT_SNOOPf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_APPL_PROT_SNOOPf_SET
#define QOS_REASON_CODEr_ARL_VLAN_DIR_FWDf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_VLAN_DIR_FWDf_GET
#define QOS_REASON_CODEr_ARL_VLAN_DIR_FWDf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_VLAN_DIR_FWDf_SET
#define QOS_REASON_CODEr_ARL_CFP_FWDf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_CFP_FWDf_GET
#define QOS_REASON_CODEr_ARL_CFP_FWDf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_CFP_FWDf_SET
#define QOS_REASON_CODEr_ARL_LOOPBACKf_GET BCM53600_A0_QOS_REASON_CODEr_ARL_LOOPBACKf_GET
#define QOS_REASON_CODEr_ARL_LOOPBACKf_SET BCM53600_A0_QOS_REASON_CODEr_ARL_LOOPBACKf_SET
#define QOS_REASON_CODEr_MIRROR_COPYf_GET BCM53600_A0_QOS_REASON_CODEr_MIRROR_COPYf_GET
#define QOS_REASON_CODEr_MIRROR_COPYf_SET BCM53600_A0_QOS_REASON_CODEr_MIRROR_COPYf_SET
#define QOS_REASON_CODEr_INGRESS_SFLOWf_GET BCM53600_A0_QOS_REASON_CODEr_INGRESS_SFLOWf_GET
#define QOS_REASON_CODEr_INGRESS_SFLOWf_SET BCM53600_A0_QOS_REASON_CODEr_INGRESS_SFLOWf_SET
#define QOS_REASON_CODEr_EGRESS_SFLOWf_GET BCM53600_A0_QOS_REASON_CODEr_EGRESS_SFLOWf_GET
#define QOS_REASON_CODEr_EGRESS_SFLOWf_SET BCM53600_A0_QOS_REASON_CODEr_EGRESS_SFLOWf_SET
#define QOS_REASON_CODEr_SA_MOVEMENT_EVENTf_GET BCM53600_A0_QOS_REASON_CODEr_SA_MOVEMENT_EVENTf_GET
#define QOS_REASON_CODEr_SA_MOVEMENT_EVENTf_SET BCM53600_A0_QOS_REASON_CODEr_SA_MOVEMENT_EVENTf_SET
#define QOS_REASON_CODEr_SA_UNKNOWN_EVENTf_GET BCM53600_A0_QOS_REASON_CODEr_SA_UNKNOWN_EVENTf_GET
#define QOS_REASON_CODEr_SA_UNKNOWN_EVENTf_SET BCM53600_A0_QOS_REASON_CODEr_SA_UNKNOWN_EVENTf_SET
#define QOS_REASON_CODEr_SA_OVER_LIMIT_EVENTf_GET BCM53600_A0_QOS_REASON_CODEr_SA_OVER_LIMIT_EVENTf_GET
#define QOS_REASON_CODEr_SA_OVER_LIMIT_EVENTf_SET BCM53600_A0_QOS_REASON_CODEr_SA_OVER_LIMIT_EVENTf_SET
#define QOS_REASON_CODEr_INP_NON_MEMBERf_GET BCM53600_A0_QOS_REASON_CODEr_INP_NON_MEMBERf_GET
#define QOS_REASON_CODEr_INP_NON_MEMBERf_SET BCM53600_A0_QOS_REASON_CODEr_INP_NON_MEMBERf_SET
#define QOS_REASON_CODEr_VLAN_UNKNOWNf_GET BCM53600_A0_QOS_REASON_CODEr_VLAN_UNKNOWNf_GET
#define QOS_REASON_CODEr_VLAN_UNKNOWNf_SET BCM53600_A0_QOS_REASON_CODEr_VLAN_UNKNOWNf_SET
#define QOS_REASON_CODEr_RESERVEDf_GET BCM53600_A0_QOS_REASON_CODEr_RESERVEDf_GET
#define QOS_REASON_CODEr_RESERVEDf_SET BCM53600_A0_QOS_REASON_CODEr_RESERVEDf_SET
#define READ_QOS_REASON_CODEr BCM53600_A0_READ_QOS_REASON_CODEr
#define WRITE_QOS_REASON_CODEr BCM53600_A0_WRITE_QOS_REASON_CODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_QOS_REASON_CODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  QUEUE_REGION_STATUS
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Queue Region Status Register
 * SIZE:     16
 * FIELDS:
 *     TXQ0_REGION_STAT Queue 0 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ1_REGION_STAT Queue 1 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ2_REGION_STAT Queue 2 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ3_REGION_STAT Queue 3 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ4_REGION_STAT Queue 4 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ5_REGION_STAT Queue 5 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ6_REGION_STAT Queue 6 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     TXQ7_REGION_STAT Queue 7 region status:00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_QUEUE_REGION_STATUSr 0x00000a40

#define BCM53600_A0_QUEUE_REGION_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_REGION_STATUS.
 *
 */
typedef union BCM53600_A0_QUEUE_REGION_STATUSr_s {
	uint32_t v[1];
	uint32_t queue_region_status[1];
	uint32_t _queue_region_status;
} BCM53600_A0_QUEUE_REGION_STATUSr_t;

#define BCM53600_A0_QUEUE_REGION_STATUSr_CLR(r) (r).queue_region_status[0] = 0
#define BCM53600_A0_QUEUE_REGION_STATUSr_SET(r,d) (r).queue_region_status[0] = d
#define BCM53600_A0_QUEUE_REGION_STATUSr_GET(r) (r).queue_region_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ0_REGION_STATf_GET(r) (((r).queue_region_status[0]) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ0_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ1_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 2) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ1_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ2_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 4) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ2_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ3_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 6) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ3_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ4_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 8) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ4_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ5_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 10) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ5_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ6_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 12) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ6_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ7_REGION_STATf_GET(r) ((((r).queue_region_status[0]) >> 14) & 0x3)
#define BCM53600_A0_QUEUE_REGION_STATUSr_TXQ7_REGION_STATf_SET(r,f) (r).queue_region_status[0]=(((r).queue_region_status[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access QUEUE_REGION_STATUS.
 *
 */
#define BCM53600_A0_READ_QUEUE_REGION_STATUSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_QUEUE_REGION_STATUSr,(r._queue_region_status),2)
#define BCM53600_A0_WRITE_QUEUE_REGION_STATUSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_QUEUE_REGION_STATUSr,&(r._queue_region_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_REGION_STATUSr BCM53600_A0_QUEUE_REGION_STATUSr
#define QUEUE_REGION_STATUSr_SIZE BCM53600_A0_QUEUE_REGION_STATUSr_SIZE
typedef BCM53600_A0_QUEUE_REGION_STATUSr_t QUEUE_REGION_STATUSr_t;
#define QUEUE_REGION_STATUSr_CLR BCM53600_A0_QUEUE_REGION_STATUSr_CLR
#define QUEUE_REGION_STATUSr_SET BCM53600_A0_QUEUE_REGION_STATUSr_SET
#define QUEUE_REGION_STATUSr_GET BCM53600_A0_QUEUE_REGION_STATUSr_GET
#define QUEUE_REGION_STATUSr_TXQ0_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ0_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ0_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ0_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ1_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ1_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ1_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ1_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ2_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ2_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ2_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ2_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ3_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ3_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ3_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ3_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ4_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ4_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ4_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ4_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ5_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ5_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ5_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ5_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ6_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ6_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ6_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ6_REGION_STATf_SET
#define QUEUE_REGION_STATUSr_TXQ7_REGION_STATf_GET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ7_REGION_STATf_GET
#define QUEUE_REGION_STATUSr_TXQ7_REGION_STATf_SET BCM53600_A0_QUEUE_REGION_STATUSr_TXQ7_REGION_STATf_SET
#define READ_QUEUE_REGION_STATUSr BCM53600_A0_READ_QUEUE_REGION_STATUSr
#define WRITE_QUEUE_REGION_STATUSr BCM53600_A0_WRITE_QUEUE_REGION_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_QUEUE_REGION_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RANGE_CHECKER
 * BLOCKS:   SYS
 * DESC:     Range Checker Register
 * SIZE:     32
 * FIELDS:
 *     LOW_VAL          LOW Value.Note 1: For field selector = CVID+CPCP/SVID+SPCP, bit 11:0 = VID, bit 15:13 = PCP
 *     HIGH_VAL         If the field is between HIGH and LOW values(High >= xxxx >= Low),inclusive then the corresponding bit in the range results is set.The range results vector is included in the CFP.Large Value.Note 1: For field selector = CVID+CPCP/SVID+SPCP, bit 27:16 = VID, bit 31:29 = PCP.
 *
 ******************************************************************************/
#define BCM53600_A0_RANGE_CHECKERr 0x00002150

#define BCM53600_A0_RANGE_CHECKERr_SIZE 4

/*
 * This structure should be used to declare and program RANGE_CHECKER.
 *
 */
typedef union BCM53600_A0_RANGE_CHECKERr_s {
	uint32_t v[1];
	uint32_t range_checker[1];
	uint32_t _range_checker;
} BCM53600_A0_RANGE_CHECKERr_t;

#define BCM53600_A0_RANGE_CHECKERr_CLR(r) (r).range_checker[0] = 0
#define BCM53600_A0_RANGE_CHECKERr_SET(r,d) (r).range_checker[0] = d
#define BCM53600_A0_RANGE_CHECKERr_GET(r) (r).range_checker[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RANGE_CHECKERr_LOW_VALf_GET(r) (((r).range_checker[0]) & 0xffff)
#define BCM53600_A0_RANGE_CHECKERr_LOW_VALf_SET(r,f) (r).range_checker[0]=(((r).range_checker[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_RANGE_CHECKERr_HIGH_VALf_GET(r) ((((r).range_checker[0]) >> 16) & 0xffff)
#define BCM53600_A0_RANGE_CHECKERr_HIGH_VALf_SET(r,f) (r).range_checker[0]=(((r).range_checker[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access RANGE_CHECKER.
 *
 */
#define BCM53600_A0_READ_RANGE_CHECKERr(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_RANGE_CHECKERr+(4*(i)),(r._range_checker),4)
#define BCM53600_A0_WRITE_RANGE_CHECKERr(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_RANGE_CHECKERr+(4*(i)),&(r._range_checker),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RANGE_CHECKERr BCM53600_A0_RANGE_CHECKERr
#define RANGE_CHECKERr_SIZE BCM53600_A0_RANGE_CHECKERr_SIZE
typedef BCM53600_A0_RANGE_CHECKERr_t RANGE_CHECKERr_t;
#define RANGE_CHECKERr_CLR BCM53600_A0_RANGE_CHECKERr_CLR
#define RANGE_CHECKERr_SET BCM53600_A0_RANGE_CHECKERr_SET
#define RANGE_CHECKERr_GET BCM53600_A0_RANGE_CHECKERr_GET
#define RANGE_CHECKERr_LOW_VALf_GET BCM53600_A0_RANGE_CHECKERr_LOW_VALf_GET
#define RANGE_CHECKERr_LOW_VALf_SET BCM53600_A0_RANGE_CHECKERr_LOW_VALf_SET
#define RANGE_CHECKERr_HIGH_VALf_GET BCM53600_A0_RANGE_CHECKERr_HIGH_VALf_GET
#define RANGE_CHECKERr_HIGH_VALf_SET BCM53600_A0_RANGE_CHECKERr_HIGH_VALf_SET
#define READ_RANGE_CHECKERr BCM53600_A0_READ_RANGE_CHECKERr
#define WRITE_RANGE_CHECKERr BCM53600_A0_WRITE_RANGE_CHECKERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RANGE_CHECKERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RANGE_CHECKER_FIELD_SEL
 * BLOCKS:   SYS
 * DESC:     Range Checker Field Selector Register
 * SIZE:     8
 * FIELDS:
 *     FIELD_SELECT     Range Checker Field Selector000 = CVID001 = SVID010 = CVID+CPCP011 = SVID+SPCP100 = TCP/UDP Destination Port101 = TCP/UDP Source Port
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr 0x00002140

#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_SIZE 1

/*
 * This structure should be used to declare and program RANGE_CHECKER_FIELD_SEL.
 *
 */
typedef union BCM53600_A0_RANGE_CHECKER_FIELD_SELr_s {
	uint32_t v[1];
	uint32_t range_checker_field_sel[1];
	uint32_t _range_checker_field_sel;
} BCM53600_A0_RANGE_CHECKER_FIELD_SELr_t;

#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_CLR(r) (r).range_checker_field_sel[0] = 0
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_SET(r,d) (r).range_checker_field_sel[0] = d
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_GET(r) (r).range_checker_field_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_FIELD_SELECTf_GET(r) (((r).range_checker_field_sel[0]) & 0x7)
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_FIELD_SELECTf_SET(r,f) (r).range_checker_field_sel[0]=(((r).range_checker_field_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_RESERVEDf_GET(r) ((((r).range_checker_field_sel[0]) >> 3) & 0x1f)
#define BCM53600_A0_RANGE_CHECKER_FIELD_SELr_RESERVEDf_SET(r,f) (r).range_checker_field_sel[0]=(((r).range_checker_field_sel[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access RANGE_CHECKER_FIELD_SEL.
 *
 */
#define BCM53600_A0_READ_RANGE_CHECKER_FIELD_SELr(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_RANGE_CHECKER_FIELD_SELr+(1*(i)),(r._range_checker_field_sel),1)
#define BCM53600_A0_WRITE_RANGE_CHECKER_FIELD_SELr(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_RANGE_CHECKER_FIELD_SELr+(1*(i)),&(r._range_checker_field_sel),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RANGE_CHECKER_FIELD_SELr BCM53600_A0_RANGE_CHECKER_FIELD_SELr
#define RANGE_CHECKER_FIELD_SELr_SIZE BCM53600_A0_RANGE_CHECKER_FIELD_SELr_SIZE
typedef BCM53600_A0_RANGE_CHECKER_FIELD_SELr_t RANGE_CHECKER_FIELD_SELr_t;
#define RANGE_CHECKER_FIELD_SELr_CLR BCM53600_A0_RANGE_CHECKER_FIELD_SELr_CLR
#define RANGE_CHECKER_FIELD_SELr_SET BCM53600_A0_RANGE_CHECKER_FIELD_SELr_SET
#define RANGE_CHECKER_FIELD_SELr_GET BCM53600_A0_RANGE_CHECKER_FIELD_SELr_GET
#define RANGE_CHECKER_FIELD_SELr_FIELD_SELECTf_GET BCM53600_A0_RANGE_CHECKER_FIELD_SELr_FIELD_SELECTf_GET
#define RANGE_CHECKER_FIELD_SELr_FIELD_SELECTf_SET BCM53600_A0_RANGE_CHECKER_FIELD_SELr_FIELD_SELECTf_SET
#define RANGE_CHECKER_FIELD_SELr_RESERVEDf_GET BCM53600_A0_RANGE_CHECKER_FIELD_SELr_RESERVEDf_GET
#define RANGE_CHECKER_FIELD_SELr_RESERVEDf_SET BCM53600_A0_RANGE_CHECKER_FIELD_SELr_RESERVEDf_SET
#define READ_RANGE_CHECKER_FIELD_SELr BCM53600_A0_READ_RANGE_CHECKER_FIELD_SELr
#define WRITE_RANGE_CHECKER_FIELD_SELr BCM53600_A0_WRITE_RANGE_CHECKER_FIELD_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RANGE_CHECKER_FIELD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RGMII_CTRL_GP25
 * BLOCKS:   SYS
 * DESC:     GigaPort0 RGMII Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_RGMII_DLL_TXC 1.RGMII tx_clk delayed timing mode(Delay Mode)0:RGMII tx_clk aligned timing mode(Normal Mode)
 *     EN_RGMII_DLL_RXC 1:clock delay by DLL is enabled(Delay Mode)0:clock delay by DLL is disabled(Normal Mode)
 *     BYPASS_2NS_DEL   1:Bypass dll65_2ns_del IP0:Use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affectedby bit[0] and bit[1].{Bit[2],Bit[0]}=2'b10, Bypass tx side dll65_2ns_del IP{Bit[2],Bit[0]}=2'b11, use tx side dll65_2ns_del IP{Bit[2],Bit[0]}=2'b0X, use tx side dll65_2ns_del IP{Bit[2],Bit[1]}=2'b10, Bypass rx side dll65_2ns_del IP{Bit[2],Bit[1]}=2'b11, use rx side dll65_2ns_del IP{Bit[2],Bit[1]}=2'b0X, use rx side dll65_2ns_del IP(Not2Release)
 *     RESERVED         Reserved.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_RGMII_CTRL_GP25r 0x00000104

#define BCM53600_A0_RGMII_CTRL_GP25r_SIZE 1

/*
 * This structure should be used to declare and program RGMII_CTRL_GP25.
 *
 */
typedef union BCM53600_A0_RGMII_CTRL_GP25r_s {
	uint32_t v[1];
	uint32_t rgmii_ctrl_gp25[1];
	uint32_t _rgmii_ctrl_gp25;
} BCM53600_A0_RGMII_CTRL_GP25r_t;

#define BCM53600_A0_RGMII_CTRL_GP25r_CLR(r) (r).rgmii_ctrl_gp25[0] = 0
#define BCM53600_A0_RGMII_CTRL_GP25r_SET(r,d) (r).rgmii_ctrl_gp25[0] = d
#define BCM53600_A0_RGMII_CTRL_GP25r_GET(r) (r).rgmii_ctrl_gp25[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_TXCf_GET(r) (((r).rgmii_ctrl_gp25[0]) & 0x1)
#define BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_TXCf_SET(r,f) (r).rgmii_ctrl_gp25[0]=(((r).rgmii_ctrl_gp25[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_RXCf_GET(r) ((((r).rgmii_ctrl_gp25[0]) >> 1) & 0x1)
#define BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_RXCf_SET(r,f) (r).rgmii_ctrl_gp25[0]=(((r).rgmii_ctrl_gp25[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_RGMII_CTRL_GP25r_BYPASS_2NS_DELf_GET(r) ((((r).rgmii_ctrl_gp25[0]) >> 2) & 0x1)
#define BCM53600_A0_RGMII_CTRL_GP25r_BYPASS_2NS_DELf_SET(r,f) (r).rgmii_ctrl_gp25[0]=(((r).rgmii_ctrl_gp25[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_RGMII_CTRL_GP25r_RESERVEDf_GET(r) ((((r).rgmii_ctrl_gp25[0]) >> 3) & 0x1f)
#define BCM53600_A0_RGMII_CTRL_GP25r_RESERVEDf_SET(r,f) (r).rgmii_ctrl_gp25[0]=(((r).rgmii_ctrl_gp25[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access RGMII_CTRL_GP25.
 *
 */
#define BCM53600_A0_READ_RGMII_CTRL_GP25r(u,r) cdk_robo_reg_read(u,BCM53600_A0_RGMII_CTRL_GP25r,(r._rgmii_ctrl_gp25),1)
#define BCM53600_A0_WRITE_RGMII_CTRL_GP25r(u,r) cdk_robo_reg_write(u,BCM53600_A0_RGMII_CTRL_GP25r,&(r._rgmii_ctrl_gp25),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_CTRL_GP25r BCM53600_A0_RGMII_CTRL_GP25r
#define RGMII_CTRL_GP25r_SIZE BCM53600_A0_RGMII_CTRL_GP25r_SIZE
typedef BCM53600_A0_RGMII_CTRL_GP25r_t RGMII_CTRL_GP25r_t;
#define RGMII_CTRL_GP25r_CLR BCM53600_A0_RGMII_CTRL_GP25r_CLR
#define RGMII_CTRL_GP25r_SET BCM53600_A0_RGMII_CTRL_GP25r_SET
#define RGMII_CTRL_GP25r_GET BCM53600_A0_RGMII_CTRL_GP25r_GET
#define RGMII_CTRL_GP25r_EN_RGMII_DLL_TXCf_GET BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_TXCf_GET
#define RGMII_CTRL_GP25r_EN_RGMII_DLL_TXCf_SET BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_TXCf_SET
#define RGMII_CTRL_GP25r_EN_RGMII_DLL_RXCf_GET BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_RXCf_GET
#define RGMII_CTRL_GP25r_EN_RGMII_DLL_RXCf_SET BCM53600_A0_RGMII_CTRL_GP25r_EN_RGMII_DLL_RXCf_SET
#define RGMII_CTRL_GP25r_BYPASS_2NS_DELf_GET BCM53600_A0_RGMII_CTRL_GP25r_BYPASS_2NS_DELf_GET
#define RGMII_CTRL_GP25r_BYPASS_2NS_DELf_SET BCM53600_A0_RGMII_CTRL_GP25r_BYPASS_2NS_DELf_SET
#define RGMII_CTRL_GP25r_RESERVEDf_GET BCM53600_A0_RGMII_CTRL_GP25r_RESERVEDf_GET
#define RGMII_CTRL_GP25r_RESERVEDf_SET BCM53600_A0_RGMII_CTRL_GP25r_RESERVEDf_SET
#define READ_RGMII_CTRL_GP25r BCM53600_A0_READ_RGMII_CTRL_GP25r
#define WRITE_RGMII_CTRL_GP25r BCM53600_A0_WRITE_RGMII_CTRL_GP25r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RGMII_CTRL_GP25r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RGMII_CTRL_IMP
 * BLOCKS:   SYS
 * DESC:     IMP Port RGMII Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_RGMII_DLL_TXC 1.RGMII tx_clk delayed timing mode(Delay Mode)0:RGMII tx_clk aligned timing mode(Normal Mode)
 *     EN_RGMII_DLL_RXC 1:clock delay by DLL is enabled(Delay Mode)0:clock delay by DLL is disabled(Normal Mode)
 *     BYPASS_2NS_DEL   1:Bypass dll65_2ns_del IP0:Use dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affectedby bit[0] and bit[1].{Bit[2],Bit[0]}=2'b10, Bypass tx side dll65_2ns_del IP{Bit[2],Bit[0]}=2'b11, use tx side dll65_2ns_del IP{Bit[2],Bit[0]}=2'b0X, use tx side dll65_2ns_del IP{Bit[2],Bit[1]}=2'b10, Bypass rx side dll65_2ns_del IP{Bit[2],Bit[1]}=2'b11, use rx side dll65_2ns_del IP{Bit[2],Bit[1]}=2'b0X, use rx side dll65_2ns_del IP(Not2Release)
 *     RESERVED         Reserved.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_RGMII_CTRL_IMPr 0x00000102

#define BCM53600_A0_RGMII_CTRL_IMPr_SIZE 1

/*
 * This structure should be used to declare and program RGMII_CTRL_IMP.
 *
 */
typedef union BCM53600_A0_RGMII_CTRL_IMPr_s {
	uint32_t v[1];
	uint32_t rgmii_ctrl_imp[1];
	uint32_t _rgmii_ctrl_imp;
} BCM53600_A0_RGMII_CTRL_IMPr_t;

#define BCM53600_A0_RGMII_CTRL_IMPr_CLR(r) (r).rgmii_ctrl_imp[0] = 0
#define BCM53600_A0_RGMII_CTRL_IMPr_SET(r,d) (r).rgmii_ctrl_imp[0] = d
#define BCM53600_A0_RGMII_CTRL_IMPr_GET(r) (r).rgmii_ctrl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_TXCf_GET(r) (((r).rgmii_ctrl_imp[0]) & 0x1)
#define BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_TXCf_SET(r,f) (r).rgmii_ctrl_imp[0]=(((r).rgmii_ctrl_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_RXCf_GET(r) ((((r).rgmii_ctrl_imp[0]) >> 1) & 0x1)
#define BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_RXCf_SET(r,f) (r).rgmii_ctrl_imp[0]=(((r).rgmii_ctrl_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_RGMII_CTRL_IMPr_BYPASS_2NS_DELf_GET(r) ((((r).rgmii_ctrl_imp[0]) >> 2) & 0x1)
#define BCM53600_A0_RGMII_CTRL_IMPr_BYPASS_2NS_DELf_SET(r,f) (r).rgmii_ctrl_imp[0]=(((r).rgmii_ctrl_imp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_RGMII_CTRL_IMPr_RESERVEDf_GET(r) ((((r).rgmii_ctrl_imp[0]) >> 3) & 0x1f)
#define BCM53600_A0_RGMII_CTRL_IMPr_RESERVEDf_SET(r,f) (r).rgmii_ctrl_imp[0]=(((r).rgmii_ctrl_imp[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access RGMII_CTRL_IMP.
 *
 */
#define BCM53600_A0_READ_RGMII_CTRL_IMPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RGMII_CTRL_IMPr,(r._rgmii_ctrl_imp),1)
#define BCM53600_A0_WRITE_RGMII_CTRL_IMPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RGMII_CTRL_IMPr,&(r._rgmii_ctrl_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_CTRL_IMPr BCM53600_A0_RGMII_CTRL_IMPr
#define RGMII_CTRL_IMPr_SIZE BCM53600_A0_RGMII_CTRL_IMPr_SIZE
typedef BCM53600_A0_RGMII_CTRL_IMPr_t RGMII_CTRL_IMPr_t;
#define RGMII_CTRL_IMPr_CLR BCM53600_A0_RGMII_CTRL_IMPr_CLR
#define RGMII_CTRL_IMPr_SET BCM53600_A0_RGMII_CTRL_IMPr_SET
#define RGMII_CTRL_IMPr_GET BCM53600_A0_RGMII_CTRL_IMPr_GET
#define RGMII_CTRL_IMPr_EN_RGMII_DLL_TXCf_GET BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_TXCf_GET
#define RGMII_CTRL_IMPr_EN_RGMII_DLL_TXCf_SET BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_TXCf_SET
#define RGMII_CTRL_IMPr_EN_RGMII_DLL_RXCf_GET BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_RXCf_GET
#define RGMII_CTRL_IMPr_EN_RGMII_DLL_RXCf_SET BCM53600_A0_RGMII_CTRL_IMPr_EN_RGMII_DLL_RXCf_SET
#define RGMII_CTRL_IMPr_BYPASS_2NS_DELf_GET BCM53600_A0_RGMII_CTRL_IMPr_BYPASS_2NS_DELf_GET
#define RGMII_CTRL_IMPr_BYPASS_2NS_DELf_SET BCM53600_A0_RGMII_CTRL_IMPr_BYPASS_2NS_DELf_SET
#define RGMII_CTRL_IMPr_RESERVEDf_GET BCM53600_A0_RGMII_CTRL_IMPr_RESERVEDf_GET
#define RGMII_CTRL_IMPr_RESERVEDf_SET BCM53600_A0_RGMII_CTRL_IMPr_RESERVEDf_SET
#define READ_RGMII_CTRL_IMPr BCM53600_A0_READ_RGMII_CTRL_IMPr
#define WRITE_RGMII_CTRL_IMPr BCM53600_A0_WRITE_RGMII_CTRL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RGMII_CTRL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RGMII_TIME_DLY_CTRL_GP25
 * BLOCKS:   SYS
 * DESC:     GigaPort0 RGMII Timing Delay Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DLY_ADDR         Delay timing selection4'b0111:clk_gtxt=1'b14'b1000:clk_gtxg=1'b14'b1001:clk_gtxr=1'b14'b1010:clk_rxg=1'b14'b1011:clk_rxr=1'b14'b1110:Reserved4'b1101:Reserved(Not2Release)
 *     DLY_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x(Not2Release)
 *     DEL_STRB         Delay Value Write Enable1:CPU over-write Enable, del_value and del_addr will affect the RGMII interfacetiming adjustment0:Del_value and del_addr will not affect RGMII interface timing adjustment(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r 0x00000105

#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_SIZE 1

/*
 * This structure should be used to declare and program RGMII_TIME_DLY_CTRL_GP25.
 *
 */
typedef union BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_s {
	uint32_t v[1];
	uint32_t rgmii_time_dly_ctrl_gp25[1];
	uint32_t _rgmii_time_dly_ctrl_gp25;
} BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_t;

#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_CLR(r) (r).rgmii_time_dly_ctrl_gp25[0] = 0
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_SET(r,d) (r).rgmii_time_dly_ctrl_gp25[0] = d
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_GET(r) (r).rgmii_time_dly_ctrl_gp25[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_ADDRf_GET(r) (((r).rgmii_time_dly_ctrl_gp25[0]) & 0xf)
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_ADDRf_SET(r,f) (r).rgmii_time_dly_ctrl_gp25[0]=(((r).rgmii_time_dly_ctrl_gp25[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_VALUEf_GET(r) ((((r).rgmii_time_dly_ctrl_gp25[0]) >> 4) & 0x7)
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_VALUEf_SET(r,f) (r).rgmii_time_dly_ctrl_gp25[0]=(((r).rgmii_time_dly_ctrl_gp25[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DEL_STRBf_GET(r) ((((r).rgmii_time_dly_ctrl_gp25[0]) >> 7) & 0x1)
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DEL_STRBf_SET(r,f) (r).rgmii_time_dly_ctrl_gp25[0]=(((r).rgmii_time_dly_ctrl_gp25[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RGMII_TIME_DLY_CTRL_GP25.
 *
 */
#define BCM53600_A0_READ_RGMII_TIME_DLY_CTRL_GP25r(u,r) cdk_robo_reg_read(u,BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r,(r._rgmii_time_dly_ctrl_gp25),1)
#define BCM53600_A0_WRITE_RGMII_TIME_DLY_CTRL_GP25r(u,r) cdk_robo_reg_write(u,BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r,&(r._rgmii_time_dly_ctrl_gp25),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_TIME_DLY_CTRL_GP25r BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r
#define RGMII_TIME_DLY_CTRL_GP25r_SIZE BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_SIZE
typedef BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_t RGMII_TIME_DLY_CTRL_GP25r_t;
#define RGMII_TIME_DLY_CTRL_GP25r_CLR BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_CLR
#define RGMII_TIME_DLY_CTRL_GP25r_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_SET
#define RGMII_TIME_DLY_CTRL_GP25r_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_GET
#define RGMII_TIME_DLY_CTRL_GP25r_DLY_ADDRf_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_ADDRf_GET
#define RGMII_TIME_DLY_CTRL_GP25r_DLY_ADDRf_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_ADDRf_SET
#define RGMII_TIME_DLY_CTRL_GP25r_DLY_VALUEf_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_VALUEf_GET
#define RGMII_TIME_DLY_CTRL_GP25r_DLY_VALUEf_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DLY_VALUEf_SET
#define RGMII_TIME_DLY_CTRL_GP25r_DEL_STRBf_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DEL_STRBf_GET
#define RGMII_TIME_DLY_CTRL_GP25r_DEL_STRBf_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r_DEL_STRBf_SET
#define READ_RGMII_TIME_DLY_CTRL_GP25r BCM53600_A0_READ_RGMII_TIME_DLY_CTRL_GP25r
#define WRITE_RGMII_TIME_DLY_CTRL_GP25r BCM53600_A0_WRITE_RGMII_TIME_DLY_CTRL_GP25r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RGMII_TIME_DLY_CTRL_GP25r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RGMII_TIME_DLY_CTRL_IMP
 * BLOCKS:   SYS
 * DESC:     IMP Port RGMII Timing Delay Control Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     DLY_ADDR         Delay timing selection4'b0111:clk_gtxt=1'b14'b1000:clk_gtxg=1'b14'b1001:clk_gtxr=1'b14'b1010:clk_rxg=1'b14'b1011:clk_rxr=1'b14'b1110:Reserved4'b1101:Reserved(Not2Release)
 *     DLY_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x(Not2Release)
 *     DEL_STRB         Delay Value Write Enable1:CPU over-write Enable, del_value and del_addr will affect the RGMII interfacetiming adjustment0:Del_value and del_addr will not affect RGMII interface timing adjustment(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr 0x00000103

#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_SIZE 1

/*
 * This structure should be used to declare and program RGMII_TIME_DLY_CTRL_IMP.
 *
 */
typedef union BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_s {
	uint32_t v[1];
	uint32_t rgmii_time_dly_ctrl_imp[1];
	uint32_t _rgmii_time_dly_ctrl_imp;
} BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_t;

#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_CLR(r) (r).rgmii_time_dly_ctrl_imp[0] = 0
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_SET(r,d) (r).rgmii_time_dly_ctrl_imp[0] = d
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_GET(r) (r).rgmii_time_dly_ctrl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_ADDRf_GET(r) (((r).rgmii_time_dly_ctrl_imp[0]) & 0xf)
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_ADDRf_SET(r,f) (r).rgmii_time_dly_ctrl_imp[0]=(((r).rgmii_time_dly_ctrl_imp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_VALUEf_GET(r) ((((r).rgmii_time_dly_ctrl_imp[0]) >> 4) & 0x7)
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_VALUEf_SET(r,f) (r).rgmii_time_dly_ctrl_imp[0]=(((r).rgmii_time_dly_ctrl_imp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DEL_STRBf_GET(r) ((((r).rgmii_time_dly_ctrl_imp[0]) >> 7) & 0x1)
#define BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DEL_STRBf_SET(r,f) (r).rgmii_time_dly_ctrl_imp[0]=(((r).rgmii_time_dly_ctrl_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RGMII_TIME_DLY_CTRL_IMP.
 *
 */
#define BCM53600_A0_READ_RGMII_TIME_DLY_CTRL_IMPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr,(r._rgmii_time_dly_ctrl_imp),1)
#define BCM53600_A0_WRITE_RGMII_TIME_DLY_CTRL_IMPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr,&(r._rgmii_time_dly_ctrl_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_TIME_DLY_CTRL_IMPr BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr
#define RGMII_TIME_DLY_CTRL_IMPr_SIZE BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_SIZE
typedef BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_t RGMII_TIME_DLY_CTRL_IMPr_t;
#define RGMII_TIME_DLY_CTRL_IMPr_CLR BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_CLR
#define RGMII_TIME_DLY_CTRL_IMPr_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_SET
#define RGMII_TIME_DLY_CTRL_IMPr_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_GET
#define RGMII_TIME_DLY_CTRL_IMPr_DLY_ADDRf_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_ADDRf_GET
#define RGMII_TIME_DLY_CTRL_IMPr_DLY_ADDRf_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_ADDRf_SET
#define RGMII_TIME_DLY_CTRL_IMPr_DLY_VALUEf_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_VALUEf_GET
#define RGMII_TIME_DLY_CTRL_IMPr_DLY_VALUEf_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DLY_VALUEf_SET
#define RGMII_TIME_DLY_CTRL_IMPr_DEL_STRBf_GET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DEL_STRBf_GET
#define RGMII_TIME_DLY_CTRL_IMPr_DEL_STRBf_SET BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr_DEL_STRBf_SET
#define READ_RGMII_TIME_DLY_CTRL_IMPr BCM53600_A0_READ_RGMII_TIME_DLY_CTRL_IMPr
#define WRITE_RGMII_TIME_DLY_CTRL_IMPr BCM53600_A0_WRITE_RGMII_TIME_DLY_CTRL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RGMII_TIME_DLY_CTRL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RST_TABLE_MEM
 * BLOCKS:   SYS
 * DESC:     Table Memory Reset Control Register
 * SIZE:     32
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB Counter.Default : 1'b0.Set to 1'b1 to reset all MIB counter to zero.When finished, it will be reset to 1'b0.
 *     RST_ARL          Reset ARL Table.Default : 1'b0.Set to 1'b1 to reset L2 ARL Table to zero.When finished, it will be reset to 1'b0.
 *     RST_MCST         Reset L2 Multicast Table.Default : 1'b0.Set to 1'b1 to reset L2 Multicast Table to zero.When finished, it will be reset to 1'b0.
 *     RST_VT           Reset VLAN Table.Default : 1'b0.Set to 1'b1 to reset VLAN Table to zero.When finished, it will be reset to 1'b0.
 *     RST_MSTP         Reset Multiple Spanning Tree Table.Default : 1'b0.Set to 1'b1 to reset Multiple Spanning Tree Table to zero.When finished, it will be reset to 1'b0.
 *     RST_CFP_TCAM     Reset CFP TCAM Data/Mask Table.Default : 1'b0.Set to 1'b1 to reset CFP TCAM Data/Mask Table.When finished, it will be reset to 1'b0.
 *     RST_CFP_ACTION   Reset CFP Action/Policy RAM Table.Default : 1'b0.Set to 1'b1 to reset CFP Action/Policy RAM Table.When finished, it will be reset to 1'b0.
 *     RST_CFP_RATE_METER Reset CFP Rate Meter RAM Table.Default : 1'b0.Set to 1'b1 to reset CFP Rate Meter RAM Table.When finished, it will be reset to 1'b0.
 *     RST_CFP_STATISTIC Reset CFP in-band/out-band Statistic RAM Table.Default : 1'b0.Set to 1'b1 to reset CFP in-band/out-band Statistic RAM Table.When finished, it will be reset to 1'b0.
 *     RST_IVM_KEY_TCAM Reset IVM Key TCAM Data/Mask Table.Default : 1'b0.Set to 1'b1 to reset IVM Key TCAM Data/Mask Table.When finished, it will be reset to 1'b0.
 *     RST_IVM_ACTION   Reset IVM Action RAM Table.Default : 1'b0.Set to 1'b1 to reset IVM Action RAM Table.When finished, it will be reset to 1'b0.
 *     RST_EVM_KEY_TCAM Reset EVM Key TCAM Data/Mask Table.Default : 1'b0.Set to 1'b1 to reset EVM Key TCAM Data/Mask Table.When finished, it will be reset to 1'b0.
 *     RST_EVM_ACTION   Reset EVM Action RAM Table.Default : 1'b0.Set to 1'b1 to reset EVM Action RAM Table.When finished, it will be reset to 1'b0.
 *     RST_IRC          Reset Ingress Rate Control Port Table.Default : 1'b0.Set to 1'b1 to reset Ingress Rate Control Port Table.When finished, it will be reset to 1'b0.
 *     RST_ERC          Reset Egress Rate Control Port Table.Default : 1'b0.Set to 1'b1 to reset Egress Rate Control Port Table.When finished, it will be reset to 1'b0.
 *     RST_1P_TO_TCDP_MAPPING Reset 1P-to-TCDC port Mapping Table.Default : 1'b0.Set to 1'b1 to reset 1P-to-TCDP port Mapping Table.When finished, it will be reset to 1'b0.
 *     RST_TCDP_TO_1P_MAPPING Reset TCDC-to-1P port Mapping Table.Default : 1'b0.Set to 1'b1 to reset TCDC-to-1P port Mapping Table.When finished, it will be reset to 1'b0.
 *     RST_PORT_MASK    Reset Port Mask Table.Default : 1'b0.Set to 1'b1 to reset Port Mask Table.When finished, it will be reset to 1'b0.
 *     RST_MGVP_ID_MAPPING Reset Multicast Group Virtual Port ID Mapping Table.Default : 1'b0.Set to 1'b1 to reset Multicast Group Virtual Port ID Mapping Table.When finished, it will be reset to 1'b0.
 *     RST_VP_VID_MAPPING Reset Virtual Port VID Mapping Table.Default : 1'b0.Set to 1'b1 to reset Virtual Port VID Mapping Table.When finished, it will be reset to 1'b0.
 *     RST_SA_LRN_CNT   Reset SA Learning Counter Configuration Table.Default : 1'b0.Set to 1'b1 to reset SA Learning Counter Configuration Table.When finished, it will be reset to 1'b0.
 *     RST_DSCPECN_TO_TCDP Reset DSCPECN-to-TCDP Mapping Table.Default : 1'b0.Set to 1'b1 to reset DSCP/ECN to TC/DP Mapping Table.When finished, it will be reset to 1'b0.
 *     RST_TCDP_TO_DSCPECN Reset TCDP-to-DSCPECN Mapping Table.Default : 1'b0.Set to 1'b1 to reset TC/DP to DSCP/ECN Mapping Table.When finished, it will be reset to 1'b0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_RST_TABLE_MEMr 0x0000037e

#define BCM53600_A0_RST_TABLE_MEMr_SIZE 4

/*
 * This structure should be used to declare and program RST_TABLE_MEM.
 *
 */
typedef union BCM53600_A0_RST_TABLE_MEMr_s {
	uint32_t v[1];
	uint32_t rst_table_mem[1];
	uint32_t _rst_table_mem;
} BCM53600_A0_RST_TABLE_MEMr_t;

#define BCM53600_A0_RST_TABLE_MEMr_CLR(r) (r).rst_table_mem[0] = 0
#define BCM53600_A0_RST_TABLE_MEMr_SET(r,d) (r).rst_table_mem[0] = d
#define BCM53600_A0_RST_TABLE_MEMr_GET(r) (r).rst_table_mem[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_RST_TABLE_MEMr_RST_MIB_CNTf_GET(r) (((r).rst_table_mem[0]) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_MIB_CNTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_RST_TABLE_MEMr_RST_ARLf_GET(r) ((((r).rst_table_mem[0]) >> 1) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_ARLf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_RST_TABLE_MEMr_RST_MCSTf_GET(r) ((((r).rst_table_mem[0]) >> 2) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_MCSTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_RST_TABLE_MEMr_RST_VTf_GET(r) ((((r).rst_table_mem[0]) >> 3) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_VTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_RST_TABLE_MEMr_RST_MSTPf_GET(r) ((((r).rst_table_mem[0]) >> 4) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_MSTPf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_TCAMf_GET(r) ((((r).rst_table_mem[0]) >> 5) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_TCAMf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_ACTIONf_GET(r) ((((r).rst_table_mem[0]) >> 6) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_ACTIONf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_RATE_METERf_GET(r) ((((r).rst_table_mem[0]) >> 7) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_RATE_METERf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_STATISTICf_GET(r) ((((r).rst_table_mem[0]) >> 8) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_CFP_STATISTICf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_RST_TABLE_MEMr_RST_IVM_KEY_TCAMf_GET(r) ((((r).rst_table_mem[0]) >> 9) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_IVM_KEY_TCAMf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_RST_TABLE_MEMr_RST_IVM_ACTIONf_GET(r) ((((r).rst_table_mem[0]) >> 10) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_IVM_ACTIONf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_RST_TABLE_MEMr_RST_EVM_KEY_TCAMf_GET(r) ((((r).rst_table_mem[0]) >> 11) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_EVM_KEY_TCAMf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_RST_TABLE_MEMr_RST_EVM_ACTIONf_GET(r) ((((r).rst_table_mem[0]) >> 12) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_EVM_ACTIONf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_RST_TABLE_MEMr_RST_IRCf_GET(r) ((((r).rst_table_mem[0]) >> 13) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_IRCf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_RST_TABLE_MEMr_RST_ERCf_GET(r) ((((r).rst_table_mem[0]) >> 14) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_ERCf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_RST_TABLE_MEMr_RST_1P_TO_TCDP_MAPPINGf_GET(r) ((((r).rst_table_mem[0]) >> 15) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_1P_TO_TCDP_MAPPINGf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_1P_MAPPINGf_GET(r) ((((r).rst_table_mem[0]) >> 16) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_1P_MAPPINGf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53600_A0_RST_TABLE_MEMr_RST_PORT_MASKf_GET(r) ((((r).rst_table_mem[0]) >> 17) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_PORT_MASKf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53600_A0_RST_TABLE_MEMr_RST_MGVP_ID_MAPPINGf_GET(r) ((((r).rst_table_mem[0]) >> 18) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_MGVP_ID_MAPPINGf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53600_A0_RST_TABLE_MEMr_RST_VP_VID_MAPPINGf_GET(r) ((((r).rst_table_mem[0]) >> 19) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_VP_VID_MAPPINGf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53600_A0_RST_TABLE_MEMr_RST_SA_LRN_CNTf_GET(r) ((((r).rst_table_mem[0]) >> 20) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_SA_LRN_CNTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53600_A0_RST_TABLE_MEMr_RST_DSCPECN_TO_TCDPf_GET(r) ((((r).rst_table_mem[0]) >> 21) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_DSCPECN_TO_TCDPf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_DSCPECNf_GET(r) ((((r).rst_table_mem[0]) >> 22) & 0x1)
#define BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_DSCPECNf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53600_A0_RST_TABLE_MEMr_RESERVEDf_GET(r) ((((r).rst_table_mem[0]) >> 23) & 0x1ff)
#define BCM53600_A0_RST_TABLE_MEMr_RESERVEDf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1ff << 23)) | ((((uint32_t)f) & 0x1ff) << 23))

/*
 * These macros can be used to access RST_TABLE_MEM.
 *
 */
#define BCM53600_A0_READ_RST_TABLE_MEMr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RST_TABLE_MEMr,(r._rst_table_mem),4)
#define BCM53600_A0_WRITE_RST_TABLE_MEMr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RST_TABLE_MEMr,&(r._rst_table_mem),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RST_TABLE_MEMr BCM53600_A0_RST_TABLE_MEMr
#define RST_TABLE_MEMr_SIZE BCM53600_A0_RST_TABLE_MEMr_SIZE
typedef BCM53600_A0_RST_TABLE_MEMr_t RST_TABLE_MEMr_t;
#define RST_TABLE_MEMr_CLR BCM53600_A0_RST_TABLE_MEMr_CLR
#define RST_TABLE_MEMr_SET BCM53600_A0_RST_TABLE_MEMr_SET
#define RST_TABLE_MEMr_GET BCM53600_A0_RST_TABLE_MEMr_GET
#define RST_TABLE_MEMr_RST_MIB_CNTf_GET BCM53600_A0_RST_TABLE_MEMr_RST_MIB_CNTf_GET
#define RST_TABLE_MEMr_RST_MIB_CNTf_SET BCM53600_A0_RST_TABLE_MEMr_RST_MIB_CNTf_SET
#define RST_TABLE_MEMr_RST_ARLf_GET BCM53600_A0_RST_TABLE_MEMr_RST_ARLf_GET
#define RST_TABLE_MEMr_RST_ARLf_SET BCM53600_A0_RST_TABLE_MEMr_RST_ARLf_SET
#define RST_TABLE_MEMr_RST_MCSTf_GET BCM53600_A0_RST_TABLE_MEMr_RST_MCSTf_GET
#define RST_TABLE_MEMr_RST_MCSTf_SET BCM53600_A0_RST_TABLE_MEMr_RST_MCSTf_SET
#define RST_TABLE_MEMr_RST_VTf_GET BCM53600_A0_RST_TABLE_MEMr_RST_VTf_GET
#define RST_TABLE_MEMr_RST_VTf_SET BCM53600_A0_RST_TABLE_MEMr_RST_VTf_SET
#define RST_TABLE_MEMr_RST_MSTPf_GET BCM53600_A0_RST_TABLE_MEMr_RST_MSTPf_GET
#define RST_TABLE_MEMr_RST_MSTPf_SET BCM53600_A0_RST_TABLE_MEMr_RST_MSTPf_SET
#define RST_TABLE_MEMr_RST_CFP_TCAMf_GET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_TCAMf_GET
#define RST_TABLE_MEMr_RST_CFP_TCAMf_SET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_TCAMf_SET
#define RST_TABLE_MEMr_RST_CFP_ACTIONf_GET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_ACTIONf_GET
#define RST_TABLE_MEMr_RST_CFP_ACTIONf_SET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_ACTIONf_SET
#define RST_TABLE_MEMr_RST_CFP_RATE_METERf_GET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_RATE_METERf_GET
#define RST_TABLE_MEMr_RST_CFP_RATE_METERf_SET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_RATE_METERf_SET
#define RST_TABLE_MEMr_RST_CFP_STATISTICf_GET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_STATISTICf_GET
#define RST_TABLE_MEMr_RST_CFP_STATISTICf_SET BCM53600_A0_RST_TABLE_MEMr_RST_CFP_STATISTICf_SET
#define RST_TABLE_MEMr_RST_IVM_KEY_TCAMf_GET BCM53600_A0_RST_TABLE_MEMr_RST_IVM_KEY_TCAMf_GET
#define RST_TABLE_MEMr_RST_IVM_KEY_TCAMf_SET BCM53600_A0_RST_TABLE_MEMr_RST_IVM_KEY_TCAMf_SET
#define RST_TABLE_MEMr_RST_IVM_ACTIONf_GET BCM53600_A0_RST_TABLE_MEMr_RST_IVM_ACTIONf_GET
#define RST_TABLE_MEMr_RST_IVM_ACTIONf_SET BCM53600_A0_RST_TABLE_MEMr_RST_IVM_ACTIONf_SET
#define RST_TABLE_MEMr_RST_EVM_KEY_TCAMf_GET BCM53600_A0_RST_TABLE_MEMr_RST_EVM_KEY_TCAMf_GET
#define RST_TABLE_MEMr_RST_EVM_KEY_TCAMf_SET BCM53600_A0_RST_TABLE_MEMr_RST_EVM_KEY_TCAMf_SET
#define RST_TABLE_MEMr_RST_EVM_ACTIONf_GET BCM53600_A0_RST_TABLE_MEMr_RST_EVM_ACTIONf_GET
#define RST_TABLE_MEMr_RST_EVM_ACTIONf_SET BCM53600_A0_RST_TABLE_MEMr_RST_EVM_ACTIONf_SET
#define RST_TABLE_MEMr_RST_IRCf_GET BCM53600_A0_RST_TABLE_MEMr_RST_IRCf_GET
#define RST_TABLE_MEMr_RST_IRCf_SET BCM53600_A0_RST_TABLE_MEMr_RST_IRCf_SET
#define RST_TABLE_MEMr_RST_ERCf_GET BCM53600_A0_RST_TABLE_MEMr_RST_ERCf_GET
#define RST_TABLE_MEMr_RST_ERCf_SET BCM53600_A0_RST_TABLE_MEMr_RST_ERCf_SET
#define RST_TABLE_MEMr_RST_1P_TO_TCDP_MAPPINGf_GET BCM53600_A0_RST_TABLE_MEMr_RST_1P_TO_TCDP_MAPPINGf_GET
#define RST_TABLE_MEMr_RST_1P_TO_TCDP_MAPPINGf_SET BCM53600_A0_RST_TABLE_MEMr_RST_1P_TO_TCDP_MAPPINGf_SET
#define RST_TABLE_MEMr_RST_TCDP_TO_1P_MAPPINGf_GET BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_1P_MAPPINGf_GET
#define RST_TABLE_MEMr_RST_TCDP_TO_1P_MAPPINGf_SET BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_1P_MAPPINGf_SET
#define RST_TABLE_MEMr_RST_PORT_MASKf_GET BCM53600_A0_RST_TABLE_MEMr_RST_PORT_MASKf_GET
#define RST_TABLE_MEMr_RST_PORT_MASKf_SET BCM53600_A0_RST_TABLE_MEMr_RST_PORT_MASKf_SET
#define RST_TABLE_MEMr_RST_MGVP_ID_MAPPINGf_GET BCM53600_A0_RST_TABLE_MEMr_RST_MGVP_ID_MAPPINGf_GET
#define RST_TABLE_MEMr_RST_MGVP_ID_MAPPINGf_SET BCM53600_A0_RST_TABLE_MEMr_RST_MGVP_ID_MAPPINGf_SET
#define RST_TABLE_MEMr_RST_VP_VID_MAPPINGf_GET BCM53600_A0_RST_TABLE_MEMr_RST_VP_VID_MAPPINGf_GET
#define RST_TABLE_MEMr_RST_VP_VID_MAPPINGf_SET BCM53600_A0_RST_TABLE_MEMr_RST_VP_VID_MAPPINGf_SET
#define RST_TABLE_MEMr_RST_SA_LRN_CNTf_GET BCM53600_A0_RST_TABLE_MEMr_RST_SA_LRN_CNTf_GET
#define RST_TABLE_MEMr_RST_SA_LRN_CNTf_SET BCM53600_A0_RST_TABLE_MEMr_RST_SA_LRN_CNTf_SET
#define RST_TABLE_MEMr_RST_DSCPECN_TO_TCDPf_GET BCM53600_A0_RST_TABLE_MEMr_RST_DSCPECN_TO_TCDPf_GET
#define RST_TABLE_MEMr_RST_DSCPECN_TO_TCDPf_SET BCM53600_A0_RST_TABLE_MEMr_RST_DSCPECN_TO_TCDPf_SET
#define RST_TABLE_MEMr_RST_TCDP_TO_DSCPECNf_GET BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_DSCPECNf_GET
#define RST_TABLE_MEMr_RST_TCDP_TO_DSCPECNf_SET BCM53600_A0_RST_TABLE_MEMr_RST_TCDP_TO_DSCPECNf_SET
#define RST_TABLE_MEMr_RESERVEDf_GET BCM53600_A0_RST_TABLE_MEMr_RESERVEDf_GET
#define RST_TABLE_MEMr_RESERVEDf_SET BCM53600_A0_RST_TABLE_MEMr_RESERVEDf_SET
#define READ_RST_TABLE_MEMr BCM53600_A0_READ_RST_TABLE_MEMr
#define WRITE_RST_TABLE_MEMr BCM53600_A0_WRITE_RST_TABLE_MEMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RST_TABLE_MEMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXALIGNMENTERRORSr 0x00005134

#define BCM53600_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 *
 */
typedef union BCM53600_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM53600_A0_RXALIGNMENTERRORSr_t;

#define BCM53600_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM53600_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM53600_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 *
 */
#define BCM53600_A0_READ_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM53600_A0_WRITE_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM53600_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM53600_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM53600_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM53600_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM53600_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM53600_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM53600_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM53600_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXBROADCASTPKTSr 0x00005150

#define BCM53600_A0_RXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkts.
 *
 */
typedef union BCM53600_A0_RXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkts[1];
	uint32_t _rxbroadcastpkts;
} BCM53600_A0_RXBROADCASTPKTSr_t;

#define BCM53600_A0_RXBROADCASTPKTSr_CLR(r) (r).rxbroadcastpkts[0] = 0
#define BCM53600_A0_RXBROADCASTPKTSr_SET(r,d) (r).rxbroadcastpkts[0] = d
#define BCM53600_A0_RXBROADCASTPKTSr_GET(r) (r).rxbroadcastpkts[0]


/*
 * These macros can be used to access RxBroadcastPkts.
 *
 */
#define BCM53600_A0_READ_RXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXBROADCASTPKTSr,(r._rxbroadcastpkts),4)
#define BCM53600_A0_WRITE_RXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXBROADCASTPKTSr,&(r._rxbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTSr BCM53600_A0_RXBROADCASTPKTSr
#define RXBROADCASTPKTSr_SIZE BCM53600_A0_RXBROADCASTPKTSr_SIZE
typedef BCM53600_A0_RXBROADCASTPKTSr_t RXBROADCASTPKTSr_t;
#define RXBROADCASTPKTSr_CLR BCM53600_A0_RXBROADCASTPKTSr_CLR
#define RXBROADCASTPKTSr_SET BCM53600_A0_RXBROADCASTPKTSr_SET
#define RXBROADCASTPKTSr_GET BCM53600_A0_RXBROADCASTPKTSr_GET
#define READ_RXBROADCASTPKTSr BCM53600_A0_READ_RXBROADCASTPKTSr
#define WRITE_RXBROADCASTPKTSr BCM53600_A0_WRITE_RXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXFCSERRORSr 0x00005138

#define BCM53600_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 *
 */
typedef union BCM53600_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM53600_A0_RXFCSERRORSr_t;

#define BCM53600_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM53600_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM53600_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 *
 */
#define BCM53600_A0_READ_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM53600_A0_WRITE_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM53600_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM53600_A0_RXFCSERRORSr_SIZE
typedef BCM53600_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM53600_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM53600_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM53600_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM53600_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM53600_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxFragments
 * BLOCKS:   SYS
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXFRAGMENTSr 0x00005154

#define BCM53600_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 *
 */
typedef union BCM53600_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM53600_A0_RXFRAGMENTSr_t;

#define BCM53600_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM53600_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM53600_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 *
 */
#define BCM53600_A0_READ_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM53600_A0_WRITE_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM53600_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM53600_A0_RXFRAGMENTSr_SIZE
typedef BCM53600_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM53600_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM53600_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM53600_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM53600_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM53600_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxFwdDiscPkts
 * BLOCKS:   SYS
 * DESC:     Rx Forward Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXFWDDISCPKTSr 0x00005160

#define BCM53600_A0_RXFWDDISCPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFwdDiscPkts.
 *
 */
typedef union BCM53600_A0_RXFWDDISCPKTSr_s {
	uint32_t v[1];
	uint32_t rxfwddiscpkts[1];
	uint32_t _rxfwddiscpkts;
} BCM53600_A0_RXFWDDISCPKTSr_t;

#define BCM53600_A0_RXFWDDISCPKTSr_CLR(r) (r).rxfwddiscpkts[0] = 0
#define BCM53600_A0_RXFWDDISCPKTSr_SET(r,d) (r).rxfwddiscpkts[0] = d
#define BCM53600_A0_RXFWDDISCPKTSr_GET(r) (r).rxfwddiscpkts[0]


/*
 * These macros can be used to access RxFwdDiscPkts.
 *
 */
#define BCM53600_A0_READ_RXFWDDISCPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXFWDDISCPKTSr,(r._rxfwddiscpkts),4)
#define BCM53600_A0_WRITE_RXFWDDISCPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXFWDDISCPKTSr,&(r._rxfwddiscpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFWDDISCPKTSr BCM53600_A0_RXFWDDISCPKTSr
#define RXFWDDISCPKTSr_SIZE BCM53600_A0_RXFWDDISCPKTSr_SIZE
typedef BCM53600_A0_RXFWDDISCPKTSr_t RXFWDDISCPKTSr_t;
#define RXFWDDISCPKTSr_CLR BCM53600_A0_RXFWDDISCPKTSr_CLR
#define RXFWDDISCPKTSr_SET BCM53600_A0_RXFWDDISCPKTSr_SET
#define RXFWDDISCPKTSr_GET BCM53600_A0_RXFWDDISCPKTSr_GET
#define READ_RXFWDDISCPKTSr BCM53600_A0_READ_RXFWDDISCPKTSr
#define WRITE_RXFWDDISCPKTSr BCM53600_A0_WRITE_RXFWDDISCPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXFWDDISCPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_RXGOODOCTETSr 0x0000513c

#define BCM53600_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 *
 */
typedef union BCM53600_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM53600_A0_RXGOODOCTETSr_t;

#define BCM53600_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM53600_A0_RXGOODOCTETSr_t))
#define BCM53600_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM53600_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 *
 */
#define BCM53600_A0_READ_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM53600_A0_WRITE_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM53600_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM53600_A0_RXGOODOCTETSr_SIZE
typedef BCM53600_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM53600_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM53600_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM53600_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM53600_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM53600_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxJabberPkts
 * BLOCKS:   SYS
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXJABBERPKTSr 0x00005130

#define BCM53600_A0_RXJABBERPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabberPkts.
 *
 */
typedef union BCM53600_A0_RXJABBERPKTSr_s {
	uint32_t v[1];
	uint32_t rxjabberpkts[1];
	uint32_t _rxjabberpkts;
} BCM53600_A0_RXJABBERPKTSr_t;

#define BCM53600_A0_RXJABBERPKTSr_CLR(r) (r).rxjabberpkts[0] = 0
#define BCM53600_A0_RXJABBERPKTSr_SET(r,d) (r).rxjabberpkts[0] = d
#define BCM53600_A0_RXJABBERPKTSr_GET(r) (r).rxjabberpkts[0]


/*
 * These macros can be used to access RxJabberPkts.
 *
 */
#define BCM53600_A0_READ_RXJABBERPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXJABBERPKTSr,(r._rxjabberpkts),4)
#define BCM53600_A0_WRITE_RXJABBERPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXJABBERPKTSr,&(r._rxjabberpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERPKTSr BCM53600_A0_RXJABBERPKTSr
#define RXJABBERPKTSr_SIZE BCM53600_A0_RXJABBERPKTSr_SIZE
typedef BCM53600_A0_RXJABBERPKTSr_t RXJABBERPKTSr_t;
#define RXJABBERPKTSr_CLR BCM53600_A0_RXJABBERPKTSr_CLR
#define RXJABBERPKTSr_SET BCM53600_A0_RXJABBERPKTSr_SET
#define RXJABBERPKTSr_GET BCM53600_A0_RXJABBERPKTSr_GET
#define READ_RXJABBERPKTSr BCM53600_A0_READ_RXJABBERPKTSr
#define WRITE_RXJABBERPKTSr BCM53600_A0_WRITE_RXJABBERPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXJABBERPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXMULTICASTPKTSr 0x0000514c

#define BCM53600_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 *
 */
typedef union BCM53600_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM53600_A0_RXMULTICASTPKTSr_t;

#define BCM53600_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM53600_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM53600_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 *
 */
#define BCM53600_A0_READ_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM53600_A0_WRITE_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM53600_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM53600_A0_RXMULTICASTPKTSr_SIZE
typedef BCM53600_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM53600_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM53600_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM53600_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM53600_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM53600_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxOctets
 * BLOCKS:   SYS
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_RXOCTETSr 0x0000511c

#define BCM53600_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 *
 */
typedef union BCM53600_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM53600_A0_RXOCTETSr_t;

#define BCM53600_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM53600_A0_RXOCTETSr_t))
#define BCM53600_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM53600_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 *
 */
#define BCM53600_A0_READ_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM53600_A0_WRITE_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM53600_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM53600_A0_RXOCTETSr_SIZE
typedef BCM53600_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM53600_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM53600_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM53600_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM53600_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM53600_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXOVERSIZEPKTSr 0x0000512c

#define BCM53600_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 *
 */
typedef union BCM53600_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM53600_A0_RXOVERSIZEPKTSr_t;

#define BCM53600_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM53600_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM53600_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 *
 */
#define BCM53600_A0_READ_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM53600_A0_WRITE_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM53600_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM53600_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM53600_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM53600_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM53600_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM53600_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM53600_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM53600_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPAUSEPKTSr 0x00005128

#define BCM53600_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 *
 */
typedef union BCM53600_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM53600_A0_RXPAUSEPKTSr_t;

#define BCM53600_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM53600_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM53600_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 *
 */
#define BCM53600_A0_READ_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM53600_A0_WRITE_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM53600_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM53600_A0_RXPAUSEPKTSr_SIZE
typedef BCM53600_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM53600_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM53600_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM53600_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM53600_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM53600_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPkts1024toMaxPkt
 * BLOCKS:   SYS
 * DESC:     Rx 1024 Bytes Octets to Standard Maximum Size Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPKTS1024TOMAXPKTr 0x00005114

#define BCM53600_A0_RXPKTS1024TOMAXPKTr_SIZE 4

/*
 * This structure should be used to declare and program RxPkts1024toMaxPkt.
 *
 */
typedef union BCM53600_A0_RXPKTS1024TOMAXPKTr_s {
	uint32_t v[1];
	uint32_t rxpkts1024tomaxpkt[1];
	uint32_t _rxpkts1024tomaxpkt;
} BCM53600_A0_RXPKTS1024TOMAXPKTr_t;

#define BCM53600_A0_RXPKTS1024TOMAXPKTr_CLR(r) (r).rxpkts1024tomaxpkt[0] = 0
#define BCM53600_A0_RXPKTS1024TOMAXPKTr_SET(r,d) (r).rxpkts1024tomaxpkt[0] = d
#define BCM53600_A0_RXPKTS1024TOMAXPKTr_GET(r) (r).rxpkts1024tomaxpkt[0]


/*
 * These macros can be used to access RxPkts1024toMaxPkt.
 *
 */
#define BCM53600_A0_READ_RXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPKTS1024TOMAXPKTr,(r._rxpkts1024tomaxpkt),4)
#define BCM53600_A0_WRITE_RXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPKTS1024TOMAXPKTr,&(r._rxpkts1024tomaxpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPKTS1024TOMAXPKTr BCM53600_A0_RXPKTS1024TOMAXPKTr
#define RXPKTS1024TOMAXPKTr_SIZE BCM53600_A0_RXPKTS1024TOMAXPKTr_SIZE
typedef BCM53600_A0_RXPKTS1024TOMAXPKTr_t RXPKTS1024TOMAXPKTr_t;
#define RXPKTS1024TOMAXPKTr_CLR BCM53600_A0_RXPKTS1024TOMAXPKTr_CLR
#define RXPKTS1024TOMAXPKTr_SET BCM53600_A0_RXPKTS1024TOMAXPKTr_SET
#define RXPKTS1024TOMAXPKTr_GET BCM53600_A0_RXPKTS1024TOMAXPKTr_GET
#define READ_RXPKTS1024TOMAXPKTr BCM53600_A0_READ_RXPKTS1024TOMAXPKTr
#define WRITE_RXPKTS1024TOMAXPKTr BCM53600_A0_WRITE_RXPKTS1024TOMAXPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPKTS1024TOMAXPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPKTS128TO255OCTETSr 0x00005108

#define BCM53600_A0_RXPKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program RxPkts128to255Octets.
 *
 */
typedef union BCM53600_A0_RXPKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t rxpkts128to255octets[1];
	uint32_t _rxpkts128to255octets;
} BCM53600_A0_RXPKTS128TO255OCTETSr_t;

#define BCM53600_A0_RXPKTS128TO255OCTETSr_CLR(r) (r).rxpkts128to255octets[0] = 0
#define BCM53600_A0_RXPKTS128TO255OCTETSr_SET(r,d) (r).rxpkts128to255octets[0] = d
#define BCM53600_A0_RXPKTS128TO255OCTETSr_GET(r) (r).rxpkts128to255octets[0]


/*
 * These macros can be used to access RxPkts128to255Octets.
 *
 */
#define BCM53600_A0_READ_RXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPKTS128TO255OCTETSr,(r._rxpkts128to255octets),4)
#define BCM53600_A0_WRITE_RXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPKTS128TO255OCTETSr,&(r._rxpkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPKTS128TO255OCTETSr BCM53600_A0_RXPKTS128TO255OCTETSr
#define RXPKTS128TO255OCTETSr_SIZE BCM53600_A0_RXPKTS128TO255OCTETSr_SIZE
typedef BCM53600_A0_RXPKTS128TO255OCTETSr_t RXPKTS128TO255OCTETSr_t;
#define RXPKTS128TO255OCTETSr_CLR BCM53600_A0_RXPKTS128TO255OCTETSr_CLR
#define RXPKTS128TO255OCTETSr_SET BCM53600_A0_RXPKTS128TO255OCTETSr_SET
#define RXPKTS128TO255OCTETSr_GET BCM53600_A0_RXPKTS128TO255OCTETSr_GET
#define READ_RXPKTS128TO255OCTETSr BCM53600_A0_READ_RXPKTS128TO255OCTETSr
#define WRITE_RXPKTS128TO255OCTETSr BCM53600_A0_WRITE_RXPKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPKTS256TO511OCTETSr 0x0000510c

#define BCM53600_A0_RXPKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program RxPkts256to511Octets.
 *
 */
typedef union BCM53600_A0_RXPKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t rxpkts256to511octets[1];
	uint32_t _rxpkts256to511octets;
} BCM53600_A0_RXPKTS256TO511OCTETSr_t;

#define BCM53600_A0_RXPKTS256TO511OCTETSr_CLR(r) (r).rxpkts256to511octets[0] = 0
#define BCM53600_A0_RXPKTS256TO511OCTETSr_SET(r,d) (r).rxpkts256to511octets[0] = d
#define BCM53600_A0_RXPKTS256TO511OCTETSr_GET(r) (r).rxpkts256to511octets[0]


/*
 * These macros can be used to access RxPkts256to511Octets.
 *
 */
#define BCM53600_A0_READ_RXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPKTS256TO511OCTETSr,(r._rxpkts256to511octets),4)
#define BCM53600_A0_WRITE_RXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPKTS256TO511OCTETSr,&(r._rxpkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPKTS256TO511OCTETSr BCM53600_A0_RXPKTS256TO511OCTETSr
#define RXPKTS256TO511OCTETSr_SIZE BCM53600_A0_RXPKTS256TO511OCTETSr_SIZE
typedef BCM53600_A0_RXPKTS256TO511OCTETSr_t RXPKTS256TO511OCTETSr_t;
#define RXPKTS256TO511OCTETSr_CLR BCM53600_A0_RXPKTS256TO511OCTETSr_CLR
#define RXPKTS256TO511OCTETSr_SET BCM53600_A0_RXPKTS256TO511OCTETSr_SET
#define RXPKTS256TO511OCTETSr_GET BCM53600_A0_RXPKTS256TO511OCTETSr_GET
#define READ_RXPKTS256TO511OCTETSr BCM53600_A0_READ_RXPKTS256TO511OCTETSr
#define WRITE_RXPKTS256TO511OCTETSr BCM53600_A0_WRITE_RXPKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPKTS512TO1023OCTETSr 0x00005110

#define BCM53600_A0_RXPKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program RxPkts512to1023Octets.
 *
 */
typedef union BCM53600_A0_RXPKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t rxpkts512to1023octets[1];
	uint32_t _rxpkts512to1023octets;
} BCM53600_A0_RXPKTS512TO1023OCTETSr_t;

#define BCM53600_A0_RXPKTS512TO1023OCTETSr_CLR(r) (r).rxpkts512to1023octets[0] = 0
#define BCM53600_A0_RXPKTS512TO1023OCTETSr_SET(r,d) (r).rxpkts512to1023octets[0] = d
#define BCM53600_A0_RXPKTS512TO1023OCTETSr_GET(r) (r).rxpkts512to1023octets[0]


/*
 * These macros can be used to access RxPkts512to1023Octets.
 *
 */
#define BCM53600_A0_READ_RXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPKTS512TO1023OCTETSr,(r._rxpkts512to1023octets),4)
#define BCM53600_A0_WRITE_RXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPKTS512TO1023OCTETSr,&(r._rxpkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPKTS512TO1023OCTETSr BCM53600_A0_RXPKTS512TO1023OCTETSr
#define RXPKTS512TO1023OCTETSr_SIZE BCM53600_A0_RXPKTS512TO1023OCTETSr_SIZE
typedef BCM53600_A0_RXPKTS512TO1023OCTETSr_t RXPKTS512TO1023OCTETSr_t;
#define RXPKTS512TO1023OCTETSr_CLR BCM53600_A0_RXPKTS512TO1023OCTETSr_CLR
#define RXPKTS512TO1023OCTETSr_SET BCM53600_A0_RXPKTS512TO1023OCTETSr_SET
#define RXPKTS512TO1023OCTETSr_GET BCM53600_A0_RXPKTS512TO1023OCTETSr_GET
#define READ_RXPKTS512TO1023OCTETSr BCM53600_A0_READ_RXPKTS512TO1023OCTETSr
#define WRITE_RXPKTS512TO1023OCTETSr BCM53600_A0_WRITE_RXPKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPkts64Octets
 * BLOCKS:   SYS
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPKTS64OCTETSr 0x00005100

#define BCM53600_A0_RXPKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program RxPkts64Octets.
 *
 */
typedef union BCM53600_A0_RXPKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t rxpkts64octets[1];
	uint32_t _rxpkts64octets;
} BCM53600_A0_RXPKTS64OCTETSr_t;

#define BCM53600_A0_RXPKTS64OCTETSr_CLR(r) (r).rxpkts64octets[0] = 0
#define BCM53600_A0_RXPKTS64OCTETSr_SET(r,d) (r).rxpkts64octets[0] = d
#define BCM53600_A0_RXPKTS64OCTETSr_GET(r) (r).rxpkts64octets[0]


/*
 * These macros can be used to access RxPkts64Octets.
 *
 */
#define BCM53600_A0_READ_RXPKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPKTS64OCTETSr,(r._rxpkts64octets),4)
#define BCM53600_A0_WRITE_RXPKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPKTS64OCTETSr,&(r._rxpkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPKTS64OCTETSr BCM53600_A0_RXPKTS64OCTETSr
#define RXPKTS64OCTETSr_SIZE BCM53600_A0_RXPKTS64OCTETSr_SIZE
typedef BCM53600_A0_RXPKTS64OCTETSr_t RXPKTS64OCTETSr_t;
#define RXPKTS64OCTETSr_CLR BCM53600_A0_RXPKTS64OCTETSr_CLR
#define RXPKTS64OCTETSr_SET BCM53600_A0_RXPKTS64OCTETSr_SET
#define RXPKTS64OCTETSr_GET BCM53600_A0_RXPKTS64OCTETSr_GET
#define READ_RXPKTS64OCTETSr BCM53600_A0_READ_RXPKTS64OCTETSr
#define WRITE_RXPKTS64OCTETSr BCM53600_A0_WRITE_RXPKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxPkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXPKTS65TO127OCTETSr 0x00005104

#define BCM53600_A0_RXPKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program RxPkts65to127Octets.
 *
 */
typedef union BCM53600_A0_RXPKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t rxpkts65to127octets[1];
	uint32_t _rxpkts65to127octets;
} BCM53600_A0_RXPKTS65TO127OCTETSr_t;

#define BCM53600_A0_RXPKTS65TO127OCTETSr_CLR(r) (r).rxpkts65to127octets[0] = 0
#define BCM53600_A0_RXPKTS65TO127OCTETSr_SET(r,d) (r).rxpkts65to127octets[0] = d
#define BCM53600_A0_RXPKTS65TO127OCTETSr_GET(r) (r).rxpkts65to127octets[0]


/*
 * These macros can be used to access RxPkts65to127Octets.
 *
 */
#define BCM53600_A0_READ_RXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXPKTS65TO127OCTETSr,(r._rxpkts65to127octets),4)
#define BCM53600_A0_WRITE_RXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXPKTS65TO127OCTETSr,&(r._rxpkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPKTS65TO127OCTETSr BCM53600_A0_RXPKTS65TO127OCTETSr
#define RXPKTS65TO127OCTETSr_SIZE BCM53600_A0_RXPKTS65TO127OCTETSr_SIZE
typedef BCM53600_A0_RXPKTS65TO127OCTETSr_t RXPKTS65TO127OCTETSr_t;
#define RXPKTS65TO127OCTETSr_CLR BCM53600_A0_RXPKTS65TO127OCTETSr_CLR
#define RXPKTS65TO127OCTETSr_SET BCM53600_A0_RXPKTS65TO127OCTETSr_SET
#define RXPKTS65TO127OCTETSr_GET BCM53600_A0_RXPKTS65TO127OCTETSr_GET
#define READ_RXPKTS65TO127OCTETSr BCM53600_A0_READ_RXPKTS65TO127OCTETSr
#define WRITE_RXPKTS65TO127OCTETSr BCM53600_A0_WRITE_RXPKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXPKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxSymbolErr
 * BLOCKS:   SYS
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXSYMBOLERRr 0x0000515c

#define BCM53600_A0_RXSYMBOLERRr_SIZE 4

/*
 * This structure should be used to declare and program RxSymbolErr.
 *
 */
typedef union BCM53600_A0_RXSYMBOLERRr_s {
	uint32_t v[1];
	uint32_t rxsymbolerr[1];
	uint32_t _rxsymbolerr;
} BCM53600_A0_RXSYMBOLERRr_t;

#define BCM53600_A0_RXSYMBOLERRr_CLR(r) (r).rxsymbolerr[0] = 0
#define BCM53600_A0_RXSYMBOLERRr_SET(r,d) (r).rxsymbolerr[0] = d
#define BCM53600_A0_RXSYMBOLERRr_GET(r) (r).rxsymbolerr[0]


/*
 * These macros can be used to access RxSymbolErr.
 *
 */
#define BCM53600_A0_READ_RXSYMBOLERRr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXSYMBOLERRr,(r._rxsymbolerr),4)
#define BCM53600_A0_WRITE_RXSYMBOLERRr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXSYMBOLERRr,&(r._rxsymbolerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBOLERRr BCM53600_A0_RXSYMBOLERRr
#define RXSYMBOLERRr_SIZE BCM53600_A0_RXSYMBOLERRr_SIZE
typedef BCM53600_A0_RXSYMBOLERRr_t RXSYMBOLERRr_t;
#define RXSYMBOLERRr_CLR BCM53600_A0_RXSYMBOLERRr_CLR
#define RXSYMBOLERRr_SET BCM53600_A0_RXSYMBOLERRr_SET
#define RXSYMBOLERRr_GET BCM53600_A0_RXSYMBOLERRr_GET
#define READ_RXSYMBOLERRr BCM53600_A0_READ_RXSYMBOLERRr
#define WRITE_RXSYMBOLERRr BCM53600_A0_WRITE_RXSYMBOLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXSYMBOLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXUNDERSIZEPKTSr 0x00005124

#define BCM53600_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 *
 */
typedef union BCM53600_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM53600_A0_RXUNDERSIZEPKTSr_t;

#define BCM53600_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM53600_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM53600_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 *
 */
#define BCM53600_A0_READ_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM53600_A0_WRITE_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM53600_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM53600_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM53600_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM53600_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM53600_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM53600_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM53600_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM53600_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RXUNICASTPKTSr 0x00005148

#define BCM53600_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 *
 */
typedef union BCM53600_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM53600_A0_RXUNICASTPKTSr_t;

#define BCM53600_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM53600_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM53600_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 *
 */
#define BCM53600_A0_READ_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM53600_A0_WRITE_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM53600_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM53600_A0_RXUNICASTPKTSr_SIZE
typedef BCM53600_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM53600_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM53600_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM53600_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM53600_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM53600_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  Rx_Jumbo_Packet_Counter
 * BLOCKS:   SYS
 * DESC:     Rx Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_RX_JUMBO_PACKET_COUNTERr 0x00005118

#define BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program Rx_Jumbo_Packet_Counter.
 *
 */
typedef union BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_s {
	uint32_t v[1];
	uint32_t rx_jumbo_packet_counter[1];
	uint32_t _rx_jumbo_packet_counter;
} BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_t;

#define BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_CLR(r) (r).rx_jumbo_packet_counter[0] = 0
#define BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_SET(r,d) (r).rx_jumbo_packet_counter[0] = d
#define BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_GET(r) (r).rx_jumbo_packet_counter[0]


/*
 * These macros can be used to access Rx_Jumbo_Packet_Counter.
 *
 */
#define BCM53600_A0_READ_RX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_read(u,BCM53600_A0_RX_JUMBO_PACKET_COUNTERr,(r._rx_jumbo_packet_counter),4)
#define BCM53600_A0_WRITE_RX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_write(u,BCM53600_A0_RX_JUMBO_PACKET_COUNTERr,&(r._rx_jumbo_packet_counter),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_JUMBO_PACKET_COUNTERr BCM53600_A0_RX_JUMBO_PACKET_COUNTERr
#define RX_JUMBO_PACKET_COUNTERr_SIZE BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_SIZE
typedef BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_t RX_JUMBO_PACKET_COUNTERr_t;
#define RX_JUMBO_PACKET_COUNTERr_CLR BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_CLR
#define RX_JUMBO_PACKET_COUNTERr_SET BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_SET
#define RX_JUMBO_PACKET_COUNTERr_GET BCM53600_A0_RX_JUMBO_PACKET_COUNTERr_GET
#define READ_RX_JUMBO_PACKET_COUNTERr BCM53600_A0_READ_RX_JUMBO_PACKET_COUNTERr
#define WRITE_RX_JUMBO_PACKET_COUNTERr BCM53600_A0_WRITE_RX_JUMBO_PACKET_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_RX_JUMBO_PACKET_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  SA_LRN_CNT
 * BLOCKS:   SYS
 * DESC:     SA_LRN_CNT Table
 * SIZE:     32
 * FIELDS:
 *     SA_LRN_CNT_LIM   max number of SA is allowed to learn
 *     SA_LRN_CNT_NO    increase when a new SA is learnd
 *
 ******************************************************************************/
#define BCM53600_A0_SA_LRN_CNTm 0x00000000

#define BCM53600_A0_SA_LRN_CNTm_MIN 0
#define BCM53600_A0_SA_LRN_CNTm_MAX 28
#define BCM53600_A0_SA_LRN_CNTm_CMAX(u) 28
#define BCM53600_A0_SA_LRN_CNTm_SIZE 4

/*
 * This structure should be used to declare and program SA_LRN_CNT.
 *
 */
typedef union BCM53600_A0_SA_LRN_CNTm_s {
	uint32_t v[1];
	uint32_t sa_lrn_cnt[1];
	uint32_t _sa_lrn_cnt;
} BCM53600_A0_SA_LRN_CNTm_t;

#define BCM53600_A0_SA_LRN_CNTm_CLR(r) (r).sa_lrn_cnt[0] = 0
#define BCM53600_A0_SA_LRN_CNTm_SET(r,d) (r).sa_lrn_cnt[0] = d
#define BCM53600_A0_SA_LRN_CNTm_GET(r) (r).sa_lrn_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_LIMf_GET(r) (((r).sa_lrn_cnt[0]) & 0xffff)
#define BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_LIMf_SET(r,f) (r).sa_lrn_cnt[0]=(((r).sa_lrn_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_NOf_GET(r) ((((r).sa_lrn_cnt[0]) >> 16) & 0xffff)
#define BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_NOf_SET(r,f) (r).sa_lrn_cnt[0]=(((r).sa_lrn_cnt[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access SA_LRN_CNT.
 *
 */
#define BCM53600_A0_READ_SA_LRN_CNTm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_SA_LRN_CNTm,i,(m),4)
#define BCM53600_A0_WRITE_SA_LRN_CNTm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_SA_LRN_CNTm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SA_LRN_CNTm BCM53600_A0_SA_LRN_CNTm
#define SA_LRN_CNTm_MIN BCM53600_A0_SA_LRN_CNTm_MIN
#define SA_LRN_CNTm_MAX BCM53600_A0_SA_LRN_CNTm_MAX
#define SA_LRN_CNTm_CMAX(u) BCM53600_A0_SA_LRN_CNTm_CMAX(u)
#define SA_LRN_CNTm_SIZE BCM53600_A0_SA_LRN_CNTm_SIZE
typedef BCM53600_A0_SA_LRN_CNTm_t SA_LRN_CNTm_t;
#define SA_LRN_CNTm_CLR BCM53600_A0_SA_LRN_CNTm_CLR
#define SA_LRN_CNTm_SET BCM53600_A0_SA_LRN_CNTm_SET
#define SA_LRN_CNTm_GET BCM53600_A0_SA_LRN_CNTm_GET
#define SA_LRN_CNTm_SA_LRN_CNT_LIMf_GET BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_LIMf_GET
#define SA_LRN_CNTm_SA_LRN_CNT_LIMf_SET BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_LIMf_SET
#define SA_LRN_CNTm_SA_LRN_CNT_NOf_GET BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_NOf_GET
#define SA_LRN_CNTm_SA_LRN_CNT_NOf_SET BCM53600_A0_SA_LRN_CNTm_SA_LRN_CNT_NOf_SET
#define READ_SA_LRN_CNTm BCM53600_A0_READ_SA_LRN_CNTm
#define WRITE_SA_LRN_CNTm BCM53600_A0_WRITE_SA_LRN_CNTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SA_LRN_CNTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SCAN_RSLT_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port Scan Result Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status.1: Link Up0: Link Down
 *     DUPLX_MODE       Duplex Mode Status,0: Half Duplex,1: Full Duplex.
 *     SPEED            Speed Status 2'b11 : 2500M(for 2.5G port)2'b10 : 1000M2'b01 : 100M2'b00 : 10M
 *     RXFLOW_CNTL      Rx XOFF status.0: Not PAUSE capable.1: PAUSE capable.
 *     TXFLOW_CNTL      Tx XOFF status.0: Not PAUSE capable.1: PAUSE capable.
 *     SCAN_TIMEOUT_ERR PHY scan register Time-Out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SCAN_RSLT_GPr 0x00190169

#define BCM53600_A0_SCAN_RSLT_GPr_SIZE 1

/*
 * This structure should be used to declare and program SCAN_RSLT_GP.
 *
 */
typedef union BCM53600_A0_SCAN_RSLT_GPr_s {
	uint32_t v[1];
	uint32_t scan_rslt_gp[1];
	uint32_t _scan_rslt_gp;
} BCM53600_A0_SCAN_RSLT_GPr_t;

#define BCM53600_A0_SCAN_RSLT_GPr_CLR(r) (r).scan_rslt_gp[0] = 0
#define BCM53600_A0_SCAN_RSLT_GPr_SET(r,d) (r).scan_rslt_gp[0] = d
#define BCM53600_A0_SCAN_RSLT_GPr_GET(r) (r).scan_rslt_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SCAN_RSLT_GPr_LINK_STSf_GET(r) (((r).scan_rslt_gp[0]) & 0x1)
#define BCM53600_A0_SCAN_RSLT_GPr_LINK_STSf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SCAN_RSLT_GPr_DUPLX_MODEf_GET(r) ((((r).scan_rslt_gp[0]) >> 1) & 0x1)
#define BCM53600_A0_SCAN_RSLT_GPr_DUPLX_MODEf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SCAN_RSLT_GPr_SPEEDf_GET(r) ((((r).scan_rslt_gp[0]) >> 2) & 0x3)
#define BCM53600_A0_SCAN_RSLT_GPr_SPEEDf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_GET(r) ((((r).scan_rslt_gp[0]) >> 4) & 0x1)
#define BCM53600_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_GET(r) ((((r).scan_rslt_gp[0]) >> 5) & 0x1)
#define BCM53600_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_GET(r) ((((r).scan_rslt_gp[0]) >> 6) & 0x1)
#define BCM53600_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_SCAN_RSLT_GPr_RESERVEDf_GET(r) ((((r).scan_rslt_gp[0]) >> 7) & 0x1)
#define BCM53600_A0_SCAN_RSLT_GPr_RESERVEDf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SCAN_RSLT_GP.
 *
 */
#define BCM53600_A0_READ_SCAN_RSLT_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_SCAN_RSLT_GPr,(r._scan_rslt_gp),1)
#define BCM53600_A0_WRITE_SCAN_RSLT_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_SCAN_RSLT_GPr,&(r._scan_rslt_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SCAN_RSLT_GPr BCM53600_A0_SCAN_RSLT_GPr
#define SCAN_RSLT_GPr_SIZE BCM53600_A0_SCAN_RSLT_GPr_SIZE
typedef BCM53600_A0_SCAN_RSLT_GPr_t SCAN_RSLT_GPr_t;
#define SCAN_RSLT_GPr_CLR BCM53600_A0_SCAN_RSLT_GPr_CLR
#define SCAN_RSLT_GPr_SET BCM53600_A0_SCAN_RSLT_GPr_SET
#define SCAN_RSLT_GPr_GET BCM53600_A0_SCAN_RSLT_GPr_GET
#define SCAN_RSLT_GPr_LINK_STSf_GET BCM53600_A0_SCAN_RSLT_GPr_LINK_STSf_GET
#define SCAN_RSLT_GPr_LINK_STSf_SET BCM53600_A0_SCAN_RSLT_GPr_LINK_STSf_SET
#define SCAN_RSLT_GPr_DUPLX_MODEf_GET BCM53600_A0_SCAN_RSLT_GPr_DUPLX_MODEf_GET
#define SCAN_RSLT_GPr_DUPLX_MODEf_SET BCM53600_A0_SCAN_RSLT_GPr_DUPLX_MODEf_SET
#define SCAN_RSLT_GPr_SPEEDf_GET BCM53600_A0_SCAN_RSLT_GPr_SPEEDf_GET
#define SCAN_RSLT_GPr_SPEEDf_SET BCM53600_A0_SCAN_RSLT_GPr_SPEEDf_SET
#define SCAN_RSLT_GPr_RXFLOW_CNTLf_GET BCM53600_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_GET
#define SCAN_RSLT_GPr_RXFLOW_CNTLf_SET BCM53600_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_SET
#define SCAN_RSLT_GPr_TXFLOW_CNTLf_GET BCM53600_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_GET
#define SCAN_RSLT_GPr_TXFLOW_CNTLf_SET BCM53600_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_SET
#define SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_GET BCM53600_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_GET
#define SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_SET BCM53600_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_SET
#define SCAN_RSLT_GPr_RESERVEDf_GET BCM53600_A0_SCAN_RSLT_GPr_RESERVEDf_GET
#define SCAN_RSLT_GPr_RESERVEDf_SET BCM53600_A0_SCAN_RSLT_GPr_RESERVEDf_SET
#define READ_SCAN_RSLT_GPr BCM53600_A0_READ_SCAN_RSLT_GPr
#define WRITE_SCAN_RSLT_GPr BCM53600_A0_WRITE_SCAN_RSLT_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SCAN_RSLT_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SCAN_RSLT_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port Scan Result Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status.1: Link Up0: Link Down
 *     DUPLX_MODE       Duplex Mode Status,0: Half Duplex,1: Full Duplex.
 *     SPEED            Speed Status 2'b11 : 250M(for 2.5G port) 2'b10 : 1000M2'b01 : 100M2'b00 : 10M
 *     RXFLOW_CNTL      Rx XOFF status.0: Not PAUSE capable1: PAUSE capable
 *     TXFLOW_CNTL      Tx XOFF status.0: Not PAUSE capable1: PAUSE capable
 *     SCAN_TIMEOUT_ERR PHY scan register Time-Out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SCAN_RSLT_IMPr 0x00000168

#define BCM53600_A0_SCAN_RSLT_IMPr_SIZE 1

/*
 * This structure should be used to declare and program SCAN_RSLT_IMP.
 *
 */
typedef union BCM53600_A0_SCAN_RSLT_IMPr_s {
	uint32_t v[1];
	uint32_t scan_rslt_imp[1];
	uint32_t _scan_rslt_imp;
} BCM53600_A0_SCAN_RSLT_IMPr_t;

#define BCM53600_A0_SCAN_RSLT_IMPr_CLR(r) (r).scan_rslt_imp[0] = 0
#define BCM53600_A0_SCAN_RSLT_IMPr_SET(r,d) (r).scan_rslt_imp[0] = d
#define BCM53600_A0_SCAN_RSLT_IMPr_GET(r) (r).scan_rslt_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SCAN_RSLT_IMPr_LINK_STSf_GET(r) (((r).scan_rslt_imp[0]) & 0x1)
#define BCM53600_A0_SCAN_RSLT_IMPr_LINK_STSf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SCAN_RSLT_IMPr_DUPLX_MODEf_GET(r) ((((r).scan_rslt_imp[0]) >> 1) & 0x1)
#define BCM53600_A0_SCAN_RSLT_IMPr_DUPLX_MODEf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SCAN_RSLT_IMPr_SPEEDf_GET(r) ((((r).scan_rslt_imp[0]) >> 2) & 0x3)
#define BCM53600_A0_SCAN_RSLT_IMPr_SPEEDf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_SCAN_RSLT_IMPr_RXFLOW_CNTLf_GET(r) ((((r).scan_rslt_imp[0]) >> 4) & 0x1)
#define BCM53600_A0_SCAN_RSLT_IMPr_RXFLOW_CNTLf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_SCAN_RSLT_IMPr_TXFLOW_CNTLf_GET(r) ((((r).scan_rslt_imp[0]) >> 5) & 0x1)
#define BCM53600_A0_SCAN_RSLT_IMPr_TXFLOW_CNTLf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_SCAN_RSLT_IMPr_SCAN_TIMEOUT_ERRf_GET(r) ((((r).scan_rslt_imp[0]) >> 6) & 0x1)
#define BCM53600_A0_SCAN_RSLT_IMPr_SCAN_TIMEOUT_ERRf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_SCAN_RSLT_IMPr_RESERVEDf_GET(r) ((((r).scan_rslt_imp[0]) >> 7) & 0x1)
#define BCM53600_A0_SCAN_RSLT_IMPr_RESERVEDf_SET(r,f) (r).scan_rslt_imp[0]=(((r).scan_rslt_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SCAN_RSLT_IMP.
 *
 */
#define BCM53600_A0_READ_SCAN_RSLT_IMPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SCAN_RSLT_IMPr,(r._scan_rslt_imp),1)
#define BCM53600_A0_WRITE_SCAN_RSLT_IMPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SCAN_RSLT_IMPr,&(r._scan_rslt_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SCAN_RSLT_IMPr BCM53600_A0_SCAN_RSLT_IMPr
#define SCAN_RSLT_IMPr_SIZE BCM53600_A0_SCAN_RSLT_IMPr_SIZE
typedef BCM53600_A0_SCAN_RSLT_IMPr_t SCAN_RSLT_IMPr_t;
#define SCAN_RSLT_IMPr_CLR BCM53600_A0_SCAN_RSLT_IMPr_CLR
#define SCAN_RSLT_IMPr_SET BCM53600_A0_SCAN_RSLT_IMPr_SET
#define SCAN_RSLT_IMPr_GET BCM53600_A0_SCAN_RSLT_IMPr_GET
#define SCAN_RSLT_IMPr_LINK_STSf_GET BCM53600_A0_SCAN_RSLT_IMPr_LINK_STSf_GET
#define SCAN_RSLT_IMPr_LINK_STSf_SET BCM53600_A0_SCAN_RSLT_IMPr_LINK_STSf_SET
#define SCAN_RSLT_IMPr_DUPLX_MODEf_GET BCM53600_A0_SCAN_RSLT_IMPr_DUPLX_MODEf_GET
#define SCAN_RSLT_IMPr_DUPLX_MODEf_SET BCM53600_A0_SCAN_RSLT_IMPr_DUPLX_MODEf_SET
#define SCAN_RSLT_IMPr_SPEEDf_GET BCM53600_A0_SCAN_RSLT_IMPr_SPEEDf_GET
#define SCAN_RSLT_IMPr_SPEEDf_SET BCM53600_A0_SCAN_RSLT_IMPr_SPEEDf_SET
#define SCAN_RSLT_IMPr_RXFLOW_CNTLf_GET BCM53600_A0_SCAN_RSLT_IMPr_RXFLOW_CNTLf_GET
#define SCAN_RSLT_IMPr_RXFLOW_CNTLf_SET BCM53600_A0_SCAN_RSLT_IMPr_RXFLOW_CNTLf_SET
#define SCAN_RSLT_IMPr_TXFLOW_CNTLf_GET BCM53600_A0_SCAN_RSLT_IMPr_TXFLOW_CNTLf_GET
#define SCAN_RSLT_IMPr_TXFLOW_CNTLf_SET BCM53600_A0_SCAN_RSLT_IMPr_TXFLOW_CNTLf_SET
#define SCAN_RSLT_IMPr_SCAN_TIMEOUT_ERRf_GET BCM53600_A0_SCAN_RSLT_IMPr_SCAN_TIMEOUT_ERRf_GET
#define SCAN_RSLT_IMPr_SCAN_TIMEOUT_ERRf_SET BCM53600_A0_SCAN_RSLT_IMPr_SCAN_TIMEOUT_ERRf_SET
#define SCAN_RSLT_IMPr_RESERVEDf_GET BCM53600_A0_SCAN_RSLT_IMPr_RESERVEDf_GET
#define SCAN_RSLT_IMPr_RESERVEDf_SET BCM53600_A0_SCAN_RSLT_IMPr_RESERVEDf_SET
#define READ_SCAN_RSLT_IMPr BCM53600_A0_READ_SCAN_RSLT_IMPr
#define WRITE_SCAN_RSLT_IMPr BCM53600_A0_WRITE_SCAN_RSLT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SCAN_RSLT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SCAN_RSLT_P
 * BLOCKS:   EPIC0
 * DESC:     FE Port Scan Result Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status.1: Link Up0: Link Down
 *     DUPLX_MODE       Duplex Mode Status,0: Half Duplex,1: Full Duplex.
 *     SPEED            Speed Status 1'b1 : 100M1'b0 : 10M
 *     RESERVED_0       Reserved
 *     FLOW_CNTL        XOFF status.0: Not PAUSE capable1: PAUSE capable
 *     SCAN_TIMEOUT_ERR PHY scan register Time-Out.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SCAN_RSLT_Pr 0x00000150

#define BCM53600_A0_SCAN_RSLT_Pr_SIZE 1

/*
 * This structure should be used to declare and program SCAN_RSLT_P.
 *
 */
typedef union BCM53600_A0_SCAN_RSLT_Pr_s {
	uint32_t v[1];
	uint32_t scan_rslt_p[1];
	uint32_t _scan_rslt_p;
} BCM53600_A0_SCAN_RSLT_Pr_t;

#define BCM53600_A0_SCAN_RSLT_Pr_CLR(r) (r).scan_rslt_p[0] = 0
#define BCM53600_A0_SCAN_RSLT_Pr_SET(r,d) (r).scan_rslt_p[0] = d
#define BCM53600_A0_SCAN_RSLT_Pr_GET(r) (r).scan_rslt_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SCAN_RSLT_Pr_LINK_STSf_GET(r) (((r).scan_rslt_p[0]) & 0x1)
#define BCM53600_A0_SCAN_RSLT_Pr_LINK_STSf_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SCAN_RSLT_Pr_DUPLX_MODEf_GET(r) ((((r).scan_rslt_p[0]) >> 1) & 0x1)
#define BCM53600_A0_SCAN_RSLT_Pr_DUPLX_MODEf_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SCAN_RSLT_Pr_SPEEDf_GET(r) ((((r).scan_rslt_p[0]) >> 2) & 0x1)
#define BCM53600_A0_SCAN_RSLT_Pr_SPEEDf_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_SCAN_RSLT_Pr_RESERVED_0f_GET(r) ((((r).scan_rslt_p[0]) >> 3) & 0x3)
#define BCM53600_A0_SCAN_RSLT_Pr_RESERVED_0f_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53600_A0_SCAN_RSLT_Pr_FLOW_CNTLf_GET(r) ((((r).scan_rslt_p[0]) >> 5) & 0x1)
#define BCM53600_A0_SCAN_RSLT_Pr_FLOW_CNTLf_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_SCAN_RSLT_Pr_SCAN_TIMEOUT_ERRf_GET(r) ((((r).scan_rslt_p[0]) >> 6) & 0x1)
#define BCM53600_A0_SCAN_RSLT_Pr_SCAN_TIMEOUT_ERRf_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_SCAN_RSLT_Pr_RESERVED_1f_GET(r) ((((r).scan_rslt_p[0]) >> 7) & 0x1)
#define BCM53600_A0_SCAN_RSLT_Pr_RESERVED_1f_SET(r,f) (r).scan_rslt_p[0]=(((r).scan_rslt_p[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SCAN_RSLT_P.
 *
 */
#define BCM53600_A0_READ_SCAN_RSLT_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_SCAN_RSLT_Pr,(r._scan_rslt_p),1)
#define BCM53600_A0_WRITE_SCAN_RSLT_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_SCAN_RSLT_Pr,&(r._scan_rslt_p),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SCAN_RSLT_Pr BCM53600_A0_SCAN_RSLT_Pr
#define SCAN_RSLT_Pr_SIZE BCM53600_A0_SCAN_RSLT_Pr_SIZE
typedef BCM53600_A0_SCAN_RSLT_Pr_t SCAN_RSLT_Pr_t;
#define SCAN_RSLT_Pr_CLR BCM53600_A0_SCAN_RSLT_Pr_CLR
#define SCAN_RSLT_Pr_SET BCM53600_A0_SCAN_RSLT_Pr_SET
#define SCAN_RSLT_Pr_GET BCM53600_A0_SCAN_RSLT_Pr_GET
#define SCAN_RSLT_Pr_LINK_STSf_GET BCM53600_A0_SCAN_RSLT_Pr_LINK_STSf_GET
#define SCAN_RSLT_Pr_LINK_STSf_SET BCM53600_A0_SCAN_RSLT_Pr_LINK_STSf_SET
#define SCAN_RSLT_Pr_DUPLX_MODEf_GET BCM53600_A0_SCAN_RSLT_Pr_DUPLX_MODEf_GET
#define SCAN_RSLT_Pr_DUPLX_MODEf_SET BCM53600_A0_SCAN_RSLT_Pr_DUPLX_MODEf_SET
#define SCAN_RSLT_Pr_SPEEDf_GET BCM53600_A0_SCAN_RSLT_Pr_SPEEDf_GET
#define SCAN_RSLT_Pr_SPEEDf_SET BCM53600_A0_SCAN_RSLT_Pr_SPEEDf_SET
#define SCAN_RSLT_Pr_RESERVED_0f_GET BCM53600_A0_SCAN_RSLT_Pr_RESERVED_0f_GET
#define SCAN_RSLT_Pr_RESERVED_0f_SET BCM53600_A0_SCAN_RSLT_Pr_RESERVED_0f_SET
#define SCAN_RSLT_Pr_FLOW_CNTLf_GET BCM53600_A0_SCAN_RSLT_Pr_FLOW_CNTLf_GET
#define SCAN_RSLT_Pr_FLOW_CNTLf_SET BCM53600_A0_SCAN_RSLT_Pr_FLOW_CNTLf_SET
#define SCAN_RSLT_Pr_SCAN_TIMEOUT_ERRf_GET BCM53600_A0_SCAN_RSLT_Pr_SCAN_TIMEOUT_ERRf_GET
#define SCAN_RSLT_Pr_SCAN_TIMEOUT_ERRf_SET BCM53600_A0_SCAN_RSLT_Pr_SCAN_TIMEOUT_ERRf_SET
#define SCAN_RSLT_Pr_RESERVED_1f_GET BCM53600_A0_SCAN_RSLT_Pr_RESERVED_1f_GET
#define SCAN_RSLT_Pr_RESERVED_1f_SET BCM53600_A0_SCAN_RSLT_Pr_RESERVED_1f_SET
#define READ_SCAN_RSLT_Pr BCM53600_A0_READ_SCAN_RSLT_Pr
#define WRITE_SCAN_RSLT_Pr BCM53600_A0_WRITE_SCAN_RSLT_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SCAN_RSLT_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SCAN_TIMEOUT
 * BLOCKS:   SYS
 * DESC:     Scan Timeout Register(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     SCAN_TIMEOUT     Scan Timeout(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_SCAN_TIMEOUTr 0x0000001f

#define BCM53600_A0_SCAN_TIMEOUTr_SIZE 1

/*
 * This structure should be used to declare and program SCAN_TIMEOUT.
 *
 */
typedef union BCM53600_A0_SCAN_TIMEOUTr_s {
	uint32_t v[1];
	uint32_t scan_timeout[1];
	uint32_t _scan_timeout;
} BCM53600_A0_SCAN_TIMEOUTr_t;

#define BCM53600_A0_SCAN_TIMEOUTr_CLR(r) (r).scan_timeout[0] = 0
#define BCM53600_A0_SCAN_TIMEOUTr_SET(r,d) (r).scan_timeout[0] = d
#define BCM53600_A0_SCAN_TIMEOUTr_GET(r) (r).scan_timeout[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_GET(r) (((r).scan_timeout[0]) & 0xff)
#define BCM53600_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_SET(r,f) (r).scan_timeout[0]=(((r).scan_timeout[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SCAN_TIMEOUT.
 *
 */
#define BCM53600_A0_READ_SCAN_TIMEOUTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SCAN_TIMEOUTr,(r._scan_timeout),1)
#define BCM53600_A0_WRITE_SCAN_TIMEOUTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SCAN_TIMEOUTr,&(r._scan_timeout),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SCAN_TIMEOUTr BCM53600_A0_SCAN_TIMEOUTr
#define SCAN_TIMEOUTr_SIZE BCM53600_A0_SCAN_TIMEOUTr_SIZE
typedef BCM53600_A0_SCAN_TIMEOUTr_t SCAN_TIMEOUTr_t;
#define SCAN_TIMEOUTr_CLR BCM53600_A0_SCAN_TIMEOUTr_CLR
#define SCAN_TIMEOUTr_SET BCM53600_A0_SCAN_TIMEOUTr_SET
#define SCAN_TIMEOUTr_GET BCM53600_A0_SCAN_TIMEOUTr_GET
#define SCAN_TIMEOUTr_SCAN_TIMEOUTf_GET BCM53600_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_GET
#define SCAN_TIMEOUTr_SCAN_TIMEOUTf_SET BCM53600_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_SET
#define READ_SCAN_TIMEOUTr BCM53600_A0_READ_SCAN_TIMEOUTr
#define WRITE_SCAN_TIMEOUTr BCM53600_A0_WRITE_SCAN_TIMEOUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SCAN_TIMEOUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SECURITY_BYPASS_CTL
 * BLOCKS:   SYS
 * DESC:     Security Bypass Control Registers
 * SIZE:     16
 * FIELDS:
 *     EAP_BYPASS_MAC_BPDU 1 = Enable BPDU frame bypass EAP Port State Filter and SA Filter.(Not2Release)
 *     EAP_BYPASS_MAC_0X 1 = Enable(DA=01-80-c2-00-00-02)or (DA=01-80-c2-00-00-04,05,....,0f)frame bypass EAP Port State Filter and SA Filter.
 *     EAP_BYPASS_MAC_10 1 = Enable(DA=01-80-c2-00-00-10) frame bypass EAP Port State Filterand SA Filter.
 *     EAP_BYPASS_MAC_11_1F 1 = Enable(DA=01-80-c2-00-00-11,12,....,1f) frame bypass EAP Port StateFilter and SA Filter.
 *     EAP_BYPASS_MAC_20 1 = Enable(DA=01-80-c2-00-00-20) frame bypass EAP Port State Filter andSA Filter.
 *     EAP_BYPASS_MAC_21 1 = Enable(DA=01-80-c2-00-00-21) frame bypass EAP Port State Filter andSA Filter.
 *     EAP_BYPASS_MAC_22_2F 1 = Enable(DA=01-80-c2-00-00-22,23,....,2f) frame bypass EAP Port StateFilter and SA Filter.
 *     EAP_BYPASS_ARP   1 = Enable ARP frame bypass EAP Port State Filter and SA Filter.When set, ARP frame (DA=FF-FF-FF-FF-FF-FF & LT=08-06) will bypassEAP Port State Filter and SA Filter.
 *     EAP_BYPASS_DHCP  1 = Enable DHCP frame bypass EAP Port State Filter and SA Filter.
 *     EAP_BYPASS_L2_USER_ADDR 1 = Enable L2 User address frame bypass EAP Port State Filter and SAFilter.
 *     EAP_BYPASS_MAC_03 1 = Enable (DA=01-80-c2-00-00-03) frame bypass EAP Port State Filter andSA Filter.(Not2Release)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SECURITY_BYPASS_CTLr 0x00004001

#define BCM53600_A0_SECURITY_BYPASS_CTLr_SIZE 2

/*
 * This structure should be used to declare and program SECURITY_BYPASS_CTL.
 *
 */
typedef union BCM53600_A0_SECURITY_BYPASS_CTLr_s {
	uint32_t v[1];
	uint32_t security_bypass_ctl[1];
	uint32_t _security_bypass_ctl;
} BCM53600_A0_SECURITY_BYPASS_CTLr_t;

#define BCM53600_A0_SECURITY_BYPASS_CTLr_CLR(r) (r).security_bypass_ctl[0] = 0
#define BCM53600_A0_SECURITY_BYPASS_CTLr_SET(r,d) (r).security_bypass_ctl[0] = d
#define BCM53600_A0_SECURITY_BYPASS_CTLr_GET(r) (r).security_bypass_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_BPDUf_GET(r) (((r).security_bypass_ctl[0]) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_BPDUf_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_0Xf_GET(r) ((((r).security_bypass_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_0Xf_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_10f_GET(r) ((((r).security_bypass_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_10f_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_11_1Ff_GET(r) ((((r).security_bypass_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_11_1Ff_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_20f_GET(r) ((((r).security_bypass_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_20f_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_21f_GET(r) ((((r).security_bypass_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_21f_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_22_2Ff_GET(r) ((((r).security_bypass_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_22_2Ff_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_ARPf_GET(r) ((((r).security_bypass_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_ARPf_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_DHCPf_GET(r) ((((r).security_bypass_ctl[0]) >> 8) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_DHCPf_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_L2_USER_ADDRf_GET(r) ((((r).security_bypass_ctl[0]) >> 9) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_L2_USER_ADDRf_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_03f_GET(r) ((((r).security_bypass_ctl[0]) >> 10) & 0x1)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_03f_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_SECURITY_BYPASS_CTLr_RESERVEDf_GET(r) ((((r).security_bypass_ctl[0]) >> 11) & 0x1f)
#define BCM53600_A0_SECURITY_BYPASS_CTLr_RESERVEDf_SET(r,f) (r).security_bypass_ctl[0]=(((r).security_bypass_ctl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access SECURITY_BYPASS_CTL.
 *
 */
#define BCM53600_A0_READ_SECURITY_BYPASS_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SECURITY_BYPASS_CTLr,(r._security_bypass_ctl),2)
#define BCM53600_A0_WRITE_SECURITY_BYPASS_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SECURITY_BYPASS_CTLr,&(r._security_bypass_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SECURITY_BYPASS_CTLr BCM53600_A0_SECURITY_BYPASS_CTLr
#define SECURITY_BYPASS_CTLr_SIZE BCM53600_A0_SECURITY_BYPASS_CTLr_SIZE
typedef BCM53600_A0_SECURITY_BYPASS_CTLr_t SECURITY_BYPASS_CTLr_t;
#define SECURITY_BYPASS_CTLr_CLR BCM53600_A0_SECURITY_BYPASS_CTLr_CLR
#define SECURITY_BYPASS_CTLr_SET BCM53600_A0_SECURITY_BYPASS_CTLr_SET
#define SECURITY_BYPASS_CTLr_GET BCM53600_A0_SECURITY_BYPASS_CTLr_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_BPDUf_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_BPDUf_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_BPDUf_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_BPDUf_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_0Xf_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_0Xf_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_0Xf_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_0Xf_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_10f_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_10f_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_10f_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_10f_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_11_1Ff_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_11_1Ff_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_11_1Ff_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_11_1Ff_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_20f_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_20f_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_20f_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_20f_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_21f_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_21f_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_21f_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_21f_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_22_2Ff_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_22_2Ff_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_22_2Ff_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_22_2Ff_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_ARPf_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_ARPf_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_ARPf_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_ARPf_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_DHCPf_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_DHCPf_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_DHCPf_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_DHCPf_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_L2_USER_ADDRf_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_L2_USER_ADDRf_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_L2_USER_ADDRf_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_L2_USER_ADDRf_SET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_03f_GET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_03f_GET
#define SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_03f_SET BCM53600_A0_SECURITY_BYPASS_CTLr_EAP_BYPASS_MAC_03f_SET
#define SECURITY_BYPASS_CTLr_RESERVEDf_GET BCM53600_A0_SECURITY_BYPASS_CTLr_RESERVEDf_GET
#define SECURITY_BYPASS_CTLr_RESERVEDf_SET BCM53600_A0_SECURITY_BYPASS_CTLr_RESERVEDf_SET
#define READ_SECURITY_BYPASS_CTLr BCM53600_A0_READ_SECURITY_BYPASS_CTLr
#define WRITE_SECURITY_BYPASS_CTLr BCM53600_A0_WRITE_SECURITY_BYPASS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SECURITY_BYPASS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SECURITY_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     Security Global Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_CHK_OPT       Option to control EAP packet checking.0 : Only check DA=01-80-c2-0-00-03.1 : Full check, including DA, EtherType, Packet Type, non-1Q.(Default)
 *     ROAMING_OPT      This control bit is used in the per port SA learning counter.0 : Not support address roaming.1 : Support address roaming. When the port ID of the ARL entry is changedand updated, the ingress port SA learning counter is incremented, and theorginal port SA learning counter is decremented.(Default)
 *     RX_EAP_EN        Receive EAP PDU Enable.To indicate EAP PDU CPUCopy is enabled or not.1 = Enables all ports to receive EAP packet and forward to the definedPhysical Management Port. Management CPU must set this bit to globallyallow EAP to be received.0 = Drop EAP packet.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SECURITY_GLOBAL_CTLr 0x00004000

#define BCM53600_A0_SECURITY_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program SECURITY_GLOBAL_CTL.
 *
 */
typedef union BCM53600_A0_SECURITY_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t security_global_ctl[1];
	uint32_t _security_global_ctl;
} BCM53600_A0_SECURITY_GLOBAL_CTLr_t;

#define BCM53600_A0_SECURITY_GLOBAL_CTLr_CLR(r) (r).security_global_ctl[0] = 0
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_SET(r,d) (r).security_global_ctl[0] = d
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_GET(r) (r).security_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_EN_CHK_OPTf_GET(r) (((r).security_global_ctl[0]) & 0x1)
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_EN_CHK_OPTf_SET(r,f) (r).security_global_ctl[0]=(((r).security_global_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_ROAMING_OPTf_GET(r) ((((r).security_global_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_ROAMING_OPTf_SET(r,f) (r).security_global_ctl[0]=(((r).security_global_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_RX_EAP_ENf_GET(r) ((((r).security_global_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_RX_EAP_ENf_SET(r,f) (r).security_global_ctl[0]=(((r).security_global_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_RESERVEDf_GET(r) ((((r).security_global_ctl[0]) >> 3) & 0x1f)
#define BCM53600_A0_SECURITY_GLOBAL_CTLr_RESERVEDf_SET(r,f) (r).security_global_ctl[0]=(((r).security_global_ctl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access SECURITY_GLOBAL_CTL.
 *
 */
#define BCM53600_A0_READ_SECURITY_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SECURITY_GLOBAL_CTLr,(r._security_global_ctl),1)
#define BCM53600_A0_WRITE_SECURITY_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SECURITY_GLOBAL_CTLr,&(r._security_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SECURITY_GLOBAL_CTLr BCM53600_A0_SECURITY_GLOBAL_CTLr
#define SECURITY_GLOBAL_CTLr_SIZE BCM53600_A0_SECURITY_GLOBAL_CTLr_SIZE
typedef BCM53600_A0_SECURITY_GLOBAL_CTLr_t SECURITY_GLOBAL_CTLr_t;
#define SECURITY_GLOBAL_CTLr_CLR BCM53600_A0_SECURITY_GLOBAL_CTLr_CLR
#define SECURITY_GLOBAL_CTLr_SET BCM53600_A0_SECURITY_GLOBAL_CTLr_SET
#define SECURITY_GLOBAL_CTLr_GET BCM53600_A0_SECURITY_GLOBAL_CTLr_GET
#define SECURITY_GLOBAL_CTLr_EN_CHK_OPTf_GET BCM53600_A0_SECURITY_GLOBAL_CTLr_EN_CHK_OPTf_GET
#define SECURITY_GLOBAL_CTLr_EN_CHK_OPTf_SET BCM53600_A0_SECURITY_GLOBAL_CTLr_EN_CHK_OPTf_SET
#define SECURITY_GLOBAL_CTLr_ROAMING_OPTf_GET BCM53600_A0_SECURITY_GLOBAL_CTLr_ROAMING_OPTf_GET
#define SECURITY_GLOBAL_CTLr_ROAMING_OPTf_SET BCM53600_A0_SECURITY_GLOBAL_CTLr_ROAMING_OPTf_SET
#define SECURITY_GLOBAL_CTLr_RX_EAP_ENf_GET BCM53600_A0_SECURITY_GLOBAL_CTLr_RX_EAP_ENf_GET
#define SECURITY_GLOBAL_CTLr_RX_EAP_ENf_SET BCM53600_A0_SECURITY_GLOBAL_CTLr_RX_EAP_ENf_SET
#define SECURITY_GLOBAL_CTLr_RESERVEDf_GET BCM53600_A0_SECURITY_GLOBAL_CTLr_RESERVEDf_GET
#define SECURITY_GLOBAL_CTLr_RESERVEDf_SET BCM53600_A0_SECURITY_GLOBAL_CTLr_RESERVEDf_SET
#define READ_SECURITY_GLOBAL_CTLr BCM53600_A0_READ_SECURITY_GLOBAL_CTLr
#define WRITE_SECURITY_GLOBAL_CTLr BCM53600_A0_WRITE_SECURITY_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SECURITY_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     6
 * FIELDS:
 *     CPIC             Software Block Flag for CPIC
 *     EPIC             Software Block Flag for EPIC
 *     EXP              Software Block Flag for EXP
 *     GPIC             Software Block Flag for GPIC
 *     SPI              Software Block Flag for SPI
 *     SYS              Software Block Flag for SYS
 *
 ******************************************************************************/
#define BCM53600_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM53600_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM53600_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM53600_A0_SOFTWARE_BLOCKMAP_t;

#define BCM53600_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM53600_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM53600_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM53600_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SOFTWARE_BLOCKMAP_EPICf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM53600_A0_SOFTWARE_BLOCKMAP_EPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM53600_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_SOFTWARE_BLOCKMAP_GPICf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM53600_A0_SOFTWARE_BLOCKMAP_GPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM53600_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) ((((r).software_blockmap[0]) >> 5) & 0x1)
#define BCM53600_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM53600_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM53600_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM53600_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM53600_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM53600_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM53600_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM53600_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM53600_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_EPICf_GET BCM53600_A0_SOFTWARE_BLOCKMAP_EPICf_GET
#define SOFTWARE_BLOCKMAP_EPICf_SET BCM53600_A0_SOFTWARE_BLOCKMAP_EPICf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM53600_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM53600_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_GPICf_GET BCM53600_A0_SOFTWARE_BLOCKMAP_GPICf_GET
#define SOFTWARE_BLOCKMAP_GPICf_SET BCM53600_A0_SOFTWARE_BLOCKMAP_GPICf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM53600_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM53600_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM53600_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM53600_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define READ_SOFTWARE_BLOCKMAP BCM53600_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM53600_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     64
 * FIELDS:
 *     PORT_SPD_FE      Port Speed for FE portsA 48-bit field to indicate the operating speed for each 10/100 BASE-T portTwo bit for each port. Bits 47:0 = 10/100 ports[port23-port0] respectatively.2'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = Reserved2'b11 = Reserved
 *     PORT_SPD_IMP     Port Speed for IMP Port2'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = 1000Mbps2'b11 = ReservedNote that port speed for the IMP port can only be reported for externaltransceiver by:(a) using the SPD# strap to pass the transceiver's default state to the switch.(b) using the CPU to read the port speed via the MDC/MDIO interface andwrite this back to the IMP Port Status Override register.
 *     PORT_SPD_G0      Port Speed for Giga Port G02'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = 1000Mbps2'b11 = Reserved
 *     PORT_SPD_G1      Port Speed for Giga Port G12'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = 1000Mbps2'b11 = 2500Mbps(for 2.5G port) 
 *     PORT_SPD_G2      Port Speed for Giga Port G22'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = 1000Mbps2'b11 = Reserved
 *     PORT_SPD_G3      Port Speed for Giga Port G32'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = 1000Mbps2'b11 = Reserved 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPDSTSr 0x00000220

#define BCM53600_A0_SPDSTSr_SIZE 8

/*
 * This structure should be used to declare and program SPDSTS.
 *
 */
typedef union BCM53600_A0_SPDSTSr_s {
	uint32_t v[2];
	uint32_t spdsts[2];
	uint32_t _spdsts;
} BCM53600_A0_SPDSTSr_t;

#define BCM53600_A0_SPDSTSr_CLR(r) CDK_MEMSET(&((r)._spdsts), 0, sizeof(BCM53600_A0_SPDSTSr_t))
#define BCM53600_A0_SPDSTSr_SET(r,i,d) (r).spdsts[i] = d
#define BCM53600_A0_SPDSTSr_GET(r,i) (r).spdsts[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPDSTSr_PORT_SPD_FEf_GET(r,a) cdk_field_get((r).spdsts,0,47,a)
#define BCM53600_A0_SPDSTSr_PORT_SPD_FEf_SET(r,a) cdk_field_set((r).spdsts,0,47,a)
#define BCM53600_A0_SPDSTSr_PORT_SPD_IMPf_GET(r) ((((r).spdsts[1]) >> 16) & 0x3)
#define BCM53600_A0_SPDSTSr_PORT_SPD_IMPf_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_SPDSTSr_PORT_SPD_G0f_GET(r) ((((r).spdsts[1]) >> 18) & 0x3)
#define BCM53600_A0_SPDSTSr_PORT_SPD_G0f_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53600_A0_SPDSTSr_PORT_SPD_G1f_GET(r) ((((r).spdsts[1]) >> 20) & 0x3)
#define BCM53600_A0_SPDSTSr_PORT_SPD_G1f_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53600_A0_SPDSTSr_PORT_SPD_G2f_GET(r) ((((r).spdsts[1]) >> 22) & 0x3)
#define BCM53600_A0_SPDSTSr_PORT_SPD_G2f_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_SPDSTSr_PORT_SPD_G3f_GET(r) ((((r).spdsts[1]) >> 24) & 0x3)
#define BCM53600_A0_SPDSTSr_PORT_SPD_G3f_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53600_A0_SPDSTSr_RESERVED_1f_GET(r) ((((r).spdsts[1]) >> 26) & 0x3f)
#define BCM53600_A0_SPDSTSr_RESERVED_1f_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access SPDSTS.
 *
 */
#define BCM53600_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPDSTSr,(r._spdsts),8)
#define BCM53600_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPDSTSr,&(r._spdsts),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM53600_A0_SPDSTSr
#define SPDSTSr_SIZE BCM53600_A0_SPDSTSr_SIZE
typedef BCM53600_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM53600_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM53600_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM53600_A0_SPDSTSr_GET
#define SPDSTSr_PORT_SPD_FEf_GET BCM53600_A0_SPDSTSr_PORT_SPD_FEf_GET
#define SPDSTSr_PORT_SPD_FEf_SET BCM53600_A0_SPDSTSr_PORT_SPD_FEf_SET
#define SPDSTSr_PORT_SPD_IMPf_GET BCM53600_A0_SPDSTSr_PORT_SPD_IMPf_GET
#define SPDSTSr_PORT_SPD_IMPf_SET BCM53600_A0_SPDSTSr_PORT_SPD_IMPf_SET
#define SPDSTSr_PORT_SPD_G0f_GET BCM53600_A0_SPDSTSr_PORT_SPD_G0f_GET
#define SPDSTSr_PORT_SPD_G0f_SET BCM53600_A0_SPDSTSr_PORT_SPD_G0f_SET
#define SPDSTSr_PORT_SPD_G1f_GET BCM53600_A0_SPDSTSr_PORT_SPD_G1f_GET
#define SPDSTSr_PORT_SPD_G1f_SET BCM53600_A0_SPDSTSr_PORT_SPD_G1f_SET
#define SPDSTSr_PORT_SPD_G2f_GET BCM53600_A0_SPDSTSr_PORT_SPD_G2f_GET
#define SPDSTSr_PORT_SPD_G2f_SET BCM53600_A0_SPDSTSr_PORT_SPD_G2f_SET
#define SPDSTSr_PORT_SPD_G3f_GET BCM53600_A0_SPDSTSr_PORT_SPD_G3f_GET
#define SPDSTSr_PORT_SPD_G3f_SET BCM53600_A0_SPDSTSr_PORT_SPD_G3f_SET
#define SPDSTSr_RESERVED_1f_GET BCM53600_A0_SPDSTSr_RESERVED_1f_GET
#define SPDSTSr_RESERVED_1f_SET BCM53600_A0_SPDSTSr_RESERVED_1f_SET
#define READ_SPDSTSr BCM53600_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM53600_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPDSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPECIAL_MNGT
 * BLOCKS:   SYS
 * DESC:     Special Management Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     PASS_ARP_DHCP    When management mode is enabled and "Receive Broadcast Enable" bit is1'b0(Page 01h, Offset a8h, Bit 2), set this bit to allow ARP and DHCP(MAC-DA = broadcast) forwarding to IMP
 *     RESERVED_1       Reserved
 *     EN_ALL0_DA_DROP  Drop All 0 MAC DA Frame Control.When set, any frame with DA = 00:00:00:00:00:00 is dropped,otherwise it is forwarded as is.
 *     EN_MCST_SA_DROP  Drop Multicast SA Frame Control.When set, any frame with SA = multicast is dropped, otherwise it isforwarded as is.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPECIAL_MNGTr 0x00000340

#define BCM53600_A0_SPECIAL_MNGTr_SIZE 1

/*
 * This structure should be used to declare and program SPECIAL_MNGT.
 *
 */
typedef union BCM53600_A0_SPECIAL_MNGTr_s {
	uint32_t v[1];
	uint32_t special_mngt[1];
	uint32_t _special_mngt;
} BCM53600_A0_SPECIAL_MNGTr_t;

#define BCM53600_A0_SPECIAL_MNGTr_CLR(r) (r).special_mngt[0] = 0
#define BCM53600_A0_SPECIAL_MNGTr_SET(r,d) (r).special_mngt[0] = d
#define BCM53600_A0_SPECIAL_MNGTr_GET(r) (r).special_mngt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPECIAL_MNGTr_RESERVED_0f_GET(r) (((r).special_mngt[0]) & 0x1)
#define BCM53600_A0_SPECIAL_MNGTr_RESERVED_0f_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SPECIAL_MNGTr_PASS_ARP_DHCPf_GET(r) ((((r).special_mngt[0]) >> 1) & 0x1)
#define BCM53600_A0_SPECIAL_MNGTr_PASS_ARP_DHCPf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SPECIAL_MNGTr_RESERVED_1f_GET(r) ((((r).special_mngt[0]) >> 2) & 0x1)
#define BCM53600_A0_SPECIAL_MNGTr_RESERVED_1f_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_GET(r) ((((r).special_mngt[0]) >> 3) & 0x1)
#define BCM53600_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_SPECIAL_MNGTr_EN_MCST_SA_DROPf_GET(r) ((((r).special_mngt[0]) >> 4) & 0x1)
#define BCM53600_A0_SPECIAL_MNGTr_EN_MCST_SA_DROPf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_SPECIAL_MNGTr_RESERVED_2f_GET(r) ((((r).special_mngt[0]) >> 5) & 0x7)
#define BCM53600_A0_SPECIAL_MNGTr_RESERVED_2f_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SPECIAL_MNGT.
 *
 */
#define BCM53600_A0_READ_SPECIAL_MNGTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPECIAL_MNGTr,(r._special_mngt),1)
#define BCM53600_A0_WRITE_SPECIAL_MNGTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPECIAL_MNGTr,&(r._special_mngt),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPECIAL_MNGTr BCM53600_A0_SPECIAL_MNGTr
#define SPECIAL_MNGTr_SIZE BCM53600_A0_SPECIAL_MNGTr_SIZE
typedef BCM53600_A0_SPECIAL_MNGTr_t SPECIAL_MNGTr_t;
#define SPECIAL_MNGTr_CLR BCM53600_A0_SPECIAL_MNGTr_CLR
#define SPECIAL_MNGTr_SET BCM53600_A0_SPECIAL_MNGTr_SET
#define SPECIAL_MNGTr_GET BCM53600_A0_SPECIAL_MNGTr_GET
#define SPECIAL_MNGTr_RESERVED_0f_GET BCM53600_A0_SPECIAL_MNGTr_RESERVED_0f_GET
#define SPECIAL_MNGTr_RESERVED_0f_SET BCM53600_A0_SPECIAL_MNGTr_RESERVED_0f_SET
#define SPECIAL_MNGTr_PASS_ARP_DHCPf_GET BCM53600_A0_SPECIAL_MNGTr_PASS_ARP_DHCPf_GET
#define SPECIAL_MNGTr_PASS_ARP_DHCPf_SET BCM53600_A0_SPECIAL_MNGTr_PASS_ARP_DHCPf_SET
#define SPECIAL_MNGTr_RESERVED_1f_GET BCM53600_A0_SPECIAL_MNGTr_RESERVED_1f_GET
#define SPECIAL_MNGTr_RESERVED_1f_SET BCM53600_A0_SPECIAL_MNGTr_RESERVED_1f_SET
#define SPECIAL_MNGTr_EN_ALL0_DA_DROPf_GET BCM53600_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_GET
#define SPECIAL_MNGTr_EN_ALL0_DA_DROPf_SET BCM53600_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_SET
#define SPECIAL_MNGTr_EN_MCST_SA_DROPf_GET BCM53600_A0_SPECIAL_MNGTr_EN_MCST_SA_DROPf_GET
#define SPECIAL_MNGTr_EN_MCST_SA_DROPf_SET BCM53600_A0_SPECIAL_MNGTr_EN_MCST_SA_DROPf_SET
#define SPECIAL_MNGTr_RESERVED_2f_GET BCM53600_A0_SPECIAL_MNGTr_RESERVED_2f_GET
#define SPECIAL_MNGTr_RESERVED_2f_SET BCM53600_A0_SPECIAL_MNGTr_RESERVED_2f_SET
#define READ_SPECIAL_MNGTr BCM53600_A0_READ_SPECIAL_MNGTr
#define WRITE_SPECIAL_MNGTr BCM53600_A0_WRITE_SPECIAL_MNGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPECIAL_MNGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPICTL
 * BLOCKS:   SPI
 * DESC:     SPI Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPICTLr 0x0000fffd

#define BCM53600_A0_SPICTLr_SIZE 1

/*
 * This structure should be used to declare and program SPICTL.
 *
 */
typedef union BCM53600_A0_SPICTLr_s {
	uint32_t v[1];
	uint32_t spictl[1];
	uint32_t _spictl;
} BCM53600_A0_SPICTLr_t;

#define BCM53600_A0_SPICTLr_CLR(r) (r).spictl[0] = 0
#define BCM53600_A0_SPICTLr_SET(r,d) (r).spictl[0] = d
#define BCM53600_A0_SPICTLr_GET(r) (r).spictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPICTLr_RESERVEDf_GET(r) (((r).spictl[0]) & 0xff)
#define BCM53600_A0_SPICTLr_RESERVEDf_SET(r,f) (r).spictl[0]=(((r).spictl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPICTL.
 *
 */
#define BCM53600_A0_READ_SPICTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPICTLr,(r._spictl),1)
#define BCM53600_A0_WRITE_SPICTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPICTLr,&(r._spictl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPICTLr BCM53600_A0_SPICTLr
#define SPICTLr_SIZE BCM53600_A0_SPICTLr_SIZE
typedef BCM53600_A0_SPICTLr_t SPICTLr_t;
#define SPICTLr_CLR BCM53600_A0_SPICTLr_CLR
#define SPICTLr_SET BCM53600_A0_SPICTLr_SET
#define SPICTLr_GET BCM53600_A0_SPICTLr_GET
#define SPICTLr_RESERVEDf_GET BCM53600_A0_SPICTLr_RESERVEDf_GET
#define SPICTLr_RESERVEDf_SET BCM53600_A0_SPICTLr_RESERVEDf_SET
#define READ_SPICTLr BCM53600_A0_READ_SPICTLr
#define WRITE_SPICTLr BCM53600_A0_WRITE_SPICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO0
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 0
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO0r 0x0000fff0

#define BCM53600_A0_SPIDIO0r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO0.
 *
 */
typedef union BCM53600_A0_SPIDIO0r_s {
	uint32_t v[1];
	uint32_t spidio0[1];
	uint32_t _spidio0;
} BCM53600_A0_SPIDIO0r_t;

#define BCM53600_A0_SPIDIO0r_CLR(r) (r).spidio0[0] = 0
#define BCM53600_A0_SPIDIO0r_SET(r,d) (r).spidio0[0] = d
#define BCM53600_A0_SPIDIO0r_GET(r) (r).spidio0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO0r_RESERVEDf_GET(r) (((r).spidio0[0]) & 0xff)
#define BCM53600_A0_SPIDIO0r_RESERVEDf_SET(r,f) (r).spidio0[0]=(((r).spidio0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO0.
 *
 */
#define BCM53600_A0_READ_SPIDIO0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO0r,(r._spidio0),1)
#define BCM53600_A0_WRITE_SPIDIO0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO0r,&(r._spidio0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO0r BCM53600_A0_SPIDIO0r
#define SPIDIO0r_SIZE BCM53600_A0_SPIDIO0r_SIZE
typedef BCM53600_A0_SPIDIO0r_t SPIDIO0r_t;
#define SPIDIO0r_CLR BCM53600_A0_SPIDIO0r_CLR
#define SPIDIO0r_SET BCM53600_A0_SPIDIO0r_SET
#define SPIDIO0r_GET BCM53600_A0_SPIDIO0r_GET
#define SPIDIO0r_RESERVEDf_GET BCM53600_A0_SPIDIO0r_RESERVEDf_GET
#define SPIDIO0r_RESERVEDf_SET BCM53600_A0_SPIDIO0r_RESERVEDf_SET
#define READ_SPIDIO0r BCM53600_A0_READ_SPIDIO0r
#define WRITE_SPIDIO0r BCM53600_A0_WRITE_SPIDIO0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO1
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 1
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO1r 0x0000fff1

#define BCM53600_A0_SPIDIO1r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO1.
 *
 */
typedef union BCM53600_A0_SPIDIO1r_s {
	uint32_t v[1];
	uint32_t spidio1[1];
	uint32_t _spidio1;
} BCM53600_A0_SPIDIO1r_t;

#define BCM53600_A0_SPIDIO1r_CLR(r) (r).spidio1[0] = 0
#define BCM53600_A0_SPIDIO1r_SET(r,d) (r).spidio1[0] = d
#define BCM53600_A0_SPIDIO1r_GET(r) (r).spidio1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO1r_RESERVEDf_GET(r) (((r).spidio1[0]) & 0xff)
#define BCM53600_A0_SPIDIO1r_RESERVEDf_SET(r,f) (r).spidio1[0]=(((r).spidio1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO1.
 *
 */
#define BCM53600_A0_READ_SPIDIO1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO1r,(r._spidio1),1)
#define BCM53600_A0_WRITE_SPIDIO1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO1r,&(r._spidio1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO1r BCM53600_A0_SPIDIO1r
#define SPIDIO1r_SIZE BCM53600_A0_SPIDIO1r_SIZE
typedef BCM53600_A0_SPIDIO1r_t SPIDIO1r_t;
#define SPIDIO1r_CLR BCM53600_A0_SPIDIO1r_CLR
#define SPIDIO1r_SET BCM53600_A0_SPIDIO1r_SET
#define SPIDIO1r_GET BCM53600_A0_SPIDIO1r_GET
#define SPIDIO1r_RESERVEDf_GET BCM53600_A0_SPIDIO1r_RESERVEDf_GET
#define SPIDIO1r_RESERVEDf_SET BCM53600_A0_SPIDIO1r_RESERVEDf_SET
#define READ_SPIDIO1r BCM53600_A0_READ_SPIDIO1r
#define WRITE_SPIDIO1r BCM53600_A0_WRITE_SPIDIO1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO2
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 2
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO2r 0x0000fff2

#define BCM53600_A0_SPIDIO2r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO2.
 *
 */
typedef union BCM53600_A0_SPIDIO2r_s {
	uint32_t v[1];
	uint32_t spidio2[1];
	uint32_t _spidio2;
} BCM53600_A0_SPIDIO2r_t;

#define BCM53600_A0_SPIDIO2r_CLR(r) (r).spidio2[0] = 0
#define BCM53600_A0_SPIDIO2r_SET(r,d) (r).spidio2[0] = d
#define BCM53600_A0_SPIDIO2r_GET(r) (r).spidio2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO2r_RESERVEDf_GET(r) (((r).spidio2[0]) & 0xff)
#define BCM53600_A0_SPIDIO2r_RESERVEDf_SET(r,f) (r).spidio2[0]=(((r).spidio2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO2.
 *
 */
#define BCM53600_A0_READ_SPIDIO2r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO2r,(r._spidio2),1)
#define BCM53600_A0_WRITE_SPIDIO2r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO2r,&(r._spidio2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO2r BCM53600_A0_SPIDIO2r
#define SPIDIO2r_SIZE BCM53600_A0_SPIDIO2r_SIZE
typedef BCM53600_A0_SPIDIO2r_t SPIDIO2r_t;
#define SPIDIO2r_CLR BCM53600_A0_SPIDIO2r_CLR
#define SPIDIO2r_SET BCM53600_A0_SPIDIO2r_SET
#define SPIDIO2r_GET BCM53600_A0_SPIDIO2r_GET
#define SPIDIO2r_RESERVEDf_GET BCM53600_A0_SPIDIO2r_RESERVEDf_GET
#define SPIDIO2r_RESERVEDf_SET BCM53600_A0_SPIDIO2r_RESERVEDf_SET
#define READ_SPIDIO2r BCM53600_A0_READ_SPIDIO2r
#define WRITE_SPIDIO2r BCM53600_A0_WRITE_SPIDIO2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO3
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 3
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO3r 0x0000fff3

#define BCM53600_A0_SPIDIO3r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO3.
 *
 */
typedef union BCM53600_A0_SPIDIO3r_s {
	uint32_t v[1];
	uint32_t spidio3[1];
	uint32_t _spidio3;
} BCM53600_A0_SPIDIO3r_t;

#define BCM53600_A0_SPIDIO3r_CLR(r) (r).spidio3[0] = 0
#define BCM53600_A0_SPIDIO3r_SET(r,d) (r).spidio3[0] = d
#define BCM53600_A0_SPIDIO3r_GET(r) (r).spidio3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO3r_RESERVEDf_GET(r) (((r).spidio3[0]) & 0xff)
#define BCM53600_A0_SPIDIO3r_RESERVEDf_SET(r,f) (r).spidio3[0]=(((r).spidio3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO3.
 *
 */
#define BCM53600_A0_READ_SPIDIO3r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO3r,(r._spidio3),1)
#define BCM53600_A0_WRITE_SPIDIO3r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO3r,&(r._spidio3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO3r BCM53600_A0_SPIDIO3r
#define SPIDIO3r_SIZE BCM53600_A0_SPIDIO3r_SIZE
typedef BCM53600_A0_SPIDIO3r_t SPIDIO3r_t;
#define SPIDIO3r_CLR BCM53600_A0_SPIDIO3r_CLR
#define SPIDIO3r_SET BCM53600_A0_SPIDIO3r_SET
#define SPIDIO3r_GET BCM53600_A0_SPIDIO3r_GET
#define SPIDIO3r_RESERVEDf_GET BCM53600_A0_SPIDIO3r_RESERVEDf_GET
#define SPIDIO3r_RESERVEDf_SET BCM53600_A0_SPIDIO3r_RESERVEDf_SET
#define READ_SPIDIO3r BCM53600_A0_READ_SPIDIO3r
#define WRITE_SPIDIO3r BCM53600_A0_WRITE_SPIDIO3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO4
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 4
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO4r 0x0000fff4

#define BCM53600_A0_SPIDIO4r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO4.
 *
 */
typedef union BCM53600_A0_SPIDIO4r_s {
	uint32_t v[1];
	uint32_t spidio4[1];
	uint32_t _spidio4;
} BCM53600_A0_SPIDIO4r_t;

#define BCM53600_A0_SPIDIO4r_CLR(r) (r).spidio4[0] = 0
#define BCM53600_A0_SPIDIO4r_SET(r,d) (r).spidio4[0] = d
#define BCM53600_A0_SPIDIO4r_GET(r) (r).spidio4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO4r_RESERVEDf_GET(r) (((r).spidio4[0]) & 0xff)
#define BCM53600_A0_SPIDIO4r_RESERVEDf_SET(r,f) (r).spidio4[0]=(((r).spidio4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO4.
 *
 */
#define BCM53600_A0_READ_SPIDIO4r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO4r,(r._spidio4),1)
#define BCM53600_A0_WRITE_SPIDIO4r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO4r,&(r._spidio4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO4r BCM53600_A0_SPIDIO4r
#define SPIDIO4r_SIZE BCM53600_A0_SPIDIO4r_SIZE
typedef BCM53600_A0_SPIDIO4r_t SPIDIO4r_t;
#define SPIDIO4r_CLR BCM53600_A0_SPIDIO4r_CLR
#define SPIDIO4r_SET BCM53600_A0_SPIDIO4r_SET
#define SPIDIO4r_GET BCM53600_A0_SPIDIO4r_GET
#define SPIDIO4r_RESERVEDf_GET BCM53600_A0_SPIDIO4r_RESERVEDf_GET
#define SPIDIO4r_RESERVEDf_SET BCM53600_A0_SPIDIO4r_RESERVEDf_SET
#define READ_SPIDIO4r BCM53600_A0_READ_SPIDIO4r
#define WRITE_SPIDIO4r BCM53600_A0_WRITE_SPIDIO4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO5
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 5
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO5r 0x0000fff5

#define BCM53600_A0_SPIDIO5r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO5.
 *
 */
typedef union BCM53600_A0_SPIDIO5r_s {
	uint32_t v[1];
	uint32_t spidio5[1];
	uint32_t _spidio5;
} BCM53600_A0_SPIDIO5r_t;

#define BCM53600_A0_SPIDIO5r_CLR(r) (r).spidio5[0] = 0
#define BCM53600_A0_SPIDIO5r_SET(r,d) (r).spidio5[0] = d
#define BCM53600_A0_SPIDIO5r_GET(r) (r).spidio5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO5r_RESERVEDf_GET(r) (((r).spidio5[0]) & 0xff)
#define BCM53600_A0_SPIDIO5r_RESERVEDf_SET(r,f) (r).spidio5[0]=(((r).spidio5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO5.
 *
 */
#define BCM53600_A0_READ_SPIDIO5r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO5r,(r._spidio5),1)
#define BCM53600_A0_WRITE_SPIDIO5r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO5r,&(r._spidio5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO5r BCM53600_A0_SPIDIO5r
#define SPIDIO5r_SIZE BCM53600_A0_SPIDIO5r_SIZE
typedef BCM53600_A0_SPIDIO5r_t SPIDIO5r_t;
#define SPIDIO5r_CLR BCM53600_A0_SPIDIO5r_CLR
#define SPIDIO5r_SET BCM53600_A0_SPIDIO5r_SET
#define SPIDIO5r_GET BCM53600_A0_SPIDIO5r_GET
#define SPIDIO5r_RESERVEDf_GET BCM53600_A0_SPIDIO5r_RESERVEDf_GET
#define SPIDIO5r_RESERVEDf_SET BCM53600_A0_SPIDIO5r_RESERVEDf_SET
#define READ_SPIDIO5r BCM53600_A0_READ_SPIDIO5r
#define WRITE_SPIDIO5r BCM53600_A0_WRITE_SPIDIO5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO6
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 6
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO6r 0x0000fff6

#define BCM53600_A0_SPIDIO6r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO6.
 *
 */
typedef union BCM53600_A0_SPIDIO6r_s {
	uint32_t v[1];
	uint32_t spidio6[1];
	uint32_t _spidio6;
} BCM53600_A0_SPIDIO6r_t;

#define BCM53600_A0_SPIDIO6r_CLR(r) (r).spidio6[0] = 0
#define BCM53600_A0_SPIDIO6r_SET(r,d) (r).spidio6[0] = d
#define BCM53600_A0_SPIDIO6r_GET(r) (r).spidio6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO6r_RESERVEDf_GET(r) (((r).spidio6[0]) & 0xff)
#define BCM53600_A0_SPIDIO6r_RESERVEDf_SET(r,f) (r).spidio6[0]=(((r).spidio6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO6.
 *
 */
#define BCM53600_A0_READ_SPIDIO6r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO6r,(r._spidio6),1)
#define BCM53600_A0_WRITE_SPIDIO6r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO6r,&(r._spidio6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO6r BCM53600_A0_SPIDIO6r
#define SPIDIO6r_SIZE BCM53600_A0_SPIDIO6r_SIZE
typedef BCM53600_A0_SPIDIO6r_t SPIDIO6r_t;
#define SPIDIO6r_CLR BCM53600_A0_SPIDIO6r_CLR
#define SPIDIO6r_SET BCM53600_A0_SPIDIO6r_SET
#define SPIDIO6r_GET BCM53600_A0_SPIDIO6r_GET
#define SPIDIO6r_RESERVEDf_GET BCM53600_A0_SPIDIO6r_RESERVEDf_GET
#define SPIDIO6r_RESERVEDf_SET BCM53600_A0_SPIDIO6r_RESERVEDf_SET
#define READ_SPIDIO6r BCM53600_A0_READ_SPIDIO6r
#define WRITE_SPIDIO6r BCM53600_A0_WRITE_SPIDIO6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPIDIO7
 * BLOCKS:   SPI
 * DESC:     SPI Data I/O Registers 7
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPIDIO7r 0x0000fff7

#define BCM53600_A0_SPIDIO7r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO7.
 *
 */
typedef union BCM53600_A0_SPIDIO7r_s {
	uint32_t v[1];
	uint32_t spidio7[1];
	uint32_t _spidio7;
} BCM53600_A0_SPIDIO7r_t;

#define BCM53600_A0_SPIDIO7r_CLR(r) (r).spidio7[0] = 0
#define BCM53600_A0_SPIDIO7r_SET(r,d) (r).spidio7[0] = d
#define BCM53600_A0_SPIDIO7r_GET(r) (r).spidio7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPIDIO7r_RESERVEDf_GET(r) (((r).spidio7[0]) & 0xff)
#define BCM53600_A0_SPIDIO7r_RESERVEDf_SET(r,f) (r).spidio7[0]=(((r).spidio7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO7.
 *
 */
#define BCM53600_A0_READ_SPIDIO7r(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPIDIO7r,(r._spidio7),1)
#define BCM53600_A0_WRITE_SPIDIO7r(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPIDIO7r,&(r._spidio7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO7r BCM53600_A0_SPIDIO7r
#define SPIDIO7r_SIZE BCM53600_A0_SPIDIO7r_SIZE
typedef BCM53600_A0_SPIDIO7r_t SPIDIO7r_t;
#define SPIDIO7r_CLR BCM53600_A0_SPIDIO7r_CLR
#define SPIDIO7r_SET BCM53600_A0_SPIDIO7r_SET
#define SPIDIO7r_GET BCM53600_A0_SPIDIO7r_GET
#define SPIDIO7r_RESERVEDf_GET BCM53600_A0_SPIDIO7r_RESERVEDf_GET
#define SPIDIO7r_RESERVEDf_SET BCM53600_A0_SPIDIO7r_RESERVEDf_SET
#define READ_SPIDIO7r BCM53600_A0_READ_SPIDIO7r
#define WRITE_SPIDIO7r BCM53600_A0_WRITE_SPIDIO7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPIDIO7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPISTS
 * BLOCKS:   SPI
 * DESC:     SPI Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPISTSr 0x0000fffe

#define BCM53600_A0_SPISTSr_SIZE 1

/*
 * This structure should be used to declare and program SPISTS.
 *
 */
typedef union BCM53600_A0_SPISTSr_s {
	uint32_t v[1];
	uint32_t spists[1];
	uint32_t _spists;
} BCM53600_A0_SPISTSr_t;

#define BCM53600_A0_SPISTSr_CLR(r) (r).spists[0] = 0
#define BCM53600_A0_SPISTSr_SET(r,d) (r).spists[0] = d
#define BCM53600_A0_SPISTSr_GET(r) (r).spists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPISTSr_RESERVEDf_GET(r) (((r).spists[0]) & 0xff)
#define BCM53600_A0_SPISTSr_RESERVEDf_SET(r,f) (r).spists[0]=(((r).spists[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPISTS.
 *
 */
#define BCM53600_A0_READ_SPISTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPISTSr,(r._spists),1)
#define BCM53600_A0_WRITE_SPISTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPISTSr,&(r._spists),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPISTSr BCM53600_A0_SPISTSr
#define SPISTSr_SIZE BCM53600_A0_SPISTSr_SIZE
typedef BCM53600_A0_SPISTSr_t SPISTSr_t;
#define SPISTSr_CLR BCM53600_A0_SPISTSr_CLR
#define SPISTSr_SET BCM53600_A0_SPISTSr_SET
#define SPISTSr_GET BCM53600_A0_SPISTSr_GET
#define SPISTSr_RESERVEDf_GET BCM53600_A0_SPISTSr_RESERVEDf_GET
#define SPISTSr_RESERVEDf_SET BCM53600_A0_SPISTSr_RESERVEDf_SET
#define READ_SPISTSr BCM53600_A0_READ_SPISTSr
#define WRITE_SPISTSr BCM53600_A0_WRITE_SPISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in seconds for dynamically learned address.Maximum age time is 1,048,575 s. Note that while 802.1D specifiesa range of values of 10 - 1,000,000 s, this register does not enforcethis range. Setting the AGE_TIME to zero disables the aging process.
 *     SPTAGT_RSRV0     Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SPTAGTr 0x00000304

#define BCM53600_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 *
 */
typedef union BCM53600_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM53600_A0_SPTAGTr_t;

#define BCM53600_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM53600_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM53600_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM53600_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53600_A0_SPTAGTr_SPTAGT_RSRV0f_GET(r) ((((r).sptagt[0]) >> 20) & 0xfff)
#define BCM53600_A0_SPTAGTr_SPTAGT_RSRV0f_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access SPTAGT.
 *
 */
#define BCM53600_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SPTAGTr,(r._sptagt),4)
#define BCM53600_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM53600_A0_SPTAGTr
#define SPTAGTr_SIZE BCM53600_A0_SPTAGTr_SIZE
typedef BCM53600_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM53600_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM53600_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM53600_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM53600_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM53600_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_SPTAGT_RSRV0f_GET BCM53600_A0_SPTAGTr_SPTAGT_RSRV0f_GET
#define SPTAGTr_SPTAGT_RSRV0f_SET BCM53600_A0_SPTAGTr_SPTAGT_RSRV0f_SET
#define READ_SPTAGTr BCM53600_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM53600_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SPTAGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  STP_BYPASS_CTL
 * BLOCKS:   SYS
 * DESC:     STP Bypass Control Register
 * SIZE:     8
 * FIELDS:
 *     STP_BYPAS_MAC0X  When set to 1'b1, incoming packet with DA = 01-80-c2-00-00-00 ~01-80-c2-00-00-10 will bypass STP Port State Filter checking.
 *     STP_BYPAS_L2_USER_ADDR 1 = Enable L2 User Addres frame bypass STP Port State Filter.
 *     STP_BYPAS_BPDU   1 = Enable BPDU bypass STP Port State Filter.(Not2Release)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_STP_BYPASS_CTLr 0x00000402

#define BCM53600_A0_STP_BYPASS_CTLr_SIZE 1

/*
 * This structure should be used to declare and program STP_BYPASS_CTL.
 *
 */
typedef union BCM53600_A0_STP_BYPASS_CTLr_s {
	uint32_t v[1];
	uint32_t stp_bypass_ctl[1];
	uint32_t _stp_bypass_ctl;
} BCM53600_A0_STP_BYPASS_CTLr_t;

#define BCM53600_A0_STP_BYPASS_CTLr_CLR(r) (r).stp_bypass_ctl[0] = 0
#define BCM53600_A0_STP_BYPASS_CTLr_SET(r,d) (r).stp_bypass_ctl[0] = d
#define BCM53600_A0_STP_BYPASS_CTLr_GET(r) (r).stp_bypass_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_MAC0Xf_GET(r) (((r).stp_bypass_ctl[0]) & 0x1)
#define BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_MAC0Xf_SET(r,f) (r).stp_bypass_ctl[0]=(((r).stp_bypass_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_L2_USER_ADDRf_GET(r) ((((r).stp_bypass_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_L2_USER_ADDRf_SET(r,f) (r).stp_bypass_ctl[0]=(((r).stp_bypass_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_BPDUf_GET(r) ((((r).stp_bypass_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_BPDUf_SET(r,f) (r).stp_bypass_ctl[0]=(((r).stp_bypass_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_STP_BYPASS_CTLr_RESERVEDf_GET(r) ((((r).stp_bypass_ctl[0]) >> 3) & 0x1f)
#define BCM53600_A0_STP_BYPASS_CTLr_RESERVEDf_SET(r,f) (r).stp_bypass_ctl[0]=(((r).stp_bypass_ctl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access STP_BYPASS_CTL.
 *
 */
#define BCM53600_A0_READ_STP_BYPASS_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_STP_BYPASS_CTLr,(r._stp_bypass_ctl),1)
#define BCM53600_A0_WRITE_STP_BYPASS_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_STP_BYPASS_CTLr,&(r._stp_bypass_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STP_BYPASS_CTLr BCM53600_A0_STP_BYPASS_CTLr
#define STP_BYPASS_CTLr_SIZE BCM53600_A0_STP_BYPASS_CTLr_SIZE
typedef BCM53600_A0_STP_BYPASS_CTLr_t STP_BYPASS_CTLr_t;
#define STP_BYPASS_CTLr_CLR BCM53600_A0_STP_BYPASS_CTLr_CLR
#define STP_BYPASS_CTLr_SET BCM53600_A0_STP_BYPASS_CTLr_SET
#define STP_BYPASS_CTLr_GET BCM53600_A0_STP_BYPASS_CTLr_GET
#define STP_BYPASS_CTLr_STP_BYPAS_MAC0Xf_GET BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_MAC0Xf_GET
#define STP_BYPASS_CTLr_STP_BYPAS_MAC0Xf_SET BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_MAC0Xf_SET
#define STP_BYPASS_CTLr_STP_BYPAS_L2_USER_ADDRf_GET BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_L2_USER_ADDRf_GET
#define STP_BYPASS_CTLr_STP_BYPAS_L2_USER_ADDRf_SET BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_L2_USER_ADDRf_SET
#define STP_BYPASS_CTLr_STP_BYPAS_BPDUf_GET BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_BPDUf_GET
#define STP_BYPASS_CTLr_STP_BYPAS_BPDUf_SET BCM53600_A0_STP_BYPASS_CTLr_STP_BYPAS_BPDUf_SET
#define STP_BYPASS_CTLr_RESERVEDf_GET BCM53600_A0_STP_BYPASS_CTLr_RESERVEDf_GET
#define STP_BYPASS_CTLr_RESERVEDf_SET BCM53600_A0_STP_BYPASS_CTLr_RESERVEDf_SET
#define READ_STP_BYPASS_CTLr BCM53600_A0_READ_STP_BYPASS_CTLr
#define WRITE_STP_BYPASS_CTLr BCM53600_A0_WRITE_STP_BYPASS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_STP_BYPASS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  STRAP_STS
 * BLOCKS:   SYS
 * DESC:     Strap Status Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     HW_FWDG_EN       1 : forwarding process enable.(default)0 : turn off forwarding process. Assertion for dumb switch
 *     CSS_DEBUG        Enter css debugging mode when css_dis - 10:(default), the keystone into IDDQ mode.1:the keystone don't into IDDQ mode. Designer can use jtag interface to debug keystone.No release the css_debug pin to customer..
 *     RESERVED         Reserved.
 *     WRALLPHY         Update all PHY in the same time.
 *     ENEXTCLK         Enable external clock.0 : disable external clk,1 : enable external clk.
 *     BISR_BYPASS_AUTOLOAD Bypass BISA load sequence1:Bypass0:No bypass
 *     CSS_DIS          CPU Sub System disable.1:Disable CPU0:Active CPU(default)
 *     MIPS_BIG_ENDIAN  MIPS endian setting.0:Little endian.(default)1:Big endian.
 *     SFLASH_BOOT_STRAP Boot Flash type, specifies using pFlash or sFlash as the boot device.0:pFlash as the boot device.(default)1:sFlash as the boot device.
 *     BOOT_FLASH_TYPE_STRAP Boot flash type, depend on sflash_boot_strap setting, it specifies the pFlash or sFlash boot device type:If(sflash_boot_strap == 0),0:8-bit pFlash.1:16-bit pFlash.(default)If(sflash_boot_strap == 1),0:ST-compatiable sFlash.(default)1:Atmel sFlash.
 *     EN_SYSCLK_PROBE  Enable sysclk probe.1:Enable0:Disable(default)
 *     GIMP_IFSEL       GIGA_IMP_SEL:00: RGMII01: RvMII10: GMII(default)(When KS CPU enable, fixed at this mode)11: MII
 *     EN_DDR2_EXTCLK_STRAP Enable DDR2 external clock1:Active0: Disactive(default)
 *     LEDMODE          LED mode.00: (default)
 *     EN_TDM_MAC_EXTCLK_STRAP Enable TDM and MAC external clock [Bypass ALTA PLL channel 1 and 2]1:Active0: Disactive(default)
 *     GIGA0_IFSEL      GIGA_IFSEL:00: RGMII(default)01: Reserved10: GMII11: MII
 *     EN_MIPS_EXTCLK_STRAP Enable MIPS external clock [Bypass PROC PLL channel 1]1:Active0: Disactive(default)
 *     EJTAG_MODE_STRAP MIPS EJTAG enable.1: Active0: Disactive(default)
 *     FREQ_ADI_CTL_STRAP CPU boot-up frequency adjustment control. It controls PLL clock divider value after reset. The frequency configurations are list below:3'b000:600MHz.(default)3'b001:587.5MHz.3'b010:575MHz.3'b011:562.5MHz.3'b100:550MHz.3'b101:537.5MHz.3'b110:525MHz.3'b111:512.5MHz.
 *     RESERVED_1       Reserved.
 *     PHY_POLL_DIS     Disable external EPHY/GPHY polling.1: Disable polling 0: Enable polling (default)
 *     SKIP_CLR_MEM_SEL Select BIST or Memory clear function.1: BIST function(default) 0: Memory clear function 
 *     SKIP_SRAM_BIST   Turn off BIST/Memory clear function.1: Turn off0: Turn on (default)
 *
 ******************************************************************************/
#define BCM53600_A0_STRAP_STSr 0x00000050

#define BCM53600_A0_STRAP_STSr_SIZE 4

/*
 * This structure should be used to declare and program STRAP_STS.
 *
 */
typedef union BCM53600_A0_STRAP_STSr_s {
	uint32_t v[1];
	uint32_t strap_sts[1];
	uint32_t _strap_sts;
} BCM53600_A0_STRAP_STSr_t;

#define BCM53600_A0_STRAP_STSr_CLR(r) (r).strap_sts[0] = 0
#define BCM53600_A0_STRAP_STSr_SET(r,d) (r).strap_sts[0] = d
#define BCM53600_A0_STRAP_STSr_GET(r) (r).strap_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_STRAP_STSr_RESERVED_0f_GET(r) (((r).strap_sts[0]) & 0x3)
#define BCM53600_A0_STRAP_STSr_RESERVED_0f_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_STRAP_STSr_HW_FWDG_ENf_GET(r) ((((r).strap_sts[0]) >> 2) & 0x1)
#define BCM53600_A0_STRAP_STSr_HW_FWDG_ENf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_STRAP_STSr_CSS_DEBUGf_GET(r) ((((r).strap_sts[0]) >> 3) & 0x1)
#define BCM53600_A0_STRAP_STSr_CSS_DEBUGf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_STRAP_STSr_RESERVEDf_GET(r) ((((r).strap_sts[0]) >> 4) & 0x1)
#define BCM53600_A0_STRAP_STSr_RESERVEDf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_STRAP_STSr_WRALLPHYf_GET(r) ((((r).strap_sts[0]) >> 5) & 0x1)
#define BCM53600_A0_STRAP_STSr_WRALLPHYf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_STRAP_STSr_ENEXTCLKf_GET(r) ((((r).strap_sts[0]) >> 6) & 0x1)
#define BCM53600_A0_STRAP_STSr_ENEXTCLKf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_STRAP_STSr_BISR_BYPASS_AUTOLOADf_GET(r) ((((r).strap_sts[0]) >> 7) & 0x1)
#define BCM53600_A0_STRAP_STSr_BISR_BYPASS_AUTOLOADf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_STRAP_STSr_CSS_DISf_GET(r) ((((r).strap_sts[0]) >> 8) & 0x1)
#define BCM53600_A0_STRAP_STSr_CSS_DISf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_STRAP_STSr_MIPS_BIG_ENDIANf_GET(r) ((((r).strap_sts[0]) >> 9) & 0x1)
#define BCM53600_A0_STRAP_STSr_MIPS_BIG_ENDIANf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_STRAP_STSr_SFLASH_BOOT_STRAPf_GET(r) ((((r).strap_sts[0]) >> 10) & 0x1)
#define BCM53600_A0_STRAP_STSr_SFLASH_BOOT_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_STRAP_STSr_BOOT_FLASH_TYPE_STRAPf_GET(r) ((((r).strap_sts[0]) >> 11) & 0x1)
#define BCM53600_A0_STRAP_STSr_BOOT_FLASH_TYPE_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_STRAP_STSr_EN_SYSCLK_PROBEf_GET(r) ((((r).strap_sts[0]) >> 12) & 0x1)
#define BCM53600_A0_STRAP_STSr_EN_SYSCLK_PROBEf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_STRAP_STSr_GIMP_IFSELf_GET(r) ((((r).strap_sts[0]) >> 13) & 0x3)
#define BCM53600_A0_STRAP_STSr_GIMP_IFSELf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53600_A0_STRAP_STSr_EN_DDR2_EXTCLK_STRAPf_GET(r) ((((r).strap_sts[0]) >> 15) & 0x1)
#define BCM53600_A0_STRAP_STSr_EN_DDR2_EXTCLK_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_STRAP_STSr_LEDMODEf_GET(r) ((((r).strap_sts[0]) >> 16) & 0x3)
#define BCM53600_A0_STRAP_STSr_LEDMODEf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_STRAP_STSr_EN_TDM_MAC_EXTCLK_STRAPf_GET(r) ((((r).strap_sts[0]) >> 18) & 0x1)
#define BCM53600_A0_STRAP_STSr_EN_TDM_MAC_EXTCLK_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53600_A0_STRAP_STSr_GIGA0_IFSELf_GET(r) ((((r).strap_sts[0]) >> 19) & 0x3)
#define BCM53600_A0_STRAP_STSr_GIGA0_IFSELf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53600_A0_STRAP_STSr_EN_MIPS_EXTCLK_STRAPf_GET(r) ((((r).strap_sts[0]) >> 21) & 0x1)
#define BCM53600_A0_STRAP_STSr_EN_MIPS_EXTCLK_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53600_A0_STRAP_STSr_EJTAG_MODE_STRAPf_GET(r) ((((r).strap_sts[0]) >> 22) & 0x1)
#define BCM53600_A0_STRAP_STSr_EJTAG_MODE_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53600_A0_STRAP_STSr_FREQ_ADI_CTL_STRAPf_GET(r) ((((r).strap_sts[0]) >> 23) & 0x7)
#define BCM53600_A0_STRAP_STSr_FREQ_ADI_CTL_STRAPf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM53600_A0_STRAP_STSr_RESERVED_1f_GET(r) ((((r).strap_sts[0]) >> 26) & 0x7)
#define BCM53600_A0_STRAP_STSr_RESERVED_1f_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x7 << 26)) | ((((uint32_t)f) & 0x7) << 26))
#define BCM53600_A0_STRAP_STSr_PHY_POLL_DISf_GET(r) ((((r).strap_sts[0]) >> 29) & 0x1)
#define BCM53600_A0_STRAP_STSr_PHY_POLL_DISf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53600_A0_STRAP_STSr_SKIP_CLR_MEM_SELf_GET(r) ((((r).strap_sts[0]) >> 30) & 0x1)
#define BCM53600_A0_STRAP_STSr_SKIP_CLR_MEM_SELf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53600_A0_STRAP_STSr_SKIP_SRAM_BISTf_GET(r) ((((r).strap_sts[0]) >> 31) & 0x1)
#define BCM53600_A0_STRAP_STSr_SKIP_SRAM_BISTf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access STRAP_STS.
 *
 */
#define BCM53600_A0_READ_STRAP_STSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_STRAP_STSr,(r._strap_sts),4)
#define BCM53600_A0_WRITE_STRAP_STSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_STRAP_STSr,&(r._strap_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_STSr BCM53600_A0_STRAP_STSr
#define STRAP_STSr_SIZE BCM53600_A0_STRAP_STSr_SIZE
typedef BCM53600_A0_STRAP_STSr_t STRAP_STSr_t;
#define STRAP_STSr_CLR BCM53600_A0_STRAP_STSr_CLR
#define STRAP_STSr_SET BCM53600_A0_STRAP_STSr_SET
#define STRAP_STSr_GET BCM53600_A0_STRAP_STSr_GET
#define STRAP_STSr_RESERVED_0f_GET BCM53600_A0_STRAP_STSr_RESERVED_0f_GET
#define STRAP_STSr_RESERVED_0f_SET BCM53600_A0_STRAP_STSr_RESERVED_0f_SET
#define STRAP_STSr_HW_FWDG_ENf_GET BCM53600_A0_STRAP_STSr_HW_FWDG_ENf_GET
#define STRAP_STSr_HW_FWDG_ENf_SET BCM53600_A0_STRAP_STSr_HW_FWDG_ENf_SET
#define STRAP_STSr_CSS_DEBUGf_GET BCM53600_A0_STRAP_STSr_CSS_DEBUGf_GET
#define STRAP_STSr_CSS_DEBUGf_SET BCM53600_A0_STRAP_STSr_CSS_DEBUGf_SET
#define STRAP_STSr_RESERVEDf_GET BCM53600_A0_STRAP_STSr_RESERVEDf_GET
#define STRAP_STSr_RESERVEDf_SET BCM53600_A0_STRAP_STSr_RESERVEDf_SET
#define STRAP_STSr_WRALLPHYf_GET BCM53600_A0_STRAP_STSr_WRALLPHYf_GET
#define STRAP_STSr_WRALLPHYf_SET BCM53600_A0_STRAP_STSr_WRALLPHYf_SET
#define STRAP_STSr_ENEXTCLKf_GET BCM53600_A0_STRAP_STSr_ENEXTCLKf_GET
#define STRAP_STSr_ENEXTCLKf_SET BCM53600_A0_STRAP_STSr_ENEXTCLKf_SET
#define STRAP_STSr_BISR_BYPASS_AUTOLOADf_GET BCM53600_A0_STRAP_STSr_BISR_BYPASS_AUTOLOADf_GET
#define STRAP_STSr_BISR_BYPASS_AUTOLOADf_SET BCM53600_A0_STRAP_STSr_BISR_BYPASS_AUTOLOADf_SET
#define STRAP_STSr_CSS_DISf_GET BCM53600_A0_STRAP_STSr_CSS_DISf_GET
#define STRAP_STSr_CSS_DISf_SET BCM53600_A0_STRAP_STSr_CSS_DISf_SET
#define STRAP_STSr_MIPS_BIG_ENDIANf_GET BCM53600_A0_STRAP_STSr_MIPS_BIG_ENDIANf_GET
#define STRAP_STSr_MIPS_BIG_ENDIANf_SET BCM53600_A0_STRAP_STSr_MIPS_BIG_ENDIANf_SET
#define STRAP_STSr_SFLASH_BOOT_STRAPf_GET BCM53600_A0_STRAP_STSr_SFLASH_BOOT_STRAPf_GET
#define STRAP_STSr_SFLASH_BOOT_STRAPf_SET BCM53600_A0_STRAP_STSr_SFLASH_BOOT_STRAPf_SET
#define STRAP_STSr_BOOT_FLASH_TYPE_STRAPf_GET BCM53600_A0_STRAP_STSr_BOOT_FLASH_TYPE_STRAPf_GET
#define STRAP_STSr_BOOT_FLASH_TYPE_STRAPf_SET BCM53600_A0_STRAP_STSr_BOOT_FLASH_TYPE_STRAPf_SET
#define STRAP_STSr_EN_SYSCLK_PROBEf_GET BCM53600_A0_STRAP_STSr_EN_SYSCLK_PROBEf_GET
#define STRAP_STSr_EN_SYSCLK_PROBEf_SET BCM53600_A0_STRAP_STSr_EN_SYSCLK_PROBEf_SET
#define STRAP_STSr_GIMP_IFSELf_GET BCM53600_A0_STRAP_STSr_GIMP_IFSELf_GET
#define STRAP_STSr_GIMP_IFSELf_SET BCM53600_A0_STRAP_STSr_GIMP_IFSELf_SET
#define STRAP_STSr_EN_DDR2_EXTCLK_STRAPf_GET BCM53600_A0_STRAP_STSr_EN_DDR2_EXTCLK_STRAPf_GET
#define STRAP_STSr_EN_DDR2_EXTCLK_STRAPf_SET BCM53600_A0_STRAP_STSr_EN_DDR2_EXTCLK_STRAPf_SET
#define STRAP_STSr_LEDMODEf_GET BCM53600_A0_STRAP_STSr_LEDMODEf_GET
#define STRAP_STSr_LEDMODEf_SET BCM53600_A0_STRAP_STSr_LEDMODEf_SET
#define STRAP_STSr_EN_TDM_MAC_EXTCLK_STRAPf_GET BCM53600_A0_STRAP_STSr_EN_TDM_MAC_EXTCLK_STRAPf_GET
#define STRAP_STSr_EN_TDM_MAC_EXTCLK_STRAPf_SET BCM53600_A0_STRAP_STSr_EN_TDM_MAC_EXTCLK_STRAPf_SET
#define STRAP_STSr_GIGA0_IFSELf_GET BCM53600_A0_STRAP_STSr_GIGA0_IFSELf_GET
#define STRAP_STSr_GIGA0_IFSELf_SET BCM53600_A0_STRAP_STSr_GIGA0_IFSELf_SET
#define STRAP_STSr_EN_MIPS_EXTCLK_STRAPf_GET BCM53600_A0_STRAP_STSr_EN_MIPS_EXTCLK_STRAPf_GET
#define STRAP_STSr_EN_MIPS_EXTCLK_STRAPf_SET BCM53600_A0_STRAP_STSr_EN_MIPS_EXTCLK_STRAPf_SET
#define STRAP_STSr_EJTAG_MODE_STRAPf_GET BCM53600_A0_STRAP_STSr_EJTAG_MODE_STRAPf_GET
#define STRAP_STSr_EJTAG_MODE_STRAPf_SET BCM53600_A0_STRAP_STSr_EJTAG_MODE_STRAPf_SET
#define STRAP_STSr_FREQ_ADI_CTL_STRAPf_GET BCM53600_A0_STRAP_STSr_FREQ_ADI_CTL_STRAPf_GET
#define STRAP_STSr_FREQ_ADI_CTL_STRAPf_SET BCM53600_A0_STRAP_STSr_FREQ_ADI_CTL_STRAPf_SET
#define STRAP_STSr_RESERVED_1f_GET BCM53600_A0_STRAP_STSr_RESERVED_1f_GET
#define STRAP_STSr_RESERVED_1f_SET BCM53600_A0_STRAP_STSr_RESERVED_1f_SET
#define STRAP_STSr_PHY_POLL_DISf_GET BCM53600_A0_STRAP_STSr_PHY_POLL_DISf_GET
#define STRAP_STSr_PHY_POLL_DISf_SET BCM53600_A0_STRAP_STSr_PHY_POLL_DISf_SET
#define STRAP_STSr_SKIP_CLR_MEM_SELf_GET BCM53600_A0_STRAP_STSr_SKIP_CLR_MEM_SELf_GET
#define STRAP_STSr_SKIP_CLR_MEM_SELf_SET BCM53600_A0_STRAP_STSr_SKIP_CLR_MEM_SELf_SET
#define STRAP_STSr_SKIP_SRAM_BISTf_GET BCM53600_A0_STRAP_STSr_SKIP_SRAM_BISTf_GET
#define STRAP_STSr_SKIP_SRAM_BISTf_SET BCM53600_A0_STRAP_STSr_SKIP_SRAM_BISTf_SET
#define READ_STRAP_STSr BCM53600_A0_READ_STRAP_STSr
#define WRITE_STRAP_STSr BCM53600_A0_WRITE_STRAP_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_STRAP_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  STS_OVERRIDE_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex,1: Full Duplex.
 *     SPEED            Software Port Speed setting2'b11 : 2500M(for 2.5G port)2'b10 : 1000M2'b01 : 100M2'b00 : 10MG0/G2/G3: default value = 2'b10G1: default value = 2'b11(Port_26 connects to EPON internally)
 *     RXFLOW_CNTL      Software Rx XOFF Enable
 *     TXFLOW_CNTL      Software Tx XOFF Enable
 *     SW_OVERRIDE      Enable software override.Note: for Bit 0 - Bit 5.
 *     EN_PHY_SCAN      Enable External Phy Scan:G0: default value = 1G1/G2/G3: default value = 0(Port_26 connects to EPON internally, Port_27/Port_28:SGMII) 
 *
 ******************************************************************************/
#define BCM53600_A0_STS_OVERRIDE_GPr 0x00190129

#define BCM53600_A0_STS_OVERRIDE_GPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GP.
 *
 */
typedef union BCM53600_A0_STS_OVERRIDE_GPr_s {
	uint32_t v[1];
	uint32_t sts_override_gp[1];
	uint32_t _sts_override_gp;
} BCM53600_A0_STS_OVERRIDE_GPr_t;

#define BCM53600_A0_STS_OVERRIDE_GPr_CLR(r) (r).sts_override_gp[0] = 0
#define BCM53600_A0_STS_OVERRIDE_GPr_SET(r,d) (r).sts_override_gp[0] = d
#define BCM53600_A0_STS_OVERRIDE_GPr_GET(r) (r).sts_override_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_STS_OVERRIDE_GPr_LINK_STSf_GET(r) (((r).sts_override_gp[0]) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_GPr_LINK_STSf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gp[0]) >> 1) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_STS_OVERRIDE_GPr_SPEEDf_GET(r) ((((r).sts_override_gp[0]) >> 2) & 0x3)
#define BCM53600_A0_STS_OVERRIDE_GPr_SPEEDf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gp[0]) >> 4) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gp[0]) >> 5) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_STS_OVERRIDE_GPr_SW_OVERRIDEf_GET(r) ((((r).sts_override_gp[0]) >> 6) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_GPr_SW_OVERRIDEf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_GET(r) ((((r).sts_override_gp[0]) >> 7) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GP.
 *
 */
#define BCM53600_A0_READ_STS_OVERRIDE_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_STS_OVERRIDE_GPr,(r._sts_override_gp),1)
#define BCM53600_A0_WRITE_STS_OVERRIDE_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_STS_OVERRIDE_GPr,&(r._sts_override_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GPr BCM53600_A0_STS_OVERRIDE_GPr
#define STS_OVERRIDE_GPr_SIZE BCM53600_A0_STS_OVERRIDE_GPr_SIZE
typedef BCM53600_A0_STS_OVERRIDE_GPr_t STS_OVERRIDE_GPr_t;
#define STS_OVERRIDE_GPr_CLR BCM53600_A0_STS_OVERRIDE_GPr_CLR
#define STS_OVERRIDE_GPr_SET BCM53600_A0_STS_OVERRIDE_GPr_SET
#define STS_OVERRIDE_GPr_GET BCM53600_A0_STS_OVERRIDE_GPr_GET
#define STS_OVERRIDE_GPr_LINK_STSf_GET BCM53600_A0_STS_OVERRIDE_GPr_LINK_STSf_GET
#define STS_OVERRIDE_GPr_LINK_STSf_SET BCM53600_A0_STS_OVERRIDE_GPr_LINK_STSf_SET
#define STS_OVERRIDE_GPr_DUPLX_MODEf_GET BCM53600_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GPr_DUPLX_MODEf_SET BCM53600_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GPr_SPEEDf_GET BCM53600_A0_STS_OVERRIDE_GPr_SPEEDf_GET
#define STS_OVERRIDE_GPr_SPEEDf_SET BCM53600_A0_STS_OVERRIDE_GPr_SPEEDf_SET
#define STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET BCM53600_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET BCM53600_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET BCM53600_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET BCM53600_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GPr_SW_OVERRIDEf_GET BCM53600_A0_STS_OVERRIDE_GPr_SW_OVERRIDEf_GET
#define STS_OVERRIDE_GPr_SW_OVERRIDEf_SET BCM53600_A0_STS_OVERRIDE_GPr_SW_OVERRIDEf_SET
#define STS_OVERRIDE_GPr_EN_PHY_SCANf_GET BCM53600_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_GET
#define STS_OVERRIDE_GPr_EN_PHY_SCANf_SET BCM53600_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_SET
#define READ_STS_OVERRIDE_GPr BCM53600_A0_READ_STS_OVERRIDE_GPr
#define WRITE_STS_OVERRIDE_GPr BCM53600_A0_WRITE_STS_OVERRIDE_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_STS_OVERRIDE_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex,1: Full Duplex.
 *     SPEED            Software Port Speed setting2'b11 : Reserved2'b10 : 1000M2'b01 : 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx XOFF Enable
 *     TXFLOW_CNTL      Software Tx XOFF Enable
 *     SW_OVERRIDE      Enable software override.Note: for Bit 0 - Bit 5.
 *     EN_PHY_SCAN_IMP  Enable External Phy Scan:-When cpu core disable(CSS_DIS = 1), default value is read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently.-When cpu core enable(CSS_DIS = 0), default value is "0".(Not2Release, Port_24 always connect to CPU, this bit is for testing only)
 *
 ******************************************************************************/
#define BCM53600_A0_STS_OVERRIDE_IMPr 0x00000128

#define BCM53600_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 *
 */
typedef union BCM53600_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM53600_A0_STS_OVERRIDE_IMPr_t;

#define BCM53600_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM53600_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM53600_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_STS_OVERRIDE_IMPr_SPEEDf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM53600_A0_STS_OVERRIDE_IMPr_SPEEDf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53600_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_STS_OVERRIDE_IMPr_SW_OVERRIDEf_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_IMPr_SW_OVERRIDEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_STS_OVERRIDE_IMPr_EN_PHY_SCAN_IMPf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_IMPr_EN_PHY_SCAN_IMPf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 *
 */
#define BCM53600_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM53600_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM53600_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM53600_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM53600_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM53600_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM53600_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM53600_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM53600_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM53600_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM53600_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM53600_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_SPEEDf_GET BCM53600_A0_STS_OVERRIDE_IMPr_SPEEDf_GET
#define STS_OVERRIDE_IMPr_SPEEDf_SET BCM53600_A0_STS_OVERRIDE_IMPr_SPEEDf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM53600_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM53600_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET BCM53600_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET BCM53600_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_SW_OVERRIDEf_GET BCM53600_A0_STS_OVERRIDE_IMPr_SW_OVERRIDEf_GET
#define STS_OVERRIDE_IMPr_SW_OVERRIDEf_SET BCM53600_A0_STS_OVERRIDE_IMPr_SW_OVERRIDEf_SET
#define STS_OVERRIDE_IMPr_EN_PHY_SCAN_IMPf_GET BCM53600_A0_STS_OVERRIDE_IMPr_EN_PHY_SCAN_IMPf_GET
#define STS_OVERRIDE_IMPr_EN_PHY_SCAN_IMPf_SET BCM53600_A0_STS_OVERRIDE_IMPr_EN_PHY_SCAN_IMPf_SET
#define READ_STS_OVERRIDE_IMPr BCM53600_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM53600_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_STS_OVERRIDE_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  STS_OVERRIDE_P
 * BLOCKS:   EPIC0
 * DESC:     FE Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Software Port Speed setting1'b1: 100M1'b0 : 10M
 *     RESERVED_0       Reserved
 *     FLOW_CNTL        Software XOFF Enable
 *     SW_OVERRIDE      Enable software override.Note: for Bit 0 - Bit 5.
 *     EN_PHY_SCAN      Enable External Phy Scan:Default value is based on the bounding option. It can be overwritten subsequently.-BCM53606 mode: 1-BCM53602/BCM53603/BCM53604 mode: 0 
 *
 ******************************************************************************/
#define BCM53600_A0_STS_OVERRIDE_Pr 0x00000110

#define BCM53600_A0_STS_OVERRIDE_Pr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_P.
 *
 */
typedef union BCM53600_A0_STS_OVERRIDE_Pr_s {
	uint32_t v[1];
	uint32_t sts_override_p[1];
	uint32_t _sts_override_p;
} BCM53600_A0_STS_OVERRIDE_Pr_t;

#define BCM53600_A0_STS_OVERRIDE_Pr_CLR(r) (r).sts_override_p[0] = 0
#define BCM53600_A0_STS_OVERRIDE_Pr_SET(r,d) (r).sts_override_p[0] = d
#define BCM53600_A0_STS_OVERRIDE_Pr_GET(r) (r).sts_override_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_STS_OVERRIDE_Pr_LINK_STSf_GET(r) (((r).sts_override_p[0]) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_Pr_LINK_STSf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_GET(r) ((((r).sts_override_p[0]) >> 1) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_STS_OVERRIDE_Pr_SPEEDf_GET(r) ((((r).sts_override_p[0]) >> 2) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_Pr_SPEEDf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_STS_OVERRIDE_Pr_RESERVED_0f_GET(r) ((((r).sts_override_p[0]) >> 3) & 0x3)
#define BCM53600_A0_STS_OVERRIDE_Pr_RESERVED_0f_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53600_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_GET(r) ((((r).sts_override_p[0]) >> 5) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_STS_OVERRIDE_Pr_SW_OVERRIDEf_GET(r) ((((r).sts_override_p[0]) >> 6) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_Pr_SW_OVERRIDEf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_STS_OVERRIDE_Pr_EN_PHY_SCANf_GET(r) ((((r).sts_override_p[0]) >> 7) & 0x1)
#define BCM53600_A0_STS_OVERRIDE_Pr_EN_PHY_SCANf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_P.
 *
 */
#define BCM53600_A0_READ_STS_OVERRIDE_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_STS_OVERRIDE_Pr,(r._sts_override_p),1)
#define BCM53600_A0_WRITE_STS_OVERRIDE_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_STS_OVERRIDE_Pr,&(r._sts_override_p),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_Pr BCM53600_A0_STS_OVERRIDE_Pr
#define STS_OVERRIDE_Pr_SIZE BCM53600_A0_STS_OVERRIDE_Pr_SIZE
typedef BCM53600_A0_STS_OVERRIDE_Pr_t STS_OVERRIDE_Pr_t;
#define STS_OVERRIDE_Pr_CLR BCM53600_A0_STS_OVERRIDE_Pr_CLR
#define STS_OVERRIDE_Pr_SET BCM53600_A0_STS_OVERRIDE_Pr_SET
#define STS_OVERRIDE_Pr_GET BCM53600_A0_STS_OVERRIDE_Pr_GET
#define STS_OVERRIDE_Pr_LINK_STSf_GET BCM53600_A0_STS_OVERRIDE_Pr_LINK_STSf_GET
#define STS_OVERRIDE_Pr_LINK_STSf_SET BCM53600_A0_STS_OVERRIDE_Pr_LINK_STSf_SET
#define STS_OVERRIDE_Pr_DUPLX_MODEf_GET BCM53600_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_GET
#define STS_OVERRIDE_Pr_DUPLX_MODEf_SET BCM53600_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_SET
#define STS_OVERRIDE_Pr_SPEEDf_GET BCM53600_A0_STS_OVERRIDE_Pr_SPEEDf_GET
#define STS_OVERRIDE_Pr_SPEEDf_SET BCM53600_A0_STS_OVERRIDE_Pr_SPEEDf_SET
#define STS_OVERRIDE_Pr_RESERVED_0f_GET BCM53600_A0_STS_OVERRIDE_Pr_RESERVED_0f_GET
#define STS_OVERRIDE_Pr_RESERVED_0f_SET BCM53600_A0_STS_OVERRIDE_Pr_RESERVED_0f_SET
#define STS_OVERRIDE_Pr_FLOW_CNTLf_GET BCM53600_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_GET
#define STS_OVERRIDE_Pr_FLOW_CNTLf_SET BCM53600_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_SET
#define STS_OVERRIDE_Pr_SW_OVERRIDEf_GET BCM53600_A0_STS_OVERRIDE_Pr_SW_OVERRIDEf_GET
#define STS_OVERRIDE_Pr_SW_OVERRIDEf_SET BCM53600_A0_STS_OVERRIDE_Pr_SW_OVERRIDEf_SET
#define STS_OVERRIDE_Pr_EN_PHY_SCANf_GET BCM53600_A0_STS_OVERRIDE_Pr_EN_PHY_SCANf_GET
#define STS_OVERRIDE_Pr_EN_PHY_SCANf_SET BCM53600_A0_STS_OVERRIDE_Pr_EN_PHY_SCANf_SET
#define READ_STS_OVERRIDE_Pr BCM53600_A0_READ_STS_OVERRIDE_Pr
#define WRITE_STS_OVERRIDE_Pr BCM53600_A0_WRITE_STS_OVERRIDE_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_STS_OVERRIDE_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.1'b1: Managed Mode.1'b0: Unmanaged Mode.Default value is read from the inversed HW_FWDG_EN pin on power-on. Can be overwritten subsequently.
 *     SW_FWDG_EN       Software Forwarding Enable.1'b1: Frame forwarding is enable.1'b0: Frame forwarding is disable.Default value is read from HW_FWDG_EN pin on power-on.  Can be overwritten subsequently.
 *     RTRY_LMT_DIS     Retry Limit Disable.1'b1: Disable the retry limit on all MAC ports(10/100).1'b0: Stop transmit and drop the packet after 15 retry collision attempts inHalf Duplex mode.
 *     RESERVED_0       Reserved
 *     IPG              Programmable Inter-Packet-Gap.1'b1: 96 bit time.1'b0: 92 bit time.
 *     SHORT_IPG_DETECT Short IPG Detection.1 = enable0 = Disable(Not2Release)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SWMODEr 0x00000000

#define BCM53600_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 *
 */
typedef union BCM53600_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM53600_A0_SWMODEr_t;

#define BCM53600_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM53600_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM53600_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM53600_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM53600_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_SWMODEr_RTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM53600_A0_SWMODEr_RTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_SWMODEr_RESERVED_0f_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM53600_A0_SWMODEr_RESERVED_0f_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_SWMODEr_IPGf_GET(r) ((((r).swmode[0]) >> 4) & 0x1)
#define BCM53600_A0_SWMODEr_IPGf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_SWMODEr_SHORT_IPG_DETECTf_GET(r) ((((r).swmode[0]) >> 5) & 0x1)
#define BCM53600_A0_SWMODEr_SHORT_IPG_DETECTf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_SWMODEr_RESERVED_1f_GET(r) ((((r).swmode[0]) >> 6) & 0x3)
#define BCM53600_A0_SWMODEr_RESERVED_1f_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access SWMODE.
 *
 */
#define BCM53600_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SWMODEr,(r._swmode),1)
#define BCM53600_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM53600_A0_SWMODEr
#define SWMODEr_SIZE BCM53600_A0_SWMODEr_SIZE
typedef BCM53600_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM53600_A0_SWMODEr_CLR
#define SWMODEr_SET BCM53600_A0_SWMODEr_SET
#define SWMODEr_GET BCM53600_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM53600_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM53600_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM53600_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM53600_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_RTRY_LMT_DISf_GET BCM53600_A0_SWMODEr_RTRY_LMT_DISf_GET
#define SWMODEr_RTRY_LMT_DISf_SET BCM53600_A0_SWMODEr_RTRY_LMT_DISf_SET
#define SWMODEr_RESERVED_0f_GET BCM53600_A0_SWMODEr_RESERVED_0f_GET
#define SWMODEr_RESERVED_0f_SET BCM53600_A0_SWMODEr_RESERVED_0f_SET
#define SWMODEr_IPGf_GET BCM53600_A0_SWMODEr_IPGf_GET
#define SWMODEr_IPGf_SET BCM53600_A0_SWMODEr_IPGf_SET
#define SWMODEr_SHORT_IPG_DETECTf_GET BCM53600_A0_SWMODEr_SHORT_IPG_DETECTf_GET
#define SWMODEr_SHORT_IPG_DETECTf_SET BCM53600_A0_SWMODEr_SHORT_IPG_DETECTf_SET
#define SWMODEr_RESERVED_1f_GET BCM53600_A0_SWMODEr_RESERVED_1f_GET
#define SWMODEr_RESERVED_1f_SET BCM53600_A0_SWMODEr_RESERVED_1f_SET
#define READ_SWMODEr BCM53600_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM53600_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SWMODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  SW_XOFF_PORT_CTL
 * BLOCKS:   SYS
 * DESC:     Software XOFF Port Control Register
 NOTE: To enable the software override function is defined in the EN_SW_FLOW_CON(Page 00h, Addr 03h).
 * SIZE:     64
 * FIELDS:
 *     SW_FLOW_CON_FE   Software override XOFF capability for FE portsA 48-bit field to indicate the PAUSE capability for each 10/100 BASE-T portTwo bit for each port. Bits 47:0 = 10/100 ports[port23-port0] respectatively.Bit 0 = 0, Disable flow control.Bit 0 = 1, Enable flow control.Bit 1 = Reserved.
 *     SW_FLOW_CON_IMP  Software override XOFF capability for Giga port IMP.Bit1:for TXBit0:for RX
 *     SW_FLOW_CON_G0   Software override XOFF capability for Giga port G0.Bit1:for TXBit0:for RX
 *     SW_FLOW_CON_G1   Software override XOFF capability for Giga port G1.Bit1:for TXBit0:for RX
 *     SW_FLOW_CON_G2   Software override XOFF capability for Giga port G2.Bit1:for TXBit0:for RX
 *     SW_FLOW_CON_G3   Software override XOFF capability for Giga port G3.Bit1:for TXBit0:for RX
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_SW_XOFF_PORT_CTLr 0x00000040

#define BCM53600_A0_SW_XOFF_PORT_CTLr_SIZE 8

/*
 * This structure should be used to declare and program SW_XOFF_PORT_CTL.
 *
 */
typedef union BCM53600_A0_SW_XOFF_PORT_CTLr_s {
	uint32_t v[2];
	uint32_t sw_xoff_port_ctl[2];
	uint32_t _sw_xoff_port_ctl;
} BCM53600_A0_SW_XOFF_PORT_CTLr_t;

#define BCM53600_A0_SW_XOFF_PORT_CTLr_CLR(r) CDK_MEMSET(&((r)._sw_xoff_port_ctl), 0, sizeof(BCM53600_A0_SW_XOFF_PORT_CTLr_t))
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SET(r,i,d) (r).sw_xoff_port_ctl[i] = d
#define BCM53600_A0_SW_XOFF_PORT_CTLr_GET(r,i) (r).sw_xoff_port_ctl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_FEf_GET(r,a) cdk_field_get((r).sw_xoff_port_ctl,0,47,a)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_FEf_SET(r,a) cdk_field_set((r).sw_xoff_port_ctl,0,47,a)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_IMPf_GET(r) ((((r).sw_xoff_port_ctl[1]) >> 16) & 0x3)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_IMPf_SET(r,f) (r).sw_xoff_port_ctl[1]=(((r).sw_xoff_port_ctl[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G0f_GET(r) ((((r).sw_xoff_port_ctl[1]) >> 18) & 0x3)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G0f_SET(r,f) (r).sw_xoff_port_ctl[1]=(((r).sw_xoff_port_ctl[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G1f_GET(r) ((((r).sw_xoff_port_ctl[1]) >> 20) & 0x3)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G1f_SET(r,f) (r).sw_xoff_port_ctl[1]=(((r).sw_xoff_port_ctl[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G2f_GET(r) ((((r).sw_xoff_port_ctl[1]) >> 22) & 0x3)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G2f_SET(r,f) (r).sw_xoff_port_ctl[1]=(((r).sw_xoff_port_ctl[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G3f_GET(r) ((((r).sw_xoff_port_ctl[1]) >> 24) & 0x3)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G3f_SET(r,f) (r).sw_xoff_port_ctl[1]=(((r).sw_xoff_port_ctl[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53600_A0_SW_XOFF_PORT_CTLr_RESERVEDf_GET(r) ((((r).sw_xoff_port_ctl[1]) >> 26) & 0x3f)
#define BCM53600_A0_SW_XOFF_PORT_CTLr_RESERVEDf_SET(r,f) (r).sw_xoff_port_ctl[1]=(((r).sw_xoff_port_ctl[1] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access SW_XOFF_PORT_CTL.
 *
 */
#define BCM53600_A0_READ_SW_XOFF_PORT_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_SW_XOFF_PORT_CTLr,(r._sw_xoff_port_ctl),8)
#define BCM53600_A0_WRITE_SW_XOFF_PORT_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_SW_XOFF_PORT_CTLr,&(r._sw_xoff_port_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SW_XOFF_PORT_CTLr BCM53600_A0_SW_XOFF_PORT_CTLr
#define SW_XOFF_PORT_CTLr_SIZE BCM53600_A0_SW_XOFF_PORT_CTLr_SIZE
typedef BCM53600_A0_SW_XOFF_PORT_CTLr_t SW_XOFF_PORT_CTLr_t;
#define SW_XOFF_PORT_CTLr_CLR BCM53600_A0_SW_XOFF_PORT_CTLr_CLR
#define SW_XOFF_PORT_CTLr_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SET
#define SW_XOFF_PORT_CTLr_GET BCM53600_A0_SW_XOFF_PORT_CTLr_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_FEf_GET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_FEf_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_FEf_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_FEf_SET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_IMPf_GET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_IMPf_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_IMPf_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_IMPf_SET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G0f_GET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G0f_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G0f_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G0f_SET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G1f_GET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G1f_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G1f_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G1f_SET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G2f_GET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G2f_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G2f_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G2f_SET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G3f_GET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G3f_GET
#define SW_XOFF_PORT_CTLr_SW_FLOW_CON_G3f_SET BCM53600_A0_SW_XOFF_PORT_CTLr_SW_FLOW_CON_G3f_SET
#define SW_XOFF_PORT_CTLr_RESERVEDf_GET BCM53600_A0_SW_XOFF_PORT_CTLr_RESERVEDf_GET
#define SW_XOFF_PORT_CTLr_RESERVEDf_SET BCM53600_A0_SW_XOFF_PORT_CTLr_RESERVEDf_SET
#define READ_SW_XOFF_PORT_CTLr BCM53600_A0_READ_SW_XOFF_PORT_CTLr
#define WRITE_SW_XOFF_PORT_CTLr BCM53600_A0_WRITE_SW_XOFF_PORT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_SW_XOFF_PORT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_ANADV
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       write as 0, ignore on read.
 *     FULL_DUPLEX      1 = advertise full-duplex.0 = do not advertise full-duplex.
 *     HALF_DUPLEX      1 = advertise half-duplex.0 = do not advertise half-duplex.
 *     PAUSE            00 = no_pause.01 = symmetric_pause.10 = asym_pause_toward_link_partner.11 = both_sym_pause_and_asym_pause_toward local_device.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     00 = no_remote_fault.01 = link_failure.10 = offline.11 = autoneg_error.
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53600_A0_S_ANADVr 0x0000bb08

#define BCM53600_A0_S_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program S_ANADV.
 *
 */
typedef union BCM53600_A0_S_ANADVr_s {
	uint32_t v[1];
	uint32_t s_anadv[1];
	uint32_t _s_anadv;
} BCM53600_A0_S_ANADVr_t;

#define BCM53600_A0_S_ANADVr_CLR(r) (r).s_anadv[0] = 0
#define BCM53600_A0_S_ANADVr_SET(r,d) (r).s_anadv[0] = d
#define BCM53600_A0_S_ANADVr_GET(r) (r).s_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_ANADVr_RESERVED_0f_GET(r) (((r).s_anadv[0]) & 0x1f)
#define BCM53600_A0_S_ANADVr_RESERVED_0f_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53600_A0_S_ANADVr_FULL_DUPLEXf_GET(r) ((((r).s_anadv[0]) >> 5) & 0x1)
#define BCM53600_A0_S_ANADVr_FULL_DUPLEXf_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_S_ANADVr_HALF_DUPLEXf_GET(r) ((((r).s_anadv[0]) >> 6) & 0x1)
#define BCM53600_A0_S_ANADVr_HALF_DUPLEXf_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_S_ANADVr_PAUSEf_GET(r) ((((r).s_anadv[0]) >> 7) & 0x3)
#define BCM53600_A0_S_ANADVr_PAUSEf_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_S_ANADVr_RESERVED_1f_GET(r) ((((r).s_anadv[0]) >> 9) & 0x7)
#define BCM53600_A0_S_ANADVr_RESERVED_1f_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53600_A0_S_ANADVr_REMOTE_FAULTf_GET(r) ((((r).s_anadv[0]) >> 12) & 0x3)
#define BCM53600_A0_S_ANADVr_REMOTE_FAULTf_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_S_ANADVr_RESERVED_2f_GET(r) ((((r).s_anadv[0]) >> 14) & 0x1)
#define BCM53600_A0_S_ANADVr_RESERVED_2f_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_S_ANADVr_NEXT_PAGEf_GET(r) ((((r).s_anadv[0]) >> 15) & 0x1)
#define BCM53600_A0_S_ANADVr_NEXT_PAGEf_SET(r,f) (r).s_anadv[0]=(((r).s_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access S_ANADV.
 *
 */
#define BCM53600_A0_READ_S_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_ANADVr,(r._s_anadv),2)
#define BCM53600_A0_WRITE_S_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_ANADVr,&(r._s_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_ANADVr BCM53600_A0_S_ANADVr
#define S_ANADVr_SIZE BCM53600_A0_S_ANADVr_SIZE
typedef BCM53600_A0_S_ANADVr_t S_ANADVr_t;
#define S_ANADVr_CLR BCM53600_A0_S_ANADVr_CLR
#define S_ANADVr_SET BCM53600_A0_S_ANADVr_SET
#define S_ANADVr_GET BCM53600_A0_S_ANADVr_GET
#define S_ANADVr_RESERVED_0f_GET BCM53600_A0_S_ANADVr_RESERVED_0f_GET
#define S_ANADVr_RESERVED_0f_SET BCM53600_A0_S_ANADVr_RESERVED_0f_SET
#define S_ANADVr_FULL_DUPLEXf_GET BCM53600_A0_S_ANADVr_FULL_DUPLEXf_GET
#define S_ANADVr_FULL_DUPLEXf_SET BCM53600_A0_S_ANADVr_FULL_DUPLEXf_SET
#define S_ANADVr_HALF_DUPLEXf_GET BCM53600_A0_S_ANADVr_HALF_DUPLEXf_GET
#define S_ANADVr_HALF_DUPLEXf_SET BCM53600_A0_S_ANADVr_HALF_DUPLEXf_SET
#define S_ANADVr_PAUSEf_GET BCM53600_A0_S_ANADVr_PAUSEf_GET
#define S_ANADVr_PAUSEf_SET BCM53600_A0_S_ANADVr_PAUSEf_SET
#define S_ANADVr_RESERVED_1f_GET BCM53600_A0_S_ANADVr_RESERVED_1f_GET
#define S_ANADVr_RESERVED_1f_SET BCM53600_A0_S_ANADVr_RESERVED_1f_SET
#define S_ANADVr_REMOTE_FAULTf_GET BCM53600_A0_S_ANADVr_REMOTE_FAULTf_GET
#define S_ANADVr_REMOTE_FAULTf_SET BCM53600_A0_S_ANADVr_REMOTE_FAULTf_SET
#define S_ANADVr_RESERVED_2f_GET BCM53600_A0_S_ANADVr_RESERVED_2f_GET
#define S_ANADVr_RESERVED_2f_SET BCM53600_A0_S_ANADVr_RESERVED_2f_SET
#define S_ANADVr_NEXT_PAGEf_GET BCM53600_A0_S_ANADVr_NEXT_PAGEf_GET
#define S_ANADVr_NEXT_PAGEf_SET BCM53600_A0_S_ANADVr_NEXT_PAGEf_SET
#define READ_S_ANADVr BCM53600_A0_READ_S_ANADVr
#define WRITE_S_ANADVr BCM53600_A0_WRITE_S_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_ANEXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       ignore on read
 *     PAGE_REC         1 = new link code word has been received.0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page abile.0 = local device is not next page abile.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM53600_A0_S_ANEXPr 0x0000bb0c

#define BCM53600_A0_S_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program S_ANEXP.
 *
 */
typedef union BCM53600_A0_S_ANEXPr_s {
	uint32_t v[1];
	uint32_t s_anexp[1];
	uint32_t _s_anexp;
} BCM53600_A0_S_ANEXPr_t;

#define BCM53600_A0_S_ANEXPr_CLR(r) (r).s_anexp[0] = 0
#define BCM53600_A0_S_ANEXPr_SET(r,d) (r).s_anexp[0] = d
#define BCM53600_A0_S_ANEXPr_GET(r) (r).s_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_ANEXPr_RESERVED_0f_GET(r) (((r).s_anexp[0]) & 0x1)
#define BCM53600_A0_S_ANEXPr_RESERVED_0f_SET(r,f) (r).s_anexp[0]=(((r).s_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_S_ANEXPr_PAGE_RECf_GET(r) ((((r).s_anexp[0]) >> 1) & 0x1)
#define BCM53600_A0_S_ANEXPr_PAGE_RECf_SET(r,f) (r).s_anexp[0]=(((r).s_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_S_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).s_anexp[0]) >> 2) & 0x1)
#define BCM53600_A0_S_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).s_anexp[0]=(((r).s_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_S_ANEXPr_RESERVED_1f_GET(r) ((((r).s_anexp[0]) >> 3) & 0x1fff)
#define BCM53600_A0_S_ANEXPr_RESERVED_1f_SET(r,f) (r).s_anexp[0]=(((r).s_anexp[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access S_ANEXP.
 *
 */
#define BCM53600_A0_READ_S_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_ANEXPr,(r._s_anexp),2)
#define BCM53600_A0_WRITE_S_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_ANEXPr,&(r._s_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_ANEXPr BCM53600_A0_S_ANEXPr
#define S_ANEXPr_SIZE BCM53600_A0_S_ANEXPr_SIZE
typedef BCM53600_A0_S_ANEXPr_t S_ANEXPr_t;
#define S_ANEXPr_CLR BCM53600_A0_S_ANEXPr_CLR
#define S_ANEXPr_SET BCM53600_A0_S_ANEXPr_SET
#define S_ANEXPr_GET BCM53600_A0_S_ANEXPr_GET
#define S_ANEXPr_RESERVED_0f_GET BCM53600_A0_S_ANEXPr_RESERVED_0f_GET
#define S_ANEXPr_RESERVED_0f_SET BCM53600_A0_S_ANEXPr_RESERVED_0f_SET
#define S_ANEXPr_PAGE_RECf_GET BCM53600_A0_S_ANEXPr_PAGE_RECf_GET
#define S_ANEXPr_PAGE_RECf_SET BCM53600_A0_S_ANEXPr_PAGE_RECf_SET
#define S_ANEXPr_NEXT_PAGE_ABIf_GET BCM53600_A0_S_ANEXPr_NEXT_PAGE_ABIf_GET
#define S_ANEXPr_NEXT_PAGE_ABIf_SET BCM53600_A0_S_ANEXPr_NEXT_PAGE_ABIf_SET
#define S_ANEXPr_RESERVED_1f_GET BCM53600_A0_S_ANEXPr_RESERVED_1f_GET
#define S_ANEXPr_RESERVED_1f_SET BCM53600_A0_S_ANEXPr_RESERVED_1f_SET
#define READ_S_ANEXPr BCM53600_A0_READ_S_ANEXPr
#define WRITE_S_ANEXPr BCM53600_A0_WRITE_S_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_ANLPA1
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability 1 Register
 * SIZE:     16
 * FIELDS:
 *     SGMII_MODE       1 = SGMII mode.0 = fiber mode.
 *     RESERVED_0       write as 0, ignore on read.
 *     FULL_DUPLEX      1 = advertise full-duplex.0 = do not advertise full-duplex.
 *     HALF_DUPLEX      1 = advertise half-duplex.0 = do not advertise half-duplex.
 *     PAUSE            00 = no_pause.01 = symmetric_pause.10 = asym_pause_toward_link_partner.11 = both_sym_pause_and_asym_pause_toward local_device.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     00 = no_remote_fault.01 = link_failure.10 = offline.11 = autoneg_error.
 *     ACKNOWLEDGE      1 = link partner has received link code word.0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able.0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53600_A0_S_ANLPA1r 0x0000bb0a

#define BCM53600_A0_S_ANLPA1r_SIZE 2

/*
 * This structure should be used to declare and program S_ANLPA1.
 *
 */
typedef union BCM53600_A0_S_ANLPA1r_s {
	uint32_t v[1];
	uint32_t s_anlpa1[1];
	uint32_t _s_anlpa1;
} BCM53600_A0_S_ANLPA1r_t;

#define BCM53600_A0_S_ANLPA1r_CLR(r) (r).s_anlpa1[0] = 0
#define BCM53600_A0_S_ANLPA1r_SET(r,d) (r).s_anlpa1[0] = d
#define BCM53600_A0_S_ANLPA1r_GET(r) (r).s_anlpa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_ANLPA1r_SGMII_MODEf_GET(r) (((r).s_anlpa1[0]) & 0x1)
#define BCM53600_A0_S_ANLPA1r_SGMII_MODEf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_S_ANLPA1r_RESERVED_0f_GET(r) ((((r).s_anlpa1[0]) >> 1) & 0xf)
#define BCM53600_A0_S_ANLPA1r_RESERVED_0f_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM53600_A0_S_ANLPA1r_FULL_DUPLEXf_GET(r) ((((r).s_anlpa1[0]) >> 5) & 0x1)
#define BCM53600_A0_S_ANLPA1r_FULL_DUPLEXf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_S_ANLPA1r_HALF_DUPLEXf_GET(r) ((((r).s_anlpa1[0]) >> 6) & 0x1)
#define BCM53600_A0_S_ANLPA1r_HALF_DUPLEXf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_S_ANLPA1r_PAUSEf_GET(r) ((((r).s_anlpa1[0]) >> 7) & 0x3)
#define BCM53600_A0_S_ANLPA1r_PAUSEf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53600_A0_S_ANLPA1r_RESERVED_1f_GET(r) ((((r).s_anlpa1[0]) >> 9) & 0x7)
#define BCM53600_A0_S_ANLPA1r_RESERVED_1f_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53600_A0_S_ANLPA1r_REMOTE_FAULTf_GET(r) ((((r).s_anlpa1[0]) >> 12) & 0x3)
#define BCM53600_A0_S_ANLPA1r_REMOTE_FAULTf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53600_A0_S_ANLPA1r_ACKNOWLEDGEf_GET(r) ((((r).s_anlpa1[0]) >> 14) & 0x1)
#define BCM53600_A0_S_ANLPA1r_ACKNOWLEDGEf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_S_ANLPA1r_NEXT_PAGEf_GET(r) ((((r).s_anlpa1[0]) >> 15) & 0x1)
#define BCM53600_A0_S_ANLPA1r_NEXT_PAGEf_SET(r,f) (r).s_anlpa1[0]=(((r).s_anlpa1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access S_ANLPA1.
 *
 */
#define BCM53600_A0_READ_S_ANLPA1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_ANLPA1r,(r._s_anlpa1),2)
#define BCM53600_A0_WRITE_S_ANLPA1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_ANLPA1r,&(r._s_anlpa1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_ANLPA1r BCM53600_A0_S_ANLPA1r
#define S_ANLPA1r_SIZE BCM53600_A0_S_ANLPA1r_SIZE
typedef BCM53600_A0_S_ANLPA1r_t S_ANLPA1r_t;
#define S_ANLPA1r_CLR BCM53600_A0_S_ANLPA1r_CLR
#define S_ANLPA1r_SET BCM53600_A0_S_ANLPA1r_SET
#define S_ANLPA1r_GET BCM53600_A0_S_ANLPA1r_GET
#define S_ANLPA1r_SGMII_MODEf_GET BCM53600_A0_S_ANLPA1r_SGMII_MODEf_GET
#define S_ANLPA1r_SGMII_MODEf_SET BCM53600_A0_S_ANLPA1r_SGMII_MODEf_SET
#define S_ANLPA1r_RESERVED_0f_GET BCM53600_A0_S_ANLPA1r_RESERVED_0f_GET
#define S_ANLPA1r_RESERVED_0f_SET BCM53600_A0_S_ANLPA1r_RESERVED_0f_SET
#define S_ANLPA1r_FULL_DUPLEXf_GET BCM53600_A0_S_ANLPA1r_FULL_DUPLEXf_GET
#define S_ANLPA1r_FULL_DUPLEXf_SET BCM53600_A0_S_ANLPA1r_FULL_DUPLEXf_SET
#define S_ANLPA1r_HALF_DUPLEXf_GET BCM53600_A0_S_ANLPA1r_HALF_DUPLEXf_GET
#define S_ANLPA1r_HALF_DUPLEXf_SET BCM53600_A0_S_ANLPA1r_HALF_DUPLEXf_SET
#define S_ANLPA1r_PAUSEf_GET BCM53600_A0_S_ANLPA1r_PAUSEf_GET
#define S_ANLPA1r_PAUSEf_SET BCM53600_A0_S_ANLPA1r_PAUSEf_SET
#define S_ANLPA1r_RESERVED_1f_GET BCM53600_A0_S_ANLPA1r_RESERVED_1f_GET
#define S_ANLPA1r_RESERVED_1f_SET BCM53600_A0_S_ANLPA1r_RESERVED_1f_SET
#define S_ANLPA1r_REMOTE_FAULTf_GET BCM53600_A0_S_ANLPA1r_REMOTE_FAULTf_GET
#define S_ANLPA1r_REMOTE_FAULTf_SET BCM53600_A0_S_ANLPA1r_REMOTE_FAULTf_SET
#define S_ANLPA1r_ACKNOWLEDGEf_GET BCM53600_A0_S_ANLPA1r_ACKNOWLEDGEf_GET
#define S_ANLPA1r_ACKNOWLEDGEf_SET BCM53600_A0_S_ANLPA1r_ACKNOWLEDGEf_SET
#define S_ANLPA1r_NEXT_PAGEf_GET BCM53600_A0_S_ANLPA1r_NEXT_PAGEf_GET
#define S_ANLPA1r_NEXT_PAGEf_SET BCM53600_A0_S_ANLPA1r_NEXT_PAGEf_SET
#define READ_S_ANLPA1r BCM53600_A0_READ_S_ANLPA1r
#define WRITE_S_ANLPA1r BCM53600_A0_WRITE_S_ANLPA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_ANLPA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_ANLPA2
 * BLOCKS:   GPIC0
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_S_ANLPA2r 0x0000bb10

#define BCM53600_A0_S_ANLPA2r_SIZE 2

/*
 * This structure should be used to declare and program S_ANLPA2.
 *
 */
typedef union BCM53600_A0_S_ANLPA2r_s {
	uint32_t v[1];
	uint32_t s_anlpa2[1];
	uint32_t _s_anlpa2;
} BCM53600_A0_S_ANLPA2r_t;

#define BCM53600_A0_S_ANLPA2r_CLR(r) (r).s_anlpa2[0] = 0
#define BCM53600_A0_S_ANLPA2r_SET(r,d) (r).s_anlpa2[0] = d
#define BCM53600_A0_S_ANLPA2r_GET(r) (r).s_anlpa2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_ANLPA2r_RESERVEDf_GET(r) (((r).s_anlpa2[0]) & 0xffff)
#define BCM53600_A0_S_ANLPA2r_RESERVEDf_SET(r,f) (r).s_anlpa2[0]=(((r).s_anlpa2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access S_ANLPA2.
 *
 */
#define BCM53600_A0_READ_S_ANLPA2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_ANLPA2r,(r._s_anlpa2),2)
#define BCM53600_A0_WRITE_S_ANLPA2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_ANLPA2r,&(r._s_anlpa2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_ANLPA2r BCM53600_A0_S_ANLPA2r
#define S_ANLPA2r_SIZE BCM53600_A0_S_ANLPA2r_SIZE
typedef BCM53600_A0_S_ANLPA2r_t S_ANLPA2r_t;
#define S_ANLPA2r_CLR BCM53600_A0_S_ANLPA2r_CLR
#define S_ANLPA2r_SET BCM53600_A0_S_ANLPA2r_SET
#define S_ANLPA2r_GET BCM53600_A0_S_ANLPA2r_GET
#define S_ANLPA2r_RESERVEDf_GET BCM53600_A0_S_ANLPA2r_RESERVEDf_GET
#define S_ANLPA2r_RESERVEDf_SET BCM53600_A0_S_ANLPA2r_RESERVEDf_SET
#define READ_S_ANLPA2r BCM53600_A0_READ_S_ANLPA2r
#define WRITE_S_ANLPA2r BCM53600_A0_WRITE_S_ANLPA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_ANLPA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_ANNXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_S_ANNXPr 0x0000bb0e

#define BCM53600_A0_S_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program S_ANNXP.
 *
 */
typedef union BCM53600_A0_S_ANNXPr_s {
	uint32_t v[1];
	uint32_t s_annxp[1];
	uint32_t _s_annxp;
} BCM53600_A0_S_ANNXPr_t;

#define BCM53600_A0_S_ANNXPr_CLR(r) (r).s_annxp[0] = 0
#define BCM53600_A0_S_ANNXPr_SET(r,d) (r).s_annxp[0] = d
#define BCM53600_A0_S_ANNXPr_GET(r) (r).s_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_ANNXPr_RESERVEDf_GET(r) (((r).s_annxp[0]) & 0xffff)
#define BCM53600_A0_S_ANNXPr_RESERVEDf_SET(r,f) (r).s_annxp[0]=(((r).s_annxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access S_ANNXP.
 *
 */
#define BCM53600_A0_READ_S_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_ANNXPr,(r._s_annxp),2)
#define BCM53600_A0_WRITE_S_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_ANNXPr,&(r._s_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_ANNXPr BCM53600_A0_S_ANNXPr
#define S_ANNXPr_SIZE BCM53600_A0_S_ANNXPr_SIZE
typedef BCM53600_A0_S_ANNXPr_t S_ANNXPr_t;
#define S_ANNXPr_CLR BCM53600_A0_S_ANNXPr_CLR
#define S_ANNXPr_SET BCM53600_A0_S_ANNXPr_SET
#define S_ANNXPr_GET BCM53600_A0_S_ANNXPr_GET
#define S_ANNXPr_RESERVEDf_GET BCM53600_A0_S_ANNXPr_RESERVEDf_GET
#define S_ANNXPr_RESERVEDf_SET BCM53600_A0_S_ANNXPr_RESERVEDf_SET
#define READ_S_ANNXPr BCM53600_A0_READ_S_ANNXPr
#define WRITE_S_ANNXPr BCM53600_A0_WRITE_S_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable.0 = not 1000Based-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable.0 = not 1000Based-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable.0 = not 1000Based-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable.0 = not 1000Based-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53600_A0_S_EXT_STSr 0x0000bb1e

#define BCM53600_A0_S_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program S_EXT_STS.
 *
 */
typedef union BCM53600_A0_S_EXT_STSr_s {
	uint32_t v[1];
	uint32_t s_ext_sts[1];
	uint32_t _s_ext_sts;
} BCM53600_A0_S_EXT_STSr_t;

#define BCM53600_A0_S_EXT_STSr_CLR(r) (r).s_ext_sts[0] = 0
#define BCM53600_A0_S_EXT_STSr_SET(r,d) (r).s_ext_sts[0] = d
#define BCM53600_A0_S_EXT_STSr_GET(r) (r).s_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_EXT_STSr_RESERVEDf_GET(r) (((r).s_ext_sts[0]) & 0xfff)
#define BCM53600_A0_S_EXT_STSr_RESERVEDf_SET(r,f) (r).s_ext_sts[0]=(((r).s_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_S_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).s_ext_sts[0]) >> 12) & 0x1)
#define BCM53600_A0_S_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).s_ext_sts[0]=(((r).s_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_S_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).s_ext_sts[0]) >> 13) & 0x1)
#define BCM53600_A0_S_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).s_ext_sts[0]=(((r).s_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_S_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).s_ext_sts[0]) >> 14) & 0x1)
#define BCM53600_A0_S_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).s_ext_sts[0]=(((r).s_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_S_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).s_ext_sts[0]) >> 15) & 0x1)
#define BCM53600_A0_S_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).s_ext_sts[0]=(((r).s_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access S_EXT_STS.
 *
 */
#define BCM53600_A0_READ_S_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_EXT_STSr,(r._s_ext_sts),2)
#define BCM53600_A0_WRITE_S_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_EXT_STSr,&(r._s_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_EXT_STSr BCM53600_A0_S_EXT_STSr
#define S_EXT_STSr_SIZE BCM53600_A0_S_EXT_STSr_SIZE
typedef BCM53600_A0_S_EXT_STSr_t S_EXT_STSr_t;
#define S_EXT_STSr_CLR BCM53600_A0_S_EXT_STSr_CLR
#define S_EXT_STSr_SET BCM53600_A0_S_EXT_STSr_SET
#define S_EXT_STSr_GET BCM53600_A0_S_EXT_STSr_GET
#define S_EXT_STSr_RESERVEDf_GET BCM53600_A0_S_EXT_STSr_RESERVEDf_GET
#define S_EXT_STSr_RESERVEDf_SET BCM53600_A0_S_EXT_STSr_RESERVEDf_SET
#define S_EXT_STSr_B1000T_HD_CAPf_GET BCM53600_A0_S_EXT_STSr_B1000T_HD_CAPf_GET
#define S_EXT_STSr_B1000T_HD_CAPf_SET BCM53600_A0_S_EXT_STSr_B1000T_HD_CAPf_SET
#define S_EXT_STSr_B1000T_FD_CAPf_GET BCM53600_A0_S_EXT_STSr_B1000T_FD_CAPf_GET
#define S_EXT_STSr_B1000T_FD_CAPf_SET BCM53600_A0_S_EXT_STSr_B1000T_FD_CAPf_SET
#define S_EXT_STSr_B1000X_HD_CAPf_GET BCM53600_A0_S_EXT_STSr_B1000X_HD_CAPf_GET
#define S_EXT_STSr_B1000X_HD_CAPf_SET BCM53600_A0_S_EXT_STSr_B1000X_HD_CAPf_SET
#define S_EXT_STSr_B1000X_FD_CAPf_GET BCM53600_A0_S_EXT_STSr_B1000X_FD_CAPf_GET
#define S_EXT_STSr_B1000X_FD_CAPf_SET BCM53600_A0_S_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_S_EXT_STSr BCM53600_A0_READ_S_EXT_STSr
#define WRITE_S_EXT_STSr BCM53600_A0_WRITE_S_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_InRangeErrPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot InRange Errors Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_INRANGEERRPKTSr 0x00005364

#define BCM53600_A0_S_INRANGEERRPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_InRangeErrPkts.
 *
 */
typedef union BCM53600_A0_S_INRANGEERRPKTSr_s {
	uint32_t v[1];
	uint32_t s_inrangeerrpkts[1];
	uint32_t _s_inrangeerrpkts;
} BCM53600_A0_S_INRANGEERRPKTSr_t;

#define BCM53600_A0_S_INRANGEERRPKTSr_CLR(r) (r).s_inrangeerrpkts[0] = 0
#define BCM53600_A0_S_INRANGEERRPKTSr_SET(r,d) (r).s_inrangeerrpkts[0] = d
#define BCM53600_A0_S_INRANGEERRPKTSr_GET(r) (r).s_inrangeerrpkts[0]


/*
 * These macros can be used to access S_InRangeErrPkts.
 *
 */
#define BCM53600_A0_READ_S_INRANGEERRPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_INRANGEERRPKTSr,(r._s_inrangeerrpkts),4)
#define BCM53600_A0_WRITE_S_INRANGEERRPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_INRANGEERRPKTSr,&(r._s_inrangeerrpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_INRANGEERRPKTSr BCM53600_A0_S_INRANGEERRPKTSr
#define S_INRANGEERRPKTSr_SIZE BCM53600_A0_S_INRANGEERRPKTSr_SIZE
typedef BCM53600_A0_S_INRANGEERRPKTSr_t S_INRANGEERRPKTSr_t;
#define S_INRANGEERRPKTSr_CLR BCM53600_A0_S_INRANGEERRPKTSr_CLR
#define S_INRANGEERRPKTSr_SET BCM53600_A0_S_INRANGEERRPKTSr_SET
#define S_INRANGEERRPKTSr_GET BCM53600_A0_S_INRANGEERRPKTSr_GET
#define READ_S_INRANGEERRPKTSr BCM53600_A0_READ_S_INRANGEERRPKTSr
#define WRITE_S_INRANGEERRPKTSr BCM53600_A0_WRITE_S_INRANGEERRPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_INRANGEERRPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_MIICTL
 * BLOCKS:   GPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0       Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB,SPD_SEL_LSB}1X = 1000 Mbit/s.01 = 100 Mbit/s.00 =  10 Mbit/s.
 *     COL_TEST         1 : collision test mode enable.0 : collision test mode disable.
 *     DUPLEX_MOD       1 : Full Duplex.0 : Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION1 : Restart Auto-Negotiation process.0 : Normal operation.
 *     RESERVED_1       Reserved
 *     PWR_DOWN         1 : Low power mode.0 : Normal operation.
 *     AN_EN            1 : Auto-Negotiation Enable.0 : Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB,SPD_SEL_LSB}1X = 1000 Mbit/s.01 = 100 Mbit/s.00 =  10 Mbit/s.
 *     LOOPBACK         1 : Loopback mode.0 : Normal operation.
 *     RESET            1 : PHY reset.0 : Normal operation.
 *
 ******************************************************************************/
#define BCM53600_A0_S_MIICTLr 0x0000bb00

#define BCM53600_A0_S_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program S_MIICTL.
 *
 */
typedef union BCM53600_A0_S_MIICTLr_s {
	uint32_t v[1];
	uint32_t s_miictl[1];
	uint32_t _s_miictl;
} BCM53600_A0_S_MIICTLr_t;

#define BCM53600_A0_S_MIICTLr_CLR(r) (r).s_miictl[0] = 0
#define BCM53600_A0_S_MIICTLr_SET(r,d) (r).s_miictl[0] = d
#define BCM53600_A0_S_MIICTLr_GET(r) (r).s_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_MIICTLr_RESERVED_0f_GET(r) (((r).s_miictl[0]) & 0x3f)
#define BCM53600_A0_S_MIICTLr_RESERVED_0f_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_S_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).s_miictl[0]) >> 6) & 0x1)
#define BCM53600_A0_S_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_S_MIICTLr_COL_TESTf_GET(r) ((((r).s_miictl[0]) >> 7) & 0x1)
#define BCM53600_A0_S_MIICTLr_COL_TESTf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_S_MIICTLr_DUPLEX_MODf_GET(r) ((((r).s_miictl[0]) >> 8) & 0x1)
#define BCM53600_A0_S_MIICTLr_DUPLEX_MODf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_S_MIICTLr_RE_ANf_GET(r) ((((r).s_miictl[0]) >> 9) & 0x1)
#define BCM53600_A0_S_MIICTLr_RE_ANf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_S_MIICTLr_RESERVED_1f_GET(r) ((((r).s_miictl[0]) >> 10) & 0x1)
#define BCM53600_A0_S_MIICTLr_RESERVED_1f_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_S_MIICTLr_PWR_DOWNf_GET(r) ((((r).s_miictl[0]) >> 11) & 0x1)
#define BCM53600_A0_S_MIICTLr_PWR_DOWNf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_S_MIICTLr_AN_ENf_GET(r) ((((r).s_miictl[0]) >> 12) & 0x1)
#define BCM53600_A0_S_MIICTLr_AN_ENf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_S_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).s_miictl[0]) >> 13) & 0x1)
#define BCM53600_A0_S_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_S_MIICTLr_LOOPBACKf_GET(r) ((((r).s_miictl[0]) >> 14) & 0x1)
#define BCM53600_A0_S_MIICTLr_LOOPBACKf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_S_MIICTLr_RESETf_GET(r) ((((r).s_miictl[0]) >> 15) & 0x1)
#define BCM53600_A0_S_MIICTLr_RESETf_SET(r,f) (r).s_miictl[0]=(((r).s_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access S_MIICTL.
 *
 */
#define BCM53600_A0_READ_S_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_MIICTLr,(r._s_miictl),2)
#define BCM53600_A0_WRITE_S_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_MIICTLr,&(r._s_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_MIICTLr BCM53600_A0_S_MIICTLr
#define S_MIICTLr_SIZE BCM53600_A0_S_MIICTLr_SIZE
typedef BCM53600_A0_S_MIICTLr_t S_MIICTLr_t;
#define S_MIICTLr_CLR BCM53600_A0_S_MIICTLr_CLR
#define S_MIICTLr_SET BCM53600_A0_S_MIICTLr_SET
#define S_MIICTLr_GET BCM53600_A0_S_MIICTLr_GET
#define S_MIICTLr_RESERVED_0f_GET BCM53600_A0_S_MIICTLr_RESERVED_0f_GET
#define S_MIICTLr_RESERVED_0f_SET BCM53600_A0_S_MIICTLr_RESERVED_0f_SET
#define S_MIICTLr_SPD_SEL_MSBf_GET BCM53600_A0_S_MIICTLr_SPD_SEL_MSBf_GET
#define S_MIICTLr_SPD_SEL_MSBf_SET BCM53600_A0_S_MIICTLr_SPD_SEL_MSBf_SET
#define S_MIICTLr_COL_TESTf_GET BCM53600_A0_S_MIICTLr_COL_TESTf_GET
#define S_MIICTLr_COL_TESTf_SET BCM53600_A0_S_MIICTLr_COL_TESTf_SET
#define S_MIICTLr_DUPLEX_MODf_GET BCM53600_A0_S_MIICTLr_DUPLEX_MODf_GET
#define S_MIICTLr_DUPLEX_MODf_SET BCM53600_A0_S_MIICTLr_DUPLEX_MODf_SET
#define S_MIICTLr_RE_ANf_GET BCM53600_A0_S_MIICTLr_RE_ANf_GET
#define S_MIICTLr_RE_ANf_SET BCM53600_A0_S_MIICTLr_RE_ANf_SET
#define S_MIICTLr_RESERVED_1f_GET BCM53600_A0_S_MIICTLr_RESERVED_1f_GET
#define S_MIICTLr_RESERVED_1f_SET BCM53600_A0_S_MIICTLr_RESERVED_1f_SET
#define S_MIICTLr_PWR_DOWNf_GET BCM53600_A0_S_MIICTLr_PWR_DOWNf_GET
#define S_MIICTLr_PWR_DOWNf_SET BCM53600_A0_S_MIICTLr_PWR_DOWNf_SET
#define S_MIICTLr_AN_ENf_GET BCM53600_A0_S_MIICTLr_AN_ENf_GET
#define S_MIICTLr_AN_ENf_SET BCM53600_A0_S_MIICTLr_AN_ENf_SET
#define S_MIICTLr_SPD_SEL_LSBf_GET BCM53600_A0_S_MIICTLr_SPD_SEL_LSBf_GET
#define S_MIICTLr_SPD_SEL_LSBf_SET BCM53600_A0_S_MIICTLr_SPD_SEL_LSBf_SET
#define S_MIICTLr_LOOPBACKf_GET BCM53600_A0_S_MIICTLr_LOOPBACKf_GET
#define S_MIICTLr_LOOPBACKf_SET BCM53600_A0_S_MIICTLr_LOOPBACKf_SET
#define S_MIICTLr_RESETf_GET BCM53600_A0_S_MIICTLr_RESETf_GET
#define S_MIICTLr_RESETf_SET BCM53600_A0_S_MIICTLr_RESETf_SET
#define READ_S_MIICTLr BCM53600_A0_READ_S_MIICTLr
#define WRITE_S_MIICTLr BCM53600_A0_WRITE_S_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_MIISTS
 * BLOCKS:   GPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported.0 = basic register set capabilities only.
 *     JABBER_DET       1 = jabber condition detected.0 = no jabber condition detected.
 *     LINK_STA         1 = link pass.0 = link fail.
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable.0 =  not auto-negotiation capable.
 *     REMOTE_FAULT     1 = remote fault detected.0 = no remote fault detected.
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete.0 =  auto-negotiation in progress.
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed.0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved
 *     EXT_STS          1 = extended status information in register 0Fh.0 = no extended status information in register 0Fh.
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable.0 = not 100Based-T2 half duplex capable.
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable.0 = not 100Based-T2 full duplex capable.
 *     B10T_CAP         1 = 10Base-T half duplex capable.0 = not 10Based-T half duplex capable.
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable.0 = not 10Based-T full duplex capable.
 *     B100X_CAP        1 = 100Base-X half duplex capable.0 = not 100Based-X half duplex capable.
 *     B100X_FDX_CAP    1 = 100Base-X full duplex capable.0 = not 100Based-X full duplex capable.
 *     B100T4_CAP       1 = 100Base-T4 capable.0 = not 100Based-T4 capable.
 *
 ******************************************************************************/
#define BCM53600_A0_S_MIISTSr 0x0000bb02

#define BCM53600_A0_S_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program S_MIISTS.
 *
 */
typedef union BCM53600_A0_S_MIISTSr_s {
	uint32_t v[1];
	uint32_t s_miists[1];
	uint32_t _s_miists;
} BCM53600_A0_S_MIISTSr_t;

#define BCM53600_A0_S_MIISTSr_CLR(r) (r).s_miists[0] = 0
#define BCM53600_A0_S_MIISTSr_SET(r,d) (r).s_miists[0] = d
#define BCM53600_A0_S_MIISTSr_GET(r) (r).s_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_MIISTSr_EXT_CAPf_GET(r) (((r).s_miists[0]) & 0x1)
#define BCM53600_A0_S_MIISTSr_EXT_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_S_MIISTSr_JABBER_DETf_GET(r) ((((r).s_miists[0]) >> 1) & 0x1)
#define BCM53600_A0_S_MIISTSr_JABBER_DETf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_S_MIISTSr_LINK_STAf_GET(r) ((((r).s_miists[0]) >> 2) & 0x1)
#define BCM53600_A0_S_MIISTSr_LINK_STAf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_S_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).s_miists[0]) >> 3) & 0x1)
#define BCM53600_A0_S_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_S_MIISTSr_REMOTE_FAULTf_GET(r) ((((r).s_miists[0]) >> 4) & 0x1)
#define BCM53600_A0_S_MIISTSr_REMOTE_FAULTf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_S_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).s_miists[0]) >> 5) & 0x1)
#define BCM53600_A0_S_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_S_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).s_miists[0]) >> 6) & 0x1)
#define BCM53600_A0_S_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_S_MIISTSr_RESERVEDf_GET(r) ((((r).s_miists[0]) >> 7) & 0x1)
#define BCM53600_A0_S_MIISTSr_RESERVEDf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_S_MIISTSr_EXT_STSf_GET(r) ((((r).s_miists[0]) >> 8) & 0x1)
#define BCM53600_A0_S_MIISTSr_EXT_STSf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_S_MIISTSr_B100T2_HD_CAPf_GET(r) ((((r).s_miists[0]) >> 9) & 0x1)
#define BCM53600_A0_S_MIISTSr_B100T2_HD_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_S_MIISTSr_B100T2_FD_CAPf_GET(r) ((((r).s_miists[0]) >> 10) & 0x1)
#define BCM53600_A0_S_MIISTSr_B100T2_FD_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_S_MIISTSr_B10T_CAPf_GET(r) ((((r).s_miists[0]) >> 11) & 0x1)
#define BCM53600_A0_S_MIISTSr_B10T_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_S_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).s_miists[0]) >> 12) & 0x1)
#define BCM53600_A0_S_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_S_MIISTSr_B100X_CAPf_GET(r) ((((r).s_miists[0]) >> 13) & 0x1)
#define BCM53600_A0_S_MIISTSr_B100X_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_S_MIISTSr_B100X_FDX_CAPf_GET(r) ((((r).s_miists[0]) >> 14) & 0x1)
#define BCM53600_A0_S_MIISTSr_B100X_FDX_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_S_MIISTSr_B100T4_CAPf_GET(r) ((((r).s_miists[0]) >> 15) & 0x1)
#define BCM53600_A0_S_MIISTSr_B100T4_CAPf_SET(r,f) (r).s_miists[0]=(((r).s_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access S_MIISTS.
 *
 */
#define BCM53600_A0_READ_S_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_MIISTSr,(r._s_miists),2)
#define BCM53600_A0_WRITE_S_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_MIISTSr,&(r._s_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_MIISTSr BCM53600_A0_S_MIISTSr
#define S_MIISTSr_SIZE BCM53600_A0_S_MIISTSr_SIZE
typedef BCM53600_A0_S_MIISTSr_t S_MIISTSr_t;
#define S_MIISTSr_CLR BCM53600_A0_S_MIISTSr_CLR
#define S_MIISTSr_SET BCM53600_A0_S_MIISTSr_SET
#define S_MIISTSr_GET BCM53600_A0_S_MIISTSr_GET
#define S_MIISTSr_EXT_CAPf_GET BCM53600_A0_S_MIISTSr_EXT_CAPf_GET
#define S_MIISTSr_EXT_CAPf_SET BCM53600_A0_S_MIISTSr_EXT_CAPf_SET
#define S_MIISTSr_JABBER_DETf_GET BCM53600_A0_S_MIISTSr_JABBER_DETf_GET
#define S_MIISTSr_JABBER_DETf_SET BCM53600_A0_S_MIISTSr_JABBER_DETf_SET
#define S_MIISTSr_LINK_STAf_GET BCM53600_A0_S_MIISTSr_LINK_STAf_GET
#define S_MIISTSr_LINK_STAf_SET BCM53600_A0_S_MIISTSr_LINK_STAf_SET
#define S_MIISTSr_AUTO_NEGO_CAPf_GET BCM53600_A0_S_MIISTSr_AUTO_NEGO_CAPf_GET
#define S_MIISTSr_AUTO_NEGO_CAPf_SET BCM53600_A0_S_MIISTSr_AUTO_NEGO_CAPf_SET
#define S_MIISTSr_REMOTE_FAULTf_GET BCM53600_A0_S_MIISTSr_REMOTE_FAULTf_GET
#define S_MIISTSr_REMOTE_FAULTf_SET BCM53600_A0_S_MIISTSr_REMOTE_FAULTf_SET
#define S_MIISTSr_AUTO_NEGO_COMPf_GET BCM53600_A0_S_MIISTSr_AUTO_NEGO_COMPf_GET
#define S_MIISTSr_AUTO_NEGO_COMPf_SET BCM53600_A0_S_MIISTSr_AUTO_NEGO_COMPf_SET
#define S_MIISTSr_MF_PRE_SUPf_GET BCM53600_A0_S_MIISTSr_MF_PRE_SUPf_GET
#define S_MIISTSr_MF_PRE_SUPf_SET BCM53600_A0_S_MIISTSr_MF_PRE_SUPf_SET
#define S_MIISTSr_RESERVEDf_GET BCM53600_A0_S_MIISTSr_RESERVEDf_GET
#define S_MIISTSr_RESERVEDf_SET BCM53600_A0_S_MIISTSr_RESERVEDf_SET
#define S_MIISTSr_EXT_STSf_GET BCM53600_A0_S_MIISTSr_EXT_STSf_GET
#define S_MIISTSr_EXT_STSf_SET BCM53600_A0_S_MIISTSr_EXT_STSf_SET
#define S_MIISTSr_B100T2_HD_CAPf_GET BCM53600_A0_S_MIISTSr_B100T2_HD_CAPf_GET
#define S_MIISTSr_B100T2_HD_CAPf_SET BCM53600_A0_S_MIISTSr_B100T2_HD_CAPf_SET
#define S_MIISTSr_B100T2_FD_CAPf_GET BCM53600_A0_S_MIISTSr_B100T2_FD_CAPf_GET
#define S_MIISTSr_B100T2_FD_CAPf_SET BCM53600_A0_S_MIISTSr_B100T2_FD_CAPf_SET
#define S_MIISTSr_B10T_CAPf_GET BCM53600_A0_S_MIISTSr_B10T_CAPf_GET
#define S_MIISTSr_B10T_CAPf_SET BCM53600_A0_S_MIISTSr_B10T_CAPf_SET
#define S_MIISTSr_B10T_FDX_CAPf_GET BCM53600_A0_S_MIISTSr_B10T_FDX_CAPf_GET
#define S_MIISTSr_B10T_FDX_CAPf_SET BCM53600_A0_S_MIISTSr_B10T_FDX_CAPf_SET
#define S_MIISTSr_B100X_CAPf_GET BCM53600_A0_S_MIISTSr_B100X_CAPf_GET
#define S_MIISTSr_B100X_CAPf_SET BCM53600_A0_S_MIISTSr_B100X_CAPf_SET
#define S_MIISTSr_B100X_FDX_CAPf_GET BCM53600_A0_S_MIISTSr_B100X_FDX_CAPf_GET
#define S_MIISTSr_B100X_FDX_CAPf_SET BCM53600_A0_S_MIISTSr_B100X_FDX_CAPf_SET
#define S_MIISTSr_B100T4_CAPf_GET BCM53600_A0_S_MIISTSr_B100T4_CAPf_GET
#define S_MIISTSr_B100T4_CAPf_SET BCM53600_A0_S_MIISTSr_B100T4_CAPf_SET
#define READ_S_MIISTSr BCM53600_A0_READ_S_MIISTSr
#define WRITE_S_MIISTSr BCM53600_A0_WRITE_S_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_OutOfRangeErrPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot OutofRange Errors Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_OUTOFRANGEERRPKTSr 0x00005368

#define BCM53600_A0_S_OUTOFRANGEERRPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_OutOfRangeErrPkts.
 *
 */
typedef union BCM53600_A0_S_OUTOFRANGEERRPKTSr_s {
	uint32_t v[1];
	uint32_t s_outofrangeerrpkts[1];
	uint32_t _s_outofrangeerrpkts;
} BCM53600_A0_S_OUTOFRANGEERRPKTSr_t;

#define BCM53600_A0_S_OUTOFRANGEERRPKTSr_CLR(r) (r).s_outofrangeerrpkts[0] = 0
#define BCM53600_A0_S_OUTOFRANGEERRPKTSr_SET(r,d) (r).s_outofrangeerrpkts[0] = d
#define BCM53600_A0_S_OUTOFRANGEERRPKTSr_GET(r) (r).s_outofrangeerrpkts[0]


/*
 * These macros can be used to access S_OutOfRangeErrPkts.
 *
 */
#define BCM53600_A0_READ_S_OUTOFRANGEERRPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_OUTOFRANGEERRPKTSr,(r._s_outofrangeerrpkts),4)
#define BCM53600_A0_WRITE_S_OUTOFRANGEERRPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_OUTOFRANGEERRPKTSr,&(r._s_outofrangeerrpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_OUTOFRANGEERRPKTSr BCM53600_A0_S_OUTOFRANGEERRPKTSr
#define S_OUTOFRANGEERRPKTSr_SIZE BCM53600_A0_S_OUTOFRANGEERRPKTSr_SIZE
typedef BCM53600_A0_S_OUTOFRANGEERRPKTSr_t S_OUTOFRANGEERRPKTSr_t;
#define S_OUTOFRANGEERRPKTSr_CLR BCM53600_A0_S_OUTOFRANGEERRPKTSr_CLR
#define S_OUTOFRANGEERRPKTSr_SET BCM53600_A0_S_OUTOFRANGEERRPKTSr_SET
#define S_OUTOFRANGEERRPKTSr_GET BCM53600_A0_S_OUTOFRANGEERRPKTSr_GET
#define READ_S_OUTOFRANGEERRPKTSr BCM53600_A0_READ_S_OUTOFRANGEERRPKTSr
#define WRITE_S_OUTOFRANGEERRPKTSr BCM53600_A0_WRITE_S_OUTOFRANGEERRPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_OUTOFRANGEERRPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_PHYIDH
 * BLOCKS:   GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 18:3 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53600_A0_S_PHYIDHr 0x0000bb04

#define BCM53600_A0_S_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program S_PHYIDH.
 *
 */
typedef union BCM53600_A0_S_PHYIDHr_s {
	uint32_t v[1];
	uint32_t s_phyidh[1];
	uint32_t _s_phyidh;
} BCM53600_A0_S_PHYIDHr_t;

#define BCM53600_A0_S_PHYIDHr_CLR(r) (r).s_phyidh[0] = 0
#define BCM53600_A0_S_PHYIDHr_SET(r,d) (r).s_phyidh[0] = d
#define BCM53600_A0_S_PHYIDHr_GET(r) (r).s_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_PHYIDHr_OUIf_GET(r) (((r).s_phyidh[0]) & 0xffff)
#define BCM53600_A0_S_PHYIDHr_OUIf_SET(r,f) (r).s_phyidh[0]=(((r).s_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access S_PHYIDH.
 *
 */
#define BCM53600_A0_READ_S_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_PHYIDHr,(r._s_phyidh),2)
#define BCM53600_A0_WRITE_S_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_PHYIDHr,&(r._s_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PHYIDHr BCM53600_A0_S_PHYIDHr
#define S_PHYIDHr_SIZE BCM53600_A0_S_PHYIDHr_SIZE
typedef BCM53600_A0_S_PHYIDHr_t S_PHYIDHr_t;
#define S_PHYIDHr_CLR BCM53600_A0_S_PHYIDHr_CLR
#define S_PHYIDHr_SET BCM53600_A0_S_PHYIDHr_SET
#define S_PHYIDHr_GET BCM53600_A0_S_PHYIDHr_GET
#define S_PHYIDHr_OUIf_GET BCM53600_A0_S_PHYIDHr_OUIf_GET
#define S_PHYIDHr_OUIf_SET BCM53600_A0_S_PHYIDHr_OUIf_SET
#define READ_S_PHYIDHr BCM53600_A0_READ_S_PHYIDHr
#define WRITE_S_PHYIDHr BCM53600_A0_WRITE_S_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_PHYIDL
 * BLOCKS:   GPIC0
 * DESC:     PHY ID Low Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number.
 *     MODEL            Device model number.
 *     OUI              Bits 24:19 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53600_A0_S_PHYIDLr 0x0000bb06

#define BCM53600_A0_S_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program S_PHYIDL.
 *
 */
typedef union BCM53600_A0_S_PHYIDLr_s {
	uint32_t v[1];
	uint32_t s_phyidl[1];
	uint32_t _s_phyidl;
} BCM53600_A0_S_PHYIDLr_t;

#define BCM53600_A0_S_PHYIDLr_CLR(r) (r).s_phyidl[0] = 0
#define BCM53600_A0_S_PHYIDLr_SET(r,d) (r).s_phyidl[0] = d
#define BCM53600_A0_S_PHYIDLr_GET(r) (r).s_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_S_PHYIDLr_REVISIONf_GET(r) (((r).s_phyidl[0]) & 0xf)
#define BCM53600_A0_S_PHYIDLr_REVISIONf_SET(r,f) (r).s_phyidl[0]=(((r).s_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53600_A0_S_PHYIDLr_MODELf_GET(r) ((((r).s_phyidl[0]) >> 4) & 0x3f)
#define BCM53600_A0_S_PHYIDLr_MODELf_SET(r,f) (r).s_phyidl[0]=(((r).s_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53600_A0_S_PHYIDLr_OUIf_GET(r) ((((r).s_phyidl[0]) >> 10) & 0x3f)
#define BCM53600_A0_S_PHYIDLr_OUIf_SET(r,f) (r).s_phyidl[0]=(((r).s_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access S_PHYIDL.
 *
 */
#define BCM53600_A0_READ_S_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_S_PHYIDLr,(r._s_phyidl),2)
#define BCM53600_A0_WRITE_S_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_S_PHYIDLr,&(r._s_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PHYIDLr BCM53600_A0_S_PHYIDLr
#define S_PHYIDLr_SIZE BCM53600_A0_S_PHYIDLr_SIZE
typedef BCM53600_A0_S_PHYIDLr_t S_PHYIDLr_t;
#define S_PHYIDLr_CLR BCM53600_A0_S_PHYIDLr_CLR
#define S_PHYIDLr_SET BCM53600_A0_S_PHYIDLr_SET
#define S_PHYIDLr_GET BCM53600_A0_S_PHYIDLr_GET
#define S_PHYIDLr_REVISIONf_GET BCM53600_A0_S_PHYIDLr_REVISIONf_GET
#define S_PHYIDLr_REVISIONf_SET BCM53600_A0_S_PHYIDLr_REVISIONf_SET
#define S_PHYIDLr_MODELf_GET BCM53600_A0_S_PHYIDLr_MODELf_GET
#define S_PHYIDLr_MODELf_SET BCM53600_A0_S_PHYIDLr_MODELf_SET
#define S_PHYIDLr_OUIf_GET BCM53600_A0_S_PHYIDLr_OUIf_GET
#define S_PHYIDLr_OUIf_SET BCM53600_A0_S_PHYIDLr_OUIf_SET
#define READ_S_PHYIDLr BCM53600_A0_READ_S_PHYIDLr
#define WRITE_S_PHYIDLr BCM53600_A0_WRITE_S_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXALIGNMENTERRORSr 0x00005334

#define BCM53600_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 *
 */
typedef union BCM53600_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM53600_A0_S_RXALIGNMENTERRORSr_t;

#define BCM53600_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM53600_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM53600_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]


/*
 * These macros can be used to access S_RxAlignmentErrors.
 *
 */
#define BCM53600_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM53600_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM53600_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM53600_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM53600_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM53600_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM53600_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM53600_A0_S_RXALIGNMENTERRORSr_GET
#define READ_S_RXALIGNMENTERRORSr BCM53600_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM53600_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXBROADCASTPKTSr 0x00005350

#define BCM53600_A0_S_RXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkts.
 *
 */
typedef union BCM53600_A0_S_RXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkts[1];
	uint32_t _s_rxbroadcastpkts;
} BCM53600_A0_S_RXBROADCASTPKTSr_t;

#define BCM53600_A0_S_RXBROADCASTPKTSr_CLR(r) (r).s_rxbroadcastpkts[0] = 0
#define BCM53600_A0_S_RXBROADCASTPKTSr_SET(r,d) (r).s_rxbroadcastpkts[0] = d
#define BCM53600_A0_S_RXBROADCASTPKTSr_GET(r) (r).s_rxbroadcastpkts[0]


/*
 * These macros can be used to access S_RxBroadcastPkts.
 *
 */
#define BCM53600_A0_READ_S_RXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXBROADCASTPKTSr,(r._s_rxbroadcastpkts),4)
#define BCM53600_A0_WRITE_S_RXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXBROADCASTPKTSr,&(r._s_rxbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTSr BCM53600_A0_S_RXBROADCASTPKTSr
#define S_RXBROADCASTPKTSr_SIZE BCM53600_A0_S_RXBROADCASTPKTSr_SIZE
typedef BCM53600_A0_S_RXBROADCASTPKTSr_t S_RXBROADCASTPKTSr_t;
#define S_RXBROADCASTPKTSr_CLR BCM53600_A0_S_RXBROADCASTPKTSr_CLR
#define S_RXBROADCASTPKTSr_SET BCM53600_A0_S_RXBROADCASTPKTSr_SET
#define S_RXBROADCASTPKTSr_GET BCM53600_A0_S_RXBROADCASTPKTSr_GET
#define READ_S_RXBROADCASTPKTSr BCM53600_A0_READ_S_RXBROADCASTPKTSr
#define WRITE_S_RXBROADCASTPKTSr BCM53600_A0_WRITE_S_RXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXFCSERRORSr 0x00005338

#define BCM53600_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 *
 */
typedef union BCM53600_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM53600_A0_S_RXFCSERRORSr_t;

#define BCM53600_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM53600_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM53600_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]


/*
 * These macros can be used to access S_RxFCSErrors.
 *
 */
#define BCM53600_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM53600_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM53600_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM53600_A0_S_RXFCSERRORSr_SIZE
typedef BCM53600_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM53600_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM53600_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM53600_A0_S_RXFCSERRORSr_GET
#define READ_S_RXFCSERRORSr BCM53600_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM53600_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXFRAGMENTSr 0x00005354

#define BCM53600_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 *
 */
typedef union BCM53600_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM53600_A0_S_RXFRAGMENTSr_t;

#define BCM53600_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM53600_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM53600_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]


/*
 * These macros can be used to access S_RxFragments.
 *
 */
#define BCM53600_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM53600_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM53600_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM53600_A0_S_RXFRAGMENTSr_SIZE
typedef BCM53600_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM53600_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM53600_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM53600_A0_S_RXFRAGMENTSr_GET
#define READ_S_RXFRAGMENTSr BCM53600_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM53600_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxFwdDiscPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Forward Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXFWDDISCPKTSr 0x00005360

#define BCM53600_A0_S_RXFWDDISCPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFwdDiscPkts.
 *
 */
typedef union BCM53600_A0_S_RXFWDDISCPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxfwddiscpkts[1];
	uint32_t _s_rxfwddiscpkts;
} BCM53600_A0_S_RXFWDDISCPKTSr_t;

#define BCM53600_A0_S_RXFWDDISCPKTSr_CLR(r) (r).s_rxfwddiscpkts[0] = 0
#define BCM53600_A0_S_RXFWDDISCPKTSr_SET(r,d) (r).s_rxfwddiscpkts[0] = d
#define BCM53600_A0_S_RXFWDDISCPKTSr_GET(r) (r).s_rxfwddiscpkts[0]


/*
 * These macros can be used to access S_RxFwdDiscPkts.
 *
 */
#define BCM53600_A0_READ_S_RXFWDDISCPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXFWDDISCPKTSr,(r._s_rxfwddiscpkts),4)
#define BCM53600_A0_WRITE_S_RXFWDDISCPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXFWDDISCPKTSr,&(r._s_rxfwddiscpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFWDDISCPKTSr BCM53600_A0_S_RXFWDDISCPKTSr
#define S_RXFWDDISCPKTSr_SIZE BCM53600_A0_S_RXFWDDISCPKTSr_SIZE
typedef BCM53600_A0_S_RXFWDDISCPKTSr_t S_RXFWDDISCPKTSr_t;
#define S_RXFWDDISCPKTSr_CLR BCM53600_A0_S_RXFWDDISCPKTSr_CLR
#define S_RXFWDDISCPKTSr_SET BCM53600_A0_S_RXFWDDISCPKTSr_SET
#define S_RXFWDDISCPKTSr_GET BCM53600_A0_S_RXFWDDISCPKTSr_GET
#define READ_S_RXFWDDISCPKTSr BCM53600_A0_READ_S_RXFWDDISCPKTSr
#define WRITE_S_RXFWDDISCPKTSr BCM53600_A0_WRITE_S_RXFWDDISCPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXFWDDISCPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXGOODOCTETSr 0x0000533c

#define BCM53600_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 *
 */
typedef union BCM53600_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM53600_A0_S_RXGOODOCTETSr_t;

#define BCM53600_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM53600_A0_S_RXGOODOCTETSr_t))
#define BCM53600_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM53600_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]


/*
 * These macros can be used to access S_RxGoodOctets.
 *
 */
#define BCM53600_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM53600_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM53600_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM53600_A0_S_RXGOODOCTETSr_SIZE
typedef BCM53600_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM53600_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM53600_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM53600_A0_S_RXGOODOCTETSr_GET
#define READ_S_RXGOODOCTETSr BCM53600_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM53600_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxJabberPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXJABBERPKTSr 0x00005330

#define BCM53600_A0_S_RXJABBERPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabberPkts.
 *
 */
typedef union BCM53600_A0_S_RXJABBERPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxjabberpkts[1];
	uint32_t _s_rxjabberpkts;
} BCM53600_A0_S_RXJABBERPKTSr_t;

#define BCM53600_A0_S_RXJABBERPKTSr_CLR(r) (r).s_rxjabberpkts[0] = 0
#define BCM53600_A0_S_RXJABBERPKTSr_SET(r,d) (r).s_rxjabberpkts[0] = d
#define BCM53600_A0_S_RXJABBERPKTSr_GET(r) (r).s_rxjabberpkts[0]


/*
 * These macros can be used to access S_RxJabberPkts.
 *
 */
#define BCM53600_A0_READ_S_RXJABBERPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXJABBERPKTSr,(r._s_rxjabberpkts),4)
#define BCM53600_A0_WRITE_S_RXJABBERPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXJABBERPKTSr,&(r._s_rxjabberpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERPKTSr BCM53600_A0_S_RXJABBERPKTSr
#define S_RXJABBERPKTSr_SIZE BCM53600_A0_S_RXJABBERPKTSr_SIZE
typedef BCM53600_A0_S_RXJABBERPKTSr_t S_RXJABBERPKTSr_t;
#define S_RXJABBERPKTSr_CLR BCM53600_A0_S_RXJABBERPKTSr_CLR
#define S_RXJABBERPKTSr_SET BCM53600_A0_S_RXJABBERPKTSr_SET
#define S_RXJABBERPKTSr_GET BCM53600_A0_S_RXJABBERPKTSr_GET
#define READ_S_RXJABBERPKTSr BCM53600_A0_READ_S_RXJABBERPKTSr
#define WRITE_S_RXJABBERPKTSr BCM53600_A0_WRITE_S_RXJABBERPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXJABBERPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXMULTICASTPKTSr 0x0000534c

#define BCM53600_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 *
 */
typedef union BCM53600_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM53600_A0_S_RXMULTICASTPKTSr_t;

#define BCM53600_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM53600_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM53600_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]


/*
 * These macros can be used to access S_RxMulticastPkts.
 *
 */
#define BCM53600_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM53600_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM53600_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM53600_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM53600_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM53600_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM53600_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM53600_A0_S_RXMULTICASTPKTSr_GET
#define READ_S_RXMULTICASTPKTSr BCM53600_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM53600_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXOCTETSr 0x0000531c

#define BCM53600_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 *
 */
typedef union BCM53600_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM53600_A0_S_RXOCTETSr_t;

#define BCM53600_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM53600_A0_S_RXOCTETSr_t))
#define BCM53600_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM53600_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]


/*
 * These macros can be used to access S_RxOctets.
 *
 */
#define BCM53600_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM53600_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM53600_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM53600_A0_S_RXOCTETSr_SIZE
typedef BCM53600_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM53600_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM53600_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM53600_A0_S_RXOCTETSr_GET
#define READ_S_RXOCTETSr BCM53600_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM53600_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXOVERSIZEPKTSr 0x0000532c

#define BCM53600_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 *
 */
typedef union BCM53600_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM53600_A0_S_RXOVERSIZEPKTSr_t;

#define BCM53600_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM53600_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM53600_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]


/*
 * These macros can be used to access S_RxOversizePkts.
 *
 */
#define BCM53600_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM53600_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM53600_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM53600_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM53600_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM53600_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM53600_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM53600_A0_S_RXOVERSIZEPKTSr_GET
#define READ_S_RXOVERSIZEPKTSr BCM53600_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM53600_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPAUSEPKTSr 0x00005328

#define BCM53600_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 *
 */
typedef union BCM53600_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM53600_A0_S_RXPAUSEPKTSr_t;

#define BCM53600_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM53600_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM53600_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]


/*
 * These macros can be used to access S_RxPausePkts.
 *
 */
#define BCM53600_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM53600_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM53600_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM53600_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM53600_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM53600_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM53600_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM53600_A0_S_RXPAUSEPKTSr_GET
#define READ_S_RXPAUSEPKTSr BCM53600_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM53600_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPkts1024toMaxPkt
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx 1024 Bytes Octets to Standard Maximum Size Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPKTS1024TOMAXPKTr 0x00005314

#define BCM53600_A0_S_RXPKTS1024TOMAXPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPkts1024toMaxPkt.
 *
 */
typedef union BCM53600_A0_S_RXPKTS1024TOMAXPKTr_s {
	uint32_t v[1];
	uint32_t s_rxpkts1024tomaxpkt[1];
	uint32_t _s_rxpkts1024tomaxpkt;
} BCM53600_A0_S_RXPKTS1024TOMAXPKTr_t;

#define BCM53600_A0_S_RXPKTS1024TOMAXPKTr_CLR(r) (r).s_rxpkts1024tomaxpkt[0] = 0
#define BCM53600_A0_S_RXPKTS1024TOMAXPKTr_SET(r,d) (r).s_rxpkts1024tomaxpkt[0] = d
#define BCM53600_A0_S_RXPKTS1024TOMAXPKTr_GET(r) (r).s_rxpkts1024tomaxpkt[0]


/*
 * These macros can be used to access S_RxPkts1024toMaxPkt.
 *
 */
#define BCM53600_A0_READ_S_RXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPKTS1024TOMAXPKTr,(r._s_rxpkts1024tomaxpkt),4)
#define BCM53600_A0_WRITE_S_RXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPKTS1024TOMAXPKTr,&(r._s_rxpkts1024tomaxpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPKTS1024TOMAXPKTr BCM53600_A0_S_RXPKTS1024TOMAXPKTr
#define S_RXPKTS1024TOMAXPKTr_SIZE BCM53600_A0_S_RXPKTS1024TOMAXPKTr_SIZE
typedef BCM53600_A0_S_RXPKTS1024TOMAXPKTr_t S_RXPKTS1024TOMAXPKTr_t;
#define S_RXPKTS1024TOMAXPKTr_CLR BCM53600_A0_S_RXPKTS1024TOMAXPKTr_CLR
#define S_RXPKTS1024TOMAXPKTr_SET BCM53600_A0_S_RXPKTS1024TOMAXPKTr_SET
#define S_RXPKTS1024TOMAXPKTr_GET BCM53600_A0_S_RXPKTS1024TOMAXPKTr_GET
#define READ_S_RXPKTS1024TOMAXPKTr BCM53600_A0_READ_S_RXPKTS1024TOMAXPKTr
#define WRITE_S_RXPKTS1024TOMAXPKTr BCM53600_A0_WRITE_S_RXPKTS1024TOMAXPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPKTS1024TOMAXPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPKTS128TO255OCTETSr 0x00005308

#define BCM53600_A0_S_RXPKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPkts128to255Octets.
 *
 */
typedef union BCM53600_A0_S_RXPKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_rxpkts128to255octets[1];
	uint32_t _s_rxpkts128to255octets;
} BCM53600_A0_S_RXPKTS128TO255OCTETSr_t;

#define BCM53600_A0_S_RXPKTS128TO255OCTETSr_CLR(r) (r).s_rxpkts128to255octets[0] = 0
#define BCM53600_A0_S_RXPKTS128TO255OCTETSr_SET(r,d) (r).s_rxpkts128to255octets[0] = d
#define BCM53600_A0_S_RXPKTS128TO255OCTETSr_GET(r) (r).s_rxpkts128to255octets[0]


/*
 * These macros can be used to access S_RxPkts128to255Octets.
 *
 */
#define BCM53600_A0_READ_S_RXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPKTS128TO255OCTETSr,(r._s_rxpkts128to255octets),4)
#define BCM53600_A0_WRITE_S_RXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPKTS128TO255OCTETSr,&(r._s_rxpkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPKTS128TO255OCTETSr BCM53600_A0_S_RXPKTS128TO255OCTETSr
#define S_RXPKTS128TO255OCTETSr_SIZE BCM53600_A0_S_RXPKTS128TO255OCTETSr_SIZE
typedef BCM53600_A0_S_RXPKTS128TO255OCTETSr_t S_RXPKTS128TO255OCTETSr_t;
#define S_RXPKTS128TO255OCTETSr_CLR BCM53600_A0_S_RXPKTS128TO255OCTETSr_CLR
#define S_RXPKTS128TO255OCTETSr_SET BCM53600_A0_S_RXPKTS128TO255OCTETSr_SET
#define S_RXPKTS128TO255OCTETSr_GET BCM53600_A0_S_RXPKTS128TO255OCTETSr_GET
#define READ_S_RXPKTS128TO255OCTETSr BCM53600_A0_READ_S_RXPKTS128TO255OCTETSr
#define WRITE_S_RXPKTS128TO255OCTETSr BCM53600_A0_WRITE_S_RXPKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPKTS256TO511OCTETSr 0x0000530c

#define BCM53600_A0_S_RXPKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPkts256to511Octets.
 *
 */
typedef union BCM53600_A0_S_RXPKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_rxpkts256to511octets[1];
	uint32_t _s_rxpkts256to511octets;
} BCM53600_A0_S_RXPKTS256TO511OCTETSr_t;

#define BCM53600_A0_S_RXPKTS256TO511OCTETSr_CLR(r) (r).s_rxpkts256to511octets[0] = 0
#define BCM53600_A0_S_RXPKTS256TO511OCTETSr_SET(r,d) (r).s_rxpkts256to511octets[0] = d
#define BCM53600_A0_S_RXPKTS256TO511OCTETSr_GET(r) (r).s_rxpkts256to511octets[0]


/*
 * These macros can be used to access S_RxPkts256to511Octets.
 *
 */
#define BCM53600_A0_READ_S_RXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPKTS256TO511OCTETSr,(r._s_rxpkts256to511octets),4)
#define BCM53600_A0_WRITE_S_RXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPKTS256TO511OCTETSr,&(r._s_rxpkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPKTS256TO511OCTETSr BCM53600_A0_S_RXPKTS256TO511OCTETSr
#define S_RXPKTS256TO511OCTETSr_SIZE BCM53600_A0_S_RXPKTS256TO511OCTETSr_SIZE
typedef BCM53600_A0_S_RXPKTS256TO511OCTETSr_t S_RXPKTS256TO511OCTETSr_t;
#define S_RXPKTS256TO511OCTETSr_CLR BCM53600_A0_S_RXPKTS256TO511OCTETSr_CLR
#define S_RXPKTS256TO511OCTETSr_SET BCM53600_A0_S_RXPKTS256TO511OCTETSr_SET
#define S_RXPKTS256TO511OCTETSr_GET BCM53600_A0_S_RXPKTS256TO511OCTETSr_GET
#define READ_S_RXPKTS256TO511OCTETSr BCM53600_A0_READ_S_RXPKTS256TO511OCTETSr
#define WRITE_S_RXPKTS256TO511OCTETSr BCM53600_A0_WRITE_S_RXPKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPKTS512TO1023OCTETSr 0x00005310

#define BCM53600_A0_S_RXPKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPkts512to1023Octets.
 *
 */
typedef union BCM53600_A0_S_RXPKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_rxpkts512to1023octets[1];
	uint32_t _s_rxpkts512to1023octets;
} BCM53600_A0_S_RXPKTS512TO1023OCTETSr_t;

#define BCM53600_A0_S_RXPKTS512TO1023OCTETSr_CLR(r) (r).s_rxpkts512to1023octets[0] = 0
#define BCM53600_A0_S_RXPKTS512TO1023OCTETSr_SET(r,d) (r).s_rxpkts512to1023octets[0] = d
#define BCM53600_A0_S_RXPKTS512TO1023OCTETSr_GET(r) (r).s_rxpkts512to1023octets[0]


/*
 * These macros can be used to access S_RxPkts512to1023Octets.
 *
 */
#define BCM53600_A0_READ_S_RXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPKTS512TO1023OCTETSr,(r._s_rxpkts512to1023octets),4)
#define BCM53600_A0_WRITE_S_RXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPKTS512TO1023OCTETSr,&(r._s_rxpkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPKTS512TO1023OCTETSr BCM53600_A0_S_RXPKTS512TO1023OCTETSr
#define S_RXPKTS512TO1023OCTETSr_SIZE BCM53600_A0_S_RXPKTS512TO1023OCTETSr_SIZE
typedef BCM53600_A0_S_RXPKTS512TO1023OCTETSr_t S_RXPKTS512TO1023OCTETSr_t;
#define S_RXPKTS512TO1023OCTETSr_CLR BCM53600_A0_S_RXPKTS512TO1023OCTETSr_CLR
#define S_RXPKTS512TO1023OCTETSr_SET BCM53600_A0_S_RXPKTS512TO1023OCTETSr_SET
#define S_RXPKTS512TO1023OCTETSr_GET BCM53600_A0_S_RXPKTS512TO1023OCTETSr_GET
#define READ_S_RXPKTS512TO1023OCTETSr BCM53600_A0_READ_S_RXPKTS512TO1023OCTETSr
#define WRITE_S_RXPKTS512TO1023OCTETSr BCM53600_A0_WRITE_S_RXPKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPkts64Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPKTS64OCTETSr 0x00005300

#define BCM53600_A0_S_RXPKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPkts64Octets.
 *
 */
typedef union BCM53600_A0_S_RXPKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_rxpkts64octets[1];
	uint32_t _s_rxpkts64octets;
} BCM53600_A0_S_RXPKTS64OCTETSr_t;

#define BCM53600_A0_S_RXPKTS64OCTETSr_CLR(r) (r).s_rxpkts64octets[0] = 0
#define BCM53600_A0_S_RXPKTS64OCTETSr_SET(r,d) (r).s_rxpkts64octets[0] = d
#define BCM53600_A0_S_RXPKTS64OCTETSr_GET(r) (r).s_rxpkts64octets[0]


/*
 * These macros can be used to access S_RxPkts64Octets.
 *
 */
#define BCM53600_A0_READ_S_RXPKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPKTS64OCTETSr,(r._s_rxpkts64octets),4)
#define BCM53600_A0_WRITE_S_RXPKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPKTS64OCTETSr,&(r._s_rxpkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPKTS64OCTETSr BCM53600_A0_S_RXPKTS64OCTETSr
#define S_RXPKTS64OCTETSr_SIZE BCM53600_A0_S_RXPKTS64OCTETSr_SIZE
typedef BCM53600_A0_S_RXPKTS64OCTETSr_t S_RXPKTS64OCTETSr_t;
#define S_RXPKTS64OCTETSr_CLR BCM53600_A0_S_RXPKTS64OCTETSr_CLR
#define S_RXPKTS64OCTETSr_SET BCM53600_A0_S_RXPKTS64OCTETSr_SET
#define S_RXPKTS64OCTETSr_GET BCM53600_A0_S_RXPKTS64OCTETSr_GET
#define READ_S_RXPKTS64OCTETSr BCM53600_A0_READ_S_RXPKTS64OCTETSr
#define WRITE_S_RXPKTS64OCTETSr BCM53600_A0_WRITE_S_RXPKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxPkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXPKTS65TO127OCTETSr 0x00005304

#define BCM53600_A0_S_RXPKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPkts65to127Octets.
 *
 */
typedef union BCM53600_A0_S_RXPKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_rxpkts65to127octets[1];
	uint32_t _s_rxpkts65to127octets;
} BCM53600_A0_S_RXPKTS65TO127OCTETSr_t;

#define BCM53600_A0_S_RXPKTS65TO127OCTETSr_CLR(r) (r).s_rxpkts65to127octets[0] = 0
#define BCM53600_A0_S_RXPKTS65TO127OCTETSr_SET(r,d) (r).s_rxpkts65to127octets[0] = d
#define BCM53600_A0_S_RXPKTS65TO127OCTETSr_GET(r) (r).s_rxpkts65to127octets[0]


/*
 * These macros can be used to access S_RxPkts65to127Octets.
 *
 */
#define BCM53600_A0_READ_S_RXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXPKTS65TO127OCTETSr,(r._s_rxpkts65to127octets),4)
#define BCM53600_A0_WRITE_S_RXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXPKTS65TO127OCTETSr,&(r._s_rxpkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPKTS65TO127OCTETSr BCM53600_A0_S_RXPKTS65TO127OCTETSr
#define S_RXPKTS65TO127OCTETSr_SIZE BCM53600_A0_S_RXPKTS65TO127OCTETSr_SIZE
typedef BCM53600_A0_S_RXPKTS65TO127OCTETSr_t S_RXPKTS65TO127OCTETSr_t;
#define S_RXPKTS65TO127OCTETSr_CLR BCM53600_A0_S_RXPKTS65TO127OCTETSr_CLR
#define S_RXPKTS65TO127OCTETSr_SET BCM53600_A0_S_RXPKTS65TO127OCTETSr_SET
#define S_RXPKTS65TO127OCTETSr_GET BCM53600_A0_S_RXPKTS65TO127OCTETSr_GET
#define READ_S_RXPKTS65TO127OCTETSr BCM53600_A0_READ_S_RXPKTS65TO127OCTETSr
#define WRITE_S_RXPKTS65TO127OCTETSr BCM53600_A0_WRITE_S_RXPKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXPKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxSymbolErr
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXSYMBOLERRr 0x0000535c

#define BCM53600_A0_S_RXSYMBOLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSymbolErr.
 *
 */
typedef union BCM53600_A0_S_RXSYMBOLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymbolerr[1];
	uint32_t _s_rxsymbolerr;
} BCM53600_A0_S_RXSYMBOLERRr_t;

#define BCM53600_A0_S_RXSYMBOLERRr_CLR(r) (r).s_rxsymbolerr[0] = 0
#define BCM53600_A0_S_RXSYMBOLERRr_SET(r,d) (r).s_rxsymbolerr[0] = d
#define BCM53600_A0_S_RXSYMBOLERRr_GET(r) (r).s_rxsymbolerr[0]


/*
 * These macros can be used to access S_RxSymbolErr.
 *
 */
#define BCM53600_A0_READ_S_RXSYMBOLERRr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXSYMBOLERRr,(r._s_rxsymbolerr),4)
#define BCM53600_A0_WRITE_S_RXSYMBOLERRr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXSYMBOLERRr,&(r._s_rxsymbolerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBOLERRr BCM53600_A0_S_RXSYMBOLERRr
#define S_RXSYMBOLERRr_SIZE BCM53600_A0_S_RXSYMBOLERRr_SIZE
typedef BCM53600_A0_S_RXSYMBOLERRr_t S_RXSYMBOLERRr_t;
#define S_RXSYMBOLERRr_CLR BCM53600_A0_S_RXSYMBOLERRr_CLR
#define S_RXSYMBOLERRr_SET BCM53600_A0_S_RXSYMBOLERRr_SET
#define S_RXSYMBOLERRr_GET BCM53600_A0_S_RXSYMBOLERRr_GET
#define READ_S_RXSYMBOLERRr BCM53600_A0_READ_S_RXSYMBOLERRr
#define WRITE_S_RXSYMBOLERRr BCM53600_A0_WRITE_S_RXSYMBOLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXSYMBOLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXUNDERSIZEPKTSr 0x00005324

#define BCM53600_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 *
 */
typedef union BCM53600_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM53600_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM53600_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM53600_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM53600_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]


/*
 * These macros can be used to access S_RxUndersizePkts.
 *
 */
#define BCM53600_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM53600_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM53600_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM53600_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM53600_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM53600_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM53600_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM53600_A0_S_RXUNDERSIZEPKTSr_GET
#define READ_S_RXUNDERSIZEPKTSr BCM53600_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM53600_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RXUNICASTPKTSr 0x00005348

#define BCM53600_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 *
 */
typedef union BCM53600_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM53600_A0_S_RXUNICASTPKTSr_t;

#define BCM53600_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM53600_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM53600_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]


/*
 * These macros can be used to access S_RxUnicastPkts.
 *
 */
#define BCM53600_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM53600_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM53600_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM53600_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM53600_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM53600_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM53600_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM53600_A0_S_RXUNICASTPKTSr_GET
#define READ_S_RXUNICASTPKTSr BCM53600_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM53600_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_Rx_Jumbo_Packet_Counter
 * BLOCKS:   SYS
 * DESC:     Snapshot Rx Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr 0x00005318

#define BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program S_Rx_Jumbo_Packet_Counter.
 *
 */
typedef union BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_s {
	uint32_t v[1];
	uint32_t s_rx_jumbo_packet_counter[1];
	uint32_t _s_rx_jumbo_packet_counter;
} BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_t;

#define BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_CLR(r) (r).s_rx_jumbo_packet_counter[0] = 0
#define BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_SET(r,d) (r).s_rx_jumbo_packet_counter[0] = d
#define BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_GET(r) (r).s_rx_jumbo_packet_counter[0]


/*
 * These macros can be used to access S_Rx_Jumbo_Packet_Counter.
 *
 */
#define BCM53600_A0_READ_S_RX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr,(r._s_rx_jumbo_packet_counter),4)
#define BCM53600_A0_WRITE_S_RX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr,&(r._s_rx_jumbo_packet_counter),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RX_JUMBO_PACKET_COUNTERr BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr
#define S_RX_JUMBO_PACKET_COUNTERr_SIZE BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_SIZE
typedef BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_t S_RX_JUMBO_PACKET_COUNTERr_t;
#define S_RX_JUMBO_PACKET_COUNTERr_CLR BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_CLR
#define S_RX_JUMBO_PACKET_COUNTERr_SET BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_SET
#define S_RX_JUMBO_PACKET_COUNTERr_GET BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr_GET
#define READ_S_RX_JUMBO_PACKET_COUNTERr BCM53600_A0_READ_S_RX_JUMBO_PACKET_COUNTERr
#define WRITE_S_RX_JUMBO_PACKET_COUNTERr BCM53600_A0_WRITE_S_RX_JUMBO_PACKET_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_RX_JUMBO_PACKET_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ0Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q0 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ0OCTETSr 0x00005458

#define BCM53600_A0_S_TXQQ0OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ0Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ0OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq0octets[2];
	uint32_t _s_txqq0octets;
} BCM53600_A0_S_TXQQ0OCTETSr_t;

#define BCM53600_A0_S_TXQQ0OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq0octets), 0, sizeof(BCM53600_A0_S_TXQQ0OCTETSr_t))
#define BCM53600_A0_S_TXQQ0OCTETSr_SET(r,i,d) (r).s_txqq0octets[i] = d
#define BCM53600_A0_S_TXQQ0OCTETSr_GET(r,i) (r).s_txqq0octets[i]


/*
 * These macros can be used to access S_TXQQ0Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ0OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ0OCTETSr,(r._s_txqq0octets),8)
#define BCM53600_A0_WRITE_S_TXQQ0OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ0OCTETSr,&(r._s_txqq0octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ0OCTETSr BCM53600_A0_S_TXQQ0OCTETSr
#define S_TXQQ0OCTETSr_SIZE BCM53600_A0_S_TXQQ0OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ0OCTETSr_t S_TXQQ0OCTETSr_t;
#define S_TXQQ0OCTETSr_CLR BCM53600_A0_S_TXQQ0OCTETSr_CLR
#define S_TXQQ0OCTETSr_SET BCM53600_A0_S_TXQQ0OCTETSr_SET
#define S_TXQQ0OCTETSr_GET BCM53600_A0_S_TXQQ0OCTETSr_GET
#define READ_S_TXQQ0OCTETSr BCM53600_A0_READ_S_TXQQ0OCTETSr
#define WRITE_S_TXQQ0OCTETSr BCM53600_A0_WRITE_S_TXQQ0OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ0OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ0Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ0PACKETr 0x00005454

#define BCM53600_A0_S_TXQQ0PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ0Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ0PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq0packet[1];
	uint32_t _s_txqq0packet;
} BCM53600_A0_S_TXQQ0PACKETr_t;

#define BCM53600_A0_S_TXQQ0PACKETr_CLR(r) (r).s_txqq0packet[0] = 0
#define BCM53600_A0_S_TXQQ0PACKETr_SET(r,d) (r).s_txqq0packet[0] = d
#define BCM53600_A0_S_TXQQ0PACKETr_GET(r) (r).s_txqq0packet[0]


/*
 * These macros can be used to access S_TXQQ0Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ0PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ0PACKETr,(r._s_txqq0packet),4)
#define BCM53600_A0_WRITE_S_TXQQ0PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ0PACKETr,&(r._s_txqq0packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ0PACKETr BCM53600_A0_S_TXQQ0PACKETr
#define S_TXQQ0PACKETr_SIZE BCM53600_A0_S_TXQQ0PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ0PACKETr_t S_TXQQ0PACKETr_t;
#define S_TXQQ0PACKETr_CLR BCM53600_A0_S_TXQQ0PACKETr_CLR
#define S_TXQQ0PACKETr_SET BCM53600_A0_S_TXQQ0PACKETr_SET
#define S_TXQQ0PACKETr_GET BCM53600_A0_S_TXQQ0PACKETr_GET
#define READ_S_TXQQ0PACKETr BCM53600_A0_READ_S_TXQQ0PACKETr
#define WRITE_S_TXQQ0PACKETr BCM53600_A0_WRITE_S_TXQQ0PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ0PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ1Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q1 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ1OCTETSr 0x00005464

#define BCM53600_A0_S_TXQQ1OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ1Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ1OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq1octets[2];
	uint32_t _s_txqq1octets;
} BCM53600_A0_S_TXQQ1OCTETSr_t;

#define BCM53600_A0_S_TXQQ1OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq1octets), 0, sizeof(BCM53600_A0_S_TXQQ1OCTETSr_t))
#define BCM53600_A0_S_TXQQ1OCTETSr_SET(r,i,d) (r).s_txqq1octets[i] = d
#define BCM53600_A0_S_TXQQ1OCTETSr_GET(r,i) (r).s_txqq1octets[i]


/*
 * These macros can be used to access S_TXQQ1Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ1OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ1OCTETSr,(r._s_txqq1octets),8)
#define BCM53600_A0_WRITE_S_TXQQ1OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ1OCTETSr,&(r._s_txqq1octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ1OCTETSr BCM53600_A0_S_TXQQ1OCTETSr
#define S_TXQQ1OCTETSr_SIZE BCM53600_A0_S_TXQQ1OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ1OCTETSr_t S_TXQQ1OCTETSr_t;
#define S_TXQQ1OCTETSr_CLR BCM53600_A0_S_TXQQ1OCTETSr_CLR
#define S_TXQQ1OCTETSr_SET BCM53600_A0_S_TXQQ1OCTETSr_SET
#define S_TXQQ1OCTETSr_GET BCM53600_A0_S_TXQQ1OCTETSr_GET
#define READ_S_TXQQ1OCTETSr BCM53600_A0_READ_S_TXQQ1OCTETSr
#define WRITE_S_TXQQ1OCTETSr BCM53600_A0_WRITE_S_TXQQ1OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ1OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ1Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ1PACKETr 0x00005460

#define BCM53600_A0_S_TXQQ1PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ1Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ1PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq1packet[1];
	uint32_t _s_txqq1packet;
} BCM53600_A0_S_TXQQ1PACKETr_t;

#define BCM53600_A0_S_TXQQ1PACKETr_CLR(r) (r).s_txqq1packet[0] = 0
#define BCM53600_A0_S_TXQQ1PACKETr_SET(r,d) (r).s_txqq1packet[0] = d
#define BCM53600_A0_S_TXQQ1PACKETr_GET(r) (r).s_txqq1packet[0]


/*
 * These macros can be used to access S_TXQQ1Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ1PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ1PACKETr,(r._s_txqq1packet),4)
#define BCM53600_A0_WRITE_S_TXQQ1PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ1PACKETr,&(r._s_txqq1packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ1PACKETr BCM53600_A0_S_TXQQ1PACKETr
#define S_TXQQ1PACKETr_SIZE BCM53600_A0_S_TXQQ1PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ1PACKETr_t S_TXQQ1PACKETr_t;
#define S_TXQQ1PACKETr_CLR BCM53600_A0_S_TXQQ1PACKETr_CLR
#define S_TXQQ1PACKETr_SET BCM53600_A0_S_TXQQ1PACKETr_SET
#define S_TXQQ1PACKETr_GET BCM53600_A0_S_TXQQ1PACKETr_GET
#define READ_S_TXQQ1PACKETr BCM53600_A0_READ_S_TXQQ1PACKETr
#define WRITE_S_TXQQ1PACKETr BCM53600_A0_WRITE_S_TXQQ1PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ1PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ2Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q2 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ2OCTETSr 0x00005470

#define BCM53600_A0_S_TXQQ2OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ2Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ2OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq2octets[2];
	uint32_t _s_txqq2octets;
} BCM53600_A0_S_TXQQ2OCTETSr_t;

#define BCM53600_A0_S_TXQQ2OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq2octets), 0, sizeof(BCM53600_A0_S_TXQQ2OCTETSr_t))
#define BCM53600_A0_S_TXQQ2OCTETSr_SET(r,i,d) (r).s_txqq2octets[i] = d
#define BCM53600_A0_S_TXQQ2OCTETSr_GET(r,i) (r).s_txqq2octets[i]


/*
 * These macros can be used to access S_TXQQ2Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ2OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ2OCTETSr,(r._s_txqq2octets),8)
#define BCM53600_A0_WRITE_S_TXQQ2OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ2OCTETSr,&(r._s_txqq2octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ2OCTETSr BCM53600_A0_S_TXQQ2OCTETSr
#define S_TXQQ2OCTETSr_SIZE BCM53600_A0_S_TXQQ2OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ2OCTETSr_t S_TXQQ2OCTETSr_t;
#define S_TXQQ2OCTETSr_CLR BCM53600_A0_S_TXQQ2OCTETSr_CLR
#define S_TXQQ2OCTETSr_SET BCM53600_A0_S_TXQQ2OCTETSr_SET
#define S_TXQQ2OCTETSr_GET BCM53600_A0_S_TXQQ2OCTETSr_GET
#define READ_S_TXQQ2OCTETSr BCM53600_A0_READ_S_TXQQ2OCTETSr
#define WRITE_S_TXQQ2OCTETSr BCM53600_A0_WRITE_S_TXQQ2OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ2OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ2Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ2PACKETr 0x0000546c

#define BCM53600_A0_S_TXQQ2PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ2Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ2PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq2packet[1];
	uint32_t _s_txqq2packet;
} BCM53600_A0_S_TXQQ2PACKETr_t;

#define BCM53600_A0_S_TXQQ2PACKETr_CLR(r) (r).s_txqq2packet[0] = 0
#define BCM53600_A0_S_TXQQ2PACKETr_SET(r,d) (r).s_txqq2packet[0] = d
#define BCM53600_A0_S_TXQQ2PACKETr_GET(r) (r).s_txqq2packet[0]


/*
 * These macros can be used to access S_TXQQ2Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ2PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ2PACKETr,(r._s_txqq2packet),4)
#define BCM53600_A0_WRITE_S_TXQQ2PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ2PACKETr,&(r._s_txqq2packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ2PACKETr BCM53600_A0_S_TXQQ2PACKETr
#define S_TXQQ2PACKETr_SIZE BCM53600_A0_S_TXQQ2PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ2PACKETr_t S_TXQQ2PACKETr_t;
#define S_TXQQ2PACKETr_CLR BCM53600_A0_S_TXQQ2PACKETr_CLR
#define S_TXQQ2PACKETr_SET BCM53600_A0_S_TXQQ2PACKETr_SET
#define S_TXQQ2PACKETr_GET BCM53600_A0_S_TXQQ2PACKETr_GET
#define READ_S_TXQQ2PACKETr BCM53600_A0_READ_S_TXQQ2PACKETr
#define WRITE_S_TXQQ2PACKETr BCM53600_A0_WRITE_S_TXQQ2PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ2PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ3Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q3 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ3OCTETSr 0x0000547c

#define BCM53600_A0_S_TXQQ3OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ3Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ3OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq3octets[2];
	uint32_t _s_txqq3octets;
} BCM53600_A0_S_TXQQ3OCTETSr_t;

#define BCM53600_A0_S_TXQQ3OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq3octets), 0, sizeof(BCM53600_A0_S_TXQQ3OCTETSr_t))
#define BCM53600_A0_S_TXQQ3OCTETSr_SET(r,i,d) (r).s_txqq3octets[i] = d
#define BCM53600_A0_S_TXQQ3OCTETSr_GET(r,i) (r).s_txqq3octets[i]


/*
 * These macros can be used to access S_TXQQ3Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ3OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ3OCTETSr,(r._s_txqq3octets),8)
#define BCM53600_A0_WRITE_S_TXQQ3OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ3OCTETSr,&(r._s_txqq3octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ3OCTETSr BCM53600_A0_S_TXQQ3OCTETSr
#define S_TXQQ3OCTETSr_SIZE BCM53600_A0_S_TXQQ3OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ3OCTETSr_t S_TXQQ3OCTETSr_t;
#define S_TXQQ3OCTETSr_CLR BCM53600_A0_S_TXQQ3OCTETSr_CLR
#define S_TXQQ3OCTETSr_SET BCM53600_A0_S_TXQQ3OCTETSr_SET
#define S_TXQQ3OCTETSr_GET BCM53600_A0_S_TXQQ3OCTETSr_GET
#define READ_S_TXQQ3OCTETSr BCM53600_A0_READ_S_TXQQ3OCTETSr
#define WRITE_S_TXQQ3OCTETSr BCM53600_A0_WRITE_S_TXQQ3OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ3OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ3Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ3PACKETr 0x00005478

#define BCM53600_A0_S_TXQQ3PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ3Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ3PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq3packet[1];
	uint32_t _s_txqq3packet;
} BCM53600_A0_S_TXQQ3PACKETr_t;

#define BCM53600_A0_S_TXQQ3PACKETr_CLR(r) (r).s_txqq3packet[0] = 0
#define BCM53600_A0_S_TXQQ3PACKETr_SET(r,d) (r).s_txqq3packet[0] = d
#define BCM53600_A0_S_TXQQ3PACKETr_GET(r) (r).s_txqq3packet[0]


/*
 * These macros can be used to access S_TXQQ3Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ3PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ3PACKETr,(r._s_txqq3packet),4)
#define BCM53600_A0_WRITE_S_TXQQ3PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ3PACKETr,&(r._s_txqq3packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ3PACKETr BCM53600_A0_S_TXQQ3PACKETr
#define S_TXQQ3PACKETr_SIZE BCM53600_A0_S_TXQQ3PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ3PACKETr_t S_TXQQ3PACKETr_t;
#define S_TXQQ3PACKETr_CLR BCM53600_A0_S_TXQQ3PACKETr_CLR
#define S_TXQQ3PACKETr_SET BCM53600_A0_S_TXQQ3PACKETr_SET
#define S_TXQQ3PACKETr_GET BCM53600_A0_S_TXQQ3PACKETr_GET
#define READ_S_TXQQ3PACKETr BCM53600_A0_READ_S_TXQQ3PACKETr
#define WRITE_S_TXQQ3PACKETr BCM53600_A0_WRITE_S_TXQQ3PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ3PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ4Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q4 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ4OCTETSr 0x00005488

#define BCM53600_A0_S_TXQQ4OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ4Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ4OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq4octets[2];
	uint32_t _s_txqq4octets;
} BCM53600_A0_S_TXQQ4OCTETSr_t;

#define BCM53600_A0_S_TXQQ4OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq4octets), 0, sizeof(BCM53600_A0_S_TXQQ4OCTETSr_t))
#define BCM53600_A0_S_TXQQ4OCTETSr_SET(r,i,d) (r).s_txqq4octets[i] = d
#define BCM53600_A0_S_TXQQ4OCTETSr_GET(r,i) (r).s_txqq4octets[i]


/*
 * These macros can be used to access S_TXQQ4Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ4OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ4OCTETSr,(r._s_txqq4octets),8)
#define BCM53600_A0_WRITE_S_TXQQ4OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ4OCTETSr,&(r._s_txqq4octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ4OCTETSr BCM53600_A0_S_TXQQ4OCTETSr
#define S_TXQQ4OCTETSr_SIZE BCM53600_A0_S_TXQQ4OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ4OCTETSr_t S_TXQQ4OCTETSr_t;
#define S_TXQQ4OCTETSr_CLR BCM53600_A0_S_TXQQ4OCTETSr_CLR
#define S_TXQQ4OCTETSr_SET BCM53600_A0_S_TXQQ4OCTETSr_SET
#define S_TXQQ4OCTETSr_GET BCM53600_A0_S_TXQQ4OCTETSr_GET
#define READ_S_TXQQ4OCTETSr BCM53600_A0_READ_S_TXQQ4OCTETSr
#define WRITE_S_TXQQ4OCTETSr BCM53600_A0_WRITE_S_TXQQ4OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ4OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ4Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ4PACKETr 0x00005484

#define BCM53600_A0_S_TXQQ4PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ4Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ4PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq4packet[1];
	uint32_t _s_txqq4packet;
} BCM53600_A0_S_TXQQ4PACKETr_t;

#define BCM53600_A0_S_TXQQ4PACKETr_CLR(r) (r).s_txqq4packet[0] = 0
#define BCM53600_A0_S_TXQQ4PACKETr_SET(r,d) (r).s_txqq4packet[0] = d
#define BCM53600_A0_S_TXQQ4PACKETr_GET(r) (r).s_txqq4packet[0]


/*
 * These macros can be used to access S_TXQQ4Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ4PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ4PACKETr,(r._s_txqq4packet),4)
#define BCM53600_A0_WRITE_S_TXQQ4PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ4PACKETr,&(r._s_txqq4packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ4PACKETr BCM53600_A0_S_TXQQ4PACKETr
#define S_TXQQ4PACKETr_SIZE BCM53600_A0_S_TXQQ4PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ4PACKETr_t S_TXQQ4PACKETr_t;
#define S_TXQQ4PACKETr_CLR BCM53600_A0_S_TXQQ4PACKETr_CLR
#define S_TXQQ4PACKETr_SET BCM53600_A0_S_TXQQ4PACKETr_SET
#define S_TXQQ4PACKETr_GET BCM53600_A0_S_TXQQ4PACKETr_GET
#define READ_S_TXQQ4PACKETr BCM53600_A0_READ_S_TXQQ4PACKETr
#define WRITE_S_TXQQ4PACKETr BCM53600_A0_WRITE_S_TXQQ4PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ4PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ5Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q5 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ5OCTETSr 0x00005494

#define BCM53600_A0_S_TXQQ5OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ5Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ5OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq5octets[2];
	uint32_t _s_txqq5octets;
} BCM53600_A0_S_TXQQ5OCTETSr_t;

#define BCM53600_A0_S_TXQQ5OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq5octets), 0, sizeof(BCM53600_A0_S_TXQQ5OCTETSr_t))
#define BCM53600_A0_S_TXQQ5OCTETSr_SET(r,i,d) (r).s_txqq5octets[i] = d
#define BCM53600_A0_S_TXQQ5OCTETSr_GET(r,i) (r).s_txqq5octets[i]


/*
 * These macros can be used to access S_TXQQ5Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ5OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ5OCTETSr,(r._s_txqq5octets),8)
#define BCM53600_A0_WRITE_S_TXQQ5OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ5OCTETSr,&(r._s_txqq5octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ5OCTETSr BCM53600_A0_S_TXQQ5OCTETSr
#define S_TXQQ5OCTETSr_SIZE BCM53600_A0_S_TXQQ5OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ5OCTETSr_t S_TXQQ5OCTETSr_t;
#define S_TXQQ5OCTETSr_CLR BCM53600_A0_S_TXQQ5OCTETSr_CLR
#define S_TXQQ5OCTETSr_SET BCM53600_A0_S_TXQQ5OCTETSr_SET
#define S_TXQQ5OCTETSr_GET BCM53600_A0_S_TXQQ5OCTETSr_GET
#define READ_S_TXQQ5OCTETSr BCM53600_A0_READ_S_TXQQ5OCTETSr
#define WRITE_S_TXQQ5OCTETSr BCM53600_A0_WRITE_S_TXQQ5OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ5OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ5Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ5PACKETr 0x00005490

#define BCM53600_A0_S_TXQQ5PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ5Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ5PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq5packet[1];
	uint32_t _s_txqq5packet;
} BCM53600_A0_S_TXQQ5PACKETr_t;

#define BCM53600_A0_S_TXQQ5PACKETr_CLR(r) (r).s_txqq5packet[0] = 0
#define BCM53600_A0_S_TXQQ5PACKETr_SET(r,d) (r).s_txqq5packet[0] = d
#define BCM53600_A0_S_TXQQ5PACKETr_GET(r) (r).s_txqq5packet[0]


/*
 * These macros can be used to access S_TXQQ5Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ5PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ5PACKETr,(r._s_txqq5packet),4)
#define BCM53600_A0_WRITE_S_TXQQ5PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ5PACKETr,&(r._s_txqq5packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ5PACKETr BCM53600_A0_S_TXQQ5PACKETr
#define S_TXQQ5PACKETr_SIZE BCM53600_A0_S_TXQQ5PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ5PACKETr_t S_TXQQ5PACKETr_t;
#define S_TXQQ5PACKETr_CLR BCM53600_A0_S_TXQQ5PACKETr_CLR
#define S_TXQQ5PACKETr_SET BCM53600_A0_S_TXQQ5PACKETr_SET
#define S_TXQQ5PACKETr_GET BCM53600_A0_S_TXQQ5PACKETr_GET
#define READ_S_TXQQ5PACKETr BCM53600_A0_READ_S_TXQQ5PACKETr
#define WRITE_S_TXQQ5PACKETr BCM53600_A0_WRITE_S_TXQQ5PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ5PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ6Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q6 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ6OCTETSr 0x000054a0

#define BCM53600_A0_S_TXQQ6OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ6Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ6OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq6octets[2];
	uint32_t _s_txqq6octets;
} BCM53600_A0_S_TXQQ6OCTETSr_t;

#define BCM53600_A0_S_TXQQ6OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq6octets), 0, sizeof(BCM53600_A0_S_TXQQ6OCTETSr_t))
#define BCM53600_A0_S_TXQQ6OCTETSr_SET(r,i,d) (r).s_txqq6octets[i] = d
#define BCM53600_A0_S_TXQQ6OCTETSr_GET(r,i) (r).s_txqq6octets[i]


/*
 * These macros can be used to access S_TXQQ6Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ6OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ6OCTETSr,(r._s_txqq6octets),8)
#define BCM53600_A0_WRITE_S_TXQQ6OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ6OCTETSr,&(r._s_txqq6octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ6OCTETSr BCM53600_A0_S_TXQQ6OCTETSr
#define S_TXQQ6OCTETSr_SIZE BCM53600_A0_S_TXQQ6OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ6OCTETSr_t S_TXQQ6OCTETSr_t;
#define S_TXQQ6OCTETSr_CLR BCM53600_A0_S_TXQQ6OCTETSr_CLR
#define S_TXQQ6OCTETSr_SET BCM53600_A0_S_TXQQ6OCTETSr_SET
#define S_TXQQ6OCTETSr_GET BCM53600_A0_S_TXQQ6OCTETSr_GET
#define READ_S_TXQQ6OCTETSr BCM53600_A0_READ_S_TXQQ6OCTETSr
#define WRITE_S_TXQQ6OCTETSr BCM53600_A0_WRITE_S_TXQQ6OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ6OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ6Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q6 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ6PACKETr 0x0000549c

#define BCM53600_A0_S_TXQQ6PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ6Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ6PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq6packet[1];
	uint32_t _s_txqq6packet;
} BCM53600_A0_S_TXQQ6PACKETr_t;

#define BCM53600_A0_S_TXQQ6PACKETr_CLR(r) (r).s_txqq6packet[0] = 0
#define BCM53600_A0_S_TXQQ6PACKETr_SET(r,d) (r).s_txqq6packet[0] = d
#define BCM53600_A0_S_TXQQ6PACKETr_GET(r) (r).s_txqq6packet[0]


/*
 * These macros can be used to access S_TXQQ6Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ6PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ6PACKETr,(r._s_txqq6packet),4)
#define BCM53600_A0_WRITE_S_TXQQ6PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ6PACKETr,&(r._s_txqq6packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ6PACKETr BCM53600_A0_S_TXQQ6PACKETr
#define S_TXQQ6PACKETr_SIZE BCM53600_A0_S_TXQQ6PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ6PACKETr_t S_TXQQ6PACKETr_t;
#define S_TXQQ6PACKETr_CLR BCM53600_A0_S_TXQQ6PACKETr_CLR
#define S_TXQQ6PACKETr_SET BCM53600_A0_S_TXQQ6PACKETr_SET
#define S_TXQQ6PACKETr_GET BCM53600_A0_S_TXQQ6PACKETr_GET
#define READ_S_TXQQ6PACKETr BCM53600_A0_READ_S_TXQQ6PACKETr
#define WRITE_S_TXQQ6PACKETr BCM53600_A0_WRITE_S_TXQQ6PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ6PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ7Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q7 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ7OCTETSr 0x000054ac

#define BCM53600_A0_S_TXQQ7OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TXQQ7Octets.
 *
 */
typedef union BCM53600_A0_S_TXQQ7OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqq7octets[2];
	uint32_t _s_txqq7octets;
} BCM53600_A0_S_TXQQ7OCTETSr_t;

#define BCM53600_A0_S_TXQQ7OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqq7octets), 0, sizeof(BCM53600_A0_S_TXQQ7OCTETSr_t))
#define BCM53600_A0_S_TXQQ7OCTETSr_SET(r,i,d) (r).s_txqq7octets[i] = d
#define BCM53600_A0_S_TXQQ7OCTETSr_GET(r,i) (r).s_txqq7octets[i]


/*
 * These macros can be used to access S_TXQQ7Octets.
 *
 */
#define BCM53600_A0_READ_S_TXQQ7OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ7OCTETSr,(r._s_txqq7octets),8)
#define BCM53600_A0_WRITE_S_TXQQ7OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ7OCTETSr,&(r._s_txqq7octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ7OCTETSr BCM53600_A0_S_TXQQ7OCTETSr
#define S_TXQQ7OCTETSr_SIZE BCM53600_A0_S_TXQQ7OCTETSr_SIZE
typedef BCM53600_A0_S_TXQQ7OCTETSr_t S_TXQQ7OCTETSr_t;
#define S_TXQQ7OCTETSr_CLR BCM53600_A0_S_TXQQ7OCTETSr_CLR
#define S_TXQQ7OCTETSr_SET BCM53600_A0_S_TXQQ7OCTETSr_SET
#define S_TXQQ7OCTETSr_GET BCM53600_A0_S_TXQQ7OCTETSr_GET
#define READ_S_TXQQ7OCTETSr BCM53600_A0_READ_S_TXQQ7OCTETSr
#define WRITE_S_TXQQ7OCTETSr BCM53600_A0_WRITE_S_TXQQ7OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ7OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQ7Packet
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ-Q7 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQ7PACKETr 0x000054a8

#define BCM53600_A0_S_TXQQ7PACKETr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQ7Packet.
 *
 */
typedef union BCM53600_A0_S_TXQQ7PACKETr_s {
	uint32_t v[1];
	uint32_t s_txqq7packet[1];
	uint32_t _s_txqq7packet;
} BCM53600_A0_S_TXQQ7PACKETr_t;

#define BCM53600_A0_S_TXQQ7PACKETr_CLR(r) (r).s_txqq7packet[0] = 0
#define BCM53600_A0_S_TXQQ7PACKETr_SET(r,d) (r).s_txqq7packet[0] = d
#define BCM53600_A0_S_TXQQ7PACKETr_GET(r) (r).s_txqq7packet[0]


/*
 * These macros can be used to access S_TXQQ7Packet.
 *
 */
#define BCM53600_A0_READ_S_TXQQ7PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQ7PACKETr,(r._s_txqq7packet),4)
#define BCM53600_A0_WRITE_S_TXQQ7PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQ7PACKETr,&(r._s_txqq7packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQ7PACKETr BCM53600_A0_S_TXQQ7PACKETr
#define S_TXQQ7PACKETr_SIZE BCM53600_A0_S_TXQQ7PACKETr_SIZE
typedef BCM53600_A0_S_TXQQ7PACKETr_t S_TXQQ7PACKETr_t;
#define S_TXQQ7PACKETr_CLR BCM53600_A0_S_TXQQ7PACKETr_CLR
#define S_TXQQ7PACKETr_SET BCM53600_A0_S_TXQQ7PACKETr_SET
#define S_TXQQ7PACKETr_GET BCM53600_A0_S_TXQQ7PACKETr_GET
#define READ_S_TXQQ7PACKETr BCM53600_A0_READ_S_TXQQ7PACKETr
#define WRITE_S_TXQQ7PACKETr BCM53600_A0_WRITE_S_TXQQ7PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQ7PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQSel0CongestionDrop
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ_Q Select 0 Congestion Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr 0x000054b4

#define BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQSel0CongestionDrop.
 *
 */
typedef union BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_s {
	uint32_t v[1];
	uint32_t s_txqqsel0congestiondrop[1];
	uint32_t _s_txqqsel0congestiondrop;
} BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_t;

#define BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_CLR(r) (r).s_txqqsel0congestiondrop[0] = 0
#define BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_SET(r,d) (r).s_txqqsel0congestiondrop[0] = d
#define BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_GET(r) (r).s_txqqsel0congestiondrop[0]


/*
 * These macros can be used to access S_TXQQSel0CongestionDrop.
 *
 */
#define BCM53600_A0_READ_S_TXQQSEL0CONGESTIONDROPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr,(r._s_txqqsel0congestiondrop),4)
#define BCM53600_A0_WRITE_S_TXQQSEL0CONGESTIONDROPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr,&(r._s_txqqsel0congestiondrop),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQSEL0CONGESTIONDROPr BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr
#define S_TXQQSEL0CONGESTIONDROPr_SIZE BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_SIZE
typedef BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_t S_TXQQSEL0CONGESTIONDROPr_t;
#define S_TXQQSEL0CONGESTIONDROPr_CLR BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_CLR
#define S_TXQQSEL0CONGESTIONDROPr_SET BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_SET
#define S_TXQQSEL0CONGESTIONDROPr_GET BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr_GET
#define READ_S_TXQQSEL0CONGESTIONDROPr BCM53600_A0_READ_S_TXQQSEL0CONGESTIONDROPr
#define WRITE_S_TXQQSEL0CONGESTIONDROPr BCM53600_A0_WRITE_S_TXQQSEL0CONGESTIONDROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQSEL0CONGESTIONDROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TXQQSel1CongestionDrop
 * BLOCKS:   SYS
 * DESC:     Snapshot TXQ_Q Select 1 Congestion Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr 0x000054b8

#define BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_SIZE 4

/*
 * This structure should be used to declare and program S_TXQQSel1CongestionDrop.
 *
 */
typedef union BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_s {
	uint32_t v[1];
	uint32_t s_txqqsel1congestiondrop[1];
	uint32_t _s_txqqsel1congestiondrop;
} BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_t;

#define BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_CLR(r) (r).s_txqqsel1congestiondrop[0] = 0
#define BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_SET(r,d) (r).s_txqqsel1congestiondrop[0] = d
#define BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_GET(r) (r).s_txqqsel1congestiondrop[0]


/*
 * These macros can be used to access S_TXQQSel1CongestionDrop.
 *
 */
#define BCM53600_A0_READ_S_TXQQSEL1CONGESTIONDROPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr,(r._s_txqqsel1congestiondrop),4)
#define BCM53600_A0_WRITE_S_TXQQSEL1CONGESTIONDROPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr,&(r._s_txqqsel1congestiondrop),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQQSEL1CONGESTIONDROPr BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr
#define S_TXQQSEL1CONGESTIONDROPr_SIZE BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_SIZE
typedef BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_t S_TXQQSEL1CONGESTIONDROPr_t;
#define S_TXQQSEL1CONGESTIONDROPr_CLR BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_CLR
#define S_TXQQSEL1CONGESTIONDROPr_SET BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_SET
#define S_TXQQSEL1CONGESTIONDROPr_GET BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr_GET
#define READ_S_TXQQSEL1CONGESTIONDROPr BCM53600_A0_READ_S_TXQQSEL1CONGESTIONDROPr
#define WRITE_S_TXQQSEL1CONGESTIONDROPr BCM53600_A0_WRITE_S_TXQQSEL1CONGESTIONDROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXQQSEL1CONGESTIONDROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXBROADCASTPKTSr 0x0000542c

#define BCM53600_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 *
 */
typedef union BCM53600_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM53600_A0_S_TXBROADCASTPKTSr_t;

#define BCM53600_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM53600_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM53600_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]


/*
 * These macros can be used to access S_TxBroadcastPkts.
 *
 */
#define BCM53600_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM53600_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM53600_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM53600_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM53600_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM53600_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM53600_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM53600_A0_S_TXBROADCASTPKTSr_GET
#define READ_S_TXBROADCASTPKTSr BCM53600_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM53600_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Collisions Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXCOLLISIONSr 0x00005438

#define BCM53600_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 *
 */
typedef union BCM53600_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM53600_A0_S_TXCOLLISIONSr_t;

#define BCM53600_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM53600_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM53600_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]


/*
 * These macros can be used to access S_TxCollisions.
 *
 */
#define BCM53600_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM53600_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM53600_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM53600_A0_S_TXCOLLISIONSr_SIZE
typedef BCM53600_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM53600_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM53600_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM53600_A0_S_TXCOLLISIONSr_GET
#define READ_S_TXCOLLISIONSr BCM53600_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM53600_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Snapshot Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXDEFERREDTRANSMITr 0x00005444

#define BCM53600_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 *
 */
typedef union BCM53600_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM53600_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM53600_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM53600_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM53600_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]


/*
 * These macros can be used to access S_TxDeferredTransmit.
 *
 */
#define BCM53600_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM53600_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM53600_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM53600_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM53600_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM53600_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM53600_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM53600_A0_S_TXDEFERREDTRANSMITr_GET
#define READ_S_TXDEFERREDTRANSMITr BCM53600_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM53600_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Snapshot Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXEXCESSIVECOLLISIONr 0x0000544c

#define BCM53600_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 *
 */
typedef union BCM53600_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM53600_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM53600_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM53600_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM53600_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]


/*
 * These macros can be used to access S_TxExcessiveCollision.
 *
 */
#define BCM53600_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM53600_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM53600_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM53600_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53600_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM53600_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM53600_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM53600_A0_S_TXEXCESSIVECOLLISIONr_GET
#define READ_S_TXEXCESSIVECOLLISIONr BCM53600_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM53600_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Snapshot Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXLATECOLLISIONr 0x00005448

#define BCM53600_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 *
 */
typedef union BCM53600_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM53600_A0_S_TXLATECOLLISIONr_t;

#define BCM53600_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM53600_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM53600_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]


/*
 * These macros can be used to access S_TxLateCollision.
 *
 */
#define BCM53600_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM53600_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM53600_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM53600_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM53600_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM53600_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM53600_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM53600_A0_S_TXLATECOLLISIONr_GET
#define READ_S_TXLATECOLLISIONr BCM53600_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM53600_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXMULTICASTPKTSr 0x00005430

#define BCM53600_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 *
 */
typedef union BCM53600_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM53600_A0_S_TXMULTICASTPKTSr_t;

#define BCM53600_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM53600_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM53600_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]


/*
 * These macros can be used to access S_TxMulticastPkts.
 *
 */
#define BCM53600_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM53600_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM53600_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM53600_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM53600_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM53600_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM53600_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM53600_A0_S_TXMULTICASTPKTSr_GET
#define READ_S_TXMULTICASTPKTSr BCM53600_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM53600_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxMultipleCollisions
 * BLOCKS:   SYS
 * DESC:     Snapshot MultipleCollisions Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXMULTIPLECOLLISIONSr 0x00005440

#define BCM53600_A0_S_TXMULTIPLECOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollisions.
 *
 */
typedef union BCM53600_A0_S_TXMULTIPLECOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollisions[1];
	uint32_t _s_txmultiplecollisions;
} BCM53600_A0_S_TXMULTIPLECOLLISIONSr_t;

#define BCM53600_A0_S_TXMULTIPLECOLLISIONSr_CLR(r) (r).s_txmultiplecollisions[0] = 0
#define BCM53600_A0_S_TXMULTIPLECOLLISIONSr_SET(r,d) (r).s_txmultiplecollisions[0] = d
#define BCM53600_A0_S_TXMULTIPLECOLLISIONSr_GET(r) (r).s_txmultiplecollisions[0]


/*
 * These macros can be used to access S_TxMultipleCollisions.
 *
 */
#define BCM53600_A0_READ_S_TXMULTIPLECOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXMULTIPLECOLLISIONSr,(r._s_txmultiplecollisions),4)
#define BCM53600_A0_WRITE_S_TXMULTIPLECOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXMULTIPLECOLLISIONSr,&(r._s_txmultiplecollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONSr BCM53600_A0_S_TXMULTIPLECOLLISIONSr
#define S_TXMULTIPLECOLLISIONSr_SIZE BCM53600_A0_S_TXMULTIPLECOLLISIONSr_SIZE
typedef BCM53600_A0_S_TXMULTIPLECOLLISIONSr_t S_TXMULTIPLECOLLISIONSr_t;
#define S_TXMULTIPLECOLLISIONSr_CLR BCM53600_A0_S_TXMULTIPLECOLLISIONSr_CLR
#define S_TXMULTIPLECOLLISIONSr_SET BCM53600_A0_S_TXMULTIPLECOLLISIONSr_SET
#define S_TXMULTIPLECOLLISIONSr_GET BCM53600_A0_S_TXMULTIPLECOLLISIONSr_GET
#define READ_S_TXMULTIPLECOLLISIONSr BCM53600_A0_READ_S_TXMULTIPLECOLLISIONSr
#define WRITE_S_TXMULTIPLECOLLISIONSr BCM53600_A0_WRITE_S_TXMULTIPLECOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXMULTIPLECOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXOCTETSr 0x0000541c

#define BCM53600_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 *
 */
typedef union BCM53600_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM53600_A0_S_TXOCTETSr_t;

#define BCM53600_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM53600_A0_S_TXOCTETSr_t))
#define BCM53600_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM53600_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]


/*
 * These macros can be used to access S_TxOctets.
 *
 */
#define BCM53600_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM53600_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM53600_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM53600_A0_S_TXOCTETSr_SIZE
typedef BCM53600_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM53600_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM53600_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM53600_A0_S_TXOCTETSr_GET
#define READ_S_TXOCTETSr BCM53600_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM53600_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Pause Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPAUSEPKTSr 0x00005428

#define BCM53600_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 *
 */
typedef union BCM53600_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM53600_A0_S_TXPAUSEPKTSr_t;

#define BCM53600_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM53600_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM53600_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]


/*
 * These macros can be used to access S_TxPausePkts.
 *
 */
#define BCM53600_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM53600_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM53600_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM53600_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM53600_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM53600_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM53600_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM53600_A0_S_TXPAUSEPKTSr_GET
#define READ_S_TXPAUSEPKTSr BCM53600_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM53600_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPkts1024toMaxPkt
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx 1024 Bytes Octets to Standard Maximum Size Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPKTS1024TOMAXPKTr 0x00005414

#define BCM53600_A0_S_TXPKTS1024TOMAXPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPkts1024toMaxPkt.
 *
 */
typedef union BCM53600_A0_S_TXPKTS1024TOMAXPKTr_s {
	uint32_t v[1];
	uint32_t s_txpkts1024tomaxpkt[1];
	uint32_t _s_txpkts1024tomaxpkt;
} BCM53600_A0_S_TXPKTS1024TOMAXPKTr_t;

#define BCM53600_A0_S_TXPKTS1024TOMAXPKTr_CLR(r) (r).s_txpkts1024tomaxpkt[0] = 0
#define BCM53600_A0_S_TXPKTS1024TOMAXPKTr_SET(r,d) (r).s_txpkts1024tomaxpkt[0] = d
#define BCM53600_A0_S_TXPKTS1024TOMAXPKTr_GET(r) (r).s_txpkts1024tomaxpkt[0]


/*
 * These macros can be used to access S_TxPkts1024toMaxPkt.
 *
 */
#define BCM53600_A0_READ_S_TXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPKTS1024TOMAXPKTr,(r._s_txpkts1024tomaxpkt),4)
#define BCM53600_A0_WRITE_S_TXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPKTS1024TOMAXPKTr,&(r._s_txpkts1024tomaxpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPKTS1024TOMAXPKTr BCM53600_A0_S_TXPKTS1024TOMAXPKTr
#define S_TXPKTS1024TOMAXPKTr_SIZE BCM53600_A0_S_TXPKTS1024TOMAXPKTr_SIZE
typedef BCM53600_A0_S_TXPKTS1024TOMAXPKTr_t S_TXPKTS1024TOMAXPKTr_t;
#define S_TXPKTS1024TOMAXPKTr_CLR BCM53600_A0_S_TXPKTS1024TOMAXPKTr_CLR
#define S_TXPKTS1024TOMAXPKTr_SET BCM53600_A0_S_TXPKTS1024TOMAXPKTr_SET
#define S_TXPKTS1024TOMAXPKTr_GET BCM53600_A0_S_TXPKTS1024TOMAXPKTr_GET
#define READ_S_TXPKTS1024TOMAXPKTr BCM53600_A0_READ_S_TXPKTS1024TOMAXPKTr
#define WRITE_S_TXPKTS1024TOMAXPKTr BCM53600_A0_WRITE_S_TXPKTS1024TOMAXPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPKTS1024TOMAXPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPKTS128TO255OCTETSr 0x00005408

#define BCM53600_A0_S_TXPKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPkts128to255Octets.
 *
 */
typedef union BCM53600_A0_S_TXPKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_txpkts128to255octets[1];
	uint32_t _s_txpkts128to255octets;
} BCM53600_A0_S_TXPKTS128TO255OCTETSr_t;

#define BCM53600_A0_S_TXPKTS128TO255OCTETSr_CLR(r) (r).s_txpkts128to255octets[0] = 0
#define BCM53600_A0_S_TXPKTS128TO255OCTETSr_SET(r,d) (r).s_txpkts128to255octets[0] = d
#define BCM53600_A0_S_TXPKTS128TO255OCTETSr_GET(r) (r).s_txpkts128to255octets[0]


/*
 * These macros can be used to access S_TxPkts128to255Octets.
 *
 */
#define BCM53600_A0_READ_S_TXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPKTS128TO255OCTETSr,(r._s_txpkts128to255octets),4)
#define BCM53600_A0_WRITE_S_TXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPKTS128TO255OCTETSr,&(r._s_txpkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPKTS128TO255OCTETSr BCM53600_A0_S_TXPKTS128TO255OCTETSr
#define S_TXPKTS128TO255OCTETSr_SIZE BCM53600_A0_S_TXPKTS128TO255OCTETSr_SIZE
typedef BCM53600_A0_S_TXPKTS128TO255OCTETSr_t S_TXPKTS128TO255OCTETSr_t;
#define S_TXPKTS128TO255OCTETSr_CLR BCM53600_A0_S_TXPKTS128TO255OCTETSr_CLR
#define S_TXPKTS128TO255OCTETSr_SET BCM53600_A0_S_TXPKTS128TO255OCTETSr_SET
#define S_TXPKTS128TO255OCTETSr_GET BCM53600_A0_S_TXPKTS128TO255OCTETSr_GET
#define READ_S_TXPKTS128TO255OCTETSr BCM53600_A0_READ_S_TXPKTS128TO255OCTETSr
#define WRITE_S_TXPKTS128TO255OCTETSr BCM53600_A0_WRITE_S_TXPKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPKTS256TO511OCTETSr 0x0000540c

#define BCM53600_A0_S_TXPKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPkts256to511Octets.
 *
 */
typedef union BCM53600_A0_S_TXPKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_txpkts256to511octets[1];
	uint32_t _s_txpkts256to511octets;
} BCM53600_A0_S_TXPKTS256TO511OCTETSr_t;

#define BCM53600_A0_S_TXPKTS256TO511OCTETSr_CLR(r) (r).s_txpkts256to511octets[0] = 0
#define BCM53600_A0_S_TXPKTS256TO511OCTETSr_SET(r,d) (r).s_txpkts256to511octets[0] = d
#define BCM53600_A0_S_TXPKTS256TO511OCTETSr_GET(r) (r).s_txpkts256to511octets[0]


/*
 * These macros can be used to access S_TxPkts256to511Octets.
 *
 */
#define BCM53600_A0_READ_S_TXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPKTS256TO511OCTETSr,(r._s_txpkts256to511octets),4)
#define BCM53600_A0_WRITE_S_TXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPKTS256TO511OCTETSr,&(r._s_txpkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPKTS256TO511OCTETSr BCM53600_A0_S_TXPKTS256TO511OCTETSr
#define S_TXPKTS256TO511OCTETSr_SIZE BCM53600_A0_S_TXPKTS256TO511OCTETSr_SIZE
typedef BCM53600_A0_S_TXPKTS256TO511OCTETSr_t S_TXPKTS256TO511OCTETSr_t;
#define S_TXPKTS256TO511OCTETSr_CLR BCM53600_A0_S_TXPKTS256TO511OCTETSr_CLR
#define S_TXPKTS256TO511OCTETSr_SET BCM53600_A0_S_TXPKTS256TO511OCTETSr_SET
#define S_TXPKTS256TO511OCTETSr_GET BCM53600_A0_S_TXPKTS256TO511OCTETSr_GET
#define READ_S_TXPKTS256TO511OCTETSr BCM53600_A0_READ_S_TXPKTS256TO511OCTETSr
#define WRITE_S_TXPKTS256TO511OCTETSr BCM53600_A0_WRITE_S_TXPKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPKTS512TO1023OCTETSr 0x00005410

#define BCM53600_A0_S_TXPKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPkts512to1023Octets.
 *
 */
typedef union BCM53600_A0_S_TXPKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_txpkts512to1023octets[1];
	uint32_t _s_txpkts512to1023octets;
} BCM53600_A0_S_TXPKTS512TO1023OCTETSr_t;

#define BCM53600_A0_S_TXPKTS512TO1023OCTETSr_CLR(r) (r).s_txpkts512to1023octets[0] = 0
#define BCM53600_A0_S_TXPKTS512TO1023OCTETSr_SET(r,d) (r).s_txpkts512to1023octets[0] = d
#define BCM53600_A0_S_TXPKTS512TO1023OCTETSr_GET(r) (r).s_txpkts512to1023octets[0]


/*
 * These macros can be used to access S_TxPkts512to1023Octets.
 *
 */
#define BCM53600_A0_READ_S_TXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPKTS512TO1023OCTETSr,(r._s_txpkts512to1023octets),4)
#define BCM53600_A0_WRITE_S_TXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPKTS512TO1023OCTETSr,&(r._s_txpkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPKTS512TO1023OCTETSr BCM53600_A0_S_TXPKTS512TO1023OCTETSr
#define S_TXPKTS512TO1023OCTETSr_SIZE BCM53600_A0_S_TXPKTS512TO1023OCTETSr_SIZE
typedef BCM53600_A0_S_TXPKTS512TO1023OCTETSr_t S_TXPKTS512TO1023OCTETSr_t;
#define S_TXPKTS512TO1023OCTETSr_CLR BCM53600_A0_S_TXPKTS512TO1023OCTETSr_CLR
#define S_TXPKTS512TO1023OCTETSr_SET BCM53600_A0_S_TXPKTS512TO1023OCTETSr_SET
#define S_TXPKTS512TO1023OCTETSr_GET BCM53600_A0_S_TXPKTS512TO1023OCTETSr_GET
#define READ_S_TXPKTS512TO1023OCTETSr BCM53600_A0_READ_S_TXPKTS512TO1023OCTETSr
#define WRITE_S_TXPKTS512TO1023OCTETSr BCM53600_A0_WRITE_S_TXPKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPkts64Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPKTS64OCTETSr 0x00005400

#define BCM53600_A0_S_TXPKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPkts64Octets.
 *
 */
typedef union BCM53600_A0_S_TXPKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_txpkts64octets[1];
	uint32_t _s_txpkts64octets;
} BCM53600_A0_S_TXPKTS64OCTETSr_t;

#define BCM53600_A0_S_TXPKTS64OCTETSr_CLR(r) (r).s_txpkts64octets[0] = 0
#define BCM53600_A0_S_TXPKTS64OCTETSr_SET(r,d) (r).s_txpkts64octets[0] = d
#define BCM53600_A0_S_TXPKTS64OCTETSr_GET(r) (r).s_txpkts64octets[0]


/*
 * These macros can be used to access S_TxPkts64Octets.
 *
 */
#define BCM53600_A0_READ_S_TXPKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPKTS64OCTETSr,(r._s_txpkts64octets),4)
#define BCM53600_A0_WRITE_S_TXPKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPKTS64OCTETSr,&(r._s_txpkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPKTS64OCTETSr BCM53600_A0_S_TXPKTS64OCTETSr
#define S_TXPKTS64OCTETSr_SIZE BCM53600_A0_S_TXPKTS64OCTETSr_SIZE
typedef BCM53600_A0_S_TXPKTS64OCTETSr_t S_TXPKTS64OCTETSr_t;
#define S_TXPKTS64OCTETSr_CLR BCM53600_A0_S_TXPKTS64OCTETSr_CLR
#define S_TXPKTS64OCTETSr_SET BCM53600_A0_S_TXPKTS64OCTETSr_SET
#define S_TXPKTS64OCTETSr_GET BCM53600_A0_S_TXPKTS64OCTETSr_GET
#define READ_S_TXPKTS64OCTETSr BCM53600_A0_READ_S_TXPKTS64OCTETSr
#define WRITE_S_TXPKTS64OCTETSr BCM53600_A0_WRITE_S_TXPKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPKTS65TO127OCTETSr 0x00005404

#define BCM53600_A0_S_TXPKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPkts65to127Octets.
 *
 */
typedef union BCM53600_A0_S_TXPKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_txpkts65to127octets[1];
	uint32_t _s_txpkts65to127octets;
} BCM53600_A0_S_TXPKTS65TO127OCTETSr_t;

#define BCM53600_A0_S_TXPKTS65TO127OCTETSr_CLR(r) (r).s_txpkts65to127octets[0] = 0
#define BCM53600_A0_S_TXPKTS65TO127OCTETSr_SET(r,d) (r).s_txpkts65to127octets[0] = d
#define BCM53600_A0_S_TXPKTS65TO127OCTETSr_GET(r) (r).s_txpkts65to127octets[0]


/*
 * These macros can be used to access S_TxPkts65to127Octets.
 *
 */
#define BCM53600_A0_READ_S_TXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPKTS65TO127OCTETSr,(r._s_txpkts65to127octets),4)
#define BCM53600_A0_WRITE_S_TXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPKTS65TO127OCTETSr,&(r._s_txpkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPKTS65TO127OCTETSr BCM53600_A0_S_TXPKTS65TO127OCTETSr
#define S_TXPKTS65TO127OCTETSr_SIZE BCM53600_A0_S_TXPKTS65TO127OCTETSr_SIZE
typedef BCM53600_A0_S_TXPKTS65TO127OCTETSr_t S_TXPKTS65TO127OCTETSr_t;
#define S_TXPKTS65TO127OCTETSr_CLR BCM53600_A0_S_TXPKTS65TO127OCTETSr_CLR
#define S_TXPKTS65TO127OCTETSr_SET BCM53600_A0_S_TXPKTS65TO127OCTETSr_SET
#define S_TXPKTS65TO127OCTETSr_GET BCM53600_A0_S_TXPKTS65TO127OCTETSr_GET
#define READ_S_TXPKTS65TO127OCTETSr BCM53600_A0_READ_S_TXPKTS65TO127OCTETSr
#define WRITE_S_TXPKTS65TO127OCTETSr BCM53600_A0_WRITE_S_TXPKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxPortCongestionDrop
 * BLOCKS:   SYS
 * DESC:     Snapshot Port Congestion Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXPORTCONGESTIONDROPr 0x00005450

#define BCM53600_A0_S_TXPORTCONGESTIONDROPr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPortCongestionDrop.
 *
 */
typedef union BCM53600_A0_S_TXPORTCONGESTIONDROPr_s {
	uint32_t v[1];
	uint32_t s_txportcongestiondrop[1];
	uint32_t _s_txportcongestiondrop;
} BCM53600_A0_S_TXPORTCONGESTIONDROPr_t;

#define BCM53600_A0_S_TXPORTCONGESTIONDROPr_CLR(r) (r).s_txportcongestiondrop[0] = 0
#define BCM53600_A0_S_TXPORTCONGESTIONDROPr_SET(r,d) (r).s_txportcongestiondrop[0] = d
#define BCM53600_A0_S_TXPORTCONGESTIONDROPr_GET(r) (r).s_txportcongestiondrop[0]


/*
 * These macros can be used to access S_TxPortCongestionDrop.
 *
 */
#define BCM53600_A0_READ_S_TXPORTCONGESTIONDROPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXPORTCONGESTIONDROPr,(r._s_txportcongestiondrop),4)
#define BCM53600_A0_WRITE_S_TXPORTCONGESTIONDROPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXPORTCONGESTIONDROPr,&(r._s_txportcongestiondrop),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPORTCONGESTIONDROPr BCM53600_A0_S_TXPORTCONGESTIONDROPr
#define S_TXPORTCONGESTIONDROPr_SIZE BCM53600_A0_S_TXPORTCONGESTIONDROPr_SIZE
typedef BCM53600_A0_S_TXPORTCONGESTIONDROPr_t S_TXPORTCONGESTIONDROPr_t;
#define S_TXPORTCONGESTIONDROPr_CLR BCM53600_A0_S_TXPORTCONGESTIONDROPr_CLR
#define S_TXPORTCONGESTIONDROPr_SET BCM53600_A0_S_TXPORTCONGESTIONDROPr_SET
#define S_TXPORTCONGESTIONDROPr_GET BCM53600_A0_S_TXPORTCONGESTIONDROPr_GET
#define READ_S_TXPORTCONGESTIONDROPr BCM53600_A0_READ_S_TXPORTCONGESTIONDROPr
#define WRITE_S_TXPORTCONGESTIONDROPr BCM53600_A0_WRITE_S_TXPORTCONGESTIONDROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXPORTCONGESTIONDROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxSingleCollisions
 * BLOCKS:   SYS
 * DESC:     Snapshot SingleCollisions Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXSINGLECOLLISIONSr 0x0000543c

#define BCM53600_A0_S_TXSINGLECOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollisions.
 *
 */
typedef union BCM53600_A0_S_TXSINGLECOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollisions[1];
	uint32_t _s_txsinglecollisions;
} BCM53600_A0_S_TXSINGLECOLLISIONSr_t;

#define BCM53600_A0_S_TXSINGLECOLLISIONSr_CLR(r) (r).s_txsinglecollisions[0] = 0
#define BCM53600_A0_S_TXSINGLECOLLISIONSr_SET(r,d) (r).s_txsinglecollisions[0] = d
#define BCM53600_A0_S_TXSINGLECOLLISIONSr_GET(r) (r).s_txsinglecollisions[0]


/*
 * These macros can be used to access S_TxSingleCollisions.
 *
 */
#define BCM53600_A0_READ_S_TXSINGLECOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXSINGLECOLLISIONSr,(r._s_txsinglecollisions),4)
#define BCM53600_A0_WRITE_S_TXSINGLECOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXSINGLECOLLISIONSr,&(r._s_txsinglecollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONSr BCM53600_A0_S_TXSINGLECOLLISIONSr
#define S_TXSINGLECOLLISIONSr_SIZE BCM53600_A0_S_TXSINGLECOLLISIONSr_SIZE
typedef BCM53600_A0_S_TXSINGLECOLLISIONSr_t S_TXSINGLECOLLISIONSr_t;
#define S_TXSINGLECOLLISIONSr_CLR BCM53600_A0_S_TXSINGLECOLLISIONSr_CLR
#define S_TXSINGLECOLLISIONSr_SET BCM53600_A0_S_TXSINGLECOLLISIONSr_SET
#define S_TXSINGLECOLLISIONSr_GET BCM53600_A0_S_TXSINGLECOLLISIONSr_GET
#define READ_S_TXSINGLECOLLISIONSr BCM53600_A0_READ_S_TXSINGLECOLLISIONSr
#define WRITE_S_TXSINGLECOLLISIONSr BCM53600_A0_WRITE_S_TXSINGLECOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXSINGLECOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TXUNICASTPKTSr 0x00005434

#define BCM53600_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 *
 */
typedef union BCM53600_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM53600_A0_S_TXUNICASTPKTSr_t;

#define BCM53600_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM53600_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM53600_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]


/*
 * These macros can be used to access S_TxUnicastPkts.
 *
 */
#define BCM53600_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM53600_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM53600_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM53600_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM53600_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM53600_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM53600_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM53600_A0_S_TXUNICASTPKTSr_GET
#define READ_S_TXUNICASTPKTSr BCM53600_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM53600_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  S_Tx_Jumbo_Packet_Counter
 * BLOCKS:   SYS
 * DESC:     Snapshot Tx Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr 0x00005418

#define BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program S_Tx_Jumbo_Packet_Counter.
 *
 */
typedef union BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_s {
	uint32_t v[1];
	uint32_t s_tx_jumbo_packet_counter[1];
	uint32_t _s_tx_jumbo_packet_counter;
} BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_t;

#define BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_CLR(r) (r).s_tx_jumbo_packet_counter[0] = 0
#define BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_SET(r,d) (r).s_tx_jumbo_packet_counter[0] = d
#define BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_GET(r) (r).s_tx_jumbo_packet_counter[0]


/*
 * These macros can be used to access S_Tx_Jumbo_Packet_Counter.
 *
 */
#define BCM53600_A0_READ_S_TX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_read(u,BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr,(r._s_tx_jumbo_packet_counter),4)
#define BCM53600_A0_WRITE_S_TX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_write(u,BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr,&(r._s_tx_jumbo_packet_counter),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TX_JUMBO_PACKET_COUNTERr BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr
#define S_TX_JUMBO_PACKET_COUNTERr_SIZE BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_SIZE
typedef BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_t S_TX_JUMBO_PACKET_COUNTERr_t;
#define S_TX_JUMBO_PACKET_COUNTERr_CLR BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_CLR
#define S_TX_JUMBO_PACKET_COUNTERr_SET BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_SET
#define S_TX_JUMBO_PACKET_COUNTERr_GET BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr_GET
#define READ_S_TX_JUMBO_PACKET_COUNTERr BCM53600_A0_READ_S_TX_JUMBO_PACKET_COUNTERr
#define WRITE_S_TX_JUMBO_PACKET_COUNTERr BCM53600_A0_WRITE_S_TX_JUMBO_PACKET_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_S_TX_JUMBO_PACKET_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     TC to COS Mapping Register
 * SIZE:     48
 * FIELDS:
 *     TC_0000_COS      TC 0000 mapping to COS queue ID.
 *     TC_0001_COS      TC 0001 mapping to COS queue ID.
 *     TC_0010_COS      TC 0010 mapping to COS queue ID.
 *     TC_0011_COS      TC 0011 mapping to COS queue ID.
 *     TC_0100_COS      TC 0100 mapping to COS queue ID.
 *     TC_0101_COS      TC 0101 mapping to COS queue ID.
 *     TC_0110_COS      TC 0110 mapping to COS queue ID.
 *     TC_0111_COS      TC 0111 mapping to COS queue ID.
 *     TC_1000_COS      TC 1000 mapping to COS queue ID.
 *     TC_1001_COS      TC 1001 mapping to COS queue ID.
 *     TC_1010_COS      TC 1010 mapping to COS queue ID.
 *     TC_1011_COS      TC 1011 mapping to COS queue ID.
 *     TC_1100_COS      TC 1100 mapping to COS queue ID.
 *     TC_1101_COS      TC 1101 mapping to COS queue ID.
 *     TC_1110_COS      TC 1110 mapping to COS queue ID.
 *     TC_1111_COS      TC 1111 mapping to COS queue ID.
 *
 ******************************************************************************/
#define BCM53600_A0_TC2COS_MAPr 0x00003030

#define BCM53600_A0_TC2COS_MAPr_SIZE 6

/*
 * This structure should be used to declare and program TC2COS_MAP.
 *
 */
typedef union BCM53600_A0_TC2COS_MAPr_s {
	uint32_t v[2];
	uint32_t tc2cos_map[2];
	uint32_t _tc2cos_map;
} BCM53600_A0_TC2COS_MAPr_t;

#define BCM53600_A0_TC2COS_MAPr_CLR(r) CDK_MEMSET(&((r)._tc2cos_map), 0, sizeof(BCM53600_A0_TC2COS_MAPr_t))
#define BCM53600_A0_TC2COS_MAPr_SET(r,i,d) (r).tc2cos_map[i] = d
#define BCM53600_A0_TC2COS_MAPr_GET(r,i) (r).tc2cos_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TC2COS_MAPr_TC_0000_COSf_GET(r) (((r).tc2cos_map[0]) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0000_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53600_A0_TC2COS_MAPr_TC_0001_COSf_GET(r) ((((r).tc2cos_map[0]) >> 3) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0001_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53600_A0_TC2COS_MAPr_TC_0010_COSf_GET(r) ((((r).tc2cos_map[0]) >> 6) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0010_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53600_A0_TC2COS_MAPr_TC_0011_COSf_GET(r) ((((r).tc2cos_map[0]) >> 9) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0011_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53600_A0_TC2COS_MAPr_TC_0100_COSf_GET(r) ((((r).tc2cos_map[0]) >> 12) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0100_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53600_A0_TC2COS_MAPr_TC_0101_COSf_GET(r) ((((r).tc2cos_map[0]) >> 15) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0101_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53600_A0_TC2COS_MAPr_TC_0110_COSf_GET(r) ((((r).tc2cos_map[0]) >> 18) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0110_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53600_A0_TC2COS_MAPr_TC_0111_COSf_GET(r) ((((r).tc2cos_map[0]) >> 21) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_0111_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53600_A0_TC2COS_MAPr_TC_1000_COSf_GET(r) ((((r).tc2cos_map[0]) >> 24) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1000_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53600_A0_TC2COS_MAPr_TC_1001_COSf_GET(r) ((((r).tc2cos_map[0]) >> 27) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1001_COSf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53600_A0_TC2COS_MAPr_TC_1010_COSf_GET(r) cdk_field32_get((r).tc2cos_map,30,32)
#define BCM53600_A0_TC2COS_MAPr_TC_1010_COSf_SET(r,f) cdk_field32_set((r).tc2cos_map,30,32,f)
#define BCM53600_A0_TC2COS_MAPr_TC_1011_COSf_GET(r) ((((r).tc2cos_map[1]) >> 1) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1011_COSf_SET(r,f) (r).tc2cos_map[1]=(((r).tc2cos_map[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53600_A0_TC2COS_MAPr_TC_1100_COSf_GET(r) ((((r).tc2cos_map[1]) >> 4) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1100_COSf_SET(r,f) (r).tc2cos_map[1]=(((r).tc2cos_map[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53600_A0_TC2COS_MAPr_TC_1101_COSf_GET(r) ((((r).tc2cos_map[1]) >> 7) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1101_COSf_SET(r,f) (r).tc2cos_map[1]=(((r).tc2cos_map[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53600_A0_TC2COS_MAPr_TC_1110_COSf_GET(r) ((((r).tc2cos_map[1]) >> 10) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1110_COSf_SET(r,f) (r).tc2cos_map[1]=(((r).tc2cos_map[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53600_A0_TC2COS_MAPr_TC_1111_COSf_GET(r) ((((r).tc2cos_map[1]) >> 13) & 0x7)
#define BCM53600_A0_TC2COS_MAPr_TC_1111_COSf_SET(r,f) (r).tc2cos_map[1]=(((r).tc2cos_map[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TC2COS_MAP.
 *
 */
#define BCM53600_A0_READ_TC2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TC2COS_MAPr,(r._tc2cos_map),6)
#define BCM53600_A0_WRITE_TC2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TC2COS_MAPr,&(r._tc2cos_map),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TC2COS_MAPr BCM53600_A0_TC2COS_MAPr
#define TC2COS_MAPr_SIZE BCM53600_A0_TC2COS_MAPr_SIZE
typedef BCM53600_A0_TC2COS_MAPr_t TC2COS_MAPr_t;
#define TC2COS_MAPr_CLR BCM53600_A0_TC2COS_MAPr_CLR
#define TC2COS_MAPr_SET BCM53600_A0_TC2COS_MAPr_SET
#define TC2COS_MAPr_GET BCM53600_A0_TC2COS_MAPr_GET
#define TC2COS_MAPr_TC_0000_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0000_COSf_GET
#define TC2COS_MAPr_TC_0000_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0000_COSf_SET
#define TC2COS_MAPr_TC_0001_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0001_COSf_GET
#define TC2COS_MAPr_TC_0001_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0001_COSf_SET
#define TC2COS_MAPr_TC_0010_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0010_COSf_GET
#define TC2COS_MAPr_TC_0010_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0010_COSf_SET
#define TC2COS_MAPr_TC_0011_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0011_COSf_GET
#define TC2COS_MAPr_TC_0011_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0011_COSf_SET
#define TC2COS_MAPr_TC_0100_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0100_COSf_GET
#define TC2COS_MAPr_TC_0100_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0100_COSf_SET
#define TC2COS_MAPr_TC_0101_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0101_COSf_GET
#define TC2COS_MAPr_TC_0101_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0101_COSf_SET
#define TC2COS_MAPr_TC_0110_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0110_COSf_GET
#define TC2COS_MAPr_TC_0110_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0110_COSf_SET
#define TC2COS_MAPr_TC_0111_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_0111_COSf_GET
#define TC2COS_MAPr_TC_0111_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_0111_COSf_SET
#define TC2COS_MAPr_TC_1000_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1000_COSf_GET
#define TC2COS_MAPr_TC_1000_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1000_COSf_SET
#define TC2COS_MAPr_TC_1001_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1001_COSf_GET
#define TC2COS_MAPr_TC_1001_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1001_COSf_SET
#define TC2COS_MAPr_TC_1010_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1010_COSf_GET
#define TC2COS_MAPr_TC_1010_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1010_COSf_SET
#define TC2COS_MAPr_TC_1011_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1011_COSf_GET
#define TC2COS_MAPr_TC_1011_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1011_COSf_SET
#define TC2COS_MAPr_TC_1100_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1100_COSf_GET
#define TC2COS_MAPr_TC_1100_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1100_COSf_SET
#define TC2COS_MAPr_TC_1101_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1101_COSf_GET
#define TC2COS_MAPr_TC_1101_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1101_COSf_SET
#define TC2COS_MAPr_TC_1110_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1110_COSf_GET
#define TC2COS_MAPr_TC_1110_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1110_COSf_SET
#define TC2COS_MAPr_TC_1111_COSf_GET BCM53600_A0_TC2COS_MAPr_TC_1111_COSf_GET
#define TC2COS_MAPr_TC_1111_COSf_SET BCM53600_A0_TC2COS_MAPr_TC_1111_COSf_SET
#define READ_TC2COS_MAPr BCM53600_A0_READ_TC2COS_MAPr
#define WRITE_TC2COS_MAPr BCM53600_A0_WRITE_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TCAM_CHKSUM_STS
 * BLOCKS:   SYS
 * DESC:     TCAM Checksum Status Register
 * SIZE:     48
 * FIELDS:
 *     EVM_TCAM_CHKSUM_ADDR EVM TCAM checksum address.
 *     RESERVED_0       Reserved
 *     EVM_TCAM_CHKSUM_ERR EVM TCAM checksum error.1=checksum error and the error address is stored in the field "EVM_TCAM_CHKSUM_ADDR".This error can be cleared by writing new values to the error address.0= no error.
 *     IVM_TCAM_CHKSUM_ADDR IVM TCAM checksum address.
 *     RESERVED_1       Reserved
 *     IVM_TCAM_CHKSUM_ERR IVM TCAM checksum error.1=checksum error and the error address is stored in the field "IVM_TCAM_CHKSUM_ADDR".This error can be cleared by writing new values to the error address.0= no error.
 *     CFP_TCAM_CHKSUM_ADDR CFP TCAM checksum address.
 *     RESERVED_2       Reserved
 *     CFP_TCAM_CHKSUM_ERR CFP TCAM checksum error.1=checksum error and the error address is stored in the field "CFP_TCAM_CHKSUM_ADDR".This error can be cleared by writing new values to the error address.0= no error.
 *
 ******************************************************************************/
#define BCM53600_A0_TCAM_CHKSUM_STSr 0x000003c8

#define BCM53600_A0_TCAM_CHKSUM_STSr_SIZE 6

/*
 * This structure should be used to declare and program TCAM_CHKSUM_STS.
 *
 */
typedef union BCM53600_A0_TCAM_CHKSUM_STSr_s {
	uint32_t v[2];
	uint32_t tcam_chksum_sts[2];
	uint32_t _tcam_chksum_sts;
} BCM53600_A0_TCAM_CHKSUM_STSr_t;

#define BCM53600_A0_TCAM_CHKSUM_STSr_CLR(r) CDK_MEMSET(&((r)._tcam_chksum_sts), 0, sizeof(BCM53600_A0_TCAM_CHKSUM_STSr_t))
#define BCM53600_A0_TCAM_CHKSUM_STSr_SET(r,i,d) (r).tcam_chksum_sts[i] = d
#define BCM53600_A0_TCAM_CHKSUM_STSr_GET(r,i) (r).tcam_chksum_sts[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ADDRf_GET(r) (((r).tcam_chksum_sts[0]) & 0x3ff)
#define BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ADDRf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_0f_GET(r) ((((r).tcam_chksum_sts[0]) >> 10) & 0x1f)
#define BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_0f_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ERRf_GET(r) ((((r).tcam_chksum_sts[0]) >> 15) & 0x1)
#define BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ERRf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ADDRf_GET(r) ((((r).tcam_chksum_sts[0]) >> 16) & 0x3ff)
#define BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ADDRf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_1f_GET(r) ((((r).tcam_chksum_sts[0]) >> 26) & 0x1f)
#define BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_1f_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x1f << 26)) | ((((uint32_t)f) & 0x1f) << 26))
#define BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ERRf_GET(r) ((((r).tcam_chksum_sts[0]) >> 31) & 0x1)
#define BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ERRf_SET(r,f) (r).tcam_chksum_sts[0]=(((r).tcam_chksum_sts[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_GET(r) (((r).tcam_chksum_sts[1]) & 0x7ff)
#define BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_SET(r,f) (r).tcam_chksum_sts[1]=(((r).tcam_chksum_sts[1] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_2f_GET(r) ((((r).tcam_chksum_sts[1]) >> 11) & 0xf)
#define BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_2f_SET(r,f) (r).tcam_chksum_sts[1]=(((r).tcam_chksum_sts[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_GET(r) ((((r).tcam_chksum_sts[1]) >> 15) & 0x1)
#define BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_SET(r,f) (r).tcam_chksum_sts[1]=(((r).tcam_chksum_sts[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access TCAM_CHKSUM_STS.
 *
 */
#define BCM53600_A0_READ_TCAM_CHKSUM_STSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TCAM_CHKSUM_STSr,(r._tcam_chksum_sts),6)
#define BCM53600_A0_WRITE_TCAM_CHKSUM_STSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TCAM_CHKSUM_STSr,&(r._tcam_chksum_sts),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_CHKSUM_STSr BCM53600_A0_TCAM_CHKSUM_STSr
#define TCAM_CHKSUM_STSr_SIZE BCM53600_A0_TCAM_CHKSUM_STSr_SIZE
typedef BCM53600_A0_TCAM_CHKSUM_STSr_t TCAM_CHKSUM_STSr_t;
#define TCAM_CHKSUM_STSr_CLR BCM53600_A0_TCAM_CHKSUM_STSr_CLR
#define TCAM_CHKSUM_STSr_SET BCM53600_A0_TCAM_CHKSUM_STSr_SET
#define TCAM_CHKSUM_STSr_GET BCM53600_A0_TCAM_CHKSUM_STSr_GET
#define TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ADDRf_GET BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ADDRf_GET
#define TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ADDRf_SET BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ADDRf_SET
#define TCAM_CHKSUM_STSr_RESERVED_0f_GET BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_0f_GET
#define TCAM_CHKSUM_STSr_RESERVED_0f_SET BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_0f_SET
#define TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ERRf_GET BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ERRf_GET
#define TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ERRf_SET BCM53600_A0_TCAM_CHKSUM_STSr_EVM_TCAM_CHKSUM_ERRf_SET
#define TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ADDRf_GET BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ADDRf_GET
#define TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ADDRf_SET BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ADDRf_SET
#define TCAM_CHKSUM_STSr_RESERVED_1f_GET BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_1f_GET
#define TCAM_CHKSUM_STSr_RESERVED_1f_SET BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_1f_SET
#define TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ERRf_GET BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ERRf_GET
#define TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ERRf_SET BCM53600_A0_TCAM_CHKSUM_STSr_IVM_TCAM_CHKSUM_ERRf_SET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_GET BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_GET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_SET BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ADDRf_SET
#define TCAM_CHKSUM_STSr_RESERVED_2f_GET BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_2f_GET
#define TCAM_CHKSUM_STSr_RESERVED_2f_SET BCM53600_A0_TCAM_CHKSUM_STSr_RESERVED_2f_SET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_GET BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_GET
#define TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_SET BCM53600_A0_TCAM_CHKSUM_STSr_CFP_TCAM_CHKSUM_ERRf_SET
#define READ_TCAM_CHKSUM_STSr BCM53600_A0_READ_TCAM_CHKSUM_STSr
#define WRITE_TCAM_CHKSUM_STSr BCM53600_A0_WRITE_TCAM_CHKSUM_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TCAM_CHKSUM_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TCAM_CTL
 * BLOCKS:   SYS
 * DESC:     TCAM Control Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     DISABLE_CFP_TCAM 1 = To disable CFP TCAM #5 ~ CFP TCAM #0.(Not2Release)
 *     DISABLE_IVM_TCAM 1 = To disable IVM TCAM.(Not2Release)
 *     DISABLE_EVM_TCAM 1 = To disable EVM TCAM.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *     EN_TCAM_CHKSUM   1 = To enable TCAM checksum.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_TCAM_CTLr 0x000003c0

#define BCM53600_A0_TCAM_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TCAM_CTL.
 *
 */
typedef union BCM53600_A0_TCAM_CTLr_s {
	uint32_t v[1];
	uint32_t tcam_ctl[1];
	uint32_t _tcam_ctl;
} BCM53600_A0_TCAM_CTLr_t;

#define BCM53600_A0_TCAM_CTLr_CLR(r) (r).tcam_ctl[0] = 0
#define BCM53600_A0_TCAM_CTLr_SET(r,d) (r).tcam_ctl[0] = d
#define BCM53600_A0_TCAM_CTLr_GET(r) (r).tcam_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TCAM_CTLr_DISABLE_CFP_TCAMf_GET(r) (((r).tcam_ctl[0]) & 0x3f)
#define BCM53600_A0_TCAM_CTLr_DISABLE_CFP_TCAMf_SET(r,f) (r).tcam_ctl[0]=(((r).tcam_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53600_A0_TCAM_CTLr_DISABLE_IVM_TCAMf_GET(r) ((((r).tcam_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_TCAM_CTLr_DISABLE_IVM_TCAMf_SET(r,f) (r).tcam_ctl[0]=(((r).tcam_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TCAM_CTLr_DISABLE_EVM_TCAMf_GET(r) ((((r).tcam_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_TCAM_CTLr_DISABLE_EVM_TCAMf_SET(r,f) (r).tcam_ctl[0]=(((r).tcam_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_TCAM_CTLr_RESERVEDf_GET(r) ((((r).tcam_ctl[0]) >> 8) & 0x7f)
#define BCM53600_A0_TCAM_CTLr_RESERVEDf_SET(r,f) (r).tcam_ctl[0]=(((r).tcam_ctl[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM53600_A0_TCAM_CTLr_EN_TCAM_CHKSUMf_GET(r) ((((r).tcam_ctl[0]) >> 15) & 0x1)
#define BCM53600_A0_TCAM_CTLr_EN_TCAM_CHKSUMf_SET(r,f) (r).tcam_ctl[0]=(((r).tcam_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access TCAM_CTL.
 *
 */
#define BCM53600_A0_READ_TCAM_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TCAM_CTLr,(r._tcam_ctl),2)
#define BCM53600_A0_WRITE_TCAM_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TCAM_CTLr,&(r._tcam_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_CTLr BCM53600_A0_TCAM_CTLr
#define TCAM_CTLr_SIZE BCM53600_A0_TCAM_CTLr_SIZE
typedef BCM53600_A0_TCAM_CTLr_t TCAM_CTLr_t;
#define TCAM_CTLr_CLR BCM53600_A0_TCAM_CTLr_CLR
#define TCAM_CTLr_SET BCM53600_A0_TCAM_CTLr_SET
#define TCAM_CTLr_GET BCM53600_A0_TCAM_CTLr_GET
#define TCAM_CTLr_DISABLE_CFP_TCAMf_GET BCM53600_A0_TCAM_CTLr_DISABLE_CFP_TCAMf_GET
#define TCAM_CTLr_DISABLE_CFP_TCAMf_SET BCM53600_A0_TCAM_CTLr_DISABLE_CFP_TCAMf_SET
#define TCAM_CTLr_DISABLE_IVM_TCAMf_GET BCM53600_A0_TCAM_CTLr_DISABLE_IVM_TCAMf_GET
#define TCAM_CTLr_DISABLE_IVM_TCAMf_SET BCM53600_A0_TCAM_CTLr_DISABLE_IVM_TCAMf_SET
#define TCAM_CTLr_DISABLE_EVM_TCAMf_GET BCM53600_A0_TCAM_CTLr_DISABLE_EVM_TCAMf_GET
#define TCAM_CTLr_DISABLE_EVM_TCAMf_SET BCM53600_A0_TCAM_CTLr_DISABLE_EVM_TCAMf_SET
#define TCAM_CTLr_RESERVEDf_GET BCM53600_A0_TCAM_CTLr_RESERVEDf_GET
#define TCAM_CTLr_RESERVEDf_SET BCM53600_A0_TCAM_CTLr_RESERVEDf_SET
#define TCAM_CTLr_EN_TCAM_CHKSUMf_GET BCM53600_A0_TCAM_CTLr_EN_TCAM_CHKSUMf_GET
#define TCAM_CTLr_EN_TCAM_CHKSUMf_SET BCM53600_A0_TCAM_CTLr_EN_TCAM_CHKSUMf_SET
#define READ_TCAM_CTLr BCM53600_A0_READ_TCAM_CTLr
#define WRITE_TCAM_CTLr BCM53600_A0_WRITE_TCAM_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TCAM_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  TCAM_TABLE
 * BLOCKS:   SYS
 * DESC:     TCAM DATA-MASK Table
 * SIZE:     460
 * FIELDS:
 *     DATA_0           DATA/MASK 0
 *     DATA_1           DATA/MASK 1
 *     DATA_2           DATA/MASK 2
 *     DATA_3           DATA/MASK 3
 *     DATA_4           DATA/MASK 4
 *     DATA_5           DATA/MASK 5
 *     DATA_6           DATA/MASK 6
 *     DATA_7           DATA/MASK 7
 *
 ******************************************************************************/
#define BCM53600_A0_TCAM_TABLEm 0x00000000

#define BCM53600_A0_TCAM_TABLEm_MIN 0
#define BCM53600_A0_TCAM_TABLEm_MAX 1535
#define BCM53600_A0_TCAM_TABLEm_CMAX(u) 1535
#define BCM53600_A0_TCAM_TABLEm_SIZE 58

/*
 * This structure should be used to declare and program TCAM_TABLE.
 *
 */
typedef union BCM53600_A0_TCAM_TABLEm_s {
	uint32_t v[15];
	uint32_t tcam_table[15];
	uint32_t _tcam_table;
} BCM53600_A0_TCAM_TABLEm_t;

#define BCM53600_A0_TCAM_TABLEm_CLR(r) CDK_MEMSET(&((r)._tcam_table), 0, sizeof(BCM53600_A0_TCAM_TABLEm_t))
#define BCM53600_A0_TCAM_TABLEm_SET(r,i,d) (r).tcam_table[i] = d
#define BCM53600_A0_TCAM_TABLEm_GET(r,i) (r).tcam_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TCAM_TABLEm_DATA_0f_GET(r,a) cdk_field_get((r).tcam_table,0,63,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_0f_SET(r,a) cdk_field_set((r).tcam_table,0,63,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_1f_GET(r,a) cdk_field_get((r).tcam_table,64,127,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_1f_SET(r,a) cdk_field_set((r).tcam_table,64,127,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_2f_GET(r,a) cdk_field_get((r).tcam_table,128,191,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_2f_SET(r,a) cdk_field_set((r).tcam_table,128,191,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_3f_GET(r,a) cdk_field_get((r).tcam_table,192,229,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_3f_SET(r,a) cdk_field_set((r).tcam_table,192,229,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_4f_GET(r,a) cdk_field_get((r).tcam_table,230,293,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_4f_SET(r,a) cdk_field_set((r).tcam_table,230,293,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_5f_GET(r,a) cdk_field_get((r).tcam_table,294,357,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_5f_SET(r,a) cdk_field_set((r).tcam_table,294,357,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_6f_GET(r,a) cdk_field_get((r).tcam_table,358,421,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_6f_SET(r,a) cdk_field_set((r).tcam_table,358,421,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_7f_GET(r,a) cdk_field_get((r).tcam_table,422,459,a)
#define BCM53600_A0_TCAM_TABLEm_DATA_7f_SET(r,a) cdk_field_set((r).tcam_table,422,459,a)

/*
 * These macros can be used to access TCAM_TABLE.
 *
 */
#define BCM53600_A0_READ_TCAM_TABLEm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_TCAM_TABLEm,i,(m),58)
#define BCM53600_A0_WRITE_TCAM_TABLEm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_TCAM_TABLEm,i,&(m),58)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_TABLEm BCM53600_A0_TCAM_TABLEm
#define TCAM_TABLEm_MIN BCM53600_A0_TCAM_TABLEm_MIN
#define TCAM_TABLEm_MAX BCM53600_A0_TCAM_TABLEm_MAX
#define TCAM_TABLEm_CMAX(u) BCM53600_A0_TCAM_TABLEm_CMAX(u)
#define TCAM_TABLEm_SIZE BCM53600_A0_TCAM_TABLEm_SIZE
typedef BCM53600_A0_TCAM_TABLEm_t TCAM_TABLEm_t;
#define TCAM_TABLEm_CLR BCM53600_A0_TCAM_TABLEm_CLR
#define TCAM_TABLEm_SET BCM53600_A0_TCAM_TABLEm_SET
#define TCAM_TABLEm_GET BCM53600_A0_TCAM_TABLEm_GET
#define TCAM_TABLEm_DATA_0f_GET BCM53600_A0_TCAM_TABLEm_DATA_0f_GET
#define TCAM_TABLEm_DATA_0f_SET BCM53600_A0_TCAM_TABLEm_DATA_0f_SET
#define TCAM_TABLEm_DATA_1f_GET BCM53600_A0_TCAM_TABLEm_DATA_1f_GET
#define TCAM_TABLEm_DATA_1f_SET BCM53600_A0_TCAM_TABLEm_DATA_1f_SET
#define TCAM_TABLEm_DATA_2f_GET BCM53600_A0_TCAM_TABLEm_DATA_2f_GET
#define TCAM_TABLEm_DATA_2f_SET BCM53600_A0_TCAM_TABLEm_DATA_2f_SET
#define TCAM_TABLEm_DATA_3f_GET BCM53600_A0_TCAM_TABLEm_DATA_3f_GET
#define TCAM_TABLEm_DATA_3f_SET BCM53600_A0_TCAM_TABLEm_DATA_3f_SET
#define TCAM_TABLEm_DATA_4f_GET BCM53600_A0_TCAM_TABLEm_DATA_4f_GET
#define TCAM_TABLEm_DATA_4f_SET BCM53600_A0_TCAM_TABLEm_DATA_4f_SET
#define TCAM_TABLEm_DATA_5f_GET BCM53600_A0_TCAM_TABLEm_DATA_5f_GET
#define TCAM_TABLEm_DATA_5f_SET BCM53600_A0_TCAM_TABLEm_DATA_5f_SET
#define TCAM_TABLEm_DATA_6f_GET BCM53600_A0_TCAM_TABLEm_DATA_6f_GET
#define TCAM_TABLEm_DATA_6f_SET BCM53600_A0_TCAM_TABLEm_DATA_6f_SET
#define TCAM_TABLEm_DATA_7f_GET BCM53600_A0_TCAM_TABLEm_DATA_7f_GET
#define TCAM_TABLEm_DATA_7f_SET BCM53600_A0_TCAM_TABLEm_DATA_7f_SET
#define READ_TCAM_TABLEm BCM53600_A0_READ_TCAM_TABLEm
#define WRITE_TCAM_TABLEm BCM53600_A0_WRITE_TCAM_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TCAM_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  TCDP2DSCPECN
 * BLOCKS:   SYS
 * DESC:     TCDP2DSCPECN Table
 * SIZE:     8
 * FIELDS:
 *     ECN              Explicit Congestion Notification
 *     DSCP             differentiated services codepoint
 *
 ******************************************************************************/
#define BCM53600_A0_TCDP2DSCPECNm 0x00000000

#define BCM53600_A0_TCDP2DSCPECNm_MIN 0
#define BCM53600_A0_TCDP2DSCPECNm_MAX 63
#define BCM53600_A0_TCDP2DSCPECNm_CMAX(u) 63
#define BCM53600_A0_TCDP2DSCPECNm_SIZE 1

/*
 * This structure should be used to declare and program TCDP2DSCPECN.
 *
 */
typedef union BCM53600_A0_TCDP2DSCPECNm_s {
	uint32_t v[1];
	uint32_t tcdp2dscpecn[1];
	uint32_t _tcdp2dscpecn;
} BCM53600_A0_TCDP2DSCPECNm_t;

#define BCM53600_A0_TCDP2DSCPECNm_CLR(r) (r).tcdp2dscpecn[0] = 0
#define BCM53600_A0_TCDP2DSCPECNm_SET(r,d) (r).tcdp2dscpecn[0] = d
#define BCM53600_A0_TCDP2DSCPECNm_GET(r) (r).tcdp2dscpecn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TCDP2DSCPECNm_ECNf_GET(r) (((r).tcdp2dscpecn[0]) & 0x3)
#define BCM53600_A0_TCDP2DSCPECNm_ECNf_SET(r,f) (r).tcdp2dscpecn[0]=(((r).tcdp2dscpecn[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_TCDP2DSCPECNm_DSCPf_GET(r) ((((r).tcdp2dscpecn[0]) >> 2) & 0x3f)
#define BCM53600_A0_TCDP2DSCPECNm_DSCPf_SET(r,f) (r).tcdp2dscpecn[0]=(((r).tcdp2dscpecn[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access TCDP2DSCPECN.
 *
 */
#define BCM53600_A0_READ_TCDP2DSCPECNm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_TCDP2DSCPECNm,i,(m),1)
#define BCM53600_A0_WRITE_TCDP2DSCPECNm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_TCDP2DSCPECNm,i,&(m),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCDP2DSCPECNm BCM53600_A0_TCDP2DSCPECNm
#define TCDP2DSCPECNm_MIN BCM53600_A0_TCDP2DSCPECNm_MIN
#define TCDP2DSCPECNm_MAX BCM53600_A0_TCDP2DSCPECNm_MAX
#define TCDP2DSCPECNm_CMAX(u) BCM53600_A0_TCDP2DSCPECNm_CMAX(u)
#define TCDP2DSCPECNm_SIZE BCM53600_A0_TCDP2DSCPECNm_SIZE
typedef BCM53600_A0_TCDP2DSCPECNm_t TCDP2DSCPECNm_t;
#define TCDP2DSCPECNm_CLR BCM53600_A0_TCDP2DSCPECNm_CLR
#define TCDP2DSCPECNm_SET BCM53600_A0_TCDP2DSCPECNm_SET
#define TCDP2DSCPECNm_GET BCM53600_A0_TCDP2DSCPECNm_GET
#define TCDP2DSCPECNm_ECNf_GET BCM53600_A0_TCDP2DSCPECNm_ECNf_GET
#define TCDP2DSCPECNm_ECNf_SET BCM53600_A0_TCDP2DSCPECNm_ECNf_SET
#define TCDP2DSCPECNm_DSCPf_GET BCM53600_A0_TCDP2DSCPECNm_DSCPf_GET
#define TCDP2DSCPECNm_DSCPf_SET BCM53600_A0_TCDP2DSCPECNm_DSCPf_SET
#define READ_TCDP2DSCPECNm BCM53600_A0_READ_TCDP2DSCPECNm
#define WRITE_TCDP2DSCPECNm BCM53600_A0_WRITE_TCDP2DSCPECNm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TCDP2DSCPECNm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TC_GROUP_CTRL
 * BLOCKS:   SYS
 * DESC:     TC Group Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TC0_ASSURED_GRP 1 = TC 0 is associated with Assured TC Group.0 = TC 0 is associated with BestEffort TC Group.
 *     EN_TC1_ASSURED_GRP 1 = TC 1 is associated with Assured TC Group.0 = TC 1 is associated with BestEffort TC Group.
 *     EN_TC2_ASSURED_GRP 1 = TC 2 is associated with Assured TC Group.0 = TC 2 is associated with BestEffort TC Group.
 *     EN_TC3_ASSURED_GRP 1 = TC 3 is associated with Assured TC Group.0 = TC 3 is associated with BestEffort TC Group.
 *     EN_TC4_ASSURED_GRP 1 = TC 4 is associated with Assured TC Group.0 = TC 4 is associated with BestEffort TC Group.
 *     EN_TC5_ASSURED_GRP 1 = TC 5 is associated with Assured TC Group.0 = TC 5 is associated with BestEffort TC Group.
 *     EN_TC6_ASSURED_GRP 1 = TC 6 is associated with Assured TC Group.0 = TC 6 is associated with BestEffort TC Group.
 *     EN_TC7_ASSURED_GRP 1 = TC 7 is associated with Assured TC Group.0 = TC 7 is associated with BestEffort TC Group.
 *     EN_TC8_ASSURED_GRP 1 = TC 8 is associated with Assured TC Group.0 = TC 8 is associated with BestEffort TC Group.
 *     EN_TC9_ASSURED_GRP 1 = TC 9 is associated with Assured TC Group.0 = TC 9 is associated with BestEffort TC Group.
 *     EN_TC10_ASSURED_GRP 1 = TC 10 is associated with Assured TC Group.0 = TC 10 is associated with BestEffort TC Group.
 *     EN_TC11_ASSURED_GRP 1 = TC 11 is associated with Assured TC Group.0 = TC 11 is associated with BestEffort TC Group.
 *     EN_TC12_ASSURED_GRP 1 = TC 12 is associated with Assured TC Group.0 = TC 12 is associated with BestEffort TC Group.
 *     EN_TC13_ASSURED_GRP 1 = TC 13 is associated with Assured TC Group.0 = TC 13 is associated with BestEffort TC Group.
 *     EN_TC14_ASSURED_GRP 1 = TC 14 is associated with Assured TC Group.0 = TC 14 is associated with BestEffort TC Group.
 *     EN_TC15_ASSURED_GRP 1 = TC 15 is associated with Assured TC Group.0 = TC 15 is associated with BestEffort TC Group.
 *
 ******************************************************************************/
#define BCM53600_A0_TC_GROUP_CTRLr 0x00000a02

#define BCM53600_A0_TC_GROUP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program TC_GROUP_CTRL.
 *
 */
typedef union BCM53600_A0_TC_GROUP_CTRLr_s {
	uint32_t v[1];
	uint32_t tc_group_ctrl[1];
	uint32_t _tc_group_ctrl;
} BCM53600_A0_TC_GROUP_CTRLr_t;

#define BCM53600_A0_TC_GROUP_CTRLr_CLR(r) (r).tc_group_ctrl[0] = 0
#define BCM53600_A0_TC_GROUP_CTRLr_SET(r,d) (r).tc_group_ctrl[0] = d
#define BCM53600_A0_TC_GROUP_CTRLr_GET(r) (r).tc_group_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC0_ASSURED_GRPf_GET(r) (((r).tc_group_ctrl[0]) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC0_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC1_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 1) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC1_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC2_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 2) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC2_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC3_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 3) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC3_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC4_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 4) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC4_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC5_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 5) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC5_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC6_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 6) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC6_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC7_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 7) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC7_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC8_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 8) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC8_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC9_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 9) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC9_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC10_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 10) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC10_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC11_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 11) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC11_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC12_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 12) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC12_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC13_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 13) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC13_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC14_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 14) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC14_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC15_ASSURED_GRPf_GET(r) ((((r).tc_group_ctrl[0]) >> 15) & 0x1)
#define BCM53600_A0_TC_GROUP_CTRLr_EN_TC15_ASSURED_GRPf_SET(r,f) (r).tc_group_ctrl[0]=(((r).tc_group_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access TC_GROUP_CTRL.
 *
 */
#define BCM53600_A0_READ_TC_GROUP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TC_GROUP_CTRLr,(r._tc_group_ctrl),2)
#define BCM53600_A0_WRITE_TC_GROUP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TC_GROUP_CTRLr,&(r._tc_group_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TC_GROUP_CTRLr BCM53600_A0_TC_GROUP_CTRLr
#define TC_GROUP_CTRLr_SIZE BCM53600_A0_TC_GROUP_CTRLr_SIZE
typedef BCM53600_A0_TC_GROUP_CTRLr_t TC_GROUP_CTRLr_t;
#define TC_GROUP_CTRLr_CLR BCM53600_A0_TC_GROUP_CTRLr_CLR
#define TC_GROUP_CTRLr_SET BCM53600_A0_TC_GROUP_CTRLr_SET
#define TC_GROUP_CTRLr_GET BCM53600_A0_TC_GROUP_CTRLr_GET
#define TC_GROUP_CTRLr_EN_TC0_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC0_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC0_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC0_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC1_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC1_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC1_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC1_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC2_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC2_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC2_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC2_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC3_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC3_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC3_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC3_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC4_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC4_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC4_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC4_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC5_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC5_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC5_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC5_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC6_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC6_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC6_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC6_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC7_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC7_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC7_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC7_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC8_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC8_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC8_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC8_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC9_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC9_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC9_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC9_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC10_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC10_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC10_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC10_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC11_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC11_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC11_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC11_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC12_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC12_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC12_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC12_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC13_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC13_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC13_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC13_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC14_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC14_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC14_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC14_ASSURED_GRPf_SET
#define TC_GROUP_CTRLr_EN_TC15_ASSURED_GRPf_GET BCM53600_A0_TC_GROUP_CTRLr_EN_TC15_ASSURED_GRPf_GET
#define TC_GROUP_CTRLr_EN_TC15_ASSURED_GRPf_SET BCM53600_A0_TC_GROUP_CTRLr_EN_TC15_ASSURED_GRPf_SET
#define READ_TC_GROUP_CTRLr BCM53600_A0_READ_TC_GROUP_CTRLr
#define WRITE_TC_GROUP_CTRLr BCM53600_A0_WRITE_TC_GROUP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TC_GROUP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TEMP_MON_CAL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Calibration Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA_25C    Temperature measure code at 25oC. The default value is loaded from OTPmemory and the value is changeable if required.Note: Temperature(oC) = (measure code - TEMP_DATA_25)*(-0.69)+25oC.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_TEMP_MON_CALr 0x00000b06

#define BCM53600_A0_TEMP_MON_CALr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_CAL.
 *
 */
typedef union BCM53600_A0_TEMP_MON_CALr_s {
	uint32_t v[1];
	uint32_t temp_mon_cal[1];
	uint32_t _temp_mon_cal;
} BCM53600_A0_TEMP_MON_CALr_t;

#define BCM53600_A0_TEMP_MON_CALr_CLR(r) (r).temp_mon_cal[0] = 0
#define BCM53600_A0_TEMP_MON_CALr_SET(r,d) (r).temp_mon_cal[0] = d
#define BCM53600_A0_TEMP_MON_CALr_GET(r) (r).temp_mon_cal[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET(r) (((r).temp_mon_cal[0]) & 0x1ff)
#define BCM53600_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53600_A0_TEMP_MON_CALr_RESERVEDf_GET(r) ((((r).temp_mon_cal[0]) >> 9) & 0x7f)
#define BCM53600_A0_TEMP_MON_CALr_RESERVEDf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_CAL.
 *
 */
#define BCM53600_A0_READ_TEMP_MON_CALr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TEMP_MON_CALr,(r._temp_mon_cal),2)
#define BCM53600_A0_WRITE_TEMP_MON_CALr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TEMP_MON_CALr,&(r._temp_mon_cal),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CALr BCM53600_A0_TEMP_MON_CALr
#define TEMP_MON_CALr_SIZE BCM53600_A0_TEMP_MON_CALr_SIZE
typedef BCM53600_A0_TEMP_MON_CALr_t TEMP_MON_CALr_t;
#define TEMP_MON_CALr_CLR BCM53600_A0_TEMP_MON_CALr_CLR
#define TEMP_MON_CALr_SET BCM53600_A0_TEMP_MON_CALr_SET
#define TEMP_MON_CALr_GET BCM53600_A0_TEMP_MON_CALr_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_GET BCM53600_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_SET BCM53600_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET
#define TEMP_MON_CALr_RESERVEDf_GET BCM53600_A0_TEMP_MON_CALr_RESERVEDf_GET
#define TEMP_MON_CALr_RESERVEDf_SET BCM53600_A0_TEMP_MON_CALr_RESERVEDf_SET
#define READ_TEMP_MON_CALr BCM53600_A0_READ_TEMP_MON_CALr
#define WRITE_TEMP_MON_CALr BCM53600_A0_WRITE_TEMP_MON_CALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TEMP_MON_CALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TEMP_MON_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     ADC_TEST_EN      1 = Temp monitor normal mode.0 = SAR ADC test mode.(Not2Release)
 *     BIAS_ADJUST      Analog bias adjustments.(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_TEMP_MON_CTLr 0x00000b00

#define BCM53600_A0_TEMP_MON_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_CTL.
 *
 */
typedef union BCM53600_A0_TEMP_MON_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_ctl[1];
	uint32_t _temp_mon_ctl;
} BCM53600_A0_TEMP_MON_CTLr_t;

#define BCM53600_A0_TEMP_MON_CTLr_CLR(r) (r).temp_mon_ctl[0] = 0
#define BCM53600_A0_TEMP_MON_CTLr_SET(r,d) (r).temp_mon_ctl[0] = d
#define BCM53600_A0_TEMP_MON_CTLr_GET(r) (r).temp_mon_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET(r) (((r).temp_mon_ctl[0]) & 0x1)
#define BCM53600_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET(r) ((((r).temp_mon_ctl[0]) >> 1) & 0x7f)
#define BCM53600_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_CTL.
 *
 */
#define BCM53600_A0_READ_TEMP_MON_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TEMP_MON_CTLr,(r._temp_mon_ctl),1)
#define BCM53600_A0_WRITE_TEMP_MON_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TEMP_MON_CTLr,&(r._temp_mon_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CTLr BCM53600_A0_TEMP_MON_CTLr
#define TEMP_MON_CTLr_SIZE BCM53600_A0_TEMP_MON_CTLr_SIZE
typedef BCM53600_A0_TEMP_MON_CTLr_t TEMP_MON_CTLr_t;
#define TEMP_MON_CTLr_CLR BCM53600_A0_TEMP_MON_CTLr_CLR
#define TEMP_MON_CTLr_SET BCM53600_A0_TEMP_MON_CTLr_SET
#define TEMP_MON_CTLr_GET BCM53600_A0_TEMP_MON_CTLr_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_GET BCM53600_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_SET BCM53600_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_GET BCM53600_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_SET BCM53600_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET
#define READ_TEMP_MON_CTLr BCM53600_A0_READ_TEMP_MON_CTLr
#define WRITE_TEMP_MON_CTLr BCM53600_A0_WRITE_TEMP_MON_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TEMP_MON_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA        Temperature monitor result. When the temperature is higher, the measure code is lower.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_TEMP_MON_RESUr 0x00000b02

#define BCM53600_A0_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_RESU.
 *
 */
typedef union BCM53600_A0_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t temp_mon_resu[1];
	uint32_t _temp_mon_resu;
} BCM53600_A0_TEMP_MON_RESUr_t;

#define BCM53600_A0_TEMP_MON_RESUr_CLR(r) (r).temp_mon_resu[0] = 0
#define BCM53600_A0_TEMP_MON_RESUr_SET(r,d) (r).temp_mon_resu[0] = d
#define BCM53600_A0_TEMP_MON_RESUr_GET(r) (r).temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TEMP_MON_RESUr_TEMP_DATAf_GET(r) (((r).temp_mon_resu[0]) & 0x1ff)
#define BCM53600_A0_TEMP_MON_RESUr_TEMP_DATAf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53600_A0_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM53600_A0_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_RESU.
 *
 */
#define BCM53600_A0_READ_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TEMP_MON_RESUr,(r._temp_mon_resu),2)
#define BCM53600_A0_WRITE_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TEMP_MON_RESUr,&(r._temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_RESUr BCM53600_A0_TEMP_MON_RESUr
#define TEMP_MON_RESUr_SIZE BCM53600_A0_TEMP_MON_RESUr_SIZE
typedef BCM53600_A0_TEMP_MON_RESUr_t TEMP_MON_RESUr_t;
#define TEMP_MON_RESUr_CLR BCM53600_A0_TEMP_MON_RESUr_CLR
#define TEMP_MON_RESUr_SET BCM53600_A0_TEMP_MON_RESUr_SET
#define TEMP_MON_RESUr_GET BCM53600_A0_TEMP_MON_RESUr_GET
#define TEMP_MON_RESUr_TEMP_DATAf_GET BCM53600_A0_TEMP_MON_RESUr_TEMP_DATAf_GET
#define TEMP_MON_RESUr_TEMP_DATAf_SET BCM53600_A0_TEMP_MON_RESUr_TEMP_DATAf_SET
#define TEMP_MON_RESUr_RESERVEDf_GET BCM53600_A0_TEMP_MON_RESUr_RESERVEDf_GET
#define TEMP_MON_RESUr_RESERVEDf_SET BCM53600_A0_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_TEMP_MON_RESUr BCM53600_A0_READ_TEMP_MON_RESUr
#define WRITE_TEMP_MON_RESUr BCM53600_A0_WRITE_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TEMP_MON_SPEC_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Special Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     TEMP_PWRDN       1=Set temperature monitor in power down condition.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_TEMP_MON_SPEC_CTLr 0x00000b08

#define BCM53600_A0_TEMP_MON_SPEC_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_SPEC_CTL.
 *
 */
typedef union BCM53600_A0_TEMP_MON_SPEC_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_spec_ctl[1];
	uint32_t _temp_mon_spec_ctl;
} BCM53600_A0_TEMP_MON_SPEC_CTLr_t;

#define BCM53600_A0_TEMP_MON_SPEC_CTLr_CLR(r) (r).temp_mon_spec_ctl[0] = 0
#define BCM53600_A0_TEMP_MON_SPEC_CTLr_SET(r,d) (r).temp_mon_spec_ctl[0] = d
#define BCM53600_A0_TEMP_MON_SPEC_CTLr_GET(r) (r).temp_mon_spec_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET(r) (((r).temp_mon_spec_ctl[0]) & 0x1)
#define BCM53600_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET(r) ((((r).temp_mon_spec_ctl[0]) >> 1) & 0x7f)
#define BCM53600_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_SPEC_CTL.
 *
 */
#define BCM53600_A0_READ_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TEMP_MON_SPEC_CTLr,(r._temp_mon_spec_ctl),1)
#define BCM53600_A0_WRITE_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TEMP_MON_SPEC_CTLr,&(r._temp_mon_spec_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_SPEC_CTLr BCM53600_A0_TEMP_MON_SPEC_CTLr
#define TEMP_MON_SPEC_CTLr_SIZE BCM53600_A0_TEMP_MON_SPEC_CTLr_SIZE
typedef BCM53600_A0_TEMP_MON_SPEC_CTLr_t TEMP_MON_SPEC_CTLr_t;
#define TEMP_MON_SPEC_CTLr_CLR BCM53600_A0_TEMP_MON_SPEC_CTLr_CLR
#define TEMP_MON_SPEC_CTLr_SET BCM53600_A0_TEMP_MON_SPEC_CTLr_SET
#define TEMP_MON_SPEC_CTLr_GET BCM53600_A0_TEMP_MON_SPEC_CTLr_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET BCM53600_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET BCM53600_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_GET BCM53600_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_SET BCM53600_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET
#define READ_TEMP_MON_SPEC_CTLr BCM53600_A0_READ_TEMP_MON_SPEC_CTLr
#define WRITE_TEMP_MON_SPEC_CTLr BCM53600_A0_WRITE_TEMP_MON_SPEC_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TEMP_MON_SPEC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TH_PCTL
 * BLOCKS:   EPIC0
 * DESC:     FE Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED         Reserved
 *     STP_STATE        CPU writes the current computed states of its Spanning Tree Algorithmfor this port.2'b00: Disable State(default for managed mode).2'b01: Discarding State.2'b10: Learning State.2'b11: Forwarding State(default for unmanaged mode).Default value is read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently.If HW_FWDG_EN pin = 1, the default value = "11"(Forwarding State).If HW_FWDG_EN pin = 0, the default value = "00"(Disable State).
 *
 ******************************************************************************/
#define BCM53600_A0_TH_PCTLr 0x00000190

#define BCM53600_A0_TH_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program TH_PCTL.
 *
 */
typedef union BCM53600_A0_TH_PCTLr_s {
	uint32_t v[1];
	uint32_t th_pctl[1];
	uint32_t _th_pctl;
} BCM53600_A0_TH_PCTLr_t;

#define BCM53600_A0_TH_PCTLr_CLR(r) (r).th_pctl[0] = 0
#define BCM53600_A0_TH_PCTLr_SET(r,d) (r).th_pctl[0] = d
#define BCM53600_A0_TH_PCTLr_GET(r) (r).th_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TH_PCTLr_RX_DISf_GET(r) (((r).th_pctl[0]) & 0x1)
#define BCM53600_A0_TH_PCTLr_RX_DISf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TH_PCTLr_TX_DISf_GET(r) ((((r).th_pctl[0]) >> 1) & 0x1)
#define BCM53600_A0_TH_PCTLr_TX_DISf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TH_PCTLr_RESERVEDf_GET(r) ((((r).th_pctl[0]) >> 2) & 0xf)
#define BCM53600_A0_TH_PCTLr_RESERVEDf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53600_A0_TH_PCTLr_STP_STATEf_GET(r) ((((r).th_pctl[0]) >> 6) & 0x3)
#define BCM53600_A0_TH_PCTLr_STP_STATEf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access TH_PCTL.
 *
 */
#define BCM53600_A0_READ_TH_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53600_A0_TH_PCTLr,(r._th_pctl),1)
#define BCM53600_A0_WRITE_TH_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53600_A0_TH_PCTLr,&(r._th_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TH_PCTLr BCM53600_A0_TH_PCTLr
#define TH_PCTLr_SIZE BCM53600_A0_TH_PCTLr_SIZE
typedef BCM53600_A0_TH_PCTLr_t TH_PCTLr_t;
#define TH_PCTLr_CLR BCM53600_A0_TH_PCTLr_CLR
#define TH_PCTLr_SET BCM53600_A0_TH_PCTLr_SET
#define TH_PCTLr_GET BCM53600_A0_TH_PCTLr_GET
#define TH_PCTLr_RX_DISf_GET BCM53600_A0_TH_PCTLr_RX_DISf_GET
#define TH_PCTLr_RX_DISf_SET BCM53600_A0_TH_PCTLr_RX_DISf_SET
#define TH_PCTLr_TX_DISf_GET BCM53600_A0_TH_PCTLr_TX_DISf_GET
#define TH_PCTLr_TX_DISf_SET BCM53600_A0_TH_PCTLr_TX_DISf_SET
#define TH_PCTLr_RESERVEDf_GET BCM53600_A0_TH_PCTLr_RESERVEDf_GET
#define TH_PCTLr_RESERVEDf_SET BCM53600_A0_TH_PCTLr_RESERVEDf_SET
#define TH_PCTLr_STP_STATEf_GET BCM53600_A0_TH_PCTLr_STP_STATEf_GET
#define TH_PCTLr_STP_STATEf_SET BCM53600_A0_TH_PCTLr_STP_STATEf_SET
#define READ_TH_PCTLr BCM53600_A0_READ_TH_PCTLr
#define WRITE_TH_PCTLr BCM53600_A0_WRITE_TH_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TH_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TOTAL_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     Total Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_CONG_ON_TH The Global Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr 0x00000a14

#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t total_congestion_on_threshold[1];
	uint32_t _total_congestion_on_threshold;
} BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_CLR(r) (r).total_congestion_on_threshold[0] = 0
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).total_congestion_on_threshold[0] = d
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_GET(r) (r).total_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_TOTAL_CONG_ON_THf_GET(r) (((r).total_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_TOTAL_CONG_ON_THf_SET(r,f) (r).total_congestion_on_threshold[0]=(((r).total_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).total_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).total_congestion_on_threshold[0]=(((r).total_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TOTAL_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TOTAL_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr,(r._total_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TOTAL_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr,&(r._total_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_CONGESTION_ON_THRESHOLDr BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr
#define TOTAL_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_t TOTAL_CONGESTION_ON_THRESHOLDr_t;
#define TOTAL_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_CLR
#define TOTAL_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_SET
#define TOTAL_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_GET
#define TOTAL_CONGESTION_ON_THRESHOLDr_TOTAL_CONG_ON_THf_GET BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_TOTAL_CONG_ON_THf_GET
#define TOTAL_CONGESTION_ON_THRESHOLDr_TOTAL_CONG_ON_THf_SET BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_TOTAL_CONG_ON_THf_SET
#define TOTAL_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TOTAL_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TOTAL_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TOTAL_CONGESTION_ON_THRESHOLDr
#define WRITE_TOTAL_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TOTAL_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TOTAL_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TOTAL_HYST_COUNT
 * BLOCKS:   SYS
 * DESC:     Total Hyst Count Register
 * SIZE:     8
 * FIELDS:
 *     TOTAL_HYST_CNT   The Hyst count between global settings of ON & OFF.The unit is "Buffer Cell Size"(256 bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TOTAL_HYST_COUNTr 0x00000a04

#define BCM53600_A0_TOTAL_HYST_COUNTr_SIZE 1

/*
 * This structure should be used to declare and program TOTAL_HYST_COUNT.
 *
 */
typedef union BCM53600_A0_TOTAL_HYST_COUNTr_s {
	uint32_t v[1];
	uint32_t total_hyst_count[1];
	uint32_t _total_hyst_count;
} BCM53600_A0_TOTAL_HYST_COUNTr_t;

#define BCM53600_A0_TOTAL_HYST_COUNTr_CLR(r) (r).total_hyst_count[0] = 0
#define BCM53600_A0_TOTAL_HYST_COUNTr_SET(r,d) (r).total_hyst_count[0] = d
#define BCM53600_A0_TOTAL_HYST_COUNTr_GET(r) (r).total_hyst_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TOTAL_HYST_COUNTr_TOTAL_HYST_CNTf_GET(r) (((r).total_hyst_count[0]) & 0xff)
#define BCM53600_A0_TOTAL_HYST_COUNTr_TOTAL_HYST_CNTf_SET(r,f) (r).total_hyst_count[0]=(((r).total_hyst_count[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TOTAL_HYST_COUNT.
 *
 */
#define BCM53600_A0_READ_TOTAL_HYST_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TOTAL_HYST_COUNTr,(r._total_hyst_count),1)
#define BCM53600_A0_WRITE_TOTAL_HYST_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TOTAL_HYST_COUNTr,&(r._total_hyst_count),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_HYST_COUNTr BCM53600_A0_TOTAL_HYST_COUNTr
#define TOTAL_HYST_COUNTr_SIZE BCM53600_A0_TOTAL_HYST_COUNTr_SIZE
typedef BCM53600_A0_TOTAL_HYST_COUNTr_t TOTAL_HYST_COUNTr_t;
#define TOTAL_HYST_COUNTr_CLR BCM53600_A0_TOTAL_HYST_COUNTr_CLR
#define TOTAL_HYST_COUNTr_SET BCM53600_A0_TOTAL_HYST_COUNTr_SET
#define TOTAL_HYST_COUNTr_GET BCM53600_A0_TOTAL_HYST_COUNTr_GET
#define TOTAL_HYST_COUNTr_TOTAL_HYST_CNTf_GET BCM53600_A0_TOTAL_HYST_COUNTr_TOTAL_HYST_CNTf_GET
#define TOTAL_HYST_COUNTr_TOTAL_HYST_CNTf_SET BCM53600_A0_TOTAL_HYST_COUNTr_TOTAL_HYST_CNTf_SET
#define READ_TOTAL_HYST_COUNTr BCM53600_A0_READ_TOTAL_HYST_COUNTr
#define WRITE_TOTAL_HYST_COUNTr BCM53600_A0_WRITE_TOTAL_HYST_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TOTAL_HYST_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TOTAL_LIMIT_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     Total Limit Threshold Register(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TOTAL_LIMIT_TH   The Global_Limit threshold setting.The unit is "Buffer Cell Size"(256 bytes)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr 0x00000a10

#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_LIMIT_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t total_limit_threshold[1];
	uint32_t _total_limit_threshold;
} BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_t;

#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_CLR(r) (r).total_limit_threshold[0] = 0
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_SET(r,d) (r).total_limit_threshold[0] = d
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_GET(r) (r).total_limit_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_TOTAL_LIMIT_THf_GET(r) (((r).total_limit_threshold[0]) & 0x1fff)
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_TOTAL_LIMIT_THf_SET(r,f) (r).total_limit_threshold[0]=(((r).total_limit_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_RESERVEDf_GET(r) ((((r).total_limit_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_RESERVEDf_SET(r,f) (r).total_limit_threshold[0]=(((r).total_limit_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TOTAL_LIMIT_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TOTAL_LIMIT_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TOTAL_LIMIT_THRESHOLDr,(r._total_limit_threshold),2)
#define BCM53600_A0_WRITE_TOTAL_LIMIT_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TOTAL_LIMIT_THRESHOLDr,&(r._total_limit_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_LIMIT_THRESHOLDr BCM53600_A0_TOTAL_LIMIT_THRESHOLDr
#define TOTAL_LIMIT_THRESHOLDr_SIZE BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_SIZE
typedef BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_t TOTAL_LIMIT_THRESHOLDr_t;
#define TOTAL_LIMIT_THRESHOLDr_CLR BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_CLR
#define TOTAL_LIMIT_THRESHOLDr_SET BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_SET
#define TOTAL_LIMIT_THRESHOLDr_GET BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_GET
#define TOTAL_LIMIT_THRESHOLDr_TOTAL_LIMIT_THf_GET BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_TOTAL_LIMIT_THf_GET
#define TOTAL_LIMIT_THRESHOLDr_TOTAL_LIMIT_THf_SET BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_TOTAL_LIMIT_THf_SET
#define TOTAL_LIMIT_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_RESERVEDf_GET
#define TOTAL_LIMIT_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TOTAL_LIMIT_THRESHOLDr_RESERVEDf_SET
#define READ_TOTAL_LIMIT_THRESHOLDr BCM53600_A0_READ_TOTAL_LIMIT_THRESHOLDr
#define WRITE_TOTAL_LIMIT_THRESHOLDr BCM53600_A0_WRITE_TOTAL_LIMIT_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TOTAL_LIMIT_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TOTAL_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     Total Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_PROT_ON_TH The Global Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr 0x00000a12

#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t total_protection_on_threshold[1];
	uint32_t _total_protection_on_threshold;
} BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_CLR(r) (r).total_protection_on_threshold[0] = 0
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).total_protection_on_threshold[0] = d
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_GET(r) (r).total_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_TOTAL_PROT_ON_THf_GET(r) (((r).total_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_TOTAL_PROT_ON_THf_SET(r,f) (r).total_protection_on_threshold[0]=(((r).total_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).total_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).total_protection_on_threshold[0]=(((r).total_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TOTAL_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TOTAL_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr,(r._total_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TOTAL_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr,&(r._total_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_PROTECTION_ON_THRESHOLDr BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr
#define TOTAL_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_t TOTAL_PROTECTION_ON_THRESHOLDr_t;
#define TOTAL_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_CLR
#define TOTAL_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_SET
#define TOTAL_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_GET
#define TOTAL_PROTECTION_ON_THRESHOLDr_TOTAL_PROT_ON_THf_GET BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_TOTAL_PROT_ON_THf_GET
#define TOTAL_PROTECTION_ON_THRESHOLDr_TOTAL_PROT_ON_THf_SET BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_TOTAL_PROT_ON_THf_SET
#define TOTAL_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TOTAL_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TOTAL_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TOTAL_PROTECTION_ON_THRESHOLDr
#define WRITE_TOTAL_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TOTAL_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TOTAL_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TOTAL_REGION_STATUS
 * BLOCKS:   SYS
 * DESC:     Total Region Status Register
 * SIZE:     8
 * FIELDS:
 *     TOTAL_REGION_STAT The global region status.00 = In Un-Congestion status.01 = In Congestion status.10 = In Protection status.11 = Reserved.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TOTAL_REGION_STATUSr 0x00000a16

#define BCM53600_A0_TOTAL_REGION_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program TOTAL_REGION_STATUS.
 *
 */
typedef union BCM53600_A0_TOTAL_REGION_STATUSr_s {
	uint32_t v[1];
	uint32_t total_region_status[1];
	uint32_t _total_region_status;
} BCM53600_A0_TOTAL_REGION_STATUSr_t;

#define BCM53600_A0_TOTAL_REGION_STATUSr_CLR(r) (r).total_region_status[0] = 0
#define BCM53600_A0_TOTAL_REGION_STATUSr_SET(r,d) (r).total_region_status[0] = d
#define BCM53600_A0_TOTAL_REGION_STATUSr_GET(r) (r).total_region_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TOTAL_REGION_STATUSr_TOTAL_REGION_STATf_GET(r) (((r).total_region_status[0]) & 0x3)
#define BCM53600_A0_TOTAL_REGION_STATUSr_TOTAL_REGION_STATf_SET(r,f) (r).total_region_status[0]=(((r).total_region_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53600_A0_TOTAL_REGION_STATUSr_RESERVEDf_GET(r) ((((r).total_region_status[0]) >> 2) & 0x3f)
#define BCM53600_A0_TOTAL_REGION_STATUSr_RESERVEDf_SET(r,f) (r).total_region_status[0]=(((r).total_region_status[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access TOTAL_REGION_STATUS.
 *
 */
#define BCM53600_A0_READ_TOTAL_REGION_STATUSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TOTAL_REGION_STATUSr,(r._total_region_status),1)
#define BCM53600_A0_WRITE_TOTAL_REGION_STATUSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TOTAL_REGION_STATUSr,&(r._total_region_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_REGION_STATUSr BCM53600_A0_TOTAL_REGION_STATUSr
#define TOTAL_REGION_STATUSr_SIZE BCM53600_A0_TOTAL_REGION_STATUSr_SIZE
typedef BCM53600_A0_TOTAL_REGION_STATUSr_t TOTAL_REGION_STATUSr_t;
#define TOTAL_REGION_STATUSr_CLR BCM53600_A0_TOTAL_REGION_STATUSr_CLR
#define TOTAL_REGION_STATUSr_SET BCM53600_A0_TOTAL_REGION_STATUSr_SET
#define TOTAL_REGION_STATUSr_GET BCM53600_A0_TOTAL_REGION_STATUSr_GET
#define TOTAL_REGION_STATUSr_TOTAL_REGION_STATf_GET BCM53600_A0_TOTAL_REGION_STATUSr_TOTAL_REGION_STATf_GET
#define TOTAL_REGION_STATUSr_TOTAL_REGION_STATf_SET BCM53600_A0_TOTAL_REGION_STATUSr_TOTAL_REGION_STATf_SET
#define TOTAL_REGION_STATUSr_RESERVEDf_GET BCM53600_A0_TOTAL_REGION_STATUSr_RESERVEDf_GET
#define TOTAL_REGION_STATUSr_RESERVEDf_SET BCM53600_A0_TOTAL_REGION_STATUSr_RESERVEDf_SET
#define READ_TOTAL_REGION_STATUSr BCM53600_A0_READ_TOTAL_REGION_STATUSr
#define WRITE_TOTAL_REGION_STATUSr BCM53600_A0_WRITE_TOTAL_REGION_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TOTAL_REGION_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_00_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 0 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP   	trunk port mapping setting.	(max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_00_CTLr 0x00003110

#define BCM53600_A0_TRUNK_GRP_00_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_00_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_00_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_00_ctl[1];
	uint32_t _trunk_grp_00_ctl;
} BCM53600_A0_TRUNK_GRP_00_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_00_CTLr_CLR(r) (r).trunk_grp_00_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_00_CTLr_SET(r,d) (r).trunk_grp_00_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_00_CTLr_GET(r) (r).trunk_grp_00_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_00_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_00_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_00_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_00_ctl[0]=(((r).trunk_grp_00_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_00_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_00_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_00_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_00_ctl[0]=(((r).trunk_grp_00_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_00_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_00_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_00_CTLr,(r._trunk_grp_00_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_00_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_00_CTLr,&(r._trunk_grp_00_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_00_CTLr BCM53600_A0_TRUNK_GRP_00_CTLr
#define TRUNK_GRP_00_CTLr_SIZE BCM53600_A0_TRUNK_GRP_00_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_00_CTLr_t TRUNK_GRP_00_CTLr_t;
#define TRUNK_GRP_00_CTLr_CLR BCM53600_A0_TRUNK_GRP_00_CTLr_CLR
#define TRUNK_GRP_00_CTLr_SET BCM53600_A0_TRUNK_GRP_00_CTLr_SET
#define TRUNK_GRP_00_CTLr_GET BCM53600_A0_TRUNK_GRP_00_CTLr_GET
#define TRUNK_GRP_00_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_00_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_00_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_00_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_00_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_00_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_00_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_00_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_00_CTLr BCM53600_A0_READ_TRUNK_GRP_00_CTLr
#define WRITE_TRUNK_GRP_00_CTLr BCM53600_A0_WRITE_TRUNK_GRP_00_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_00_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_01_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 1 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_01_CTLr 0x00003118

#define BCM53600_A0_TRUNK_GRP_01_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_01_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_01_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_01_ctl[1];
	uint32_t _trunk_grp_01_ctl;
} BCM53600_A0_TRUNK_GRP_01_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_01_CTLr_CLR(r) (r).trunk_grp_01_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_01_CTLr_SET(r,d) (r).trunk_grp_01_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_01_CTLr_GET(r) (r).trunk_grp_01_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_01_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_01_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_01_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_01_ctl[0]=(((r).trunk_grp_01_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_01_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_01_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_01_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_01_ctl[0]=(((r).trunk_grp_01_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_01_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_01_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_01_CTLr,(r._trunk_grp_01_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_01_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_01_CTLr,&(r._trunk_grp_01_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_01_CTLr BCM53600_A0_TRUNK_GRP_01_CTLr
#define TRUNK_GRP_01_CTLr_SIZE BCM53600_A0_TRUNK_GRP_01_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_01_CTLr_t TRUNK_GRP_01_CTLr_t;
#define TRUNK_GRP_01_CTLr_CLR BCM53600_A0_TRUNK_GRP_01_CTLr_CLR
#define TRUNK_GRP_01_CTLr_SET BCM53600_A0_TRUNK_GRP_01_CTLr_SET
#define TRUNK_GRP_01_CTLr_GET BCM53600_A0_TRUNK_GRP_01_CTLr_GET
#define TRUNK_GRP_01_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_01_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_01_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_01_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_01_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_01_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_01_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_01_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_01_CTLr BCM53600_A0_READ_TRUNK_GRP_01_CTLr
#define WRITE_TRUNK_GRP_01_CTLr BCM53600_A0_WRITE_TRUNK_GRP_01_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_01_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_02_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 2 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_02_CTLr 0x00003120

#define BCM53600_A0_TRUNK_GRP_02_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_02_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_02_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_02_ctl[1];
	uint32_t _trunk_grp_02_ctl;
} BCM53600_A0_TRUNK_GRP_02_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_02_CTLr_CLR(r) (r).trunk_grp_02_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_02_CTLr_SET(r,d) (r).trunk_grp_02_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_02_CTLr_GET(r) (r).trunk_grp_02_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_02_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_02_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_02_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_02_ctl[0]=(((r).trunk_grp_02_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_02_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_02_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_02_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_02_ctl[0]=(((r).trunk_grp_02_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_02_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_02_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_02_CTLr,(r._trunk_grp_02_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_02_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_02_CTLr,&(r._trunk_grp_02_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_02_CTLr BCM53600_A0_TRUNK_GRP_02_CTLr
#define TRUNK_GRP_02_CTLr_SIZE BCM53600_A0_TRUNK_GRP_02_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_02_CTLr_t TRUNK_GRP_02_CTLr_t;
#define TRUNK_GRP_02_CTLr_CLR BCM53600_A0_TRUNK_GRP_02_CTLr_CLR
#define TRUNK_GRP_02_CTLr_SET BCM53600_A0_TRUNK_GRP_02_CTLr_SET
#define TRUNK_GRP_02_CTLr_GET BCM53600_A0_TRUNK_GRP_02_CTLr_GET
#define TRUNK_GRP_02_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_02_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_02_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_02_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_02_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_02_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_02_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_02_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_02_CTLr BCM53600_A0_READ_TRUNK_GRP_02_CTLr
#define WRITE_TRUNK_GRP_02_CTLr BCM53600_A0_WRITE_TRUNK_GRP_02_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_02_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_03_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 3 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_03_CTLr 0x00003128

#define BCM53600_A0_TRUNK_GRP_03_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_03_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_03_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_03_ctl[1];
	uint32_t _trunk_grp_03_ctl;
} BCM53600_A0_TRUNK_GRP_03_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_03_CTLr_CLR(r) (r).trunk_grp_03_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_03_CTLr_SET(r,d) (r).trunk_grp_03_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_03_CTLr_GET(r) (r).trunk_grp_03_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_03_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_03_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_03_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_03_ctl[0]=(((r).trunk_grp_03_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_03_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_03_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_03_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_03_ctl[0]=(((r).trunk_grp_03_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_03_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_03_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_03_CTLr,(r._trunk_grp_03_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_03_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_03_CTLr,&(r._trunk_grp_03_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_03_CTLr BCM53600_A0_TRUNK_GRP_03_CTLr
#define TRUNK_GRP_03_CTLr_SIZE BCM53600_A0_TRUNK_GRP_03_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_03_CTLr_t TRUNK_GRP_03_CTLr_t;
#define TRUNK_GRP_03_CTLr_CLR BCM53600_A0_TRUNK_GRP_03_CTLr_CLR
#define TRUNK_GRP_03_CTLr_SET BCM53600_A0_TRUNK_GRP_03_CTLr_SET
#define TRUNK_GRP_03_CTLr_GET BCM53600_A0_TRUNK_GRP_03_CTLr_GET
#define TRUNK_GRP_03_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_03_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_03_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_03_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_03_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_03_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_03_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_03_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_03_CTLr BCM53600_A0_READ_TRUNK_GRP_03_CTLr
#define WRITE_TRUNK_GRP_03_CTLr BCM53600_A0_WRITE_TRUNK_GRP_03_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_03_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_04_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 4 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_04_CTLr 0x00003130

#define BCM53600_A0_TRUNK_GRP_04_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_04_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_04_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_04_ctl[1];
	uint32_t _trunk_grp_04_ctl;
} BCM53600_A0_TRUNK_GRP_04_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_04_CTLr_CLR(r) (r).trunk_grp_04_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_04_CTLr_SET(r,d) (r).trunk_grp_04_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_04_CTLr_GET(r) (r).trunk_grp_04_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_04_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_04_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_04_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_04_ctl[0]=(((r).trunk_grp_04_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_04_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_04_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_04_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_04_ctl[0]=(((r).trunk_grp_04_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_04_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_04_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_04_CTLr,(r._trunk_grp_04_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_04_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_04_CTLr,&(r._trunk_grp_04_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_04_CTLr BCM53600_A0_TRUNK_GRP_04_CTLr
#define TRUNK_GRP_04_CTLr_SIZE BCM53600_A0_TRUNK_GRP_04_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_04_CTLr_t TRUNK_GRP_04_CTLr_t;
#define TRUNK_GRP_04_CTLr_CLR BCM53600_A0_TRUNK_GRP_04_CTLr_CLR
#define TRUNK_GRP_04_CTLr_SET BCM53600_A0_TRUNK_GRP_04_CTLr_SET
#define TRUNK_GRP_04_CTLr_GET BCM53600_A0_TRUNK_GRP_04_CTLr_GET
#define TRUNK_GRP_04_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_04_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_04_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_04_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_04_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_04_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_04_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_04_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_04_CTLr BCM53600_A0_READ_TRUNK_GRP_04_CTLr
#define WRITE_TRUNK_GRP_04_CTLr BCM53600_A0_WRITE_TRUNK_GRP_04_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_04_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_05_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 5 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_05_CTLr 0x00003138

#define BCM53600_A0_TRUNK_GRP_05_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_05_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_05_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_05_ctl[1];
	uint32_t _trunk_grp_05_ctl;
} BCM53600_A0_TRUNK_GRP_05_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_05_CTLr_CLR(r) (r).trunk_grp_05_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_05_CTLr_SET(r,d) (r).trunk_grp_05_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_05_CTLr_GET(r) (r).trunk_grp_05_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_05_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_05_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_05_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_05_ctl[0]=(((r).trunk_grp_05_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_05_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_05_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_05_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_05_ctl[0]=(((r).trunk_grp_05_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_05_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_05_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_05_CTLr,(r._trunk_grp_05_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_05_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_05_CTLr,&(r._trunk_grp_05_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_05_CTLr BCM53600_A0_TRUNK_GRP_05_CTLr
#define TRUNK_GRP_05_CTLr_SIZE BCM53600_A0_TRUNK_GRP_05_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_05_CTLr_t TRUNK_GRP_05_CTLr_t;
#define TRUNK_GRP_05_CTLr_CLR BCM53600_A0_TRUNK_GRP_05_CTLr_CLR
#define TRUNK_GRP_05_CTLr_SET BCM53600_A0_TRUNK_GRP_05_CTLr_SET
#define TRUNK_GRP_05_CTLr_GET BCM53600_A0_TRUNK_GRP_05_CTLr_GET
#define TRUNK_GRP_05_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_05_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_05_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_05_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_05_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_05_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_05_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_05_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_05_CTLr BCM53600_A0_READ_TRUNK_GRP_05_CTLr
#define WRITE_TRUNK_GRP_05_CTLr BCM53600_A0_WRITE_TRUNK_GRP_05_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_05_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_06_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 6 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_06_CTLr 0x00003140

#define BCM53600_A0_TRUNK_GRP_06_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_06_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_06_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_06_ctl[1];
	uint32_t _trunk_grp_06_ctl;
} BCM53600_A0_TRUNK_GRP_06_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_06_CTLr_CLR(r) (r).trunk_grp_06_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_06_CTLr_SET(r,d) (r).trunk_grp_06_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_06_CTLr_GET(r) (r).trunk_grp_06_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_06_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_06_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_06_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_06_ctl[0]=(((r).trunk_grp_06_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_06_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_06_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_06_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_06_ctl[0]=(((r).trunk_grp_06_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_06_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_06_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_06_CTLr,(r._trunk_grp_06_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_06_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_06_CTLr,&(r._trunk_grp_06_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_06_CTLr BCM53600_A0_TRUNK_GRP_06_CTLr
#define TRUNK_GRP_06_CTLr_SIZE BCM53600_A0_TRUNK_GRP_06_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_06_CTLr_t TRUNK_GRP_06_CTLr_t;
#define TRUNK_GRP_06_CTLr_CLR BCM53600_A0_TRUNK_GRP_06_CTLr_CLR
#define TRUNK_GRP_06_CTLr_SET BCM53600_A0_TRUNK_GRP_06_CTLr_SET
#define TRUNK_GRP_06_CTLr_GET BCM53600_A0_TRUNK_GRP_06_CTLr_GET
#define TRUNK_GRP_06_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_06_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_06_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_06_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_06_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_06_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_06_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_06_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_06_CTLr BCM53600_A0_READ_TRUNK_GRP_06_CTLr
#define WRITE_TRUNK_GRP_06_CTLr BCM53600_A0_WRITE_TRUNK_GRP_06_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_06_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_07_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 7 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_07_CTLr 0x00003148

#define BCM53600_A0_TRUNK_GRP_07_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_07_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_07_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_07_ctl[1];
	uint32_t _trunk_grp_07_ctl;
} BCM53600_A0_TRUNK_GRP_07_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_07_CTLr_CLR(r) (r).trunk_grp_07_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_07_CTLr_SET(r,d) (r).trunk_grp_07_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_07_CTLr_GET(r) (r).trunk_grp_07_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_07_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_07_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_07_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_07_ctl[0]=(((r).trunk_grp_07_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_07_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_07_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_07_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_07_ctl[0]=(((r).trunk_grp_07_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_07_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_07_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_07_CTLr,(r._trunk_grp_07_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_07_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_07_CTLr,&(r._trunk_grp_07_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_07_CTLr BCM53600_A0_TRUNK_GRP_07_CTLr
#define TRUNK_GRP_07_CTLr_SIZE BCM53600_A0_TRUNK_GRP_07_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_07_CTLr_t TRUNK_GRP_07_CTLr_t;
#define TRUNK_GRP_07_CTLr_CLR BCM53600_A0_TRUNK_GRP_07_CTLr_CLR
#define TRUNK_GRP_07_CTLr_SET BCM53600_A0_TRUNK_GRP_07_CTLr_SET
#define TRUNK_GRP_07_CTLr_GET BCM53600_A0_TRUNK_GRP_07_CTLr_GET
#define TRUNK_GRP_07_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_07_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_07_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_07_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_07_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_07_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_07_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_07_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_07_CTLr BCM53600_A0_READ_TRUNK_GRP_07_CTLr
#define WRITE_TRUNK_GRP_07_CTLr BCM53600_A0_WRITE_TRUNK_GRP_07_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_07_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_08_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 8 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_08_CTLr 0x00003150

#define BCM53600_A0_TRUNK_GRP_08_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_08_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_08_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_08_ctl[1];
	uint32_t _trunk_grp_08_ctl;
} BCM53600_A0_TRUNK_GRP_08_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_08_CTLr_CLR(r) (r).trunk_grp_08_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_08_CTLr_SET(r,d) (r).trunk_grp_08_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_08_CTLr_GET(r) (r).trunk_grp_08_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_08_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_08_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_08_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_08_ctl[0]=(((r).trunk_grp_08_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_08_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_08_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_08_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_08_ctl[0]=(((r).trunk_grp_08_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_08_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_08_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_08_CTLr,(r._trunk_grp_08_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_08_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_08_CTLr,&(r._trunk_grp_08_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_08_CTLr BCM53600_A0_TRUNK_GRP_08_CTLr
#define TRUNK_GRP_08_CTLr_SIZE BCM53600_A0_TRUNK_GRP_08_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_08_CTLr_t TRUNK_GRP_08_CTLr_t;
#define TRUNK_GRP_08_CTLr_CLR BCM53600_A0_TRUNK_GRP_08_CTLr_CLR
#define TRUNK_GRP_08_CTLr_SET BCM53600_A0_TRUNK_GRP_08_CTLr_SET
#define TRUNK_GRP_08_CTLr_GET BCM53600_A0_TRUNK_GRP_08_CTLr_GET
#define TRUNK_GRP_08_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_08_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_08_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_08_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_08_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_08_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_08_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_08_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_08_CTLr BCM53600_A0_READ_TRUNK_GRP_08_CTLr
#define WRITE_TRUNK_GRP_08_CTLr BCM53600_A0_WRITE_TRUNK_GRP_08_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_08_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_09_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 9 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_09_CTLr 0x00003158

#define BCM53600_A0_TRUNK_GRP_09_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_09_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_09_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_09_ctl[1];
	uint32_t _trunk_grp_09_ctl;
} BCM53600_A0_TRUNK_GRP_09_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_09_CTLr_CLR(r) (r).trunk_grp_09_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_09_CTLr_SET(r,d) (r).trunk_grp_09_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_09_CTLr_GET(r) (r).trunk_grp_09_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_09_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_09_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_09_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_09_ctl[0]=(((r).trunk_grp_09_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_09_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_09_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_09_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_09_ctl[0]=(((r).trunk_grp_09_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_09_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_09_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_09_CTLr,(r._trunk_grp_09_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_09_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_09_CTLr,&(r._trunk_grp_09_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_09_CTLr BCM53600_A0_TRUNK_GRP_09_CTLr
#define TRUNK_GRP_09_CTLr_SIZE BCM53600_A0_TRUNK_GRP_09_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_09_CTLr_t TRUNK_GRP_09_CTLr_t;
#define TRUNK_GRP_09_CTLr_CLR BCM53600_A0_TRUNK_GRP_09_CTLr_CLR
#define TRUNK_GRP_09_CTLr_SET BCM53600_A0_TRUNK_GRP_09_CTLr_SET
#define TRUNK_GRP_09_CTLr_GET BCM53600_A0_TRUNK_GRP_09_CTLr_GET
#define TRUNK_GRP_09_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_09_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_09_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_09_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_09_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_09_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_09_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_09_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_09_CTLr BCM53600_A0_READ_TRUNK_GRP_09_CTLr
#define WRITE_TRUNK_GRP_09_CTLr BCM53600_A0_WRITE_TRUNK_GRP_09_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_09_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_10_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 10 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_10_CTLr 0x00003160

#define BCM53600_A0_TRUNK_GRP_10_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_10_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_10_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_10_ctl[1];
	uint32_t _trunk_grp_10_ctl;
} BCM53600_A0_TRUNK_GRP_10_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_10_CTLr_CLR(r) (r).trunk_grp_10_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_10_CTLr_SET(r,d) (r).trunk_grp_10_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_10_CTLr_GET(r) (r).trunk_grp_10_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_10_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_10_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_10_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_10_ctl[0]=(((r).trunk_grp_10_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_10_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_10_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_10_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_10_ctl[0]=(((r).trunk_grp_10_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_10_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_10_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_10_CTLr,(r._trunk_grp_10_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_10_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_10_CTLr,&(r._trunk_grp_10_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_10_CTLr BCM53600_A0_TRUNK_GRP_10_CTLr
#define TRUNK_GRP_10_CTLr_SIZE BCM53600_A0_TRUNK_GRP_10_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_10_CTLr_t TRUNK_GRP_10_CTLr_t;
#define TRUNK_GRP_10_CTLr_CLR BCM53600_A0_TRUNK_GRP_10_CTLr_CLR
#define TRUNK_GRP_10_CTLr_SET BCM53600_A0_TRUNK_GRP_10_CTLr_SET
#define TRUNK_GRP_10_CTLr_GET BCM53600_A0_TRUNK_GRP_10_CTLr_GET
#define TRUNK_GRP_10_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_10_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_10_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_10_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_10_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_10_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_10_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_10_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_10_CTLr BCM53600_A0_READ_TRUNK_GRP_10_CTLr
#define WRITE_TRUNK_GRP_10_CTLr BCM53600_A0_WRITE_TRUNK_GRP_10_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_10_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_11_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 11 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_11_CTLr 0x00003168

#define BCM53600_A0_TRUNK_GRP_11_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_11_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_11_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_11_ctl[1];
	uint32_t _trunk_grp_11_ctl;
} BCM53600_A0_TRUNK_GRP_11_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_11_CTLr_CLR(r) (r).trunk_grp_11_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_11_CTLr_SET(r,d) (r).trunk_grp_11_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_11_CTLr_GET(r) (r).trunk_grp_11_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_11_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_11_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_11_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_11_ctl[0]=(((r).trunk_grp_11_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_11_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_11_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_11_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_11_ctl[0]=(((r).trunk_grp_11_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_11_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_11_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_11_CTLr,(r._trunk_grp_11_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_11_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_11_CTLr,&(r._trunk_grp_11_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_11_CTLr BCM53600_A0_TRUNK_GRP_11_CTLr
#define TRUNK_GRP_11_CTLr_SIZE BCM53600_A0_TRUNK_GRP_11_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_11_CTLr_t TRUNK_GRP_11_CTLr_t;
#define TRUNK_GRP_11_CTLr_CLR BCM53600_A0_TRUNK_GRP_11_CTLr_CLR
#define TRUNK_GRP_11_CTLr_SET BCM53600_A0_TRUNK_GRP_11_CTLr_SET
#define TRUNK_GRP_11_CTLr_GET BCM53600_A0_TRUNK_GRP_11_CTLr_GET
#define TRUNK_GRP_11_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_11_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_11_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_11_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_11_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_11_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_11_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_11_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_11_CTLr BCM53600_A0_READ_TRUNK_GRP_11_CTLr
#define WRITE_TRUNK_GRP_11_CTLr BCM53600_A0_WRITE_TRUNK_GRP_11_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_11_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_12_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 12 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_12_CTLr 0x00003170

#define BCM53600_A0_TRUNK_GRP_12_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_12_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_12_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_12_ctl[1];
	uint32_t _trunk_grp_12_ctl;
} BCM53600_A0_TRUNK_GRP_12_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_12_CTLr_CLR(r) (r).trunk_grp_12_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_12_CTLr_SET(r,d) (r).trunk_grp_12_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_12_CTLr_GET(r) (r).trunk_grp_12_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_12_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_12_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_12_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_12_ctl[0]=(((r).trunk_grp_12_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_12_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_12_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_12_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_12_ctl[0]=(((r).trunk_grp_12_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_12_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_12_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_12_CTLr,(r._trunk_grp_12_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_12_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_12_CTLr,&(r._trunk_grp_12_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_12_CTLr BCM53600_A0_TRUNK_GRP_12_CTLr
#define TRUNK_GRP_12_CTLr_SIZE BCM53600_A0_TRUNK_GRP_12_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_12_CTLr_t TRUNK_GRP_12_CTLr_t;
#define TRUNK_GRP_12_CTLr_CLR BCM53600_A0_TRUNK_GRP_12_CTLr_CLR
#define TRUNK_GRP_12_CTLr_SET BCM53600_A0_TRUNK_GRP_12_CTLr_SET
#define TRUNK_GRP_12_CTLr_GET BCM53600_A0_TRUNK_GRP_12_CTLr_GET
#define TRUNK_GRP_12_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_12_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_12_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_12_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_12_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_12_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_12_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_12_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_12_CTLr BCM53600_A0_READ_TRUNK_GRP_12_CTLr
#define WRITE_TRUNK_GRP_12_CTLr BCM53600_A0_WRITE_TRUNK_GRP_12_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_12_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUNK_GRP_13_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 13 Port Register
 * SIZE:     32
 * FIELDS:
 *     TRUNK_PORT_MAP           trunk port mapping setting.        (max 8 ports on one trunk group)
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUNK_GRP_13_CTLr 0x00003178

#define BCM53600_A0_TRUNK_GRP_13_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_GRP_13_CTL.
 *
 */
typedef union BCM53600_A0_TRUNK_GRP_13_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_13_ctl[1];
	uint32_t _trunk_grp_13_ctl;
} BCM53600_A0_TRUNK_GRP_13_CTLr_t;

#define BCM53600_A0_TRUNK_GRP_13_CTLr_CLR(r) (r).trunk_grp_13_ctl[0] = 0
#define BCM53600_A0_TRUNK_GRP_13_CTLr_SET(r,d) (r).trunk_grp_13_ctl[0] = d
#define BCM53600_A0_TRUNK_GRP_13_CTLr_GET(r) (r).trunk_grp_13_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUNK_GRP_13_CTLr_TRUNK_PORT_MAPf_GET(r) (((r).trunk_grp_13_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUNK_GRP_13_CTLr_TRUNK_PORT_MAPf_SET(r,f) (r).trunk_grp_13_ctl[0]=(((r).trunk_grp_13_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUNK_GRP_13_CTLr_RESERVED_1f_GET(r) ((((r).trunk_grp_13_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUNK_GRP_13_CTLr_RESERVED_1f_SET(r,f) (r).trunk_grp_13_ctl[0]=(((r).trunk_grp_13_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUNK_GRP_13_CTL.
 *
 */
#define BCM53600_A0_READ_TRUNK_GRP_13_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUNK_GRP_13_CTLr,(r._trunk_grp_13_ctl),4)
#define BCM53600_A0_WRITE_TRUNK_GRP_13_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUNK_GRP_13_CTLr,&(r._trunk_grp_13_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_13_CTLr BCM53600_A0_TRUNK_GRP_13_CTLr
#define TRUNK_GRP_13_CTLr_SIZE BCM53600_A0_TRUNK_GRP_13_CTLr_SIZE
typedef BCM53600_A0_TRUNK_GRP_13_CTLr_t TRUNK_GRP_13_CTLr_t;
#define TRUNK_GRP_13_CTLr_CLR BCM53600_A0_TRUNK_GRP_13_CTLr_CLR
#define TRUNK_GRP_13_CTLr_SET BCM53600_A0_TRUNK_GRP_13_CTLr_SET
#define TRUNK_GRP_13_CTLr_GET BCM53600_A0_TRUNK_GRP_13_CTLr_GET
#define TRUNK_GRP_13_CTLr_TRUNK_PORT_MAPf_GET BCM53600_A0_TRUNK_GRP_13_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_13_CTLr_TRUNK_PORT_MAPf_SET BCM53600_A0_TRUNK_GRP_13_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_13_CTLr_RESERVED_1f_GET BCM53600_A0_TRUNK_GRP_13_CTLr_RESERVED_1f_GET
#define TRUNK_GRP_13_CTLr_RESERVED_1f_SET BCM53600_A0_TRUNK_GRP_13_CTLr_RESERVED_1f_SET
#define READ_TRUNK_GRP_13_CTLr BCM53600_A0_READ_TRUNK_GRP_13_CTLr
#define WRITE_TRUNK_GRP_13_CTLr BCM53600_A0_WRITE_TRUNK_GRP_13_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUNK_GRP_13_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUST_C1P_CTL
 * BLOCKS:   SYS
 * DESC:     Trust C1P Control Register
 * SIZE:     32
 * FIELDS:
 *     TRUST_C1P        Customer PCP enable bit for per-port1). Trust_C1P control for "TC/DP/COS Mapping Process".Bits 0-23: FE ports,Bit 24: MII Port.Bit 25: Giga Port G0.Bit 26: Giga Port G1.Bit 27: Giga Port G2.Bit 28: Giga Port G3.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUST_C1P_CTLr 0x00003018

#define BCM53600_A0_TRUST_C1P_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUST_C1P_CTL.
 *
 */
typedef union BCM53600_A0_TRUST_C1P_CTLr_s {
	uint32_t v[1];
	uint32_t trust_c1p_ctl[1];
	uint32_t _trust_c1p_ctl;
} BCM53600_A0_TRUST_C1P_CTLr_t;

#define BCM53600_A0_TRUST_C1P_CTLr_CLR(r) (r).trust_c1p_ctl[0] = 0
#define BCM53600_A0_TRUST_C1P_CTLr_SET(r,d) (r).trust_c1p_ctl[0] = d
#define BCM53600_A0_TRUST_C1P_CTLr_GET(r) (r).trust_c1p_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUST_C1P_CTLr_TRUST_C1Pf_GET(r) (((r).trust_c1p_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUST_C1P_CTLr_TRUST_C1Pf_SET(r,f) (r).trust_c1p_ctl[0]=(((r).trust_c1p_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUST_C1P_CTLr_RESERVED_1f_GET(r) ((((r).trust_c1p_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUST_C1P_CTLr_RESERVED_1f_SET(r,f) (r).trust_c1p_ctl[0]=(((r).trust_c1p_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUST_C1P_CTL.
 *
 */
#define BCM53600_A0_READ_TRUST_C1P_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUST_C1P_CTLr,(r._trust_c1p_ctl),4)
#define BCM53600_A0_WRITE_TRUST_C1P_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUST_C1P_CTLr,&(r._trust_c1p_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUST_C1P_CTLr BCM53600_A0_TRUST_C1P_CTLr
#define TRUST_C1P_CTLr_SIZE BCM53600_A0_TRUST_C1P_CTLr_SIZE
typedef BCM53600_A0_TRUST_C1P_CTLr_t TRUST_C1P_CTLr_t;
#define TRUST_C1P_CTLr_CLR BCM53600_A0_TRUST_C1P_CTLr_CLR
#define TRUST_C1P_CTLr_SET BCM53600_A0_TRUST_C1P_CTLr_SET
#define TRUST_C1P_CTLr_GET BCM53600_A0_TRUST_C1P_CTLr_GET
#define TRUST_C1P_CTLr_TRUST_C1Pf_GET BCM53600_A0_TRUST_C1P_CTLr_TRUST_C1Pf_GET
#define TRUST_C1P_CTLr_TRUST_C1Pf_SET BCM53600_A0_TRUST_C1P_CTLr_TRUST_C1Pf_SET
#define TRUST_C1P_CTLr_RESERVED_1f_GET BCM53600_A0_TRUST_C1P_CTLr_RESERVED_1f_GET
#define TRUST_C1P_CTLr_RESERVED_1f_SET BCM53600_A0_TRUST_C1P_CTLr_RESERVED_1f_SET
#define READ_TRUST_C1P_CTLr BCM53600_A0_READ_TRUST_C1P_CTLr
#define WRITE_TRUST_C1P_CTLr BCM53600_A0_WRITE_TRUST_C1P_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUST_C1P_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUST_CVID
 * BLOCKS:   SYS
 * DESC:     Trust CVID Registers
 * SIZE:     32
 * FIELDS:
 *     TRUST_CVID       A 29-bit mask which selectively allows any port with its corresponding bit set,set to 1'b1 to trust the VID of the incoming customer tag.
 *     RESERVED_0       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_TRUST_CVIDr 0x00003410

#define BCM53600_A0_TRUST_CVIDr_SIZE 4

/*
 * This structure should be used to declare and program TRUST_CVID.
 *
 */
typedef union BCM53600_A0_TRUST_CVIDr_s {
	uint32_t v[1];
	uint32_t trust_cvid[1];
	uint32_t _trust_cvid;
} BCM53600_A0_TRUST_CVIDr_t;

#define BCM53600_A0_TRUST_CVIDr_CLR(r) (r).trust_cvid[0] = 0
#define BCM53600_A0_TRUST_CVIDr_SET(r,d) (r).trust_cvid[0] = d
#define BCM53600_A0_TRUST_CVIDr_GET(r) (r).trust_cvid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUST_CVIDr_TRUST_CVIDf_GET(r) (((r).trust_cvid[0]) & 0x1fffffff)
#define BCM53600_A0_TRUST_CVIDr_TRUST_CVIDf_SET(r,f) (r).trust_cvid[0]=(((r).trust_cvid[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUST_CVIDr_RESERVED_0f_GET(r) ((((r).trust_cvid[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUST_CVIDr_RESERVED_0f_SET(r,f) (r).trust_cvid[0]=(((r).trust_cvid[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUST_CVID.
 *
 */
#define BCM53600_A0_READ_TRUST_CVIDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUST_CVIDr,(r._trust_cvid),4)
#define BCM53600_A0_WRITE_TRUST_CVIDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUST_CVIDr,&(r._trust_cvid),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUST_CVIDr BCM53600_A0_TRUST_CVIDr
#define TRUST_CVIDr_SIZE BCM53600_A0_TRUST_CVIDr_SIZE
typedef BCM53600_A0_TRUST_CVIDr_t TRUST_CVIDr_t;
#define TRUST_CVIDr_CLR BCM53600_A0_TRUST_CVIDr_CLR
#define TRUST_CVIDr_SET BCM53600_A0_TRUST_CVIDr_SET
#define TRUST_CVIDr_GET BCM53600_A0_TRUST_CVIDr_GET
#define TRUST_CVIDr_TRUST_CVIDf_GET BCM53600_A0_TRUST_CVIDr_TRUST_CVIDf_GET
#define TRUST_CVIDr_TRUST_CVIDf_SET BCM53600_A0_TRUST_CVIDr_TRUST_CVIDf_SET
#define TRUST_CVIDr_RESERVED_0f_GET BCM53600_A0_TRUST_CVIDr_RESERVED_0f_GET
#define TRUST_CVIDr_RESERVED_0f_SET BCM53600_A0_TRUST_CVIDr_RESERVED_0f_SET
#define READ_TRUST_CVIDr BCM53600_A0_READ_TRUST_CVIDr
#define WRITE_TRUST_CVIDr BCM53600_A0_WRITE_TRUST_CVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUST_CVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUST_DSCP_CTL
 * BLOCKS:   SYS
 * DESC:     Trust DSCP Control Register
 * SIZE:     32
 * FIELDS:
 *     QOS_TOS_DIFF_EN  TOS/DifferServ QOS enable bit for per-port1). Trust_DSCP control for "TC/DP/COS Mapping Process".2). determineColorUsingLayer3 control for "Packet Color Determination Function".Bits 0-23: 10/100BASE-T ports,Bit 24: MII Port.Bit 25: Giga Port G0.Bit 26: Giga Port G1.Bit 27: Giga Port G2.Bit 28: Giga Port G3.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUST_DSCP_CTLr 0x00003020

#define BCM53600_A0_TRUST_DSCP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUST_DSCP_CTL.
 *
 */
typedef union BCM53600_A0_TRUST_DSCP_CTLr_s {
	uint32_t v[1];
	uint32_t trust_dscp_ctl[1];
	uint32_t _trust_dscp_ctl;
} BCM53600_A0_TRUST_DSCP_CTLr_t;

#define BCM53600_A0_TRUST_DSCP_CTLr_CLR(r) (r).trust_dscp_ctl[0] = 0
#define BCM53600_A0_TRUST_DSCP_CTLr_SET(r,d) (r).trust_dscp_ctl[0] = d
#define BCM53600_A0_TRUST_DSCP_CTLr_GET(r) (r).trust_dscp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUST_DSCP_CTLr_QOS_TOS_DIFF_ENf_GET(r) (((r).trust_dscp_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUST_DSCP_CTLr_QOS_TOS_DIFF_ENf_SET(r,f) (r).trust_dscp_ctl[0]=(((r).trust_dscp_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUST_DSCP_CTLr_RESERVED_1f_GET(r) ((((r).trust_dscp_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUST_DSCP_CTLr_RESERVED_1f_SET(r,f) (r).trust_dscp_ctl[0]=(((r).trust_dscp_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUST_DSCP_CTL.
 *
 */
#define BCM53600_A0_READ_TRUST_DSCP_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUST_DSCP_CTLr,(r._trust_dscp_ctl),4)
#define BCM53600_A0_WRITE_TRUST_DSCP_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUST_DSCP_CTLr,&(r._trust_dscp_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUST_DSCP_CTLr BCM53600_A0_TRUST_DSCP_CTLr
#define TRUST_DSCP_CTLr_SIZE BCM53600_A0_TRUST_DSCP_CTLr_SIZE
typedef BCM53600_A0_TRUST_DSCP_CTLr_t TRUST_DSCP_CTLr_t;
#define TRUST_DSCP_CTLr_CLR BCM53600_A0_TRUST_DSCP_CTLr_CLR
#define TRUST_DSCP_CTLr_SET BCM53600_A0_TRUST_DSCP_CTLr_SET
#define TRUST_DSCP_CTLr_GET BCM53600_A0_TRUST_DSCP_CTLr_GET
#define TRUST_DSCP_CTLr_QOS_TOS_DIFF_ENf_GET BCM53600_A0_TRUST_DSCP_CTLr_QOS_TOS_DIFF_ENf_GET
#define TRUST_DSCP_CTLr_QOS_TOS_DIFF_ENf_SET BCM53600_A0_TRUST_DSCP_CTLr_QOS_TOS_DIFF_ENf_SET
#define TRUST_DSCP_CTLr_RESERVED_1f_GET BCM53600_A0_TRUST_DSCP_CTLr_RESERVED_1f_GET
#define TRUST_DSCP_CTLr_RESERVED_1f_SET BCM53600_A0_TRUST_DSCP_CTLr_RESERVED_1f_SET
#define READ_TRUST_DSCP_CTLr BCM53600_A0_READ_TRUST_DSCP_CTLr
#define WRITE_TRUST_DSCP_CTLr BCM53600_A0_WRITE_TRUST_DSCP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUST_DSCP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TRUST_S1P_CTL
 * BLOCKS:   SYS
 * DESC:     Trust S1P Control Register
 * SIZE:     32
 * FIELDS:
 *     TRUST_S1P        Service PCP enable bit for per-port1). Trust_S1P control for "TC/DP/COS Mapping Process".Bits 0-23: FE ports,Bit 24: MII Port.Bit 25: Giga Port G0.Bit 26: Giga Port G1.Bit 27: Giga Port G2.Bit 28: Giga Port G3.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TRUST_S1P_CTLr 0x00003010

#define BCM53600_A0_TRUST_S1P_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TRUST_S1P_CTL.
 *
 */
typedef union BCM53600_A0_TRUST_S1P_CTLr_s {
	uint32_t v[1];
	uint32_t trust_s1p_ctl[1];
	uint32_t _trust_s1p_ctl;
} BCM53600_A0_TRUST_S1P_CTLr_t;

#define BCM53600_A0_TRUST_S1P_CTLr_CLR(r) (r).trust_s1p_ctl[0] = 0
#define BCM53600_A0_TRUST_S1P_CTLr_SET(r,d) (r).trust_s1p_ctl[0] = d
#define BCM53600_A0_TRUST_S1P_CTLr_GET(r) (r).trust_s1p_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TRUST_S1P_CTLr_TRUST_S1Pf_GET(r) (((r).trust_s1p_ctl[0]) & 0x1fffffff)
#define BCM53600_A0_TRUST_S1P_CTLr_TRUST_S1Pf_SET(r,f) (r).trust_s1p_ctl[0]=(((r).trust_s1p_ctl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_TRUST_S1P_CTLr_RESERVED_1f_GET(r) ((((r).trust_s1p_ctl[0]) >> 29) & 0x7)
#define BCM53600_A0_TRUST_S1P_CTLr_RESERVED_1f_SET(r,f) (r).trust_s1p_ctl[0]=(((r).trust_s1p_ctl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access TRUST_S1P_CTL.
 *
 */
#define BCM53600_A0_READ_TRUST_S1P_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TRUST_S1P_CTLr,(r._trust_s1p_ctl),4)
#define BCM53600_A0_WRITE_TRUST_S1P_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TRUST_S1P_CTLr,&(r._trust_s1p_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUST_S1P_CTLr BCM53600_A0_TRUST_S1P_CTLr
#define TRUST_S1P_CTLr_SIZE BCM53600_A0_TRUST_S1P_CTLr_SIZE
typedef BCM53600_A0_TRUST_S1P_CTLr_t TRUST_S1P_CTLr_t;
#define TRUST_S1P_CTLr_CLR BCM53600_A0_TRUST_S1P_CTLr_CLR
#define TRUST_S1P_CTLr_SET BCM53600_A0_TRUST_S1P_CTLr_SET
#define TRUST_S1P_CTLr_GET BCM53600_A0_TRUST_S1P_CTLr_GET
#define TRUST_S1P_CTLr_TRUST_S1Pf_GET BCM53600_A0_TRUST_S1P_CTLr_TRUST_S1Pf_GET
#define TRUST_S1P_CTLr_TRUST_S1Pf_SET BCM53600_A0_TRUST_S1P_CTLr_TRUST_S1Pf_SET
#define TRUST_S1P_CTLr_RESERVED_1f_GET BCM53600_A0_TRUST_S1P_CTLr_RESERVED_1f_GET
#define TRUST_S1P_CTLr_RESERVED_1f_SET BCM53600_A0_TRUST_S1P_CTLr_RESERVED_1f_SET
#define READ_TRUST_S1P_CTLr BCM53600_A0_READ_TRUST_S1P_CTLr
#define WRITE_TRUST_S1P_CTLr BCM53600_A0_WRITE_TRUST_S1P_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TRUST_S1P_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ0Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ0OCTETSr 0x00005258

#define BCM53600_A0_TXQQ0OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ0Octets.
 *
 */
typedef union BCM53600_A0_TXQQ0OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq0octets[2];
	uint32_t _txqq0octets;
} BCM53600_A0_TXQQ0OCTETSr_t;

#define BCM53600_A0_TXQQ0OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq0octets), 0, sizeof(BCM53600_A0_TXQQ0OCTETSr_t))
#define BCM53600_A0_TXQQ0OCTETSr_SET(r,i,d) (r).txqq0octets[i] = d
#define BCM53600_A0_TXQQ0OCTETSr_GET(r,i) (r).txqq0octets[i]


/*
 * These macros can be used to access TXQQ0Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ0OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ0OCTETSr,(r._txqq0octets),8)
#define BCM53600_A0_WRITE_TXQQ0OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ0OCTETSr,&(r._txqq0octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ0OCTETSr BCM53600_A0_TXQQ0OCTETSr
#define TXQQ0OCTETSr_SIZE BCM53600_A0_TXQQ0OCTETSr_SIZE
typedef BCM53600_A0_TXQQ0OCTETSr_t TXQQ0OCTETSr_t;
#define TXQQ0OCTETSr_CLR BCM53600_A0_TXQQ0OCTETSr_CLR
#define TXQQ0OCTETSr_SET BCM53600_A0_TXQQ0OCTETSr_SET
#define TXQQ0OCTETSr_GET BCM53600_A0_TXQQ0OCTETSr_GET
#define READ_TXQQ0OCTETSr BCM53600_A0_READ_TXQQ0OCTETSr
#define WRITE_TXQQ0OCTETSr BCM53600_A0_WRITE_TXQQ0OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ0OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ0Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ0PACKETr 0x00005254

#define BCM53600_A0_TXQQ0PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ0Packet.
 *
 */
typedef union BCM53600_A0_TXQQ0PACKETr_s {
	uint32_t v[1];
	uint32_t txqq0packet[1];
	uint32_t _txqq0packet;
} BCM53600_A0_TXQQ0PACKETr_t;

#define BCM53600_A0_TXQQ0PACKETr_CLR(r) (r).txqq0packet[0] = 0
#define BCM53600_A0_TXQQ0PACKETr_SET(r,d) (r).txqq0packet[0] = d
#define BCM53600_A0_TXQQ0PACKETr_GET(r) (r).txqq0packet[0]


/*
 * These macros can be used to access TXQQ0Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ0PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ0PACKETr,(r._txqq0packet),4)
#define BCM53600_A0_WRITE_TXQQ0PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ0PACKETr,&(r._txqq0packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ0PACKETr BCM53600_A0_TXQQ0PACKETr
#define TXQQ0PACKETr_SIZE BCM53600_A0_TXQQ0PACKETr_SIZE
typedef BCM53600_A0_TXQQ0PACKETr_t TXQQ0PACKETr_t;
#define TXQQ0PACKETr_CLR BCM53600_A0_TXQQ0PACKETr_CLR
#define TXQQ0PACKETr_SET BCM53600_A0_TXQQ0PACKETr_SET
#define TXQQ0PACKETr_GET BCM53600_A0_TXQQ0PACKETr_GET
#define READ_TXQQ0PACKETr BCM53600_A0_READ_TXQQ0PACKETr
#define WRITE_TXQQ0PACKETr BCM53600_A0_WRITE_TXQQ0PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ0PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ1Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ1OCTETSr 0x00005264

#define BCM53600_A0_TXQQ1OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ1Octets.
 *
 */
typedef union BCM53600_A0_TXQQ1OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq1octets[2];
	uint32_t _txqq1octets;
} BCM53600_A0_TXQQ1OCTETSr_t;

#define BCM53600_A0_TXQQ1OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq1octets), 0, sizeof(BCM53600_A0_TXQQ1OCTETSr_t))
#define BCM53600_A0_TXQQ1OCTETSr_SET(r,i,d) (r).txqq1octets[i] = d
#define BCM53600_A0_TXQQ1OCTETSr_GET(r,i) (r).txqq1octets[i]


/*
 * These macros can be used to access TXQQ1Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ1OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ1OCTETSr,(r._txqq1octets),8)
#define BCM53600_A0_WRITE_TXQQ1OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ1OCTETSr,&(r._txqq1octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ1OCTETSr BCM53600_A0_TXQQ1OCTETSr
#define TXQQ1OCTETSr_SIZE BCM53600_A0_TXQQ1OCTETSr_SIZE
typedef BCM53600_A0_TXQQ1OCTETSr_t TXQQ1OCTETSr_t;
#define TXQQ1OCTETSr_CLR BCM53600_A0_TXQQ1OCTETSr_CLR
#define TXQQ1OCTETSr_SET BCM53600_A0_TXQQ1OCTETSr_SET
#define TXQQ1OCTETSr_GET BCM53600_A0_TXQQ1OCTETSr_GET
#define READ_TXQQ1OCTETSr BCM53600_A0_READ_TXQQ1OCTETSr
#define WRITE_TXQQ1OCTETSr BCM53600_A0_WRITE_TXQQ1OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ1OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ1Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ1PACKETr 0x00005260

#define BCM53600_A0_TXQQ1PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ1Packet.
 *
 */
typedef union BCM53600_A0_TXQQ1PACKETr_s {
	uint32_t v[1];
	uint32_t txqq1packet[1];
	uint32_t _txqq1packet;
} BCM53600_A0_TXQQ1PACKETr_t;

#define BCM53600_A0_TXQQ1PACKETr_CLR(r) (r).txqq1packet[0] = 0
#define BCM53600_A0_TXQQ1PACKETr_SET(r,d) (r).txqq1packet[0] = d
#define BCM53600_A0_TXQQ1PACKETr_GET(r) (r).txqq1packet[0]


/*
 * These macros can be used to access TXQQ1Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ1PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ1PACKETr,(r._txqq1packet),4)
#define BCM53600_A0_WRITE_TXQQ1PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ1PACKETr,&(r._txqq1packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ1PACKETr BCM53600_A0_TXQQ1PACKETr
#define TXQQ1PACKETr_SIZE BCM53600_A0_TXQQ1PACKETr_SIZE
typedef BCM53600_A0_TXQQ1PACKETr_t TXQQ1PACKETr_t;
#define TXQQ1PACKETr_CLR BCM53600_A0_TXQQ1PACKETr_CLR
#define TXQQ1PACKETr_SET BCM53600_A0_TXQQ1PACKETr_SET
#define TXQQ1PACKETr_GET BCM53600_A0_TXQQ1PACKETr_GET
#define READ_TXQQ1PACKETr BCM53600_A0_READ_TXQQ1PACKETr
#define WRITE_TXQQ1PACKETr BCM53600_A0_WRITE_TXQQ1PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ1PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ2Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ2OCTETSr 0x00005270

#define BCM53600_A0_TXQQ2OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ2Octets.
 *
 */
typedef union BCM53600_A0_TXQQ2OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq2octets[2];
	uint32_t _txqq2octets;
} BCM53600_A0_TXQQ2OCTETSr_t;

#define BCM53600_A0_TXQQ2OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq2octets), 0, sizeof(BCM53600_A0_TXQQ2OCTETSr_t))
#define BCM53600_A0_TXQQ2OCTETSr_SET(r,i,d) (r).txqq2octets[i] = d
#define BCM53600_A0_TXQQ2OCTETSr_GET(r,i) (r).txqq2octets[i]


/*
 * These macros can be used to access TXQQ2Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ2OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ2OCTETSr,(r._txqq2octets),8)
#define BCM53600_A0_WRITE_TXQQ2OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ2OCTETSr,&(r._txqq2octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ2OCTETSr BCM53600_A0_TXQQ2OCTETSr
#define TXQQ2OCTETSr_SIZE BCM53600_A0_TXQQ2OCTETSr_SIZE
typedef BCM53600_A0_TXQQ2OCTETSr_t TXQQ2OCTETSr_t;
#define TXQQ2OCTETSr_CLR BCM53600_A0_TXQQ2OCTETSr_CLR
#define TXQQ2OCTETSr_SET BCM53600_A0_TXQQ2OCTETSr_SET
#define TXQQ2OCTETSr_GET BCM53600_A0_TXQQ2OCTETSr_GET
#define READ_TXQQ2OCTETSr BCM53600_A0_READ_TXQQ2OCTETSr
#define WRITE_TXQQ2OCTETSr BCM53600_A0_WRITE_TXQQ2OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ2OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ2Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ2PACKETr 0x0000526c

#define BCM53600_A0_TXQQ2PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ2Packet.
 *
 */
typedef union BCM53600_A0_TXQQ2PACKETr_s {
	uint32_t v[1];
	uint32_t txqq2packet[1];
	uint32_t _txqq2packet;
} BCM53600_A0_TXQQ2PACKETr_t;

#define BCM53600_A0_TXQQ2PACKETr_CLR(r) (r).txqq2packet[0] = 0
#define BCM53600_A0_TXQQ2PACKETr_SET(r,d) (r).txqq2packet[0] = d
#define BCM53600_A0_TXQQ2PACKETr_GET(r) (r).txqq2packet[0]


/*
 * These macros can be used to access TXQQ2Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ2PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ2PACKETr,(r._txqq2packet),4)
#define BCM53600_A0_WRITE_TXQQ2PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ2PACKETr,&(r._txqq2packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ2PACKETr BCM53600_A0_TXQQ2PACKETr
#define TXQQ2PACKETr_SIZE BCM53600_A0_TXQQ2PACKETr_SIZE
typedef BCM53600_A0_TXQQ2PACKETr_t TXQQ2PACKETr_t;
#define TXQQ2PACKETr_CLR BCM53600_A0_TXQQ2PACKETr_CLR
#define TXQQ2PACKETr_SET BCM53600_A0_TXQQ2PACKETr_SET
#define TXQQ2PACKETr_GET BCM53600_A0_TXQQ2PACKETr_GET
#define READ_TXQQ2PACKETr BCM53600_A0_READ_TXQQ2PACKETr
#define WRITE_TXQQ2PACKETr BCM53600_A0_WRITE_TXQQ2PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ2PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ3Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ3OCTETSr 0x0000527c

#define BCM53600_A0_TXQQ3OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ3Octets.
 *
 */
typedef union BCM53600_A0_TXQQ3OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq3octets[2];
	uint32_t _txqq3octets;
} BCM53600_A0_TXQQ3OCTETSr_t;

#define BCM53600_A0_TXQQ3OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq3octets), 0, sizeof(BCM53600_A0_TXQQ3OCTETSr_t))
#define BCM53600_A0_TXQQ3OCTETSr_SET(r,i,d) (r).txqq3octets[i] = d
#define BCM53600_A0_TXQQ3OCTETSr_GET(r,i) (r).txqq3octets[i]


/*
 * These macros can be used to access TXQQ3Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ3OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ3OCTETSr,(r._txqq3octets),8)
#define BCM53600_A0_WRITE_TXQQ3OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ3OCTETSr,&(r._txqq3octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ3OCTETSr BCM53600_A0_TXQQ3OCTETSr
#define TXQQ3OCTETSr_SIZE BCM53600_A0_TXQQ3OCTETSr_SIZE
typedef BCM53600_A0_TXQQ3OCTETSr_t TXQQ3OCTETSr_t;
#define TXQQ3OCTETSr_CLR BCM53600_A0_TXQQ3OCTETSr_CLR
#define TXQQ3OCTETSr_SET BCM53600_A0_TXQQ3OCTETSr_SET
#define TXQQ3OCTETSr_GET BCM53600_A0_TXQQ3OCTETSr_GET
#define READ_TXQQ3OCTETSr BCM53600_A0_READ_TXQQ3OCTETSr
#define WRITE_TXQQ3OCTETSr BCM53600_A0_WRITE_TXQQ3OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ3OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ3Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ3PACKETr 0x00005278

#define BCM53600_A0_TXQQ3PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ3Packet.
 *
 */
typedef union BCM53600_A0_TXQQ3PACKETr_s {
	uint32_t v[1];
	uint32_t txqq3packet[1];
	uint32_t _txqq3packet;
} BCM53600_A0_TXQQ3PACKETr_t;

#define BCM53600_A0_TXQQ3PACKETr_CLR(r) (r).txqq3packet[0] = 0
#define BCM53600_A0_TXQQ3PACKETr_SET(r,d) (r).txqq3packet[0] = d
#define BCM53600_A0_TXQQ3PACKETr_GET(r) (r).txqq3packet[0]


/*
 * These macros can be used to access TXQQ3Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ3PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ3PACKETr,(r._txqq3packet),4)
#define BCM53600_A0_WRITE_TXQQ3PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ3PACKETr,&(r._txqq3packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ3PACKETr BCM53600_A0_TXQQ3PACKETr
#define TXQQ3PACKETr_SIZE BCM53600_A0_TXQQ3PACKETr_SIZE
typedef BCM53600_A0_TXQQ3PACKETr_t TXQQ3PACKETr_t;
#define TXQQ3PACKETr_CLR BCM53600_A0_TXQQ3PACKETr_CLR
#define TXQQ3PACKETr_SET BCM53600_A0_TXQQ3PACKETr_SET
#define TXQQ3PACKETr_GET BCM53600_A0_TXQQ3PACKETr_GET
#define READ_TXQQ3PACKETr BCM53600_A0_READ_TXQQ3PACKETr
#define WRITE_TXQQ3PACKETr BCM53600_A0_WRITE_TXQQ3PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ3PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ4Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q4 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ4OCTETSr 0x00005288

#define BCM53600_A0_TXQQ4OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ4Octets.
 *
 */
typedef union BCM53600_A0_TXQQ4OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq4octets[2];
	uint32_t _txqq4octets;
} BCM53600_A0_TXQQ4OCTETSr_t;

#define BCM53600_A0_TXQQ4OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq4octets), 0, sizeof(BCM53600_A0_TXQQ4OCTETSr_t))
#define BCM53600_A0_TXQQ4OCTETSr_SET(r,i,d) (r).txqq4octets[i] = d
#define BCM53600_A0_TXQQ4OCTETSr_GET(r,i) (r).txqq4octets[i]


/*
 * These macros can be used to access TXQQ4Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ4OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ4OCTETSr,(r._txqq4octets),8)
#define BCM53600_A0_WRITE_TXQQ4OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ4OCTETSr,&(r._txqq4octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ4OCTETSr BCM53600_A0_TXQQ4OCTETSr
#define TXQQ4OCTETSr_SIZE BCM53600_A0_TXQQ4OCTETSr_SIZE
typedef BCM53600_A0_TXQQ4OCTETSr_t TXQQ4OCTETSr_t;
#define TXQQ4OCTETSr_CLR BCM53600_A0_TXQQ4OCTETSr_CLR
#define TXQQ4OCTETSr_SET BCM53600_A0_TXQQ4OCTETSr_SET
#define TXQQ4OCTETSr_GET BCM53600_A0_TXQQ4OCTETSr_GET
#define READ_TXQQ4OCTETSr BCM53600_A0_READ_TXQQ4OCTETSr
#define WRITE_TXQQ4OCTETSr BCM53600_A0_WRITE_TXQQ4OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ4OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ4Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ4PACKETr 0x00005284

#define BCM53600_A0_TXQQ4PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ4Packet.
 *
 */
typedef union BCM53600_A0_TXQQ4PACKETr_s {
	uint32_t v[1];
	uint32_t txqq4packet[1];
	uint32_t _txqq4packet;
} BCM53600_A0_TXQQ4PACKETr_t;

#define BCM53600_A0_TXQQ4PACKETr_CLR(r) (r).txqq4packet[0] = 0
#define BCM53600_A0_TXQQ4PACKETr_SET(r,d) (r).txqq4packet[0] = d
#define BCM53600_A0_TXQQ4PACKETr_GET(r) (r).txqq4packet[0]


/*
 * These macros can be used to access TXQQ4Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ4PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ4PACKETr,(r._txqq4packet),4)
#define BCM53600_A0_WRITE_TXQQ4PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ4PACKETr,&(r._txqq4packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ4PACKETr BCM53600_A0_TXQQ4PACKETr
#define TXQQ4PACKETr_SIZE BCM53600_A0_TXQQ4PACKETr_SIZE
typedef BCM53600_A0_TXQQ4PACKETr_t TXQQ4PACKETr_t;
#define TXQQ4PACKETr_CLR BCM53600_A0_TXQQ4PACKETr_CLR
#define TXQQ4PACKETr_SET BCM53600_A0_TXQQ4PACKETr_SET
#define TXQQ4PACKETr_GET BCM53600_A0_TXQQ4PACKETr_GET
#define READ_TXQQ4PACKETr BCM53600_A0_READ_TXQQ4PACKETr
#define WRITE_TXQQ4PACKETr BCM53600_A0_WRITE_TXQQ4PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ4PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ5Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q5 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ5OCTETSr 0x00005294

#define BCM53600_A0_TXQQ5OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ5Octets.
 *
 */
typedef union BCM53600_A0_TXQQ5OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq5octets[2];
	uint32_t _txqq5octets;
} BCM53600_A0_TXQQ5OCTETSr_t;

#define BCM53600_A0_TXQQ5OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq5octets), 0, sizeof(BCM53600_A0_TXQQ5OCTETSr_t))
#define BCM53600_A0_TXQQ5OCTETSr_SET(r,i,d) (r).txqq5octets[i] = d
#define BCM53600_A0_TXQQ5OCTETSr_GET(r,i) (r).txqq5octets[i]


/*
 * These macros can be used to access TXQQ5Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ5OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ5OCTETSr,(r._txqq5octets),8)
#define BCM53600_A0_WRITE_TXQQ5OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ5OCTETSr,&(r._txqq5octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ5OCTETSr BCM53600_A0_TXQQ5OCTETSr
#define TXQQ5OCTETSr_SIZE BCM53600_A0_TXQQ5OCTETSr_SIZE
typedef BCM53600_A0_TXQQ5OCTETSr_t TXQQ5OCTETSr_t;
#define TXQQ5OCTETSr_CLR BCM53600_A0_TXQQ5OCTETSr_CLR
#define TXQQ5OCTETSr_SET BCM53600_A0_TXQQ5OCTETSr_SET
#define TXQQ5OCTETSr_GET BCM53600_A0_TXQQ5OCTETSr_GET
#define READ_TXQQ5OCTETSr BCM53600_A0_READ_TXQQ5OCTETSr
#define WRITE_TXQQ5OCTETSr BCM53600_A0_WRITE_TXQQ5OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ5OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ5Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ5PACKETr 0x00005290

#define BCM53600_A0_TXQQ5PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ5Packet.
 *
 */
typedef union BCM53600_A0_TXQQ5PACKETr_s {
	uint32_t v[1];
	uint32_t txqq5packet[1];
	uint32_t _txqq5packet;
} BCM53600_A0_TXQQ5PACKETr_t;

#define BCM53600_A0_TXQQ5PACKETr_CLR(r) (r).txqq5packet[0] = 0
#define BCM53600_A0_TXQQ5PACKETr_SET(r,d) (r).txqq5packet[0] = d
#define BCM53600_A0_TXQQ5PACKETr_GET(r) (r).txqq5packet[0]


/*
 * These macros can be used to access TXQQ5Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ5PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ5PACKETr,(r._txqq5packet),4)
#define BCM53600_A0_WRITE_TXQQ5PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ5PACKETr,&(r._txqq5packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ5PACKETr BCM53600_A0_TXQQ5PACKETr
#define TXQQ5PACKETr_SIZE BCM53600_A0_TXQQ5PACKETr_SIZE
typedef BCM53600_A0_TXQQ5PACKETr_t TXQQ5PACKETr_t;
#define TXQQ5PACKETr_CLR BCM53600_A0_TXQQ5PACKETr_CLR
#define TXQQ5PACKETr_SET BCM53600_A0_TXQQ5PACKETr_SET
#define TXQQ5PACKETr_GET BCM53600_A0_TXQQ5PACKETr_GET
#define READ_TXQQ5PACKETr BCM53600_A0_READ_TXQQ5PACKETr
#define WRITE_TXQQ5PACKETr BCM53600_A0_WRITE_TXQQ5PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ5PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ6Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q6 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ6OCTETSr 0x000052a0

#define BCM53600_A0_TXQQ6OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ6Octets.
 *
 */
typedef union BCM53600_A0_TXQQ6OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq6octets[2];
	uint32_t _txqq6octets;
} BCM53600_A0_TXQQ6OCTETSr_t;

#define BCM53600_A0_TXQQ6OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq6octets), 0, sizeof(BCM53600_A0_TXQQ6OCTETSr_t))
#define BCM53600_A0_TXQQ6OCTETSr_SET(r,i,d) (r).txqq6octets[i] = d
#define BCM53600_A0_TXQQ6OCTETSr_GET(r,i) (r).txqq6octets[i]


/*
 * These macros can be used to access TXQQ6Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ6OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ6OCTETSr,(r._txqq6octets),8)
#define BCM53600_A0_WRITE_TXQQ6OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ6OCTETSr,&(r._txqq6octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ6OCTETSr BCM53600_A0_TXQQ6OCTETSr
#define TXQQ6OCTETSr_SIZE BCM53600_A0_TXQQ6OCTETSr_SIZE
typedef BCM53600_A0_TXQQ6OCTETSr_t TXQQ6OCTETSr_t;
#define TXQQ6OCTETSr_CLR BCM53600_A0_TXQQ6OCTETSr_CLR
#define TXQQ6OCTETSr_SET BCM53600_A0_TXQQ6OCTETSr_SET
#define TXQQ6OCTETSr_GET BCM53600_A0_TXQQ6OCTETSr_GET
#define READ_TXQQ6OCTETSr BCM53600_A0_READ_TXQQ6OCTETSr
#define WRITE_TXQQ6OCTETSr BCM53600_A0_WRITE_TXQQ6OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ6OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ6Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q6 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ6PACKETr 0x0000529c

#define BCM53600_A0_TXQQ6PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ6Packet.
 *
 */
typedef union BCM53600_A0_TXQQ6PACKETr_s {
	uint32_t v[1];
	uint32_t txqq6packet[1];
	uint32_t _txqq6packet;
} BCM53600_A0_TXQQ6PACKETr_t;

#define BCM53600_A0_TXQQ6PACKETr_CLR(r) (r).txqq6packet[0] = 0
#define BCM53600_A0_TXQQ6PACKETr_SET(r,d) (r).txqq6packet[0] = d
#define BCM53600_A0_TXQQ6PACKETr_GET(r) (r).txqq6packet[0]


/*
 * These macros can be used to access TXQQ6Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ6PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ6PACKETr,(r._txqq6packet),4)
#define BCM53600_A0_WRITE_TXQQ6PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ6PACKETr,&(r._txqq6packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ6PACKETr BCM53600_A0_TXQQ6PACKETr
#define TXQQ6PACKETr_SIZE BCM53600_A0_TXQQ6PACKETr_SIZE
typedef BCM53600_A0_TXQQ6PACKETr_t TXQQ6PACKETr_t;
#define TXQQ6PACKETr_CLR BCM53600_A0_TXQQ6PACKETr_CLR
#define TXQQ6PACKETr_SET BCM53600_A0_TXQQ6PACKETr_SET
#define TXQQ6PACKETr_GET BCM53600_A0_TXQQ6PACKETr_GET
#define READ_TXQQ6PACKETr BCM53600_A0_READ_TXQQ6PACKETr
#define WRITE_TXQQ6PACKETr BCM53600_A0_WRITE_TXQQ6PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ6PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ7Octets
 * BLOCKS:   SYS
 * DESC:     TXQ-Q7 Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ7OCTETSr 0x000052ac

#define BCM53600_A0_TXQQ7OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TXQQ7Octets.
 *
 */
typedef union BCM53600_A0_TXQQ7OCTETSr_s {
	uint32_t v[2];
	uint32_t txqq7octets[2];
	uint32_t _txqq7octets;
} BCM53600_A0_TXQQ7OCTETSr_t;

#define BCM53600_A0_TXQQ7OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqq7octets), 0, sizeof(BCM53600_A0_TXQQ7OCTETSr_t))
#define BCM53600_A0_TXQQ7OCTETSr_SET(r,i,d) (r).txqq7octets[i] = d
#define BCM53600_A0_TXQQ7OCTETSr_GET(r,i) (r).txqq7octets[i]


/*
 * These macros can be used to access TXQQ7Octets.
 *
 */
#define BCM53600_A0_READ_TXQQ7OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ7OCTETSr,(r._txqq7octets),8)
#define BCM53600_A0_WRITE_TXQQ7OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ7OCTETSr,&(r._txqq7octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ7OCTETSr BCM53600_A0_TXQQ7OCTETSr
#define TXQQ7OCTETSr_SIZE BCM53600_A0_TXQQ7OCTETSr_SIZE
typedef BCM53600_A0_TXQQ7OCTETSr_t TXQQ7OCTETSr_t;
#define TXQQ7OCTETSr_CLR BCM53600_A0_TXQQ7OCTETSr_CLR
#define TXQQ7OCTETSr_SET BCM53600_A0_TXQQ7OCTETSr_SET
#define TXQQ7OCTETSr_GET BCM53600_A0_TXQQ7OCTETSr_GET
#define READ_TXQQ7OCTETSr BCM53600_A0_READ_TXQQ7OCTETSr
#define WRITE_TXQQ7OCTETSr BCM53600_A0_WRITE_TXQQ7OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ7OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQ7Packet
 * BLOCKS:   SYS
 * DESC:     TXQ-Q7 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQ7PACKETr 0x000052a8

#define BCM53600_A0_TXQQ7PACKETr_SIZE 4

/*
 * This structure should be used to declare and program TXQQ7Packet.
 *
 */
typedef union BCM53600_A0_TXQQ7PACKETr_s {
	uint32_t v[1];
	uint32_t txqq7packet[1];
	uint32_t _txqq7packet;
} BCM53600_A0_TXQQ7PACKETr_t;

#define BCM53600_A0_TXQQ7PACKETr_CLR(r) (r).txqq7packet[0] = 0
#define BCM53600_A0_TXQQ7PACKETr_SET(r,d) (r).txqq7packet[0] = d
#define BCM53600_A0_TXQQ7PACKETr_GET(r) (r).txqq7packet[0]


/*
 * These macros can be used to access TXQQ7Packet.
 *
 */
#define BCM53600_A0_READ_TXQQ7PACKETr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQ7PACKETr,(r._txqq7packet),4)
#define BCM53600_A0_WRITE_TXQQ7PACKETr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQ7PACKETr,&(r._txqq7packet),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQ7PACKETr BCM53600_A0_TXQQ7PACKETr
#define TXQQ7PACKETr_SIZE BCM53600_A0_TXQQ7PACKETr_SIZE
typedef BCM53600_A0_TXQQ7PACKETr_t TXQQ7PACKETr_t;
#define TXQQ7PACKETr_CLR BCM53600_A0_TXQQ7PACKETr_CLR
#define TXQQ7PACKETr_SET BCM53600_A0_TXQQ7PACKETr_SET
#define TXQQ7PACKETr_GET BCM53600_A0_TXQQ7PACKETr_GET
#define READ_TXQQ7PACKETr BCM53600_A0_READ_TXQQ7PACKETr
#define WRITE_TXQQ7PACKETr BCM53600_A0_WRITE_TXQQ7PACKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQ7PACKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQSel0CongestionDrop
 * BLOCKS:   SYS
 * DESC:     TXQ_Q Select 0 Congestion Drop Packet Counter Register
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQSEL0CONGESTIONDROPr 0x000052b4

#define BCM53600_A0_TXQQSEL0CONGESTIONDROPr_SIZE 4

/*
 * This structure should be used to declare and program TXQQSel0CongestionDrop.
 *
 */
typedef union BCM53600_A0_TXQQSEL0CONGESTIONDROPr_s {
	uint32_t v[1];
	uint32_t txqqsel0congestiondrop[1];
	uint32_t _txqqsel0congestiondrop;
} BCM53600_A0_TXQQSEL0CONGESTIONDROPr_t;

#define BCM53600_A0_TXQQSEL0CONGESTIONDROPr_CLR(r) (r).txqqsel0congestiondrop[0] = 0
#define BCM53600_A0_TXQQSEL0CONGESTIONDROPr_SET(r,d) (r).txqqsel0congestiondrop[0] = d
#define BCM53600_A0_TXQQSEL0CONGESTIONDROPr_GET(r) (r).txqqsel0congestiondrop[0]


/*
 * These macros can be used to access TXQQSel0CongestionDrop.
 *
 */
#define BCM53600_A0_READ_TXQQSEL0CONGESTIONDROPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQSEL0CONGESTIONDROPr,(r._txqqsel0congestiondrop),4)
#define BCM53600_A0_WRITE_TXQQSEL0CONGESTIONDROPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQSEL0CONGESTIONDROPr,&(r._txqqsel0congestiondrop),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQSEL0CONGESTIONDROPr BCM53600_A0_TXQQSEL0CONGESTIONDROPr
#define TXQQSEL0CONGESTIONDROPr_SIZE BCM53600_A0_TXQQSEL0CONGESTIONDROPr_SIZE
typedef BCM53600_A0_TXQQSEL0CONGESTIONDROPr_t TXQQSEL0CONGESTIONDROPr_t;
#define TXQQSEL0CONGESTIONDROPr_CLR BCM53600_A0_TXQQSEL0CONGESTIONDROPr_CLR
#define TXQQSEL0CONGESTIONDROPr_SET BCM53600_A0_TXQQSEL0CONGESTIONDROPr_SET
#define TXQQSEL0CONGESTIONDROPr_GET BCM53600_A0_TXQQSEL0CONGESTIONDROPr_GET
#define READ_TXQQSEL0CONGESTIONDROPr BCM53600_A0_READ_TXQQSEL0CONGESTIONDROPr
#define WRITE_TXQQSEL0CONGESTIONDROPr BCM53600_A0_WRITE_TXQQSEL0CONGESTIONDROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQSEL0CONGESTIONDROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQQSel1CongestionDrop
 * BLOCKS:   SYS
 * DESC:     TXQ_Q Select 1 Congestion Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXQQSEL1CONGESTIONDROPr 0x000052b8

#define BCM53600_A0_TXQQSEL1CONGESTIONDROPr_SIZE 4

/*
 * This structure should be used to declare and program TXQQSel1CongestionDrop.
 *
 */
typedef union BCM53600_A0_TXQQSEL1CONGESTIONDROPr_s {
	uint32_t v[1];
	uint32_t txqqsel1congestiondrop[1];
	uint32_t _txqqsel1congestiondrop;
} BCM53600_A0_TXQQSEL1CONGESTIONDROPr_t;

#define BCM53600_A0_TXQQSEL1CONGESTIONDROPr_CLR(r) (r).txqqsel1congestiondrop[0] = 0
#define BCM53600_A0_TXQQSEL1CONGESTIONDROPr_SET(r,d) (r).txqqsel1congestiondrop[0] = d
#define BCM53600_A0_TXQQSEL1CONGESTIONDROPr_GET(r) (r).txqqsel1congestiondrop[0]


/*
 * These macros can be used to access TXQQSel1CongestionDrop.
 *
 */
#define BCM53600_A0_READ_TXQQSEL1CONGESTIONDROPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQQSEL1CONGESTIONDROPr,(r._txqqsel1congestiondrop),4)
#define BCM53600_A0_WRITE_TXQQSEL1CONGESTIONDROPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQQSEL1CONGESTIONDROPr,&(r._txqqsel1congestiondrop),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQQSEL1CONGESTIONDROPr BCM53600_A0_TXQQSEL1CONGESTIONDROPr
#define TXQQSEL1CONGESTIONDROPr_SIZE BCM53600_A0_TXQQSEL1CONGESTIONDROPr_SIZE
typedef BCM53600_A0_TXQQSEL1CONGESTIONDROPr_t TXQQSEL1CONGESTIONDROPr_t;
#define TXQQSEL1CONGESTIONDROPr_CLR BCM53600_A0_TXQQSEL1CONGESTIONDROPr_CLR
#define TXQQSEL1CONGESTIONDROPr_SET BCM53600_A0_TXQQSEL1CONGESTIONDROPr_SET
#define TXQQSEL1CONGESTIONDROPr_GET BCM53600_A0_TXQQSEL1CONGESTIONDROPr_GET
#define READ_TXQQSEL1CONGESTIONDROPr BCM53600_A0_READ_TXQQSEL1CONGESTIONDROPr
#define WRITE_TXQQSEL1CONGESTIONDROPr BCM53600_A0_WRITE_TXQQSEL1CONGESTIONDROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQQSEL1CONGESTIONDROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_BACKPRESSURE_GE0_CTL
 * BLOCKS:   SYS
 * DESC:     TXQ Backpressure GE0 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_TXQ0_BP_GE0   1 = Pause traffic scheduling on TXQ-Q0.
 *     EN_TXQ1_BP_GE0   1 = Pause traffic scheduling on TXQ-Q1.
 *     EN_TXQ2_BP_GE0   1 = Pause traffic scheduling on TXQ-Q2.
 *     EN_TXQ3_BP_GE0   1 = Pause traffic scheduling on TXQ-Q3.
 *     EN_TXQ4_BP_GE0   1 = Pause traffic scheduling on TXQ-Q4.
 *     EN_TXQ5_BP_GE0   1 = Pause traffic scheduling on TXQ-Q5.
 *     EN_TXQ6_BP_GE0   1 = Pause traffic scheduling on TXQ-Q6.
 *     EN_TXQ7_BP_GE0   1 = Pause traffic scheduling on TXQ-Q7.
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr 0x000030d1

#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_BACKPRESSURE_GE0_CTL.
 *
 */
typedef union BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_s {
	uint32_t v[1];
	uint32_t txq_backpressure_ge0_ctl[1];
	uint32_t _txq_backpressure_ge0_ctl;
} BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_t;

#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_CLR(r) (r).txq_backpressure_ge0_ctl[0] = 0
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_SET(r,d) (r).txq_backpressure_ge0_ctl[0] = d
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_GET(r) (r).txq_backpressure_ge0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ0_BP_GE0f_GET(r) (((r).txq_backpressure_ge0_ctl[0]) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ0_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ1_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ1_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ2_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ2_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ3_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ3_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ4_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ4_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ5_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ5_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ6_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ6_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ7_BP_GE0f_GET(r) ((((r).txq_backpressure_ge0_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ7_BP_GE0f_SET(r,f) (r).txq_backpressure_ge0_ctl[0]=(((r).txq_backpressure_ge0_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_BACKPRESSURE_GE0_CTL.
 *
 */
#define BCM53600_A0_READ_TXQ_BACKPRESSURE_GE0_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr,(r._txq_backpressure_ge0_ctl),1)
#define BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE0_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr,&(r._txq_backpressure_ge0_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_BACKPRESSURE_GE0_CTLr BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr
#define TXQ_BACKPRESSURE_GE0_CTLr_SIZE BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_SIZE
typedef BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_t TXQ_BACKPRESSURE_GE0_CTLr_t;
#define TXQ_BACKPRESSURE_GE0_CTLr_CLR BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_CLR
#define TXQ_BACKPRESSURE_GE0_CTLr_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ0_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ0_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ0_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ0_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ1_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ1_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ1_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ1_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ2_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ2_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ2_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ2_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ3_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ3_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ3_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ3_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ4_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ4_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ4_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ4_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ5_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ5_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ5_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ5_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ6_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ6_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ6_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ6_BP_GE0f_SET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ7_BP_GE0f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ7_BP_GE0f_GET
#define TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ7_BP_GE0f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr_EN_TXQ7_BP_GE0f_SET
#define READ_TXQ_BACKPRESSURE_GE0_CTLr BCM53600_A0_READ_TXQ_BACKPRESSURE_GE0_CTLr
#define WRITE_TXQ_BACKPRESSURE_GE0_CTLr BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_BACKPRESSURE_GE0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_BACKPRESSURE_GE1_CTL
 * BLOCKS:   SYS
 * DESC:     TXQ Backpressure GE1 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_TXQ0_BP_GE1   1 = Pause traffic scheduling on TXQ-Q0.
 *     EN_TXQ1_BP_GE1   1 = Pause traffic scheduling on TXQ-Q1.
 *     EN_TXQ2_BP_GE1   1 = Pause traffic scheduling on TXQ-Q2.
 *     EN_TXQ3_BP_GE1   1 = Pause traffic scheduling on TXQ-Q3.
 *     EN_TXQ4_BP_GE1   1 = Pause traffic scheduling on TXQ-Q4.
 *     EN_TXQ5_BP_GE1   1 = Pause traffic scheduling on TXQ-Q5.
 *     EN_TXQ6_BP_GE1   1 = Pause traffic scheduling on TXQ-Q6.
 *     EN_TXQ7_BP_GE1   1 = Pause traffic scheduling on TXQ-Q7.
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr 0x000030d2

#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_BACKPRESSURE_GE1_CTL.
 *
 */
typedef union BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_s {
	uint32_t v[1];
	uint32_t txq_backpressure_ge1_ctl[1];
	uint32_t _txq_backpressure_ge1_ctl;
} BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_t;

#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_CLR(r) (r).txq_backpressure_ge1_ctl[0] = 0
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_SET(r,d) (r).txq_backpressure_ge1_ctl[0] = d
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_GET(r) (r).txq_backpressure_ge1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ0_BP_GE1f_GET(r) (((r).txq_backpressure_ge1_ctl[0]) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ0_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ1_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ1_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ2_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ2_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ3_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ3_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ4_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ4_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ5_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ5_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ6_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ6_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ7_BP_GE1f_GET(r) ((((r).txq_backpressure_ge1_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ7_BP_GE1f_SET(r,f) (r).txq_backpressure_ge1_ctl[0]=(((r).txq_backpressure_ge1_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_BACKPRESSURE_GE1_CTL.
 *
 */
#define BCM53600_A0_READ_TXQ_BACKPRESSURE_GE1_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr,(r._txq_backpressure_ge1_ctl),1)
#define BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE1_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr,&(r._txq_backpressure_ge1_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_BACKPRESSURE_GE1_CTLr BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr
#define TXQ_BACKPRESSURE_GE1_CTLr_SIZE BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_SIZE
typedef BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_t TXQ_BACKPRESSURE_GE1_CTLr_t;
#define TXQ_BACKPRESSURE_GE1_CTLr_CLR BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_CLR
#define TXQ_BACKPRESSURE_GE1_CTLr_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ0_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ0_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ0_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ0_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ1_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ1_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ1_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ1_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ2_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ2_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ2_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ2_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ3_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ3_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ3_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ3_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ4_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ4_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ4_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ4_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ5_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ5_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ5_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ5_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ6_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ6_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ6_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ6_BP_GE1f_SET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ7_BP_GE1f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ7_BP_GE1f_GET
#define TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ7_BP_GE1f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr_EN_TXQ7_BP_GE1f_SET
#define READ_TXQ_BACKPRESSURE_GE1_CTLr BCM53600_A0_READ_TXQ_BACKPRESSURE_GE1_CTLr
#define WRITE_TXQ_BACKPRESSURE_GE1_CTLr BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_BACKPRESSURE_GE1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_BACKPRESSURE_GE2_CTL
 * BLOCKS:   SYS
 * DESC:     TXQ Backpressure GE2 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_TXQ0_BP_GE2   1 = Pause traffic scheduling on TXQ-Q0.
 *     EN_TXQ1_BP_GE2   1 = Pause traffic scheduling on TXQ-Q1.
 *     EN_TXQ2_BP_GE2   1 = Pause traffic scheduling on TXQ-Q2.
 *     EN_TXQ3_BP_GE2   1 = Pause traffic scheduling on TXQ-Q3.
 *     EN_TXQ4_BP_GE2   1 = Pause traffic scheduling on TXQ-Q4.
 *     EN_TXQ5_BP_GE2   1 = Pause traffic scheduling on TXQ-Q5.
 *     EN_TXQ6_BP_GE2   1 = Pause traffic scheduling on TXQ-Q6.
 *     EN_TXQ7_BP_GE2   1 = Pause traffic scheduling on TXQ-Q7.
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr 0x000030d3

#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_BACKPRESSURE_GE2_CTL.
 *
 */
typedef union BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_s {
	uint32_t v[1];
	uint32_t txq_backpressure_ge2_ctl[1];
	uint32_t _txq_backpressure_ge2_ctl;
} BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_t;

#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_CLR(r) (r).txq_backpressure_ge2_ctl[0] = 0
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_SET(r,d) (r).txq_backpressure_ge2_ctl[0] = d
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_GET(r) (r).txq_backpressure_ge2_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ0_BP_GE2f_GET(r) (((r).txq_backpressure_ge2_ctl[0]) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ0_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ1_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ1_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ2_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ2_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ3_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ3_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ4_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ4_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ5_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ5_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ6_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ6_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ7_BP_GE2f_GET(r) ((((r).txq_backpressure_ge2_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ7_BP_GE2f_SET(r,f) (r).txq_backpressure_ge2_ctl[0]=(((r).txq_backpressure_ge2_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_BACKPRESSURE_GE2_CTL.
 *
 */
#define BCM53600_A0_READ_TXQ_BACKPRESSURE_GE2_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr,(r._txq_backpressure_ge2_ctl),1)
#define BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE2_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr,&(r._txq_backpressure_ge2_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_BACKPRESSURE_GE2_CTLr BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr
#define TXQ_BACKPRESSURE_GE2_CTLr_SIZE BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_SIZE
typedef BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_t TXQ_BACKPRESSURE_GE2_CTLr_t;
#define TXQ_BACKPRESSURE_GE2_CTLr_CLR BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_CLR
#define TXQ_BACKPRESSURE_GE2_CTLr_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ0_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ0_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ0_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ0_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ1_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ1_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ1_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ1_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ2_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ2_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ2_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ2_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ3_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ3_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ3_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ3_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ4_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ4_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ4_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ4_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ5_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ5_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ5_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ5_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ6_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ6_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ6_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ6_BP_GE2f_SET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ7_BP_GE2f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ7_BP_GE2f_GET
#define TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ7_BP_GE2f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr_EN_TXQ7_BP_GE2f_SET
#define READ_TXQ_BACKPRESSURE_GE2_CTLr BCM53600_A0_READ_TXQ_BACKPRESSURE_GE2_CTLr
#define WRITE_TXQ_BACKPRESSURE_GE2_CTLr BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE2_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_BACKPRESSURE_GE2_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_BACKPRESSURE_GE3_CTL
 * BLOCKS:   SYS
 * DESC:     TXQ Backpressure GE3 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_TXQ0_BP_GE3   1 = Pause traffic scheduling on TXQ-Q0.
 *     EN_TXQ1_BP_GE3   1 = Pause traffic scheduling on TXQ-Q1.
 *     EN_TXQ2_BP_GE3   1 = Pause traffic scheduling on TXQ-Q2.
 *     EN_TXQ3_BP_GE3   1 = Pause traffic scheduling on TXQ-Q3.
 *     EN_TXQ4_BP_GE3   1 = Pause traffic scheduling on TXQ-Q4.
 *     EN_TXQ5_BP_GE3   1 = Pause traffic scheduling on TXQ-Q5.
 *     EN_TXQ6_BP_GE3   1 = Pause traffic scheduling on TXQ-Q6.
 *     EN_TXQ7_BP_GE3   1 = Pause traffic scheduling on TXQ-Q7.
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr 0x000030d4

#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_BACKPRESSURE_GE3_CTL.
 *
 */
typedef union BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_s {
	uint32_t v[1];
	uint32_t txq_backpressure_ge3_ctl[1];
	uint32_t _txq_backpressure_ge3_ctl;
} BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_t;

#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_CLR(r) (r).txq_backpressure_ge3_ctl[0] = 0
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_SET(r,d) (r).txq_backpressure_ge3_ctl[0] = d
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_GET(r) (r).txq_backpressure_ge3_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ0_BP_GE3f_GET(r) (((r).txq_backpressure_ge3_ctl[0]) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ0_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ1_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ1_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ2_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ2_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ3_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ3_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ4_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ4_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ5_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ5_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ6_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ6_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ7_BP_GE3f_GET(r) ((((r).txq_backpressure_ge3_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ7_BP_GE3f_SET(r,f) (r).txq_backpressure_ge3_ctl[0]=(((r).txq_backpressure_ge3_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_BACKPRESSURE_GE3_CTL.
 *
 */
#define BCM53600_A0_READ_TXQ_BACKPRESSURE_GE3_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr,(r._txq_backpressure_ge3_ctl),1)
#define BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE3_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr,&(r._txq_backpressure_ge3_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_BACKPRESSURE_GE3_CTLr BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr
#define TXQ_BACKPRESSURE_GE3_CTLr_SIZE BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_SIZE
typedef BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_t TXQ_BACKPRESSURE_GE3_CTLr_t;
#define TXQ_BACKPRESSURE_GE3_CTLr_CLR BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_CLR
#define TXQ_BACKPRESSURE_GE3_CTLr_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ0_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ0_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ0_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ0_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ1_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ1_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ1_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ1_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ2_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ2_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ2_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ2_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ3_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ3_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ3_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ3_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ4_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ4_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ4_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ4_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ5_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ5_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ5_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ5_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ6_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ6_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ6_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ6_BP_GE3f_SET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ7_BP_GE3f_GET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ7_BP_GE3f_GET
#define TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ7_BP_GE3f_SET BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr_EN_TXQ7_BP_GE3f_SET
#define READ_TXQ_BACKPRESSURE_GE3_CTLr BCM53600_A0_READ_TXQ_BACKPRESSURE_GE3_CTLr
#define WRITE_TXQ_BACKPRESSURE_GE3_CTLr BCM53600_A0_WRITE_TXQ_BACKPRESSURE_GE3_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_BACKPRESSURE_GE3_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_BACKPRESSURE_IMP_CTL
 * BLOCKS:   SYS
 * DESC:     TXQ Backpressure IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_TXQ0_BP_IMP   1 = Pause traffic scheduling on TXQ-Q0.
 *     EN_TXQ1_BP_IMP   1 = Pause traffic scheduling on TXQ-Q1.
 *     EN_TXQ2_BP_IMP   1 = Pause traffic scheduling on TXQ-Q2.
 *     EN_TXQ3_BP_IMP   1 = Pause traffic scheduling on TXQ-Q3.
 *     EN_TXQ4_BP_IMP   1 = Pause traffic scheduling on TXQ-Q4.
 *     EN_TXQ5_BP_IMP   1 = Pause traffic scheduling on TXQ-Q5.
 *     EN_TXQ6_BP_IMP   1 = Pause traffic scheduling on TXQ-Q6.
 *     EN_TXQ7_BP_IMP   1 = Pause traffic scheduling on TXQ-Q7.
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr 0x000030d0

#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_BACKPRESSURE_IMP_CTL.
 *
 */
typedef union BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_s {
	uint32_t v[1];
	uint32_t txq_backpressure_imp_ctl[1];
	uint32_t _txq_backpressure_imp_ctl;
} BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_t;

#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_CLR(r) (r).txq_backpressure_imp_ctl[0] = 0
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_SET(r,d) (r).txq_backpressure_imp_ctl[0] = d
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_GET(r) (r).txq_backpressure_imp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ0_BP_IMPf_GET(r) (((r).txq_backpressure_imp_ctl[0]) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ0_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ1_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ1_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ2_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ2_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ3_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ3_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ4_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ4_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ5_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ5_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ6_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ6_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ7_BP_IMPf_GET(r) ((((r).txq_backpressure_imp_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ7_BP_IMPf_SET(r,f) (r).txq_backpressure_imp_ctl[0]=(((r).txq_backpressure_imp_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_BACKPRESSURE_IMP_CTL.
 *
 */
#define BCM53600_A0_READ_TXQ_BACKPRESSURE_IMP_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr,(r._txq_backpressure_imp_ctl),1)
#define BCM53600_A0_WRITE_TXQ_BACKPRESSURE_IMP_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr,&(r._txq_backpressure_imp_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_BACKPRESSURE_IMP_CTLr BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr
#define TXQ_BACKPRESSURE_IMP_CTLr_SIZE BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_SIZE
typedef BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_t TXQ_BACKPRESSURE_IMP_CTLr_t;
#define TXQ_BACKPRESSURE_IMP_CTLr_CLR BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_CLR
#define TXQ_BACKPRESSURE_IMP_CTLr_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ0_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ0_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ0_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ0_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ1_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ1_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ1_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ1_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ2_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ2_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ2_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ2_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ3_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ3_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ3_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ3_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ4_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ4_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ4_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ4_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ5_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ5_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ5_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ5_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ6_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ6_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ6_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ6_BP_IMPf_SET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ7_BP_IMPf_GET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ7_BP_IMPf_GET
#define TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ7_BP_IMPf_SET BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr_EN_TXQ7_BP_IMPf_SET
#define READ_TXQ_BACKPRESSURE_IMP_CTLr BCM53600_A0_READ_TXQ_BACKPRESSURE_IMP_CTLr
#define WRITE_TXQ_BACKPRESSURE_IMP_CTLr BCM53600_A0_WRITE_TXQ_BACKPRESSURE_IMP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_BACKPRESSURE_IMP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_DROP_CNT_COS_SELECT_0
 * BLOCKS:   SYS
 * DESC:     TXQ DROP Count CoS Select 0 Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_DROP_QSEL_0  COS value select#0 to indicate which queue bitmap to be monitored forthe TXQ-Q Select#0 packet drop count due to Queue congestion.Bit[7:0] indicate COS[7:0] respectatively. noted that the selected queuenumber in the COS select#0 register should be excluded in the COSselect#1 register.The counter can be access in the TXQ_QSEL0_CONG_DROP_PKT[Page52h].
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r 0x00005004

#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_SIZE 1

/*
 * This structure should be used to declare and program TXQ_DROP_CNT_COS_SELECT_0.
 *
 */
typedef union BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_s {
	uint32_t v[1];
	uint32_t txq_drop_cnt_cos_select_0[1];
	uint32_t _txq_drop_cnt_cos_select_0;
} BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_t;

#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_CLR(r) (r).txq_drop_cnt_cos_select_0[0] = 0
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_SET(r,d) (r).txq_drop_cnt_cos_select_0[0] = d
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_GET(r) (r).txq_drop_cnt_cos_select_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_TXQ_DROP_QSEL_0f_GET(r) (((r).txq_drop_cnt_cos_select_0[0]) & 0xff)
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_TXQ_DROP_QSEL_0f_SET(r,f) (r).txq_drop_cnt_cos_select_0[0]=(((r).txq_drop_cnt_cos_select_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_DROP_CNT_COS_SELECT_0.
 *
 */
#define BCM53600_A0_READ_TXQ_DROP_CNT_COS_SELECT_0r(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r,(r._txq_drop_cnt_cos_select_0),1)
#define BCM53600_A0_WRITE_TXQ_DROP_CNT_COS_SELECT_0r(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r,&(r._txq_drop_cnt_cos_select_0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_DROP_CNT_COS_SELECT_0r BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r
#define TXQ_DROP_CNT_COS_SELECT_0r_SIZE BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_SIZE
typedef BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_t TXQ_DROP_CNT_COS_SELECT_0r_t;
#define TXQ_DROP_CNT_COS_SELECT_0r_CLR BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_CLR
#define TXQ_DROP_CNT_COS_SELECT_0r_SET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_SET
#define TXQ_DROP_CNT_COS_SELECT_0r_GET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_GET
#define TXQ_DROP_CNT_COS_SELECT_0r_TXQ_DROP_QSEL_0f_GET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_TXQ_DROP_QSEL_0f_GET
#define TXQ_DROP_CNT_COS_SELECT_0r_TXQ_DROP_QSEL_0f_SET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r_TXQ_DROP_QSEL_0f_SET
#define READ_TXQ_DROP_CNT_COS_SELECT_0r BCM53600_A0_READ_TXQ_DROP_CNT_COS_SELECT_0r
#define WRITE_TXQ_DROP_CNT_COS_SELECT_0r BCM53600_A0_WRITE_TXQ_DROP_CNT_COS_SELECT_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_DROP_CNT_COS_SELECT_1
 * BLOCKS:   SYS
 * DESC:     TXQ DROP Count CoS Select 1 Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_DROP_QSEL_1  COS value select#1 to indicate which queue bitmap to be monitored forthe TXQ-Q Select#1 packet drop count due to Queue congestion.Bit[7:0] indicate COS[7:0] respectatively. noted that the selected queuenumber in the COS select#1 register should be excluded in the COSselect#0 register.The counter can be access in the TXQ_QSEL1_CONG_DROP_PKT[Page52h].
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r 0x00005005

#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_SIZE 1

/*
 * This structure should be used to declare and program TXQ_DROP_CNT_COS_SELECT_1.
 *
 */
typedef union BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_s {
	uint32_t v[1];
	uint32_t txq_drop_cnt_cos_select_1[1];
	uint32_t _txq_drop_cnt_cos_select_1;
} BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_t;

#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_CLR(r) (r).txq_drop_cnt_cos_select_1[0] = 0
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_SET(r,d) (r).txq_drop_cnt_cos_select_1[0] = d
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_GET(r) (r).txq_drop_cnt_cos_select_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_TXQ_DROP_QSEL_1f_GET(r) (((r).txq_drop_cnt_cos_select_1[0]) & 0xff)
#define BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_TXQ_DROP_QSEL_1f_SET(r,f) (r).txq_drop_cnt_cos_select_1[0]=(((r).txq_drop_cnt_cos_select_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_DROP_CNT_COS_SELECT_1.
 *
 */
#define BCM53600_A0_READ_TXQ_DROP_CNT_COS_SELECT_1r(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r,(r._txq_drop_cnt_cos_select_1),1)
#define BCM53600_A0_WRITE_TXQ_DROP_CNT_COS_SELECT_1r(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r,&(r._txq_drop_cnt_cos_select_1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_DROP_CNT_COS_SELECT_1r BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r
#define TXQ_DROP_CNT_COS_SELECT_1r_SIZE BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_SIZE
typedef BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_t TXQ_DROP_CNT_COS_SELECT_1r_t;
#define TXQ_DROP_CNT_COS_SELECT_1r_CLR BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_CLR
#define TXQ_DROP_CNT_COS_SELECT_1r_SET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_SET
#define TXQ_DROP_CNT_COS_SELECT_1r_GET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_GET
#define TXQ_DROP_CNT_COS_SELECT_1r_TXQ_DROP_QSEL_1f_GET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_TXQ_DROP_QSEL_1f_GET
#define TXQ_DROP_CNT_COS_SELECT_1r_TXQ_DROP_QSEL_1f_SET BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r_TXQ_DROP_QSEL_1f_SET
#define READ_TXQ_DROP_CNT_COS_SELECT_1r BCM53600_A0_READ_TXQ_DROP_CNT_COS_SELECT_1r
#define WRITE_TXQ_DROP_CNT_COS_SELECT_1r BCM53600_A0_WRITE_TXQ_DROP_CNT_COS_SELECT_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_DROP_CNT_COS_SELECT_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_HYST_A_COUNT
 * BLOCKS:   SYS
 * DESC:     TXQ Hyst A Count Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_HYST_A_CNT   The Hyst A count between TXQ threshold settings of ON & OFF. The Hyst Acount is used for TXQ Protection Region and Congestion Region.The unit is "Buffer Cell Size"(256 bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_HYST_A_COUNTr 0x00000a05

#define BCM53600_A0_TXQ_HYST_A_COUNTr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_HYST_A_COUNT.
 *
 */
typedef union BCM53600_A0_TXQ_HYST_A_COUNTr_s {
	uint32_t v[1];
	uint32_t txq_hyst_a_count[1];
	uint32_t _txq_hyst_a_count;
} BCM53600_A0_TXQ_HYST_A_COUNTr_t;

#define BCM53600_A0_TXQ_HYST_A_COUNTr_CLR(r) (r).txq_hyst_a_count[0] = 0
#define BCM53600_A0_TXQ_HYST_A_COUNTr_SET(r,d) (r).txq_hyst_a_count[0] = d
#define BCM53600_A0_TXQ_HYST_A_COUNTr_GET(r) (r).txq_hyst_a_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_HYST_A_COUNTr_TXQ_HYST_A_CNTf_GET(r) (((r).txq_hyst_a_count[0]) & 0xff)
#define BCM53600_A0_TXQ_HYST_A_COUNTr_TXQ_HYST_A_CNTf_SET(r,f) (r).txq_hyst_a_count[0]=(((r).txq_hyst_a_count[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_HYST_A_COUNT.
 *
 */
#define BCM53600_A0_READ_TXQ_HYST_A_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_HYST_A_COUNTr,(r._txq_hyst_a_count),1)
#define BCM53600_A0_WRITE_TXQ_HYST_A_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_HYST_A_COUNTr,&(r._txq_hyst_a_count),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_HYST_A_COUNTr BCM53600_A0_TXQ_HYST_A_COUNTr
#define TXQ_HYST_A_COUNTr_SIZE BCM53600_A0_TXQ_HYST_A_COUNTr_SIZE
typedef BCM53600_A0_TXQ_HYST_A_COUNTr_t TXQ_HYST_A_COUNTr_t;
#define TXQ_HYST_A_COUNTr_CLR BCM53600_A0_TXQ_HYST_A_COUNTr_CLR
#define TXQ_HYST_A_COUNTr_SET BCM53600_A0_TXQ_HYST_A_COUNTr_SET
#define TXQ_HYST_A_COUNTr_GET BCM53600_A0_TXQ_HYST_A_COUNTr_GET
#define TXQ_HYST_A_COUNTr_TXQ_HYST_A_CNTf_GET BCM53600_A0_TXQ_HYST_A_COUNTr_TXQ_HYST_A_CNTf_GET
#define TXQ_HYST_A_COUNTr_TXQ_HYST_A_CNTf_SET BCM53600_A0_TXQ_HYST_A_COUNTr_TXQ_HYST_A_CNTf_SET
#define READ_TXQ_HYST_A_COUNTr BCM53600_A0_READ_TXQ_HYST_A_COUNTr
#define WRITE_TXQ_HYST_A_COUNTr BCM53600_A0_WRITE_TXQ_HYST_A_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_HYST_A_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_HYST_B_COUNT
 * BLOCKS:   SYS
 * DESC:     TXQ Hyst B Count Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_HYST_B_CNT   The Hyst B count between TXQ threshold settings of ON & OFF. The Hyst Bcount is used for TXQ OverSubscription Region. The unit is "Buffer Cell Size"(256 bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_HYST_B_COUNTr 0x00000a06

#define BCM53600_A0_TXQ_HYST_B_COUNTr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_HYST_B_COUNT.
 *
 */
typedef union BCM53600_A0_TXQ_HYST_B_COUNTr_s {
	uint32_t v[1];
	uint32_t txq_hyst_b_count[1];
	uint32_t _txq_hyst_b_count;
} BCM53600_A0_TXQ_HYST_B_COUNTr_t;

#define BCM53600_A0_TXQ_HYST_B_COUNTr_CLR(r) (r).txq_hyst_b_count[0] = 0
#define BCM53600_A0_TXQ_HYST_B_COUNTr_SET(r,d) (r).txq_hyst_b_count[0] = d
#define BCM53600_A0_TXQ_HYST_B_COUNTr_GET(r) (r).txq_hyst_b_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_HYST_B_COUNTr_TXQ_HYST_B_CNTf_GET(r) (((r).txq_hyst_b_count[0]) & 0xff)
#define BCM53600_A0_TXQ_HYST_B_COUNTr_TXQ_HYST_B_CNTf_SET(r,f) (r).txq_hyst_b_count[0]=(((r).txq_hyst_b_count[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_HYST_B_COUNT.
 *
 */
#define BCM53600_A0_READ_TXQ_HYST_B_COUNTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_HYST_B_COUNTr,(r._txq_hyst_b_count),1)
#define BCM53600_A0_WRITE_TXQ_HYST_B_COUNTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_HYST_B_COUNTr,&(r._txq_hyst_b_count),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_HYST_B_COUNTr BCM53600_A0_TXQ_HYST_B_COUNTr
#define TXQ_HYST_B_COUNTr_SIZE BCM53600_A0_TXQ_HYST_B_COUNTr_SIZE
typedef BCM53600_A0_TXQ_HYST_B_COUNTr_t TXQ_HYST_B_COUNTr_t;
#define TXQ_HYST_B_COUNTr_CLR BCM53600_A0_TXQ_HYST_B_COUNTr_CLR
#define TXQ_HYST_B_COUNTr_SET BCM53600_A0_TXQ_HYST_B_COUNTr_SET
#define TXQ_HYST_B_COUNTr_GET BCM53600_A0_TXQ_HYST_B_COUNTr_GET
#define TXQ_HYST_B_COUNTr_TXQ_HYST_B_CNTf_GET BCM53600_A0_TXQ_HYST_B_COUNTr_TXQ_HYST_B_CNTf_GET
#define TXQ_HYST_B_COUNTr_TXQ_HYST_B_CNTf_SET BCM53600_A0_TXQ_HYST_B_COUNTr_TXQ_HYST_B_CNTf_SET
#define READ_TXQ_HYST_B_COUNTr BCM53600_A0_READ_TXQ_HYST_B_COUNTr
#define WRITE_TXQ_HYST_B_COUNTr BCM53600_A0_WRITE_TXQ_HYST_B_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_HYST_B_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q0_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ0_CONG_ON_TH  The TXQ-Q0 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr 0x00000a30

#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q0_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q0_congestion_on_threshold[1];
	uint32_t _txq_q0_congestion_on_threshold;
} BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q0_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q0_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q0_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_TXQ0_CONG_ON_THf_GET(r) (((r).txq_q0_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_TXQ0_CONG_ON_THf_SET(r,f) (r).txq_q0_congestion_on_threshold[0]=(((r).txq_q0_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q0_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q0_congestion_on_threshold[0]=(((r).txq_q0_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q0_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q0_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr,(r._txq_q0_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q0_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr,&(r._txq_q0_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q0_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_t TXQ_Q0_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_TXQ0_CONG_ON_THf_GET BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_TXQ0_CONG_ON_THf_GET
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_TXQ0_CONG_ON_THf_SET BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_TXQ0_CONG_ON_THf_SET
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q0_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q0_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q0_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q0_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q0_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q0_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q0_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q0_OVERS_ON_TH The TXQ-Q0 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr 0x00000a18

#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q0_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q0_overs_on_threshold[1];
	uint32_t _txq_q0_overs_on_threshold;
} BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q0_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q0_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q0_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_TXQ_Q0_OVERS_ON_THf_GET(r) (((r).txq_q0_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_TXQ_Q0_OVERS_ON_THf_SET(r,f) (r).txq_q0_overs_on_threshold[0]=(((r).txq_q0_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q0_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q0_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr,(r._txq_q0_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q0_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr,&(r._txq_q0_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q0_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr
#define TXQ_Q0_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_t TXQ_Q0_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q0_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q0_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q0_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q0_OVERS_ON_THRESHOLDr_TXQ_Q0_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_TXQ_Q0_OVERS_ON_THf_GET
#define TXQ_Q0_OVERS_ON_THRESHOLDr_TXQ_Q0_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr_TXQ_Q0_OVERS_ON_THf_SET
#define READ_TXQ_Q0_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q0_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q0_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q0_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q0_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q0_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ0_PROT_ON_TH  The TXQ-Q0 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr 0x00000a20

#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q0_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q0_protection_on_threshold[1];
	uint32_t _txq_q0_protection_on_threshold;
} BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q0_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q0_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q0_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_TXQ0_PROT_ON_THf_GET(r) (((r).txq_q0_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_TXQ0_PROT_ON_THf_SET(r,f) (r).txq_q0_protection_on_threshold[0]=(((r).txq_q0_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q0_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q0_protection_on_threshold[0]=(((r).txq_q0_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q0_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q0_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr,(r._txq_q0_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q0_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr,&(r._txq_q0_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q0_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_t TXQ_Q0_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_TXQ0_PROT_ON_THf_GET BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_TXQ0_PROT_ON_THf_GET
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_TXQ0_PROT_ON_THf_SET BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_TXQ0_PROT_ON_THf_SET
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q0_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q0_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q0_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q0_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q0_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q0_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q1_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ1_CONG_ON_TH  The TXQ-Q1 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr 0x00000a32

#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q1_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q1_congestion_on_threshold[1];
	uint32_t _txq_q1_congestion_on_threshold;
} BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q1_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q1_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q1_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_TXQ1_CONG_ON_THf_GET(r) (((r).txq_q1_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_TXQ1_CONG_ON_THf_SET(r,f) (r).txq_q1_congestion_on_threshold[0]=(((r).txq_q1_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q1_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q1_congestion_on_threshold[0]=(((r).txq_q1_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q1_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q1_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr,(r._txq_q1_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q1_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr,&(r._txq_q1_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q1_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_t TXQ_Q1_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_TXQ1_CONG_ON_THf_GET BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_TXQ1_CONG_ON_THf_GET
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_TXQ1_CONG_ON_THf_SET BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_TXQ1_CONG_ON_THf_SET
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q1_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q1_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q1_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q1_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q1_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q1_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q1_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q1_OVERS_ON_TH The TXQ-Q1 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr 0x00000a19

#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q1_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q1_overs_on_threshold[1];
	uint32_t _txq_q1_overs_on_threshold;
} BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q1_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q1_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q1_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_TXQ_Q1_OVERS_ON_THf_GET(r) (((r).txq_q1_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_TXQ_Q1_OVERS_ON_THf_SET(r,f) (r).txq_q1_overs_on_threshold[0]=(((r).txq_q1_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q1_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q1_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr,(r._txq_q1_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q1_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr,&(r._txq_q1_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q1_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr
#define TXQ_Q1_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_t TXQ_Q1_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q1_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q1_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q1_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q1_OVERS_ON_THRESHOLDr_TXQ_Q1_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_TXQ_Q1_OVERS_ON_THf_GET
#define TXQ_Q1_OVERS_ON_THRESHOLDr_TXQ_Q1_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr_TXQ_Q1_OVERS_ON_THf_SET
#define READ_TXQ_Q1_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q1_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q1_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q1_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q1_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q1_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ1_PROT_ON_TH  The TXQ-Q1 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr 0x00000a22

#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q1_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q1_protection_on_threshold[1];
	uint32_t _txq_q1_protection_on_threshold;
} BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q1_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q1_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q1_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_TXQ1_PROT_ON_THf_GET(r) (((r).txq_q1_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_TXQ1_PROT_ON_THf_SET(r,f) (r).txq_q1_protection_on_threshold[0]=(((r).txq_q1_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q1_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q1_protection_on_threshold[0]=(((r).txq_q1_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q1_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q1_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr,(r._txq_q1_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q1_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr,&(r._txq_q1_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q1_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_t TXQ_Q1_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_TXQ1_PROT_ON_THf_GET BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_TXQ1_PROT_ON_THf_GET
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_TXQ1_PROT_ON_THf_SET BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_TXQ1_PROT_ON_THf_SET
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q1_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q1_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q1_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q1_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q1_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q1_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q2_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ2_CONG_ON_TH  The TXQ-Q2 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr 0x00000a34

#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q2_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q2_congestion_on_threshold[1];
	uint32_t _txq_q2_congestion_on_threshold;
} BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q2_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q2_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q2_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_TXQ2_CONG_ON_THf_GET(r) (((r).txq_q2_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_TXQ2_CONG_ON_THf_SET(r,f) (r).txq_q2_congestion_on_threshold[0]=(((r).txq_q2_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q2_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q2_congestion_on_threshold[0]=(((r).txq_q2_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q2_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q2_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr,(r._txq_q2_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q2_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr,&(r._txq_q2_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q2_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_t TXQ_Q2_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_TXQ2_CONG_ON_THf_GET BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_TXQ2_CONG_ON_THf_GET
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_TXQ2_CONG_ON_THf_SET BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_TXQ2_CONG_ON_THf_SET
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q2_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q2_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q2_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q2_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q2_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q2_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q2_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q2_OVERS_ON_TH The TXQ-Q2 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr 0x00000a1a

#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q2_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q2_overs_on_threshold[1];
	uint32_t _txq_q2_overs_on_threshold;
} BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q2_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q2_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q2_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_TXQ_Q2_OVERS_ON_THf_GET(r) (((r).txq_q2_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_TXQ_Q2_OVERS_ON_THf_SET(r,f) (r).txq_q2_overs_on_threshold[0]=(((r).txq_q2_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q2_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q2_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr,(r._txq_q2_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q2_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr,&(r._txq_q2_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q2_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr
#define TXQ_Q2_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_t TXQ_Q2_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q2_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q2_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q2_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q2_OVERS_ON_THRESHOLDr_TXQ_Q2_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_TXQ_Q2_OVERS_ON_THf_GET
#define TXQ_Q2_OVERS_ON_THRESHOLDr_TXQ_Q2_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr_TXQ_Q2_OVERS_ON_THf_SET
#define READ_TXQ_Q2_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q2_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q2_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q2_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q2_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q2_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ2_PROT_ON_TH  The TXQ-Q2 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr 0x00000a24

#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q2_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q2_protection_on_threshold[1];
	uint32_t _txq_q2_protection_on_threshold;
} BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q2_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q2_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q2_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_TXQ2_PROT_ON_THf_GET(r) (((r).txq_q2_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_TXQ2_PROT_ON_THf_SET(r,f) (r).txq_q2_protection_on_threshold[0]=(((r).txq_q2_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q2_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q2_protection_on_threshold[0]=(((r).txq_q2_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q2_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q2_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr,(r._txq_q2_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q2_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr,&(r._txq_q2_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q2_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_t TXQ_Q2_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_TXQ2_PROT_ON_THf_GET BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_TXQ2_PROT_ON_THf_GET
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_TXQ2_PROT_ON_THf_SET BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_TXQ2_PROT_ON_THf_SET
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q2_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q2_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q2_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q2_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q2_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q2_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q3_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ3_CONG_ON_TH  The TXQ-Q3 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr 0x00000a36

#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q3_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q3_congestion_on_threshold[1];
	uint32_t _txq_q3_congestion_on_threshold;
} BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q3_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q3_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q3_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_TXQ3_CONG_ON_THf_GET(r) (((r).txq_q3_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_TXQ3_CONG_ON_THf_SET(r,f) (r).txq_q3_congestion_on_threshold[0]=(((r).txq_q3_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q3_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q3_congestion_on_threshold[0]=(((r).txq_q3_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q3_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q3_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr,(r._txq_q3_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q3_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr,&(r._txq_q3_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q3_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_t TXQ_Q3_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_TXQ3_CONG_ON_THf_GET BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_TXQ3_CONG_ON_THf_GET
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_TXQ3_CONG_ON_THf_SET BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_TXQ3_CONG_ON_THf_SET
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q3_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q3_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q3_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q3_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q3_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q3_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q3_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q3_OVERS_ON_TH The TXQ-Q3 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr 0x00000a1b

#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q3_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q3_overs_on_threshold[1];
	uint32_t _txq_q3_overs_on_threshold;
} BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q3_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q3_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q3_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_TXQ_Q3_OVERS_ON_THf_GET(r) (((r).txq_q3_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_TXQ_Q3_OVERS_ON_THf_SET(r,f) (r).txq_q3_overs_on_threshold[0]=(((r).txq_q3_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q3_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q3_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr,(r._txq_q3_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q3_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr,&(r._txq_q3_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q3_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr
#define TXQ_Q3_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_t TXQ_Q3_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q3_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q3_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q3_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q3_OVERS_ON_THRESHOLDr_TXQ_Q3_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_TXQ_Q3_OVERS_ON_THf_GET
#define TXQ_Q3_OVERS_ON_THRESHOLDr_TXQ_Q3_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr_TXQ_Q3_OVERS_ON_THf_SET
#define READ_TXQ_Q3_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q3_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q3_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q3_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q3_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q3_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ3_PROT_ON_TH  The TXQ-Q3 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr 0x00000a26

#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q3_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q3_protection_on_threshold[1];
	uint32_t _txq_q3_protection_on_threshold;
} BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q3_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q3_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q3_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_TXQ3_PROT_ON_THf_GET(r) (((r).txq_q3_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_TXQ3_PROT_ON_THf_SET(r,f) (r).txq_q3_protection_on_threshold[0]=(((r).txq_q3_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q3_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q3_protection_on_threshold[0]=(((r).txq_q3_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q3_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q3_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr,(r._txq_q3_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q3_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr,&(r._txq_q3_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q3_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_t TXQ_Q3_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_TXQ3_PROT_ON_THf_GET BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_TXQ3_PROT_ON_THf_GET
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_TXQ3_PROT_ON_THf_SET BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_TXQ3_PROT_ON_THf_SET
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q3_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q3_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q3_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q3_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q3_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q3_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q4_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q4 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ4_CONG_ON_TH  The TXQ-Q4 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr 0x00000a38

#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q4_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q4_congestion_on_threshold[1];
	uint32_t _txq_q4_congestion_on_threshold;
} BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q4_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q4_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q4_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_TXQ4_CONG_ON_THf_GET(r) (((r).txq_q4_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_TXQ4_CONG_ON_THf_SET(r,f) (r).txq_q4_congestion_on_threshold[0]=(((r).txq_q4_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q4_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q4_congestion_on_threshold[0]=(((r).txq_q4_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q4_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q4_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr,(r._txq_q4_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q4_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr,&(r._txq_q4_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q4_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_t TXQ_Q4_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_TXQ4_CONG_ON_THf_GET BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_TXQ4_CONG_ON_THf_GET
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_TXQ4_CONG_ON_THf_SET BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_TXQ4_CONG_ON_THf_SET
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q4_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q4_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q4_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q4_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q4_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q4_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q4_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q4 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q4_OVERS_ON_TH The TXQ-Q4 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr 0x00000a1c

#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q4_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q4_overs_on_threshold[1];
	uint32_t _txq_q4_overs_on_threshold;
} BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q4_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q4_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q4_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_TXQ_Q4_OVERS_ON_THf_GET(r) (((r).txq_q4_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_TXQ_Q4_OVERS_ON_THf_SET(r,f) (r).txq_q4_overs_on_threshold[0]=(((r).txq_q4_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q4_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q4_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr,(r._txq_q4_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q4_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr,&(r._txq_q4_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q4_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr
#define TXQ_Q4_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_t TXQ_Q4_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q4_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q4_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q4_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q4_OVERS_ON_THRESHOLDr_TXQ_Q4_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_TXQ_Q4_OVERS_ON_THf_GET
#define TXQ_Q4_OVERS_ON_THRESHOLDr_TXQ_Q4_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr_TXQ_Q4_OVERS_ON_THf_SET
#define READ_TXQ_Q4_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q4_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q4_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q4_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q4_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q4_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q4 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ4_PROT_ON_TH  The TXQ-Q4 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr 0x00000a28

#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q4_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q4_protection_on_threshold[1];
	uint32_t _txq_q4_protection_on_threshold;
} BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q4_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q4_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q4_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_TXQ4_PROT_ON_THf_GET(r) (((r).txq_q4_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_TXQ4_PROT_ON_THf_SET(r,f) (r).txq_q4_protection_on_threshold[0]=(((r).txq_q4_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q4_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q4_protection_on_threshold[0]=(((r).txq_q4_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q4_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q4_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr,(r._txq_q4_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q4_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr,&(r._txq_q4_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q4_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_t TXQ_Q4_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_TXQ4_PROT_ON_THf_GET BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_TXQ4_PROT_ON_THf_GET
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_TXQ4_PROT_ON_THf_SET BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_TXQ4_PROT_ON_THf_SET
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q4_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q4_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q4_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q4_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q4_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q4_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q5_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q5 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ5_CONG_ON_TH  The TXQ-Q5 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr 0x00000a3a

#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q5_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q5_congestion_on_threshold[1];
	uint32_t _txq_q5_congestion_on_threshold;
} BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q5_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q5_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q5_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_TXQ5_CONG_ON_THf_GET(r) (((r).txq_q5_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_TXQ5_CONG_ON_THf_SET(r,f) (r).txq_q5_congestion_on_threshold[0]=(((r).txq_q5_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q5_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q5_congestion_on_threshold[0]=(((r).txq_q5_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q5_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q5_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr,(r._txq_q5_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q5_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr,&(r._txq_q5_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q5_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_t TXQ_Q5_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_TXQ5_CONG_ON_THf_GET BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_TXQ5_CONG_ON_THf_GET
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_TXQ5_CONG_ON_THf_SET BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_TXQ5_CONG_ON_THf_SET
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q5_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q5_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q5_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q5_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q5_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q5_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q5_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q5 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q5_OVERS_ON_TH The TXQ-Q5 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr 0x00000a1d

#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q5_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q5_overs_on_threshold[1];
	uint32_t _txq_q5_overs_on_threshold;
} BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q5_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q5_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q5_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_TXQ_Q5_OVERS_ON_THf_GET(r) (((r).txq_q5_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_TXQ_Q5_OVERS_ON_THf_SET(r,f) (r).txq_q5_overs_on_threshold[0]=(((r).txq_q5_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q5_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q5_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr,(r._txq_q5_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q5_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr,&(r._txq_q5_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q5_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr
#define TXQ_Q5_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_t TXQ_Q5_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q5_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q5_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q5_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q5_OVERS_ON_THRESHOLDr_TXQ_Q5_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_TXQ_Q5_OVERS_ON_THf_GET
#define TXQ_Q5_OVERS_ON_THRESHOLDr_TXQ_Q5_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr_TXQ_Q5_OVERS_ON_THf_SET
#define READ_TXQ_Q5_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q5_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q5_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q5_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q5_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q5_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q5 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ5_PROT_ON_TH  The TXQ-Q5 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr 0x00000a2a

#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q5_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q5_protection_on_threshold[1];
	uint32_t _txq_q5_protection_on_threshold;
} BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q5_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q5_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q5_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_TXQ5_PROT_ON_THf_GET(r) (((r).txq_q5_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_TXQ5_PROT_ON_THf_SET(r,f) (r).txq_q5_protection_on_threshold[0]=(((r).txq_q5_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q5_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q5_protection_on_threshold[0]=(((r).txq_q5_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q5_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q5_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr,(r._txq_q5_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q5_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr,&(r._txq_q5_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q5_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_t TXQ_Q5_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_TXQ5_PROT_ON_THf_GET BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_TXQ5_PROT_ON_THf_GET
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_TXQ5_PROT_ON_THf_SET BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_TXQ5_PROT_ON_THf_SET
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q5_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q5_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q5_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q5_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q5_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q5_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q6_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q6 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ6_CONG_ON_TH  The TXQ-Q6 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr 0x00000a3c

#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q6_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q6_congestion_on_threshold[1];
	uint32_t _txq_q6_congestion_on_threshold;
} BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q6_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q6_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q6_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_TXQ6_CONG_ON_THf_GET(r) (((r).txq_q6_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_TXQ6_CONG_ON_THf_SET(r,f) (r).txq_q6_congestion_on_threshold[0]=(((r).txq_q6_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q6_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q6_congestion_on_threshold[0]=(((r).txq_q6_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q6_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q6_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr,(r._txq_q6_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q6_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr,&(r._txq_q6_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q6_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_t TXQ_Q6_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_TXQ6_CONG_ON_THf_GET BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_TXQ6_CONG_ON_THf_GET
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_TXQ6_CONG_ON_THf_SET BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_TXQ6_CONG_ON_THf_SET
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q6_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q6_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q6_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q6_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q6_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q6_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q6_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q6 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q6_OVERS_ON_TH The TXQ-Q6 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr 0x00000a1e

#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q6_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q6_overs_on_threshold[1];
	uint32_t _txq_q6_overs_on_threshold;
} BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q6_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q6_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q6_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_TXQ_Q6_OVERS_ON_THf_GET(r) (((r).txq_q6_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_TXQ_Q6_OVERS_ON_THf_SET(r,f) (r).txq_q6_overs_on_threshold[0]=(((r).txq_q6_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q6_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q6_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr,(r._txq_q6_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q6_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr,&(r._txq_q6_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q6_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr
#define TXQ_Q6_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_t TXQ_Q6_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q6_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q6_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q6_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q6_OVERS_ON_THRESHOLDr_TXQ_Q6_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_TXQ_Q6_OVERS_ON_THf_GET
#define TXQ_Q6_OVERS_ON_THRESHOLDr_TXQ_Q6_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr_TXQ_Q6_OVERS_ON_THf_SET
#define READ_TXQ_Q6_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q6_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q6_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q6_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q6_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q6_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q6 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ6_PROT_ON_TH  The TXQ-Q6 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr 0x00000a2c

#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q6_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q6_protection_on_threshold[1];
	uint32_t _txq_q6_protection_on_threshold;
} BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q6_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q6_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q6_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_TXQ6_PROT_ON_THf_GET(r) (((r).txq_q6_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_TXQ6_PROT_ON_THf_SET(r,f) (r).txq_q6_protection_on_threshold[0]=(((r).txq_q6_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q6_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q6_protection_on_threshold[0]=(((r).txq_q6_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q6_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q6_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr,(r._txq_q6_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q6_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr,&(r._txq_q6_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q6_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_t TXQ_Q6_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_TXQ6_PROT_ON_THf_GET BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_TXQ6_PROT_ON_THf_GET
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_TXQ6_PROT_ON_THf_SET BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_TXQ6_PROT_ON_THf_SET
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q6_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q6_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q6_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q6_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q6_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q6_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q7_CONGESTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q7 Congestion ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ7_CONG_ON_TH  The TXQ-Q7 Congestion_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr 0x00000a3e

#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q7_CONGESTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q7_congestion_on_threshold[1];
	uint32_t _txq_q7_congestion_on_threshold;
} BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_CLR(r) (r).txq_q7_congestion_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_SET(r,d) (r).txq_q7_congestion_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_GET(r) (r).txq_q7_congestion_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_TXQ7_CONG_ON_THf_GET(r) (((r).txq_q7_congestion_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_TXQ7_CONG_ON_THf_SET(r,f) (r).txq_q7_congestion_on_threshold[0]=(((r).txq_q7_congestion_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q7_congestion_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q7_congestion_on_threshold[0]=(((r).txq_q7_congestion_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q7_CONGESTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q7_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr,(r._txq_q7_congestion_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q7_CONGESTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr,&(r._txq_q7_congestion_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q7_CONGESTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_t TXQ_Q7_CONGESTION_ON_THRESHOLDr_t;
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_CLR
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_SET
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_GET
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_TXQ7_CONG_ON_THf_GET BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_TXQ7_CONG_ON_THf_GET
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_TXQ7_CONG_ON_THf_SET BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_TXQ7_CONG_ON_THf_SET
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q7_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q7_CONGESTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q7_CONGESTION_ON_THRESHOLDr
#define WRITE_TXQ_Q7_CONGESTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q7_CONGESTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q7_CONGESTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q7_OVERS_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q7 OverSubscription ON Threshold Register
 * SIZE:     8
 * FIELDS:
 *     TXQ_Q7_OVERS_ON_TH The TXQ-Q7 OverSubscription_ON threshold setting.The unit is "Buffer Cell Size"(256bytes).
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr 0x00000a1f

#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_Q7_OVERS_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q7_overs_on_threshold[1];
	uint32_t _txq_q7_overs_on_threshold;
} BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_CLR(r) (r).txq_q7_overs_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_SET(r,d) (r).txq_q7_overs_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_GET(r) (r).txq_q7_overs_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_TXQ_Q7_OVERS_ON_THf_GET(r) (((r).txq_q7_overs_on_threshold[0]) & 0xff)
#define BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_TXQ_Q7_OVERS_ON_THf_SET(r,f) (r).txq_q7_overs_on_threshold[0]=(((r).txq_q7_overs_on_threshold[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TXQ_Q7_OVERS_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q7_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr,(r._txq_q7_overs_on_threshold),1)
#define BCM53600_A0_WRITE_TXQ_Q7_OVERS_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr,&(r._txq_q7_overs_on_threshold),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q7_OVERS_ON_THRESHOLDr BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr
#define TXQ_Q7_OVERS_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_t TXQ_Q7_OVERS_ON_THRESHOLDr_t;
#define TXQ_Q7_OVERS_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_CLR
#define TXQ_Q7_OVERS_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_SET
#define TXQ_Q7_OVERS_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_GET
#define TXQ_Q7_OVERS_ON_THRESHOLDr_TXQ_Q7_OVERS_ON_THf_GET BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_TXQ_Q7_OVERS_ON_THf_GET
#define TXQ_Q7_OVERS_ON_THRESHOLDr_TXQ_Q7_OVERS_ON_THf_SET BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr_TXQ_Q7_OVERS_ON_THf_SET
#define READ_TXQ_Q7_OVERS_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q7_OVERS_ON_THRESHOLDr
#define WRITE_TXQ_Q7_OVERS_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q7_OVERS_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q7_OVERS_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_Q7_PROTECTION_ON_THRESHOLD
 * BLOCKS:   SYS
 * DESC:     TXQ-Q7 Protection ON Threshold Register
 * SIZE:     16
 * FIELDS:
 *     TXQ7_PROT_ON_TH  The TXQ-Q7 Protection_ON threshold setting.The unit is "Buffer Cell Size"(256 bytes)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr 0x00000a2e

#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_SIZE 2

/*
 * This structure should be used to declare and program TXQ_Q7_PROTECTION_ON_THRESHOLD.
 *
 */
typedef union BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t txq_q7_protection_on_threshold[1];
	uint32_t _txq_q7_protection_on_threshold;
} BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_t;

#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_CLR(r) (r).txq_q7_protection_on_threshold[0] = 0
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_SET(r,d) (r).txq_q7_protection_on_threshold[0] = d
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_GET(r) (r).txq_q7_protection_on_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_TXQ7_PROT_ON_THf_GET(r) (((r).txq_q7_protection_on_threshold[0]) & 0x1fff)
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_TXQ7_PROT_ON_THf_SET(r,f) (r).txq_q7_protection_on_threshold[0]=(((r).txq_q7_protection_on_threshold[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET(r) ((((r).txq_q7_protection_on_threshold[0]) >> 13) & 0x7)
#define BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET(r,f) (r).txq_q7_protection_on_threshold[0]=(((r).txq_q7_protection_on_threshold[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access TXQ_Q7_PROTECTION_ON_THRESHOLD.
 *
 */
#define BCM53600_A0_READ_TXQ_Q7_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr,(r._txq_q7_protection_on_threshold),2)
#define BCM53600_A0_WRITE_TXQ_Q7_PROTECTION_ON_THRESHOLDr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr,&(r._txq_q7_protection_on_threshold),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_Q7_PROTECTION_ON_THRESHOLDr BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_SIZE BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_SIZE
typedef BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_t TXQ_Q7_PROTECTION_ON_THRESHOLDr_t;
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_CLR BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_CLR
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_SET BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_SET
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_GET BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_GET
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_TXQ7_PROT_ON_THf_GET BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_TXQ7_PROT_ON_THf_GET
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_TXQ7_PROT_ON_THf_SET BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_TXQ7_PROT_ON_THf_SET
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_RESERVEDf_GET
#define TXQ_Q7_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr_RESERVEDf_SET
#define READ_TXQ_Q7_PROTECTION_ON_THRESHOLDr BCM53600_A0_READ_TXQ_Q7_PROTECTION_ON_THRESHOLDr
#define WRITE_TXQ_Q7_PROTECTION_ON_THRESHOLDr BCM53600_A0_WRITE_TXQ_Q7_PROTECTION_ON_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_Q7_PROTECTION_ON_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TXQ_WEIGHT_QUOTA_SZ
 * BLOCKS:   SYS
 * DESC:     TXQ Weight Quota Size Register
 * SIZE:     64
 * FIELDS:
 *     TXQ0_WEIGHT_QUOTA TXQ-Q0 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ1_WEIGHT_QUOTA TXQ-Q1 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ2_WEIGHT_QUOTA TXQ-Q2 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ3_WEIGHT_QUOTA TXQ-Q3 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ4_WEIGHT_QUOTA TXQ-Q4 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ5_WEIGHT_QUOTA TXQ-Q5 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ6_WEIGHT_QUOTA TXQ-Q6 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *     TXQ7_WEIGHT_QUOTA TXQ-Q7 Weight Quota Size.If WDRR_GRANULARITY = 1, the value = number of packet.If WDRR_GRANULARITY = 0, the value = number of 16-bytes.
 *
 ******************************************************************************/
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr 0x00003002

#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_SIZE 8

/*
 * This structure should be used to declare and program TXQ_WEIGHT_QUOTA_SZ.
 *
 */
typedef union BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_s {
	uint32_t v[2];
	uint32_t txq_weight_quota_sz[2];
	uint32_t _txq_weight_quota_sz;
} BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_t;

#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_CLR(r) CDK_MEMSET(&((r)._txq_weight_quota_sz), 0, sizeof(BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_t))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_SET(r,i,d) (r).txq_weight_quota_sz[i] = d
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_GET(r,i) (r).txq_weight_quota_sz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ0_WEIGHT_QUOTAf_GET(r) (((r).txq_weight_quota_sz[0]) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ0_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[0]=(((r).txq_weight_quota_sz[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ1_WEIGHT_QUOTAf_GET(r) ((((r).txq_weight_quota_sz[0]) >> 8) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ1_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[0]=(((r).txq_weight_quota_sz[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ2_WEIGHT_QUOTAf_GET(r) ((((r).txq_weight_quota_sz[0]) >> 16) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ2_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[0]=(((r).txq_weight_quota_sz[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ3_WEIGHT_QUOTAf_GET(r) ((((r).txq_weight_quota_sz[0]) >> 24) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ3_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[0]=(((r).txq_weight_quota_sz[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ4_WEIGHT_QUOTAf_GET(r) (((r).txq_weight_quota_sz[1]) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ4_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[1]=(((r).txq_weight_quota_sz[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ5_WEIGHT_QUOTAf_GET(r) ((((r).txq_weight_quota_sz[1]) >> 8) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ5_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[1]=(((r).txq_weight_quota_sz[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ6_WEIGHT_QUOTAf_GET(r) ((((r).txq_weight_quota_sz[1]) >> 16) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ6_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[1]=(((r).txq_weight_quota_sz[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ7_WEIGHT_QUOTAf_GET(r) ((((r).txq_weight_quota_sz[1]) >> 24) & 0xff)
#define BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ7_WEIGHT_QUOTAf_SET(r,f) (r).txq_weight_quota_sz[1]=(((r).txq_weight_quota_sz[1] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access TXQ_WEIGHT_QUOTA_SZ.
 *
 */
#define BCM53600_A0_READ_TXQ_WEIGHT_QUOTA_SZr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr,(r._txq_weight_quota_sz),8)
#define BCM53600_A0_WRITE_TXQ_WEIGHT_QUOTA_SZr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr,&(r._txq_weight_quota_sz),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_WEIGHT_QUOTA_SZr BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr
#define TXQ_WEIGHT_QUOTA_SZr_SIZE BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_SIZE
typedef BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_t TXQ_WEIGHT_QUOTA_SZr_t;
#define TXQ_WEIGHT_QUOTA_SZr_CLR BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_CLR
#define TXQ_WEIGHT_QUOTA_SZr_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_SET
#define TXQ_WEIGHT_QUOTA_SZr_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ0_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ0_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ0_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ0_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ1_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ1_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ1_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ1_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ2_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ2_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ2_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ2_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ3_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ3_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ3_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ3_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ4_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ4_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ4_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ4_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ5_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ5_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ5_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ5_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ6_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ6_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ6_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ6_WEIGHT_QUOTAf_SET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ7_WEIGHT_QUOTAf_GET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ7_WEIGHT_QUOTAf_GET
#define TXQ_WEIGHT_QUOTA_SZr_TXQ7_WEIGHT_QUOTAf_SET BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr_TXQ7_WEIGHT_QUOTAf_SET
#define READ_TXQ_WEIGHT_QUOTA_SZr BCM53600_A0_READ_TXQ_WEIGHT_QUOTA_SZr
#define WRITE_TXQ_WEIGHT_QUOTA_SZr BCM53600_A0_WRITE_TXQ_WEIGHT_QUOTA_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXQ_WEIGHT_QUOTA_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXBROADCASTPKTSr 0x0000522c

#define BCM53600_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 *
 */
typedef union BCM53600_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM53600_A0_TXBROADCASTPKTSr_t;

#define BCM53600_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM53600_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM53600_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 *
 */
#define BCM53600_A0_READ_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM53600_A0_WRITE_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM53600_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM53600_A0_TXBROADCASTPKTSr_SIZE
typedef BCM53600_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM53600_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM53600_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM53600_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM53600_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM53600_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   SYS
 * DESC:     Tx Collisions Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXCOLLISIONSr 0x00005238

#define BCM53600_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 *
 */
typedef union BCM53600_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM53600_A0_TXCOLLISIONSr_t;

#define BCM53600_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM53600_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM53600_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 *
 */
#define BCM53600_A0_READ_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM53600_A0_WRITE_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM53600_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM53600_A0_TXCOLLISIONSr_SIZE
typedef BCM53600_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM53600_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM53600_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM53600_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM53600_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM53600_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXDEFERREDTRANSMITr 0x00005244

#define BCM53600_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 *
 */
typedef union BCM53600_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM53600_A0_TXDEFERREDTRANSMITr_t;

#define BCM53600_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM53600_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM53600_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 *
 */
#define BCM53600_A0_READ_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM53600_A0_WRITE_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM53600_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM53600_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM53600_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM53600_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM53600_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM53600_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM53600_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM53600_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXEXCESSIVECOLLISIONr 0x0000524c

#define BCM53600_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 *
 */
typedef union BCM53600_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM53600_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM53600_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM53600_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM53600_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 *
 */
#define BCM53600_A0_READ_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM53600_A0_WRITE_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM53600_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM53600_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53600_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM53600_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM53600_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM53600_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM53600_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM53600_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXLATECOLLISIONr 0x00005248

#define BCM53600_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 *
 */
typedef union BCM53600_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM53600_A0_TXLATECOLLISIONr_t;

#define BCM53600_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM53600_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM53600_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 *
 */
#define BCM53600_A0_READ_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM53600_A0_WRITE_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM53600_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM53600_A0_TXLATECOLLISIONr_SIZE
typedef BCM53600_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM53600_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM53600_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM53600_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM53600_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM53600_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXMULTICASTPKTSr 0x00005230

#define BCM53600_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 *
 */
typedef union BCM53600_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM53600_A0_TXMULTICASTPKTSr_t;

#define BCM53600_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM53600_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM53600_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 *
 */
#define BCM53600_A0_READ_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM53600_A0_WRITE_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM53600_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM53600_A0_TXMULTICASTPKTSr_SIZE
typedef BCM53600_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM53600_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM53600_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM53600_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM53600_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM53600_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxMultipleCollisions
 * BLOCKS:   SYS
 * DESC:     Tx MultipleCollisions Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXMULTIPLECOLLISIONSr 0x00005240

#define BCM53600_A0_TXMULTIPLECOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollisions.
 *
 */
typedef union BCM53600_A0_TXMULTIPLECOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txmultiplecollisions[1];
	uint32_t _txmultiplecollisions;
} BCM53600_A0_TXMULTIPLECOLLISIONSr_t;

#define BCM53600_A0_TXMULTIPLECOLLISIONSr_CLR(r) (r).txmultiplecollisions[0] = 0
#define BCM53600_A0_TXMULTIPLECOLLISIONSr_SET(r,d) (r).txmultiplecollisions[0] = d
#define BCM53600_A0_TXMULTIPLECOLLISIONSr_GET(r) (r).txmultiplecollisions[0]


/*
 * These macros can be used to access TxMultipleCollisions.
 *
 */
#define BCM53600_A0_READ_TXMULTIPLECOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXMULTIPLECOLLISIONSr,(r._txmultiplecollisions),4)
#define BCM53600_A0_WRITE_TXMULTIPLECOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXMULTIPLECOLLISIONSr,&(r._txmultiplecollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONSr BCM53600_A0_TXMULTIPLECOLLISIONSr
#define TXMULTIPLECOLLISIONSr_SIZE BCM53600_A0_TXMULTIPLECOLLISIONSr_SIZE
typedef BCM53600_A0_TXMULTIPLECOLLISIONSr_t TXMULTIPLECOLLISIONSr_t;
#define TXMULTIPLECOLLISIONSr_CLR BCM53600_A0_TXMULTIPLECOLLISIONSr_CLR
#define TXMULTIPLECOLLISIONSr_SET BCM53600_A0_TXMULTIPLECOLLISIONSr_SET
#define TXMULTIPLECOLLISIONSr_GET BCM53600_A0_TXMULTIPLECOLLISIONSr_GET
#define READ_TXMULTIPLECOLLISIONSr BCM53600_A0_READ_TXMULTIPLECOLLISIONSr
#define WRITE_TXMULTIPLECOLLISIONSr BCM53600_A0_WRITE_TXMULTIPLECOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXMULTIPLECOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxOctets
 * BLOCKS:   SYS
 * DESC:     Tx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53600_A0_TXOCTETSr 0x0000521c

#define BCM53600_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 *
 */
typedef union BCM53600_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM53600_A0_TXOCTETSr_t;

#define BCM53600_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM53600_A0_TXOCTETSr_t))
#define BCM53600_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM53600_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 *
 */
#define BCM53600_A0_READ_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXOCTETSr,(r._txoctets),8)
#define BCM53600_A0_WRITE_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM53600_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM53600_A0_TXOCTETSr_SIZE
typedef BCM53600_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM53600_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM53600_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM53600_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM53600_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM53600_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Tx Pause Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPAUSEPKTSr 0x00005228

#define BCM53600_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 *
 */
typedef union BCM53600_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM53600_A0_TXPAUSEPKTSr_t;

#define BCM53600_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM53600_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM53600_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 *
 */
#define BCM53600_A0_READ_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM53600_A0_WRITE_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM53600_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM53600_A0_TXPAUSEPKTSr_SIZE
typedef BCM53600_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM53600_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM53600_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM53600_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM53600_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM53600_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPkts1024toMaxPkt
 * BLOCKS:   SYS
 * DESC:     Tx 1024 Bytes Octets to Standard Maximum Size Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPKTS1024TOMAXPKTr 0x00005214

#define BCM53600_A0_TXPKTS1024TOMAXPKTr_SIZE 4

/*
 * This structure should be used to declare and program TxPkts1024toMaxPkt.
 *
 */
typedef union BCM53600_A0_TXPKTS1024TOMAXPKTr_s {
	uint32_t v[1];
	uint32_t txpkts1024tomaxpkt[1];
	uint32_t _txpkts1024tomaxpkt;
} BCM53600_A0_TXPKTS1024TOMAXPKTr_t;

#define BCM53600_A0_TXPKTS1024TOMAXPKTr_CLR(r) (r).txpkts1024tomaxpkt[0] = 0
#define BCM53600_A0_TXPKTS1024TOMAXPKTr_SET(r,d) (r).txpkts1024tomaxpkt[0] = d
#define BCM53600_A0_TXPKTS1024TOMAXPKTr_GET(r) (r).txpkts1024tomaxpkt[0]


/*
 * These macros can be used to access TxPkts1024toMaxPkt.
 *
 */
#define BCM53600_A0_READ_TXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPKTS1024TOMAXPKTr,(r._txpkts1024tomaxpkt),4)
#define BCM53600_A0_WRITE_TXPKTS1024TOMAXPKTr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPKTS1024TOMAXPKTr,&(r._txpkts1024tomaxpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPKTS1024TOMAXPKTr BCM53600_A0_TXPKTS1024TOMAXPKTr
#define TXPKTS1024TOMAXPKTr_SIZE BCM53600_A0_TXPKTS1024TOMAXPKTr_SIZE
typedef BCM53600_A0_TXPKTS1024TOMAXPKTr_t TXPKTS1024TOMAXPKTr_t;
#define TXPKTS1024TOMAXPKTr_CLR BCM53600_A0_TXPKTS1024TOMAXPKTr_CLR
#define TXPKTS1024TOMAXPKTr_SET BCM53600_A0_TXPKTS1024TOMAXPKTr_SET
#define TXPKTS1024TOMAXPKTr_GET BCM53600_A0_TXPKTS1024TOMAXPKTr_GET
#define READ_TXPKTS1024TOMAXPKTr BCM53600_A0_READ_TXPKTS1024TOMAXPKTr
#define WRITE_TXPKTS1024TOMAXPKTr BCM53600_A0_WRITE_TXPKTS1024TOMAXPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPKTS1024TOMAXPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Tx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPKTS128TO255OCTETSr 0x00005208

#define BCM53600_A0_TXPKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program TxPkts128to255Octets.
 *
 */
typedef union BCM53600_A0_TXPKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t txpkts128to255octets[1];
	uint32_t _txpkts128to255octets;
} BCM53600_A0_TXPKTS128TO255OCTETSr_t;

#define BCM53600_A0_TXPKTS128TO255OCTETSr_CLR(r) (r).txpkts128to255octets[0] = 0
#define BCM53600_A0_TXPKTS128TO255OCTETSr_SET(r,d) (r).txpkts128to255octets[0] = d
#define BCM53600_A0_TXPKTS128TO255OCTETSr_GET(r) (r).txpkts128to255octets[0]


/*
 * These macros can be used to access TxPkts128to255Octets.
 *
 */
#define BCM53600_A0_READ_TXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPKTS128TO255OCTETSr,(r._txpkts128to255octets),4)
#define BCM53600_A0_WRITE_TXPKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPKTS128TO255OCTETSr,&(r._txpkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPKTS128TO255OCTETSr BCM53600_A0_TXPKTS128TO255OCTETSr
#define TXPKTS128TO255OCTETSr_SIZE BCM53600_A0_TXPKTS128TO255OCTETSr_SIZE
typedef BCM53600_A0_TXPKTS128TO255OCTETSr_t TXPKTS128TO255OCTETSr_t;
#define TXPKTS128TO255OCTETSr_CLR BCM53600_A0_TXPKTS128TO255OCTETSr_CLR
#define TXPKTS128TO255OCTETSr_SET BCM53600_A0_TXPKTS128TO255OCTETSr_SET
#define TXPKTS128TO255OCTETSr_GET BCM53600_A0_TXPKTS128TO255OCTETSr_GET
#define READ_TXPKTS128TO255OCTETSr BCM53600_A0_READ_TXPKTS128TO255OCTETSr
#define WRITE_TXPKTS128TO255OCTETSr BCM53600_A0_WRITE_TXPKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Tx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPKTS256TO511OCTETSr 0x0000520c

#define BCM53600_A0_TXPKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program TxPkts256to511Octets.
 *
 */
typedef union BCM53600_A0_TXPKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t txpkts256to511octets[1];
	uint32_t _txpkts256to511octets;
} BCM53600_A0_TXPKTS256TO511OCTETSr_t;

#define BCM53600_A0_TXPKTS256TO511OCTETSr_CLR(r) (r).txpkts256to511octets[0] = 0
#define BCM53600_A0_TXPKTS256TO511OCTETSr_SET(r,d) (r).txpkts256to511octets[0] = d
#define BCM53600_A0_TXPKTS256TO511OCTETSr_GET(r) (r).txpkts256to511octets[0]


/*
 * These macros can be used to access TxPkts256to511Octets.
 *
 */
#define BCM53600_A0_READ_TXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPKTS256TO511OCTETSr,(r._txpkts256to511octets),4)
#define BCM53600_A0_WRITE_TXPKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPKTS256TO511OCTETSr,&(r._txpkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPKTS256TO511OCTETSr BCM53600_A0_TXPKTS256TO511OCTETSr
#define TXPKTS256TO511OCTETSr_SIZE BCM53600_A0_TXPKTS256TO511OCTETSr_SIZE
typedef BCM53600_A0_TXPKTS256TO511OCTETSr_t TXPKTS256TO511OCTETSr_t;
#define TXPKTS256TO511OCTETSr_CLR BCM53600_A0_TXPKTS256TO511OCTETSr_CLR
#define TXPKTS256TO511OCTETSr_SET BCM53600_A0_TXPKTS256TO511OCTETSr_SET
#define TXPKTS256TO511OCTETSr_GET BCM53600_A0_TXPKTS256TO511OCTETSr_GET
#define READ_TXPKTS256TO511OCTETSr BCM53600_A0_READ_TXPKTS256TO511OCTETSr
#define WRITE_TXPKTS256TO511OCTETSr BCM53600_A0_WRITE_TXPKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Tx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPKTS512TO1023OCTETSr 0x00005210

#define BCM53600_A0_TXPKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program TxPkts512to1023Octets.
 *
 */
typedef union BCM53600_A0_TXPKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t txpkts512to1023octets[1];
	uint32_t _txpkts512to1023octets;
} BCM53600_A0_TXPKTS512TO1023OCTETSr_t;

#define BCM53600_A0_TXPKTS512TO1023OCTETSr_CLR(r) (r).txpkts512to1023octets[0] = 0
#define BCM53600_A0_TXPKTS512TO1023OCTETSr_SET(r,d) (r).txpkts512to1023octets[0] = d
#define BCM53600_A0_TXPKTS512TO1023OCTETSr_GET(r) (r).txpkts512to1023octets[0]


/*
 * These macros can be used to access TxPkts512to1023Octets.
 *
 */
#define BCM53600_A0_READ_TXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPKTS512TO1023OCTETSr,(r._txpkts512to1023octets),4)
#define BCM53600_A0_WRITE_TXPKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPKTS512TO1023OCTETSr,&(r._txpkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPKTS512TO1023OCTETSr BCM53600_A0_TXPKTS512TO1023OCTETSr
#define TXPKTS512TO1023OCTETSr_SIZE BCM53600_A0_TXPKTS512TO1023OCTETSr_SIZE
typedef BCM53600_A0_TXPKTS512TO1023OCTETSr_t TXPKTS512TO1023OCTETSr_t;
#define TXPKTS512TO1023OCTETSr_CLR BCM53600_A0_TXPKTS512TO1023OCTETSr_CLR
#define TXPKTS512TO1023OCTETSr_SET BCM53600_A0_TXPKTS512TO1023OCTETSr_SET
#define TXPKTS512TO1023OCTETSr_GET BCM53600_A0_TXPKTS512TO1023OCTETSr_GET
#define READ_TXPKTS512TO1023OCTETSr BCM53600_A0_READ_TXPKTS512TO1023OCTETSr
#define WRITE_TXPKTS512TO1023OCTETSr BCM53600_A0_WRITE_TXPKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPkts64Octets
 * BLOCKS:   SYS
 * DESC:     Tx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPKTS64OCTETSr 0x00005200

#define BCM53600_A0_TXPKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program TxPkts64Octets.
 *
 */
typedef union BCM53600_A0_TXPKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t txpkts64octets[1];
	uint32_t _txpkts64octets;
} BCM53600_A0_TXPKTS64OCTETSr_t;

#define BCM53600_A0_TXPKTS64OCTETSr_CLR(r) (r).txpkts64octets[0] = 0
#define BCM53600_A0_TXPKTS64OCTETSr_SET(r,d) (r).txpkts64octets[0] = d
#define BCM53600_A0_TXPKTS64OCTETSr_GET(r) (r).txpkts64octets[0]


/*
 * These macros can be used to access TxPkts64Octets.
 *
 */
#define BCM53600_A0_READ_TXPKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPKTS64OCTETSr,(r._txpkts64octets),4)
#define BCM53600_A0_WRITE_TXPKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPKTS64OCTETSr,&(r._txpkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPKTS64OCTETSr BCM53600_A0_TXPKTS64OCTETSr
#define TXPKTS64OCTETSr_SIZE BCM53600_A0_TXPKTS64OCTETSr_SIZE
typedef BCM53600_A0_TXPKTS64OCTETSr_t TXPKTS64OCTETSr_t;
#define TXPKTS64OCTETSr_CLR BCM53600_A0_TXPKTS64OCTETSr_CLR
#define TXPKTS64OCTETSr_SET BCM53600_A0_TXPKTS64OCTETSr_SET
#define TXPKTS64OCTETSr_GET BCM53600_A0_TXPKTS64OCTETSr_GET
#define READ_TXPKTS64OCTETSr BCM53600_A0_READ_TXPKTS64OCTETSr
#define WRITE_TXPKTS64OCTETSr BCM53600_A0_WRITE_TXPKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Tx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPKTS65TO127OCTETSr 0x00005204

#define BCM53600_A0_TXPKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program TxPkts65to127Octets.
 *
 */
typedef union BCM53600_A0_TXPKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t txpkts65to127octets[1];
	uint32_t _txpkts65to127octets;
} BCM53600_A0_TXPKTS65TO127OCTETSr_t;

#define BCM53600_A0_TXPKTS65TO127OCTETSr_CLR(r) (r).txpkts65to127octets[0] = 0
#define BCM53600_A0_TXPKTS65TO127OCTETSr_SET(r,d) (r).txpkts65to127octets[0] = d
#define BCM53600_A0_TXPKTS65TO127OCTETSr_GET(r) (r).txpkts65to127octets[0]


/*
 * These macros can be used to access TxPkts65to127Octets.
 *
 */
#define BCM53600_A0_READ_TXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPKTS65TO127OCTETSr,(r._txpkts65to127octets),4)
#define BCM53600_A0_WRITE_TXPKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPKTS65TO127OCTETSr,&(r._txpkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPKTS65TO127OCTETSr BCM53600_A0_TXPKTS65TO127OCTETSr
#define TXPKTS65TO127OCTETSr_SIZE BCM53600_A0_TXPKTS65TO127OCTETSr_SIZE
typedef BCM53600_A0_TXPKTS65TO127OCTETSr_t TXPKTS65TO127OCTETSr_t;
#define TXPKTS65TO127OCTETSr_CLR BCM53600_A0_TXPKTS65TO127OCTETSr_CLR
#define TXPKTS65TO127OCTETSr_SET BCM53600_A0_TXPKTS65TO127OCTETSr_SET
#define TXPKTS65TO127OCTETSr_GET BCM53600_A0_TXPKTS65TO127OCTETSr_GET
#define READ_TXPKTS65TO127OCTETSr BCM53600_A0_READ_TXPKTS65TO127OCTETSr
#define WRITE_TXPKTS65TO127OCTETSr BCM53600_A0_WRITE_TXPKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxPortCongestionDrop
 * BLOCKS:   SYS
 * DESC:     Tx Port Congestion Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXPORTCONGESTIONDROPr 0x00005250

#define BCM53600_A0_TXPORTCONGESTIONDROPr_SIZE 4

/*
 * This structure should be used to declare and program TxPortCongestionDrop.
 *
 */
typedef union BCM53600_A0_TXPORTCONGESTIONDROPr_s {
	uint32_t v[1];
	uint32_t txportcongestiondrop[1];
	uint32_t _txportcongestiondrop;
} BCM53600_A0_TXPORTCONGESTIONDROPr_t;

#define BCM53600_A0_TXPORTCONGESTIONDROPr_CLR(r) (r).txportcongestiondrop[0] = 0
#define BCM53600_A0_TXPORTCONGESTIONDROPr_SET(r,d) (r).txportcongestiondrop[0] = d
#define BCM53600_A0_TXPORTCONGESTIONDROPr_GET(r) (r).txportcongestiondrop[0]


/*
 * These macros can be used to access TxPortCongestionDrop.
 *
 */
#define BCM53600_A0_READ_TXPORTCONGESTIONDROPr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXPORTCONGESTIONDROPr,(r._txportcongestiondrop),4)
#define BCM53600_A0_WRITE_TXPORTCONGESTIONDROPr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXPORTCONGESTIONDROPr,&(r._txportcongestiondrop),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPORTCONGESTIONDROPr BCM53600_A0_TXPORTCONGESTIONDROPr
#define TXPORTCONGESTIONDROPr_SIZE BCM53600_A0_TXPORTCONGESTIONDROPr_SIZE
typedef BCM53600_A0_TXPORTCONGESTIONDROPr_t TXPORTCONGESTIONDROPr_t;
#define TXPORTCONGESTIONDROPr_CLR BCM53600_A0_TXPORTCONGESTIONDROPr_CLR
#define TXPORTCONGESTIONDROPr_SET BCM53600_A0_TXPORTCONGESTIONDROPr_SET
#define TXPORTCONGESTIONDROPr_GET BCM53600_A0_TXPORTCONGESTIONDROPr_GET
#define READ_TXPORTCONGESTIONDROPr BCM53600_A0_READ_TXPORTCONGESTIONDROPr
#define WRITE_TXPORTCONGESTIONDROPr BCM53600_A0_WRITE_TXPORTCONGESTIONDROPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXPORTCONGESTIONDROPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxSingleCollisions
 * BLOCKS:   SYS
 * DESC:     Tx SingleCollisions Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXSINGLECOLLISIONSr 0x0000523c

#define BCM53600_A0_TXSINGLECOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollisions.
 *
 */
typedef union BCM53600_A0_TXSINGLECOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txsinglecollisions[1];
	uint32_t _txsinglecollisions;
} BCM53600_A0_TXSINGLECOLLISIONSr_t;

#define BCM53600_A0_TXSINGLECOLLISIONSr_CLR(r) (r).txsinglecollisions[0] = 0
#define BCM53600_A0_TXSINGLECOLLISIONSr_SET(r,d) (r).txsinglecollisions[0] = d
#define BCM53600_A0_TXSINGLECOLLISIONSr_GET(r) (r).txsinglecollisions[0]


/*
 * These macros can be used to access TxSingleCollisions.
 *
 */
#define BCM53600_A0_READ_TXSINGLECOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXSINGLECOLLISIONSr,(r._txsinglecollisions),4)
#define BCM53600_A0_WRITE_TXSINGLECOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXSINGLECOLLISIONSr,&(r._txsinglecollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONSr BCM53600_A0_TXSINGLECOLLISIONSr
#define TXSINGLECOLLISIONSr_SIZE BCM53600_A0_TXSINGLECOLLISIONSr_SIZE
typedef BCM53600_A0_TXSINGLECOLLISIONSr_t TXSINGLECOLLISIONSr_t;
#define TXSINGLECOLLISIONSr_CLR BCM53600_A0_TXSINGLECOLLISIONSr_CLR
#define TXSINGLECOLLISIONSr_SET BCM53600_A0_TXSINGLECOLLISIONSr_SET
#define TXSINGLECOLLISIONSr_GET BCM53600_A0_TXSINGLECOLLISIONSr_GET
#define READ_TXSINGLECOLLISIONSr BCM53600_A0_READ_TXSINGLECOLLISIONSr
#define WRITE_TXSINGLECOLLISIONSr BCM53600_A0_WRITE_TXSINGLECOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXSINGLECOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TXUNICASTPKTSr 0x00005234

#define BCM53600_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 *
 */
typedef union BCM53600_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM53600_A0_TXUNICASTPKTSr_t;

#define BCM53600_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM53600_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM53600_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 *
 */
#define BCM53600_A0_READ_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM53600_A0_WRITE_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM53600_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM53600_A0_TXUNICASTPKTSr_SIZE
typedef BCM53600_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM53600_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM53600_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM53600_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM53600_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM53600_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  Tx_Jumbo_Packet_Counter
 * BLOCKS:   SYS
 * DESC:     Tx Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53600_A0_TX_JUMBO_PACKET_COUNTERr 0x00005218

#define BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program Tx_Jumbo_Packet_Counter.
 *
 */
typedef union BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_s {
	uint32_t v[1];
	uint32_t tx_jumbo_packet_counter[1];
	uint32_t _tx_jumbo_packet_counter;
} BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_t;

#define BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_CLR(r) (r).tx_jumbo_packet_counter[0] = 0
#define BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_SET(r,d) (r).tx_jumbo_packet_counter[0] = d
#define BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_GET(r) (r).tx_jumbo_packet_counter[0]


/*
 * These macros can be used to access Tx_Jumbo_Packet_Counter.
 *
 */
#define BCM53600_A0_READ_TX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_read(u,BCM53600_A0_TX_JUMBO_PACKET_COUNTERr,(r._tx_jumbo_packet_counter),4)
#define BCM53600_A0_WRITE_TX_JUMBO_PACKET_COUNTERr(u,r) cdk_robo_reg_write(u,BCM53600_A0_TX_JUMBO_PACKET_COUNTERr,&(r._tx_jumbo_packet_counter),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_JUMBO_PACKET_COUNTERr BCM53600_A0_TX_JUMBO_PACKET_COUNTERr
#define TX_JUMBO_PACKET_COUNTERr_SIZE BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_SIZE
typedef BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_t TX_JUMBO_PACKET_COUNTERr_t;
#define TX_JUMBO_PACKET_COUNTERr_CLR BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_CLR
#define TX_JUMBO_PACKET_COUNTERr_SET BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_SET
#define TX_JUMBO_PACKET_COUNTERr_GET BCM53600_A0_TX_JUMBO_PACKET_COUNTERr_GET
#define READ_TX_JUMBO_PACKET_COUNTERr BCM53600_A0_READ_TX_JUMBO_PACKET_COUNTERr
#define WRITE_TX_JUMBO_PACKET_COUNTERr BCM53600_A0_WRITE_TX_JUMBO_PACKET_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_TX_JUMBO_PACKET_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  VID_RANGE_CHECKER
 * BLOCKS:   SYS
 * DESC:     VID Range Checker Register
 * SIZE:     32
 * FIELDS:
 *     SMALL_VALUE      Small Value.Large >= xxxx >= Small
 *     RESERVED_0       Reserved.
 *     LARGE_VALUE      Large Value.Large >= xxxx >= Small
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_VID_RANGE_CHECKERr 0x00002130

#define BCM53600_A0_VID_RANGE_CHECKERr_SIZE 4

/*
 * This structure should be used to declare and program VID_RANGE_CHECKER.
 *
 */
typedef union BCM53600_A0_VID_RANGE_CHECKERr_s {
	uint32_t v[1];
	uint32_t vid_range_checker[1];
	uint32_t _vid_range_checker;
} BCM53600_A0_VID_RANGE_CHECKERr_t;

#define BCM53600_A0_VID_RANGE_CHECKERr_CLR(r) (r).vid_range_checker[0] = 0
#define BCM53600_A0_VID_RANGE_CHECKERr_SET(r,d) (r).vid_range_checker[0] = d
#define BCM53600_A0_VID_RANGE_CHECKERr_GET(r) (r).vid_range_checker[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_VID_RANGE_CHECKERr_SMALL_VALUEf_GET(r) (((r).vid_range_checker[0]) & 0xfff)
#define BCM53600_A0_VID_RANGE_CHECKERr_SMALL_VALUEf_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_0f_GET(r) ((((r).vid_range_checker[0]) >> 12) & 0xf)
#define BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_0f_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53600_A0_VID_RANGE_CHECKERr_LARGE_VALUEf_GET(r) ((((r).vid_range_checker[0]) >> 16) & 0xfff)
#define BCM53600_A0_VID_RANGE_CHECKERr_LARGE_VALUEf_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_1f_GET(r) ((((r).vid_range_checker[0]) >> 28) & 0xf)
#define BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_1f_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access VID_RANGE_CHECKER.
 *
 */
#define BCM53600_A0_READ_VID_RANGE_CHECKERr(u,i,r) cdk_robo_reg_read(u,BCM53600_A0_VID_RANGE_CHECKERr+(4*(i)),(r._vid_range_checker),4)
#define BCM53600_A0_WRITE_VID_RANGE_CHECKERr(u,i,r) cdk_robo_reg_write(u,BCM53600_A0_VID_RANGE_CHECKERr+(4*(i)),&(r._vid_range_checker),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VID_RANGE_CHECKERr BCM53600_A0_VID_RANGE_CHECKERr
#define VID_RANGE_CHECKERr_SIZE BCM53600_A0_VID_RANGE_CHECKERr_SIZE
typedef BCM53600_A0_VID_RANGE_CHECKERr_t VID_RANGE_CHECKERr_t;
#define VID_RANGE_CHECKERr_CLR BCM53600_A0_VID_RANGE_CHECKERr_CLR
#define VID_RANGE_CHECKERr_SET BCM53600_A0_VID_RANGE_CHECKERr_SET
#define VID_RANGE_CHECKERr_GET BCM53600_A0_VID_RANGE_CHECKERr_GET
#define VID_RANGE_CHECKERr_SMALL_VALUEf_GET BCM53600_A0_VID_RANGE_CHECKERr_SMALL_VALUEf_GET
#define VID_RANGE_CHECKERr_SMALL_VALUEf_SET BCM53600_A0_VID_RANGE_CHECKERr_SMALL_VALUEf_SET
#define VID_RANGE_CHECKERr_RESERVED_0f_GET BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_0f_GET
#define VID_RANGE_CHECKERr_RESERVED_0f_SET BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_0f_SET
#define VID_RANGE_CHECKERr_LARGE_VALUEf_GET BCM53600_A0_VID_RANGE_CHECKERr_LARGE_VALUEf_GET
#define VID_RANGE_CHECKERr_LARGE_VALUEf_SET BCM53600_A0_VID_RANGE_CHECKERr_LARGE_VALUEf_SET
#define VID_RANGE_CHECKERr_RESERVED_1f_GET BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_1f_GET
#define VID_RANGE_CHECKERr_RESERVED_1f_SET BCM53600_A0_VID_RANGE_CHECKERr_RESERVED_1f_SET
#define READ_VID_RANGE_CHECKERr BCM53600_A0_READ_VID_RANGE_CHECKERr
#define WRITE_VID_RANGE_CHECKERr BCM53600_A0_WRITE_VID_RANGE_CHECKERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_VID_RANGE_CHECKERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     101
 * FIELDS:
 *     FORWARD_MAP      Forward port bitmap
 *     MSPT_ID          VLAN Table spaning ID
 *     DIS_LRN          Disable learning
 *     DIR_FWD          Direct Forward
 *     ULF_DROP         Unicast Pkt LF drop
 *     MLF_DROP         Multicast Pkt LF drop
 *     ISO_MAP          Isolation Map
 *     V_UNTAG_MAP      VLAN Untag Map
 *     L2MC_BC          L2 Multicast index for the broadcast packet
 *     L2MC_MLF         L2 Multicast index for the multicast packet which DA is not found in the ARL table
 *     L2MC_ULF         L2 Multicast index for the unicast packet which DA is not found in the ARL table
 *     EN_BC_REP        Enable L2 Multicast index for Broadcast packet forwarding decision
 *     EN_MLF_REP       Enable L2 Multicast index for MLF packet forwarding decision
 *     EN_ULF_REP       Enable L2 Multicast index for ULF packet forwarding decision
 *
 ******************************************************************************/
#define BCM53600_A0_VLAN_1Qm 0x60030800

#define BCM53600_A0_VLAN_1Qm_MIN 0
#define BCM53600_A0_VLAN_1Qm_MAX 4095
#define BCM53600_A0_VLAN_1Qm_CMAX(u) 4095
#define BCM53600_A0_VLAN_1Qm_SIZE 13

/*
 * This structure should be used to declare and program VLAN_1Q.
 *
 */
typedef union BCM53600_A0_VLAN_1Qm_s {
	uint32_t v[4];
	uint32_t vlan_1q[4];
	uint32_t _vlan_1q;
} BCM53600_A0_VLAN_1Qm_t;

#define BCM53600_A0_VLAN_1Qm_CLR(r) CDK_MEMSET(&((r)._vlan_1q), 0, sizeof(BCM53600_A0_VLAN_1Qm_t))
#define BCM53600_A0_VLAN_1Qm_SET(r,i,d) (r).vlan_1q[i] = d
#define BCM53600_A0_VLAN_1Qm_GET(r,i) (r).vlan_1q[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) (((r).vlan_1q[0]) & 0x1fffffff)
#define BCM53600_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_VLAN_1Qm_MSPT_IDf_GET(r) cdk_field32_get((r).vlan_1q,29,36)
#define BCM53600_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) cdk_field32_set((r).vlan_1q,29,36,f)
#define BCM53600_A0_VLAN_1Qm_DIS_LRNf_GET(r) ((((r).vlan_1q[1]) >> 5) & 0x1)
#define BCM53600_A0_VLAN_1Qm_DIS_LRNf_SET(r,f) (r).vlan_1q[1]=(((r).vlan_1q[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_VLAN_1Qm_DIR_FWDf_GET(r) ((((r).vlan_1q[1]) >> 6) & 0x1)
#define BCM53600_A0_VLAN_1Qm_DIR_FWDf_SET(r,f) (r).vlan_1q[1]=(((r).vlan_1q[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_VLAN_1Qm_ULF_DROPf_GET(r) ((((r).vlan_1q[1]) >> 7) & 0x1)
#define BCM53600_A0_VLAN_1Qm_ULF_DROPf_SET(r,f) (r).vlan_1q[1]=(((r).vlan_1q[1] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53600_A0_VLAN_1Qm_MLF_DROPf_GET(r) ((((r).vlan_1q[1]) >> 8) & 0x1)
#define BCM53600_A0_VLAN_1Qm_MLF_DROPf_SET(r,f) (r).vlan_1q[1]=(((r).vlan_1q[1] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53600_A0_VLAN_1Qm_ISO_MAPf_GET(r) ((((r).vlan_1q[1]) >> 9) & 0xf)
#define BCM53600_A0_VLAN_1Qm_ISO_MAPf_SET(r,f) (r).vlan_1q[1]=(((r).vlan_1q[1] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53600_A0_VLAN_1Qm_V_UNTAG_MAPf_GET(r) cdk_field32_get((r).vlan_1q,45,73)
#define BCM53600_A0_VLAN_1Qm_V_UNTAG_MAPf_SET(r,f) cdk_field32_set((r).vlan_1q,45,73,f)
#define BCM53600_A0_VLAN_1Qm_L2MC_BCf_GET(r) ((((r).vlan_1q[2]) >> 10) & 0xff)
#define BCM53600_A0_VLAN_1Qm_L2MC_BCf_SET(r,f) (r).vlan_1q[2]=(((r).vlan_1q[2] & ~((uint32_t)0xff << 10)) | ((((uint32_t)f) & 0xff) << 10))
#define BCM53600_A0_VLAN_1Qm_L2MC_MLFf_GET(r) ((((r).vlan_1q[2]) >> 18) & 0xff)
#define BCM53600_A0_VLAN_1Qm_L2MC_MLFf_SET(r,f) (r).vlan_1q[2]=(((r).vlan_1q[2] & ~((uint32_t)0xff << 18)) | ((((uint32_t)f) & 0xff) << 18))
#define BCM53600_A0_VLAN_1Qm_L2MC_ULFf_GET(r) cdk_field32_get((r).vlan_1q,90,97)
#define BCM53600_A0_VLAN_1Qm_L2MC_ULFf_SET(r,f) cdk_field32_set((r).vlan_1q,90,97,f)
#define BCM53600_A0_VLAN_1Qm_EN_BC_REPf_GET(r) ((((r).vlan_1q[3]) >> 2) & 0x1)
#define BCM53600_A0_VLAN_1Qm_EN_BC_REPf_SET(r,f) (r).vlan_1q[3]=(((r).vlan_1q[3] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_VLAN_1Qm_EN_MLF_REPf_GET(r) ((((r).vlan_1q[3]) >> 3) & 0x1)
#define BCM53600_A0_VLAN_1Qm_EN_MLF_REPf_SET(r,f) (r).vlan_1q[3]=(((r).vlan_1q[3] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_VLAN_1Qm_EN_ULF_REPf_GET(r) ((((r).vlan_1q[3]) >> 4) & 0x1)
#define BCM53600_A0_VLAN_1Qm_EN_ULF_REPf_SET(r,f) (r).vlan_1q[3]=(((r).vlan_1q[3] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access VLAN_1Q.
 *
 */
#define BCM53600_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_VLAN_1Qm,i,(m),13)
#define BCM53600_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_VLAN_1Qm,i,&(m),13)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM53600_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM53600_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM53600_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_CMAX(u) BCM53600_A0_VLAN_1Qm_CMAX(u)
#define VLAN_1Qm_SIZE BCM53600_A0_VLAN_1Qm_SIZE
typedef BCM53600_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM53600_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM53600_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM53600_A0_VLAN_1Qm_GET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM53600_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM53600_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM53600_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM53600_A0_VLAN_1Qm_MSPT_IDf_SET
#define VLAN_1Qm_DIS_LRNf_GET BCM53600_A0_VLAN_1Qm_DIS_LRNf_GET
#define VLAN_1Qm_DIS_LRNf_SET BCM53600_A0_VLAN_1Qm_DIS_LRNf_SET
#define VLAN_1Qm_DIR_FWDf_GET BCM53600_A0_VLAN_1Qm_DIR_FWDf_GET
#define VLAN_1Qm_DIR_FWDf_SET BCM53600_A0_VLAN_1Qm_DIR_FWDf_SET
#define VLAN_1Qm_ULF_DROPf_GET BCM53600_A0_VLAN_1Qm_ULF_DROPf_GET
#define VLAN_1Qm_ULF_DROPf_SET BCM53600_A0_VLAN_1Qm_ULF_DROPf_SET
#define VLAN_1Qm_MLF_DROPf_GET BCM53600_A0_VLAN_1Qm_MLF_DROPf_GET
#define VLAN_1Qm_MLF_DROPf_SET BCM53600_A0_VLAN_1Qm_MLF_DROPf_SET
#define VLAN_1Qm_ISO_MAPf_GET BCM53600_A0_VLAN_1Qm_ISO_MAPf_GET
#define VLAN_1Qm_ISO_MAPf_SET BCM53600_A0_VLAN_1Qm_ISO_MAPf_SET
#define VLAN_1Qm_V_UNTAG_MAPf_GET BCM53600_A0_VLAN_1Qm_V_UNTAG_MAPf_GET
#define VLAN_1Qm_V_UNTAG_MAPf_SET BCM53600_A0_VLAN_1Qm_V_UNTAG_MAPf_SET
#define VLAN_1Qm_L2MC_BCf_GET BCM53600_A0_VLAN_1Qm_L2MC_BCf_GET
#define VLAN_1Qm_L2MC_BCf_SET BCM53600_A0_VLAN_1Qm_L2MC_BCf_SET
#define VLAN_1Qm_L2MC_MLFf_GET BCM53600_A0_VLAN_1Qm_L2MC_MLFf_GET
#define VLAN_1Qm_L2MC_MLFf_SET BCM53600_A0_VLAN_1Qm_L2MC_MLFf_SET
#define VLAN_1Qm_L2MC_ULFf_GET BCM53600_A0_VLAN_1Qm_L2MC_ULFf_GET
#define VLAN_1Qm_L2MC_ULFf_SET BCM53600_A0_VLAN_1Qm_L2MC_ULFf_SET
#define VLAN_1Qm_EN_BC_REPf_GET BCM53600_A0_VLAN_1Qm_EN_BC_REPf_GET
#define VLAN_1Qm_EN_BC_REPf_SET BCM53600_A0_VLAN_1Qm_EN_BC_REPf_SET
#define VLAN_1Qm_EN_MLF_REPf_GET BCM53600_A0_VLAN_1Qm_EN_MLF_REPf_GET
#define VLAN_1Qm_EN_MLF_REPf_SET BCM53600_A0_VLAN_1Qm_EN_MLF_REPf_SET
#define VLAN_1Qm_EN_ULF_REPf_GET BCM53600_A0_VLAN_1Qm_EN_ULF_REPf_GET
#define VLAN_1Qm_EN_ULF_REPf_SET BCM53600_A0_VLAN_1Qm_EN_ULF_REPf_SET
#define READ_VLAN_1Qm BCM53600_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM53600_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_VLAN_1Qm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  VLAN_BYPASS_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN Bypass Control Registers
 * SIZE:     8
 * FIELDS:
 *     VLAN_BYPASS_L2_USER_ADDR 1 = Enable "L2 user address" frame bypass VLAN Ingress Filter andVLAN Egress Filter.
 *     VLAN_BYPASS_RSV_MCAST 1 = Enable 802.1 reserved multicast frame bypass VLAN IngressFilter and VLAN Egress Filter. Included BPDU and EAP packet
 *     RESERVED_0       Reserved
 *     VLAN_BYPASS_MCST 1 = Enable known multicast frame bypass VLAN Ingress Filter andVLAN Egress Filter.
 *     VLAN_BYPASS_MIIM 1 = Enable IMP ingress frame bypass VLAN Ingress Filter andVLAN Egress Filter.
 *     VLAN_CPUCOPY_ARP_DHCP 1 : Enable CpuCopy for ARP/DHCP frame. This CpuCopy action is notsubject to any filtering operation.ARP/DHCP frame are followed the VLAN egress filter to forwarded theframes to the defined VLAN domain and also copied to the IMP even IMPis not part of the same VLAN group.
 *     VLAN_BYPASS_IGMP_MLD 1 = Enable IGMP/MLD packet bypass VLAN Ingress Filter and VLAN Egress Filter.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_VLAN_BYPASS_CTLr 0x00003401

#define BCM53600_A0_VLAN_BYPASS_CTLr_SIZE 1

/*
 * This structure should be used to declare and program VLAN_BYPASS_CTL.
 *
 */
typedef union BCM53600_A0_VLAN_BYPASS_CTLr_s {
	uint32_t v[1];
	uint32_t vlan_bypass_ctl[1];
	uint32_t _vlan_bypass_ctl;
} BCM53600_A0_VLAN_BYPASS_CTLr_t;

#define BCM53600_A0_VLAN_BYPASS_CTLr_CLR(r) (r).vlan_bypass_ctl[0] = 0
#define BCM53600_A0_VLAN_BYPASS_CTLr_SET(r,d) (r).vlan_bypass_ctl[0] = d
#define BCM53600_A0_VLAN_BYPASS_CTLr_GET(r) (r).vlan_bypass_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_L2_USER_ADDRf_GET(r) (((r).vlan_bypass_ctl[0]) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_L2_USER_ADDRf_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_RSV_MCASTf_GET(r) ((((r).vlan_bypass_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_RSV_MCASTf_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_0f_GET(r) ((((r).vlan_bypass_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_0f_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MCSTf_GET(r) ((((r).vlan_bypass_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MCSTf_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MIIMf_GET(r) ((((r).vlan_bypass_ctl[0]) >> 4) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MIIMf_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_CPUCOPY_ARP_DHCPf_GET(r) ((((r).vlan_bypass_ctl[0]) >> 5) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_CPUCOPY_ARP_DHCPf_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_IGMP_MLDf_GET(r) ((((r).vlan_bypass_ctl[0]) >> 6) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_IGMP_MLDf_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_1f_GET(r) ((((r).vlan_bypass_ctl[0]) >> 7) & 0x1)
#define BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_1f_SET(r,f) (r).vlan_bypass_ctl[0]=(((r).vlan_bypass_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_BYPASS_CTL.
 *
 */
#define BCM53600_A0_READ_VLAN_BYPASS_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_VLAN_BYPASS_CTLr,(r._vlan_bypass_ctl),1)
#define BCM53600_A0_WRITE_VLAN_BYPASS_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_VLAN_BYPASS_CTLr,&(r._vlan_bypass_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_BYPASS_CTLr BCM53600_A0_VLAN_BYPASS_CTLr
#define VLAN_BYPASS_CTLr_SIZE BCM53600_A0_VLAN_BYPASS_CTLr_SIZE
typedef BCM53600_A0_VLAN_BYPASS_CTLr_t VLAN_BYPASS_CTLr_t;
#define VLAN_BYPASS_CTLr_CLR BCM53600_A0_VLAN_BYPASS_CTLr_CLR
#define VLAN_BYPASS_CTLr_SET BCM53600_A0_VLAN_BYPASS_CTLr_SET
#define VLAN_BYPASS_CTLr_GET BCM53600_A0_VLAN_BYPASS_CTLr_GET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_L2_USER_ADDRf_GET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_L2_USER_ADDRf_GET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_L2_USER_ADDRf_SET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_L2_USER_ADDRf_SET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_RSV_MCASTf_GET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_RSV_MCASTf_GET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_RSV_MCASTf_SET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_RSV_MCASTf_SET
#define VLAN_BYPASS_CTLr_RESERVED_0f_GET BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_0f_GET
#define VLAN_BYPASS_CTLr_RESERVED_0f_SET BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_0f_SET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_MCSTf_GET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MCSTf_GET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_MCSTf_SET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MCSTf_SET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_MIIMf_GET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MIIMf_GET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_MIIMf_SET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_MIIMf_SET
#define VLAN_BYPASS_CTLr_VLAN_CPUCOPY_ARP_DHCPf_GET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_CPUCOPY_ARP_DHCPf_GET
#define VLAN_BYPASS_CTLr_VLAN_CPUCOPY_ARP_DHCPf_SET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_CPUCOPY_ARP_DHCPf_SET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_IGMP_MLDf_GET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_IGMP_MLDf_GET
#define VLAN_BYPASS_CTLr_VLAN_BYPASS_IGMP_MLDf_SET BCM53600_A0_VLAN_BYPASS_CTLr_VLAN_BYPASS_IGMP_MLDf_SET
#define VLAN_BYPASS_CTLr_RESERVED_1f_GET BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_1f_GET
#define VLAN_BYPASS_CTLr_RESERVED_1f_SET BCM53600_A0_VLAN_BYPASS_CTLr_RESERVED_1f_SET
#define READ_VLAN_BYPASS_CTLr BCM53600_A0_READ_VLAN_BYPASS_CTLr
#define WRITE_VLAN_BYPASS_CTLr BCM53600_A0_WRITE_VLAN_BYPASS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_VLAN_BYPASS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  VLAN_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN Global Control Registers
 * SIZE:     8
 * FIELDS:
 *     VID_MAC_CTRL     VID_MAC Control. Used for ARL table lookup.1: IVL mode(MAC+VID)0: SVL mode(MAC)
 *     RESERVED_0       Reserved
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame.
 *     EN_MGE_REV_GVRP  When set to 1, management port ( the port with CPU) willbe the destination port of GVRP frame.
 *     RESERVED_1       Reserved
 *     VT_MODE          VLAN Translation Mode.00 : VT_Enable=0, V_Domain=0.01 : VT_Enable=0, V_Domain=1.10 : VT_Enalbe=1, V_Domain=0/1.11 : Reserved.
 *
 ******************************************************************************/
#define BCM53600_A0_VLAN_GLOBAL_CTLr 0x00003400

#define BCM53600_A0_VLAN_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program VLAN_GLOBAL_CTL.
 *
 */
typedef union BCM53600_A0_VLAN_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t vlan_global_ctl[1];
	uint32_t _vlan_global_ctl;
} BCM53600_A0_VLAN_GLOBAL_CTLr_t;

#define BCM53600_A0_VLAN_GLOBAL_CTLr_CLR(r) (r).vlan_global_ctl[0] = 0
#define BCM53600_A0_VLAN_GLOBAL_CTLr_SET(r,d) (r).vlan_global_ctl[0] = d
#define BCM53600_A0_VLAN_GLOBAL_CTLr_GET(r) (r).vlan_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_VLAN_GLOBAL_CTLr_VID_MAC_CTRLf_GET(r) (((r).vlan_global_ctl[0]) & 0x1)
#define BCM53600_A0_VLAN_GLOBAL_CTLr_VID_MAC_CTRLf_SET(r,f) (r).vlan_global_ctl[0]=(((r).vlan_global_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_0f_GET(r) ((((r).vlan_global_ctl[0]) >> 1) & 0x1)
#define BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_0f_SET(r,f) (r).vlan_global_ctl[0]=(((r).vlan_global_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_global_ctl[0]) >> 2) & 0x1)
#define BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_global_ctl[0]=(((r).vlan_global_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_global_ctl[0]) >> 3) & 0x1)
#define BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_global_ctl[0]=(((r).vlan_global_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_1f_GET(r) ((((r).vlan_global_ctl[0]) >> 4) & 0x3)
#define BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_1f_SET(r,f) (r).vlan_global_ctl[0]=(((r).vlan_global_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53600_A0_VLAN_GLOBAL_CTLr_VT_MODEf_GET(r) ((((r).vlan_global_ctl[0]) >> 6) & 0x3)
#define BCM53600_A0_VLAN_GLOBAL_CTLr_VT_MODEf_SET(r,f) (r).vlan_global_ctl[0]=(((r).vlan_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_GLOBAL_CTL.
 *
 */
#define BCM53600_A0_READ_VLAN_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_VLAN_GLOBAL_CTLr,(r._vlan_global_ctl),1)
#define BCM53600_A0_WRITE_VLAN_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_VLAN_GLOBAL_CTLr,&(r._vlan_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_GLOBAL_CTLr BCM53600_A0_VLAN_GLOBAL_CTLr
#define VLAN_GLOBAL_CTLr_SIZE BCM53600_A0_VLAN_GLOBAL_CTLr_SIZE
typedef BCM53600_A0_VLAN_GLOBAL_CTLr_t VLAN_GLOBAL_CTLr_t;
#define VLAN_GLOBAL_CTLr_CLR BCM53600_A0_VLAN_GLOBAL_CTLr_CLR
#define VLAN_GLOBAL_CTLr_SET BCM53600_A0_VLAN_GLOBAL_CTLr_SET
#define VLAN_GLOBAL_CTLr_GET BCM53600_A0_VLAN_GLOBAL_CTLr_GET
#define VLAN_GLOBAL_CTLr_VID_MAC_CTRLf_GET BCM53600_A0_VLAN_GLOBAL_CTLr_VID_MAC_CTRLf_GET
#define VLAN_GLOBAL_CTLr_VID_MAC_CTRLf_SET BCM53600_A0_VLAN_GLOBAL_CTLr_VID_MAC_CTRLf_SET
#define VLAN_GLOBAL_CTLr_RESERVED_0f_GET BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_0f_GET
#define VLAN_GLOBAL_CTLr_RESERVED_0f_SET BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_0f_SET
#define VLAN_GLOBAL_CTLr_EN_MGE_REV_GMRPf_GET BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GMRPf_GET
#define VLAN_GLOBAL_CTLr_EN_MGE_REV_GMRPf_SET BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GMRPf_SET
#define VLAN_GLOBAL_CTLr_EN_MGE_REV_GVRPf_GET BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GVRPf_GET
#define VLAN_GLOBAL_CTLr_EN_MGE_REV_GVRPf_SET BCM53600_A0_VLAN_GLOBAL_CTLr_EN_MGE_REV_GVRPf_SET
#define VLAN_GLOBAL_CTLr_RESERVED_1f_GET BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_1f_GET
#define VLAN_GLOBAL_CTLr_RESERVED_1f_SET BCM53600_A0_VLAN_GLOBAL_CTLr_RESERVED_1f_SET
#define VLAN_GLOBAL_CTLr_VT_MODEf_GET BCM53600_A0_VLAN_GLOBAL_CTLr_VT_MODEf_GET
#define VLAN_GLOBAL_CTLr_VT_MODEf_SET BCM53600_A0_VLAN_GLOBAL_CTLr_VT_MODEf_SET
#define READ_VLAN_GLOBAL_CTLr BCM53600_A0_READ_VLAN_GLOBAL_CTLr
#define WRITE_VLAN_GLOBAL_CTLr BCM53600_A0_WRITE_VLAN_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_VLAN_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * MEMORY:  VPORT_VID_MAP
 * BLOCKS:   SYS
 * DESC:     VPORT_VID_MAP Table
 * SIZE:     208
 * FIELDS:
 *     VPORT_VID_0      Virtual Port 0 VID
 *     VPORT_VID_1      Virtual Port 1 VID
 *     VPORT_VID_2      Virtual Port 2 VID
 *     VPORT_VID_3      Virtual Port 3 VID
 *     VPORT_VID_4      Virtual Port 4 VID
 *     VPORT_VID_5      Virtual Port 5 VID
 *     VPORT_VID_6      Virtual Port 6 VID
 *     VPORT_VID_7      Virtual Port 7 VID
 *     VPORT_VID_8      Virtual Port 8 VID
 *     VPORT_VID_9      Virtual Port 9 VID
 *     VPORT_VID_10     Virtual Port 10 VID
 *     VPORT_VID_11     Virtual Port 11 VID
 *     VPORT_VID_12     Virtual Port 12 VID
 *     VPORT_VID_13     Virtual Port 13 VID
 *     VPORT_VID_14     Virtual Port 14 VID
 *     VPORT_VID_15     Virtual Port 15 VID
 *     VPORT_UNTAG      UNTAG[15:0]
 *
 ******************************************************************************/
#define BCM53600_A0_VPORT_VID_MAPm 0x00000000

#define BCM53600_A0_VPORT_VID_MAPm_MIN 0
#define BCM53600_A0_VPORT_VID_MAPm_MAX 28
#define BCM53600_A0_VPORT_VID_MAPm_CMAX(u) 28
#define BCM53600_A0_VPORT_VID_MAPm_SIZE 26

/*
 * This structure should be used to declare and program VPORT_VID_MAP.
 *
 */
typedef union BCM53600_A0_VPORT_VID_MAPm_s {
	uint32_t v[7];
	uint32_t vport_vid_map[7];
	uint32_t _vport_vid_map;
} BCM53600_A0_VPORT_VID_MAPm_t;

#define BCM53600_A0_VPORT_VID_MAPm_CLR(r) CDK_MEMSET(&((r)._vport_vid_map), 0, sizeof(BCM53600_A0_VPORT_VID_MAPm_t))
#define BCM53600_A0_VPORT_VID_MAPm_SET(r,i,d) (r).vport_vid_map[i] = d
#define BCM53600_A0_VPORT_VID_MAPm_GET(r,i) (r).vport_vid_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_0f_GET(r) (((r).vport_vid_map[0]) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_0f_SET(r,f) (r).vport_vid_map[0]=(((r).vport_vid_map[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_1f_GET(r) ((((r).vport_vid_map[0]) >> 12) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_1f_SET(r,f) (r).vport_vid_map[0]=(((r).vport_vid_map[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_2f_GET(r) cdk_field32_get((r).vport_vid_map,24,35)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_2f_SET(r,f) cdk_field32_set((r).vport_vid_map,24,35,f)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_3f_GET(r) ((((r).vport_vid_map[1]) >> 4) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_3f_SET(r,f) (r).vport_vid_map[1]=(((r).vport_vid_map[1] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_4f_GET(r) ((((r).vport_vid_map[1]) >> 16) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_4f_SET(r,f) (r).vport_vid_map[1]=(((r).vport_vid_map[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_5f_GET(r) cdk_field32_get((r).vport_vid_map,60,71)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_5f_SET(r,f) cdk_field32_set((r).vport_vid_map,60,71,f)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_6f_GET(r) ((((r).vport_vid_map[2]) >> 8) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_6f_SET(r,f) (r).vport_vid_map[2]=(((r).vport_vid_map[2] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_7f_GET(r) ((((r).vport_vid_map[2]) >> 20) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_7f_SET(r,f) (r).vport_vid_map[2]=(((r).vport_vid_map[2] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_8f_GET(r) (((r).vport_vid_map[3]) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_8f_SET(r,f) (r).vport_vid_map[3]=(((r).vport_vid_map[3] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_9f_GET(r) ((((r).vport_vid_map[3]) >> 12) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_9f_SET(r,f) (r).vport_vid_map[3]=(((r).vport_vid_map[3] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_10f_GET(r) cdk_field32_get((r).vport_vid_map,120,131)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_10f_SET(r,f) cdk_field32_set((r).vport_vid_map,120,131,f)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_11f_GET(r) ((((r).vport_vid_map[4]) >> 4) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_11f_SET(r,f) (r).vport_vid_map[4]=(((r).vport_vid_map[4] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_12f_GET(r) ((((r).vport_vid_map[4]) >> 16) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_12f_SET(r,f) (r).vport_vid_map[4]=(((r).vport_vid_map[4] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_13f_GET(r) cdk_field32_get((r).vport_vid_map,156,167)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_13f_SET(r,f) cdk_field32_set((r).vport_vid_map,156,167,f)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_14f_GET(r) ((((r).vport_vid_map[5]) >> 8) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_14f_SET(r,f) (r).vport_vid_map[5]=(((r).vport_vid_map[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_15f_GET(r) ((((r).vport_vid_map[5]) >> 20) & 0xfff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_15f_SET(r,f) (r).vport_vid_map[5]=(((r).vport_vid_map[5] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_UNTAGf_GET(r) (((r).vport_vid_map[6]) & 0xffff)
#define BCM53600_A0_VPORT_VID_MAPm_VPORT_UNTAGf_SET(r,f) (r).vport_vid_map[6]=(((r).vport_vid_map[6] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VPORT_VID_MAP.
 *
 */
#define BCM53600_A0_READ_VPORT_VID_MAPm(u,i,m) cdk_robo_mem_read(u,BCM53600_A0_VPORT_VID_MAPm,i,(m),26)
#define BCM53600_A0_WRITE_VPORT_VID_MAPm(u,i,m) cdk_robo_mem_write(u,BCM53600_A0_VPORT_VID_MAPm,i,&(m),26)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VPORT_VID_MAPm BCM53600_A0_VPORT_VID_MAPm
#define VPORT_VID_MAPm_MIN BCM53600_A0_VPORT_VID_MAPm_MIN
#define VPORT_VID_MAPm_MAX BCM53600_A0_VPORT_VID_MAPm_MAX
#define VPORT_VID_MAPm_CMAX(u) BCM53600_A0_VPORT_VID_MAPm_CMAX(u)
#define VPORT_VID_MAPm_SIZE BCM53600_A0_VPORT_VID_MAPm_SIZE
typedef BCM53600_A0_VPORT_VID_MAPm_t VPORT_VID_MAPm_t;
#define VPORT_VID_MAPm_CLR BCM53600_A0_VPORT_VID_MAPm_CLR
#define VPORT_VID_MAPm_SET BCM53600_A0_VPORT_VID_MAPm_SET
#define VPORT_VID_MAPm_GET BCM53600_A0_VPORT_VID_MAPm_GET
#define VPORT_VID_MAPm_VPORT_VID_0f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_0f_GET
#define VPORT_VID_MAPm_VPORT_VID_0f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_0f_SET
#define VPORT_VID_MAPm_VPORT_VID_1f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_1f_GET
#define VPORT_VID_MAPm_VPORT_VID_1f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_1f_SET
#define VPORT_VID_MAPm_VPORT_VID_2f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_2f_GET
#define VPORT_VID_MAPm_VPORT_VID_2f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_2f_SET
#define VPORT_VID_MAPm_VPORT_VID_3f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_3f_GET
#define VPORT_VID_MAPm_VPORT_VID_3f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_3f_SET
#define VPORT_VID_MAPm_VPORT_VID_4f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_4f_GET
#define VPORT_VID_MAPm_VPORT_VID_4f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_4f_SET
#define VPORT_VID_MAPm_VPORT_VID_5f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_5f_GET
#define VPORT_VID_MAPm_VPORT_VID_5f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_5f_SET
#define VPORT_VID_MAPm_VPORT_VID_6f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_6f_GET
#define VPORT_VID_MAPm_VPORT_VID_6f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_6f_SET
#define VPORT_VID_MAPm_VPORT_VID_7f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_7f_GET
#define VPORT_VID_MAPm_VPORT_VID_7f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_7f_SET
#define VPORT_VID_MAPm_VPORT_VID_8f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_8f_GET
#define VPORT_VID_MAPm_VPORT_VID_8f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_8f_SET
#define VPORT_VID_MAPm_VPORT_VID_9f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_9f_GET
#define VPORT_VID_MAPm_VPORT_VID_9f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_9f_SET
#define VPORT_VID_MAPm_VPORT_VID_10f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_10f_GET
#define VPORT_VID_MAPm_VPORT_VID_10f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_10f_SET
#define VPORT_VID_MAPm_VPORT_VID_11f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_11f_GET
#define VPORT_VID_MAPm_VPORT_VID_11f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_11f_SET
#define VPORT_VID_MAPm_VPORT_VID_12f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_12f_GET
#define VPORT_VID_MAPm_VPORT_VID_12f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_12f_SET
#define VPORT_VID_MAPm_VPORT_VID_13f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_13f_GET
#define VPORT_VID_MAPm_VPORT_VID_13f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_13f_SET
#define VPORT_VID_MAPm_VPORT_VID_14f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_14f_GET
#define VPORT_VID_MAPm_VPORT_VID_14f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_14f_SET
#define VPORT_VID_MAPm_VPORT_VID_15f_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_15f_GET
#define VPORT_VID_MAPm_VPORT_VID_15f_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_VID_15f_SET
#define VPORT_VID_MAPm_VPORT_UNTAGf_GET BCM53600_A0_VPORT_VID_MAPm_VPORT_UNTAGf_GET
#define VPORT_VID_MAPm_VPORT_UNTAGf_SET BCM53600_A0_VPORT_VID_MAPm_VPORT_UNTAGf_SET
#define READ_VPORT_VID_MAPm BCM53600_A0_READ_VPORT_VID_MAPm
#define WRITE_VPORT_VID_MAPm BCM53600_A0_WRITE_VPORT_VID_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_VPORT_VID_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  XOFF_PORT_HISTORY
 * BLOCKS:   SYS
 * DESC:     XOFF Port History Register(Not2Release)
 * SIZE:     32
 * FIELDS:
 *     XOFF_HISTORY     Flow control triggering status.bit28-0 for port28-port01:Flow control has been triggered in this port.0:No flow control has been triggered in this port.(Read and Clear)(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53600_A0_XOFF_PORT_HISTORYr 0x00000aea

#define BCM53600_A0_XOFF_PORT_HISTORYr_SIZE 4

/*
 * This structure should be used to declare and program XOFF_PORT_HISTORY.
 *
 */
typedef union BCM53600_A0_XOFF_PORT_HISTORYr_s {
	uint32_t v[1];
	uint32_t xoff_port_history[1];
	uint32_t _xoff_port_history;
} BCM53600_A0_XOFF_PORT_HISTORYr_t;

#define BCM53600_A0_XOFF_PORT_HISTORYr_CLR(r) (r).xoff_port_history[0] = 0
#define BCM53600_A0_XOFF_PORT_HISTORYr_SET(r,d) (r).xoff_port_history[0] = d
#define BCM53600_A0_XOFF_PORT_HISTORYr_GET(r) (r).xoff_port_history[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_XOFF_PORT_HISTORYr_XOFF_HISTORYf_GET(r) (((r).xoff_port_history[0]) & 0x1fffffff)
#define BCM53600_A0_XOFF_PORT_HISTORYr_XOFF_HISTORYf_SET(r,f) (r).xoff_port_history[0]=(((r).xoff_port_history[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_XOFF_PORT_HISTORYr_RESERVEDf_GET(r) ((((r).xoff_port_history[0]) >> 29) & 0x7)
#define BCM53600_A0_XOFF_PORT_HISTORYr_RESERVEDf_SET(r,f) (r).xoff_port_history[0]=(((r).xoff_port_history[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access XOFF_PORT_HISTORY.
 *
 */
#define BCM53600_A0_READ_XOFF_PORT_HISTORYr(u,r) cdk_robo_reg_read(u,BCM53600_A0_XOFF_PORT_HISTORYr,(r._xoff_port_history),4)
#define BCM53600_A0_WRITE_XOFF_PORT_HISTORYr(u,r) cdk_robo_reg_write(u,BCM53600_A0_XOFF_PORT_HISTORYr,&(r._xoff_port_history),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XOFF_PORT_HISTORYr BCM53600_A0_XOFF_PORT_HISTORYr
#define XOFF_PORT_HISTORYr_SIZE BCM53600_A0_XOFF_PORT_HISTORYr_SIZE
typedef BCM53600_A0_XOFF_PORT_HISTORYr_t XOFF_PORT_HISTORYr_t;
#define XOFF_PORT_HISTORYr_CLR BCM53600_A0_XOFF_PORT_HISTORYr_CLR
#define XOFF_PORT_HISTORYr_SET BCM53600_A0_XOFF_PORT_HISTORYr_SET
#define XOFF_PORT_HISTORYr_GET BCM53600_A0_XOFF_PORT_HISTORYr_GET
#define XOFF_PORT_HISTORYr_XOFF_HISTORYf_GET BCM53600_A0_XOFF_PORT_HISTORYr_XOFF_HISTORYf_GET
#define XOFF_PORT_HISTORYr_XOFF_HISTORYf_SET BCM53600_A0_XOFF_PORT_HISTORYr_XOFF_HISTORYf_SET
#define XOFF_PORT_HISTORYr_RESERVEDf_GET BCM53600_A0_XOFF_PORT_HISTORYr_RESERVEDf_GET
#define XOFF_PORT_HISTORYr_RESERVEDf_SET BCM53600_A0_XOFF_PORT_HISTORYr_RESERVEDf_SET
#define READ_XOFF_PORT_HISTORYr BCM53600_A0_READ_XOFF_PORT_HISTORYr
#define WRITE_XOFF_PORT_HISTORYr BCM53600_A0_WRITE_XOFF_PORT_HISTORYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_XOFF_PORT_HISTORYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53600_A0
 * REGISTER:  XOFF_TRIG_PORT_CTRL
 * BLOCKS:   SYS
 * DESC:     XOFF Trigger Port Control Register
 * SIZE:     32
 * FIELDS:
 *     EN_XOFF_TRIGGER  Enable the corresponding egress port to allow such the flow control triggering.bit 28-0 for port 28 - port 01 : enable0 : disable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr 0x00000a08

#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program XOFF_TRIG_PORT_CTRL.
 *
 */
typedef union BCM53600_A0_XOFF_TRIG_PORT_CTRLr_s {
	uint32_t v[1];
	uint32_t xoff_trig_port_ctrl[1];
	uint32_t _xoff_trig_port_ctrl;
} BCM53600_A0_XOFF_TRIG_PORT_CTRLr_t;

#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_CLR(r) (r).xoff_trig_port_ctrl[0] = 0
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_SET(r,d) (r).xoff_trig_port_ctrl[0] = d
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_GET(r) (r).xoff_trig_port_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_EN_XOFF_TRIGGERf_GET(r) (((r).xoff_trig_port_ctrl[0]) & 0x1fffffff)
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_EN_XOFF_TRIGGERf_SET(r,f) (r).xoff_trig_port_ctrl[0]=(((r).xoff_trig_port_ctrl[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_RESERVEDf_GET(r) ((((r).xoff_trig_port_ctrl[0]) >> 29) & 0x7)
#define BCM53600_A0_XOFF_TRIG_PORT_CTRLr_RESERVEDf_SET(r,f) (r).xoff_trig_port_ctrl[0]=(((r).xoff_trig_port_ctrl[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access XOFF_TRIG_PORT_CTRL.
 *
 */
#define BCM53600_A0_READ_XOFF_TRIG_PORT_CTRLr(u,r) cdk_robo_reg_read(u,BCM53600_A0_XOFF_TRIG_PORT_CTRLr,(r._xoff_trig_port_ctrl),4)
#define BCM53600_A0_WRITE_XOFF_TRIG_PORT_CTRLr(u,r) cdk_robo_reg_write(u,BCM53600_A0_XOFF_TRIG_PORT_CTRLr,&(r._xoff_trig_port_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XOFF_TRIG_PORT_CTRLr BCM53600_A0_XOFF_TRIG_PORT_CTRLr
#define XOFF_TRIG_PORT_CTRLr_SIZE BCM53600_A0_XOFF_TRIG_PORT_CTRLr_SIZE
typedef BCM53600_A0_XOFF_TRIG_PORT_CTRLr_t XOFF_TRIG_PORT_CTRLr_t;
#define XOFF_TRIG_PORT_CTRLr_CLR BCM53600_A0_XOFF_TRIG_PORT_CTRLr_CLR
#define XOFF_TRIG_PORT_CTRLr_SET BCM53600_A0_XOFF_TRIG_PORT_CTRLr_SET
#define XOFF_TRIG_PORT_CTRLr_GET BCM53600_A0_XOFF_TRIG_PORT_CTRLr_GET
#define XOFF_TRIG_PORT_CTRLr_EN_XOFF_TRIGGERf_GET BCM53600_A0_XOFF_TRIG_PORT_CTRLr_EN_XOFF_TRIGGERf_GET
#define XOFF_TRIG_PORT_CTRLr_EN_XOFF_TRIGGERf_SET BCM53600_A0_XOFF_TRIG_PORT_CTRLr_EN_XOFF_TRIGGERf_SET
#define XOFF_TRIG_PORT_CTRLr_RESERVEDf_GET BCM53600_A0_XOFF_TRIG_PORT_CTRLr_RESERVEDf_GET
#define XOFF_TRIG_PORT_CTRLr_RESERVEDf_SET BCM53600_A0_XOFF_TRIG_PORT_CTRLr_RESERVEDf_SET
#define READ_XOFF_TRIG_PORT_CTRLr BCM53600_A0_READ_XOFF_TRIG_PORT_CTRLr
#define WRITE_XOFF_TRIG_PORT_CTRLr BCM53600_A0_WRITE_XOFF_TRIG_PORT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53600_A0_XOFF_TRIG_PORT_CTRLr'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM53600_A0_DEFS_H__ */
